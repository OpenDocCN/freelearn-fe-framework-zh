- en: '*Chapter 2*: Setting Up GraphQL with Express.js'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic setup and prototype for our frontend are now complete. Now, we need
    to get our GraphQL server running to begin implementing the backend. Apollo and
    Express.js are going to be used to build the foundation of our backend.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explain the installation process for Express.js, as well as
    the configuration for our GraphQL endpoint. We will quickly go through all the
    essential features of Express.js and the debugging tools for our backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Express.js installation and explanation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing in Express.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Middleware in Express.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding Apollo Server to a GraphQL endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending our first GraphQL requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backend debugging and logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available in the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter02)'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Node.js and Express.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the primary goals of this book is to set up a GraphQL API, which is then
    consumed by our React frontend. To accept network requests – especially GraphQL
    requests – we are going to set up a Node.js web server.
  prefs: []
  type: TYPE_NORMAL
- en: The most significant competitors in the Node.js web server area are Express.js,
    Koa, and Hapi. In this book, we are going to use Express.js. Most tutorials and
    articles about Apollo rely on it.
  prefs: []
  type: TYPE_NORMAL
- en: Express.js is also the most used Node.js web server out there and describes
    itself as a Node.js web framework, offering all the main features needed to build
    web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing Express.js is easy. We can use `npm` in the same way as we did in
    the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This command adds the latest version of Express to `package.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we created all the JavaScript files directly in the
    `src/client` folder. Now, let''s create a separate folder for our server-side
    code. This separation gives us a tidy directory structure. We can create this
    folder with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can continue configuring Express.js.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Express.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As always, we need a root file that's loaded with all the main components to
    combine them into a real application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `index.js` file in the `server` folder. This file is the starting
    point for the backend. Here''s how we do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must import `express` from `node_modules`, which we just installed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can use `import` here since our backend gets transpiled by Babel. We are
    also going to set up webpack for the server-side code later in [*Chapter 9*](B17337_09_Final_ASB_ePub.xhtml#_idTextAnchor176),
    *Implementing Server-Side Rendering*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we must initialize the server with the `express` command. The result
    is stored in the `app` variable. Everything our backend does is executed through
    this object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we must specify the routes that accept requests. For this straightforward
    introduction, we accept all HTTP `GET` requests that match any path by using the
    `app.get` method. Other HTTP methods can be caught with `app.post` and `app.put`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To match all the paths, you can use an asterisk, which generally stands for
    `any` in the programming field, as we did in the preceding `app.get` line.
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter for all the `app.METHOD` functions is the path to match.
    From here, you can provide an unlimited list of callback functions, which are
    executed one by one. We are going to look at this feature later in the *Routing
    with Express.js* section.
  prefs: []
  type: TYPE_NORMAL
- en: A callback always receives the client request as the first parameter and the
    response as the second parameter, which the server is going to send. Our first
    callback is going to use the `send` response method.
  prefs: []
  type: TYPE_NORMAL
- en: The `send` function merely sends the HTTP response. It sets the HTTP body as
    specified. So, in our case, the body shows `Hello World!`, while the `send` function
    takes care of all the necessary standard HTTP headers, such as `Content-Length`.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to tell Express.js which port the server should listen for
    requests on. In our code, we are using `8000` as the first parameter of `app.listen`.
    You can replace `8000` with any port or URL you want to listen on. The callback
    is executed when the HTTP server is bound to that port and requests can be accepted.
  prefs: []
  type: TYPE_NORMAL
- en: This is the easiest setup we can have for Express.js.
  prefs: []
  type: TYPE_NORMAL
- en: Running Express.js in development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To launch our server, we have to add a new script to our `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the following line to the `scripts` property of the `package.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are using a command called `nodemon`. We need to install
    it first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`nodemon` is an excellent tool for running a Node.js application. It can restart
    your server when the source changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to get the preceding command working, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must install the `@babel/node` package since we are transpiling the
    backend code with Babel using the `--exec babel-node` option. This allows us to
    use the `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Providing the `--watch` option to `nodemon` when following a path or file will
    permanently track the changes on that file or folder and reload the server to
    represent the latest state of your application. The last parameter refers to the
    actual file being the starting execution point for the backend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, when you go to your browser and enter `http://localhost:8000`, you will
    see the text **Hello World!** from our Express.js callback function.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054), *Connecting
    to the Database*, covers how Express.js routing works in detail.'
  prefs: []
  type: TYPE_NORMAL
- en: Routing in Express.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding routing is essential to extending our backend code. In this section,
    we are going to play through some simple routing examples.
  prefs: []
  type: TYPE_NORMAL
- en: In general, routing handles how and where an application responds to specific
    endpoints and methods.
  prefs: []
  type: TYPE_NORMAL
- en: In Express.js, one path can respond to different HTTP methods and can have multiple
    handler functions. These handler functions are executed one by one in the order
    they were specified in the code. A path can be a simple string, but also a complex
    regular expression or pattern.
  prefs: []
  type: TYPE_NORMAL
- en: When you're using multiple handler functions – either provided as an array or
    as multiple parameters – be sure to pass `next` to every callback function. When
    you call `next`, you hand over the execution from one callback function to the
    next function in the row. These functions can also be middleware. We'll cover
    this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example. Replace this with the current `app.get` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When you refresh your browser, look at the server logs in the Terminal; you
    will see that both `first function` and `second function` are printed. If you
    remove the execution of `next` and try to reload the browser tab, the request
    will time out and only `first function` will be printed. This problem occurs because
    neither `res.send` nor `res.end`, nor any alternative, is called. The second handler
    function is never executed when `next` is not run.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, the **Hello World!** message is nice but not the
    best we can get. In development, it is completely okay for us to run two separate
    servers – one for the frontend and one for the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Serving our production build
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can serve our production build of the frontend through Express.js. This approach
    is not great for development purposes but is useful for testing the build process
    and seeing how our live application will act.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, replace the previous routing example with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `path` module offers many functionalities for working with the directory
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: We use the global `__dirname` variable to get our project's root directory.
    The variable holds the path of the current file. Using `path.join` with `../../`
    and `__dirname` gives us the real root of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Express.js provides the `use` function, which runs a series of commands when
    a given path matches. When executing this function without a path, it is executed
    for every request.
  prefs: []
  type: TYPE_NORMAL
- en: We use this feature to serve our static files (the avatar images) with `express.static`.
    They include `bundle.js` and `bundle.css`, which are created by `npm run client:build`.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, first, we pass `'/'` with `express.static` following it. The result
    of this is that all the files and folders in `dist` are served beginning with
    `'/'`. The other paths in the first parameter of `app.use`, such as `'/example'`,
    would lead to our `bundle.js` file being able to be downloaded under `'/example/bundle.js'`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: For example, all the avatar images are served under `'/uploads/'`.
  prefs: []
  type: TYPE_NORMAL
- en: We are now prepared to let the client download all the necessary files. The
    initial route for our client is `'/'`, as specified by `app.get`. The response
    to this path is `index.html`. We run `res.sendFile` and the file path to return
    this file – that is all we have to do here.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to execute `npm run client:build` first. Otherwise, you will receive
    an error message, stating that these files were not found. Furthermore, when running
    `npm run client`, the `dist` folder is deleted, so you must rerun the build process.
  prefs: []
  type: TYPE_NORMAL
- en: Refreshing your browser now will present you with the *post* feed and form from
    [*Chapter 1*](B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017), *Preparing Your
    Development Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: The next section focuses on the great functionality of middleware functions
    in Express.js.
  prefs: []
  type: TYPE_NORMAL
- en: Using Express.js middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express.js provides us with great ways to write efficient backends without duplicating
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Every middleware function receives a request, a response, and `next`. It needs
    to run `next` to pass control to the next handler function. Otherwise, you will
    receive a timeout. Middleware allows us to pre- or post-process the request or
    response object, execute custom code, and much more. Previously, we covered a
    simple example of handling requests in Express.js.
  prefs: []
  type: TYPE_NORMAL
- en: Express.js can have multiple routes for the same path and HTTP method. The middleware
    can decide which function should be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an easy example that shows what can generally be accomplished
    with Express.js. You can test this by replacing the current `app.get` routes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The root path, `''/''`, is used to catch any requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we will randomly generate a number with `Math.random` between 1 and 10:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the number is higher than `5`, we run the `next(''route'')` function to
    skip to the next `app.get` with the same path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This route will log `'second'`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the number is lower than `0.5`, we execute the `next` function without any
    parameters and go to the next handler function. This handler will log `''first''`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You do not need to copy this code as it is just an explanatory example. This
    functionality can come in handy when we cover special treatments such as admin
    users and error handling.
  prefs: []
  type: TYPE_NORMAL
- en: Installing important middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our application, we have already used one built-in Express.js middleware:
    `express.static`. Throughout this book, we will continue to install other pieces
    of middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the `import` statement for the new packages inside the server''s `index.js`
    file so that all the dependencies are available within the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let's see what these packages do and how we can use them.
  prefs: []
  type: TYPE_NORMAL
- en: Express Helmet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Helmet is a tool that allows you to set various HTTP headers to secure your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can enable the Express.js Helmet middleware as follows in the server''s
    `index.js` file. Add the following code snippet directly beneath the `app` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We are doing multiple things here at once. In the preceding code, we added some
    `X-Powered-By` HTTP header, as well as some other useful things, just by using
    the `helmet()` function in the first line.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can look up the default parameters, as well as the other functionalities
    of Helmet, at [https://github.com/helmetjs/helmet](https://github.com/helmetjs/helmet).
    Always be conscious when implementing security features and do your best to verify
    your attack protection methods.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, to ensure that no one can inject malicious code, we used the `Content-Security-Policy`
    HTTP header or CSP for short. This header prevents attackers from loading resources
    from external URLs.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we also specified the `imgSrc` field, which tells our client
    that only images from these URLs should be loaded, including **Amazon Web Services**
    (**AWS**). We will learn how to upload images to it in [*Chapter 7*](B17337_07_Final_ASB_ePub.xhtml#_idTextAnchor154),
    *Handling Image Uploads*.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about CSP and how it can make your platform more secure at
    [https://helmetjs.github.io/docs/csp/](https://helmetjs.github.io/docs/csp/).
  prefs: []
  type: TYPE_NORMAL
- en: The last enhancement is to set the `Referrer` HTTP header, but only when making
    requests on the same host. When we're going from domain A to domain B, for example,
    we do not include the referrer, which is the URL the user is coming from. This
    enhancement stops any internal routing or requests from being exposed to the internet.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to initialize Helmet very high in your Express router so that
    all the responses are affected.
  prefs: []
  type: TYPE_NORMAL
- en: Compression with Express.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enabling compression for Express.js saves you and your user bandwidth, and
    this is easy to do. The following code must also be added to the server''s `index.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This middleware compresses all the responses going through it. Remember to add
    it very high in your routing order so that all the requests are affected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you have middleware like this or multiple routes that match the same
    path, you need to check the initialization order. Only the first matching route
    is executed unless you run the `next` command. All the routes that are defined
    afterward will not be executed.
  prefs: []
  type: TYPE_NORMAL
- en: CORS in Express.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want our GraphQL API to be accessible from any website, app, or system. A
    good idea might be to build an app or offer the API to other companies or developers
    so that they can use it. When you're using APIs via Ajax, the main problem is
    that the API needs to send the correct `Access-Control-Allow-Origin` header.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you build the API, publicize it under `https://api.example.com`,
    and try to access it from `https://example.com` without setting the correct header,
    it won't work. The API would need to set at least `example.com` inside the `Access-Control-Allow-Origin`
    header to allow this domain to access its resources. This seems a bit tedious,
    but it makes your API open to cross-site requests, which you should always be
    aware of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Allow `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This command handles all the problems we usually have with cross-origin requests
    at once. It merely sets a wildcard with `*` inside of `Access-Control-Allow-Origin`,
    allowing anyone from anywhere to use your API, at least in the first instance.
    You can always secure your API by offering API keys or by only allowing access
    to logged-in users. Enabling CORS only allows the requesting site to receive the
    response.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the command also implements the `OPTIONS` route for the whole application.
  prefs: []
  type: TYPE_NORMAL
- en: The `OPTIONS` method or request is made every time we use `CORS`. This action
    is what's called a `OPTIONS` preflight, the actual method, such as `POST`, will
    not be made by the browser at all.
  prefs: []
  type: TYPE_NORMAL
- en: Our application is now ready to serve all the routes appropriately and respond
    with the right headers.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's set up a GraphQL server.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Express.js with Apollo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First things first; we need to install the Apollo and GraphQL dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Apollo offers an Express.js-specific package that integrates itself into the
    web server. There is also a standalone version without Express.js. Apollo allows
    you to use the available Express.js middleware. In some scenarios, you may need
    to offer non-GraphQL routes to proprietary clients who do not implement GraphQL
    or are not able to understand JSON responses. There are still reasons to offer
    some fallbacks to GraphQL. In those cases, you can rely on Express.js since you
    are already using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a separate folder for services. A service can be GraphQL or other routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `index.js` file in the `graphql` folder to act as the start point
    for our GraphQL service. It must handle multiple things for initialization. Let''s
    go through all of them one by one and add them to the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must import the `apollo-server-express` and `@graphql-tools/schema`
    packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must combine the GraphQL schema with the `resolver` functions. We
    must import the corresponding schema and resolver functions at the top from separate
    files. The GraphQL schema is the representation of the API – that is, the data
    and functions a client can request or run. Resolver functions are the implementation
    of the schema. Both need to match. You cannot return a field or run a mutation
    that is not inside the schema:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `makeExecutableSchema` function of the `@graphql-tools/schema` package
    merges the GraphQL schema and the resolver functions, resolving the data we are
    going to write. The `makeExecutableSchema` function throws an error when you define
    a query or mutation that is not in the schema. The resulting schema is executed
    by our GraphQL server resolving the data or running the mutations we request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We pass this as a `schema` parameter to the Apollo Server. The `context` property
    contains the `request` object of Express.js. In our resolver functions, we can
    access the request if we need to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This `index.js` file exports the initialized server object, which handles all
    GraphQL requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we are exporting the Apollo Server, it needs to be imported somewhere
    else. I find it convenient to have one `index.js` file on the services layer so
    that we only rely on this file if a new service is added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `index.js` file in the `services` folder and enter the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code requires our `index.js` file from the `graphql` folder and
    re-exports all the services into one big object. We can define more services here
    if we need them.
  prefs: []
  type: TYPE_NORMAL
- en: To make our GraphQL server publicly accessible to our clients, we are going
    to bind the Apollo Server to the `/graphql` path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the services `index.js` file into the `server/index.js` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `services` object only holds the `graphql` index. Now, we must bind the
    GraphQL server to the Express.js web server with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: For convenience, we loop through all indexes of the `services` object and use
    the index as the name of the route the service will be bound to. The path would
    be `/example` for the `example` index in the `services` object. For a typical
    service, such as a REST interface, we rely on the standard `app.use` method of
    Express.js.
  prefs: []
  type: TYPE_NORMAL
- en: Since the Apollo Server is kind of special, when binding it to Express.js, we
    need to run the `applyMiddleware` function, which is provided by the initialized
    Apollo Server, and avoid using the `app.use` function from Express.js. Apollo
    automatically binds itself to the `/graphql` path because it is the default option.
    You could also include a `path` parameter if you want it to respond from a custom
    route.
  prefs: []
  type: TYPE_NORMAL
- en: The Apollo Server requires us to run the `start` command before applying the
    middleware. As this is an asynchronous function, we are wrapping the complete
    block into a wrapping `async` function so that we can use the `await` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two things are missing now: the schema and the resolvers. Once we''ve done
    that, we will execute some test GraphQL requests. The schema is next on our to-do
    list.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first GraphQL schemas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by creating a `schema.js` inside the `graphql` folder. You can
    also stitch multiple smaller schemas into one bigger schema. This would be cleaner
    and would make sense when your application, types, and fields grow. For this book,
    one file is okay and we can insert the following code into the `schema.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code represents a basic schema, which would be able to at least
    serve the fake posts array from [*Chapter 1*](B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017),
    *Preparing Your Development Environment*, excluding the users.
  prefs: []
  type: TYPE_NORMAL
- en: First, we must define a new type called `Post`. A `Post` type has an `id` of
    `Int` and a `text` value of `String`.
  prefs: []
  type: TYPE_NORMAL
- en: For our GraphQL server, we need a type called `RootQuery`. The `RootQuery` type
    wraps all of the queries a client can run. It can be anything from requesting
    all posts, all users, posts by just one user, and so on. You can compare this
    to all `GET` requests as you find them with common REST APIs. The paths would
    be `/posts`, `/users`, and `/users/ID/posts` to represent the GraphQL API as a
    REST API. When using GraphQL, we only have one route, and we send the query as
    a JSON-like object.
  prefs: []
  type: TYPE_NORMAL
- en: The first query we will have is going to return an array of all of the posts
    we have got.
  prefs: []
  type: TYPE_NORMAL
- en: If we query for all posts and want to return each user with its corresponding
    post, this would be a sub-query that would not be represented in our `RootQuery`
    type but in the `Post` type itself. You will see how this is done later.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the JSON-like schema, we add `RootQuery` to the `schema` property.
    This type is the starting point for the Apollo Server.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we are going to add the mutation key to the schema, where we will implement
    a `RootMutation` type. It is going to serve all of the actions a user can run.
    Mutations are comparable to the `POST`, `UPDATE`, `PATCH`, and `DELETE` requests
    of a REST API.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the file, we export the schema as an array. If we wanted to, we
    could push other schemas to this array to merge them.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing that's missing here is the implementation of our resolvers.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing GraphQL resolvers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the schema is ready, we need the matching resolver functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `resolvers.js` file in the `graphql` folder, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `resolvers` object holds all types as a property. Here, we set up `RootQuery`,
    holding the `posts` query in the same way as we did in our schema. The `resolvers`
    object must equal the schema but be recursively merged. If you want to query a
    subfield, such as the user of a post, you have to extend the `resolvers` object
    with a `Post` object containing a `user` function next to `RootQuery`.
  prefs: []
  type: TYPE_NORMAL
- en: If we send a query for all posts, the `posts` function is executed. There, you
    can do whatever you want, but you need to return something that matches the schema.
    So, if you have an array of `posts` as the response type of `RootQuery`, you cannot
    return something different, such as just one post object instead of an array.
    In that case, you would receive an error.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, GraphQL checks the data type of every property. If `id` is defined
    as `Int`, you cannot return a regular MongoDB `id` since these IDs are of the
    `String` type. GraphQL would throw an error too.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL will parse or cast specific data types for you if the value type is
    matching. For example, a `string` with a value of `2.1` is parsed to `Float` without
    any problems. On the other hand, an empty string cannot be converted into a `Float`,
    and an error would be thrown. It is better to directly have the correct data types
    because this saves you from casting and also prevents unwanted problems.
  prefs: []
  type: TYPE_NORMAL
- en: To prove that everything is working, we will continue by performing a real GraphQL
    request against our server. Our `posts` query will return an empty array, which
    is a correct response for GraphQL. We will come back to the `resolver` functions
    later. You should be able to start the server again so that we can send a demo
    request.
  prefs: []
  type: TYPE_NORMAL
- en: Sending GraphQL queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can test this query using any HTTP client, such as Postman, Insomnia, or
    any you are used to. The next section covers HTTP clients. If you want to send
    the following queries on your own, then you can read the next section and come
    back here.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test our new function when you send the following JSON as a `POST`
    request to `http://localhost:8000/graphql`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `operationName` field is not required to run a query, but it is great for
    logging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The `query` object is a JSON-like representation of the query we want to execute.
    In this example, we run the `RootQuery` posts and request the `id` and `text`
    fields of every post. We do not need to specify `RootQuery` because it is the
    highest layer of our GraphQL API.
  prefs: []
  type: TYPE_NORMAL
- en: The `variables` property can hold parameters such as the user IDs that we want
    to filter the posts by. If you want to use variables, they need to be defined
    in the query by their name too.
  prefs: []
  type: TYPE_NORMAL
- en: 'For developers who are not used to tools such as Postman, there is also the
    option to open the `/graphql` endpoint in a separate browser tab. You will be
    presented with a GraphQLi instance that''s made for sending queries easily. Here,
    you can insert the content of the `query` property and hit the play button. Because
    we set up Helmet to secure our application, we need to deactivate it in development.
    Otherwise, the GraphQLi instance is not going to work. Just wrap the complete
    Helmet initialization inside the `server/index.js` file with the following `if`
    statement in curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This short condition only activates Helmet when the environment is in development.
    Now, you can send the request with GraphQLi or any HTTP client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response of the `POST` request, when combined with the preceding body,
    should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, we received the empty posts array, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Going further, we want to respond with the fake data we statically wrote in
    our client so that it comes from our backend. Copy the `initialPosts` array from
    `App.js` above the `resolvers` object but rename it `posts`. We can respond to
    the GraphQL request with this filled `posts` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the content of the `posts` function in the GraphQL resolvers with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You can rerun the `POST` request and receive both fake posts. The response does
    not include the user object we have in our fake data, so we must define a user
    property on the `post` type in our schema to fix this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple types in GraphQL schemas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a `User` type and use it with our posts. First, add it to the
    schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a `User` type, we need to use it inside the `Post` type. Add
    it to the `Post` type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `user` field allows us to have a sub-object inside our posts, along with
    the post's author information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our extended query to test this looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You cannot just specify the user as a property of the query. Instead, you need
    to provide a sub-selection of fields. This is required whenever you have multiple
    GraphQL types nested inside each other. Then, you need to select the fields your
    result should contain.
  prefs: []
  type: TYPE_NORMAL
- en: Running the updated query gives us the fake data, which we already have in our
    frontend code; just the `posts` array as-is.
  prefs: []
  type: TYPE_NORMAL
- en: We have made good progress with querying data, but we also want to be able to
    add and change data.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first GraphQL mutation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One thing our client has already offered was adding new posts to the fake data
    temporarily. We can implement this in the backend by using GraphQL mutations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with the schema, we need to add the mutation, as well as the input
    types, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: GraphQL inputs are no more than types. Mutations can use them as parameters
    inside requests. They may look weird because our current output types look almost
    the same. However, it would be wrong to have an `id` property on `PostInput`,
    for example, since the backend chooses the ID and the client cannot provide it.
    Consequently, it does make sense to have separate objects for input and output
    types.
  prefs: []
  type: TYPE_NORMAL
- en: The `addPost` function receiving our two new required input types – `PostInput`
    and `UserInput` – is a new feature. Those functions are called mutations since
    they mutate the current state of the application. The response to this mutation
    is an ordinary `Post` object. When creating a new post with the `addPost` mutation,
    we will directly get the created post from the backend in response.
  prefs: []
  type: TYPE_NORMAL
- en: The exclamation mark in the schema tells GraphQL that the field is a required
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The `RootMutation` type corresponds to the `RootQuery` type and is an object
    that holds all GraphQL mutations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to enable the mutations in our schema for the Apollo Server
    by applying the `RootMutation` type to the `schema` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the client does not send the user with the mutation. This is because
    the user is authenticated first, before adding a post, and through that, we already
    know which user initiated the Apollo request. However, we will ignore this for
    the moment and implement authentication later in [*Chapter 6*](B17337_06_Final_ASB_ePub.xhtml#_idTextAnchor141),
    *Authentication with Apollo and React*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the `addPost` resolver function needs to be implemented in the `resolvers.js`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `RootMutation` object to `RootQuery` in `resolvers.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This resolver extracts the `post` and `user` objects from the mutation's parameters,
    which are passed in the second argument of the function. Then, we build the `postObject`
    variable. We want to add our `posts` array as a property by destructuring the
    `post` input and adding the `user` object. The `id` field is just the length of
    the `posts` array plus one.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the `postObject` variable looks like a `post` from the `posts` array. Our
    implementation does the same as the frontend is already doing. The return value
    of our `addPost` function is `postObject`. To get this working, you need to change
    the initialization of the `posts` array from `const` to `let`. Otherwise, the
    array will be static and unchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run this mutation via your preferred HTTP client, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: First, we pass the word `mutation` and the actual function name – in this case,
    `addPost` – that we want to run, including a selection of response fields inside
    the `query` property, to the normal data query for the posts.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we use the `variables` property to send the data we want to insert into
    our backend. We need to pass them as parameters within the `query` string. We
    can define both parameters with a dollar sign and the awaited data type inside
    the `operation` string. The variables marked with dollar signs are then mapped
    into the actual action we want to trigger on the backend.
  prefs: []
  type: TYPE_NORMAL
- en: When we send this mutation, the request will have a `data` object, including
    an `addPost` field. The `addPost` field holds the post, which we send with our
    request.
  prefs: []
  type: TYPE_NORMAL
- en: If you query the posts again, you will see that there are now three posts. Great
    – it worked!
  prefs: []
  type: TYPE_NORMAL
- en: As with our client, this is only temporary until we restart the server. We'll
    cover how to persist data in a SQL database in [*Chapter 3*](B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054),
    *Connecting to the Database*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll cover the various ways you can debug your backend.
  prefs: []
  type: TYPE_NORMAL
- en: Backend debugging and logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two things are very important for debugging. The first is that we need to implement
    logging for our backend in case we receive errors from our users, while the second
    is that we need to look into Postman to debug our GraphQL API efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's get started with logging.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in Node.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most popular logging package for Node.js is called `winston`. Install and
    configure `winston` by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `winston` with `npm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a new folder for all of the helper functions from the backend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, insert a `logger.js` file into the new folder with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This file can be imported everywhere we want to log.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we defined the standard `transports` for `winston`. A
    transport is nothing more than how `winston` separates and saves various log types
    in different files.
  prefs: []
  type: TYPE_NORMAL
- en: The first `transport` generates an `error.log` file where only real errors are
    saved.
  prefs: []
  type: TYPE_NORMAL
- en: The second transport is a combined log where we save all the other log messages,
    such as warnings or information logs.
  prefs: []
  type: TYPE_NORMAL
- en: If we are running the server in a development environment, which we are currently
    doing, we must add a third transport. We will also directly log all the messages
    to the console while developing on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Most people who are used to JavaScript development know the difficulty with
    `console.log`. By directly using `winston`, we can see all the messages in the
    Terminal, but we do not need to clean the code from `console.log` either, so long
    as the things we log make sense.
  prefs: []
  type: TYPE_NORMAL
- en: To test this out, we can try the `winston` logger in the only mutation we have.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `resolvers.js`, add the following code to the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can extend the `addPost` function by adding the following before the
    `return` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: When you send the mutation now, you will see that the message was logged to
    the console.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, if you look in the root folder of your project, you will see the
    `error.log` and `combined.log` files. The `combined.log` file should contain the
    log from the console.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can log all the operations on the server, we should explore Postman
    so that we can send requests comfortably.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with Postman
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Postman** is one of the most widely used HTTP clients there is. It not only
    provides raw HTTP client functionality but also teams and collections, along with
    letting you synchronize all the requests you saved in Postman.'
  prefs: []
  type: TYPE_NORMAL
- en: You can install Postman by downloading the appropriate file from [https://www.postman.com/downloads/](https://www.postman.com/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Numerous other HTTP client tools are useful for debugging your application.
    You are free to use your tool of choice. Some other great clients that I use are
    Insomnia, SoapUI, and Stoplight, but there are many more. In this book, we will
    use Postman, as it is the most popular from my point of view.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have finished the installation, it should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Postman screen after installing the Book collection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.1_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Postman screen after installing the Book collection
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, I have already created a collection called **Book** in the
    left-hand panel. This collection includes our two requests: one to request all
    posts and one to add a new post.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the following screenshot shows you what the **Add Post** mutation
    looks like in Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – The Add Post mutation in Postman'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.2_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – The Add Post mutation in Postman
  prefs: []
  type: TYPE_NORMAL
- en: The URL is `localhost` and includes port `8000`, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The request body looks pretty much like what we saw previously. Be sure to select
    `application/json` as `Content-Type` next to the `raw` format.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In my case, I need to write the query inline because Postman is not able to
    handle multi-row text inside JSON. If this is not the case for you, please ignore
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the newer version of Postman was released, there is also the option to
    select GraphQL instead of JSON. If you do that, you can write the GraphQL code
    in multiple lines and write the variables in a separate window. The result should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Postman with GraphQL selected'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.3_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Postman with GraphQL selected
  prefs: []
  type: TYPE_NORMAL
- en: If you add a new request, you can use the *Ctrl* + *S* shortcut to save it.
    You need to select a collection and a name to save it with. One major downfall
    of using Postman (at least with GraphQL APIs) is that we are only using `POST`.
    It would be great to have some kind of indication of what we are doing here –
    for example, a query or a mutation. We will learn how to use authorization in
    Postman once we have implemented it.
  prefs: []
  type: TYPE_NORMAL
- en: Postman also has other great features, such as automated testing, monitoring,
    and mocking a fake server.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this book, it will become more complicated to configure Postman for
    all requests. In such cases, I like to use the Apollo Client Developer Tools,
    which perfectly integrate into the frontend and make use of Chrome DevTools. What's
    great about the Apollo Client Developer Tools is that they use the Apollo Client
    we configure in the frontend code, which means they reuse the authentication we
    built into our frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we set up our Node.js server with Express.js and bound the
    Apollo Server to respond to requests on a GraphQL endpoint. We can handle queries,
    return fake data, and mutate that data with GraphQL mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we can log every process in our Node.js server. Debugging an application
    with Postman leads to a well-tested API, which can be used later in our frontend.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to persist data in a SQL server. We will
    also implement models for our GraphQL types and cover migrations for our database.
    We need to replace our current `resolver` functions with queries via Sequelize.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot to do, so read on for more!
  prefs: []
  type: TYPE_NORMAL
