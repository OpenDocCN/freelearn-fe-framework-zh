- en: Chapter 3. An Interactive Google Map
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。一个交互式的 Google 地图
- en: In this project we'll create a highly interactive Google map that works with
    the latest version of Google's API to produce a map with custom overlays and markers,
    geocoded addresses, and computed distances. We'll also look at how to keep our
    simple UI in sync with the locations added to the map using a combination of Google
    and jQuery event handlers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将创建一个与 Google 最新 API 版本配合工作的高度交互式 Google 地图，以生成带有自定义覆盖层和标记、地理编码地址以及计算距离的地图。我们还将看看如何使用谷歌和
    jQuery 事件处理程序的组合来保持我们的简单 UI 与地图上添加的位置同步。
- en: Mission Briefing
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务简报
- en: For the purposes of this project, we'll have a scenario where we need to build
    a map-based application for a company that takes things from one place to another.
    They want a page that their customers can visit to calculate the cost of, and
    maybe order, the transport of something from one place to another by clicking
    on different areas of a localized map.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 出于本项目的目的，我们将有一个场景，需要为一个将物品从一个地方运送到另一个地方的公司构建一个基于地图的应用程序。他们希望客户可以访问一个页面，通过点击地图上的不同区域来计算运输某物品从一个地方到另一个地方的成本，并可能下单。
- en: We'll see how to listen for clicks on the map so that markers can be added and
    the precise locations of each marker can be recorded. We can then update the UI
    to show the actual street addresses of the locations that were clicked and allow
    the visitor to generate a quote based on the computed distance between the two
    addresses.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将了解如何监听地图上的点击事件，以便可以添加标记并记录每个标记的精确位置。然后我们可以更新 UI 以显示被点击位置的实际街道地址，并允许访问者根据两个地址之间的计算距离生成报价。
- en: Why Is It Awesome?
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么这很棒？
- en: Google Maps is a fantastic API to build on. Already highly interactive and packed
    with features, we can build robust and highly functional applications on top of
    the solid foundation it provides. Google provides the mapping data and interactivity
    with the map, while jQuery is used to build the UI – a winning combination.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌地图是一个很棒的 API 来构建应用程序。已经具有高度交互性和丰富的功能，我们可以在其提供的坚实基础上构建稳健且高度功能性的应用程序。谷歌提供地图数据和地图的交互性，而
    jQuery 用于构建 UI——这是一个胜利的组合。
- en: 'The page that we''ll end up with will resemble the following screenshot:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终将得到的页面将类似于以下屏幕截图：
- en: '![Why Is It Awesome?](img/9106OS_03_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![为什么这很棒？](img/9106OS_03_01.jpg)'
- en: Your Hotshot Objectives
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '你的高能目标 '
- en: 'This project will be broken down into the following tasks:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '该项目将分解为以下任务： '
- en: Creating the page and interface
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建页面和界面
- en: Initializing the map
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化地图
- en: Showing the company HQ with a custom overlay
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义覆盖层显示公司总部位置
- en: Capturing clicks on the map
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获地图上的点击事件
- en: Updating the UI with the start and end locations
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 UI，显示起始位置和终点位置
- en: Handling marker repositions
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理标记重新定位
- en: Factoring in weights
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑权重因素
- en: Displaying the projected distance and cost
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示预计距离和费用
- en: Mission Checklist
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务清单
- en: We'll need to link to a script file provided by Google in order to initialize
    the map and load in the API. We can also create the new files that we'll be using
    in the project at this point.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要链接到由谷歌提供的脚本文件，以初始化地图并加载 API。我们还可以在此时创建项目中将要使用的新文件。
- en: Don't worry, we don't need an API key from Google or anything like that for
    this project to work, we can just use the script by linking directly to it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心，我们不需要从谷歌获取 API 密钥之类的东西，这个项目可以直接通过链接使用脚本。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Google Maps API is feature-rich and stable, and contains entry points for
    all of the best known mapping features, including Street View, geolocation, and
    the directions service. As well as the configuration options we used here, there
    are many, many others. For further information, see the documentation site at
    [http://developers.google.com/maps/](http://developers.google.com/maps/).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌地图 API 功能丰富且稳定，包含所有最知名的地图功能入口，包括街景、地理位置和导航服务。除了我们在此处使用的配置选项外，还有许多其他选项。有关更多信息，请参阅[http://developers.google.com/maps/](http://developers.google.com/maps/)上的文档网站。
- en: First we should save a new copy of the template file to our root project folder
    and call it `google-map.html`. Also create a `google-map.css` file and a `google-map.js`
    file and save them in the `css` and `js` folders respectively.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该将模板文件的新副本保存到我们的根项目文件夹中，并将其命名为`google-map.html`。还创建一个`google-map.css`文件和一个`google-map.js`文件，并将它们分别保存在`css`和`js`文件夹中。
- en: 'We can link to the style sheet for this example by adding the following `<link>`
    element to the `<head>` of the page, directly after the `<link>` element for `common.css`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将以下`<link>`元素添加到页面的`<head>`中，直接在`common.css`的`<link>`元素后面，来链接到此示例的样式表：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't forget, we're using `common.css` with each project so that we can focus
    on the styles we actually need for the project, without all of the boring reset,
    float-clears, and other common CSS styling required for most web pages.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了，我们每个项目都使用`common.css`，这样我们就可以专注于实际项目中需要的样式，而不用关注大多数网页所需的所有无聊的重置、浮动清除和其他常见CSS样式。
- en: 'We can link to Google''s script file, as well as the JavaScript file we just
    created, using the following `<script>` elements, directly after the `<script>`
    element for jQuery:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下`<script>`元素直接在jQuery的`<script>`元素后面链接到Google的脚本文件以及我们刚刚创建的JavaScript文件：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We'll also be using a couple of images in this project, `hq.png` and `start.png`,
    which can both be found in the accompanying code download for this book. You should
    copy them into the `img` directory in your local `jquery-hotshots` project directory.
    Our page is now set up ready for the first task.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们还将使用几张图片，`hq.png`和`start.png`，它们都可以在本书的附带代码下载中找到。你应该将它们复制到本地`jquery-hotshots`项目目录中的`img`目录下。我们的页面现在已经准备好进行第一个任务了。
- en: Creating the page and interface
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建页面和界面
- en: In our first task we can add the different containers for the map, and the initial
    UI elements needed by the page. We can also add some basic styling to lay things
    out as we want.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个任务中，我们可以添加地图的不同容器，以及页面所需的初始UI元素。我们也可以添加一些基本的样式，将事物布局成我们想要的样子。
- en: Engage Thrusters
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'We should add the following elements to the `<body>` element in the `google-map.html`
    page that we just set up:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该将以下元素添加到我们刚刚设置的`google-map.html`页面的`<body>`元素中：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For some basic styling and to lay out the page ready for when we initialize
    the map, we can add the following selectors and styles to the `google-map.css`
    file that we just created:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行一些基本的样式设置，并为初始化地图做好页面布局准备，我们可以将以下选择器和样式添加到我们刚刚创建的`google-map.css`文件中：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Objective Complete - Mini Debriefing
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 迷你总结
- en: In this task we're just getting started by adding the underlying HTML elements
    that we'll populate properly over the next few tasks. A slightly boring, but somewhat
    necessary, first step in getting the example page up and running, and the project
    under way.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们只是开始添加我们将在接下来的几个任务中正确填充的基础HTML元素。这是让示例页面开始运行并让项目启动的一个略微无聊但有些必要的第一步。
- en: The first element we added is the container that the Google Maps API will render
    the map tiles into. We give it an `id` of `map` so that it can be efficiently
    selected, but it is completely empty to start with.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的第一个元素是Google Maps API将渲染地图瓦片到其中的容器。我们给它一个`id`为`map`，以便可以有效地选择它，但它一开始是完全空的。
- en: The next element is the container for the various UI elements the example requires.
    It too has an `id` of `ui` for easy selecting from our script, as well as for
    adding the CSS styling with.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个元素是各种UI元素的容器，示例需要它。它也有一个`id`为`ui`，以便我们的脚本可以轻松选择它，并且用CSS样式添加。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Styling with IDs**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用ID进行样式设置**'
- en: Avoiding the use of ID selectors to add CSS styling is well on its way to becoming
    a general best practice, with tools such as **CSSLint** advising against its use.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用ID选择器添加CSS样式正逐渐成为一种普遍的最佳实践，例如**CSSLint**等工具建议不要使用它。
- en: While the arguments for doing this and sticking to classes, element, or attribute
    selectors are compelling, we'll be working with them in some of the projects throughout
    this book for simplicity.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用类、元素或属性选择器的理由很有说服力，但为了简单起见，我们将在本书中的一些项目中使用它们。
- en: CSSLint is an open source CSS code quality tool that performs static analysis
    of source code and flag patterns that might be errors or otherwise cause problems
    for the developer. See [http://csslint.net/](http://csslint.net/) for more information.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: CSSLint是一个开源的CSS代码质量工具，它对源代码进行静态分析，并标记可能是错误或可能会给开发人员带来问题的模式。有关更多信息，请参见[http://csslint.net/](http://csslint.net/)。
- en: Within the interface container we have the name of the fictional company, some
    basic instructions for using the page, a list of the different charges, and an
    `<input>` element to allow weights to be entered.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在界面容器中，我们有一个虚构公司的名称，一些使用页面的基本说明，一个不同费用的列表，以及一个`<input>`元素用于输入权重。
- en: Most of the CSS that we added in this task was purely decorative and specific
    to this example. It could easily be wildly different if a different look and feel
    was required. We've made the map container take up the full width and height of
    the page, and styled the interface so that it appears to float over the right-hand
    side of the page.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在此任务中添加的大多数 CSS 仅仅是装饰性的，并且特定于此示例。如果需要不同的外观和感觉，它很容易会完全不同。我们已经让地图容器占据了页面的全宽度和高度，并且设计了界面，使其似乎漂浮在页面的右侧。
- en: Initializing the map
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化地图
- en: Getting a zoomable and panable interactive Google map up and running takes a
    ludicrously small amount of code. In this task we'll add that code, as well as
    set up some of the variables that we'll use later in the script.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让一个可缩放和可平移的交互式 Google 地图运行起来只需要极少量的代码。在这个任务中，我们将添加这段代码，并设置稍后在脚本中将使用的一些变量。
- en: Prepare for Lift Off
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为起飞做准备
- en: 'In this task we''ll initialize the variables needed to configure the map and
    make a call to the Google Maps API. We should start by adding the standard jQuery
    wrapper to the empty `google-map.js` file that we created earlier:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将初始化配置地图所需的变量，并调用 Google 地图 API。我们应该从添加标准 jQuery 封装到之前创建的空白 `google-map.js`
    文件开始：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Remember, the `$(function () { … });` construct is a shortcut for jQuery's `document.ready`
    event handler.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`$(function () { … });` 结构是 jQuery 的 `document.ready` 事件处理程序的快捷方式。
- en: Engage Thrusters
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'Within the wrapper we just added, we should add the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚添加的封装器中，我们应该添加以下代码：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Objective Complete - Mini Debriefing
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 迷你简报
- en: In this task we start by creating some variables that we'll need to initialize
    the map. We'll be addressing the `google.maps` namespace throughout our code so
    the first variable we set is the contents of the top two namespaces for convenience.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们首先创建了一些需要初始化地图的变量。我们将在整个代码中处理 `google.maps` 命名空间，因此我们设置的第一个变量是为了方便起见而设置的顶级两个命名空间的内容。
- en: Having a locally scoped copy that reaches right into the actual API that we
    want to use will make our code marginally more efficient because it is easier
    for our code to resolve a single variable. It's also much quicker to type in the
    first place.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个本地范围的副本，可以直接访问我们想要使用的实际 API，这将使我们的代码稍微更有效率，因为我们的代码更容易解析一个变量。而且，一开始输入时也会快得多。
- en: All properties and methods used by the Google Maps API are namespaced. They
    all sit within the `maps` namespace, which itself sits in the `google` namespace.
    Google has such a large code-base for use in so many different applications that
    it makes sense to keep everything isolated and organized using namespaces.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Google 地图 API 使用的所有属性和方法都是命名空间的。它们都位于 `maps` 命名空间中，而 `maps` 命名空间本身位于 `google`
    命名空间中。Google 在许多不同应用程序中使用了如此庞大的代码库，因此使用命名空间将所有内容隔离并组织起来是有意义的。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For an excellent in-depth discussion on the intricacies of namespacing in JavaScript,
    see the excellent article on the subject by JavaScript supremo *Addy Osmani* ([http://addyosmani.com/blog/essential-js-namespacing/](http://addyosmani.com/blog/essential-js-namespacing/)).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 JavaScript 命名空间复杂性的深入讨论，请参阅 JavaScript 专家 *Addy Osmani* 的关于这个主题的优秀文章（[http://addyosmani.com/blog/essential-js-namespacing/](http://addyosmani.com/blog/essential-js-namespacing/)）。
- en: Next we store the latitude and longitude that we'd like to center the map on.
    This is done using the Google Maps API's `LatLng()` method, which takes two arguments,
    the latitude and longitude values, and returns a `LatLng` object for use with
    other API methods. Notice how we call the `LatLng` constructor using our local
    `api` variable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们存储我们想要将地图居中显示的纬度和经度。这是使用 Google 地图 API 的 `LatLng()` 方法完成的，该方法接受两个参数，纬度和经度值，并返回一个用于其他
    API 方法的 `LatLng` 对象。请注意我们如何使用本地的 `api` 变量调用 `LatLng` 构造函数。
- en: We can then create an object literal containing some of the configuration options
    that our map will need. These options include the zoom level, the location the
    map should be centered on, the type of map, and an option which disables the default
    map type and zoom/pan controls. We can use the `LatLng` object contained in `mapCenter`
    for the `center` configuration option.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个对象字面量，其中包含我们的地图将需要的一些配置选项。这些选项包括缩放级别、地图应该居中的位置、地图类型，以及一个禁用默认地图类型和缩放/平移控件的选项。我们可以使用
    `mapCenter` 中包含的 `LatLng` 对象作为 `center` 配置选项。
- en: 'Following this we create a new map instance using the map API''s `Map()` constructor
    function. This function accepts two arguments: the first is the DOM element that
    the map should be rendered into and the second is the object literal containing
    the configuration options that we wish to set.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用地图API的`Map()`构造函数创建一个新的地图实例。这个函数接受两个参数：第一个是地图应该呈现的DOM元素，第二个是包含我们想要设置的配置选项的对象文字。
- en: The first argument takes an actual DOM element, not a jQuery-wrapped DOM element.
    So although we could select the element from the page using jQuery and then extract
    the raw DOM element, it is more efficient to use JavaScript's native `getElementById()`
    function to retrieve the map container we added to the page in the previous task
    and pass it to the `Map()` constructor.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数需要一个真正的DOM元素，而不是一个用jQuery包装的DOM元素。因此，虽然我们可以使用jQuery从页面中选择元素，然后提取原始的DOM元素，但更有效的方法是使用JavaScript的原生`getElementById()`函数来检索我们在上一个任务中添加到页面中的地图容器，并将其传递给`Map()`构造函数。
- en: Next, we cache a jQuery selector for the UI container so that we can access
    it from the page repeatedly without having to actually select it from the DOM
    each time, and define a variable called `clicks`, which we'll use to record how
    many times the map has been clicked. We need to define it here in the top-level
    function scope so that we can reference it from within a click handler later in
    the code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们缓存一个用于UI容器的jQuery选择器，以便我们可以重复地从页面中访问它，而不必每次都从DOM中选择它，并定义一个名为`clicks`的变量，我们将用它来记录地图被点击的次数。我们需要在顶层函数范围内定义它，以便我们可以在代码中后续的点击处理程序中引用它。
- en: Lastly, we add an empty array literal in the variable `positions`, which we'll
    populate later on when we need to store the different areas of the map that have
    been clicked on. The array needs to be in the scope of the top-level function
    so that we can access it from within different event handlers later in the code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在变量`positions`中添加一个空的数组文字，以便在需要存储地图上不同区域时稍后填充。数组需要在顶层函数范围内，以便我们在后面的代码中从不同的事件处理程序中访问它。
- en: Showing the company HQ with a custom overlay
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示公司总部及自定义叠加层
- en: In this task we'll put the company HQ on the map, literally, by adding a custom
    marker complete with an overlay that provides some basic information about the
    company, and perhaps an image of the premises.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将在地图上直接放置公司总部，通过添加一个自定义标记和叠加层，提供一些关于公司的基本信息，也许还有场所的图片。
- en: Prepare for Lift Off
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备升空
- en: 'In this task we''ll cover the following subtasks:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将涵盖以下子任务：
- en: Adding a marker to the map
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在地图上添加一个标记
- en: Adding a hidden element containing information about the company
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个包含有关公司信息的隐藏元素
- en: Adding a custom overlay to display the company information when the new marker
    is clicked
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新标记被单击时添加一个自定义叠加层以显示公司信息
- en: Adding a click handler to show the overlay when the marker is clicked
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标记被单击时添加一个单击处理程序来显示叠加层
- en: Engage Thrusters
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'Adding a custom marker to the map can be achieved with the following simple
    code block, which should be added directly after the variables we added in the
    previous task:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个任务中添加的变量后面，可以通过以下简单的代码块实现在地图上添加自定义标记：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To create an information overlay, or info window to use the correct Google
    terminology, for our new marker, we should first add an HTML element that contains
    the content we wish to display in the overlay. We can add the following new collection
    of elements to `google-map.html` directly after the UI container:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的新标记创建信息叠加层，或者使用正确的谷歌术语，信息窗口，首先应该添加一个包含我们希望在叠加层中显示内容的HTML元素。我们可以在UI容器后面直接添加以下新的元素集合到`google-map.html`中：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We're using the `placehold.it` service again so that we don't have to worry
    about sourcing or creating an actual image for this bit of example content. It's
    a great service to use when mocking up prototypes quickly.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用`placehold.it`服务，这样我们就不必为这个示例内容担心获取或创建实际的图像。在快速创建原型时，这是一个很好的服务。
- en: 'To tell the map about the new info window, we can use the following code, which
    should be added directly after the `homeMarker` code back in `google-map.js`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了告诉地图新的信息窗口，我们可以使用以下代码，在`google-map.js`中`homeMarker`代码后直接添加：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We also need some extra CSS to style the contents of the info window and to
    hide it until it is required. Add the following code to the bottom of `google-map.css`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一些额外的CSS来样式化信息窗口的内容，并在需要时隐藏它。将以下代码添加到`google-map.css`的底部：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we can add a simple click handler that displays the info window using
    the following code, which should be added after the `infoWindow` variable that
    we added a moment ago in `google-map.js`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以添加一个简单的点击处理程序，使用以下代码，在刚刚在`google-map.js`中添加的`infoWindow`变量之后添加：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Objective Complete - Mini Debriefing
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小结
- en: First of all we defined a new marker, which is done using Google's `Marker()`
    constructor. This function takes a single argument, which is an object literal
    that defines different properties of the marker.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个新的标记，使用的是Google的`Marker()`构造函数。这个函数接受一个参数，即定义标记不同属性的对象字面量。
- en: We set the `position` of the marker to be the center of the map for simplicity,
    although when defining other markers you'll see that any `LatLng` object can be
    used. We should also define the map that the marker belongs to, which we set to
    the `map` variable that contains our map instance. To specify the image to use
    as the marker, we can supply a relative path in string format to the `icon` option.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将标记的`position`设置为地图的中心，以简化操作，尽管在定义其他标记时，您会看到任何`LatLng`对象都可以使用。我们还应该定义标记所属的地图，我们将其设置为包含地图实例的`map`变量。要指定用作标记的图像，我们可以提供一个相对路径的字符串格式给`icon`选项。
- en: We then added a new container to the page which contains the information we
    want to display in our custom info window. The content here is not important;
    it's the technique that matters. We also added some additional styling for the
    contents of the info window.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们向页面添加了一个新的容器，其中包含我们想要在自定义信息窗口中显示的信息。这里的内容并不重要；重要的是技术。我们还为信息窗口的内容添加了一些额外的样式。
- en: In order to add the info window to our map instance, we used Google's `InfoWindow()`
    constructor. This method also takes a single argument, which again is an object
    literal which contains the options we wish to set. In this example we just set
    the `content` option to the element containing the content we just added to the
    page.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将信息窗口添加到我们的地图实例中，我们使用了Google的`InfoWindow()`构造函数。这个方法也接受一个参数，再次是一个对象字面量，其中包含我们希望设置的选项。在这个示例中，我们只是将`content`选项设置为包含我们刚刚添加到页面上内容的元素。
- en: This should be an actual DOM element, hence we use JavaScript's `document.getElementById()`
    to get the element, instead of selecting it with jQuery.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是一个实际的DOM元素，因此我们使用JavaScript的`document.getElementById()`来获取元素，而不是使用jQuery进行选择。
- en: Lastly we added an event handler to the map using Google's `addListener()` method.
    This method takes the element to attach the event handler to, which in this case
    is the marker we added, as the first argument, the event we wish to listen for
    as the second argument, and the callback function to handle the event as the third
    argument. The signature of this method is very similar to the event handling methods
    found in other common JavaScript libraries, although it is slightly different
    to how events handlers are added in jQuery.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用Google的`addListener()`方法向地图添加了一个事件处理程序。该方法接受要附加事件处理程序的元素作为第一个参数，本例中为我们添加的标记；要监听的事件作为第二个参数；以及处理事件的回调函数作为第三个参数。该方法的签名与其他常见JavaScript库中找到的事件处理方法非常相似，尽管与jQuery中添加事件处理程序的方式略有不同。
- en: Within the anonymous function we pass as the third argument to the `addListener()`
    method, all we do is call the `open()` method of our info window. The `open()`
    method takes two arguments; the first is the map that the info window belongs
    to, and the second is the location the info window is added to, which we set to
    our marker.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在作为`addListener()`方法的第三个参数传递的匿名函数中，我们所做的就是调用我们信息窗口的`open()`方法。`open()`方法接受两个参数；第一个是信息窗口所属的地图，第二个是信息窗口添加到的位置，我们将其设置为我们的标记。
- en: 'At this point we should be able to run the page in a browser, click on our
    custom marker, and have the contents of our hidden `<div>` displayed in the info
    window, as shown in the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该能够在浏览器中运行页面，单击我们的自定义标记，并将隐藏的`<div>`的内容显示在信息窗口中，如下面的截图所示：
- en: '![Objective Complete - Mini Debriefing](img/9106OS_03_02.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![目标完成 - 小结](img/9106OS_03_02.jpg)'
- en: Capturing clicks on the map
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获地图上的点击事件
- en: In this task we need to add a click handler for our map so that visitors can
    set the start and end of their transportation journey.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们需要为地图添加一个点击处理程序，以便访问者可以设置其交通旅程的起点和终点。
- en: Engage Thrusters
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'First of all we need to add the function that will be executed when the map
    is clicked. Directly after the listener that we added in the last task, add the
    following function expression:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要添加当地图被单击时将执行的函数。在上一个任务中添加的监听器之后，直接添加以下函数表达式：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, to attach a listener for clicks on the map which fires this function,
    we can add the following code directly after it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为地图上的单击附加一个触发此函数的监听器，我们可以在其后直接添加以下代码：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Objective Complete - Mini Debriefing
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小型简报
- en: First of all we added the function that will be executed every time the map
    is clicked. The function will automatically be passed the event object by the
    `addListener()` method, which will contain a `latLng` object for the coordinates
    on the map that were clicked.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加了每次单击地图时将执行的函数。该函数会自动通过`addListener()`方法传递事件对象，其中包含了在地图上单击的坐标的`latLng`对象。
- en: The first thing we do in the function is store the `latLng` property of the
    event object in our `positions` array. We'll need to know both of the locations
    that were clicked so it is useful to add them both to the `positions` array, which
    is visible throughout our code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中的第一件事是将事件对象的`latLng`属性存储在我们的`positions`数组中。我们需要知道单击了哪两个位置，因此将它们都添加到我们的`positions`数组中很有用，并且该数组可以在整个代码中可见。
- en: Then we check whether the `clicks` variable that we defined earlier is less
    than or equal to `1`. Provided it is, we go ahead and create a new marker using
    Google's `Marker()` constructor. We used the constructor earlier when we added
    a marker to show the company's headquarters, but this time we set some different
    properties.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查之前定义的`clicks`变量是否小于或等于`1`。如果是，我们继续使用Google的`Marker()`构造函数创建一个新的标记。之前在添加标记显示公司总部时我们已经使用了该构造函数，但这次我们设置了一些不同的属性。
- en: We set the `map` property to be our map instance, and this time set the `position`
    of the marker to the `latLng` object contained in the event object, which will
    match the point on the map that was clicked.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`map`属性设置为我们的地图实例，并将标记的`position`设置为事件对象中包含的`latLng`对象，该对象将匹配在地图上单击的点。
- en: We'll use a green marker image for the first click, which will represent the
    start of the journey. The image we'll use already has its own shadow, so when
    we add the first marker, which we can determine using a JavaScript ternary that
    checks whether `clicks` is equal to `0`, we set the `flat` property to `true`
    to disable the shadow that Google will otherwise add.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为第一次单击使用绿色标记图像，表示旅程的起始点。我们将使用的图像已经有了自己的阴影，因此当添加第一个标记时，我们可以使用JavaScript三元运算符确定是否`clicks`等于`0`，然后将`flat`属性设置为`true`以禁用Google否则会添加的阴影。
- en: We can easily add a nice drop animation so that when the map is clicked, the
    new marker drops into place. The animation features a bounce easing effect, which
    is also visually pleasing. The animation is set using the `animation` property,
    which is set to `DROP` using the `Animation` API.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地添加一个漂亮的掉落动画，以使当地图被单击时新的标记掉落到位。动画采用弹跳的缓动效果，视觉上也很愉悦。动画使用`animation`属性进行设置，该属性使用`Animation`
    API设置为`DROP`。
- en: We can also set a `title` for the marker, which is displayed when the cursor
    hovers over it, using the `title` property. Again we use a simple JavaScript ternary
    to set either the `Start` or `End` as the string depending on value of our `clicks`
    variable.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以设置标记的`title`，当光标悬停在上面时会显示，使用`title`属性。同样，我们使用一个简单的JavaScript三元运算符根据`clicks`变量的值设置`Start`或`End`字符串。
- en: We use the `icon` property to specify the path to the image that we'll use for
    the start marker. When `clicks` is not equal to `0` we just specify an empty string,
    which causes the default red marker to be added.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`icon`属性指定用于起始标记的图像的路径。当`clicks`不等于`0`时，我们只指定一个空字符串，这会导致添加默认的红色标记。
- en: We also set the `draggable` property to `true` to make the markers draggable.
    This will let users modify the start or end locations of the journey if they wish.
    We can add the code that will handle this a little later on.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`draggable`属性设置为`true`，以使标记可拖动。这将允许用户根据需要修改旅程的起始位置或终点位置。稍后我们可以添加处理这一功能的代码。
- en: Next we can use Google's `event` API to trigger a custom event. We use the `trigger()`
    method, specifying the `map` instance as the object that the event will originate
    from, `locationAdd` as the name of our custom event, and pass the event object
    that we've worked with in our `addMarker()` function (stored in `e`) as a parameter
    to any handlers that may be listening for our custom event. We add a handler for
    this event in the next section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用谷歌的`event`API来触发一个自定义事件。我们使用`trigger()`方法，指定`map`实例作为事件源对象，`locationAdd`作为我们自定义事件的名称，并将我们在`addMarker()`函数中使用的事件对象（存储在`e`中）作为参数传递给可能正在监听我们自定义事件的任何处理程序。我们在下一节中添加对此事件的处理程序。
- en: Lastly we can set a unique `id` attribute on the marker so that we can differentiate
    each marker. We'll need this when we want to update our UI following a marker
    drag, which we'll look at a little later on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在标记上设置一个唯一的`id`属性，以便我们可以区分每个标记。当我们想要在标记拖动后更新我们的 UI 时，我们会用到这一点，稍后我们会讨论这一点。
- en: This is everything we want to do at this point while the `clicks` variable is
    still less than or equal to `1`. The second branch of the outer conditional in
    our `addMarker()` function deals with situations when `clicks` is greater than
    `1`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在`clicks`变量仍小于或等于`1`的情况下想要做的一切。我们`addMarker()`函数中外部条件分支的第二个分支处理`clicks`大于`1`的情况。
- en: In this case, we know the map has already been clicked twice, so when this occurs
    we want to stop listening for clicks on the map. We can unbind our handler using
    the `event` API's `removeListener()` method. This method simply takes a reference
    to the `eventListener` returned by the `addListener()` method.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们知道地图已经被点击了两次，所以当这种情况发生时，我们希望停止监听地图上的点击事件。我们可以使用`event`API的`removeListener()`方法解除绑定我们的处理程序。该方法只需一个对`addListener()`方法返回的`eventListener`的引用。
- en: When we bind the click event on the map to our `addMarker` function, we store
    what is returned in the `mapClick` variable, which is what is passed to the `removeListener()`
    method.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将地图上的点击事件绑定到我们的`addMarker`函数时，我们将返回的内容存储在`mapClick`变量中，这是传递给`removeListener()`方法的内容。
- en: At this point we should be able to run the page in a browser and add new markers
    to the map by clicking at different locations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该能够在浏览器中运行页面，并通过单击不同位置来向地图添加新标记。
- en: Classified Intel
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机密情报
- en: We used a **function expression** in this task, by assigning the event handler
    to a variable, instead of perhaps the more familiar **function declaration**.
    This is generally considered a good practice, and while not essential in this
    situation, it is certainly a good habit to get into. For a thorough understanding
    of why function expressions are generally better than function declarations, see
    *John Resig's* blog post at [http://ejohn.org/blog/javascript-as-a-first-language/](http://ejohn.org/blog/javascript-as-a-first-language/).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们使用了**函数表达式**，通过将事件处理程序分配给一个变量，而不是更熟悉的**函数声明**。这通常被认为是一个好习惯，虽然在这种情况下不是必需的，但养成这种习惯肯定是一个好习惯。想要全面理解为什么函数表达式通常比函数声明更好，请参阅*John
    Resig*的博客文章[http://ejohn.org/blog/javascript-as-a-first-language/](http://ejohn.org/blog/javascript-as-a-first-language/)。
- en: Updating the UI with the start and end locations
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用起点和终点位置更新 UI
- en: Once the two markers have been added to the map, we want to display their locations
    in the UI sidebar at the right of the page ready for when we compute the cost
    of the journey.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦两个标记已添加到地图上，我们希望在页面右侧的 UI 侧边栏中显示它们的位置，以便在计算行程费用时使用。
- en: We'll want to show the full street address of each location that is clicked
    and also add a button that triggers the computation of a quote based on the locations
    that the visitor has chosen on the map.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将希望显示每个点击位置的完整街道地址，并添加一个按钮，触发基于访问者在地图上选择的位置计算报价。
- en: Prepare for Lift Off
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为起飞做准备
- en: In the last task we used Google's `trigger()` method to trigger a custom event
    each time a new marker was added to the map following a click. In this task we'll
    add a handler for that custom event.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个任务中，我们使用了谷歌的`trigger()`方法，以便在每次通过点击向地图添加新标记时触发一个自定义事件。在这个任务中，我们将为该自定义事件添加一个处理程序。
- en: So far in this project, we've stuck almost entirely to Google's map API and
    haven't really used jQuery at all other than to add the initial `document.load`
    wrapper for the rest of code. In this part of the project we'll rectify that and
    fire up jQuery in order to update our UI.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这个项目中，我们几乎完全使用了谷歌的地图 API，除了在代码的其余部分中添加了最初的`document.load`包装器之外，几乎没有使用
    jQuery。在项目的这一部分，我们将纠正这一点，启动 jQuery 来更新我们的用户界面。
- en: Engage Thrusters
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'The handler for our custom `locationAdd` event should be as follows, which
    can be added directly after the `mapClick` variable from the last task:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义 `locationAdd` 事件的处理程序应该如下所示，可以直接添加到上一个任务的 `mapClick` 变量后面：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we''ll be adding some new elements to the page, we''ll also need to update
    our style sheet for this project. Add the following new styles to the bottom of
    `google-map.css`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将向页面添加一些新元素，所以我们还需要更新这个项目的样式表。在 `google-map.css` 的底部添加以下新样式：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Objective Complete - Mini Debriefing
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小型总结
- en: We add the event handler for our custom `locationAdd` event in the same way
    that we added our click events, using Google's `addListener()` method.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以与添加点击事件相同的方式为我们的自定义 `locationAdd` 事件添加事件处理程序，使用 Google 的 `addListener()`
    方法。
- en: Within the event handler we first define some variables. The first is a cached
    jQuery object that represents the element that displays the start and end points.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件处理程序中，我们首先定义了一些变量。第一个是一个缓存的 jQuery 对象，表示显示起始点和终点的元素。
- en: The next variable we set is then one of two things. If the jQuery object we
    set as the first variable has length, we know the journey element exists on the
    page, so we just store a reference to it. If it doesn't exist, we create a new
    element to use as the journey element and set its `id` to `journey`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们设置的下一个变量是两者之一。如果我们将第一个变量设置为 jQuery 对象的长度，我们知道页面上存在行程元素，所以我们只是存储对它的引用。如果它不存在，我们将创建一个新元素用作行程元素，并将其
    `id` 设置为 `journey`。
- en: When the map is clicked for the first time, the journey element won't exist
    and will be created. The second time the map is clicked, the element will exist,
    so it will be selected from the page instead of being created.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当地图首次被点击时，行程元素不存在并将被创建。第二次点击地图时，该元素将存在，因此它将从页面中选择而不是被创建。
- en: Next we use the `geocode()` method of Google's `Geocoder()` API, which allows
    us to reverse-geocode a `latLng` object to get a street address. This method takes
    two arguments. The first is a configuration object, which we can use to specify
    the `latLng` object that we want to convert.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们使用 Google 的 `Geocoder()` API 的 `geocode()` 方法，它允许我们对 `latLng` 对象进行逆地理编码以获取街道地址。这个方法有两个参数。第一个是配置对象，我们可以用它来指定我们想要转换的
    `latLng` 对象。
- en: The second argument is a callback function that is executed once the geocoding
    is complete. This function is automatically passed a `results` object that contains
    the address.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个回调函数，一旦地理编码完成就会执行。这个函数会自动传递一个包含地址的 `results` 对象。
- en: Within this callback function we can use jQuery to create new elements to display
    the address and then append them to the journey element. The complete street address
    is found in the `formatted_address` property of the `results` object, which we
    can set as the text of one of the new elements. We can also set an `id` attribute
    on this element so that we can easily select it programmatically when required,
    and store the `latLng` object of the location using a custom `data-latLng` attribute.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个回调函数中，我们可以使用 jQuery 创建新元素来显示地址，然后将它们附加到行程元素上。完整的街道地址在 `results` 对象的 `formatted_address`
    属性中找到，我们可以将其设置为新元素之一的文本。我们还可以在此元素上设置一个 `id` 属性，以便在需要时可以轻松地通过编程选择它，并使用自定义的 `data-latLng`
    属性存储位置的 `latLng` 对象。
- en: The `results` object also contains a range of other useful properties about
    the address, so be sure to check it out in the object explorer of your favorite
    browser-based developer toolkit.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`results` 对象还包含有关地址的一系列其他有用属性，因此一定要在您喜爱的基于浏览器的开发者工具包的对象浏览器中查看它。'
- en: If the journey element doesn't exist we can then append it to the UI in order
    to display the address of the location. If it does exist, we know that it is the
    second click and can then create a new `<button>` that can be used to generate
    a quote based on the distance between the two locations.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果行程元素不存在，我们可以将其附加到 UI 中以显示位置的地址。如果它存在，我们知道这是第二次点击，然后可以创建一个新的 `<button>`，该按钮可用于根据两个位置之间的距离生成报价。
- en: We disable the `<button>` element using jQuery's `prop()` method to set the
    `disabled` property. We can enable the button later when a weight is added to
    the `<input>` in the UI.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 jQuery 的 `prop()` 方法禁用 `<button>` 元素来设置 `disabled` 属性。当 UI 中的 `<input>`
    添加了重量后，我们可以稍后启用按钮。
- en: Once we have added the new elements showing the journey start and end points
    in the UI, we can then increment the `clicks` variable so that we can keep track
    of how many markers have been added.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在 UI 中添加了显示行程起点和终点的新元素，我们就可以增加 `clicks` 变量，以便我们可以跟踪添加了多少个标记。
- en: Now when we run the page and click on the map twice to add both the markers,
    the address of the points that we clicked should be displayed in the UI area at
    the right of the page. We should also now see the red end marker and be limited
    to adding only two markers now that we're incrementing the `clicks` variable.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行页面并点击地图两次以添加两个标记时，我们点击的点的地址应该显示在页面右侧的 UI 区域中。现在，我们还应该看到红色的结束标记，并且现在由于增加了
    `clicks` 变量，我们只能添加两个标记。
- en: Handling marker repositions
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理标记重新定位
- en: 'We''ve made our map markers draggable, so we need to handle address changes
    following a marker drag. This task will show just how easily that can be done.
    This will take just two steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使我们的地图标记可拖动，因此我们需要处理标记拖动后的地址更改。这个任务将展示如何轻松完成。这只需要两个步骤：
- en: Binding each marker to the `dragend` event
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个标记绑定到 `dragend` 事件上
- en: Adding the handler function for the event
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为事件添加处理函数
- en: Engage Thrusters
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'First we need to bind each marker to the `dragend` event when the marker is
    created. To do this, we should add the following highlighted line of code to the
    `addMarker()` function, directly after the marker''s constructor:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当创建标记时，我们需要将每个标记绑定到 `dragend` 事件上。为此，我们应该在 `addMarker()` 函数中添加以下突出显示的代码行，直接放在标记构造函数之后：
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next we should add the `markerDrag()` function itself. This can go directly
    after the `locationAdd` handler that we added in the last task:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该添加 `markerDrag()` 函数本身。这可以直接放在我们在上一个任务中添加的 `locationAdd` 处理程序之后：
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Objective Complete - Mini Debriefing
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小型总结
- en: In this task we first updated the `addMarker()` function to bind each new marker
    to the `dragend` event, which will be fired once the marker stops being dragged.
    We specify the marker as the first argument to Google's `addListener()` method,
    which is the object to bind to the event. The name of the event, `dragend`, is
    specified as the second argument, and `markerDrag` as the name of the function
    that will handle the event.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们首先更新了 `addMarker()` 函数，将每个新的标记绑定到 `dragend` 事件上，该事件将在标记停止拖动时触发。我们将标记指定为
    Google 的 `addListener()` 方法的第一个参数，该方法是要绑定到事件的对象。事件的名称 `dragend` 被指定为第二个参数，`markerDrag`
    被指定为将处理事件的函数的名称。
- en: Then we added `markerDrag()` as a function expression. Because it's an event
    handler it will automatically be passed to the event object, which once again
    contains the `latLng` that we need to pass to a `Geocoder()` to get the new address
    that the marker was dragged to.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加了 `markerDrag()` 作为函数表达式。因为它是一个事件处理程序，所以它将自动传递给事件对象，该对象再次包含我们需要传递给 `Geocoder()`
    的 `latLng`。
- en: Inside the handler we first set a new variable that will be used as the selector
    for the element in the UI we want to update. Instead of concatenating a string
    together, we use the `array.join()` technique for performance reasons. The first
    and last items in the array we join are simply text.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理程序内，我们首先设置一个新变量，它将用作我们想要更新的 UI 元素的选择器。为了性能原因，我们使用 `array.join()` 技术来连接字符串，而不是将字符串连接在一起。我们连接的数组中的第一个和最后一个项目只是文本。
- en: The second item will be a string containing either `start` or `end` depending
    on which marker was dragged. Inside our event handler this refers to the marker,
    so we can use it get the custom `id` property that we added to each marker when
    it was created, allowing us to update the right element in the UI.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个项目将是一个字符串，其中包含 `start` 或 `end`，这取决于拖动了哪个标记。在我们的事件处理程序内部，这指的是标记，因此我们可以使用它获取我们在创建每个标记时添加的自定义
    `id` 属性，从而允许我们更新 UI 中的正确元素。
- en: Once we have constructed the selector we just get the street address using Google's
    `geocode()` method exactly as we did before, which will give us the new address
    of the marker after the drag.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构造了选择器，我们就可以像之前一样使用 Google 的 `geocode()` 方法来获取街道地址，这将给我们带来标记拖动后的新地址。
- en: Inside the callback function for `geocode()` we use the selector we just created
    to select the `<p>` element in the UI and update its text content to the newly
    geocoded address.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `geocode()` 的回调函数内，我们使用刚刚创建的选择器来选择 UI 中的 `<p>` 元素，并将其文本内容更新为新的地理编码地址。
- en: Now when we view the page, we should be able to add the markers to the map as
    before, then drag them around and see the new address in the UI area at the right
    of the page.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们查看页面时，我们应该能够像以前一样将标记添加到地图中，然后拖拽它们并在页面右侧的UI区域中看到新的地址。
- en: Factoring in weights
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑到重量
- en: We now have two addresses – the start and end markers for the journey. All the
    visitor needs to do now is enter a weight and we'll be able to calculate and display
    the distance and cost.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个地址——旅程的起点和终点标记。访客现在只需要输入一个重量，我们就能计算并显示距离和费用。
- en: Engage Thrusters
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'All we need to do in this task is add a handler for the `<input>` element in
    the UI area so that once a weight is entered the `<button>` becomes clickable.
    We can achieve this with the following code, which can be added directly after
    the `markerDrag()` function from the previous task:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这项任务中，我们所需要做的就是为UI区域中的`<input>`元素添加一个处理程序，这样一旦输入了重量，`<button>`就会变得可点击。我们可以通过以下代码实现这一点，直接添加到上一个任务中的`markerDrag()`函数之后：
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Objective Complete - Mini Debriefing
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成-迷你总结
- en: We can add the event handler for the user-generated `keyup` DOM event using
    jQuery's `on()` method. Using the `on()` method is now the standard way of attaching
    event handlers in jQuery. Old methods such as `live()` or `delegate()` have now
    been deprecated and should not be used.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用jQuery的`on()`方法为用户生成的`keyup` DOM事件添加事件处理程序。现在使用`on()`方法是在jQuery中附加事件处理程序的标准方法。旧的方法，如`live()`或`delegate()`现在已被弃用，不应再使用。
- en: Within the event handler we first check whether a timeout has been set, and
    if it has, we clear it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件处理程序内部，我们首先检查是否设置了一个超时，如果设置了，就清除它。
- en: We then cache a selector for the `<input>` element so that we can see it inside
    our `enableButton()` function. We add the `enableButton()` function, again as
    a function expression.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们缓存了`<input>`元素的选择器，以便我们可以在`enableButton()`函数中看到它。我们再次添加`enableButton()`函数，这次是作为函数表达式。
- en: All this function does is check whether the `<input>` element has a value, and
    if it does, we set the `disabled` property to `false` using jQuery's `prop()`
    method. If it doesn't have a value, we just disable it once more by setting the
    `disabled` property to `true`. Lastly we set a timeout using the JavaScript `setTimeout()`
    function, passing it the `enableButton()` function as the first argument. We set
    `250`, or a quarter of a second, as the timeout length. The timeout is stored
    in the `timeout` variable, ready for us to check the next time the function is
    executed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的作用只是检查`<input>`元素是否有值，如果有，我们使用jQuery的`prop()`方法将`disabled`属性设置为`false`。如果没有值，我们再次通过将`disabled`属性设置为`true`来禁用它。最后，我们使用JavaScript的`setTimeout()`函数设置了一个超时，将`enableButton()`函数作为第一个参数传递给它。我们将`250`，或四分之一秒，作为超时长度。超时存储在`timeout`变量中，准备好在下次函数被执行时检查。
- en: Classified Intel
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机密情报
- en: The reason we use the timeout here is to rate-limit the number of times the
    `enableButton()` function is executed. The function will be invoked after every
    character is entered into the field.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用超时的原因是为了限制`enableButton()`函数被执行的次数。每输入一个字符后，函数就会被调用。
- en: A quarter of a second is a barely discernible delay, but if someone types a
    long number into the field quickly, it can drastically reduce the number of times
    the function runs. Within the function, we select an element from the page and
    create a jQuery object. That's not too intense and in this example we probably
    don't even need to worry about it. But using a timeout like this is a robust solution
    that can help out when doing more intense operations inside a frequently fired
    event handler.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 四分之一秒的延迟几乎是难以察觉的，但如果有人快速在字段中输入了一个长数字，它就会大大减少函数运行的次数。在函数内部，我们从页面中选择一个元素并创建一个jQuery对象。这并不太过于密集，而且在这个例子中我们可能甚至不需要担心它。但像这样使用超时是一个健壮的解决方案，可以帮助在频繁触发的事件处理程序内执行更加密集的操作时提供帮助。
- en: We could have just used jQuery's `one()` method to attach an event handler that
    simply enables the `<button>` and then removes itself. However, this wouldn't
    allow us to disable the `<button>` once more if the figure entered into the field
    is removed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本来可以只使用jQuery的`one()`方法来附加一个事件处理程序，它只是简单地启用`<button>`，然后自行删除。但是，这样就不允许我们在字段中输入的数字被移除后再次禁用`<button>`。
- en: Displaying the projected distance and cost
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示预计距离和费用
- en: Our last task in this project is to get the distance between the two markers
    and calculate the cost of the journey. Once calculated, we should probably display
    the results to the visitor too.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个项目中的最后一个任务是获取两个标记之间的距离并计算旅程的成本。一旦计算出来，我们可能也应该向访问者显示结果。
- en: Engage Thrusters
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'First we should attach a click event handler for our `<button>`. Add the following
    code directly after the handler for the `keyup` event that we added in the last
    task:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该为我们的`<button>`附加一个点击事件处理程序。在我们在上一个任务中添加的`keyup`事件处理程序之后，直接添加以下代码：
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next we can get the distance between the two points. Directly after the `remove()`
    method we just added (but still inside the click handler function), add the following
    code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以获取两点之间的距离。在我们刚刚添加的`remove()`方法之后（但仍在点击处理程序函数内部），添加以下代码：
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we just need to compute and display the cost, which we can do by adding
    the following code to the empty callback function we just added. First we can
    add the variables we''ll need:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要计算并显示成本，我们可以通过添加以下代码到我们刚刚添加的空回调函数来完成。首先我们可以添加我们需要的变量：
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next we can generate the HTML structure that we''ll use to display the computed
    figures:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们可以生成用于显示计算出的数字的HTML结构：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Lastly, we should probably add some additional styling for the new elements
    that we just created and added to the page. At the bottom of `google-map.css`,
    add the following new styles:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可能应该为我们刚刚创建并添加到页面中的新元素添加一些额外的样式。在`google-map.css`的底部，添加以下新样式：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Objective Complete - Mini Debriefing
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小结
- en: We started out by binding a click event handler to the `body` of the page using
    jQuery's `on()` method. This time we use the 3-argument form of the method where
    the first argument is still the name of the event, the second argument is a selector
    to filter the event by, and the third argument is the function to trigger when
    the event occurs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用jQuery的`on()`方法将点击事件处理程序绑定到页面的`body`上。这次我们使用了该方法的三个参数形式，其中第一个参数仍然是事件的名称，第二个参数是用于筛选事件的选择器，第三个参数是事件发生时触发的函数。
- en: Events in JavaScript bubble up through their containers and when the event hits
    the `body`, it will be filtered by the selector used as the second argument and
    the function will only be executed if it was dispatched by an element that matches
    the selector. In this example, only events dispatched by the `<button>` will trigger
    the function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的事件会通过它们的容器冒泡，并且当事件到达`body`时，它将被第二个参数用作筛选器过滤，并且只有当它是由与选择器匹配的元素分派时，函数才会被执行。在这个示例中，只有由`<button>`分派的事件才会触发该函数。
- en: Using the `on()` method in this form gives us a means of employing powerful
    event delegation that allows us to bind events for elements which may or may not
    exist at the time of the binding.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种形式的`on()`方法为我们提供了一种使用强大的事件委托的方法，这使我们能够为可能存在也可能不存在的元素绑定事件。
- en: Within the handler function, we first prevent the default behavior of the browser.
    There shouldn't be any default behavior because we don't have a `<form>` on the
    page so there is nothing for the `<button>` to submit. But if someone were to
    try and run this on an ASPX page, which usually does have a `<form>` enclosing
    most, if not all, of the elements on the page, it could behave in unexpected ways.
    Unless strictly necessary, `preventDefault()` should always be used.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理程序函数中，我们首先阻止了浏览器的默认行为。因为页面上没有`<form>`，所以不应该有任何默认行为，因此`<button>`没有什么可提交的。但是如果有人试图在一个通常包含页面上大多数甚至所有元素的`<form>`的ASPX页面上运行这个，它可能会以意想不到的方式行事。除非绝对必要，否则应始终使用`preventDefault()`。
- en: We then remove the `<button>` from the page. Note that even though the event
    handler is bound to the `<body>`, the `this` object inside the handler function
    still points at the `<button>` element that triggered the event.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们从页面中移除了`<button>`。请注意，尽管事件处理程序绑定到了`<body>`，但处理程序函数内部的`this`对象仍指向触发事件的`<button>`元素。
- en: We then used another of Google's APIs – the `DistanceMatrixService()`, which
    allows us to compute the distance between two or more points on the map. Because
    we don't need to reference the object returned by the `DistanceMatrixService()`
    constructor, we can chain the `getDistanceMatrix()` method directly onto it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用了Google的另一个API - `DistanceMatrixService()`，它允许我们在地图上计算两个或多个点之间的距离。因为我们不需要引用`DistanceMatrixService()`构造函数返回的对象，所以我们可以直接将`getDistanceMatrix()`方法链接到它上面。
- en: This method takes two arguments with the first being a configuration object
    and the second a callback function to execute when the method returns. The callback
    function will automatically be passed an object containing the response.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法有两个参数，第一个参数是一个配置对象，第二个参数是一个方法返回时执行的回调函数。回调函数会自动传入一个包含响应的对象。
- en: We set several configuration options using the first argument. The `origins`
    and `destinations` options both take arrays where each item in each array is a
    `latLng` object. We can easily get the `latLng` objects for both of the markers
    using the custom `data-latLng` attribute that we set when we showed the addresses.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用第一个参数来设置几个配置选项。`origins`和`destinations`选项都采用了数组的形式，其中每个数组中的每个项目都是一个`latLng`对象。我们可以使用自定义的`data-latLng`属性，它在显示地址时设置，很容易地获取这两个标记的`latLng`对象。
- en: We also set the `travelMode` option to the distance it would be via road using
    the `google.maps.TravelMode.DRIVING` constant, and set the `unitSystem` option
    to `google.maps.UnitSystem.IMPERIAL` to give a distance in miles instead of kilometers,
    for no other reason than because I'm a Brit, and I'm used to using miles.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`travelMode`选项设置为通过道路行驶的距离，使用`google.maps.TravelMode.DRIVING`常量，并将`unitSystem`选项设置为`google.maps.UnitSystem.IMPERIAL`，以获得英里而不是公里的距离，除了因为我是英国人，习惯使用英里之外，并没有其他原因。
- en: The callback function we supply is automatically passed a results object that
    contains, of course, the results returned by the distance matrix. The first half
    of the callback function is concerned with creating variables and computing values.
    The second part of the function deals with displaying the information that has
    been computed.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供的回调函数会自动传入一个结果对象，其中包含了距离矩阵返回的结果。回调函数的前半部分涉及创建变量和计算值。函数的后半部分处理显示已计算的信息。
- en: We first create a new `<dl>` element and give it a `class` that is required
    for use with our `common.css` style sheet, and an `id` attribute, mostly for decorative
    styling. Then we add a simple function expression that receives a number as an
    argument, rounds it, and then fixes it to two decimal places before returning
    it. We'll use this function to ensure that our financial figures are in the required
    format.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的`<dl>`元素，并给它一个`class`，这是在`common.css`样式表中需要使用的，以及一个`id`属性，主要用于装饰性样式。然后我们添加一个简单的函数表达式，接收一个数字作为参数，对其四舍五入，然后将其修正为两位小数，最后返回它。我们将使用这个函数来确保我们的财务数字符合要求的格式。
- en: We also create a new `<dt>` element and a new `<dd>` element that we can clone
    as many times as required without having to repeatedly create new instances of
    jQuery, and then store the value entered into the weight text field using jQuery's
    `val()` method.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个新的`<dt>`元素和一个新的`<dd>`元素，可以根据需要克隆多次，而无需反复创建新的jQuery实例，然后使用jQuery的`val()`方法存储在重量文本字段中输入的值。
- en: Next we extract the `distance` property from the object passed to the callback
    function. Its structure may look complex, as the object we are actually interested
    in for this example is buried within a multidimensional array, but as the method's
    name suggests, it is able to return a complex matrix of results for multiple origins
    and destinations.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从传递给回调函数的对象中提取`distance`属性。它的结构可能看起来复杂，因为我们实际上感兴趣的对象被埋在一个多维数组中，但正如方法的名字所暗示的，它能够返回多个起点和目的地的复杂结果矩阵。
- en: Following this we concatenate a string that includes the `text` property of
    the `distance` object that we just stored and the full word `miles`. The distance
    matrix returns imperial results as `mi` instead of the full `miles`, so we add
    the string `les` to the end of the value.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们连接一个字符串，其中包括我们刚刚存储的`distance`对象的`text`属性和完整的单词`miles`。距离矩阵以`mi`的形式返回英里的结果，因此我们在值的末尾添加字符串`les`。
- en: We then get the numerical distance by splitting the string on the space between
    the number of miles and the letters `mi`. JavaScript's `split()` function will
    return an array of two items containing the part of the string up to, but not
    including, the split-character and the part after the split-character. We are
    only interested in the first item in this array, and also use JavaScript's `parseFloat()`
    function to ensure that this value is definitely a number and not a string.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过在英里数量和字母`mi`之间进行拆分来获取数字距离。JavaScript的`split()`函数会返回一个包含字符串部分的数组，该数组包含了拆分字符的前端，但不包括拆分字符和拆分字符后的部分。我们只对数组中的第一个项目感兴趣，并且使用JavaScript的`parseFloat()`函数来确保这个值绝对是一个数字而不是一个字符串。
- en: Now we have enough information to actually work out the cost of the journey.
    We've specified the charge per mile to be £3 so we multiply the distance by `3`
    and pass the result to our `format()` function so that the number is in the correct
    format.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有足够的信息来实际计算旅程的费用了。我们指定了每英里的费用为 £3，所以我们将距离乘以 `3`，然后将结果传递给我们的`format()`函数，以便数字的格式正确。
- en: We can also work out the charge per kilogram per mile in a very similar way,
    first multiplying the weight by the cost per kilogram, then multiplying by the
    distance. Again we pass this figure into our `format()` function. Then we can
    work out the total cost by adding these two figures together. The figures that
    we've been working with somehow become strings. To fix this, we can still use
    our `format()` function, but we prefix each of the values we want to add with
    the `+` character, which will force them to be numbers and not strings.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过非常类似的方式计算每千克每英里的费用，首先将重量乘以每千克的成本，然后乘以距离。再次将这个数字传递给我们的`format()`函数。然后，我们可以通过将这两个数字相加来计算总费用。我们一直在使用的数字变成了字符串。为了解决这个问题，我们仍然可以使用我们的`format()`函数，但是我们需要使用`+`字符作为我们要添加的每个值的前缀，这将强制它们成为数字而不是字符串。
- en: Once we have created the figures we wish to display, we can then create the
    new elements that we need to use to display them, starting with a nice heading
    to help clarify the new set of information we're adding to the UI.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了要显示的图形，我们就可以创建我们需要用来显示它们的新元素，首先是一个漂亮的标题，以帮助澄清我们正在添加到 UI 的新信息集。
- en: 'We can then create the clones of the `<dt>` and `<dd>` elements which hold
    each label and figure. Once these have been created, we append them to the `<dl>`
    element we created, before finally appending the new list as a whole to the UI,
    as shown in the following screenshot:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以创建包含每个标签和图形的`<dt>`和`<dd>`元素的克隆。一旦这些被创建，我们就将它们附加到我们创建的`<dl>`元素上，然后最终将新列表作为一个整体附加到
    UI 上，如下图所示：
- en: '![Objective Complete - Mini Debriefing](img/9106OS_03_03.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![目标完成 - 小结](img/9106OS_03_03.jpg)'
- en: Classified Intel
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机密情报
- en: The astute of you will notice that the number rounding solution we've used in
    this example isn't that robust, and won't round all fractions as precisely (or
    correctly) as would be required for a genuine system that deals with real currency.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 机敏的你会注意到，我们在这个例子中使用的数值舍入解决方案并不那么健壮，并且不会像真实处理实际货币所需的那样准确（或正确地）舍入所有分数。
- en: JavaScript does not handle floating point arithmetic as gracefully as some other
    languages do, and so creating the perfect rounding system that rounds correctly
    100 percent of the time is beyond the scope of this book.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 不像其他一些语言那样优雅地处理浮点运算，因此创建一个完美的舍入系统，100% 正确地舍入是超出了本书范围的。
- en: 'For those who are interested, the stackoverflow site has some extremely illuminating
    answers posted to questions around currency formatting in JavaScript. For example,
    see: [http://stackoverflow.com/questions/149055/how-can-i-format-numbers-as-money-in-javascript](http://stackoverflow.com/questions/149055/how-can-i-format-numbers-as-money-in-javascript).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些感兴趣的人，stackoverflow 网站上发布了一些极具启发性的关于 JavaScript 货币格式化的问题的答案。例如，参见：[http://stackoverflow.com/questions/149055/how-can-i-format-numbers-as-money-in-javascript](http://stackoverflow.com/questions/149055/how-can-i-format-numbers-as-money-in-javascript)。
- en: Mission Accomplished
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务完成
- en: 'We''ve covered a lot of both Google and jQuery functionality in this project.
    Specifically we looked at the following subjects:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们涵盖了大量的 Google 和 jQuery 功能。具体来说，我们研究了以下主题：
- en: Adding markers and overlays to the map using the `Marker()` and `InfoWindow()`
    constructors.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Marker()`和`InfoWindow()`构造函数将标记和覆盖物添加到地图上。
- en: Reacting to map-driven events such as clicks on markers or marker drags. Event
    handlers are attached using the `addListener()` method of the `google.maps` API.
    We also saw how to fire custom events using the `trigger()` method.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对地图驱动事件的反应，比如点击标记或标记拖动。事件处理程序使用`google.maps`API的`addListener()`方法附加。我们还看到如何使用`trigger()`方法触发自定义事件。
- en: Using Google's services to manipulate the data generated by the map. The services
    we used were the `Geocoder()` to reverse-geocode the `latLng` of each point on
    the map that was clicked in order to obtain its address, and the `DistanceMatrixService()`
    to determine the distance between the points.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Google 的服务来操作地图生成的数据。我们使用的服务是`Geocoder()`，用于反向地理编码地图上每个点击的点的`latLng`，以获取其地址，以及`DistanceMatrixService()`，用于确定点之间的距离。
- en: Taking advantage of jQuery's event capabilities to add both standard and delegated
    events using the `on()` method to detect when different parts of our UI were interacted
    with, such as the `<button>` being clicked or the `<input>` being typed into.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用jQuery的事件功能，使用`on()`方法添加标准事件和委托事件，以便检测UI的不同部分与之交互的情况，比如点击`<button>`或输入`<input>`。
- en: Using jQuery's powerful DOM manipulation methods to update the UI with addresses
    and the quote. We used a range of these methods including `clone()`, `html()`,
    `text()`, and `prop()`, as well both selecting and creating new elements.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jQuery强大的DOM操作方法来更新UI，包括地址和报价。我们使用了一系列这些方法，包括`clone()`，`html()`，`text()`和`prop()`，既选择又创建新元素。
- en: You Ready To Go Gung HO? A Hotshot Challenge
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你准备好全力以赴了吗？一个火热的挑战
- en: In this example, visitors are only able to generate a single quote. Once the
    `getQuote` `<button>` is clicked, the results are displayed and no further interaction
    is possible. Why don't you change it so that a reset button is added to the UI
    when the quote is generated? The visitor can then clear the quote and the markers
    from the map and start over from scratch.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，访客只能生成一份报价。一旦点击`getQuote` `<button>`，结果就会显示，不再允许进一步交互。为什么不在生成报价时添加一个重置按钮到UI？访客可以清除报价和地图上的标记，从头开始。
