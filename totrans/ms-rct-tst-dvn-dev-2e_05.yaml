- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding Complex Form Interactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s time to apply what you’ve learned to a more complicated HTML setup. In
    this chapter, we’ll test-drive a new component: `AppointmentForm`. It contains
    a select box, for selecting the service required, and a grid of radio buttons
    that form a calendar view for selecting the appointment time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Combining both layout and form input, the code in this chapter shows how TDD
    gives you a structure for your work that makes even complicated scenarios straightforward:
    you will use your tests to grow the component into a component hierarchy, splitting
    out functionality from the main component as it begins to grow.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a value from a select box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing a calendar view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-driving radio button groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing effort when constructing components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you’ll have learned how to apply test-driven development
    to complex user input scenarios. These techniques will be useful for all kinds
    of form components, not just select boxes and radio buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a value from a select box
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start by creating a component for booking new appointments, named `AppointmentForm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first field is a select box for choosing which service the customer requires:
    cut, color, blow-dry, and so on. Let’s create that now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `test/AppointmentForm.test.js`, with the following test
    and setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make this test pass by implementing and creating a new file, `src/AppointmentForm.js`,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a nested `describe` block for the service field. We’ll jump to this
    right away because we know this form will have multiple fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following test to the `describe` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this test pass, modify the `AppointmentForm` component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests and ensure they are all passing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that, we’ve done the basic scaffolding for the new select box field so
    that it’s ready to be populated with `option` elements.
  prefs: []
  type: TYPE_NORMAL
- en: Providing select box options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our salon provides a whole range of salon services. We should ensure that they
    are all listed in the app. We could start our test by defining our expectations,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do this, we’ll end up repeating the same array of services in our test
    code and our production code. We can avoid that repetition by focusing our unit
    tests on the *behavior* of the select box rather than the static data that populates
    it: what should the select box *do*?'
  prefs: []
  type: TYPE_NORMAL
- en: 'As it turns out, we can specify the functionality of our select box with just
    *two* items in our array. There’s another good reason for keeping it to just two,
    which is that keeping the array brief helps us focus the test on what’s important:
    the behavior, not the data.'
  prefs: []
  type: TYPE_NORMAL
- en: That leaves the question, how do we use only two items in our test when we need
    six items for the production code?
  prefs: []
  type: TYPE_NORMAL
- en: We’ll do this by introducing a new prop, `selectableServices`, to `AppointmentForm`.
    Our tests can choose to specify a value if they need to. In our production code,
    we can specify a value for the component’s `defaultProps`.
  prefs: []
  type: TYPE_NORMAL
- en: '`defaultProps` is a nifty mechanism that React offers for setting default prop
    values that will be used when required props are not explicitly provided.'
  prefs: []
  type: TYPE_NORMAL
- en: For our tests that *don’t* care about the select box values, we can avoid passing
    the prop and ignore it entirely in the test. For the tests that *do* care, we
    can provide a short, two-item array for our tests.
  prefs: []
  type: TYPE_NORMAL
- en: How do we verify the real select box values?
  prefs: []
  type: TYPE_NORMAL
- en: Testing static data does happen, just not within our unit tests. One place this
    can be tested is within acceptance tests, which we’ll look at in *Part 4, Behavior-Driven
    Development with Cucumber*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start with a test to ensure the first value is a blank entry. This is
    the value that’s initially selected when the user creates a new appointment: no
    option is selected. Let’s write that test now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test at the end of the `AppointmentForm` test suite. It specifies
    that the very first item in the select box is blank, meaning the user is not automatically
    assigned a choice from our list of services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by adding a blank `option` element to the existing `select`
    element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back in your tests, add this new helper just after the `beforeEach` block.
    We’ll make use of it in our next test to build an array of all the labels of the
    select box options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following test. This makes use of a new prop, `selectableServices`,
    which is simply the array of available options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Choosing test data
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve used “real” data for my expected services: `Cut` and `Blow-dry`. It’s
    also fine to use non-real names such as `Service A` and `Service B`. Often, that
    can be more descriptive. Both are valid approaches.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make this pass. Change the component definition, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Check that the latest test now passes. However, you will see that our earlier
    tests break because of the introduction of the new prop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can make these tests pass again using `defaultProps`. Just below the definition
    of the `AppointmentForm` function in `src/AppointmentForm.js`, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run your tests and verify they are passing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s all there is to it. With that, we’ve learned how to define the behavior
    of our component using a short two-item array and saved the real data for `defaultProps`.
  prefs: []
  type: TYPE_NORMAL
- en: Preselecting a value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s ensure that our component preselects the value that has already been
    saved if we’re editing an existing appointment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a `findOption` arrow function at the top of the `describe` block. This
    function searches the DOM tree for a particular text node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our next test, we can find that node and then check that it is selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this pass, set the value property on the root `select` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Accessible rich internet applications (ARIA) labels
  prefs: []
  type: TYPE_NORMAL
- en: If you have experience with building React applications, you may be expecting
    to set the `aria-label` property on the `select` element. However, one of this
    chapter’s *Exercises* is to add a label element for this `select` box that will
    ensure an ARIA label is set implicitly by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need to change your component props so that it includes the new `service`
    prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run your tests. Although this test is now passing, you’ll find the previous
    tests are failing because the original prop has not been set. To fix them, first,
    define a new constant, `blankAppointment`, just above your `beforeEach` block.
    We’ll use this in each of the failing tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update your previous tests so that they use this new constant as the value
    for the `original` prop. For example, the very first test for `AppointmentForm`
    will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests again with `npm test`; all your tests should be passing. (If they
    aren’t, go back and check that you’ve got an `original` prop value for each test.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s finish with a small bit of refactoring. Your last two tests both have
    the same definition for services. Pull that out of each test, placing it above
    the definition of `blankAppointment`. Make sure that you delete that line from
    both tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That completes this test, but there is still more functionality to add if we
    want a fully functional select box. Completing those tests is left as one of the
    *Exercises* at the end of this chapter. They work the same as the tests for the
    text boxes in `CustomerForm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you compare our select box tests to those of the text box, you will see
    that it’s a similar pattern but with a couple of additional techniques: we used
    `defaultProps` to separate the definition of production data from test behavior,
    and we defined a couple of localized helper methods, `labelsOfAllOptions` and
    `findOption`, to help keep our tests short.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move on to the next item in our form: the time of the appointment.'
  prefs: []
  type: TYPE_NORMAL
- en: Constructing a calendar view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll learn how to use our existing helpers, such as `element`
    and `elements`, mixed with CSS selectors, to select specific elements we’re interested
    in within our HTML layout.
  prefs: []
  type: TYPE_NORMAL
- en: But first, let’s start with some planning.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’d like `AppointmentForm` to display available time slots over the next 7
    days as a grid, with columns representing days and rows representing 30-minute
    time slots, just like a standard calendar view. The user will be able to quickly
    find a time slot that works for them and then select the right radio button before
    submitting the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The visual design of our calendar view ](img/Figure_5.01_B18423.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – The visual design of our calendar view
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of the HTML structure that we’re aiming to build. We can
    use this as a guide as we write out our React component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the next few sections, we’ll test-drive the `table` element itself, then
    build a header column for times of the day, and then a header for days of the
    week.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s begin by building `table` itself:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a nested `describe` block with a new test at the bottom of `test/AppointmentForm.test.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ll need to pull the `element` helper into your imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, move to `src/AppointmentForm.js` and define a new `TimeSlotTable`
    component, above the definition of `AppointmentForm`. We don’t need to mark this
    one as an export as it will only be referenced by `AppointmentForm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Why add an ID?
  prefs: []
  type: TYPE_NORMAL
- en: The ID is important because that’s what the application’s CSS uses to find the
    `table` element. Although it’s not covered in this book, if you’re using CSS and
    it defines selectors based on element IDs, then you should treat those IDs as
    a kind of technical specification that your code must satisfy. That’s why we write
    unit tests for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this component to your `AppointmentForm` JSX, right at the bottom, just
    below the `select` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests and verify that they are all passing.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all there is to the `table` element. Now, let’s get some data into the
    first column.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a header column
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the next test, we’ll test the left-hand header column that displays a list
    of times. We’ll introduce two new props, `salonOpensAt` and `salonClosesAt`, which
    inform the component of which time to show each day. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Asserting on array patterns
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are checking `textContent` on *three* array entries, even
    though there are four entries in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Properties that are the same for all array entries only need to be tested on
    one entry. Properties that vary per entry, such as `textContent`, need to be tested
    on two or three entries, depending on how many you need to test a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: For this test, I want to test that it starts and ends at the right time and
    that each time slot increases by 30 minutes. I can do that with assertions on
    array entries 0, 1, and 3.
  prefs: []
  type: TYPE_NORMAL
- en: This test “breaks” our rule of one expectation per test. However, in this scenario,
    I think it’s okay. An alternative approach might be to use the `textOf` helper
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need to pull the `elements` helper into your imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this pass, add the following functions above the `TimeSlotTable` component.
    They calculate the list of daily time slots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `toTimeValue` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can make use of those two functions. Update `TimeSlotTable` so that
    it reads as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the JSX for `AppointmentForm`, pass the `salonOpensAt` and `salonClosesAt`
    props to `TimeSlotTable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fill in `defaultProps` for both `salonOpensAt` and `salonsCloseAt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests and make sure everything is passing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s all there is to adding the left-hand side column of headings.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a header row
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, what about the column headings? In this section, we’ll create a new top
    row that contains these cells, making sure to leave an empty cell in the top-left
    corner, since the left column contains the time headings and not data. Follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the table JSX so that it includes a new table row:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the rest of the header row, we’ll show the 7 days starting from today.
    `AppointmentForm` will need to take a new prop, `today`, which is the first day
    to display within the table. The value that’s assigned to that prop is stored
    in a variable named `specificDate`. This name has been chosen to highlight the
    fact that this chosen date affects the rendered day output, for example, `"Sat
    01"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Why pass a date into the component?
  prefs: []
  type: TYPE_NORMAL
- en: When you’re testing a component that deals with dates and times, you almost
    always want a way to control the time values that the component will see, as we
    have in this test. You’ll rarely want to just use the real-world time because
    that can cause intermittent failures in the future. For example, your test may
    assume that a month has at least 30 days in the year, which is only true for 11
    out of 12 months. It’s better to fix the month to a specific month rather than
    have an unexpected failure when February comes around.
  prefs: []
  type: TYPE_NORMAL
- en: For an in-depth discussion on this topic, take a look at [https://reacttdd.com/controlling-time](https://reacttdd.com/controlling-time-within-unit-tests/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To make that pass, first, create a function that lists the 7 days we’re after,
    in the same way we did with time slots. You can place this just after the `toTimeValue`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `toShortDate` function, which formats our date as a short string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify `TimeSlotTable` so that it takes the new `today` prop and uses the two
    new functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within `AppointmentForm`, pass the `today` prop from `AppointmentForm` into
    `TimeSlotTable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add a `defaultProp` for `today`. Set it to the current date by calling
    the `Date` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests. They should be all green.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that, we’re done with our table layout. You’ve seen how to write tests
    that specify the table structure itself and fill in both a header column and a
    header row. In the next section, we’ll fill in the table cells with radio buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Test-driving radio button groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our table with headings in place, it’s time to add radio buttons
    to each of the table cells. Not all cells will have radio buttons – only those
    that represent an available time slot will have a radio button.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means we’ll need to pass in another new prop to `AppointmentForm` that
    will help us determine which time slots to show. This prop is `availableTimeSlots`,
    which is an array of objects that list times that are still available. Follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test, which establishes a value for the `availableTimeSlots`
    prop and then checks that radio buttons have been rendered for each of those slots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice that this test uses a `cellsWithRadioButtons` helper, which we need
    to define now. You can place this just above the test; there’s no need to move
    it to the extension’s module since it’s specific to this one component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This test checks that there are radio buttons in the first two time slots for
    today. These will be in cells 0 and 7 since `elements` returns matching elements
    in page order. We can make this test pass very simply by adding the following
    to our `AppointmentForm` render method, just below `th` within each `tr`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, your test will be passing.
  prefs: []
  type: TYPE_NORMAL
- en: We didn’t need to use `availableTimeSlots` in our production code, even though
    our tests require it! Instead, we just put a radio button in *every* cell! This
    is obviously “broken.” However, if you think back to our rule of only ever implementing
    the simplest thing that will make the test pass, then it makes sense. What we
    need now is another test to prove the opposite – that certain radio buttons do
    *not* exist, given `availableTimeSlots`.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding input controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How can we get to the right implementation? We can do this by testing that
    having no available time slots renders no radio buttons at all:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, first, move to `src/AppointmentForm.js` and define the `mergeDateAndTime`
    function above the `TimeSlotTable` component. This takes the date from a column
    header, along with a time from a row header, and converts them into a timestamp
    that we can use to compare against the `startsAt` fields in `availableTimeSlots`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `TimeSlotTable` so that it takes the new `availableTimeSlots` prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the existing radio button element in `TimeSlotTable` with a JSX conditional:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, update `AppointmentForm` so that it takes the new prop, and then pass
    it through to `TimeSlotTable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Although your test will now be passing, the rest will be failing: they need
    a value for the `availableTimeSlots` prop. To do that, first, add the following
    definitions to the top of `AppointmentForm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go through each test and update each call to render to specify an `availableTimeSlots`
    prop with a value of `availableTimeSlots`. For example, the first test should
    have the following render call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Handling sensible defaults for props
  prefs: []
  type: TYPE_NORMAL
- en: Adding a default value for a new prop in every single test is no one’s idea
    of fun. Later in this chapter you'll learn how to avoid prop explosion in your
    tests by introducing a `testProps` object to group sensible default prop values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue with the next test. We must ensure each radio button has the
    correct value. We’ll use the `startsAt` value for each radio button’s value. Radio
    button values are strings, but the appointment object property, `startsAt`, is
    a number. We’ll use a standard library function, `parseInt`, to convert the button
    value back into a usable number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Defining constants within tests
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it’s preferable to keep constants within a test rather than pulling
    them out as helpers. In this case, these helpers are only used by this one test
    and are very specific in what they do. Keeping them inline helps you understand
    what the functions are doing without having to search through the file for the
    function definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your production code, pull out the ternary that contained the original call
    to `mergeDateAndTime` into a new component. Take care to add the new `name` and
    `value` attributes to the `input` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The name property
  prefs: []
  type: TYPE_NORMAL
- en: Radio buttons with the same `name` attribute are part of the same group. Clicking
    one radio button will check that button and uncheck all others in the group.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now use this within `TimeSlotTable`, replacing the existing ternary
    with an instance of this functional component. After this, your tests should be
    passing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that you’ve got the radio buttons displaying correctly, it’s time to give
    them some behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a radio button in a group
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s see how we can use the `checked` property on the input element to ensure
    we set the right initial value for our radio button.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we’ll use a helper called `startsAtField` that takes an index and
    returns the radio button at that position. To do that, the radio buttons must
    all be given the same name. This joins the radio button into a group, which means
    only one can be selected at a time. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding the `startsAtField` helper at the top of the time slot table’s
    `describe` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following test. It passes in an existing appointment with a `startsAt`
    value set to the second item in the `availableTimeSlots` list. Choosing the second
    item rather than the first isn’t strictly necessary (since the default will be
    for *all* radio buttons to be unchecked), but it can help highlight to future
    maintainers that a specific value has been chosen and is being checked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, first, add a new `checkedTimeSlot` prop to `TimeSlotTable`
    that has the value of the original `startsAt` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `TimeSlotTable` so that it makes use of this new prop, passing it through
    to `RadioButtonIfAvailable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can make use of that in `RadioButtonIfAvailable`, setting the `isChecked`
    prop on the input element, as shown here. After this change, your test should
    be passing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s it for setting the initial value. Next, we’ll hook up the component with
    the `onChange` behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Handling field changes through a component hierarchy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we have slowly built up a component hierarchy: `AppointmentForm`
    renders a `TimeSlotTable` component that renders a bunch of `RadioButtonIfAvailable`
    components that may (or may not) render the radio button input elements.'
  prefs: []
  type: TYPE_NORMAL
- en: The final challenge involves how to take an `onChange` event from the input
    element and pass it back up to `AppointmentForm`, which will control the appointment
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in this section will make use of the `useCallback` hook. This is a
    form of performance optimization: we can’t write a test to specify that this behavior
    exists. A good rule of thumb is that if you’re passing functions through as props,
    then you should consider using `useCallback`.'
  prefs: []
  type: TYPE_NORMAL
- en: The useCallback hook
  prefs: []
  type: TYPE_NORMAL
- en: The `useCallback` hook returns a `TimeSlotTable`) would re-render each time
    the parent re-renders, because the different reference would cause it to believe
    that a re-render was required.
  prefs: []
  type: TYPE_NORMAL
- en: Event handlers on `input` elements don’t need to use `useCallback` because event
    handler props are handled centrally; changes to those props do not require re-renders.
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter to `useCallback` is the set of dependencies that will cause
    `useCallback` to update. In this case, it’s `[]`, an empty array, because it isn’t
    dependent on any props or other functions that may change. Parameters to the function
    such as `target` don’t count, and `setAppointment` is a function that is guaranteed
    to remain constant across re-renders.
  prefs: []
  type: TYPE_NORMAL
- en: See the *Further reading* section at the end of this chapter for a link to more
    information on `useCallback`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we haven’t done any work on submitting `AppointmentForm` yet, we need
    to start there. Let’s add a test for the form’s submit button:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test to your `AppointmentForm` test suite, which tests for
    the presence of a submit button. This can go at the top of the test suite, just
    underneath the `renders a form` test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ll also need to import the `submitButton` helper into your tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, add the button at the bottom of your `AppointmentForm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the next test, let’s submit the form and check that we get the original
    `startsAt` value submitted back. We’ll use the same `expect.hasAssertions` technique
    that we saw in the previous chapter. The test verifies that the `onSubmit` prop
    was called with the original, unchanged `startsAt` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since this test uses the `click` helper, you’ll need to import it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For this test, all we need is to get the form’s `onSubmit` event handler in
    place. At this stage, it will simply submit the `original` object without any
    registered changes. Update the `AppointmentForm` component, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With that test passing, let’s add the final test. This uses a `click` action
    rather than `change`, which we used for the text box and select box. We click
    on the desired radio button just as a user would:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, the fun begins. Let’s work from the top down: we’ll start by defining
    a new `appointment` state object, which we’ll then use in a new event handler
    that modifies the current appointment when a radio button is clicked. Move to
    `src/AppointmentForm.js` and update your React import so that it reads as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Introduce a new `appointment` state object and update your `checkedTimeSlot`
    prop to use this object, rather than the `original` prop value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `handleSubmit` function so that it uses `appointment` rather than
    `original`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The call to preventDefault
  prefs: []
  type: TYPE_NORMAL
- en: I’m avoiding writing the test for `preventDefault` since we’ve covered it previously.
    In a real application, I would almost certainly add that test again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time for the new event handler. This is the one that makes use of
    `useCallback` so that we can safely pass it through to `TimeSlotTable` and beyond.
    Add the following definition just below the `useState` call you added in the previous
    step. The handler uses `parseInt` to convert between our radio button’s string
    value and the numeric timestamp value we’ll be storing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ve got to weave the event handler through to the `input` element, just like
    we did with `checkedTimeSlot`. Start by passing it into `TimeSlotTable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, update `TimeSlotTable`, taking that prop and passing it through to `RadioButtonIfAvailable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, in `RadioButtonIfAvailable`, remove the `readOnly` property on the
    input field and set `onChange` in its place:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, your test should pass, and your time slot table should be fully
    functional.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section has covered a great deal of code: conditionally rendering `input`
    elements, as well as details of radio button elements, such as giving a group
    `name` and using the `onChecked` prop, and then passing its `onChange` event through
    a hierarchy of components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a good moment to manually test what you’ve built. You’ll need to update
    `src/index.js` so that it loads `AppointmentForm`, together with sample data.
    These changes are included in the `Chapter05/Complete` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – AppointmentForm on show ](img/Figure_5.02_B18423.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – AppointmentForm on show
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now completed the work required to build the radio button table. Now
    it’s time to refactor.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing effort when constructing components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s look at a couple of simple ways to reduce the amount of time and code
    needed for test suites like the one we’ve just built: first, extracting builder
    functions, and second, extracting objects to store sensible defaults for our component
    props.'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting test data builders for time and date functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve already seen how we can extract reusable functions into namespaces of
    their own, such as the `render`, `click`, and `element` DOM functions. A special
    case of this is the **builder** function, which constructs objects that you’ll
    use in the **Arrange** and **Act** phases of your test.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of these functions is not just to remove duplication but also for
    simplification and to aid with comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have one candidate in our test suite, which is the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll update our test suite so that it uses a builder function called `todayAt`,
    which will save a bit of typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We’ll also extract the `today` value as a constant as we’ll also make use of
    that.
  prefs: []
  type: TYPE_NORMAL
- en: Builders for domain objects
  prefs: []
  type: TYPE_NORMAL
- en: Most often, you’ll create builder functions for the domain objects in your code
    base. In our case, that would be `customer` or `appointment` objects, or even
    the time slot objects with the single `startsAt` field. Our code base hasn’t progressed
    enough to warrant this, so we’ll start with builders for the `Date` objects that
    we’re using. We’ll write more builders later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory, `test/builders`. This is where all our `builder` functions
    will live.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file, `test/builders/time.js`. This is where we’ll throw everything
    related to time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following constant to your new file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back in `test/AppointmentForm.test.js`, add the following import, just below
    your other imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Delete the definition of the `today` constant in the test suite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `test/builders/time.js`, add the following definition of `todayAt`. Notice
    that this does allow us to specify hours, minutes, seconds, and milliseconds if
    we so choose, but it has a default value of `0` for each if we don’t specify them.
    We’ll make use of this full form in one of the tests. We must also make a copy
    of the `today` constant by calling the `date` constructor. This ensures that we
    don’t unexpectedly modify the `today` constant on any callers of this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Immutability of builder functions
  prefs: []
  type: TYPE_NORMAL
- en: If your namespaces use shared constant values, like we’re doing with `today`
    here, make sure your functions don’t inadvertently mutate them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `test/AppointmentForm.test.js`, update your import so that it includes
    the new function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Time for a search and replace! Find all occurrences of the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Find all occurrences of the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Ensure your tests are still passing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Move these lines from the test suite into `test/builders/time.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rather than use the `tomorrow` constant directly, let’s write a `tomorrowAt`
    helper for that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update your import so that it includes the new function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Delete the definitions of `oneDayInMs` and `tomorrow` from the test suite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the following expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Run the tests again; they should be passing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll make use of these helpers again in [*Chapter 7*](B18423_07.xhtml#_idTextAnchor125),
    *Testing useEffect and Mocking Components*. However, there’s one more extraction
    we can do before we finish with this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting a test props object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A test props object is an object that sets sensible defaults for props that
    you can use to reduce the size of your `render` statements. For example, look
    at the following render call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the test, some (or all) of these props may be irrelevant to the
    test. The `original` prop is necessary so that our render function doesn’t blow
    up when rendering existing field values. But if our test is checking that we show
    a label on the page, we don’t care about that – and that’s one reason we created
    the `blankAppointment` constant. Similarly, `availableTimeSlots` and the `today`
    prop may not be relevant to a test.
  prefs: []
  type: TYPE_NORMAL
- en: Not only that, but often, our components can end up needing a whole lot of props
    that are necessary for a test to function. This can end up making your tests extremely
    verbose.
  prefs: []
  type: TYPE_NORMAL
- en: Too many props?
  prefs: []
  type: TYPE_NORMAL
- en: The technique you’re about to see is one way of dealing with many required props.
    But having a lot of props (say, more than four or five) might be a hint that the
    design of your components can be improved. Can the props be joined into a complex
    type? Or should the component be split into two or more components?
  prefs: []
  type: TYPE_NORMAL
- en: This is another example of listening to your tests. If the tests are difficult
    to write, take a step back and look at your component design.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define an object named `testProps` that exists at the top of our `describe`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This can then be used in the `render` call, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'If the test does depend on a prop, such as if its expectation mentions part
    of the `props` value, then you shouldn’t rely on the hidden-away value in the
    `testProps` object. Those values are sensible defaults. The values in your test
    should be prominently displayed, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the `original` prop is still included in the render call after `testProps`.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you’ll want to explicitly include a prop, even if the value is the
    same as the `testProps` value. That’s to highlight its use within the test. We’ll
    see an example of that in this section.
  prefs: []
  type: TYPE_NORMAL
- en: When to use an explicit prop
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, if the prop is used in your test assertions, or if the prop’s
    value is crucial for the scenario the test is testing, then the prop should be
    included explicitly in the `render` call, even if its value is the same as the
    value defined in `testProps`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update the `AppointmentForm` test suite so that it uses a `testProps`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: In your test suite, find the definitions for `services`, `availableTimeSlots`,
    and `blankAppointment`. These should be near the top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `testProps` definition just after the other definitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first test in the suite looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This can be updated to look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The next two tests, `renders a submit button` and `renders as a select box`,
    can use the same change. Go ahead and do that now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next up, we have the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since this test depends on having a blank value passed in for the `service`
    field, let’s keep the original prop there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: We’ve effectively hidden the `availableTimeSlots` property, which was noise
    before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have a test that makes use of `selectableServices`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This test uses the `services` constant in its expectation, so this is a sign
    that we need to keep that as an explicit prop. Change it so that it matches the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next test, it’s just `availableTimeSlots` that we can get rid of since
    both `services` and `appointments` are defined in the test itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The remaining tests in this test suite are in the nested `describe` block for
    the time slot table. Updating this is left as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve now learned yet more ways to clean up your test suites: extracting test
    data builders and extracting a `testProps` object. Remember that using the `testProps`
    object isn’t always the right thing to do; it may be better to refactor your component
    so that it takes fewer props.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how to use two types of HTML form elements: select
    boxes and radio buttons.'
  prefs: []
  type: TYPE_NORMAL
- en: The component we’ve built has a decent amount of complexity, mainly due to the
    component hierarchy that’s used to display a calendar view, but also because of
    the date and time functions we’ve needed to help display that view.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is about as complex as it gets: writing React component tests shouldn’t
    feel any more difficult than it has in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Taking a moment to review our tests, the biggest issue we have is the use of
    `expect.hasAssertions` and the unusual **Arrange-Assert-Act** order. In [*Chapter
    6*](B18423_06.xhtml#_idTextAnchor099), *Exploring Test Doubles*, we’ll discover
    how we can simplify these tests and get them back into **Arrange-Act-Assert**
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some exercises for you to try out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `toBeElementWithTag` matcher that replaces the two expectations in the
    `renders as a select box` test. It should be used like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Complete the remaining tests for the `AppointmentForm` select box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Renders a label
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigns an ID that matches the label ID
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Saves an existing value when submitted
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Saves a new value when submitted
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These tests are practically the same as they were for `CustomerForm`, including
    the use of the `change` helper. If you want a challenge, you can try extracting
    these form test helpers into a module of their own that is shared between `CustomerForm`
    and `AppointmentForm`.
  prefs: []
  type: TYPE_NORMAL
- en: Update the time slot table tests so that they use the `testProps` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `AppointmentsDayView` component so that it uses the `todayAt` builder,
    where appropriate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the ability to choose a stylist before choosing a time slot. This should
    be a select box that filters based on the service required, as not all stylists
    will be qualified to provide all services. You’ll need to decide on a suitable
    data structure to hold this data. Modify `availableTimeSlots` so that it lists
    which stylists are available at each time, and update the table to reflect which
    stylist has been chosen and their availability during the week.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `useCallback` hook is useful when you’re passing event handlers through
    a hierarchy of components. Take a look at the React documentation for tips on
    how to ensure correct usage: https://reactjs.org/docs/hooks-reference.xhtml#usecallback.'
  prefs: []
  type: TYPE_NORMAL
