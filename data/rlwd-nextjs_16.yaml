- en: '*Chapter 13*: Building an E-Commerce Website with Next.js and GraphCMS'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第13章*：使用Next.js和GraphCMS构建电子商务网站'
- en: During our journey exploring Next.js, we've learned a lot. We've explored different
    rendering methodologies, styling techniques, integrations, and even deployment
    strategies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索Next.js的旅程中，我们学到了很多。我们探索了不同的渲染方法、样式技术、集成甚至部署策略。
- en: Now it's time to start creating something worth going to production, taking
    advantage of everything we have learned so far.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始创建一些值得投入生产的作品了，利用我们迄今为止所学的一切。
- en: In this chapter, we will see how to adopt Next.js to build e-commerce storefronts
    from scratch.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何采用Next.js从头开始构建电子商务店面。
- en: 'We will look at the following in detail:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细探讨以下内容：
- en: What GraphCMS is and how to adopt it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是GraphCMS以及如何采用它
- en: How to integrate payment methods such as Stripe
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何集成支付方式，例如Stripe
- en: How to deploy an e-commerce website
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何部署电子商务网站
- en: By the end of this chapter, you will be able to describe a Next.js e-commerce
    architecture, find the right SEO and performance tradeoff, and deploy your Next.js
    instance on the right cloud platform.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够描述一个Next.js电子商务架构，找到合适的SEO和性能权衡，并在正确的云平台上部署您的Next.js实例。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run the code examples in this chapter, you need to have both Node.js and
    npm installed on your local machine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码示例，您需要在您的本地机器上安装Node.js和npm。
- en: 'If you prefer, you can use an online IDE, such as [https://repl.it](https://repl.it)
    or [https://codesandbox.io](https://codesandbox.io); they both support Next.js
    and you don''t need to install any dependency on your computer. As with the other
    chapters, you can find the code base for this chapter on GitHub: https://github.com/PacktPublishing/Real-World-Next.js.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，可以使用在线IDE，例如[https://repl.it](https://repl.it)或[https://codesandbox.io](https://codesandbox.io)；它们都支持Next.js，您不需要在您的电脑上安装任何依赖。与其他章节一样，您可以在GitHub上找到本章的代码库：https://github.com/PacktPublishing/Real-World-Next.js。
- en: Creating e-commerce websites for the modern web
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为现代网络创建电子商务网站
- en: Since the internet started to spread at the end of the 90s, it opened a world
    of possibilities for online businesses. As a result, many companies began to develop
    **software-as-a-service** (**SaaS**) products to help people build their own online
    shopping platforms.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 自从90年代末互联网开始传播以来，它为在线业务开辟了一个充满可能性的世界。因此，许多公司开始开发**软件即服务**（**SaaS**）产品，以帮助人们建立自己的在线购物平台。
- en: 'Today, there are several significant players in this area: Shopify, Big Cartel,
    WordPress (using WooCommerce or other plugins), and Magento, just to name a few.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，这个领域有几个重要的参与者：Shopify、Big Cartel、WordPress（使用WooCommerce或其他插件）和Magento，仅举几个例子。
- en: There are also companies, such as PayPal and Stripe, that make it incredibly
    easy to integrate payment methods on any platform, paving the ground for custom
    e-commerce creation, where our imagination is the only limit.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 还有像PayPal和Stripe这样的公司，它们使在任何平台上集成支付方式变得极其简单，为定制电子商务创建铺平了道路，我们的想象力是唯一的限制。
- en: When talking about "limits" in e-commerce creation, I'm referring to the fact
    that certain SaaS platforms can make it hard for us developers to customize the
    UI, payment flow, and so on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论电子商务创建中的“限制”时，我指的是某些SaaS平台可能会让开发者难以自定义UI、支付流程等。
- en: Shopify, as an example, solved this problem by creating a new server-side-rendered
    React.js framework called **Hydrogen**, which ships with pre-built components
    and Hooks to communicate with its GraphQL APIs, allowing developers to create
    unique user experiences on the frontend with ease.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以Shopify为例，通过创建一个新的服务器端渲染的React.js框架来解决此问题，名为**Hydrogen**，它包含预构建的组件和Hooks以与GraphQL
    API通信，使开发者能够轻松地在前端创建独特的用户体验。
- en: Next.js, released Next.js Commerce, a highly customizable starter kit for effortlessly
    creating e-commerce experiences, being able to integrate with many different platforms.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js发布了Next.js Commerce，这是一个高度可定制的入门套件，可以轻松创建电子商务体验，能够与许多不同的平台集成。
- en: Next.js Commerce doesn't add anything new to the Next.js framework. Instead,
    it acts as a template for starting a new e-commerce website, knowing that we can
    customize every single part of it with extreme ease. We will not touch upon the
    customization capabilities in practice; however, we will still deploy an incredibly
    performant and optimized online shop.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js Commerce 并没有为 Next.js 框架添加任何新功能。相反，它作为一个模板来启动一个新的电子商务网站，知道我们可以极其容易地定制它的每一个部分。我们不会涉及实际的定制能力；然而，我们仍然会部署一个性能卓越且优化的在线商店。
- en: We can use Next.js commerce with any headless backend service. It doesn't matter
    whether we're using Shopify, BigCommerce, Saleor, or any other service, as long
    as they expose some APIs to communicate with the backend.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Next.js Commerce 与任何无头后端服务一起使用。无论我们使用 Shopify、BigCommerce、Saleor 还是任何其他服务，只要它们公开一些
    API 与后端通信即可。
- en: 'Starting from the next section, we will be using one of the best headless CMS
    platforms out there, which can manage any aspect of a modern e-commerce platform,
    from product inventory to content translations, always keeping an API-first approach:
    GraphCMS.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一节开始，我们将使用目前最好的无头 CMS 平台之一，它可以管理现代电子商务平台的任何方面，从产品库存到内容翻译，始终采用 API 首选的方法：GraphCMS。
- en: Setting up GraphCMS
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 GraphCMS
- en: There are many different competitors in the e-commerce world; all of them offer
    a great set of functionalities for building modern and performant solutions, but
    there's always a kind of tradeoff when it comes to analyzing back-office features,
    frontend customization capabilities, APIs, integrations, and so on.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子商务领域有许多不同的竞争对手；它们都提供了一套构建现代和高效解决方案的功能，但在分析后台功能、前端定制能力、API、集成等方面总会有一定的权衡。
- en: 'In this chapter, we will be using GraphCMS for a simple reason: it''s easy
    to integrate, offers a generous free plan, and requires no setup for complex release
    pipelines, databases, or whatever. We just need to open an account and take advantage
    of the massive set of free features to build a fully working e-commerce website.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 GraphCMS 的一个简单原因：它易于集成，提供慷慨的免费计划，并且不需要为复杂的发布流程、数据库或其他任何东西进行设置。我们只需要开设一个账户，利用庞大的免费功能集来构建一个完全工作的电子商务网站。
- en: It also provides an e-commerce starter template with pre-built (yet fully customizable)
    contents, which translates to a pre-built GraphQL schema ready to consume on the
    frontend to create product pages, catalogs, and so on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了一个带有预构建（但完全可定制）内容的电子商务入门模板，这意味着一个预构建的 GraphQL 模式，可以在前端消费以创建产品页面、目录等。
- en: We can start by creating a new GraphCMS account by going to [https://graphcms.com](https://graphcms.com).
    Once we log into our dashboard, we will see that GraphCMS prompts us to create
    a new project, and we will choose among several pre-made templates. We can select
    the **Commerce Shop** template, which will generate some mock content for us.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过访问 [https://graphcms.com](https://graphcms.com) 来创建一个新的 GraphCMS 账户。一旦我们登录到我们的控制台，我们会看到
    GraphCMS 会提示我们创建一个新的项目，我们将在几个预制的模板中进行选择。我们可以选择**商业商店**模板，这将为我们生成一些模拟内容。
- en: '![Figure 13.1 – The GraphCMS dashboard'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.1 – GraphCMS 控制台'
- en: '](img/Figure_13.1_B16985.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_13.1_B16985.jpg)'
- en: Figure 13.1 – The GraphCMS dashboard
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – GraphCMS 控制台
- en: Once we have created the project by selecting **Commerce Shop** as a template,
    we can browse the **Content** section in our GraphCMS dashboard and see what mock
    data we have.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们通过选择**商业商店**作为模板创建了项目，我们就可以在我们的 GraphCMS 控制台中浏览**内容**部分，看看我们有什么模拟数据。
- en: We will see many useful and prepopulated sections, such as products, product
    variants, categories, and reviews; we will use this data in our Next.js commerce
    application shortly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到许多有用且预先填充的部分，如产品、产品变体、类别和评论；我们将在我们的 Next.js 电子商务应用中很快使用这些数据。
- en: 'Now that we have our content, we need to create a Next.js application to display
    it on the frontend by using the powerful GraphCMS GraphQL APIs:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了内容，我们需要创建一个 Next.js 应用程序，通过使用强大的 GraphCMS GraphQL API 在前端显示它：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once we have created the app, we can start thinking about how we want the UI
    to be. In this case, we want to keep things easy, and we''ll use Chakra UI for
    styling our components. Let''s install it and set it up inside our Next.js application:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了应用程序，我们就可以开始考虑我们想要的 UI 是什么样子。在这种情况下，我们希望保持简单，我们将使用 Chakra UI 来为我们的组件进行样式设计。让我们安装它并在我们的
    Next.js 应用程序中设置它：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s open our `_app.js` file and add the Chakra provider:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开 `_app.js` 文件并添加 Chakra 提供者：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we've set up an elementary Next.js application, we can start thinking
    about linking GraphCMS to it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个基本的 Next.js 应用程序，我们可以开始考虑将 GraphCMS 连接到它。
- en: 'As said before, GraphCMS exposes excellent GraphQL APIs, so we need to connect
    to it by using that protocol. We''ve already discussed how to connect to any GraphQL
    endpoint using Apollo in [*Chapter 4*](B16985_04_Final_SB_epub.xhtml#_idTextAnchor053),
    *Organizing the Code base and Fetching Data in Next.js*. For the sake of simplicity,
    we''ll now use a more straightforward library for connecting to GraphCMS: `graphql-request`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，GraphCMS 提供了出色的 GraphQL API，因此我们需要通过该协议连接到它。我们已经在 [*第 4 章*](B16985_04_Final_SB_epub.xhtml#_idTextAnchor053)
    中讨论了如何使用 Apollo 连接到任何 GraphQL 端点，*在 Next.js 中组织代码库和获取数据*。为了简化，我们现在将使用一个更直接的库来连接到
    GraphCMS：`graphql-request`。
- en: 'We can install it by using Yarn:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 Yarn 来安装它：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now let''s create a basic GraphQL interface to connect GraphCMS to our storefront.
    First, let''s create a new file called `lib/graphql/index.js` and add the following
    content:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个基本的 GraphQL 接口，将 GraphCMS 连接到我们的店面。首先，让我们创建一个名为 `lib/graphql/index.js`
    的新文件，并添加以下内容：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What's happening here?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？
- en: 'As you can see, we will need to create a couple of environment variables: `GRAPHCMS_ENDPOINT`
    and `GRAPHCMS_API_KEY`. The first one contains the GraphCMS endpoint URL, and
    the second is an optional API key for accessing protected data.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们需要创建几个环境变量：`GRAPHCMS_ENDPOINT` 和 `GRAPHCMS_API_KEY`。第一个包含 GraphCMS 端点
    URL，第二个是用于访问受保护数据的可选 API 密钥。
- en: In fact, GraphCMS allows you to expose its data publicly, which can be handy
    in certain situations. In other cases, though, we want our data to be accessible
    to authorized clients only, so we need to use an API key.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，GraphCMS 允许您公开其数据，这在某些情况下可能很有用。然而，在其他情况下，我们希望我们的数据只能被授权客户端访问，因此我们需要使用一个
    API 密钥。
- en: We can retrieve those environment variables values by going to **Settings**
    then **API Access** on our GraphCMS dashboard.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过访问我们的 GraphCMS 控制面板上的**设置**然后**API 访问**来检索这些环境变量值。
- en: '![Figure 13.2 – API access management in GraphCMS'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.2 – GraphCMS 的 API 访问管理'
- en: '](img/Figure_13.2_B16985.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_13.2_B16985.jpg)'
- en: Figure 13.2 – API access management in GraphCMS
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – GraphCMS 的 API 访问管理
- en: 'We can now take the `GRAPHCMS_ENDPOINT` value inside the `.env.local` file
    in our codebase. Of course, if this file does not exist, we can create it from
    scratch:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从我们的代码库中的`.env.local`文件中获取`GRAPHCMS_ENDPOINT`值。当然，如果这个文件不存在，我们可以从头创建它：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We now need to set the API key, which allows us to perform mutations on the
    CMS (for example, save an order once it's paid). We can use the default `GRAPHCMS_API_KEY`
    value in our `.env.local` file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要设置 API 密钥，这允许我们在 CMS 上执行突变（例如，一旦付款，保存订单）。我们可以在 `.env.local` 文件中使用默认的
    `GRAPHCMS_API_KEY` 值。
- en: We're now ready to go! We have a connection with the CMS, so we can read, write,
    and even update or delete data via GraphQL APIs. In the next section, we will
    use them to create the storefront and the product detail page.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备就绪！我们已经与 CMS 建立了连接，因此我们可以通过 GraphQL API 读取、写入，甚至更新或删除数据。在下一节中，我们将使用它们来创建店面和产品详情页面。
- en: Creating the storefront, cart, and product detail pages
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建店面、购物车和产品详情页面
- en: 'GraphCMS offers a well-made, rock-solid, open source template for creating
    e-commerce websites, which can be found at this URL: [https://github.com/GraphCMS/graphcms-commerce-starter](https://github.com/GraphCMS/graphcms-commerce-starter).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: GraphCMS 提供了一个制作精良、坚如磐石的开源模板，用于创建电子商务网站，您可以通过此 URL 获取：[https://github.com/GraphCMS/graphcms-commerce-starter](https://github.com/GraphCMS/graphcms-commerce-starter)。
- en: We're not adopting this starter template because we want to fully understand
    the reasoning behind certain technical decisions and how to approach the problems
    that can appear during the development phase.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有采用这个入门模板，因为我们想完全理解某些技术决策背后的推理以及如何处理开发阶段可能出现的问题。
- en: That said, we can focus on developing the first essential components for our
    storefront.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们可以专注于开发我们店面所需的第一批基本组件。
- en: 'We will wrap our entire application in a Chakra UI box so that every page will
    have a similar layout. We can do that by opening the `_app.js` file and adding
    the following components:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把整个应用程序包裹在一个 Chakra UI 框架中，这样每个页面都将拥有相似的布局。我们可以通过打开 `_app.js` 文件并添加以下组件来实现这一点：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, we can start thinking about how we want to show our products on the home
    page. However, before doing that, we may want to check the data provided via GraphQL
    APIs by the CMS, and we can easily do that by going into the **API Playground**
    section of our dashboard. Here, we can write our GraphQL queries, taking advantage
    of the **Explorer** functionality to help us create highly customizable GraphQL
    queries with ease.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始考虑我们如何在主页上展示我们的产品。然而，在这样做之前，我们可能想检查CMS通过GraphQL API提供的数据，我们可以通过进入仪表板的**API
    演示场**部分轻松做到这一点。在这里，我们可以编写我们的GraphQL查询，利用**探索器**功能帮助我们轻松创建高度可定制的GraphQL查询。
- en: '![Figure 13.3 – GraphCMS API Playground'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.3 – GraphCMS API 演示场'
- en: '](img/Figure_13.3_B16985.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.3 – GraphCMS API 演示场](img/Figure_13.3_B16985.jpg)'
- en: Figure 13.3 – GraphCMS API Playground
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – GraphCMS API 演示场
- en: 'In the query shown in the preceding screenshot, we''re retrieving all the publicly
    available products. We can use this exact query in our Next.js app, so let''s
    create a new `/lib/graphql/queries/getAllProducts.js` file and add the following
    content:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图所示的查询中，我们正在检索所有公开可用的产品。我们可以在我们的Next.js应用程序中使用这个确切的查询，所以让我们创建一个新的`/lib/graphql/queries/getAllProducts.js`文件并添加以下内容：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''re now ready to fetch all the products to populate our home page. To generate
    a static page at build time, let''s head to our `pages/index.js` page and retrieve
    the products inside the `getStaticProps` function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已准备好获取所有产品以填充我们的主页。为了在构建时生成静态页面，让我们前往`pages/index.js`页面并在`getStaticProps`函数中检索产品：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At this point, we might be wondering how to handle cases where we create a
    new product and want to display it immediately on the home page. Here, we have
    two options:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可能会想知道如何处理我们创建一个新产品并希望立即在主页上显示的情况。这里，我们有两种选择：
- en: Use `getServerSideProps` instead of `getStaticProps`, which will dynamically
    generate the page on each request, but we already know its downsides, as seen
    in [*Chapter 10*](B16985_10_Final_SB_epub.xhtml#_idTextAnchor102), *Working with
    SEO and Managing Performance*.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`getServerSideProps`而不是`getStaticProps`，这将根据每个请求动态生成页面，但我们已经知道它的缺点，如在第10章中所述，*与SEO合作和管理性能*。
- en: Use incremental static regeneration so that after a given period, the page gets
    regenerated, including any new API changes.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用增量静态再生，这样在给定的时间后，页面会得到再生，包括任何新的API更改。
- en: 'We''ll proceed with the second option by adding the following property to our
    returning `getStaticProps` object:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过添加以下属性到我们的返回的`getStaticProps`对象中继续进行第二种选择：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''re now ready to display all the products on our home page. We''ll do that
    by creating a new component under `/components/ProductCard/index.js`, exposing
    the following function:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已准备好在主页上展示所有产品。我们将通过在`/components/ProductCard/index.js`下创建一个新的组件来实现这一点，并公开以下函数：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, this is a straightforward component that displays a product
    card containing the product image, name, and price.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个简单的组件，它显示包含产品图片、名称和价格的产品卡片。
- en: 'If you look at the used props (highlighted in the preceding code snippet),
    you will notice a one-to-one correspondence with the data we''re getting back
    from GraphCMS. That''s another slight advantage of using GraphQL: it allows you
    to model your data while querying it, making it incredibly easy to build components,
    functions, and even algorithms around it.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看使用的属性（在前面的代码片段中突出显示），你会注意到它与从GraphCMS返回的数据一一对应。这是使用GraphQL的另一个微小优势：它允许你在查询数据的同时对数据进行建模，这使得围绕它构建组件、函数甚至算法变得极其容易。
- en: 'Now that we have our `ProductCard` component, we can import it into our home
    page and use it to display all the products fetched from the CMS:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`ProductCard`组件，我们可以将其导入到我们的主页中，并使用它来显示从CMS获取的所有产品：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we now launch our development server and head to [http://localhost:3000](http://localhost:3000),
    we will be able to see our storefront.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在启动开发服务器并转到[http://localhost:3000](http://localhost:3000)，我们将能够看到我们的店面。
- en: '![Figure 13.4 – Our first Next.js-based storefront'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.4 – 我们基于Next.js的第一个店面'
- en: '](img/Figure_13.4_B16985.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.4 – GraphCMS API 演示场](img/Figure_13.4_B16985.jpg)'
- en: Figure 13.4 – Our first Next.js-based storefront
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 我们基于Next.js的第一个店面
- en: Now that we have a working storefront, we need to create a single product page.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个工作的店面，我们需要创建一个单独的产品页面。
- en: As for the home page, we will use SSG + ISR to build all the product pages,
    which will help us maintain great performance and improve SEO and user experience.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 至于主页，我们将使用SSG + ISR来构建所有产品页面，这将帮助我们保持良好的性能并提高SEO和用户体验。
- en: 'We can do that by creating a new file under `pages/product/[slug].js`, where
    we can start writing the following function definitions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 `pages/product/[slug].js` 下创建一个新文件来实现这一点，在那里我们可以开始编写以下函数定义：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you may have guessed, we will need to generate a new page for each product,
    and we can do that by using Next.js' reserved `getStaticPaths` function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的，我们需要为每个产品生成一个新的页面，我们可以通过使用 Next.js 的保留函数 `getStaticPaths` 来实现这一点。
- en: Inside that function, we will query for all the products in our CMS, then generate
    the dynamic URL paths for each one; that way, at build time, Next.js will generate
    all the pages we need in our website.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在该函数内部，我们将查询我们 CMS 中的所有产品，然后为每个产品生成动态 URL 路径；这样，在构建时，Next.js 将生成我们网站中需要的所有页面。
- en: The other two functions should already sound familiar, so we will implement
    them later.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 其他两个函数应该已经很熟悉了，所以我们将稍后实现它们。
- en: We now need to write a GraphQL query for getting all the products in GraphCMS.
    To keep it simple, we can reuse the query we wrote for the home page, which is
    already fetching all the products, including their slugs (which will be part of
    the product URL).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要编写一个 GraphQL 查询来获取 GraphCMS 中的所有产品。为了保持简单，我们可以重用我们为主页编写的查询，该查询已经获取了所有产品，包括它们的
    slugs（这将是产品 URL 的一部分）。
- en: 'Let''s update our product page by making a request to GraphCMS for all the
    products in the inventory:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向 GraphCMS 发送请求来更新我们的产品页面，获取库存中的所有产品：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With this edit, we''re returning an object containing all the pages we need
    to generate at build time. In fact, the returning object will look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次编辑，我们正在返回一个包含我们在构建时需要生成的所有页面的对象。实际上，返回的对象将看起来像这样：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you may guess, this will help Next.js to match a given `/product/[slug]`
    route with the correct product slug.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的，这将帮助 Next.js 匹配给定的 `/product/[slug]` 路由与正确的产品 slugs。
- en: 'At this point, we need to create a GraphQL query to get the single product
    details. We can create a new file under `lib/graphql/queries/getProductDetail.js`
    and add the following content:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要创建一个 GraphQL 查询来获取单个产品的详细信息。我们可以在 `lib/graphql/queries/getProductDetail.js`
    下创建一个新文件并添加以下内容：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With this query, we will get all the products whose slug matches the `$slug`
    query variable. Given that the `slug` property is unique in GraphCMS, it will
    return an array with just one result if the requested products exist or an empty
    array if it doesn't.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个查询，我们将获取所有与 `$slug` 查询变量匹配的产品。鉴于 `slug` 属性在 GraphCMS 中是唯一的，如果请求的产品存在，它将返回一个只有一个结果的数组；如果不存在，则返回一个空数组。
- en: 'We''re now ready to import this query and edit the `getStaticProps` function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好导入这个查询并编辑 `getStaticProps` 函数：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we only need to create the product page layout, containing an image of
    our product, a title, a brief description, the price, and a quantity selector.
    To do that, we can edit the `ProductPage` function in the following way:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要创建产品页面布局，包含我们产品的图片、标题、简要描述、价格和数量选择器。为此，我们可以按照以下方式编辑 `ProductPage` 函数：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we now launch the development server and open a single product page, we
    will see the following content:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在启动开发服务器并打开单个产品页面，我们将看到以下内容：
- en: '![Figure 13.5 – The single product detail page'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.5 – 单个产品详情页面'
- en: '](img/Figure_13.5_B16985.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_13.5_B16985.jpg)'
- en: Figure 13.5 – The single product detail page
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – 单个产品详情页面
- en: Now that we can navigate from the home page to a product page, we need to build
    a navigation bar that can allow us to go back to the storefront or go to the shopping
    cart to review the product we want to purchase and then make the payment.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们现在可以从主页导航到产品页面，我们需要构建一个导航栏，以便我们可以返回店面或转到购物车来查看我们想要购买的产品，然后进行支付。
- en: 'We can easily create a navigation bar by opening a new file under `components/NavBar/index.js`
    and adding the following content:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 `components/NavBar/index.js` 下创建一个新文件并添加以下内容来轻松创建一个导航栏：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will also need to install the `react-icons` library, which, as the name
    suggests, is an excellent package containing hundreds of well-made and useful
    icons for our React-based projects:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要安装 `react-icons` 库，正如其名所示，这是一个包含数百个精心制作且实用的图标，非常适合我们的基于 React 的项目的优秀包：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We now only need to update our `_app.js` file by including the newest `NavBar`
    component so that it will be rendered on all the application pages:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要更新我们的 `_app.js` 文件，包括最新的 `NavBar` 组件，这样它就会在所有应用程序页面上渲染：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can finally navigate from the storefront to the product page and back!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以从店面导航到产品页面，然后再返回！
- en: Now that the website is taking shape, we want to add products to our shopping
    basket. We discussed a similar scenario in [*Chapter 5*](B16985_05_Final_SB_epub.xhtml#_idTextAnchor068),
    *Managing Local and Global States in Next.js*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在网站已经初具规模，我们想要将产品添加到我们的购物篮中。我们曾在 [*第5章*](B16985_05_Final_SB_epub.xhtml#_idTextAnchor068)
    中讨论过类似的场景，*在 Next.js 中管理本地和全局状态*。
- en: We will need to create a React context to hold the shopping list until the user
    pays.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个 React 上下文来保存购物清单，直到用户付款。
- en: 'First, we will need to create a new file under `lib/context/Cart/index.js`.
    Here, we will write the following script:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在 `lib/context/Cart/index.js` 下创建一个新文件。在这里，我们将编写以下脚本：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We now need to wrap the entire app under this context, so we need to open the
    `_app.js` file and edit it as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将整个应用程序包裹在这个上下文中，因此我们需要打开 `_app.js` 文件并按以下方式编辑它：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is quite similar to the context we created in [*Chapter 5*](B16985_05_Final_SB_epub.xhtml#_idTextAnchor068),
    *Managing Local and Global States in Next.js*, right?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在 [*第5章*](B16985_05_Final_SB_epub.xhtml#_idTextAnchor068) 中创建的上下文非常相似，*在
    Next.js 中管理本地和全局状态*，对吧？
- en: 'We now need to link the single product page to the context to add products
    to the shopping cart. Let''s open the `components/ProductCard/index.js` file and
    link the context to the **select quantity** and **add to cart** actions:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将单个产品页面链接到上下文，以便将产品添加到购物篮中。让我们打开 `components/ProductCard/index.js` 文件，并将上下文链接到**选择数量**和**添加到购物篮**操作：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can also make things more exciting and dynamic by showing how many products
    we have in our shopping cart. We can do this by linking the `NavBar` component
    to the same `CartContext` by adding a few lines:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过显示购物车中有多少产品来使事情更加有趣和动态。我们可以通过将 `NavBar` 组件链接到相同的 `CartContext` 来实现这一点，只需添加几行代码：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that we have a way to add items to the shopping cart, we need to create
    the cart page itself. Let''s create a new `pages/cart.js,` file where we will
    add the following component:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了向购物篮添加项目的方法，我们需要创建购物页本身。让我们创建一个新的 `pages/cart.js` 文件，我们将添加以下组件：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will be the shopping cart's page default state. When a user puts any product
    into the basket, we need to display it here.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是购物篮页面的默认状态。当用户将任何产品放入篮子时，我们需要在这里显示它。
- en: 'To do that, we can easily use the cart context we just created, which will
    tell us the ID and quantity of each product:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们可以轻松地使用我们刚刚创建的购物车上下文，这将告诉我们每个产品的ID和数量：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We ended up having an object containing the IDs and the quantity for each product
    in the format `{ [product_id]: quantity }`.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '我们最终得到了一个包含每个产品的ID和数量的对象，格式为 `{ [product_id]: quantity }`。'
- en: 'We will use the keys of this object to fetch all the required products from
    GraphCMS by using a new query, positioned under `lib/graphql/queries/getProductsById.js`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用此对象的键，通过一个新的查询从 GraphCMS 获取所有所需的产品，该查询位于 `lib/graphql/queries/getProductsById.js`：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once we finish writing the query, we can move back to our `cart.js` file and
    implement it using a `useEffect` React Hook, so that we fetch all the products
    as soon as the page loads:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成查询的编写，我们可以回到我们的 `cart.js` 文件，并使用 `useEffect` React 钩子实现它，以便在页面加载时立即获取所有产品：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As soon as we try to add a couple of products to the shopping basket and then
    move to the cart page, we will see the following error:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试将几个产品添加到购物篮中，然后转到购物页时，我们会看到以下错误：
- en: '![Figure 13.6 – The browser can''t find the process variable'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.6 – 浏览器找不到进程变量'
- en: '](img/Figure_13.6_B16985.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.6_B16985.jpg)'
- en: Figure 13.6 – The browser can't find the process variable
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 – 浏览器找不到进程变量
- en: Next.js is telling us that the `process` variable, containing all the environment
    variables, is not available on the browser. Thankfully, even if this variable
    is not officially supported by any browser, Next.js provides an excellent polyfill
    for us; we only need to make a couple of changes to make it effective.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 告诉我们，包含所有环境变量的 `process` 变量在浏览器中不可用。幸运的是，即使这个变量没有被任何浏览器官方支持，Next.js
    为我们提供了一个出色的 polyfill；我们只需要做一些更改使其有效。
- en: First of all, we will need to rename the `GRAPHCMS_ENDPOINT` variable to `NEXT_PUBLIC_GRAPHCMS_ENDPOINT`.
    By prepending `NEXT_PUBLIC_` to any environment variable, Next.js will add a `process.env`
    object, available on the browser, exposing only the public variables.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将 `GRAPHCMS_ENDPOINT` 变量重命名为 `NEXT_PUBLIC_GRAPHCMS_ENDPOINT`。通过在环境变量前添加
    `NEXT_PUBLIC_`，Next.js 将添加一个 `process.env` 对象，在浏览器中可用，仅公开公共变量。
- en: 'Let''s make the change in the `.env.local` file, then move back to the `lib/graphql/index.js`
    file and make a small change there too:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`.env.local`文件中进行更改，然后回到`lib/graphql/index.js`文件并对其进行一些小的修改：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Please note that we're not modifying the `GRAPHCMS_API_KEY` environment variable
    name, as it contains private data and should never be exposed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有修改`GRAPHCMS_API_KEY`环境变量名称，因为它包含私有数据，永远不应该暴露。
- en: Now that we have fixed this little issue, we're finally ready to compose our
    cart page.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了这个小问题，我们终于准备好编写购物车页面了。
- en: 'First, we will need to write a function that calculates the final expense by
    summing the product prices multiplied by their quantity. We can do that by adding
    this function inside our component''s body:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要编写一个函数来计算最终费用，通过将产品价格乘以它们的数量来求和。我们可以在组件的主体中添加此函数来实现：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we can update our component returning JSX by including the list of products
    that we added to the shopping cart:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过包括我们添加到购物车中的产品列表来更新我们的组件返回的JSX：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We're all set for managing the cart! We now need to process the payment by choosing
    a financial service, such as Stripe, PayPal, or Braintree.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好管理购物车了！我们现在需要通过选择一个金融服务，例如Stripe、PayPal或Braintree来处理支付。
- en: In the next section, we will see how to implement the payment feature using
    Stripe.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何使用Stripe实现支付功能。
- en: Processing payments using Stripe
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Stripe处理支付
- en: Stripe is one of the best financial services out there; it's straightforward
    to use and offers excellent documentation to understand how to integrate their
    APIs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Stripe是市面上最好的金融服务之一；它使用简单，并提供优秀的文档，帮助我们了解如何集成他们的API。
- en: Before continuing with this section, make sure to open an account at https://stripe.com.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本节之前，请确保在https://stripe.com上开设账户。
- en: 'Once we have an account, we can log in and go to [https://dashboard.stripe.com/apikeys](https://dashboard.stripe.com/apikeys),
    where we''ll retrieve the following information: the publishable key and secret
    key. We will need to store them inside of two environment variables, following
    this naming convention:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了账户，我们可以登录并前往[https://dashboard.stripe.com/apikeys](https://dashboard.stripe.com/apikeys)，在那里我们将检索以下信息：发布密钥和秘密密钥。我们需要将它们存储在两个环境变量中，遵循以下命名约定：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Please double-check that you're not exposing the `STRIPE_SECRET_KEY` variable
    and that the `.env.local` file is not added to the Git history by including it
    in the `.gitignore` file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必检查您没有暴露`STRIPE_SECRET_KEY`变量，并且`.env.local`文件没有被添加到Git历史记录中，通过将其包含在`.gitignore`文件中来实现。
- en: 'Now let''s install the Stripe JavaScript SDK inside of our project:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将Stripe JavaScript SDK安装到我们的项目中：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once the two packages are installed, we can create a new file under `lib/stripe/index.js`,
    containing the following script:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 两个包安装完成后，我们可以在`lib/stripe/index.js`下创建一个新文件，包含以下脚本：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This script will ensure that we load Stripe only once, even if we come back
    to the cart page multiple times.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将确保我们只加载一次Stripe，即使我们多次返回购物车页面。
- en: At this point, we will need to create an API page that creates a Stripe session.
    By doing that, Stripe will create a beautiful and secure checkout page to redirect
    our users to insert their payment and shipping details. Once the users place their
    orders, they will get redirected to a landing page of our choice, but we'll see
    that later on in this section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要创建一个API页面来创建Stripe会话。通过这样做，Stripe将创建一个美丽且安全的结账页面，将我们的用户重定向到输入他们的支付和配送详情。一旦用户下订单，他们将被重定向到我们选择的着陆页，但我们会在这个部分的后面看到。
- en: 'Let''s create a new API route under `/pages/api/checkout/index.js`, where we
    will write a very basic Stripe checkout session request:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`/pages/api/checkout/index.js`下创建一个新的API路由，我们将在这里编写一个非常基本的Stripe结账会话请求：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Once we have created this basic function, we need to understand what data Stripe
    requires to complete the session.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了这个基本函数，我们需要了解Stripe需要哪些数据来完成会话。
- en: 'We will need to pass the following data in a particular order:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要按照特定的顺序传递以下数据：
- en: All the products to purchase, containing names, quantities, prices, and (optionally)
    images
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有要购买的产品，包含名称、数量、价格和（可选）图片
- en: All the available payment methods (credit cards, Alipay, SEPA Debit, or other
    payment methods, such as Klarna)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有可用的支付方式（信用卡、支付宝、SEPA借记或其他支付方式，如Klarna）
- en: Shipping rates
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运费
- en: Success and cancel redirect URLs for either case
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论是成功还是取消重定向URL
- en: 'We can start by considering the first point; we can easily pass the whole cart
    context object to this endpoint, including both product IDs to purchase and their
    quantity. We will need to then ask GraphCMS for product details, and we can do
    that by creating a new specific query under `lib/graphql/queries/getProductDetailsById.js`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从考虑第一个点开始；我们可以轻松地将整个购物车上下文对象传递到这个端点，包括要购买的产品 ID 和它们的数量。然后我们需要向 GraphCMS
    请求产品详情，我们可以在 `lib/graphql/queries/getProductDetailsById.js` 下创建一个新的特定查询来完成这个操作：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Going back to our `/pages/api/checkout/index.js` API page, we can start by
    implementing the query to retrieve the product details:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的 `/pages/api/checkout/index.js` API 页面，我们可以从实现查询以检索产品详情开始：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Stripe requires a configuration object containing a property called `line_items`,
    which describes all the products ready for purchase. Now that we have all the
    product information, we can compose this property in the following way:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Stripe 需要一个包含一个名为 `line_items` 的属性的配置对象，该属性描述了所有准备购买的产品。现在我们有了所有产品信息，我们可以以下这种方式来组合这个属性：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As a reference, if a user buys a couple of backpacks from our store, the `line_items`
    array would look like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，如果用户从我们的商店购买几个背包，`line_items` 数组看起来会是这样：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can now start writing the Stripe checkout session request by using the `line_items`
    array and a bit more information:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始通过使用 `line_items` 数组和一些更多信息来编写 Stripe 结账会话请求：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We''re almost there. Now, we only need to get the shipping information and
    store it in two different Stripe session properties: `shipping_address_collection`
    and `shipping_options`.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。现在，我们只需要获取配送信息并将其存储在两个不同的 Stripe 会话属性中：`shipping_address_collection`
    和 `shipping_options`。
- en: We can create two new variables outside the `handler` function. Still, as you
    can imagine, this can be completely CMS-driven.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `handler` 函数外部创建两个新变量。尽管如此，正如你所想象的，这可以完全由 CMS 驱动。
- en: 'To keep it simple, let''s create the first `shipping_address_collection` variable:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，让我们创建第一个 `shipping_address_collection` 变量：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, we can restrict shipping by manually selecting the countries
    where we ship to. You can simply avoid passing the `shipping_address_collection`
    property to the Stripe session if you want to ship worldwide.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以通过手动选择我们配送的国家来限制配送。如果你想全球配送，你可以简单地避免将 `shipping_address_collection`
    属性传递到 Stripe 会话中。
- en: The second variable is more complex but allows us to create different shipping
    methods with different rates. Let's say we offer free shipping, which takes 3
    to 5 business days for delivery, and express next day shipping for €4.99\.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个变量更复杂，但允许我们创建具有不同费用的不同配送方式。比如说，我们提供免费配送，通常需要 3 到 5 个工作日才能送达，而快递次日配送需要 €4.99。
- en: 'We can create the following array of shipping options:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建以下一系列的配送选项：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The shipping objects are self-explanatory. We can finally add those two new
    properties to our Stripe checkout session:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 配送对象是自解释的。我们终于可以添加这两个新属性到我们的 Stripe 结账会话中：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: And we're done! We're now replying with a session object that contains the redirect
    URL to be used on the frontend to redirect the user to the Stripe-hosted checkout
    page.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！我们现在回复一个包含用于在前端重定向用户到 Stripe 托管的结账页面的重定向 URL 的会话对象。
- en: 'We can do that by moving back to our `pages/cart.js` page and adding the following
    function:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过回到我们的 `pages/cart.js` 页面并添加以下函数来实现这一点：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As a very last thing, we only need to link this function to the `Cart` function:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需要将这个函数链接到 `Cart` 函数：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We''re finally ready to test out our checkout flow! Let''s boot the development
    server, add a couple of products to the shopping basket, then go to the **Cart**
    section and click on the **Pay now** button. We should end up on this beautiful,
    Stripe-powered checkout page, where we can insert our shipping information, choose
    the desired payment method, and modify the quantity for each product we put in
    the cart:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好测试我们的结账流程了！让我们启动开发服务器，将几个产品添加到购物车中，然后转到 **购物车** 部分，点击 **立即支付** 按钮。我们应该会到达这个美丽的、由
    Stripe 提供支持的结账页面，在那里我们可以输入我们的配送信息，选择所需的支付方式，并修改购物车中每个产品的数量：
- en: '![Figure 13.7 – The Stripe checkout page'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.7 – Stripe 结账页面'
- en: '](img/Figure_13.7_B16985.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.7_B16985.jpg)'
- en: Figure 13.7 – The Stripe checkout page
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 – Stripe 结账页面
- en: In my case, you can see that I've been redirected to a **Michele Riva** store
    (upper-left corner), as I opened my Stripe account using my name, but if you did
    the same and want to customize the store name, you can edit it on your Stripe
    dashboard.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，您可以看到我被重定向到了一个**Michele Riva**商店（左上角），因为我使用我的名字打开了Stripe账户，但如果你也这样做并想自定义商店名称，你可以在Stripe仪表板上编辑它。
- en: By clicking on the store name in the upper-left corner, we will be redirected
    to the `cancel_url` we set in the `pages/api/checkout/index.js` page; if we successfully
    complete a purchase, we will get redirected to `success_url`. I'll leave you the
    task of creating those two pages as a little homework to complete before moving
    on to the next chapter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 点击左上角的商店名称，我们将被重定向到我们在`pages/api/checkout/index.js`页面设置的`cancel_url`；如果我们成功完成购买，我们将被重定向到`success_url`。我将把这个创建这两个页面的任务留给你，作为在进入下一章之前完成的小作业。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In the previous sections, we saw how to create a straightforward e-commerce
    website using GraphCMS and Stripe, two incredible products that can help build
    scalable, secure, and maintainable storefronts.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何使用GraphCMS和Stripe这两个令人难以置信的产品创建一个简单的电子商务网站，这两个产品可以帮助构建可扩展、安全且易于维护的店面。
- en: Even though we've made some significant progress during this chapter, we're
    still missing some features that would deserve an entire book on them exclusively.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在本章中取得了一些显著的进展，但我们仍然缺少一些值得专门写一本书来介绍的功能。
- en: For example, if we now want to navigate back from the Stripe checkout to the
    cart page, we will see that our shopping cart is empty, as the cart context is
    not persistent. And what if we want to allow our users to create an account and
    see the shipping progress, order history, and other helpful information?
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们现在想从Stripe结账导航回购物车页面，我们会发现我们的购物车是空的，因为购物车上下文不是持久的。那么，如果我们想允许我们的用户创建账户并查看运输进度、订单历史和其他有用的信息呢？
- en: 'As you can imagine, these are complex topics, and there''s no way we can manage
    them in one chapter exclusively. One thing''s for sure: once we know how to handle
    users and authentication via Auth0, product inventory and order history on GraphCMS,
    and checkout on Stripe, we have all the elements we need to create rock-solid
    user experiences and development workflows.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想，这些都是复杂的话题，我们不可能在一个章节中专门处理它们。有一点可以肯定：一旦我们知道了如何通过Auth0处理用户和身份验证，如何在GraphCMS上管理产品库存和订单历史，以及如何在Stripe上完成结账，我们就拥有了创建稳固的用户体验和开发工作流程所需的所有元素。
- en: 'The Vercel team also announced Next.js Commerce in the latest releases, a template
    ready to be attached to Shopify, Saleor, BigCommerce, and a few more e-commerce
    platforms to create a custom UI instantly for your storefront. The reason why
    we''re not digging into that template is simple: it is compelling, but it abstracts
    most of the work that is needed to connect different systems (such as Stripe and
    GraphCMS, or PayPal and WordPress), and we want to understand how to do it ourselves
    for the sake of learning more.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Vercel团队也在最新版本中宣布了Next.js Commerce，这是一个可以立即附加到Shopify、Saleor、BigCommerce等几个电子商务平台的模板，以创建店面自定义UI。我们之所以没有深入研究这个模板，原因很简单：它很有吸引力，但它抽象了连接不同系统（如Stripe和GraphCMS或PayPal和WordPress）所需的大部分工作，而我们想为了学习而自己理解如何完成这些工作。
- en: In this chapter, we saw how to integrate a headless CMS into our Next.js frontend.
    But if you found it easy, that's mainly because GraphCMS has been wisely built
    with the developer experience in mind, allowing us to take advantage of well-written
    GraphQL APIs built for the modern web era.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何将无头CMS集成到我们的Next.js前端。但如果你觉得这很容易，那主要是因为GraphCMS被明智地构建，以开发者的体验为出发点，使我们能够利用为现代网络时代构建的优秀的GraphQL
    API。
- en: 'We can''t say that the same applies to other CMSs, born when the web was still
    young and evolving, maintaining a full-stack approach, where we used the CMS itself
    to build both the backend and the frontend of our applications. But today, even
    those older CMS platforms are evolving thanks to an incredible community effort,
    aiming to provide a great developer experience by allowing us to adopt Next.js
    (or any other framework) as a frontend. For example, there''s a fantastic WordPress
    plugin that generates excellent GraphQL APIs from an existing website; that way,
    we can use WordPress as a complete headless CMS, creating a robust, performant,
    custom Next.js frontend. You can learn more about this plugin at https://www.wpgraphql.com.
    The same applies to Drupal, another popular, open source CMS that can expose GraphQL
    APIs thanks to the GraphQL module: [https://www.drupal.org/project/graphql](https://www.drupal.org/project/graphql).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能说同样的情况适用于其他在互联网仍处于幼年和成长时期诞生的CMS，它们采用全栈方法，即我们使用CMS本身来构建应用的后端和前端。但如今，即使是那些较老的CMS平台也在社区不可思议的努力下不断发展，旨在通过允许我们采用Next.js（或任何其他框架）作为前端来提供出色的开发者体验。例如，有一个出色的WordPress插件可以从现有网站生成优秀的GraphQL
    API；这样，我们可以将WordPress作为一个完整的无头CMS使用，创建一个强大、性能优异、定制的Next.js前端。您可以在https://www.wpgraphql.com了解更多关于这个插件的信息。同样的情况也适用于Drupal，另一个流行的开源CMS，它可以通过GraphQL模块暴露GraphQL
    API：[https://www.drupal.org/project/graphql](https://www.drupal.org/project/graphql)。
- en: In the followingchapter, we will briefly recap what we've seen so far and see
    some example projects that we can build to practice more with Next.js.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将简要回顾到目前为止我们所看到的内容，并看看我们可以构建的一些示例项目，以进一步练习使用Next.js。
