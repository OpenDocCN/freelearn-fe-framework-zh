- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scalable Front-End Architecture for Angular Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular is a powerful and extensive framework for building web applications.
    According to the 2023 Stack Overflow developer survey, it is the fourth most used
    web technology after ReactJS, NodeJS, and jQuery among professional developers.
    Due to the structure and tools it provides, Angular is often chosen when building
    large web applications or enterprise solutions comprised of several applications
    and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: This book will guide you through the process of effectively using the Angular
    framework to develop and test applications of any size. You’ll start by learning
    about front-end architecture and setting up a scalable workspace with Nx that’s
    ready for hundreds of Angular applications. Next, you’ll explore the most powerful
    and newest features within the Angular framework. You’ll learn about reactive
    programming and state management using RxJS, Signals, and NgRx, and will be able
    to test Angular applications with Jest and Cypress. Upon completing this book,
    you’ll be able to effectively use the Angular framework and develop scalable,
    enterprise-ready Angular applications, utilizing all the tools Angular has to
    offer while implementing best practices and sound design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will create your Angular workspace using Nx. You’ll start
    by learning what we mean by scalable front-end architecture and why it is essential
    to think about your architecture before you start writing code. You will also
    learn about different patterns in front-end architecture and what to consider
    when building enterprise-ready solutions from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you will explore and use Nx, the build tool that allows you to create
    scalable Angular monorepos. By the end of this chapter, you will understand crucial
    aspects of front-end architecture and have your own Nx monorepo for Angular, ready
    to handle hundreds of applications easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding scalable front-end applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different approaches to scalable front-end architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Nx and why should you use it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a scalable Angular workspace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By the end of this chapter, we will create an Nx monorepo with an Angular application
    and library in it. To follow along, you’ll need to install some tools. Note that
    we will only use freely available tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visual Studio Code** (**VS Code**) as your **integrated development** **environment**
    (**IDE**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chrome web browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular 17.1 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NodeJS version v20.11.0 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript version 5.3.3 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nx version v18.0.7 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this book, we will use Angular 17.1, NodeJS 20.11.0, TypeScript 5.3.3,
    and Nx 18.0.7.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository for this book is available at [https://github.com/PacktPublishing/Effective-Angular](https://github.com/PacktPublishing/Effective-Angular).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding scalable front-end applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern web applications are constantly getting bigger and more complex. Because
    of this, developing scalable front-end applications is more critical than ever.
    To create scalable front-end applications, we need to understand what scalability
    means in the context of a front-end application.
  prefs: []
  type: TYPE_NORMAL
- en: What is scalability?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing that might come to mind when you hear the term **scalability**
    is handling more traffic. However, in the context of front-end applications, when
    talking about scalability, we mostly mean the scalability of the code base. Or,
    more concisely, the code is easy to extend, and modules or micro front-ends can
    be added to the software without much work. Components and libraries are reusable;
    the code is easy to maintain, test, and debug, even when the application grows.
    You can work with different teams on separate parts of the application, and onboarding
    new teams that write similar code is easy to achieve and enforce. The application
    has good performance and small bundle sizes. Compile and build times remain low,
    and deployment can be done swiftly to different staging environments if needed.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve these feats within your front-end applications, you must create a
    good architecture, a set of tools, and rules everyone can adhere to. Your architecture
    will include elements such as your repository type, folder structure, architectural
    patterns, design patterns, a programming language, framework, and tools for building,
    testing, linting, and deploying your application. Making the right decisions for
    each part of your architecture helps with creating scalable applications that
    are easy to maintain and extend.
  prefs: []
  type: TYPE_NORMAL
- en: When making architectural decisions, you should aim to create a fast, loosely
    coupled, testable system. You want to avoid direct dependencies between different
    parts of your system so that you don’t get stuck and need to refactor the entire
    application when the business introduces changes.
  prefs: []
  type: TYPE_NORMAL
- en: With this brief introduction to what a scalable front-end application is, let’s
    understand the importance of a good front-end architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Why is front-end architecture important?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Good architecture is essential to maintain a good workflow for the developers
    working on the software and makes it easy for new teams and team members to join.
    If developers spend much time refactoring or waiting for builds or tests to complete,
    they wander off and do less productive things.
  prefs: []
  type: TYPE_NORMAL
- en: With good architecture in place, the code base remains manageable, even when
    your applications grow. Without good architecture, the code becomes messy and
    hard to debug or extend. As time progresses, such problems will pile up, and developers
    will be wasting more time on bugs and refactoring than creating new features,
    especially in large enterprise solutions where business needs are constantly changing.
    Before you know it, you will have a web of dependencies, and adding simple things
    will become very time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you’re building an application for employee scheduling that includes
    a calendar component. You want to avoid tight coupling between the calendar and
    scheduling applications. When management lets you know the company is adding another
    application – let’s say a project management tool that also includes a calendar
    – you don’t want to redo the entire calendar component and scheduling application
    because the two are tightly coupled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the development process with and without architecture.
    Without architecture, you start fast, but in the end, you are crawling. With architecture,
    you will have a consistent and predictable work pace:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: Development speed](img/B21625_01_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Development speed'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand what we mean by scalable front-end applications and
    why having good architecture is essential to achieve them, we will dive into some
    approaches to scaling front-end applications and learn about their advantages
    and trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: Different approaches to scaling front-end applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to architecting software, it’s essential to think of what you
    are building, what it can grow into, what the context is, and who will work on
    it. Depending on these parameters, you’ll want to create an architecture that’s
    flexible enough to grow and adapt without overengineering it, making things more
    complex and time-consuming than needed.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you’re building a simple website for a small family-owned business,
    you don’t need elaborate architecture and complex design patterns; this will make
    things more complex and time-consuming than they need to be. The needs for the
    website will probably stay mostly the same, and the code base will remain small
    and manageable. But when you’re building enterprise software comprised of multiple
    applications, the needs and utility of those applications will change quite a
    bit, and you’ll want to ensure that the software is set up for that.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn about different architectural choices so that
    you can ensure you don’t over or under-engineer your front-end applications. You
    will learn about different repository structures and architectural patterns that
    are commonly used within Angular applications. Without further ado, let’s learn
    about the differences between mono and poly repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Monorepo or polyrepo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Monorepo** and **polyrepo** are two options for storing code within a source
    control application such as GitHub. If you create a new repository for each project
    or application, it’s called a polyrepo or multi-repos structure. Meanwhile, when
    all applications are in one large repository, it’s called a monorepo structure.
    For large companies, a monorepo can easily contain hundreds of applications.'
  prefs: []
  type: TYPE_NORMAL
- en: What option should you pick when developing a large front-end environment? Let’s
    start exploring the advantages and disadvantages of both solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of monorepos
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some of the key advantages of monorepos are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Easy code sharing**: Monorepos make it easy to share code among different
    projects and teams. You have the code of all projects in one directory, so inspecting
    or reusing code from another project and sharing things in libraries is simple.
    This helps prevent duplicate code, gives you inspiration and guidance on solving
    similar issues, and allows you to quickly check if a bug originates in your code
    or the implementation of a library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uniformity among different applications**: Because all code resides in one
    repository, enforcing uniformity among different applications is easier. You can
    ensure that the same tooling is used, code conventions and best practices are
    applied, and all applications are tested similarly. Also, testing the entire system
    is easier with a monorepo.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No versioning conflicts**: In a monorepo, dependencies commonly share the
    same version among all applications. This ensures that no versioning conflicts
    occur and implementations are equal in all applications. Furthermore, it ensures
    that applications that are not actively developed still get regular updates for
    their dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-project refactoring**: If you want to refactor something that occurs
    in many applications, you can do it in one go for all applications or efficiently
    run scripts to perform these actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quick code movement and debugging**: Code can quickly be moved from one project
    to another, and when you encounter a bug within a library, you can fix the bug
    without holdups and continue your work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shared commit timeline**: Lastly, a monorepo has one shared commit timeline.
    This makes it safe to create atomic commits with changes in multiple applications.
    This happens because if anything goes wrong, you can always revert to a common
    state of all applications through the commit timeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regardless of these advantages, monorepos have some shortcomings too. We’ll
    look at them in detail in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of monorepos
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some of the disadvantages of monorepos are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Large folder structure**: A monorepo can be daunting because all code and
    libraries live in one large solution. If you have yet to work with a monorepo,
    this might take some time to get used to. Because it’s so easy to use code from
    other projects, you need to be extra careful not to create unwanted dependencies
    between applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex package updates**: Updating packages and dependencies in a monorepo
    can be complicated because, often, all projects need to update at once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Breaking changes**: Because there are no different versions, when you make
    changes in libraries, you can break other applications without noticing it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slow build times**: In a monorepo, building and testing can become time-consuming
    if not managed correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Challenges in deployment**: Deploying applications modularly can be more
    challenging compared to polyrepos, where everything is separated and modular by
    nature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most disadvantages can be mitigated with the right tools. For monorepos comprised
    of Angular applications, you can use Nx, giving you everything to handle a monorepo
    without these disadvantages. In this book, we will work with a monorepo and Nx.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to the advantages and disadvantages of polyrepos.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of polyrepos
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The key advantages of polyrepos are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A higher level of isolation between applications**: The most apparent advantage
    of a polyrepo is higher levels of isolation between your applications. Each project
    has a repository and developers can do whatever they want within that repository
    without affecting other projects too much.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility with dependency management**: When using a polyrepo, each project
    can manage versions of its dependencies on its own. This gives the teams working
    on the projects more freedom when updating dependencies and offers more stability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Individual tooling**: With a polyrepo, there is more flexibility for using
    different tools and programming languages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to manage**: A polyrepo is generally easier to manage, especially for
    smaller teams. There is little code in each repository compared to a monorepo,
    so there are fewer things you can affect with your changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Straightforward modular deployment**: Deploying your applications modularly
    is more straightforward.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In-line with a micro front-end architecture**: Lastly, if you’re developing
    with a micro front-end architecture, using a polyrepo might feel more in tune
    with the rest of your architecture. However, micro front-ends can be achieved
    with both a monorepo and polyrepo structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before you pick between a monorepo or polyrepo structure, you must also consider
    the drawbacks of polyrepos. These are described in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of polyrepos
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some common disadvantages of polyrepos are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Difficulties in code sharing**: First, because code resides in isolation,
    it is harder to share code between applications. This can result in different
    implementations for the same problem or duplicate code in various projects. Teams
    will often create their own solution instead of contributing to a library that
    solves shared problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boundaries between projects and libraries**: When you depend on a library
    that resides in another repository, and you run into a bug, it will be more time-consuming
    to fix the issue. Often, you need to wait for other teams to fix the bug in the
    library and deploy a new version before you can continue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Challenges when testing multiple repositories**: Testing applications can
    become more challenging. Predominantly when applications consist of different
    modules that reside in different repositories, testing the entire system can be
    difficult.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Difficulties in creating CI/CD pipelines and deployments**: Creating CI/CD
    pipelines and deployments of the whole system might become more challenging as
    you need multiple repositories to complete the tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency conflicts**: Lastly, you can run into dependency conflicts. Different
    applications need to work together in production and can depend on similar dependencies.
    You can encounter compatibility issues when these applications use different versions
    of the set dependency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, you learned about the advantages and disadvantages of storing
    your code in a monorepo or polyrepo. Next, you will learn about different architectural
    patterns that are commonly used with Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Architectural patterns for Angular applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Architectural patterns focus on how you structure your code and provide rules
    for abstracting business logic away from specific implementations. Architectural
    patterns are an extensive topic and there are entire books dedicated to it; so,
    it will be impossible to cover everything in this section. Still, we will briefly
    cover some of the most common architectural patterns that are used with Angular
    and Nx. In [*Chapter 5*](B21625_05.xhtml#_idTextAnchor083), we will dive into
    design patterns while focusing on code implementations instead of providing a
    high-level view of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s dive into some architectural patterns and learn what they try to
    achieve, how they try to achieve it, and what their advantages and disadvantages
    are.
  prefs: []
  type: TYPE_NORMAL
- en: Common architectural patterns in Angular applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most architectural patterns try to accomplish the same at their core, only with
    little nuances and different terminologies. Regarding architectural patterns for
    Angular applications, they try to separate domain and business logic from implementations
    and the view. Doing so gives you a loosely coupled system that is easy to test,
    change, and expand without creating dependencies in the wrong places. In this
    section, we will cover the **Model-View-Controller** (**MVC**), hexagonal architecture,
    and layered architecture. These three patterns are some of the most commonly used
    architectural patterns for Angular applications. Other noteworthy patterns are
    the **Model-View View-Model** (**MVVM**), union architecture, and clean architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Without further ado, let’s learn about the MVC pattern and how it can be used
    within Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: MVC in Angular applications
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**MVC** is one of the most commonly used architectural patterns in the world
    of software development. The pattern was first used in the back-end but is now
    also used for front-end applications, or at least something resembling the MVC
    pattern. The MVC pattern is often used for Angular applications because it fits
    well with the tools provided by the framework. As the name implies, MVC consists
    of three parts – the **model**, the **view**, and the **controller**:'
  prefs: []
  type: TYPE_NORMAL
- en: The model declares the data models and handles business and data-related logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The view displays the current state of the model to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The controller acts as a bridge between the view and the model. The controller
    passes the user input to the model so that the model can perform actions and update
    accordingly, after which the controller returns the updated values to the view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we translate this pattern into an Angular application, the model would be
    a service handling the data and data models. The view would be the HTML template.
    Finally, the controller would be the TypeScript file behind the HTML file, commonly
    named the component class. A better implementation is considering the component
    class as part of the view and having an extra facade service (an additional abstraction
    layer creating a simple interface and communication layer between the view and
    business or state-related logic of your application; we will discuss the facade
    pattern in more detail in [*Chapter 5*](B21625_05.xhtml#_idTextAnchor083)) between
    the model service and the view acting as the controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you keep true to the MVC architecture’s original implementation, the model
    directly gives the updated values to the view. To achieve this, in *Figure 1**.2*,
    we would eliminate *steps 4* and *5* and would then go to the view instead of
    the controller. In Angular, this is sort of the case when using the component
    class as a controller, and it results in a tight coupling between the business
    logic and the component classes. Because of that, I prefer to add a separate facade
    service that acts as a controller to fully separate the component classes from
    the business and state layers of my application. By separating the components
    from the state and business logic, you end up with a loose coupling, making it
    easier to change implementations throughout your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2: MVC pattern](img/B21625_01_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: MVC pattern'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know what the MVC pattern entails and how you can implement it
    within your Angular applications, let’s learn about the next common architectural
    pattern: the Hexagonal architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: The hexagonal architecture pattern in Angular applications
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Hexagonal architecture is relatively new compared to MVC and some other architectural
    patterns, such as layered architecture, MVVC, and MVP. The hexagonal architecture
    was introduced in 2005, and people have only started implementing it in Angular
    applications in the last couple of years. It gained popularity because **domain-driven
    development** (**DDD**) became a hot topic, and hexagonal architecture is very
    well suited to combine with DDD. The main principle of hexagonal architecture
    is to separate the core application logic away from the UI and data implementation
    through ports and adapters. Because of that, the architecture is also commonly
    referred to as the *ports and adapter architecture*. But I hear you thinking,
    what are ports and adapters?
  prefs: []
  type: TYPE_NORMAL
- en: 'In simple terms, **ports** are interfaces (or abstract classes) that separate
    your core logic from the UI and code implementations. These interfaces dictate
    how the UI and code implementations can communicate with your application core.
    The **adapters** are the UI and code implementations that connect with your application
    core through the ports. In hexagonal architecture, ports and adaptors come in
    two types, UI and data-related ports and adapters – in other terms, primary and
    secondary adapters and ports. This concept is illustrated in *Figure 1**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3: Hexagonal architecture pattern](img/B21625_01_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: Hexagonal architecture pattern'
  prefs: []
  type: TYPE_NORMAL
- en: When implementing hexagonal architecture, you will have a set of ports and adapters
    for each domain within your application. I like to use a facade service between
    the port interfaces and adapters for more abstraction between the UI, implementations,
    and application core. When using a facade service, the facade can be considered
    as the port itself. Just make sure the facade implements an interface so that
    there is a fixed set of rules for communication with the core and adapters.
  prefs: []
  type: TYPE_NORMAL
- en: Because ports define a fixed set of rules for communicating with your application
    core, you can easily change implementations when business requirements change.
    You can swap UI components without touching your business logic or data implementations,
    and you can change how you persist or fetch your data without touching your views
    or application core. The only thing you need to do is ensure your new implementation
    can connect to the same interface your ports are using to connect everything.
    This approach offers excellent flexibility and a loosely coupled system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clarify things, I want to go over *Figure 1**.3* and translate it into an
    Angular application. We will go from left to right. On the far left, we have the
    primary adapters. Everything the user faces, or triggers, is considered a primary
    adapter: components, directives, resolvers, guards, and event listeners. One step
    to the right, we will find the primary ports. These regular TypeScript interfaces
    (or facade services) dictate how the UI layer communicates with the application
    core. Our application core is in the middle, where we access state management
    and define business and application logic in Angular services. On the right of
    the application core, we have our secondary ports. These ports dictate how the
    application code communicates with HTTP services, state management, in-memory
    persistence, event dispatchers, and other data or API-related logic. Like the
    primary ports, the secondary ports are regular TypeScript interfaces (or facade
    services). On the far right, we have our secondary adapters. The secondary adapters
    implement our HTTP services, local storage persistence, state management, and
    event dispatchers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know what hexagonal architecture is and how you can implement
    it within your Angular applications, let’s take a look at the third and final
    architectural pattern we will discuss: layered architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: The layered architecture pattern in Angular applications
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the name implies, the layered architecture pattern uses different layers
    to separate concerns. For each application section, you create a layer in the
    architecture that sits on top of another layer. When you implement the layered
    architecture pattern in your Angular applications, you should have at least three
    (main) layers: the core layer, the abstraction layer, and the presentation layer.
    Within these top-level layers, you can have additional sub-layers or sibling elements.
    If your application architecture needs more layers, you can add them as needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important thing with layered architecture is that each layer can only
    communicate with the layer above and below itself; the rest of the layers in the
    chain are off limits. Another essential feat is that events and actions flow upwards,
    and data flows downwards. The user triggers an event or performs an action in
    the presentation layer. This layer notifies the abstraction layer of the action
    and the corresponding changes. The abstraction layer sends these actions and changes
    to the core layer, where the business logic is performed and the data changes
    persist. When the core layer has performed the application logic and persisted
    the changes, the data will flow back from the core layer through the abstraction
    layer in the presentation layer, where the view is updated for the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4: Layered architecture pattern](img/B21625_01_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: Layered architecture pattern'
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we will use a layered architecture resembling what’s shown
    in *Figure 1**.4*, with the presentation layer containing dumb, wrapper, and smart
    components. Dumb components only have component inputs to receive data and outputs
    to alert the parent components something has changed. Wrapper components are also
    dumb, but they are used to group multiple components and provide a reusable layout
    or animation. Even though a wrapper container can wrap around dumb components,
    they are the same for the flow of data and separation of dependencies, which is
    why they are placed next to each other in the architecture design. On top of the
    dumb components, we have smart components. These components are, generally speaking,
    specific business use cases or pages, and they inject facade services and implement
    component logic and state.
  prefs: []
  type: TYPE_NORMAL
- en: The next main layer in our architecture is the abstraction layer, where we have
    facade services. These facade services are regular Angular services that implement
    the facade design pattern. These facade services provide additional abstraction
    and are used as a bridge between our smart components and the core layer of the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Our last major layer is the core layer, where the global state management, business
    and application logic, and HTTP services reside. Our HTTP services layer lies
    on top of the state management and business logic layers. We have separate services
    that do nothing but fetch data and pass it to our other core layers; the lower
    core layers never fetch data directly, so we have an additional abstraction layer
    and have better separation of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about the layered, hexagonal, and MVC architectural patterns,
    let’s move on and briefly learn about the advantages and disadvantages of each
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the architectural patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All three patterns we discussed in the *Common architectural patterns in Angular
    applications* section separate the business logic from the implementations and
    presentation code. They all provide abstraction layers but have different approaches
    to creating these layers. First, the MVC pattern might seem the simplest to implement,
    but you can have too many dependencies and implementations in your component classes
    if you don’t add facade services, especially if you let the model part of MVC
    directly communicate with the view. Not only will this tightly couple your view
    with your business logic, but it can also trigger extensive DOM updates. Changing
    implementations can become hard, and unit testing needs a lot of mocking.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have hexagonal architecture. I like this architecture, but it introduces
    a lot of boilerplate code and can feel complex to implement, making it not the
    right fit if you have a lot of junior developers on your team. Nonetheless, the
    significant advantage of hexagonal architecture is that you can easily change
    implementations once everything has been set up. Unit testing the code also becomes
    straightforward because everything is separated into ports and adapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we have the layered architecture. This one offers the best of both
    the MVC and hexagonal architectures: we have clear divisions and good abstraction
    for our core, implementations, and view. Adding more layers to your architecture
    is simple, and the rules are easy to understand, making it a good solution for
    teams with developers of different experience levels. Because of good separation
    and abstractions, you can simply change implementations, and unit testing remains
    easy.'
  prefs: []
  type: TYPE_NORMAL
- en: You now know what the MVC, hexagonal, and layered architectures are, and you
    learned about the advantages and disadvantages of each implementation. In the
    next section, you’ll briefly learn what design patterns are and how they differ
    from architectural patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns used within Angular applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While architectural patterns focus on a high-level overview of how we segment
    and abstract our code, design patterns focus on how we implement things within
    our code. When developing Angular applications, we are already working with some
    design patterns out of the box. This is because Angular is a strongly opinionated
    framework with strong **object-orientated programming** (**OOP**) principles at
    its core. Some design patterns we use by default within Angular applications are
    the observable, dependency injection, decorator, component, and singleton patterns.
    These and other design patterns, such as the factory and inheritance patterns,
    are embedded in how the Angular framework works and should be used throughout
    your application when you use the framework correctly. Because these patterns
    are somewhat concealed within the tools and ways of working of the Angular framework,
    you might be using them without actually understanding how they work at their
    core. Besides these design patterns embedded within the Angular framework, you
    can improve your code by introducing even more design patterns. Some work very
    well in combination with Angular, such as the facade pattern.
  prefs: []
  type: TYPE_NORMAL
- en: As with architectural patterns, design patterns ensure that you adhere to specific
    rules when implementing your code, resulting in code that is easy to adjust and
    extend. They prevent you from making the wrong dependencies throughout your code
    and provide a structured and battle-tested way to approach common problems with
    software engineering. For now, I wanted to briefly explain design patterns and
    list some design patterns the Angular framework uses by default. In [*Chapter
    5*](B21625_05.xhtml#_idTextAnchor083), you will learn about design patterns in
    more detail. You will learn about different patterns, when to use them, and how
    to implement them correctly.
  prefs: []
  type: TYPE_NORMAL
- en: You now know what design patterns are and how they differ from architectural
    patterns. You’ve learned about some patterns that are used within Angular by design
    and that you can add more patterns to improve your code implementations throughout
    your code base. The next topic we will discuss is Nx, which makes structuring,
    creating, maintaining, and testing large Angular monorepos easy.
  prefs: []
  type: TYPE_NORMAL
- en: What is Nx and why should you use it?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn what Nx is and why it’s such a fantastic tool
    for developing Angular applications at scale. **Nx** is rapidly becoming the go-to
    tool for developing large monorepo front-end applications. So, what exactly is
    Nx and why should you use it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Nx is a tool that helps you to speed up, streamline, and standardize your development,
    testing, build, and deployment process. The Nx tooling offers various features
    and integrations you can utilize during every stage of development. Nx was created
    so that you can adopt it incrementally by picking and choosing what you want to
    use or add to your current environment. At its core, Nx helps you with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Speeding up the build and test times of your applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing dependencies and running tasks within monorepo projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swiftly scaffolding new code snippets, applications, and libraries without needing
    to worry about configuring build tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating new tools into the projects of your monorepo workspace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring uniformity and consistency within the code of different projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating applications and tools through automated code migration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceding tasks, multiple tools, features, and options, such as a CLI,
    generators, and plugins, help you achieve your goals and streamline processes.
    The tools and features Nx has to offer are divided into different modules in their
    ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, you have the Nx **command-line interface** (**CLI**). Similar to
    the Angular CLI, it lets you run commands for tasks such as creating workspaces,
    scaffolding projects, testing projects, or serving and building. Next, the **Nx
    package** contains all the fundamental technologies Nx offers: task running, workspace
    analysis, build caching, scaffolding, and automated code migrations. Then, there
    are plugins, which are NPM packages that extend the fundamentals of Nx and can
    be created by the Nx community for various purposes, such as generating projects,
    integrating tools, and adding or updating libraries. Another element of Nx is
    its **Devkit**, which can be used to build plugins to extend the Nx tooling to
    your specific needs. Nx also has something called **Nx cloud**, which speeds up
    your CI with remote caching and distributed task executions, but this is outside
    the scope of this book. Lastly, we have the **Nx console**, an extension for VS
    Code, IntelliJ, and VIM, making it much easier to manage your Nx workspace and
    run Nx commands.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know what Nx does at its core, let’s examine it in more detail
    and see how it can help you build scalable monorepos for your Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: How Nx helps you build Angular monorepos that scale
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you understand what Nx is at its core, let’s dive deeper and explore
    how it helps you build, test, and standardize your Angular applications. We will
    begin with one of the main features Nx offers: speeding up tasks such as building,
    serving, and testing.'
  prefs: []
  type: TYPE_NORMAL
- en: Improving build times with computational caching and incremental builds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Typically, when we run tasks with the Angular CLI, such as `ng build` or `ng
    serve`, our entire application and all the libraries it depends on need to be
    compiled to complete the build or serve your application. This can become time-consuming
    as the application grows. The result is slow CI builds and developers waiting
    for the application to compile each time they want to start or test it. Nx helps
    to resolve these issues with incremental builds and computational caching.
  prefs: []
  type: TYPE_NORMAL
- en: With computational caching, Nx will check if anything has changed since the
    last time you ran a command. If nothing has changed or the build computation is
    equal to a previous cached run, Nx won’t rerun the command and instead take the
    results from its caching system. First, it will look at the local caching, and
    if you set up remote caching with Nx cloud, it will also check if it can find
    the same computational hash in the remote cache. If Nx cannot find the same computational
    hash, it will run the command and store the hash of the result in the Nx cache.
  prefs: []
  type: TYPE_NORMAL
- en: Besides computational caching, Nx helps speed up our build and compile times
    with incremental builds. When using incremental builds, we only build projects
    that have been changed since your last build. In a regular scenario, we build
    the application and all the libraries the application uses. As the application
    grows and depends on many libraries, it can become time-consuming and costly to
    rebuild everything each time you build the application. To use incremental builds,
    your libraries must be buildable so that Nx can cache the libraries and only build
    them if they changed since your last build. When you’re building smaller applications,
    you might not want buildable libraries with computational caching because making
    a library buildable has some overhead as well. When you create a library in your
    Nx workspace, you can choose if you want it to be standard, buildable, or publishable.
    We will dive deeper into this topic in the *Structuring Angular applications and*
    *libraries* section.
  prefs: []
  type: TYPE_NORMAL
- en: Running tasks effectively in a monorepo with Nx
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Running tasks, such as `ng build`, `ng test`, and `ng lint`, with the Angular
    CLI in a single Angular project is straightforward. But things become more complicated
    when you have a monorepo with tens, hundreds, or even thousands of applications
    and libraries. In many scenarios, you want to run tasks simultaneously for multiple
    (or all) projects. Sometimes, you want to run specific tasks when something changes
    in a project, or you need to know if changes in a library have affected other
    projects and break them. If you perform these tasks by running commands one by
    one, this becomes unmanageable quickly, and building tools to watch and check
    for the affected projects becomes complicated. Luckily, Nx has everything we need
    to run tasks for multiple or affected projects, watch for changes, and react to
    them with commands.
  prefs: []
  type: TYPE_NORMAL
- en: When you use the Nx CLI, it is advised not to use the Angular CLI within the
    monorepo. We want Nx to do all its magic, and this is not possible if we start
    to generate things with the Angular CLI. Luckily, Nx has you covered!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the basics – running commands for a single project using the
    Nx CLI. Running tasks for a single project is similar to running tasks with the
    Angular CLI. For example, if we want to run the tests for an application named
    **testApp**, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to run tasks for multiple projects, we can use the `run-many` keyword
    combined with the `-p` flag to define the projects for which we want to run the
    tasks. If you omit the `-p` flag and only use the `run-many` keyword, the task
    will run for all projects. We can also add the `-t` flag to run multiple tasks
    at once. For example, if we want to build, lint, and test all projects, we can
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s say we only want to build, lint, and test *testApp* and *testApp2*.
    For this, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, running commands with the Nx CLI is simple, even if you need
    to do it for multiple or all projects within your monorepo. Even if you want to
    run several tasks simultaneously for a subset or all projects, you can do it quickly
    and with a single command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another helpful option is to watch for changes in specific projects and run
    scripts whenever changes occur in a watched project. For example, you can watch
    for changes in an application and echo the project name and the changed filename.
    This can be done for single projects, a subset of projects, or all projects, like
    running regular commands. Here’s an example of what this command will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need something to detect the affected projects and run commands
    for them. When a monorepo grows, it becomes too time-consuming to run tests for
    all projects every time you change a library. Consider the following scenario.
    We have five applications and three libraries being used by those applications.
    Now, if we change the code of a library and all five projects use this library,
    our changes can affect and break the four other projects we aren’t working on
    ourselves. This can be a massive problem if we release an application or library
    to production without noticing we broke another application with our changes.
    When we make changes in a library, we need to know what projects in the monorepo
    are affected by those changes and run the appropriate tests to see if everything
    still works. For this scenario, Nx has *affected commands*. By running these commands,
    you can run tasks such as linting and testing for all projects affected by your
    changes. The following is an example of such a command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With that, you have basic knowledge of running tasks in an Nx monorepo. Next,
    let’s explore how Nx helps us keep the code and setup in our monorepo projects
    standardized and uniform.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring uniformity and consistency within your Nx monorepo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another critical aspect of a scalable Angular monorepo is uniformity and consistency
    in the code of the different applications within the monorepo. When you have hundreds
    of projects in your monorepo, you don’t want different code conventions and implementations
    in each project. This would make it much harder for developers to start working
    on other projects within the monorepo, and it also makes it harder to find similar
    code or refactor code in bulk. When everyone uses the same conventions and code
    patterns, each developer can work on every project within the monorepo and make
    changes when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Nx helps us maintain uniformity with global linting rules that apply to all
    projects within the monorepo. You can set up these linting rules however you see
    fit and can even create custom linting rules. Besides global linting rules, you
    can also apply specific lint rules for individual projects.
  prefs: []
  type: TYPE_NORMAL
- en: Nx generators are another great way to enforce uniformity within your Nx monorepo.
    Generators are used to generate applications, libraries, components, and other
    code snippets. You can even use Nx generators to modify your code throughout the
    monorepo or set up and change configuration files. This can be very useful when
    you need to apply refactoring to multiple files of your monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: Using generators ensures that things are created in the same manner by all developers
    working within the monorepo. Executing generators can be done with the terminal,
    though when using the Nx console, you get a nice user interface for executing
    them. You can also overwrite the built-in generators so that fewer options are
    revealed, and the default values are set. This reduces variation and makes the
    generators easier to use for less experienced developers. We will dive deeper
    into this topic when we create an Nx monorepo in the *Setting up a scalable Angular
    workspace* section. For now, it’s important to know that you must use generators
    whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing I want to mention on uniformity is **Prettier**. Nx has built-in
    support for the code formatter Prettier. As with linting rules, formatting rules
    can be configured for the entire monorepo and individual projects within the monorepo.
    You can also run a command with the Nx CLI to detect unformatted lines of code.
    When you configure VS Code to auto-format on **Save**, Prettier will format your
    code whenever you save a file.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve learned how to manage monorepos with Nx, we will explore how
    you can update and manage dependencies in an Nx monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: Nx dependency management and code migrations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Managing dependencies in an Nx monorepo is easy since there is one `package.json`
    file for the entire monorepo (this is only the case for integrated monorepos,
    but we’ll cover this in more detail when we create our monorepo in the *Setting
    up a scalable Angular workspace* section) and most packages can be updated automatically,
    including configuration and code changes needed for that update. Running automated
    updates can be done by using the `nx migrate` command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, you will update to the latest version of the Nx package and dependencies;
    in that case, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding command will update your `package.json` file and generate
    a `migrations.json` file containing all the migrations that Nx and its plugins
    need to run to update all packages successfully. To execute these migrations,
    you need to run the `migrate` command with an additional flag, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After running this command, your packages, configuration files, and code will
    be updated to use the latest versions of Nx and the plugins configured within
    the workspace. For packages that don’t have a plugin, you need to do the updates
    manually as you do with NPM packages. Packages with a plugin will do everything
    for you with Nx migrations. There are plugins for Angular, Jest, Cypress, and
    most other things you will use within the Nx monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another cool feature for managing dependencies is that Nx lets you visualize
    dependencies on a graph. With this, you can see what projects depend on one another
    and zoom in on these nodes to better view the dependencies. This works for projects
    as well as tasks. If you have tasks that run multiple tasks in a chain, you can
    also visualize this task chain on a nice graph. The **Nx graph** is a valuable
    tool as visualization helps you better understand your monorepo’s structure. If
    you can no longer make sense of the dependencies in the graph, chances are that
    they won’t make sense in your code either. You can open the graph by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want a graph of the affected projects, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, you can use tags to set up boundaries throughout your monorepo so that
    projects can only import what they’re supposed to import. If you try to import
    a library you aren’t supposed to, the code won’t compile, and an error will inform
    you that you aren’t allowed to use the library within your project. When we create
    our monorepo in the *Setting up a scalable Angular workspace* section, we’ll set
    up these boundaries as well.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, Nx is a vast topic that offers us many tools for managing
    monorepos. As we progress through this book, we will learn more about Nx, but
    for now, you have a good idea of what Nx is and how it can help you manage Angular
    monorepos of any size. Now, we will move on to creating an Nx monorepo, including
    some Angular projects and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a scalable Angular workspace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final section, we will create an Nx monorepo, along with some placeholder
    Angular applications and libraries for demonstration purposes. We’ll start by
    adding some extensions in VS Code to make our developer experience more pleasant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following extensions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular Essentials (version 16): Angular Essentials is comprised of eight different
    extensions that are useful for Angular development'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nx console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you’ve installed these extensions, you will probably need to reload VS
    Code for all of them to be applied, so restart your VS Code application. After
    this, you should see an Nx icon on the left-hand side of VS Code; this is the
    Nx console. When you have successfully installed the various VS Code extensions,
    you must globally install the `Nx` and `Cypress NPM` packages. To do so, you can
    run the following command in the terminal of your choice. I like to use the integrated
    VS Code terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once these NPM packages have been installed, we can create our Nx workspace.
    Find a folder where you want to create the Nx monorepo and open a terminal at
    this location. To create the Nx workspace, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this command, you will be prompted with several questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Where would you like to create your workspace? (`business-tools-monorepo`.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which stack do you want to use? (Angular: Configures an Angular app with modern
    tooling.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Standalone project or integrated monorepo? (Integrated monorepo: Nx creates
    a monorepo that contains multiple projects.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Application name (`Invoicing`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which bundler would you like to use? (`esbuild`.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Default stylesheet format (`SASS(.scss)`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you want to enable **server-side rendering** (**SSR**) and **static site
    generation** (**SSG**)? (No.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test runner to use for **end-to-end** (**e2e**) tests (Cypress).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up CI with caching, distribution, and test deflaking (Skip).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Would you like remote caching to make your build faster? (Yes.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you’ve answered these questions, the Nx monorepo will be created in a folder
    called `business-tools-monorepo`. We will dive into what Nx created for us in
    the *What did Nx create in our new workspace?* section, but first, I want to explain
    the different types of workspaces you can create with Nx.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nx workspaces come as standalone projects, package-based monorepos, and integrated
    monorepos:'
  prefs: []
  type: TYPE_NORMAL
- en: Standalone projects are well suited for when you want to start with a single
    project but keep the door open for growing into a large monorepo. Nx is also useful
    for single projects as you can utilize their generators and automated updates
    through Nx migrations and executors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we have package-based monorepos. This solution is beneficial when you
    need to add a lot of exciting projects to an Nx workspace. With package-based
    repos, each project in the Nx workspace has its own dependencies. You will get
    the improved speed and task running from Nx, but Nx will stay out of your way
    for the rest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, there are integrated Nx monorepos. This is what we’ll be using and is
    the setup where you leverage all the tools Nx has to offer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s see what Nx created f when it generated the monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: What did Nx create in our new workspace?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you open the `business-tools-monorepo` folder in V SCode, you will see
    five folders and a couple of files in the root of the monorepo. We will review
    the essential files and explain the folders, but first, let’s briefly lay out
    what Nx did for us when it generated the monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: Nx created our monorepo and configured it for building Angular applications.
    It installed the Nx Angular plugin and all the essential NPM packages needed to
    develop Angular applications. Besides that, Nx configured everything for computational
    caching, ESlint, Cypress e2e testing, and unit testing with Jest, and Prettier
    for code formatting. Nx also made our first Angular application, `apps` folder.
    The `apps` folder will contain all the applications we create in our Nx monorepo.
    If you open the `apps` folder, you will notice that Nx also created an `invoicing-e2e`
    project. This is a Cypress project for e2e testing our Angular invoicing application.
    All of these things will work out of the box. Nx did all the configuration for
    us. In the folder structure, we’ll see a folder named `apps`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at some important files that Nx created in our workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nx.json`: This is used to configure the Nx CLI and its default configurations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.eslintrc.json`: This file can be found at the root of your monorepo and inside
    each project in the repo. The file in the root contains the global ESlint rules
    that are applied to all projects within our monorepo. The files within the specific
    projects contain project-specific ESlint rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`project.json`: This can be found at the root of our Angular application (`apps\invoicing\project.json`).
    In a regular Angular application, this would be our `angular.json` file. It has
    the same content and usage. The `project.json` file will be created for each project
    in our Nx monorepo.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tsconfig.base.json`: This is used for global TypeScript settings and setting
    up aliases for library imports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn more about these files and how to edit them throughout this book
    and when we start to add projects, libraries, and plugins to our Nx monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: Improving our Nx workspace for better Angular development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already have a nice workspace from Nx that will scale pretty well out of
    the box. You can uniformly create Angular applications, libraries, and other classes
    throughout the workspace. For each application or library you create, Jest unit
    testing is configured, and for each application, you get a Cypress project with
    everything you need to run e2e tests. ESlint and Prettier are configured for the
    entire monorepo to keep your code uniform among the different projects. The monorepo
    has automated updates with Nx migrations; you can visualize your dependencies
    and tasks with the Nx graph and effectively run commands against your monorepo
    with the Nx task runner. The first step I like to take is creating a `libs` folder
    next to the `apps` folder. Inside this `libs` folder, we will store all our libraries.
    To improve this further, we need to add some extra ESlint rules, create custom
    generators tailored to our needs, and set up project boundaries with tags.
  prefs: []
  type: TYPE_NORMAL
- en: Adding ESlint rules to improve our Angular code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use lint rules to keep our code uniform and ensure that developers don’t
    implement code in unintended ways. Linting can catch bugs preemptively and enforce
    best practices. Nx has already added Angular-specific lint rules for our monorepo
    with two `@angular-eslint` packages. To make our monorepo more robust, we’ll want
    to add some extra ESlint rules tailored for Angular and RxJS. The lint rules we
    will add are not required, but I suggest using them or adding rules according
    to your preferences when setting up a monorepo. This is important so that everyone
    working on your code will follow the same implementation and style guide rules
    for writing code. Each company and code base uses its own conventions, so make
    sure you have lint rules in place to enforce them. If you can’t find lint rules
    that enforce your code conventions, Nx also allows you to add custom lint rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will add some NPM packages as dev dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When the command has finished running, the packages will be added to the `package.json`
    file in the root of your Nx monorepo, and the lint rules belonging to these packages
    can be added to the `.eslintrc.json` files. We will only add rules to the `.eslintrc.json`
    file at the root of the monorepo. These lint rules will be applied to all the
    projects within the monorepo. We also need to add `parserOptions` to the `.eslintrc.json`
    file because we’re working with TypeScript and type-based lint rules. You can
    find the updated `.eslintrc.json` file in this book’s GitHub repository (link
    in the *Technical* *requirements* section).
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve added the extra lint rules and `parserOptions`, we can move on and
    start creating some custom Nx generators.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom Nx generators for our Angular monorepo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generators are excellent tools to do things uniformly because everyone who uses
    the generator will have the same result. First, we’ll focus on overwriting built-in
    Angular generators. Throughout this book, we will create and use generators to
    refactor code in our monorepo and to create custom code snippets.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will overwrite the generator for creating Angular libraries.
    We will significantly reduce the options you can enter when using the generator,
    add custom options to enforce a directory structure, and add tags for project
    boundaries. Fewer options means less deviation from the conventions your organization
    is using, resulting in more uniformity and fewer questions from less experienced
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating an Nx plugin using an Nx generator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the plugin generator, install the NPM package by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, on the left-hand side of VS Code, click on the Nx icon to open the Nx console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **GENERATE & RUN TARGET** tab and click **generate**. This will open
    a dropdown with a search bar at the top of VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this search bar, enter `plugin` and select the **@nx/plugin - plugin Create
    a Nx plugin** option. This will open a new window in VS Code where you can generate
    your plugin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, the generator will ask you to fill out two fields, a *name* and
    an *import path*, and a directory, of which the name is required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your plugin `workspace-generators-plugin`. For the import path, enter `@business-tools/workspace-generators-plugin`,
    and for the directory, enter `libs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Show** **all options**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **projectNameAndRootFormat**, select **derived**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click on the **generate** button at the top right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will generate your plugin under the `libs` folder at the root of your monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create our custom generator:'
  prefs: []
  type: TYPE_NORMAL
- en: First, click on **generate** again in the Nx console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the search bar, type `generator` and select **@nx/plugin -** **generator**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, in the newly opened window, give the generator a name, such as `generate-angular-library`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `libs\workspace-generators-plugin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Show** **all options**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **projectNameAndRootFormat**, select **derived**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click on the **generate** button at the top right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When this process completes, you will find a `generators` folder inside the
    `src` folder of `workspace-generators-plugin`. Inside this `generators` folder,
    you will find your custom generator, which is named `generate-angular-library`.
    Inside your custom generator are a bunch of files, but before we start exploring
    them, let’s look at what we will overwrite with this custom generator:'
  prefs: []
  type: TYPE_NORMAL
- en: Go back to your Nx console and click **generate** again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This time, search for `library` and choose **option @nx/angular -** **library**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you inspect the new generator window for this library, you will find seven
    options to fill out; if you click on **Show all options**, you will have 30 possibilities
    to fill out. Not all developers will know what to select here, and if we leave
    it up to developers, we will get too much variation when we create libraries within
    our monorepo. For now, let’s close the window for generating an Angular library
    and start to overwrite it with our custom generator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we overwrite an existing generator, we are interested in three different
    files: `generator.ts`, `schema.json`, and `schema.d.ts`. We will write our logic
    inside the `generator.ts` file; the `schema.json` file will contain the information
    for the Nx console window, and the `schema.d.ts` will contain the interface for
    our options inside the `generator.ts` file. Let’s inspect these three files individually,
    starting with the `generator.ts` file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nx has already generated a bunch of code for us in this `generator.ts` file,
    but we won’t worry about all that and instead replace it with the following small
    piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We cleared everything inside the `generateAngularLibraryGenerator` function
    and replaced it with a `libraryGenerator` method from `@nx/angular/generators`.
    This `libraryGenerator` method is the built-in Angular library generator we inspected
    a moment ago. When you want to overwrite built-in generators, you can find them
    in your `node_modules` folder or the GitHub repository of the corresponding package.
    Now, if we build and run our custom generator, we can only enter a name because
    that is the only thing we have in our `schema.json` file, so our custom generator
    generates an Angular library for us with the default settings. So, we went from
    30 options to fill out to only a name. However, we want to add additional options
    and choose specific values for some of the built-in options. We can do this by
    editing the `libraryGenerator` method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Our generated libraries will now be buildable, use standalone components, have
    on-push change detection, use SCSS style, have tags, have an import path, and
    have a directory structure configured. We use a name, domain, and type property
    in our `options` object. The name is configured by default, so let’s add the options
    we want to expose inside our `schema.json` and `schema.d.ts` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `schema.d.ts` file, we’ll find an interface for the `options` object
    we used in the `generator.ts` file. This interface declares a `name` property
    by default. We want to add a domain and type to the interface and only allow preset
    string values for these properties. We can do this by editing the interface like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we want to update our `schema.json` file. This `schema.json` file defines
    the values we can fill out in the Nx console or terminal when using the generator.
    When we generated our custom generator, Nx added a name property for us, so we
    must add the domain and type. We can do this by adding extra objects in the `properties`
    object inside the `schema.json` file. To include the domain, you can add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: For the `type` field, you can add a similar object under the `domain` object.
    The `index` property needs to be one unit higher for the `type` object because
    this index indicates at what position the field will be shown in the Nx console
    when we use the generator.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we build and run the generator, we’ll have three fields to fill out.
    When we fill those fields, a library will be generated for us with all the configurations
    we added.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can improve the generator even more. We can do this by adding an `''all''`
    option to the type. When selecting `''all''`, we generate a library for each type
    at once, and we can add cleanup logic to remove the initial component that comes
    with the generator – in most cases, we don’t want a component named after the
    library. To achieve these improvements, we’ll need to extract the `libraryGenerator`
    method into a separate function underneath the `generateAngularLibraryGenerator`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add an array with our types above the `generateAngularLibraryGenerator`
    function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the `generateAngularLibraryGenerator` function, we’ll replace `libraryGenerator`
    with a `for` loop. This will add a library for each of the available types when
    `options.type` is equal to `''all''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The only thing that is left to do now is to add some logic to clean up the initial
    component files and update the `index.ts` file to remove the export of this initial
    component. Otherwise, if we create a library named `common-components`, for example,
    it will create a component named `common-components-component`, and that is not
    something we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clean up our library, we will use the `tree` parameter that’s exposed to
    us by the `generateAngularLibraryGenerator` function. This `tree` object contains
    our monorepo tree and, in it, all our folders and files. To remove the initial
    component files and update the `index.ts` file when we generate a library, we
    can add the following code at the bottom of our `generateAngularLibraryGenerator`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Once you’ve updated and saved everything, you can test the generator.
  prefs: []
  type: TYPE_NORMAL
- en: Open the Nx console in VS Code. At the top, you will find a section named `projects`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Underneath this section, you will find your **workspace-generators-plugin**
    project. If you expand this, you will see three options: **build**, **lint**,
    and **test**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you hover over the **build** option, you’ll see a **play** button. Go ahead
    and click on this button to build the **workspace-generators-plugin** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the plugin is built successfully, restart VS Code and click on **generate**
    in your Nx console. You should see **@business-tools/workspace-generators-plugin
    -** **generate-angular-library generator**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You only need to restart VS Code when you add a new generator or adjust `schema.json`
    because Nx schematics are loaded when you open VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the generator, there are three fields where we can enter the name,
    domain, and type. Let’s create a library called `common-components` and then select
    `libs\shared\ui\common-components` path.
  prefs: []
  type: TYPE_NORMAL
- en: We will also overwrite the component generator. You can go ahead and try to
    do this yourself. If it still feels challenging, you can go to this book’s GitHub
    repository and take the code from there (link in the *Technical requirements*
    section). If you did the overwrite on your own, please check if you implemented
    it the same as we did so that you can continue using the same generators throughout
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you know how to overwrite generators and have created your first
    custom generator to build Angular libraries. Next, we will create project boundaries
    for the Nx monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up project boundaries for the Angular monorepo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you work in a large monorepo where different teams work on separate projects,
    it is essential to have some boundaries. If you have a library only intended for
    one domain of the monorepo, you don’t want someone to create unintended dependencies
    by importing that library into another domain.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you have a library intended for finance-related applications,
    you don’t want it to be imported into a marketing application and create a dependency
    between our finance and marketing domains. What’s even worse is if someone made
    a direct dependency between the two applications. If we do this, we have to build
    and deploy both applications when we only want to update and deploy one of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Nx, we can set up boundaries with `project.json` file. The boundaries
    are defined inside the `.eslintrc.json` files. We will only create global boundaries
    in the root `.eslintrc.json` file. Inside this `.eslintrc.json` file, you will
    find the following lint rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can update the `depConstraints` array to update the boundaries for your
    Nx monorepo. By default, the object inside this array uses `*` as a wildcard,
    allowing any project to import every other project. I advise removing this object
    and setting strict project boundaries. For example, if you only want projects
    with domain finance to import other projects with the same domain, you can add
    this object to the `depConstraints` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `sourceTag` component defines the tag we are targeting, while `onlyDependOnLibsWithTags`
    defines the tag it is allowed to import. If you want to see the constraints I
    configured for the monorepo, you can take them from this book’s GitHub repository,
    but you are free to set up the constraints however you like.
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve configured the boundaries, you will get a lint error in VS Code
    if you try to import something you’re not allowed to. After the initial setup,
    you might need to restart VS Code for the boundaries to take effect without running
    the linter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve improved our Nx monorepo and it is ready to host many Angular
    applications and libraries, let’s wrap things up by discussing a good structure
    for our Angular applications and libraries within our monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring Angular applications and libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last thing we must cover is how to structure our Angular applications and
    libraries within the Nx monorepo. Seeing your applications as containers that
    build up their pages with the components and logic from libraries is a good practice.
    This incentivizes a modular approach and makes it easier for you to have a good
    separation of concerns as a dedicated library project is a much greater boundary
    than separating code with folders in your application. Generally speaking, you
    can use the 80/20 rule, where 80% of your code lives within dedicated library
    projects and 20% within your application projects.
  prefs: []
  type: TYPE_NORMAL
- en: These libraries don’t have to be built separately from the projects that consume
    them. If that is the case, everything stays the same regarding your deployment
    process, but you won’t utilize Nx incremental builds and computational caching.
    If you want to use incremental builds or publish your libraries to an external
    registry such as NPM, you can mark them as buildable or publishable when you generate
    them. In our custom generator, we made the libraries buildable by default. For
    small applications, you can consider using regular libraries that aren’t buildable
    unless you want to publish them.
  prefs: []
  type: TYPE_NORMAL
- en: Placing code in a library doesn’t necessarily mean the code has to be general
    purpose and must be consumed by multiple parties; putting code in an Nx library
    can be purely for organizational goals. It stimulates you to think in a more API-driven
    way about your code, often resulting in cleaner implementations with fewer dependencies,
    which, in turn, might result in code that can be reused, but it doesn’t have to
    be. When organizing libraries and applications, you should consider the different
    business domains. Generally speaking, the teams of an organization are aligned
    with these business domains; thus, it makes sense to have a similar organization
    for your monorepo projects.
  prefs: []
  type: TYPE_NORMAL
- en: Do you create a new library or reuse an existing one?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The decision of when to create a new application is pretty straightforward.
    It should probably be an application if it’s a product with a UI that can be used
    or sold independently. For libraries, it can sometimes be harder to define when
    to create a new library and when to add code to an existing library. As with most
    programming decisions, whether to start or reuse a library is about trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: The main benefits of creating a new library and splitting up your code are that
    tasks such as building and testing will be completed faster, you have better visualization
    of your architecture with the Nx graph, and you have more control over project
    boundaries by using tags. The advantages of reusing a library are that you can
    better group related code together without any constraints, so it’s easier to
    experiment and less prone to mistakes. Especially when your code base is rapidly
    evolving, keeping things in one library might be easier for the time being. A
    good practice is splitting things into multiple libraries when the development
    pace slows.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries are generally divided into UI, feature, utility, and data-access libraries.
    Your UI libraries should only contain dumb presentational components. Feature
    libraries contain smart components with access to your facade services and are
    created for business cases or pages within the applications. The data-access libraries
    house state management logic and provide everything to communicate with the back-end
    APIs. Lastly, we have the utility libraries, which host helper functions and other
    useful low-level utilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'All your libraries should be grouped by their respective application or a business
    domain containing multiple applications. For large companies, the libraries can
    be grouped by sections of a specific business domain, depending on how the scope
    of each domain is defined. When you want to move an application or library into
    a new folder within your Nx monorepo, you need to use the Nx `move` generator
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to remove an application or library, you should use the Nx `remove`
    generator, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: For both moving and removing projects, you can use the Nx console for a more
    visual approach. It is important to use the Nx console or run the respective Nx
    command in the terminal to perform these actions because they will automatically
    update all configuration files within your Nx monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1**.5* shows a proposed folder structure, although this is entirely
    up to you and the structure and needs of what you’re building:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5: Folder structure](img/B21625_01_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: Folder structure'
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to the next chapter, let’s clean up our monorepo and add some
    placeholder projects. First, remove the invoicing application we made earlier
    and its corresponding e2e project. You can do this by right-clicking on the project
    and selecting `invoicing-e2e` project; then, remove the `invoicing` project. Once
    you’ve removed both projects, we can create some placeholder applications with
    the custom application generator we took from this book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`expenses-registration` (under the domain finance)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`social-media-dashboard` (under the domain marketing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `placeholder` library we created can stay because it is already equipped
    with tags and a domain and was created with a custom generator. We will create
    extra libraries as we continue and start to add some code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you created an Nx monorepo with some placeholder projects and
    are now ready to scale to hundreds of applications. You learned how to structure
    your Angular applications and libraries within the monorepo, and now know how
    to utilize the essential features of Nx.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore some of the newest and most powerful features
    in the Angular framework.
  prefs: []
  type: TYPE_NORMAL
