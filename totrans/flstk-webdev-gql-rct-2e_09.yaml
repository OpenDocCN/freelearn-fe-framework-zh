- en: '*Chapter 7*: Handling Image Uploads'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All social networks have one thing in common: each of them allows its users
    to upload custom and personal pictures, videos, or any other kind of document.
    This feature can take place inside chats, posts, groups, or profiles. To offer
    the same functionality, we are going to implement an image upload feature in Graphbook.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Amazon Web Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring an AWS S3bucket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accepting file uploads on the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading images with React through Apollo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cropping images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available in the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter07)'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Amazon Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, I have to mention that Amazon—or, to be specific, **Amazon Web Services**
    (**AWS**)—is not the only provider of hosting, storage, or computing systems.
    There are many such providers, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Heroku
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DigitalOcean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS offers everything that you need to run a full-fledged web application, as
    with all the other providers. Furthermore, it is also widely used, which is why
    we are focusing on AWS for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Its services span from databases to object storage, to security services, and
    so much more. Besides, AWS is the go-to solution that you will find in most other
    books and tutorials, and many big companies use it to power their complete infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: This book uses AWS for serving static files, such as images, to run the production
    database and the Docker container for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing with this chapter, you will be required to have an account
    for AWS. You can create one on the official web page at [https://aws.amazon.com/](https://aws.amazon.com/).
    For this, you will need a valid credit card; you can also run nearly all of the
    services on the Free Tier while working through this book without facing any problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have successfully registered for AWS, you will see the following dashboard.
    This screen is called the **AWS Management Console**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – AWS Management Console'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.01_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – AWS Management Console
  prefs: []
  type: TYPE_NORMAL
- en: The next section will cover the options for storing files with AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring an AWS S3 bucket
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this chapter, we will require a storage service to save all uploaded images.
    AWS provides different storage types for various use cases. In our scenario of
    a social network, we will have dozens of people accessing many images at once.
    **AWS Simple Storage Service** (**S3**) is the best option for our scenario. Follow
    these steps to set up an S3 bucket:'
  prefs: []
  type: TYPE_NORMAL
- en: You can visit the **Amazon S3** screen by clicking on the **Services** drop-down
    menu at the top of the page, and then looking under the **Storage** category in
    the drop-down menu. There, you will find a link to S3\. Having clicked on it,
    the screen will look like this:![Figure 7.2 – S3 management screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.02_B17337.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.2 – S3 management screen
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In S3, you create a bucket inside of a specific AWS region, where you can store
    files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The preceding screen provides many features for interacting with your S3 bucket.
    You can browse all of the files, upload your files via the management interface,
    and configure more settings.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will now create a new bucket for our project by clicking on **Create bucket**
    in the upper-right corner, as shown in *Figure 7.2*. You will be presented with
    a form, as shown in the following screenshot. To create a bucket, you must fill
    it out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.3 – S3 bucket wizard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.03_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – S3 bucket wizard
  prefs: []
  type: TYPE_NORMAL
- en: The bucket has to have a unique name across all buckets in S3\. Then, we need
    to pick a region. For me, **EU (Frankfurt) eu-central-1** is the best choice,
    as it is the nearest origin point. Choose the best option for you, since the performance
    of a bucket corresponds to the distance between the region of the bucket and its
    accessor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you need to uncheck the **Block all public access** option and also check
    the acknowledgment with the warning sign. AWS shows us this warning because we
    should only give public access to S3 buckets when really required. It should look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – S3 bucket access'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.04_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – S3 bucket access
  prefs: []
  type: TYPE_NORMAL
- en: For our use case, we can stay with the default settings provided for all the
    other options in this form wizard. The other options can be helpful in more advanced
    scenarios. AWS offers many features, such as a complete access log and versioning.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Many bigger companies have users across the globe, which requires a highly available
    application. When you reach this point, you can create many more S3 buckets in
    other regions, and you can set up the replication of one bucket to others living
    in various regions around the world. The correct bucket can then be distributed
    with AWS CloudFront and a router specific to each user. This approach gives every
    user the best possible experience.
  prefs: []
  type: TYPE_NORMAL
- en: Finish the setup process by clicking on **Create bucket** at the bottom of the
    page. You will be redirected back to the table view for all buckets.
  prefs: []
  type: TYPE_NORMAL
- en: Generating AWS access keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before implementing the upload feature, we must create an AWS **application
    programming interface** (**API**) key to authorize our backend at AWS, in order
    to upload new files to the S3 bucket.
  prefs: []
  type: TYPE_NORMAL
- en: Click on your username in the top bar of the AWS management screen. There, you
    will find a tab called **My Security Credentials**, which navigates to a screen
    offering various options to secure access to your AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be confronted with a dialog box like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – S3 Identity and Access Management (IAM) dialog'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.05_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – S3 Identity and Access Management (IAM) dialog
  prefs: []
  type: TYPE_NORMAL
- en: You can click on **Continue to Security Credentials** to continue. It is generally
    recommended to use AWS IAM, which allows you to efficiently manage secure access
    to AWS resources with separate IAM users. Throughout this book, we are going to
    use the root user in the same way that we are now, but I recommend looking at
    AWS IAM when writing your next application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see the credentials page, with a big list of different methods
    for storing credentials. This is how it should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – AWS access keys'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.06_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – AWS access keys
  prefs: []
  type: TYPE_NORMAL
- en: In the list, expand the tab titled **Access keys (access key ID and secret access
    key)** shown in the preceding screenshot. In this tab, you will find all access
    tokens for your AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a new access token, click on **Create New Access Key**. The output
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – AWS access key'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.07_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – AWS access key
  prefs: []
  type: TYPE_NORMAL
- en: The best practice is to download the key file as prompted and save it somewhere
    securely, just in case you lose the key at any time. You cannot retrieve access
    keys again after closing the window, so if you lose them, you will have to delete
    the old key and generate a new one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This approach is acceptable for explaining the basics of AWS. With such a huge
    platform, there are further steps that you have to take to secure your application
    even more. For example, it is recommended to renew API keys every 90 days. You
    can read more about all of the best practices at [https://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html](https://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 7.7*, AWS gives us two tokens. Both are required to
    gain access to our S3 bucket.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can start to program the uploading mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading images to Amazon S3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing file uploads and storing files is always a huge task, especially
    for image uploads in which the user may want to edit their files again.
  prefs: []
  type: TYPE_NORMAL
- en: For our frontend, the user should be able to drag and drop their image into
    a dropzone, crop the image, and then submit it when they are finished. The backend
    needs to accept file uploads in general, which is not easy at all. The files must
    be processed and then stored efficiently so that all users can access them quickly.
  prefs: []
  type: TYPE_NORMAL
- en: As this is a vast topic, the chapter only covers the basic upload of images
    from React, using a multipart `POST` request to our GraphQL API, and then transferring
    the image to our S3 bucket. When it comes to compressing, converting, and cropping,
    you should check out further tutorials or books on this topic, including techniques
    for implementing them in the frontend and backend, since there is a lot to think
    about. For example, in many applications, it makes sense to store images in various
    resolutions that will be shown to the users in different situations, in order
    to save bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by implementing the upload process on the backend.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL image upload mutation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When uploading images to S3, it is required to use an API key, which we have
    already generated. Because of this, we cannot directly upload the files from the
    client to S3 with the API key. Anyone accessing our application could read out
    the API key from the JavaScript code and access our bucket without us knowing.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading images directly from the client into the bucket is generally possible,
    however. To do this, you would need to send the name and type of the file to the
    server, which would then generate a **Uniform Resource Locator** (**URL**) and
    signature. The client can then use the signature to upload the image. This technique
    results in many round trips for the client and does not allow us to postprocess
    the image, such as by converting or compressing, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: A better solution is to upload the images to our server, have the GraphQL API
    accept the file, and then make another request to S3—including the API key—to
    store the file in our bucket.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to prepare our backend to communicate with AWS and accept file uploads.
    The preparation steps are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We install the official `npm` package to interact with AWS. It provides everything
    that''s needed to use any AWS feature, not just S3\. Also, we install `graphql-upload`,
    which provides some tools to resolve the file from any GraphQL request. The code
    to do this is illustrated here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the server `index.js` file, we need to add the initialization of the
    `graphql-upload` package. For that, import the Express dependency at the top,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `graphql` case at the end of the file, before executing the `applyMiddleware`
    function, we need to initiate it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next thing to do is edit the GraphQL schema and add an `Upload` scalar
    to the top of it. The scalar is used to resolve details such as the **Multipurpose
    Internet Mail Extensions** (**MIME**) type and encoding when uploading files.
    Here''s the code you''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `File` type to the schema. This type returns the filename and the resulting
    URL under which the image can be accessed in the browser. The code is illustrated
    in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `uploadAvatar` mutation. The user needs to be logged in to upload
    avatar images, so append the `@auth` directive to the mutation. The mutation takes
    the previously mentioned `Upload` scalar as input. The code is illustrated in
    the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will implement the mutation''s resolver function in the `resolvers.js`
    file. For this, we will import and set up our dependencies at the top of the `resolvers.js`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will initialize the `s3` object that we will use to upload images in the
    next step. It is required to pass a `region` property as a property in which we
    created the S3 bucket. We set the `signatureVersion` property to version `'v4'`
    as this is recommended.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can find details about the signature process of AWS requests at [https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html](https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside the `r``esolvers.js` file, we need to add one `Upload` resolver, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `mutation` property, insert the `uploadAvatar` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code snippet, we start by specifying the function as `async`
    so that we can use the `await` method to resolve the file and its details. The
    result of the resolved `await file` method consists of the `stream`, `filename`,
    `mimetype`, and `encoding` properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we collect the following parameters in the `params` variable, in order
    to upload our avatar image:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Bucket` field holds the name of the bucket where we save the image. I took
    the name `'apollo-book'`, but you will need to enter the name that you entered
    during the creation of the bucket. You could have specified this directly inside
    of the `s3` object, but this approach is a bit more flexible since you can have
    multiple buckets for different file types, without the need for multiple `s3`
    objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Key` property is the path and name under which the file is saved. Notice
    that we store the file under a new folder, which is just the user `context` variable.
    In a future application, you can introduce some kind of hash for every file. That
    would be good since the filename should not include characters that are not allowed.
    Furthermore, the files cannot be guessed programmatically when using a hash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ACL` field sets the permission for who can access the file. Since uploaded
    images on a social network are publicly viewable by anyone on the internet, we
    set the property to `'public-read'`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Body` field receives the `stream` variable, which we initially got by resolving
    the file. The `stream` variable is nothing more than the image itself as a stream,
    which we can directly upload into the bucket.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `params` variable is given to the `s3.upload` function, which saves the
    file to our bucket. We directly chain the `promise` function onto the `upload`
    method. In the preceding code snippet, we use the `await` statement to resolve
    the promise returned by the `upload` function. Therefore, we specified the function
    as `async`. The `response` object of the AWS S3 upload includes the public URL
    under which the image is accessible to everyone.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to set the new avatar picture on the user in our database.
    We execute the `User.update` model function from Sequelize by setting the new
    URL from `response.Location`, which S3 gave us after we resolved the promise.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example link to an S3 image is provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the URL is prefixed with the name of the bucket and then the
    region. The suffix is, of course, the folder, which is the user ID and the filename.
    The preceding URL will differ from the one that your backend generates because
    your bucket name and region will vary.
  prefs: []
  type: TYPE_NORMAL
- en: After updating the user, we can return the AWS response to update the **user
    interface** (**UI**) accordingly, without refreshing the browser window.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we generated access tokens in order to authorize our
    backend at AWS. By default, the AWS `JWT_SECRET`, we will set the tokens, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Insert your AWS tokens into the preceding code. The AWS SDK will detect both
    environment variables automatically. We do not need to read or configure them
    anywhere in our code.
  prefs: []
  type: TYPE_NORMAL
- en: We will now continue and implement all of the image upload features in the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: React image cropping and uploading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In social networks such as Facebook, there are multiple locations where you
    can select and upload files. You can send images in chats, attach them to posts,
    create galleries in your profile, and much more. For now, we will only look at
    how to change our user's avatar image. This is a great example for easily showing
    all of the techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result that we are targeting looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Cropping dialog'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.08_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8 – Cropping dialog
  prefs: []
  type: TYPE_NORMAL
- en: The user can select a file, crop it directly in the modal, and save it to AWS
    with the preceding dialog.
  prefs: []
  type: TYPE_NORMAL
- en: I am not a big fan of using too many `npm` packages, as this often makes your
    application unnecessarily big. As of the time of writing this book, we cannot
    write custom React components for everything, such as displaying a dialog or cropping,
    no matter how easy it might be.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the image upload working, we will install two new packages. To do this,
    you can follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the packages with `npm`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When using the `react-cropper` package, we can rely on its included `App.js`
    file, import it straight from the package itself, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Webpack takes care of bundling all assets, as we are already doing with our
    custom CSS. The rest of the required CSS is available on the official GitHub repository
    of this book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next package that we will install is an extension for Apollo Client, which
    will enable us to upload files, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get the `apollo-upload-client` package running, we have to edit the `index.js`
    file from the `apollo` folder where we initialize Apollo Client and all of its
    links. Import the `createUploadLink` function at the top of the `index.js` file,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You must replace the old `HttpLink` instance at the bottom of the link array
    with the new upload link. Instead of having a new `HttpLink`, we will now pass
    the `createUploadLink` function, but with the same parameters. When executing
    it, a regular link is returned. The link should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is important to note that when we make use of the new upload link and send
    a file with a GraphQL request, we do not send the standard `application/json`
    `Content-Type` request, but instead send a multipart `FormData` request. This
    allows us to upload files with GraphQL. Standard `file` objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Alternatively, it is possible to send a `base64` string instead of a `file`
    object when transferring images. This procedure would save you from the work that
    we are doing right now, as sending and receiving strings is no problem with GraphQL.
    You have to convert the `base64` string to a file if you want to save it in AWS
    S3\. This approach only works for images, however, and web applications should
    be able to accept any file type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that the packages are prepared, we can start to implement our `uploadAvatar`
    mutation component for the client. Create a new file called `uploadAvatar.js`
    in the `mutations` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the file, import all dependencies and parse all GraphQL requests
    with `gql` in the conventional way, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we have just exported the new mutation by wrapping the GraphQL
    query with the `useMutation` Hook. Also, we added an `update` function that will
    update the cache by first getting the reference for the current user and afterward
    updating this one user by reference to the new avatar URL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Lastly, we need to add the `id` property to the `userAttributes` fragment.
    Otherwise, the update of the avatar URL on the user reference would only be reflected
    on the top bar and not with all the posts. The code is illustrated in the following
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preparation is now complete. We have installed all of the required packages,
    configured them, and implemented the new mutation component. We can begin to program
    the user-facing dialog to change the avatar image.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this book, we are not relying on separate pages or anything
    like that. Instead, we are giving the user the opportunity to change their avatar
    when they click on their image in the top bar. To do so, we are going to listen
    for the click event on the avatar, opening up a dialog that includes a file dropzone
    and a button to submit the new image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following steps to get this logic running:'
  prefs: []
  type: TYPE_NORMAL
- en: It is always good to make your components as reusable as possible, so create
    an `avatarModal.js` file inside of the `components` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As always, you will have to import the new `react-modal`, `react-cropper`,
    and `react-dropzone` packages first and then the mutation, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see in the preceding code snippet, we tell the modal package at which
    point in the browser's `setAppElement` method. For our use case, it is okay to
    take the `root` DOMNode, as this is the starting point of our application. The
    modal is instantiated in this DOMNode.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The modal component accepts a special `style` parameter for the different parts
    of the dropzone. We can style all parts of the modal by specifying the `modalStyle`
    object with the correct properties.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `react-cropper` package gives the user the opportunity to crop the image.
    The result is not a `file` or `blob` object, but a `dataURI` object, formatted
    as `base64`. Generally, this is not a problem, but our GraphQL API expects that
    we send a real file, not just a string, as we explained previously. Consequently,
    we have to convert the `dataURI` object to a blob that we can send with our GraphQL
    request. Add the following function to take care of the conversion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's not get too deep into the logic behind the preceding function. The only
    thing that you need to know is that it converts all readable `blob` object to
    the calling function. It converts data URIs to blobs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The new component that we are implementing at the moment is called `AvatarUpload`.
    It receives the `isOpen` property, which sets the modal to visible or invisible.
    By default, the modal is invisible. Furthermore, when the modal is shown, the
    dropzone is rendered inside. First, set up the component itself and the required
    variables, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We require the `file` and `result` state variables to manage the original file
    selected and the cropped image. Furthermore, we set up the mutation and a reference
    using the `useRef` Hook, which is required for the `cropper` library.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to set up all the component functions that we will use to handle
    different events and callbacks. Add the following functions to the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `saveAvatar` function is the main function that will translate the `base64`
    string into a blob. The `onDrop` function is called when the user drops or selects
    an image. At this moment, we use `FileReader` to read the file and give us the
    `base64` string that we save in the `file` state variable as an object. The `useDropZone`
    Hook gives us all the properties that we can use to set up the actual dropzone.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `changeImage` function will cancel the current crop process and allow us
    to upload a new file again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `onCrop` function is called every time the cropped selection is changed
    by the user. At this moment, we save the new cropped image as a `base64` string
    to the `result` state variable to have a clear separation between the original
    `file` variable and the `result` variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `Modal` component takes an `onRequestClose` method, which executes the `showModal`
    function when the user tries to close the modal by clicking outside of it, for
    example. We receive the `showModal` function from the parent component, which
    we are going to cover in the next step. The modal also receives the default `style`
    property and a label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Cropper` component needs to receive a function in the `crop` property
    that is called on every change. Also, the `Cropper` component receives the `src`
    property from the `file` state variable, as illustrated in the following code
    snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `return` statement, as you can see, only includes the modal as a wrapper
    and a cropper. At the end, we have a button calling `saveAvatar` to execute the
    mutation, and with it send the cropped image or `changeImage`, which cancels the
    cropping for the current image.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Don''t forget to add the `export` statement to the end of the file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, switch over to the `user.js` file in the `bar` folder, where all of the
    other application bar-related files are stored. Import the new `AvatarModal` component,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `UserBar` component is the parent of `AvatarUploadModal`. Open the `user.js`
    file from the `bar` folder. That is why we handle the `isOpen` state variable
    of the dialog in the `UserBar` component. We introduce an `isOpen` state variable
    and catch the `onClick` event on the avatar of the user. Copy the following code
    into the `UserBar` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the `return` statement with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The modal component directly receives the `isOpen` property, as we explained
    earlier. The `showModal` method is executed when the avatar image is clicked.
    This function updates the property of the `AvatarModal` component, and either
    shows or hides the modal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the server and client with the matching `npm run` commands. Reload your
    browser and try out the new feature. When an image is selected, the cropping tool
    is displayed. You can drag and resize the image area that should be uploaded.
    You can see an example of this in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Cropping in progress'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.09_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.9 – Cropping in progress
  prefs: []
  type: TYPE_NORMAL
- en: Hitting `user` folder in the S3 bucket. Thanks to the mutation that we wrote,
    the avatar image in the top bar is updated with the new URL to the S3 bucket location
    of the image.
  prefs: []
  type: TYPE_NORMAL
- en: The great thing that we have accomplished is that we send the images to our
    server. Our server transfers all of the images to S3\. AWS responds with the public
    URL, which is then placed directly into the avatar field in the browser. The way
    that we query the avatar image from the backend, using our GraphQL API, does not
    change. We return the URL to the S3 file, and everything works.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by creating an AWS account and an S3 bucket for
    uploading static images from our backend. Modern social networks consist of many
    images, videos, and other types of files. We introduced Apollo Client, which allows
    us to upload any type of file. In this chapter, we managed to upload an image
    to our server, and we covered how to crop images and save them through a server
    in AWS S3\. Your application should now be able to serve your users with images
    at any time.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover the basics of client-side routing, with the use
    of React Router.
  prefs: []
  type: TYPE_NORMAL
