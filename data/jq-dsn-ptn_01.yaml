- en: Chapter 1. A Refresher on jQuery and the Composite Pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章。jQuery 和复合模式复习。
- en: Until the **Web 2.0** era started, the Web was just a document-based media and
    all it offered was just interconnecting different pages/documents and client-side
    scripting that was mostly limited to form validation. By 2005, Gmail and Google
    Maps were released, and JavaScript proved itself as a language used by big enterprises
    to create large-scale applications and provide rich user interface interactions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 **Web 2.0** 时代开始，Web 只是基于文档的媒体，它所提供的仅仅是连接不同页面/文档和客户端脚本编写，大多数情况下仅限于表单验证。到
    2005 年，Gmail 和 Google 地图发布了，JavaScript 证明了自己是大型企业用于创建大规模应用程序并提供丰富用户界面交互的语言。
- en: Even though JavaScript has had very few changes since its original release,
    there was a tremendous change in the expectations that the Enterprise world had
    about what web pages should be capable of doing. Since then, web developers were
    required to deliver complex user interactions and, finally, the term "web application"
    appeared on the market. As a result, it started to become obvious that they should
    create some code abstractions, define some best practices, and adopt all the applicable
    **Design Patterns** that computer science had to offer. The wide adoption of JavaScript
    for enterprise-grade applications helped the evolution of the language, which
    with the **EcmaScript2015**/**EcmaScript6** (**ES6**) specification was expanded
    in a way that allowed even more Design Patterns to be easily utilized.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 JavaScript 自发布以来几乎没有什么变化，但企业界对网页应该具备的功能期望发生了巨大变化。从那时起，Web 开发人员需要提供复杂的用户交互，并最终，"Web
    应用程序" 这个术语出现在市场上。因此，开始变得明显，他们应该创建一些代码抽象，定义一些最佳实践，并采用计算机科学提供的所有适用的 **设计模式**。JavaScript
    作为企业级应用程序的广泛采用帮助了语言的发展，随着 **EcmaScript2015**/**EcmaScript6**（**ES6**）规范的发布，语言得以扩展，以便更轻松地利用更多的设计模式。
- en: In August 2006, the jQuery library was first released by John Resig at [http://jquery.com](http://jquery.com),
    as an effort to create a convenient API to locate DOM elements. Since then, it
    has been an integral part of a web developer's toolkit. jQuery in its core uses
    several Design Patterns and tries to urge their use to the developer through the
    methods that it provides. The Composite Pattern is one of them and it is exposed
    to the developer through the very core `jQuery()` method, which is used for DOM
    traversal, one of the highlights of the jQuery library.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 2006 年 8 月，John Resig 在 [http://jquery.com](http://jquery.com) 首次发布了 jQuery
    库，旨在创建一个方便的 API 来定位 DOM 元素。从那时起，它已成为 Web 开发人员工具包的一个组成部分。jQuery 在其核心中使用了几种设计模式，并通过提供的方法试图敦促开发人员使用它们。复合模式是其中之一，它通过非常核心的
    `jQuery()` 方法向开发人员公开，该方法用于 DOM 遍历，这是 jQuery 库的一个亮点。
- en: 'In this chapter, we will:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Have a refresher on DOM scripting using jQuery
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 jQuery 进行 DOM 脚本编写的复习。
- en: Introduce the Composite Pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍复合模式。
- en: See how the Composite Pattern is used by jQuery
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看 jQuery 如何使用复合模式。
- en: Discuss the gains offered by jQuery over plain JavaScript DOM manipulations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论 jQuery 相对于纯 JavaScript DOM 操作所带来的优势。
- en: Introduce the Iterator Pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍迭代器模式。
- en: Use the Iterator Pattern in an example application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个示例应用中使用迭代器模式。
- en: jQuery and DOM scripting
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jQuery 和 DOM 脚本编写。
- en: By DOM scripting, we refer to any procedure that alters or manipulates the elements
    of a web page after it has been loaded by the browser. The DOM API is a JavaScript
    API that was standardized in 1998 and it provides to web developers a collection
    of methods that allow the manipulation of the DOM tree elements that the browser
    creates after loading and parsing the web page's HTML code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 DOM 脚本编写，我们指的是在浏览器加载后修改或操作网页元素的任何过程。DOM API 是一种 JavaScript API，于 1998 年标准化，它为网页开发人员提供了一组方法，允许在加载和解析网页的
    HTML 代码后操作浏览器创建的 DOM 树元素。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意。
- en: For more information on the **Document Object Mode** (**DOM**) and its APIs,
    you can visit [https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关 **文档对象模型**（**DOM**）及其 API 的更多信息，您可以访问 [https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction)。
- en: By utilizing the DOM API in their JavaScript code, web developers can manipulate
    the DOM's nodes and add new elements or remove existing elements from the page.
    The primary use case for DOM scripting was initially limited to client-side form
    validation, but as the years passed and JavaScript gained the trust of the Enterprise
    world, more complex user interactions started to be implemented.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在他们的 JavaScript 代码中利用 DOM API，web 开发者可以操纵 DOM 的节点，并向页面添加新元素或删除现有元素。最初 DOM
    脚本的主要用例仅限于客户端表单验证，但随着时间的推移和 JavaScript 获得企业界的信任，开始实现更复杂的用户交互。
- en: The initial version of the jQuery library was first released in August 2006
    and it tried to ease the way the web developers were traversing and manipulating
    the DOM tree. One of its main goals was to provide abstractions that resulted
    in shorter, easier-to-read, and less error-prone code, while also ensuring cross-browser
    interoperability.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 库的初始版本于 2006 年 8 月首次发布，它试图简化 web 开发者遍历和操纵 DOM 树的方式。其主要目标之一是提供抽象，以产生更短、更易读、更不容易出错的代码，同时确保跨浏览器的互操作性。
- en: 'These core principles that jQuery follows are clearly visible in its homepage,
    where it presents itself as:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 遵循的这些核心原则在其主页中清晰可见，它将自己呈现为：
- en: '...a fast, small, and feature-rich JavaScript library. It makes things like
    HTML document traversal and manipulation, event handling, animation, and Ajax
    much simpler with an easy-to-use API that works across a multitude of browsers.
    With a combination of versatility and extensibility, jQuery has changed the way
    that millions of people write JavaScript.'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: …一个快速、小巧且功能丰富的 JavaScript 库。它通过一个易于使用的 API，简化了 HTML 文档遍历和操纵、事件处理、动画和 Ajax，适用于众多浏览器。jQuery
    结合了多功能性和可扩展性，改变了数百万人编写 JavaScript 的方式。
- en: The abstracted APIs that jQuery provided from the beginning, and the way that
    different Design Patterns were orchestrated, led to wide acceptance among the
    web developers. As a result, the jQuery library is referenced by more than 60%
    of the most visited websites worldwide, according to several sources such as BuiltWith.com
    ([http://trends.builtwith.com/javascript/jQuery](http://trends.builtwith.com/javascript/jQuery)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 从一开始提供的抽象 API，以及不同的设计模式是如何编排的，导致在 web 开发者中得到了广泛的接受。因此，根据多个来源（例如 BuiltWith.com
    ([http://trends.builtwith.com/javascript/jQuery](http://trends.builtwith.com/javascript/jQuery)）），全球访问量最高的网站中有超过
    60% 的网站引用了 jQuery 库。
- en: Manipulating the DOM using jQuery
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 jQuery 操纵 DOM
- en: 'To have a refresher on jQuery, we will go through an example web page that
    does some simple DOM manipulations. In this example, we will load a simply structured
    page that initially looks like the following figure:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对 jQuery 进行复习，我们将通过一个示例网页进行一些简单的 DOM 操作。在这个例子中，我们将加载一个简单结构的页面，最初看起来像下图所示：
- en: '![Manipulating the DOM using jQuery](img/00002.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![使用 jQuery 操纵 DOM](img/00002.jpeg)'
- en: 'We will use some jQuery code to change the page''s content and layout and,
    in order to make its effects clearly visible, we will set it to run about 700
    milliseconds after the page has loaded. The result of our manipulations will look
    like the following figure:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一些 jQuery 代码来更改页面的内容和布局，并且为了使其效果清晰可见，我们将设置它在页面加载后约`700 milliseconds`运行。我们的操作结果将如下图所示：
- en: '![Manipulating the DOM using jQuery](img/00003.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![使用 jQuery 操纵 DOM](img/00003.jpeg)'
- en: 'Now let''s review the HTML code required for the preceding example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回顾一下前面示例所需的 HTML 代码：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The CSS code used is quite simple, containing only three CSS classes as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的 CSS 代码非常简单，只包含三个 CSS 类，如下所示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code results in a page looking like the first figure when opened
    in a browser and before our JavaScript code is executed. In the preceding CSS
    code, we first defined some basic styles for the `box`, `boxsizer`, and `clear`
    CSS classes. The `box` class styles the associated elements found in the page
    by using some padding, a thin border, some margin around, and a small shadow below
    the elements in order to make them look like a box. The `boxsizer` class will
    make the elements that use it to take just 1/3rd of the width of their parent
    element and create a three-column layout. Finally, the `clear` class will be used
    on an element as a break point for the column layout so that all the elements
    that follow will be positioned below it. The `boxsizer` and `clear` classes are
    not initially used by any element defined in the HTML code, but will be used after
    the DOM manipulations that we will do in JavaScript.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码在浏览器中打开并在执行我们的 JavaScript 代码之前，页面看起来像第一个图示所示。在前述 CSS 代码中，我们首先为 `box`、`boxsizer`
    和 `clear` CSS 类定义了一些基本样式。`box` 类通过一些填充、一条细边框、周围一些间距和在元素下方创建一个小阴影来为页面中的相关元素添加样式，使它们看起来像一个盒子。`boxsizer`
    类将使用它的元素的宽度设置为其父元素的 1/3，并创建一个三列布局。最后，`clear` 类将用于元素作为列布局的断点，以使其后的所有元素都位于其下方。`boxsizer`
    和 `clear` 类最初未被 HTML 代码中定义的任何元素使用，但会在我们将在 JavaScript 中进行的 DOM 操作之后使用。
- en: In the `<body>` element of our HTML, we initially define an `<h1>` heading element
    with ID `pageHeader` so that it is easily selectable through JavaScript. Right
    below it, we define five paragraph elements (`<p>`) with the `box` class, having
    the first three of them wrapped inside the three `<div>` elements and then inside
    another `<div>` element with the `boxContainer` class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 HTML 的 `<body>` 元素中，我们最初定义了一个带有 ID `pageHeader` 的 `<h1>` 标题元素，以便通过 JavaScript
    轻松选择。紧接着，在它下面，我们定义了五个段落元素 (`<p>`)，具有 `box` 类，前三个元素被包裹在三个 `<div>` 元素中，然后再包裹在另一个具有
    `boxContainer` 类的 `<div>` 元素中。
- en: 'Reaching our two `<script>` tags, we first include a reference to the jQuery
    library from jQuery CDN. For more information, you can visit [http://code.jquery.com/](http://code.jquery.com/).
    In the second `<script>` tag, we reference the JavaScript file with the required
    code, for this example, which looks as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到达我们的两个 `<script>` 标签时，我们首先从 jQuery CDN 引入了对 jQuery 库的引用。有关更多信息，您可以访问 [http://code.jquery.com/](http://code.jquery.com/)。在第二个
    `<script>` 标签中，我们引用了带有所需代码的 JavaScript 文件，例如：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All our code is wrapped inside a `setTimeout` call to delay its execution, according
    to the use case described earlier. The first parameter of the `setTimeout` function
    call is an anonymous function that will be executed after a timer of 700 milliseconds
    has expired, as defined in the second argument.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的代码都包装在一个 `setTimeout` 调用中以延迟其执行，根据之前描述的用例。`setTimeout` 函数调用的第一个参数是一个匿名函数，它将在定时器
    700 毫秒过期后执行，如第二个参数中定义的那样。
- en: At the first line of our anonymous callback function, we use the jQuery `$()`
    function to traverse the DOM and locate the element with the ID `pageHeader`,
    and use the `css()` method to increase its `font-size` to `3em`. Next we provide
    a more complex CSS selector to the `$()` function, to locate all the elements
    with the `box` class that are descendants of the element with the `boxContainer`
    class, and then store the result in a variable named `$boxes`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们匿名回调函数的第一行，我们使用 jQuery 的 `$()` 函数遍历 DOM 并定位 ID 为 `pageHeader` 的元素，并使用 `css()`
    方法将其 `font-size` 增加到 `3em`。接下来，我们向 `$()` 函数提供了一个更复杂的 CSS 选择器，来定位所有具有 `box` 类的元素，这些元素是具有
    `boxContainer` 类的元素的后代，然后将结果存储在名为 `$boxes` 的变量中。
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Variable naming conventions**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量命名约定**'
- en: It is a common practice among developers to use naming conventions for variables
    that hold objects of a certain type. Using such conventions not only helps you
    remember what the variable is holding, but also makes your code easier to understand
    by other developers of your team. Among jQuery developers, it is common to use
    variable names starting with a "$" sign when the variable stores the result of
    the `$()` function (also know as a jQuery collection object).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发者中使用命名约定来命名持有特定类型对象的变量是一种常见做法。使用这种约定不仅有助于你记住变量持有的内容，还能使你的代码更易于其他团队成员理解。在
    jQuery 开发者中，当变量存储了 `$()` 函数的结果（也称为 jQuery 集合对象）时，使用以 "$" 符号开头的变量名是常见的。
- en: After we get a hold of the `box` elements that we are interested in, we append
    two breaking spaces and some extra text in italics, at the end of each of them.
    Then, we use the `$boxes` variable and traverse the DOM tree one level up, using
    the `parent()` method. The `parent()` method returns a different jQuery object
    holding the parent `<div>` elements of our initially selected boxes and then we
    chain a call to the `addClass()` method to assign them the `boxsizer` CSS class.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取我们感兴趣的`box`元素之后，我们在每个元素的末尾添加两个换行空格和一些额外的斜体文本。然后，我们使用`$boxes`变量遍历DOM树，使用`parent()`方法上升一个级别。`parent()`方法返回一个不同的jQuery对象，其中包含我们最初选择的框的父`<div>`元素，然后我们链式调用`addClass()`方法将它们分配给`boxsizer`
    CSS类。
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you need to traverse all the parent nodes of a selected element, you can
    use the `$.fn.parents()` method. If you just need to find the first ancestor element
    that matches a given CSS selector, consider using the `$.fn.closest()` method
    instead.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要遍历所选元素的所有父节点，则可以使用`$.fn.parents()`方法。如果您只需要找到与给定CSS选择器匹配的第一个祖先元素，请考虑改用`$.fn.closest()`方法。
- en: Finally, since the `boxsizer` class uses floats to achieve the three-column
    layout, we need to clear the floats in the `boxContainer`. Once again, we traverse
    the DOM using the simple `.boxContainer` CSS selector and the `$()` function.
    Then, we call the `.append()` method to create a new `<div>` element with the
    `.clear` CSS class and insert it at the end of the `boxContainer`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于`boxsizer`类使用浮动来实现三列布局，我们需要清除`boxContainer`中的浮动。再次，我们使用简单的`.boxContainer`
    CSS选择器和`$()`函数遍历DOM。然后，我们调用`.append()`方法创建一个带有`.clear` CSS类的新`<div>`元素，并将其插入到`boxContainer`的末尾。
- en: 'After 700 milliseconds, our jQuery code will have finished, resulting in the
    three-column layout as shown earlier. In its final state, the HTML code of our
    `boxContainer` element will look as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 700毫秒后，我们的jQuery代码将完成，结果是之前显示的三列布局。在其最终状态下，我们的`boxContainer`元素的HTML代码如下所示：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Method Chaining and Fluent Interfaces
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法链和流畅接口
- en: 'Actually, in the preceding example, we can also go one step further and combine
    all three box-related code statements into just one, which looks something as
    follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在上面的示例中，我们还可以进一步将所有三个与框相关的代码语句合并为一个，其效果如下所示：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This Syntax Pattern is called **Method Chaining** and it is highly recommended
    by jQuery and the JavaScript community in general. Method Chaining is part of
    the Object Oriented Implementation Pattern of Fluent Interfaces where each method
    relays its instruction context to the subsequent one.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法模式被称为**方法链**，并且被jQuery和JavaScript社区广泛推荐。方法链是流畅接口的面向对象实现模式的一部分，其中每个方法将其指令上下文传递给后续方法。
- en: Most jQuery methods that apply on a jQuery object also return the same or a
    new jQuery element collection object. This allows us to chain several methods,
    not only resulting in a more readable and expressive code but also reducing the
    required variable declarations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数适用于jQuery对象的jQuery方法也会返回相同或新的jQuery元素集合对象。这使我们能够链式调用多个方法，不仅使代码更易读和表达，而且减少了所需的变量声明。
- en: The Composite Pattern
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合模式
- en: The key concept of the Composite Pattern is to enable us to treat a collection
    of objects in the same way as we treat a single object instance. Manipulating
    a composition by using a method on the collection will result in applying the
    manipulation to each part of it. Such methods can be applied successfully, regardless
    of the number of elements that are part of the composite collection, or even when
    the collection contains no elements.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式的关键概念是使我们能够像处理单个对象实例一样处理对象集合。通过在集合上使用方法来操作组合将导致将操作应用于其每个部分。这样的方法可以成功应用，而不管组合集合中包含的元素数量如何，甚至当集合不包含元素时也可以。
- en: Also, the objects of a composite collection do not necessarily have to provide
    the exact same methods. The Composite Object can either expose only the methods
    that are common among the objects of the collection, or can provide an abstracted
    API and appropriately handle the method differentiations of each object.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，组合集合的对象不一定需要提供完全相同的方法。组合对象可以只公开集合对象中对象之间共同的方法，或者可以提供一个抽象的API，并适当处理每个对象的方法差异。
- en: Let's continue by exploring how the intuitive API that jQuery exposes is highly
    influenced from the Composite Pattern.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨jQuery公开的直观API如何受到组合模式的高度影响。
- en: How the Composite Pattern is used by jQuery
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery 如何使用组合模式
- en: The Composite Pattern is an integral part of jQuery's architecture and is applied
    from the very core `$()` function itself. Each call to the `$()` function creates
    and returns an element collection object, which is often simply referred as a
    jQuery object. This is exactly where we see the first principle of the Composite
    Patterns; in fact, instead of returning a single element, the `$()` function returns
    a collection of elements.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式是 jQuery 架构的一个组成部分，并且从 `$()` 函数的核心自身应用。 对 `$()` 函数的每次调用都会创建并返回一个元素集合对象，这通常简称为
    jQuery 对象。 这正是我们看到组合模式的第一个原则的地方； 实际上，`$()` 函数不是返回单个元素，而是返回一组元素。
- en: 'The jQuery object returned is an Array-like object that acts as a wrapper object
    and carries the collection of the retrieved elements. It also exposes a number
    of extra properties as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的 jQuery 对象是一个类似数组的对象，充当包装对象并携带检索到的元素集合。 它还公开了一些额外的属性，如下所示：
- en: The `length` of the retrieved element collection
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索到的元素集合的 `length`
- en: The `context` that the object was constructed
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象构造的 `context`
- en: The CSS `selector` that was used on the `$()` function call
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `$()` 函数调用中使用的 CSS `selector`
- en: A `prevObject` property in case we need to access the previous element collection
    after chaining a method call
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在链式调用方法后如果我们需要访问先前的元素集合，则有一个 `prevObject` 属性
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Simple Array-like object definition**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单的类似数组对象定义**'
- en: 'An Array-like object is a JavaScript object `{ }` that has a numeric `length`
    property and the respective number of properties, with sequential numeric property
    names. In other words, an Array-like object that has the `length == 2` property
    is expected to also have two properties defined, `"0"` and `"1"`. Given the above
    properties, Array-like objects allow you to access their content using simple
    `for` loops, by utilizing JavaScript''s Bracket Property Accessor''s syntax:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 类似数组的对象是具有数字 `length` 属性和相应数量的属性的 JavaScript 对象 `{ }`，具有连续的数字属性名称。 换句话说，具有 `length
    == 2` 属性的类似数组对象预计也应该定义两个属性 `"0"` 和 `"1"`。 给定上述属性，类似数组的对象允许您使用简单的 `for` 循环访问它们的内容，通过利用
    JavaScript 的括号属性访问器的语法：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can easily experiment with the jQuery objects returned from the `$()` function
    and inspect the properties described above, by using the developer tools of our
    favorite browser. To open the developer tools on most of them, we just need to
    press *F12* on Windows and Linux or *Cmd* + *Opt* + *I* on Mac, and right after
    that, we can issue some `$()` calls in the console and click on the returned objects
    to inspect their properties.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地尝试使用 `$()` 函数返回的 jQuery 对象，并通过使用我们喜爱的浏览器的开发者工具检查上述属性。 要在大多数浏览器上打开开发者工具，我们只需要在
    Windows 和 Linux 上按下 *F12*，或在 Mac 上按 *Cmd* + *Opt* + *I*，然后我们可以在控制台中发出一些 `$()`
    调用并单击返回的对象以检查它们的属性。
- en: 'In the following figure, we can see what the result of the `$(''#pageHeader'')`
    call, which we used in the example earlier, looks like in Firefox Developer Tools:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们可以看到在之前示例中使用的 `$('#pageHeader')` 调用的结果在 Firefox 开发者工具中的样子：
- en: '![How the Composite Pattern is used by jQuery](img/00004.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![jQuery 如何使用组合模式](img/00004.jpeg)'
- en: 'The result of the `$(''.boxContainer .box'')` call looks as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(''.boxContainer .box'')` 调用的结果如下：'
- en: '![How the Composite Pattern is used by jQuery](img/00005.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![jQuery 如何使用组合模式](img/00005.jpeg)'
- en: 'The fact that jQuery uses Array-like objects as a wrapper for the returned
    elements allows it to expose some extra methods that apply on the collection returned.
    This is achieved through prototypical inheritance of the `jQuery.fn` object, resulting
    in each jQuery object also having access to all the methods that jQuery provides.
    This completes the Composite Pattern, which provides methods that, when applied
    to a collection, are appropriately applied to each of its members. Because jQuery
    uses Array-like objects with prototypical inheritance, these methods can be easily
    accessed as properties on each jQuery object, as shown in the example in the beginning
    of the chapter: `$(''#pageHeader'').css(''font-size'', ''3em'');`. Moreover, jQuery
    adds some extra goodies to its DOM manipulating code, following the goal of smaller
    and less error-prone code. For example, when using the `jQuery.fn.html()` method
    to change the inner HTML of a DOM node that already contains child elements, jQuery
    first tries to remove any data and event handlers that are associated with the
    child elements, before removing them from the page and appending the provided
    HTML code.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 使用类似数组的对象作为返回元素的包装器，从而使其能够公开一些额外的适用于返回的集合的方法。这是通过原型继承 `jQuery.fn` 对象来实现的，导致每个
    jQuery 对象也可以访问 jQuery 提供的所有方法。这完成了组合模式，该模式提供了适用于集合的方法，这些方法适用于集合的每个成员。因为 jQuery
    使用类似数组的对象具有原型继承，所以这些方法可以轻松地作为每个 jQuery 对象的属性访问，就像本章开头的示例中所示：`$('#pageHeader').css('font-size',
    '3em');`。此外，jQuery 还为其 DOM 操作代码添加了一些额外的好处，遵循更小和更不容易出错的代码的目标。例如，当使用 `jQuery.fn.html()`
    方法更改已包含子元素的 DOM 节点的内部 HTML 时，jQuery 首先尝试删除与子元素关联的任何数据和事件处理程序，然后再将它们从页面中删除并附加所提供的
    HTML 代码。
- en: Let's take a look at how jQuery implements these collection-applicable methods.
    For this task, we can either download and view the source code from the GitHub
    page of jQuery ([https://github.com/jquery/jquery/releases](https://github.com/jquery/jquery/releases)),
    or we can use a tool such as the jQuery Source Viewer that is available at [http://james.padolsey.com/jquery](http://james.padolsey.com/jquery).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下 jQuery 如何实现这些适用于集合的方法。对于这个任务，我们可以从 jQuery 的 GitHub 页面下载并查看源代码（[https://github.com/jquery/jquery/releases](https://github.com/jquery/jquery/releases)），或者使用类似
    jQuery 源代码查看器这样的工具，该工具可在[http://james.padolsey.com/jquery](http://james.padolsey.com/jquery)找到。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Depending on the version you are using, you might get different results to some
    degree. The most recent stable jQuery version that was released and used as a
    reference while writing this book, was v2.2.0.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您使用的版本，您可能会在某种程度上获得不同的结果。在编写本书时，作为参考的最新稳定版 jQuery 版本是 v2.2.0。
- en: 'One of the simplest methods to demonstrate how methods that apply to collections
    are implemented, is `jQuery.fn.empty()`. You can easily locate its implementation
    in jQuery''s source code by searching for `"empty:"` or using the jQuery Source
    Viewer and searching for `"jQuery.fn.empty"`. Using either one of the ways will
    bring us to the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 展示适用于集合的方法如何实现的最简单方法之一是 `jQuery.fn.empty()`。您可以通过搜索 `"empty:"` 或使用 jQuery 源代码查看器并搜索
    `"jQuery.fn.empty"` 来轻松找到它在 jQuery 源代码中的实现。使用其中任一种方式都会带我们到以下代码：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the code is not complex at all. jQuery iterates over all the
    items of the collection object (referred to as `this` since we are inside the
    method implementation) by using a plain `for` loop. For each item of the collection,
    that is, an Element Node, it clears any data-* property values using the `jQuery.cleanData()`
    helper function, and right after this, it clears its content by setting it to
    an empty string.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代码一点也不复杂。jQuery 使用简单的 `for` 循环遍历集合对象的所有项（称为 `this`，因为我们在方法实现内部），对于集合的每个项，即元素节点，它都使用
    `jQuery.cleanData()` 辅助函数清除任何 data-* 属性值，然后立即将其内容设置为空字符串。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the different specified Node Types, you can visit [https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType](https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 关于不同指定节点类型的更多信息，请访问[https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType](https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType)。
- en: Comparing the benefits over the plain DOM API
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与普通 DOM API 相比的优势
- en: 'To clearly demonstrate the benefits that the Composite Pattern provides, we
    will rewrite our initial example without the abstractions that jQuery offers.
    By using just plain JavaScript and the DOM API, we can write an equivalent code
    that looks as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚地展示复合模式提供的好处，我们将在不使用jQuery提供的抽象的情况下重新编写我们最初的示例。通过仅使用普通JavaScript和DOM API，我们可以编写一个等效的代码，如下所示：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once again, we use `setTimeout` with an anonymous function and set `700` milliseconds
    as the second parameter. Inside the function itself, we use `document.getElementById`
    to retrieve elements that are known to have a unique ID in the page, and later
    `document.getElementsByClassName` when we need to retrieve all the elements that
    have a specific class. We also use `boxContainerElement.getElementsByClassName('box')`
    to retrieve all the elements with the `box` class that are descendants of the
    element with the `boxContainer` class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`setTimeout`与匿名函数，并将`700`毫秒设置为第二个参数。在函数内部，我们使用`document.getElementById`来检索已知在页面中具有唯一ID的元素，后来在需要检索具有特定类的所有元素时使用`document.getElementsByClassName`。我们还使用`boxContainerElement.getElementsByClassName('box')`来检索所有具有`box`类的元素，这些元素是具有`boxContainer`类的元素的后代。
- en: The most obvious observation is that, in this case, we needed 18 lines of code
    in order to achieve the same results. For comparison, when using jQuery, we only
    needed 9 lines of code, that's half the number of lines of code compared to the
    later implementation. Using the jQuery `$()` function with a CSS selector was
    an easier way to retrieve the elements that we needed, and it also ensures compatibility
    with browsers that do not support the `getElementsByClassName()` method. However,
    there are more benefits than just the code line count and the improved readability.
    As an implementer of the Composite Pattern, the `$()` function always retrieves
    element collections, making our code more uniform when compared to the differentiated
    handling of each `getElement*` method we used. We use the `$()` function in exactly
    the same way, regardless of whether we just want to retrieve an element with a
    unique ID or a number of elements with a specific class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的观察是，在这种情况下，我们需要18行代码才能实现相同的结果。相比之下，当使用jQuery时，我们只需要9行代码，这是后面实现所需行数的一半。使用jQuery的`$()`函数与CSS选择器是检索所需元素的更简单的方法，它还确保与不支持`getElementsByClassName()`方法的浏览器的兼容性。然而，除了代码行数和改进的可读性之外，还有更多的好处。作为复合模式的实施者，`$()`函数始终检索元素集合，使我们的代码在与我们使用的每个`getElement*`方法的差异化处理相比更加统一。我们以完全相同的方式使用`$()`函数，无论我们是只想检索具有唯一ID的元素，还是具有特定类的一些元素。
- en: As an extra benefit of returning Array-like objects, jQuery can also provide
    more convenient methods to traverse and manipulate the DOM, such as those we saw
    in our first example, `.css()`, `.append()` and `.parent()`, which are accessible
    as properties of the returned object. Additionally, jQuery also offers methods
    that abstract more complex use cases such as `.addClass()` and `.wrap()` that
    have no equivalent methods available as part of the DOM API.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 作为返回类似数组的对象的额外好处，jQuery还可以提供更方便的方法来遍历和操作DOM，例如我们在第一个示例中看到的`.css()`、`.append()`和`.parent()`方法，它们作为返回对象的属性可访问。此外，jQuery还提供了抽象更复杂的用例的方法，例如没有等效方法可用作DOM
    API的一部分的`.addClass()`和`.wrap()`。
- en: Since the returned jQuery collection objects do not differ in anything other
    than the elements they wrap, we can use any method of the jQuery API in the same
    way. As we saw earlier, these methods apply to each element of the retrieved collection,
    regardless of the element count. As a result, we do not need a separate `for`
    loop to iterate over each retrieved element and apply our manipulations individually;
    instead, we apply our manipulations (for example, `.addClass()`) directly to the
    collection object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于返回的jQuery集合对象除了封装的元素不同之外，我们可以以相同的方式使用jQuery API的任何方法。正如我们前面所看到的，这些方法适用于检索到的每个元素，而不管元素计数如何。因此，我们不需要单独的`for`循环来迭代每个检索到的元素并分别应用我们的操作；相反，我们直接将我们的操作（例如`.addClass()`）应用到集合对象上。
- en: To continue providing the same execution safety guaranties in the later example,
    we also need to add some extra `if` statements to check for `null` values. This
    is required because, for example, if the `headerElement` is not found, an error
    will occur and the rest of the lines of code will never be executed. Someone could
    argue that these checks, such as `if (headerElement)` and `if (boxContainerElement)`,
    are not required in this example and can be omitted. This might appear to be correct
    in this example, but actually this is among the top reasons for errors while developing
    large-scale applications, where elements are created, inserted, and removed from
    the DOM tree continuously. Unfortunately, programmers in all languages and target
    platforms tend to first write their implementation logic and fill such checks
    at a later time, often after they get an error when testing their implementation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在后面的示例中继续提供相同的执行安全保证，我们还需要添加一些额外的`if`语句来检查`null`值。这是必需的，因为，例如，如果未找到`headerElement`，将会发生错误，并且其余的代码行将永远不会被执行。有人可能会认为这些检查，如`if
    (headerElement)`和`if (boxContainerElement)`在本示例中不是必需的，可以省略。在这个示例中，这似乎是正确的，但实际上这是在开发大型应用程序时发生错误的主要原因之一，其中元素不断地被创建、插入和删除到DOM树中。不幸的是，所有语言和目标平台的程序员都倾向于首先编写他们的实现逻辑，然后在以后的某个时候填写这些检查，通常是在测试实现时出现错误后。
- en: Following the Composite Pattern, even an empty jQuery collection object (one
    that contains no retrieved elements) is still a valid collection object, where
    we can safely apply any method that jQuery provides. As a result, we do not need
    the extra `if` statements to check whether a collection actually contains any
    element before applying a method such as `.css()`, just for the sake of avoiding
    a JavaScript runtime error.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循复合模式，即使是一个空的jQuery集合对象（不包含任何检索到的元素），仍然是一个有效的集合对象，我们可以安全地应用jQuery提供的任何方法。因此，我们不需要额外的`if`语句来检查集合是否实际包含任何元素，然后应用诸如`.css()`之类的方法，仅仅是为了避免JavaScript运行时错误。
- en: Overall, the abstractions that jQuery offers by using the Composite Pattern
    lead to fewer lines of code, which is more readable, uniform, and with fewer typo-prone
    lines (compare typing `$('#elementID')` versus `document.getElementById('elementID')`).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，jQuery使用复合模式提供的抽象使得代码行数减少，更易读、统一，并且有更少的易出错行（比较输入`$('#elementID')`与`document.getElementById('elementID')`）。
- en: Using the Composite Pattern to develop applications
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用复合模式开发应用程序
- en: Now that we have seen how jQuery uses the Composite Pattern in its architecture
    and also did a comparison on the benefits it provided, let's try to write an example
    use case of our own. We will try to cover all concepts that we have seen earlier
    in this chapter. We will structure our Composite to be an Array-like object, operate
    on totally different structured objects, provide a Fluent API to allow chaining,
    and have methods that apply on all the items of the collection.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了jQuery如何在其架构中使用复合模式，并且还进行了比较以及提供的好处，让我们尝试编写一个自己的示例用例。我们将尝试涵盖本章中早期看到的所有概念。我们将结构化我们的复合对象以成为一个类似数组的对象，操作完全不同结构的对象，提供流畅的API以允许链式调用，并且具有应用于集合中所有项目的方法。
- en: A sample use case
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个示例用例
- en: 'Let''s say that we have an application that at some point needs to perform
    operations on numbers. On the other hand, the items that it needs to operate on
    come from different sources and are not uniform at all. To make this example interesting,
    let''s suppose that one source of data provides plain numbers and another one
    provides objects with a specific property that holds the number we are interested
    in:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个应用程序，某个时刻需要对数字执行操作。另一方面，它需要操作的项目来自不同的来源，且完全不统一。为了使这个示例有趣，假设数据的一个来源提供普通数字，另一个提供具有包含我们感兴趣数字的特定属性的对象：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The objects returned by the second source of our use case could have a more
    complex structure and probably some extra properties. Such changes wouldn't differentiate
    our example implementation in any way, since when developing a Composite we are
    only interested in providing a uniform handling over the common parts between
    the targeted items.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用情景的第二个来源返回的对象可能具有更复杂的结构，可能还有一些额外的属性。这些更改不会以任何方式区分我们的示例实现，因为在开发复合对象时，我们只对提供对目标项目的共同部分进行统一处理感兴趣。
- en: The Composite Collection Implementation
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复合集合实现
- en: 'Let''s proceed and define the Constructor Function and the prototype that will
    describe our Composite Collection Object:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续并定义构造函数和原型，来描述我们的组合集合对象：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `ValuesComposite()` constructor function in our example is quite simple.
    When invoked with the `new` operator, it returns an empty object with a `length`
    property equal to zero, representing that the collection it wraps is empty.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`ValuesComposite()` 构造函数非常简单。当使用 `new` 操作符调用时，它返回一个长度为零的空对象，表示它包装的集合是空的。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the Prototype-based programming model of JavaScript,
    visit [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 JavaScript 基于原型的编程模型的更多信息，请访问 [https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript)。
- en: We first need to define a way that will enable us to populate our composite
    collection objects. We defined the `append` method that checks whether the provided
    parameter is one of the types that it can handle; in this case, it appends the
    parameter on the Composite Object on the next available numeric property and increments
    the `length` property value. For example, the first appended item, whether it
    is an object with a value property or a plain number, will be exposed to the "`0`"
    property of the Composite Object and will be accessible with the Bracket Property
    Accessor's syntax as `myValuesComposition[0]`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要定义一种方法，使我们能够填充我们的组合集合对象。我们定义了 `append` 方法，该方法检查提供的参数是否是它可以处理的类型之一；在这种情况下，它将参数附加到组合对象上的下一个可用数字属性，并增加
    `length` 属性值。例如，第一个附加的项，无论是具有值属性的对象还是纯数字，都将暴露给组合对象的 "`0`" 属性，并可以使用括号属性访问者的语法访问为
    `myValuesComposition[0]`。
- en: The `increment` method is presented as a simple example method that can manipulate
    such collections by operating over all the collection items. It accepts a numeric
    value as a parameter and then appropriately handles it by adding it to each item
    of our collection, based on their type. Since our composite is an Array-like object,
    `increment` uses a `for` loop to iterate over all the collection items and either
    increases the `item.value` (in case the item is an object) or the actual numeric
    value stored (when the collection item stored is a number). In the same manner,
    we can continue and implement other methods that will, for example, enable us
    to multiply the collection items with a specific number.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`increment` 方法被呈现为一个简单的例子方法，可以通过操作所有集合项来操作这些集合。它接受一个数字值作为参数，然后根据它们的类型适当地处理它，将它添加到我们集合的每个项中。由于我们的组合是类似于数组的对象，`increment`
    使用 `for` 循环来迭代所有集合项，并增加 `item.value`（如果项是对象）或存储的实际数字值（当集合项存储的是数字时）。同样地，我们可以继续实现其他方法，例如使我们能够将集合项与特定数字相乘。'
- en: In order to allow chaining the methods of our Composite Object, all the methods
    of the prototype need to return a reference to the instance of the object. We
    achieve this goal by simply adding a `return this;` statement as the last line
    for all the methods that manipulate the collection, such as `append` and `increment`.
    Keep in mind that methods such as `getValues` that do not manipulate the collection
    but are used to return a result, by definition, can't be chained to relay the
    collection object instance to subsequent method calls.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许链接我们的组合对象的方法，原型的所有方法都需要返回对对象实例的引用。我们通过简单地在操纵集合的所有方法的最后一行添加 `return this;`
    语句来实现这个目标，例如 `append` 和 `increment`。请记住，例如 `getValues` 这样不操纵集合但用于返回结果的方法，根据定义，不能链接到传递集合对象实例的后续方法调用。
- en: Finally, we implement the `getValues` method as a convenient way to retrieve
    the actual numeric values of all the items in our collection. Similar to the `increment`
    method, the `getValues` method abstracts away the handling between the different
    item types of our collection. It iterates over the collection items, extracts
    each numeric value, and appends them to a `result` array that it returns to its
    caller.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现 `getValues` 方法作为检索我们集合中所有项的实际数字值的便捷方式。与 `increment` 方法类似，`getValues`
    方法抽象了我们集合的不同项类型之间的处理。它遍历集合项，提取每个数字值，并将它们附加到一个 `result` 数组中，然后返回给它的调用者。
- en: An example execution
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个例子执行
- en: 'Let''s now see an actual example that will use the Composite Object we just
    implemented:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个实际的例子，将使用我们刚刚实现的组合对象：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When the preceding code is executed in a browser, by writing the code either
    in an existing page or directly in the browser''s console, it will log a result
    that looks as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当在浏览器中执行上述代码时，通过将代码编写到现有页面或直接编写到浏览器控制台中，将记录如下结果：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We are using our data sources such as the `numberValues` and `objectsWithValues`
    variables that were shown earlier. The preceding code iterates over both of them
    and appends their items to a newly created Composite Object instance. We then
    proceed by incrementing the values of our composite collection by 2\. Right after
    this, we chain the three item insertions using `append`, with the first two appending
    numeric values and the third appending an object with a value property. Finally,
    we use the `getValues` method in order to get an array with all the numeric values
    of our collection and log it in our browser's console.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用我们的数据源，例如前面显示的`numberValues`和`objectsWithValues`变量。上述代码遍历它们并将它们的项附加到一个新创建的组合对象实例上。然后，我们通过
    2 递增我们的复合集合的值。紧接着，我们使用`append`链式三个项目插入，前两个追加数值，第三个追加一个具有值属性的对象。最后，我们使用`getValues`方法获取一个包含我们集合所有数值的数组，并在浏览器控制台中记录它。
- en: Alternative implementations
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选的实现方式
- en: Keep in mind that a Composite does not need to be an Array-like object, but
    is commonly preferred since JavaScript makes it easy to create such an implementation.
    Additionally, Array-like implementations also have the benefit of allowing us
    to iterate over the collection items using a simple `for` loop.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，组合对象不一定要是类似数组的对象，但通常偏好于这样的实现，因为 JavaScript 让创建这样的实现变得很容易。另外，类似数组的实现还有一个好处，就是允许我们使用简单的`for`循环迭代集合项。
- en: On the other hand, in case an Array-like object is not preferred, we can easily
    use a property on the Composite Object to hold our collection items. For example,
    this property can be named as `items` and be used to store and access the items
    of the collection inside our methods using `this.items.push(item)` and `this.items[i]`,
    respectively.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果不喜欢类似数组的对象，我们可以轻松地在组合对象上使用一个属性来保存我们的集合项。例如，这个属性可以命名为`items`，并且可以在我们的方法中使用`this.items.push(item)`和`this.items[i]`来存储和访问集合的项，分别。
- en: The Iterator Pattern
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器模式
- en: The key concept of the Iterator Pattern is the use of a function with the single
    responsibility to traverse a collection and provide access to its items. This
    function is known as the iterator and provides a way to access the items of the
    collection, without exposing implementation specifics and the underlying data
    structure used by the collection object.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器模式的关键概念是使用一个负责遍历集合并提供对其项访问的函数。这个函数被称为迭代器，提供了一种访问集合项的方式，而不暴露具体实现和集合对象所使用的底层数据结构。
- en: Iterators provide a level of encapsulation regarding the way the iteration occurs,
    decoupling the iteration over the items of a collection from the implementation
    logic of their consumers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器提供了关于迭代发生方式的封装级别，将集合项的迭代与其消费者的实现逻辑解耦。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the **Single Responsibility principle**, you can visit
    [http://www.oodesign.com/single-responsibility-principle.html](http://www.oodesign.com/single-responsibility-principle.html).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 关于**单一职责原则**的更多信息，请访问[http://www.oodesign.com/single-responsibility-principle.html](http://www.oodesign.com/single-responsibility-principle.html)。
- en: How the Iterator Pattern is used by jQuery
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery 如何使用迭代器模式
- en: As we saw earlier in this chapter, the jQuery core `$()` function returns an
    Array-like object that wraps a collection of page elements and it also provides
    an iterator function to traverse it and access each element individually. It actually
    goes one step further and provides a generic helper method `jQuery.each()` that
    can iterate over arrays, Array-like objects, and also object properties.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面看到的，jQuery 核心`$()`函数返回一个类似数组的对象，包装了一组页面元素，并提供了一个迭代函数来遍历它并单独访问每个元素。它实际上进一步提供了一个通用的辅助方法`jQuery.each()`，可以迭代数组、类似数组的对象，以及对象属性。
- en: 'A more technical description can be found in jQuery API documentation page
    at [http://api.jquery.com/jQuery.each/](http://api.jquery.com/jQuery.each/), where
    the description of `jQuery.each()` reads as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 更多技术描述可以在 jQuery API 文档页面[http://api.jquery.com/jQuery.each/](http://api.jquery.com/jQuery.each/)中找到，其中`jQuery.each()`的描述如下：
- en: A generic iterator function, which can be used to seamlessly iterate over both
    objects and arrays. Arrays and Array-like objects with a length property (such
    as a function's arguments object) are iterated by numeric index, from 0 to length-1\.
    Other objects are iterated via their named properties.
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个通用的迭代器函数，可以无缝地迭代对象和数组。数组和具有长度属性的类数组对象（例如函数的参数对象）通过数值索引迭代，从0到length-1。其他对象通过它们的命名属性进行迭代。
- en: The `jQuery.each()` helper function is used internally in several places of
    the jQuery source code. One of its uses is iterating over the items of a jQuery
    object and applying manipulations on each of them, as the Composite Pattern suggests.
    A simple search for the keyword `.each(` reveals 56 matches.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`jQuery.each()`辅助函数在jQuery源代码的几个地方内部使用。其中一个用途是遍历jQuery对象的条目，并对每个条目应用操作，这正如组合模式所建议的那样。简单搜索关键字`.each(`会发现有56个匹配结果。'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As of writing this book, the latest stable version is v2.2.0 and this was used
    for the above statistics.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，最新的稳定版本是v2.2.0，它被用于上述统计信息。
- en: 'We can easily trace its implementation in jQuery''s source, either by searching
    for `"each:"` (note that there are two occurrences) or using the jQuery Source
    Viewer and searching for `"jQuery.each()"` (like we did earlier in this chapter):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地跟踪它在jQuery源码中的实现，可以通过搜索`"each:"`（注意有两个出现）或使用jQuery源码查看器搜索`"jQuery.each()"`（就像我们在本章早些时候做的那样）：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This helper function is also accessible on any jQuery object by using the same
    prototypical inheritance that we saw earlier for methods such as `.append()`.
    You can easily find the code that does exactly this, by searching for `"jQuery.fn.each()"`
    in jQuery Source Viewer or directly searching jQuery source code for `each:` (note
    that there are two occurrences):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个辅助函数也可以通过使用之前看到的像`.append()`这样的方法一样的原型继承在任何jQuery对象上访问。你可以轻松找到确切实现这个功能的代码，只需在jQuery源码查看器中搜索`"jQuery.fn.each()"`或者直接搜索jQuery源代码中的`each:`（注意有两个出现的地方）：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using the method version of `".each()"` enables us to directly iterate over
    the elements of a jQuery collection object with a more convenient syntax.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`".each()"`的方法版本可以让我们以更方便的语法直接迭代jQuery集合对象的元素。
- en: 'The example code that follows showcases how the two flavors of `.each()` can
    be used in our code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例代码展示了如何在我们的代码中使用两种`.each()`的方式：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When executed, the preceding code will log the following on the browser''s
    console:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，前面的代码将在浏览器控制台上记录以下内容：
- en: '![How the Iterator Pattern is used by jQuery](img/00006.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![jQuery 如何使用迭代器模式](img/00006.jpeg)'
- en: How it pairs with the Composite Pattern
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与组合模式搭配使用
- en: Since the Composite Pattern encapsulates a collection of items into a single
    object and the Iterator Pattern can be used to iterate over an abstracted data
    structure, we can easily characterize these two patterns as complementary.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因为组合模式将一个项目集合封装为单个对象，并且迭代器模式可以用于迭代抽象数据结构，所以我们可以很容易地将这两种模式描述为互补的。
- en: Where can it be used
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可以在哪里使用
- en: 'The Iterator Pattern can be used in our applications to abstract the way we
    access items from a data structure. For example, let''s suppose we need to retrieve
    all the items that are greater than 4 from the following tree structure:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器模式可以用于我们的应用程序中抽象化我们从数据结构中访问项目的方式。例如，假设我们需要从以下树形结构中检索大于4的所有项目：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s now implement our iterator function. Since tree data structures can
    have nesting, we end up with the following recursive implementation:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现迭代器函数。因为树形数据结构可以有嵌套，所以我们最终得到下面的递归实现：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we end up with an implementation that looks as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得到的实现如下所示：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When executed, the preceding code will log the following on the browser''s
    console:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，前面的代码将在浏览器控制台上记录以下内容：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can clearly see that the iterator simplified our code. We no longer bother
    with the implementation specifics of the data structure used every time we need
    to access some items that fulfill certain criteria. Our implementation works on
    top of the generic API that the iterator exposes, and our implementation logic
    appears in the callback that we provide to the iterator.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到迭代器简化了我们的代码。我们再也不需要每次访问满足特定条件的一些项目时烦恼于使用的数据结构的实现细节。我们的实现建立在迭代器公开的通用API之上，并且我们的实现逻辑出现在我们为迭代器提供的回调中。
- en: This encapsulation allows us to decouple our implementation from the data structure
    used, given that an iterator with the same API will be available. For instance,
    in this example, we can easily change the data structure used to a sorted binary
    tree or a simple array and preserve our implementation logic the same.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种封装使我们能够将我们的实现与所使用的数据结构解耦，前提是将提供具有相同 API 的迭代器。例如，在这个例子中，我们可以轻松地将使用的数据结构更改为排序的二叉树或简单数组，并保持我们的实现逻辑不变。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we had a refresher on JavaScript's DOM Scripting API and jQuery.
    We were introduced to the Composite Pattern and saw how it is used by the jQuery
    library. We saw how the Composite Pattern simplifies our workflow after we rewrote
    our example page without using jQuery, and later showcased an example of using
    the Composite Pattern in our applications. Finally, we were introduced to the
    Iterator Pattern and saw how well it pairs when used along with the Composite
    Pattern.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对 JavaScript 的 DOM 脚本 API 和 jQuery 进行了复习。我们介绍了复合模式，并看到了它是如何被 jQuery 库使用的。我们看到了复合模式如何简化我们的工作流程，当我们在不使用
    jQuery 的情况下重新编写了我们的示例页面之后，并且随后展示了在我们的应用程序中使用复合模式的示例。最后，我们介绍了迭代器模式，并看到了当与复合模式一起使用时它是多么出色。
- en: Now that we have completed our introduction on how the Composite Pattern plays
    an important role in the way we use jQuery methods every day, we can move on to
    the next chapter where we will showcase the Observer Pattern and the convenient
    way to utilize it in our pages using jQuery.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了关于复合模式在我们日常使用 jQuery 方法中发挥重要作用的介绍，我们可以继续下一章，在那里我们将展示观察者模式以及使用 jQuery
    在我们的页面中方便地利用它的方式。
