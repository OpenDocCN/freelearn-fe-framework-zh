<html><head></head><body>
  <div id="_idContainer176" class="Basic-Text-Frame">
    <h1 class="chapterNumber">20</h1>
    <h1 id="_idParaDest-253" class="chapterTitle">Rendering Item Lists</h1>
    <p class="normal">In this chapter, you’ll learn how to work with item lists. Lists are a common web application component. While it’s relatively straightforward to build lists using the <code class="inlineCode">&lt;ul&gt;</code> and <code class="inlineCode">&lt;li&gt;</code> elements, doing something similar on native mobile platforms is much more involved.</p>
    <p class="normal">Thankfully, React Native <a id="_idIndexMarker756"/>provides an <strong class="keyWord">item list </strong>interface that hides all of the complexity. First, you’ll get a feel for how item lists work by walking through an example. Then, you’ll learn how to build controls that change the data displayed in lists. Lastly, you’ll see a couple of examples that fetch items from the network. </p>
    <p class="normal">We’ll cover the following topics in this chapter:</p>
    <ul>
      <li class="bulletList">Rendering data collections</li>
      <li class="bulletList">Sorting and filtering lists</li>
      <li class="bulletList">Fetching list data</li>
      <li class="bulletList">Lazy list loading</li>
      <li class="bulletList">Implementing pull to refresh</li>
    </ul>
    <h1 id="_idParaDest-254" class="heading-1">Technical requirements</h1>
    <p class="normal">You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter20"><span class="url">https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter20</span></a>.</p>
    <h1 id="_idParaDest-255" class="heading-1">Rendering data collections</h1>
    <p class="normal"><strong class="keyWord">Lists</strong> are the most common way to display a lot of information: for example, you can display your <a id="_idIndexMarker757"/>friend list, messages, and news. Many apps contain lists with data collections, and React Native provides the tools to create these components.</p>
    <p class="normal">Let’s start with an example. The React Native component you’ll use to render lists is <code class="inlineCode">FlatList</code>, which works the same way on iOS and Android. List views accept a <code class="inlineCode">data</code> property, which is an array of objects. These objects can have any properties you like, but they do require a <code class="inlineCode">key</code> property. If you don’t have a <code class="inlineCode">key</code> property, you can pass the <code class="inlineCode">keyExtractor</code> prop to the <code class="inlineCode">Flatlist</code> component and instruct what to use instead of <code class="inlineCode">key</code>. The <code class="inlineCode">key</code> property is similar to the requirement for rendering the <code class="inlineCode">&lt;li&gt;</code> elements inside of a <code class="inlineCode">&lt;ul&gt;</code> element. This helps the list to efficiently render when changes are made to list data.</p>
    <p class="normal">Let’s implement a basic list now. Here’s the code to render a basic 100-item list:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title">Array</span>(<span class="hljs-number">100</span>)
  .<span class="hljs-title">fill</span>(<span class="hljs-literal">null</span>)
  .<span class="hljs-title">map</span>(<span class="hljs-function">(</span><span class="hljs-params">v, i</span><span class="hljs-function">) =&gt;</span> ({ <span class="hljs-attr">key</span>: i.<span class="hljs-title">toString</span>(), <span class="hljs-attr">value</span>: <span class="hljs-string">`Item </span><span class="hljs-subst">${i}</span><span class="hljs-string">`</span> }));
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">App</span>() {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">View</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.container}</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">FlatList</span>
<span class="hljs-tag">        </span><span class="hljs-attr">data</span><span class="hljs-tag">=</span><span class="hljs-string">{data}</span>
<span class="hljs-tag">        </span><span class="hljs-attr">renderItem</span><span class="hljs-tag">=</span><span class="hljs-string">{({</span><span class="hljs-tag"> </span><span class="hljs-attr">item</span><span class="hljs-tag"> }) =&gt;</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">Text</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.item}</span><span class="hljs-tag">&gt;</span>{item.value}<span class="hljs-tag">&lt;/</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>}
      /&gt;
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">View</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">Let’s walk through what’s going on here, starting with the <code class="inlineCode">data</code> constant. This has an array of 100 items in it. It is created by filling in a new array with 100 <code class="inlineCode">null</code> values and then mapping this to a new array with the objects that you want to pass to <code class="inlineCode">&lt;FlatList&gt;</code>. Each object has a <code class="inlineCode">key</code> property because this is a requirement; anything else is optional. In this case, you’ve decided to add a <code class="inlineCode">value</code> property that will be used later when the list is rendered.</p>
    <p class="normal">Next, you render the <code class="inlineCode">&lt;FlatList&gt;</code> component. It’s within a <code class="inlineCode">&lt;View&gt;</code> container because list views need height in order to make scrolling work correctly. The <code class="inlineCode">data</code> and <code class="inlineCode">renderItem</code> properties are passed to <code class="inlineCode">&lt;FlatList&gt;</code>, which ultimately determines the rendered content.</p>
    <p class="normal">At first glance, it seems like the <code class="inlineCode">FlatList</code> component doesn’t do too much. Do you have to figure out how the items look? Well, yes, the <code class="inlineCode">FlatList</code> component is supposed to be generic. It’s <a id="_idIndexMarker758"/>supposed to excel at handling updates and embeds scrolling capabilities into lists for us. Here are the styles that were used to render the list:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { <span class="hljs-title">StyleSheet</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-native"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title">StyleSheet</span>.<span class="hljs-title">create</span>({
  <span class="hljs-attr">container</span>: {
    <span class="hljs-attr">flex</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">flexDirection</span>: <span class="hljs-string">"</span><span class="hljs-string">column"</span>,
    <span class="hljs-attr">paddingTop</span>: <span class="hljs-number">40</span>,
  },
  <span class="hljs-attr">item</span>: {
    <span class="hljs-attr">margin</span>: <span class="hljs-number">5</span>,
    <span class="hljs-attr">padding</span>: <span class="hljs-number">5</span>,
    <span class="hljs-attr">color</span>: <span class="hljs-string">"slategrey"</span>,
    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">"ghostwhite"</span>,
    <span class="hljs-attr">textAlign</span>: <span class="hljs-string">"center"</span>,
  },
});
</code></pre>
    <p class="normal">Here, you’re styling each item on your list. Otherwise, each item would be text-only, and it would be difficult to differentiate between other list items. The <code class="inlineCode">container</code> style gives the list height by setting <code class="inlineCode">flex</code> to <code class="inlineCode">1</code>.</p>
    <p class="normal">Let’s see what the list looks like now:</p>
    <figure class="mediaobject"> <img src="../Images/B19636_20_01.png" alt="Picture 1"/></figure>
    <p class="packt_figref">Figure 20.1: Rendering the data collection</p>
    <p class="normal">If you’re <a id="_idIndexMarker759"/>running this example in a simulator, you can click and hold down the mouse button anywhere on the screen, like a finger, and then scroll up and down through the items.</p>
    <p class="normal">In the following section, you’ll learn how to add controls for sorting and filtering lists.</p>
    <h1 id="_idParaDest-256" class="heading-1">Sorting and filtering lists</h1>
    <p class="normal">Now that you have learned the basics of the <code class="inlineCode">FlatList</code> components, including how to pass data, let’s add <a id="_idIndexMarker760"/>some controls to the list that you just implemented in the <em class="italic">Rendering data collections</em> <a id="_idIndexMarker761"/>section. The <strong class="keyWord">FlatList</strong> component <a id="_idIndexMarker762"/>can be rendered together with other components: for example, list controls. It helps you to manipulate the data source, which ultimately drives what’s rendered on the screen.</p>
    <p class="normal">Before implementing list control components, it might be helpful to review the high-level structure of these components so that the code has more context. Here’s an illustration of the component structure that you’re going to implement:</p>
    <figure class="mediaobject"> <img src="../Images/B19636_20_02.png" alt="Picture 2"/></figure>
    <p class="packt_figref">Figure 20.2: The component structure</p>
    <p class="normal">Here’s what each of these components is responsible for:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">ListContainer</code>: The overall container for the list; it follows the familiar React container pattern</li>
      <li class="bulletList"><code class="inlineCode">List</code>: A stateless component that passes the relevant pieces of state into <code class="inlineCode">ListControls</code> and the React Native <code class="inlineCode">ListView</code> component</li>
      <li class="bulletList"><code class="inlineCode">ListControls</code>: A component that holds the various controls that change the state of the list</li>
      <li class="bulletList"><code class="inlineCode">ListFilter</code>: A control for filtering the item list</li>
      <li class="bulletList"><code class="inlineCode">ListSort</code>: A control for changing the sort order of the list</li>
      <li class="bulletList"><code class="inlineCode">FlatList</code>: The actual React Native component that renders items</li>
    </ul>
    <p class="normal">In some cases, splitting apart the implementation of a list like this is overhead. However, I think that <a id="_idIndexMarker763"/>if your list needs controls in the first place, you’re probably <a id="_idIndexMarker764"/>implementing something that will stand to benefit from having a well-thought-out component architecture.</p>
    <p class="normal">Now, let’s drill down into the implementation of this list, starting with the <strong class="keyWord">ListContainer</strong> component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">mapItems</span>(<span class="hljs-params">items: string[]</span>) {
  <span class="hljs-keyword">return</span> items.<span class="hljs-title">map</span>(<span class="hljs-function">(</span><span class="hljs-params">value, i</span><span class="hljs-function">) =&gt;</span> ({ <span class="hljs-attr">key</span>: i.<span class="hljs-title">toString</span>(), value }));
}
<span class="hljs-keyword">const</span> array = <span class="hljs-keyword">new</span> <span class="hljs-title">Array</span>(<span class="hljs-number">100</span>).<span class="hljs-title">fill</span>(<span class="hljs-literal">null</span>).<span class="hljs-title">map</span>(<span class="hljs-function">(</span><span class="hljs-params">v, i</span><span class="hljs-function">) =&gt;</span> <span class="hljs-string">`Item </span><span class="hljs-subst">${i}</span><span class="hljs-string">`</span>);
<span class="hljs-keyword">function</span> <span class="hljs-title">filterAndSort</span>(<span class="hljs-params">text: string, asc: boolean</span>): string[] {
  <span class="hljs-keyword">return</span> array
    .<span class="hljs-title">filter</span>(<span class="hljs-function">(</span><span class="hljs-params">i</span><span class="hljs-function">) =&gt;</span> text.<span class="hljs-property">length</span> === <span class="hljs-number">0</span> || i.<span class="hljs-title">includes</span>(text))
    .<span class="hljs-title">sort</span>(
      asc
        ? <span class="hljs-function">(</span><span class="hljs-params">a, b</span><span class="hljs-function">) =&gt;</span> (a &gt; b ? <span class="hljs-number">1</span> : a &lt; b ? -<span class="hljs-number">1</span> : <span class="hljs-number">0</span>)
        : <span class="hljs-function">(</span><span class="hljs-params">a, b</span><span class="hljs-function">) =&gt;</span> (b &gt; a ? <span class="hljs-number">1</span> : b &lt; a ? -<span class="hljs-number">1</span> : <span class="hljs-number">0</span>)
    );
}
</code></pre>
    <p class="normal">Here, we define a few utility functions and the initial array that we will use. </p>
    <p class="normal">Then, we will define <code class="inlineCode">asc</code> and <code class="inlineCode">filter</code> for managing sorting and filtering the list, respectively, with the <code class="inlineCode">data</code> variable implemented using the <code class="inlineCode">useMemo</code> hook:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">ListContainer</span>() {
  <span class="hljs-keyword">const</span> [asc, setAsc] = <span class="hljs-title">useState</span>(<span class="hljs-literal">true</span>);
  <span class="hljs-keyword">const</span> [filter, setFilter] = <span class="hljs-title">useState</span>(<span class="hljs-string">""</span>);
  <span class="hljs-keyword">const</span> data = <span class="hljs-title">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title">filterAndSort</span>(filter, asc);
  }, [filter, asc]);
</code></pre>
    <p class="normal">It gives us an opportunity to avoid updating it manually because it will be recalculated automatically when the <code class="inlineCode">filter</code> and <code class="inlineCode">asc</code> dependencies are updated. It also helps us to avoid unnecessary recalculation when <code class="inlineCode">filter</code> and <code class="inlineCode">asc</code> are not changed.</p>
    <p class="normal">This is how we apply this logic to the <code class="inlineCode">List</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">List</span>
<span class="hljs-tag">    </span><span class="hljs-attr">data</span><span class="hljs-tag">=</span><span class="hljs-string">{mapItems(data)}</span>
<span class="hljs-tag">    </span><span class="hljs-attr">asc</span><span class="hljs-tag">=</span><span class="hljs-string">{asc}</span>
<span class="hljs-tag">    </span><span class="hljs-attr">onFilter</span><span class="hljs-tag">=</span><span class="hljs-string">{(text)</span><span class="hljs-tag"> =&gt;</span> {
      setFilter(text);
    }}
    onSort={() =&gt; {
      setAsc(!asc);
    }}
  /&gt;
);
</code></pre>
    <p class="normal">If this seems like a bit much, it’s because it is. This container component has a lot of state to handle. It also has some non-trivial behavior that it needs to make available to its children. If you <a id="_idIndexMarker765"/>look at it from the perspective of an encapsulating state, it will be <a id="_idIndexMarker766"/>more approachable. Its job is to populate the list with state data and provide functions that operate in this state.</p>
    <p class="normal">In an ideal world, the child components of this container should be nice and simple, since they don’t have to directly interface with the state. Let’s take a look at the <code class="inlineCode">List</code> component next:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">List</span>(<span class="hljs-params">{ data, ...props }: Props</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">FlatList</span>
<span class="hljs-tag">      </span><span class="hljs-attr">data</span><span class="hljs-tag">=</span><span class="hljs-string">{data}</span>
<span class="hljs-tag">      </span><span class="hljs-attr">ListHeaderComponent</span><span class="hljs-tag">=</span><span class="hljs-string">{</span><span class="hljs-tag">&lt;</span><span class="hljs-attr">ListControls</span><span class="hljs-tag"> {</span><span class="hljs-attr">...props</span><span class="hljs-tag">}/&gt;</span>}
      renderItem={({ item }) =&gt; <span class="hljs-tag">&lt;</span><span class="hljs-name">Text</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.item}</span><span class="hljs-tag">&gt;</span>{item.value}<span class="hljs-tag">&lt;/</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>}
    /&gt;
  );
}
</code></pre>
    <p class="normal">This component takes the state from the <code class="inlineCode">ListContainer</code> component as a property and renders a <code class="inlineCode">FlatList</code> component. The main difference here from the previous example is the <code class="inlineCode">ListHeaderComponent</code> property. This renders the controls for your <code class="inlineCode">List</code> component. What’s especially useful about this property is that it renders the controls outside the scrollable list content, ensuring that the controls are always visible. Let’s take a look at the <code class="inlineCode">ListControls</code> component next:</p>
    <pre class="programlisting code"><code class="hljs-code">type <span class="hljs-title">Props</span> = {
  <span class="hljs-attr">onFilter</span>: <span class="hljs-function">(</span><span class="hljs-params">text: string</span><span class="hljs-function">) =&gt;</span> <span class="hljs-keyword">void</span>;
  <span class="hljs-attr">onSort</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">void</span>;
  <span class="hljs-attr">asc</span>: boolean;
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">ListControls</span>(<span class="hljs-params">{ onFilter, onSort, asc }: Props</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">View</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.controls}</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">ListFilter</span><span class="hljs-tag"> </span><span class="hljs-attr">onFilter</span><span class="hljs-tag">=</span><span class="hljs-string">{onFilter}</span><span class="hljs-tag"> /&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">ListSort</span><span class="hljs-tag"> </span><span class="hljs-attr">onSort</span><span class="hljs-tag">=</span><span class="hljs-string">{onSort}</span><span class="hljs-tag"> </span><span class="hljs-attr">asc</span><span class="hljs-tag">=</span><span class="hljs-string">{asc}</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">View</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">This component <a id="_idIndexMarker767"/>brings together the <code class="inlineCode">ListFilter</code> and <code class="inlineCode">ListSort</code> controls. So, if you <a id="_idIndexMarker768"/>were to add another list control, you would add it here. </p>
    <p class="normal">Let’s take a look at the <code class="inlineCode">ListFilter</code> implementation now:</p>
    <pre class="programlisting code"><code class="hljs-code">type <span class="hljs-title">Props</span> = {
  <span class="hljs-attr">onFilter</span>: <span class="hljs-function">(</span><span class="hljs-params">text: string</span><span class="hljs-function">) =&gt;</span> <span class="hljs-keyword">void</span>;
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">ListFilter</span>(<span class="hljs-params">{ onFilter }: Props</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">View</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">TextInput</span>
<span class="hljs-tag">        </span><span class="hljs-attr">autoFocus</span>
<span class="hljs-tag">        </span><span class="hljs-attr">placeholder</span><span class="hljs-tag">=</span><span class="hljs-string">"Search"</span>
<span class="hljs-tag">        </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.filter}</span>
<span class="hljs-tag">        </span><span class="hljs-attr">onChangeText</span><span class="hljs-tag">=</span><span class="hljs-string">{onFilter}</span>
<span class="hljs-tag">      /&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">View</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">The filter control is a simple text input that filters the list of items by user type. The <code class="inlineCode">onFilter</code> function that <a id="_idIndexMarker769"/>handles this comes from the <code class="inlineCode">ListContainer</code> component.</p>
    <p class="normal">Let’s look <a id="_idIndexMarker770"/>at the <code class="inlineCode">ListSort</code> component next:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> arrows = <span class="hljs-keyword">new</span> <span class="hljs-title">Map</span>([
  [<span class="hljs-literal">true</span>, <span class="hljs-string">"▼"</span>],
  [<span class="hljs-literal">false</span>, <span class="hljs-string">"▲"</span>],
]);
type <span class="hljs-title">Props</span> = {
  <span class="hljs-attr">onSort</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">void</span>;
  <span class="hljs-attr">asc</span>: boolean;
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">ListSort</span>(<span class="hljs-params">{ onSort, asc }: Props</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">Text</span><span class="hljs-tag"> </span><span class="hljs-attr">onPress</span><span class="hljs-tag">=</span><span class="hljs-string">{onSort}</span><span class="hljs-tag">&gt;</span>{arrows.get(asc)}<span class="hljs-tag">&lt;/</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>;
}
</code></pre>
    <p class="normal">Here’s a look at the resulting list:</p>
    <figure class="mediaobject"> <img src="../Images/B19636_20_03.png" alt="Picture 3"/></figure>
    <p class="packt_figref">Figure 20.3: The sorting and filtering list</p>
    <p class="normal">By default, the entire <a id="_idIndexMarker771"/>list is rendered in ascending order. You can see the placeholder <strong class="screenText">Search</strong> text when <a id="_idIndexMarker772"/>the user hasn’t provided anything yet. Let’s see how this looks when you enter a filter and change the sort order:</p>
    <figure class="mediaobject"> <img src="../Images/B19636_20_04.png" alt="Picture 4"/></figure>
    <p class="packt_figref">Figure 20.4: The list with a changed sort order and search value</p>
    <p class="normal">This search includes <a id="_idIndexMarker773"/>items containing <code class="inlineCode">1</code> and sorts the results in descending order. Note <a id="_idIndexMarker774"/>that you can either change the order first or enter the filter first. Both the filter and the sort order are part of the <code class="inlineCode">ListContainer</code> state.</p>
    <p class="normal">In the next section, you’ll learn how to fetch list data from an API endpoint.</p>
    <h1 id="_idParaDest-257" class="heading-1">Fetching list data</h1>
    <p class="normal">Commonly, you’ll fetch your list data from some API endpoint. In this section, you’ll learn about <a id="_idIndexMarker775"/>making API requests from React Native components. The good news is that the <code class="inlineCode">fetch()</code> API is polyfilled by React Native, so the networking code in your mobile applications should look and feel a lot like it does in your web applications.</p>
    <p class="normal">To start things off, let’s build a <strong class="keyWord">mock API</strong> for our list items using functions that return promises just like <code class="inlineCode">fetch()</code> does:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> items = <span class="hljs-keyword">new</span> <span class="hljs-title">Array</span>(<span class="hljs-number">100</span>).<span class="hljs-title">fill</span>(<span class="hljs-literal">null</span>).<span class="hljs-title">map</span>(<span class="hljs-function">(</span><span class="hljs-params">v, i</span><span class="hljs-function">) =&gt;</span> <span class="hljs-string">`Item </span><span class="hljs-subst">${i}</span><span class="hljs-string">`</span>);
<span class="hljs-keyword">function</span> <span class="hljs-title">filterAndSort</span>(<span class="hljs-params">data: string[], text: string, asc: boolean</span>) {
  <span class="hljs-keyword">return</span> data
    .<span class="hljs-title">filter</span>(<span class="hljs-function">(</span><span class="hljs-params">i</span><span class="hljs-function">) =&gt;</span> text.<span class="hljs-property">length</span> === <span class="hljs-number">0</span> || i.<span class="hljs-title">includes</span>(text))
    .<span class="hljs-title">sort</span>(
      asc
        ? <span class="hljs-function">(</span><span class="hljs-params">a, b</span><span class="hljs-function">) =&gt;</span> (b &gt; a ? -<span class="hljs-number">1</span> : a === b ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>)
        : <span class="hljs-function">(</span><span class="hljs-params">a, b</span><span class="hljs-function">) =&gt;</span> (a &gt; b ? -<span class="hljs-number">1</span> : a === b ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>)
    );
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title">fetchItems</span>(
<span class="hljs-params">  filter: string,</span>
<span class="hljs-params">  asc: boolean</span>
): <span class="hljs-title">Promise</span>&lt;{ <span class="hljs-attr">json</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title">Promise</span>&lt;{ <span class="hljs-attr">items</span>: string[] }&gt; }&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Promise</span>(<span class="hljs-function">(</span><span class="hljs-params">resolve</span><span class="hljs-function">) =&gt;</span> {
    <span class="hljs-title">resolve</span>({
      <span class="hljs-attr">json</span>: <span class="hljs-function">() =&gt;</span>
        <span class="hljs-title">Promise</span>.<span class="hljs-title">resolve</span>({
          <span class="hljs-attr">items</span>: <span class="hljs-title">filterAndSort</span>(items, filter, asc),
        }),
    });
  });
}
</code></pre>
    <p class="normal">With the mock API function in place, let’s make some changes to the <code class="inlineCode">ListContainer</code> component. Instead of using local data sources, you can now use the <code class="inlineCode">fetchItems()</code> function to load data from the mock API. Let’s take a look and define the <code class="inlineCode">ListContainer</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">ListContainer</span>() {
  <span class="hljs-keyword">const</span> [asc, setAsc] = <span class="hljs-title">useState</span>(<span class="hljs-literal">true</span>);
  <span class="hljs-keyword">const</span> [filter, setFilter] = <span class="hljs-title">useState</span>(<span class="hljs-string">""</span>);
  <span class="hljs-keyword">const</span> [data, setData] = useState&lt;<span class="hljs-title">MappedList</span>&gt;([]);
  <span class="hljs-title">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title">fetchItems</span>(filter, asc)
      .<span class="hljs-title">then</span>(<span class="hljs-function">(</span><span class="hljs-params">resp</span><span class="hljs-function">) =&gt;</span> resp.<span class="hljs-title">json</span>())
      .<span class="hljs-title">then</span>(<span class="hljs-function">(</span><span class="hljs-params">{ items }</span><span class="hljs-function">) =&gt;</span> {
        <span class="hljs-title">setData</span>(<span class="hljs-title">mapItems</span>(items));
      });
  }, []);
</code></pre>
    <p class="normal">We’ve defined <a id="_idIndexMarker776"/>state variables using the <code class="inlineCode">useState</code> and <code class="inlineCode">useEffect</code> hooks to fetch initial list data. </p>
    <p class="normal">Now, let’s take a look at the usage of our new handlers in the <code class="inlineCode">List</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">List</span>
<span class="hljs-tag">      </span><span class="hljs-attr">data</span><span class="hljs-tag">=</span><span class="hljs-string">{data}</span>
<span class="hljs-tag">      </span><span class="hljs-attr">asc</span><span class="hljs-tag">=</span><span class="hljs-string">{asc}</span>
<span class="hljs-tag">      </span><span class="hljs-attr">onFilter</span><span class="hljs-tag">=</span><span class="hljs-string">{(text)</span><span class="hljs-tag"> =&gt;</span> {
        fetchItems(text, asc)
          .then((resp) =&gt; resp.json())
          .then(({ items }) =&gt; {
            setFilter(text);
            setData(mapItems(items));
          });
      }}
      onSort={() =&gt; {
        fetchItems(filter, !asc)
          .then((resp) =&gt; resp.json())
          .then(({ items }) =&gt; {
            setAsc(!asc);
            setData(mapItems(items));
          });
      }}
    /&gt;
  );
}
</code></pre>
    <p class="normal">Any action that modifies the state of the list needs to call <code class="inlineCode">fetchItems()</code> and set the appropriate state once the promise resolves. </p>
    <p class="normal">In the following section, you’ll learn how list data can be loaded lazily.</p>
    <h1 id="_idParaDest-258" class="heading-1">Lazy list loading</h1>
    <p class="normal">In this section, you’ll implement a different kind of list: one that scrolls infinitely. Sometimes, users <a id="_idIndexMarker777"/>don’t actually know what they’re looking for, so filtering or sorting isn’t going to help. Think about the Facebook news feed you see when you log in to your account; it’s the main feature of the application, and rarely are you looking for something specific. You need to see what’s going on by scrolling through the list.</p>
    <p class="normal">To do this using a <code class="inlineCode">FlatList</code> component, you need to be able to fetch more API data when the user scrolls to the end of the list. To get an idea of how this works, you need a lot of API data to work with, and generators are great at this. So, let’s modify the mock that you created in the <em class="italic">Fetching list data</em> section’s example so that it just keeps responding with new data:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span>* <span class="hljs-title">genItems</span>() {
  <span class="hljs-keyword">let</span> cnt = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">yield</span> <span class="hljs-string">`Item </span><span class="hljs-subst">${cnt++}</span><span class="hljs-string">`</span>;
  }
}
<span class="hljs-keyword">let</span> items = <span class="hljs-title">genItems</span>();
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title">fetchItems</span>(<span class="hljs-params">{ refresh }: { refresh?: boolean }</span>) {
  <span class="hljs-keyword">if</span> (refresh) {
    items = <span class="hljs-title">genItems</span>();
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title">Promise</span>.<span class="hljs-title">resolve</span>({
    <span class="hljs-attr">json</span>: <span class="hljs-function">() =&gt;</span>
      <span class="hljs-title">Promise</span>.<span class="hljs-title">resolve</span>({
        <span class="hljs-attr">items</span>: <span class="hljs-keyword">new</span> <span class="hljs-title">Array</span>(<span class="hljs-number">30</span>).<span class="hljs-title">fill</span>(<span class="hljs-literal">null</span>).<span class="hljs-title">map</span>(<span class="hljs-function">() =&gt;</span> items.<span class="hljs-title">next</span>().<span class="hljs-property">value</span> <span class="hljs-keyword">as</span> string),
      }),
  });
}
</code></pre>
    <p class="normal">With <code class="inlineCode">fetchItems</code>, you can now make an API request for new data every time the end of the list is reached. Eventually, this will fail when you run out of memory, but I’m just trying to show you in general terms the approach you can take to implement infinite scrolling in <a id="_idIndexMarker778"/>React Native. Now, let’s take a look at what the <code class="inlineCode">ListContainer</code> component looks like with <code class="inlineCode">fetchItems</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> <span class="hljs-title">React</span>, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> api <span class="hljs-keyword">from</span> <span class="hljs-string">"./api"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title">List</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"./List"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">ListContainer</span>() {
  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title">useState</span>([]);
  <span class="hljs-keyword">function</span> <span class="hljs-title">fetchItems</span>() {
    <span class="hljs-keyword">return</span> api
      .<span class="hljs-title">fetchItems</span>({})
      .<span class="hljs-title">then</span>(<span class="hljs-function">(</span><span class="hljs-params">resp</span><span class="hljs-function">) =&gt;</span> resp.<span class="hljs-title">json</span>())
      .<span class="hljs-title">then</span>(<span class="hljs-function">(</span><span class="hljs-params">{ items }</span><span class="hljs-function">) =&gt;</span> {
        <span class="hljs-title">setData</span>([
          ...data,
          ...items.<span class="hljs-title">map</span>(<span class="hljs-function">(</span><span class="hljs-params">value</span><span class="hljs-function">) =&gt;</span> ({
            <span class="hljs-attr">key</span>: value,
            value,
          })),
        ]);
      });
  }
  <span class="hljs-title">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title">fetchItems</span>();
  }, []);
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">List</span><span class="hljs-tag"> </span><span class="hljs-attr">data</span><span class="hljs-tag">=</span><span class="hljs-string">{data}</span><span class="hljs-tag"> </span><span class="hljs-attr">fetchItems</span><span class="hljs-tag">=</span><span class="hljs-string">{fetchItems}</span><span class="hljs-tag"> /&gt;</span>;
}
</code></pre>
    <p class="normal">Each time <code class="inlineCode">fetchItems()</code> is called, the response is concatenated with the <code class="inlineCode">data</code> array. This becomes the new list data source, instead of replacing it as you did in earlier examples.</p>
    <p class="normal">Now, let’s take a look at the <code class="inlineCode">List</code> component to see how to respond to the end of the list being reached:</p>
    <pre class="programlisting code"><code class="hljs-code">type <span class="hljs-title">Props</span> = {
  <span class="hljs-attr">data</span>: { <span class="hljs-attr">key</span>: string; <span class="hljs-attr">value</span>: string }[];
  <span class="hljs-attr">fetchItems</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt;;
  <span class="hljs-attr">refreshItems</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt;;
  <span class="hljs-attr">isRefreshing</span>: boolean;
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">List</span>(<span class="hljs-params">{</span>
<span class="hljs-params">  data,</span>
<span class="hljs-params">  fetchItems</span>
<span class="hljs-params">}: Props</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">FlatList</span>
<span class="hljs-tag">      </span><span class="hljs-attr">data</span><span class="hljs-tag">=</span><span class="hljs-string">{data}</span>
<span class="hljs-tag">      </span><span class="hljs-attr">renderItem</span><span class="hljs-tag">=</span><span class="hljs-string">{({</span><span class="hljs-tag"> </span><span class="hljs-attr">item</span><span class="hljs-tag"> }) =&gt;</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">Text</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.item}</span><span class="hljs-tag">&gt;</span>{item.value}<span class="hljs-tag">&lt;/</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>}
      onEndReached={fetchItems}
    /&gt;
  );
}
</code></pre>
    <p class="normal"><code class="inlineCode">FlatList</code> accepts the <code class="inlineCode">onEndReached</code> handler prop, which will be invoked every time you reach the end <a id="_idIndexMarker779"/>of the list during scrolling.</p>
    <p class="normal">If you run this example, you’ll see that, as you approach the bottom of the screen while scrolling, the list just keeps growing.</p>
    <h1 id="_idParaDest-259" class="heading-1">Implementing pull to refresh</h1>
    <p class="normal">The <strong class="keyWord">pull-to-refresh</strong> gesture is a common action on mobile devices. It allows users to refresh the <a id="_idIndexMarker780"/>content of a view without having to lift a finger from the screen or manually reopen the app, just by pulling it down to trigger a page refresh. Loren Brichter, the creator of Tweetie (later Twitter for iPhone) and Letterpress, introduced <a id="_idIndexMarker781"/>this gesture in 2009. This gesture has become so popular that Apple integrated it into its SDKs as <code class="inlineCode">UIRefreshControl</code>.</p>
    <p class="normal">To use pull to refresh in the <code class="inlineCode">FlatList</code> app, we just need to pass a few props and handlers. Let’s take a look at our <code class="inlineCode">List</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code">type <span class="hljs-title">Props</span> = {
  <span class="hljs-attr">data</span>: { <span class="hljs-attr">key</span>: string; <span class="hljs-attr">value</span>: string }[];
  <span class="hljs-attr">fetchItems</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt;;
  <span class="hljs-attr">refreshItems</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt;;
  <span class="hljs-attr">isRefreshing</span>: boolean;
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">List</span>(<span class="hljs-params">{</span>
<span class="hljs-params">  data,</span>
<span class="hljs-params">  fetchItems,</span>
<span class="hljs-params">  refreshItems,</span>
<span class="hljs-params">  isRefreshing,</span>
<span class="hljs-params">}: Props</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">FlatList</span>
<span class="hljs-tag">      </span><span class="hljs-attr">data</span><span class="hljs-tag">=</span><span class="hljs-string">{data}</span>
<span class="hljs-tag">      </span><span class="hljs-attr">renderItem</span><span class="hljs-tag">=</span><span class="hljs-string">{({</span><span class="hljs-tag"> </span><span class="hljs-attr">item</span><span class="hljs-tag"> }) =&gt;</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">Text</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.item}</span><span class="hljs-tag">&gt;</span>{item.value}<span class="hljs-tag">&lt;/</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>}
      onEndReached={fetchItems}
      onRefresh={refreshItems}
      refreshing={isRefreshing}
    /&gt;
  );
}
</code></pre>
    <p class="normal">As we have provided the <code class="inlineCode">onRefresh</code> and <code class="inlineCode">refreshing</code> props, our <code class="inlineCode">FlatList</code> component automatically enables the pull-to-refresh gesture. The <code class="inlineCode">onRefresh</code> handler will be called when you <a id="_idIndexMarker782"/>pull the list, and the refreshing property will enable the loading spinner to reflect the loading state. </p>
    <p class="normal">To apply defined props in the <code class="inlineCode">List</code> component, let’s implement the <code class="inlineCode">refreshItems</code> function with the <code class="inlineCode">isRefreshing</code> state in the <code class="inlineCode">ListContainer</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">const</span> [isRefreshing, setIsRefreshing] = <span class="hljs-title">useState</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">function</span> <span class="hljs-title">fetchItems</span>() {
    <span class="hljs-keyword">return</span> api
      .<span class="hljs-title">fetchItems</span>({})
      .<span class="hljs-title">then</span>(<span class="hljs-function">(</span><span class="hljs-params">resp</span><span class="hljs-function">) =&gt;</span> resp.<span class="hljs-title">json</span>())
      .<span class="hljs-title">then</span>(<span class="hljs-function">(</span><span class="hljs-params">{ items }</span><span class="hljs-function">) =&gt;</span> {
        <span class="hljs-title">setData</span>([
          ...data,
          ...items.<span class="hljs-title">map</span>(<span class="hljs-function">(</span><span class="hljs-params">value</span><span class="hljs-function">) =&gt;</span> ({
            <span class="hljs-attr">key</span>: value,
            value,
          })),
        ]);
      });
  }
</code></pre>
    <p class="normal">In <code class="inlineCode">refreshItems</code>, as well as in the <code class="inlineCode">fetchItems</code> method, we get list items but save them as a new list. Also, note that before calling the API, we update the <code class="inlineCode">isRefreshing</code> state to set it as a <code class="inlineCode">true</code> value, and in the final block, we set it to <code class="inlineCode">false</code> to provide information to <code class="inlineCode">FlatList</code> that loading has ended.</p>
    <h1 id="_idParaDest-260" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, you learned about the <code class="inlineCode">FlatList</code> component in React Native. This component is general-purpose, as it doesn’t impose any specific look on the items that get rendered. Instead, the appearance of the list is up to you, leaving the <code class="inlineCode">FlatList</code> component to help with efficiently rendering a data source. The <code class="inlineCode">FlatList</code> component also provides a scrollable region for the items it renders.</p>
    <p class="normal">You implemented an example that took advantage of section headers in list views. This is a good place to render static content such as list controls. You then learned about making network calls in React Native; it’s just like using <code class="inlineCode">fetch()</code> in any other web application.</p>
    <p class="normal">Finally, you implemented lazy lists that scroll infinitely by only loading new items after you’ve scrolled to the bottom of what’s already been rendered. Also, we added a feature to refresh that list by means of a pull gesture.</p>
    <p class="normal">In the next chapter, you’ll learn how to show the progress of network calls, among other things.</p>
  </div>
</body></html>