- en: Dependency Injection in Angular
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular中的依赖注入
- en: In this chapter, we'll explain how to take advantage of the **Dependency Injection**
    (**DI**) mechanism of the framework, with all its various features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释如何利用框架的**依赖注入**（**DI**）机制及其所有各种功能。
- en: 'We will explore the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨以下主题：
- en: Configuring and creating providers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和创建提供者
- en: Injecting dependencies, instantiated with the declared providers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入由声明提供者实例化的依赖项
- en: Lower level APIs for creating and configuring injectors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和配置注入器的底层API
- en: Reusing business logic defined in services across our UI components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的UI组件之间重用服务中定义的业务逻辑
- en: Why do I need dependency injection?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么我需要依赖注入？
- en: 'Let''s suppose that we have a `Car` class that depends on the `Engine` and
    `Transmission` classes. How can we implement this system? Let''s take a look:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个依赖于`Engine`和`Transmission`类的`Car`类。我们如何实现这个系统？让我们看看：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding example, we create the dependencies of the `Car` class inside
    its constructor. Although it looks simple, it is far from being flexible. Each
    time we create an instance of the `Car` class, in its constructor, instances of
    the same `Engine` and `Transmission` classes will be created. This may be problematic
    because of the following reasons:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们在`Car`类的构造函数中创建了`Car`类的依赖项。尽管看起来很简单，但它远非灵活。每次我们创建`Car`类的实例时，在其构造函数中，都会创建相同`Engine`和`Transmission`类的实例。这可能会因为以下原因而成为问题：
- en: The `Car` class gets less testable because we can't test it independently of
    its `engine` and `transmission` dependencies
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们无法独立于其`engine`和`transmission`依赖项对其进行测试，`Car`类变得难以测试。
- en: We couple the `Car` class with the logic used for the instantiation of its dependencies
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`Car`类与其依赖项的实例化逻辑耦合在一起。
- en: Dependency injection in Angular
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular中的依赖注入
- en: 'Another way we can approach this is by taking advantage of the DI pattern.
    We''re already familiar with it from AngularJS; let''s demonstrate how we can
    refactor the preceding code using DI in the context of Angular:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过利用依赖注入模式来解决这个问题。我们已经从AngularJS中熟悉了它；让我们演示如何在Angular的上下文中使用DI重构前面的代码：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All we did in the preceding snippet was adding the `@Injectable` class decorator
    on top of the definition of the `Car` class and providing type annotations for
    the parameters of its constructor.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们只是在`Car`类的定义上方添加了`@Injectable`类装饰器，并为构造函数的参数提供了类型注解。
- en: Benefits of using dependency injection
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用依赖注入的优点
- en: 'There is one more step left, which we''ll take a look at in the next section.
    Before that, let''s take a look at what the benefits of the mentioned approach
    are:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个步骤尚未完成，我们将在下一节中探讨。在此之前，让我们看看这种方法的优点：
- en: We can easily pass different versions of the dependencies of the `Car` class
    for a testing environment, or for instantiating different `Car` models
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以轻松地为测试环境或为实例化不同的`Car`模型传递`Car`类的不同依赖项版本。
- en: We're not coupled with the logic around the instantiation of the dependencies
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们与依赖项实例化的逻辑没有耦合。
- en: The `Car` class is only responsible for implementing its own domain-specific
    logic instead of being coupled with additional functionalities, such as the management
    of its dependencies. Our code also got more declarative and easier to read.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Car`类只负责实现其自身的领域特定逻辑，而不是与额外的功能耦合，例如其依赖项的管理。我们的代码也变得更加声明性，更容易阅读。'
- en: Now that we've realized some of the benefits of DI, let's take a look at the
    missing pieces in order to make this code work.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经意识到DI的一些好处，让我们看看为了让这段代码工作所缺少的部分。
- en: Declaring providers
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明提供者
- en: The primitive used for the instantiation of the individual dependencies in our
    Angular applications via the DI mechanism of the framework is called **injector**.
    The injector contains a set of **providers** that encapsulate the logic for the
    instantiation of registered dependencies associated with **tokens**. We can think
    of tokens as identifiers of the different providers registered within the injector.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Angular应用程序中，通过框架的DI机制实例化单个依赖项所使用的原始数据类型称为**注入器**。注入器包含一组**提供者**，它们封装了与**令牌**关联的已注册依赖项的实例化逻辑。我们可以将令牌视为注入器内注册的不同提供者的标识符。
- en: In Angular, we can declare the providers for the individual dependencies using
    `@NgModule`. Internally, **Angular will create an injector based on the providers
    we've declared in a module**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，我们可以使用`@NgModule`声明单个依赖的提供者。内部，**Angular将根据我们在模块中声明的提供者创建一个注入器**。
- en: 'Let''s take a look at the following snippet, which is located at `ch6/injector-basics/basics/app.ts`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码片段，它位于`ch6/injector-basics/basics/app.ts`：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once you set up the code for the book (for instructions take a look at [Chapter
    5](1b60c28e-5f34-493d-8371-c69968f09020.xhtml)*, Getting Started with Angular
    Components and Directives*) and run `npm start`, you can see the result of the
    execution on the `http://localhost:5555/dist/dev/ch6/injector-basics/basics/`
    address. When you open the browser''s console you''ll see these lines:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你为本书设置了代码（有关说明，请参阅[第5章](1b60c28e-5f34-493d-8371-c69968f09020.xhtml)*，开始使用Angular组件和指令*)并运行`npm
    start`，你就可以在`http://localhost:5555/dist/dev/ch6/injector-basics/basics/`地址上看到执行结果。当你打开浏览器的控制台时，你会看到以下这些行：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In *Figure 1*, we can see that `AppComponent` depends on the `Socket` class,
    which depends on the `Buffer` class, which depends on the `BUFFER_SIZE` class:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图1*中，我们可以看到`AppComponent`依赖于`Socket`类，而`Socket`类依赖于`Buffer`类，`Buffer`类又依赖于`BUFFER_SIZE`类：
- en: '![](img/ce5069e4-fd32-4490-97ce-2508046d432e.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce5069e4-fd32-4490-97ce-2508046d432e.png)'
- en: Figure 1
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图1
- en: 'We set the value of the `BUFFER_SIZE` class constant to `new InjectionToken<number>(''buffer-size'')`.
    We can think of the value of `BUFFER_SIZE` as a unique identifier that cannot
    be duplicated in the application. `InjectionToken` is an alternative of the `Symbol`
    class from ES2015, since at the time of writing this book, it is not supported
    by TypeScript. `InjectionToken` provides one additional feature that `Symbol`
    doesn''t: better type checking; Angular and TypeScript can use the type parameter
    that we pass to `InjectionToken` (`number`, in the preceding case) in order to
    perform more sophisticated type checking algorithms.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`BUFFER_SIZE`类常量的值设置为`new InjectionToken<number>('buffer-size')`。我们可以把`BUFFER_SIZE`的值看作是一个在应用程序中不能重复的唯一标识符。"InjectionToken"是ES2015中的`Symbol`类的替代品，因为在编写本书的时候，TypeScript不支持它。"InjectionToken"提供了一个`Symbol`没有的额外功能：更好的类型检查；Angular和TypeScript可以使用我们传递给`InjectionToken`的类型参数（在前面的例子中是`number`）来执行更复杂的类型检查算法。
- en: 'We defined two classes: `Buffer` and `Socket`. The `Buffer` class has a constructor
    that accepts only a single dependency called `size`, which is of the `number`
    type. In order to add additional metadata for the process of dependency resolution
    (that is, hint Angular that it should inject the value associated with the `BUFFER_SIZE`
    token), we use the `@Inject` parameter decorator. This decorator accepts a token
    for the dependency we want to inject. Usually, this token is the type of the dependency
    (that is, a reference of a class), but in some cases, it can be a different type
    of value. For example, in our case, we used the instance of the `InjectionToken`
    class.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个类：`Buffer`和`Socket`。`Buffer`类有一个构造函数，它只接受一个名为`size`的单个依赖项，其类型为`number`。为了在依赖项解析过程中添加额外的元数据（即提示Angular应该注入与`BUFFER_SIZE`令牌关联的值），我们使用`@Inject`参数装饰器。这个装饰器接受我们想要注入的依赖项的令牌。通常，这个令牌是依赖项的类型（即类的引用），但在某些情况下，它可以是不同类型的值。例如，在我们的案例中，我们使用了`InjectionToken`类的实例。
- en: Using the @Injectable decorator
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`@Injectable`装饰器
- en: Now, let's take a look at the `Socket` class. We decorate it with the `@Injectable`
    decorator. This decorator is supposed to be used by any class that accepts dependencies
    that should be injected via the DI mechanism of Angular.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看`Socket`类。我们用`@Injectable`装饰器来装饰它。这个装饰器应该被任何接受依赖并通过Angular的DI机制注入依赖的类使用。
- en: The `@Injectable` decorator hints Angular that a given class accepts arguments
    which should be injected with the dependency injection mechanism of the framework.
    This means that if we omit the `@Injectable` decorator, Angular's DI mechanism
    will not know that it needs to resolve the dependencies of the class before it
    instantiates it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Injectable`装饰器向Angular暗示，一个给定的类接受应该通过框架的依赖注入机制注入的参数。这意味着如果我们省略`@Injectable`装饰器，Angular的DI机制将不知道在实例化类之前需要解决类的依赖。'
- en: Before version 5 of Angular, the `@Injectable` decorator had different semantics
    related to the generation of metadata with type information by the TypeScript
    compiler. Although this is an important detail, it doesn't have any impact on
    the way we use the dependency injection mechanism of the framework or the `@Injectable`
    decorator in particular.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 5 版本之前，`@Injectable` 装饰器与 TypeScript 编译器生成带有类型信息的元数据语义不同。尽管这是一个重要的细节，但它对我们使用框架的依赖注入机制或特定的
    `@Injectable` 装饰器方式没有任何影响。
- en: As a rule of thumb, always use the `@Injectable` decorator when a given class
    accepts dependencies that need to be injected with the dependency injection mechanism
    of Angular.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，当给定的类接受需要通过 Angular 的依赖注入机制注入的依赖项时，始终使用 `@Injectable` 装饰器。
- en: Introducing forward references
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入前向引用
- en: 'Angular introduced the concept of **forward references**. It is required because
    of the following reasons:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 引入了**前向引用**的概念。这是由于以下原因所必需的：
- en: ES2015 classes are not hoisted
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES2015 类不会被提升
- en: Allowing resolution of the dependencies that are declared after the declaration
    of the dependent providers
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许在声明依赖提供者之后解决声明的依赖项
- en: In this section, we will explain the problem that forward references solve and
    the way we can take advantage of them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释前向引用解决的问题以及我们如何利用它们。
- en: 'Now, let''s suppose that we have defined the `Buffer` and `Socket` classes
    in the opposite order:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们以相反的顺序定义了 `Buffer` 和 `Socket` 类：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we have the exact same dependencies as the ones in the previous example;
    however, in this case, the `Socket` class definition precedes the definition of
    the `Buffer` class. Note that the value of the `Buffer` identifier will equal
    `undefined` before the declaration of the `Buffer` class. This means that, during
    the interpretation of the generated JavaScript, the value of the `Buffer` identifier
    will equal `undefined`: that is, as the token of the dependency, the framework
    will get an invalid value.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们具有与上一个示例中完全相同的依赖项；然而，在这种情况下，`Socket` 类的定义先于 `Buffer` 类的定义。请注意，在 `Buffer`
    类声明之前，`Buffer` 标识符的值将是 `undefined`。这意味着在生成的 JavaScript 代码的解释过程中，`Buffer` 标识符的值将是
    `undefined`：也就是说，作为依赖项的标记，框架将获得一个无效的值。
- en: 'Running the preceding snippet will result in a runtime error of the following
    form:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码片段将导致以下形式的运行时错误：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The best way to resolve this issue is by swapping the definitions with their
    proper order. Another way we can proceed is to take advantage of a solution that
    Angular provides: a forward reference:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最佳方式是通过交换定义以正确的顺序。我们还可以利用 Angular 提供的解决方案：前向引用：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The previous snippet demonstrates how we can take advantage of forward references.
    All we need to do is to invoke the `@Inject` parameter decorator with argument
    as the result of the invocation of the `forwardRef` function. The `forwardRef`
    function is a higher-order function that accepts a single argument: another function
    that is responsible for returning the token associated with the dependency (or
    more precisely associated with its provider) that needs to be injected. This way,
    the framework provides a way to defer the process of resolving the types (tokens)
    of dependencies.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段展示了我们如何利用前向引用。我们只需要使用 `@Inject` 参数装饰器，并将 `forwardRef` 函数的调用结果作为参数。`forwardRef`
    函数是一个高阶函数，它接受一个参数：另一个函数，该函数负责返回需要注入的依赖项（或更精确地说，与其提供者关联的依赖项）的标记。这样，框架提供了一种延迟解决依赖项（标记）类型的过程的方法。
- en: The token of the dependency will be resolved the first time `Socket` needs to
    be instantiated, unlike the default behavior in which the token is required at
    the time of the declaration of the given class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项的标记将在 `Socket` 需要实例化的第一次被解决，这与默认行为不同，在默认行为中，标记在给定类的声明时就需要。
- en: Configuring providers
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置提供者
- en: 'Now, let''s take a look at an example similar to the one used earlier, but
    with a syntactically different configuration of the injector:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个与之前使用的示例类似，但具有不同语法配置的注入器示例：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, inside the provider, we explicitly declared that we want the `Buffer`
    class to be used for the construction of the dependency with a token equal to
    the reference of the `Buffer` identifier. We do the exact same thing for the dependency
    associated with the `Socket` token; however, this time, we provided the `Socket`
    class instead. This is how Angular will proceed when we omit the explicit provider
    declaration and pass only a reference to a class instead.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在提供者内部，我们明确声明我们希望使用`Buffer`类来构建与`Buffer`标识符引用相等的令牌的依赖项。我们为与`Socket`令牌关联的依赖项做完全相同的事情；然而，这次我们提供了`Socket`类。这就是Angular在我们省略显式提供者声明并仅传递类引用时将如何操作。
- en: Explicitly declaring the class used for the creation of an instance of the same
    class may seem quite worthless, and given the examples we have looked at so far,
    that'd be completely correct. In some cases, however, we might want to provide
    a different class for the instantiation of a dependency associated with a given
    token.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 明确声明用于创建同一类实例的类可能看起来毫无价值，并且鉴于我们迄今为止看到的示例，这将是完全正确的。然而，在某些情况下，我们可能希望为与给定令牌关联的依赖项的实例化提供不同的类。
- en: 'For example, let''s suppose we have the `Http` service that is used in a service
    called `UserService`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个在名为`UserService`的服务中使用的`Http`服务：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now let's trace the process of instantiation of the `UserService` service, in
    case we want to inject it somewhere in our application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们追踪`UserService`服务实例化的过程，以防我们想在应用程序的某个地方注入它。
- en: 'Internally, Angular will create an injector based on the providers passed to
    `@NgModule`: this is the injector that Angular will use to instantiate the `UserService`
    service. Initially, the provider will find out that `UserService` service accepts
    a dependency with the `Http` token, so the provider will try to find the provider
    associated with this token. Since there''s such a provider in the same injector,
    it''ll create an instance of the `Http` service and pass it to `UserService`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，Angular将根据传递给`@NgModule`的提供者创建一个注入器：这就是Angular将用于实例化`UserService`服务的注入器。最初，提供者会发现`UserService`服务接受一个带有`Http`令牌的依赖项，因此提供者会尝试找到与该令牌关联的提供者。由于在同一注入器中存在这样的提供者，它将创建一个`Http`服务的实例并将其传递给`UserService`。
- en: 'So far so good; however, if we want to test `UserService` service, we don''t
    really need to make HTTP calls through the network. In the case of unit testing,
    we can provide a dummy implementation that will only fake these HTTP calls. In
    order to inject an instance of a different class to the `UserService` service,
    we can change the configuration of the provider to the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利；然而，如果我们想测试`UserService`服务，我们实际上并不需要通过网络进行HTTP调用。在单元测试的情况下，我们可以提供一个模拟实现，它只会伪造这些HTTP调用。为了向`UserService`服务注入不同类的实例，我们可以将提供者的配置更改如下：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, Angular will again create an injector based on the providers pass
    to `@NgModule`. The difference this time is that with the `Http` token we have
    associated the `DummyHttp` service. Now when the injector instantiates the `UserService`,
    it'll look for providers associated with the `Http` token inside of the list of
    providers it maintains, and find out that it needs to use the `DummyHttp` service
    for creating the required dependency. When Angular finds that we've declared a
    `useClass` provider, it'll create an instance of the `DummyHttp` service with
    `new DummyHttp()`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Angular将再次根据传递给`@NgModule`的提供者创建一个注入器。这次的不同之处在于，我们用`DummyHttp`服务关联了`Http`令牌。现在当注入器实例化`UserService`时，它会在它维护的提供者列表中寻找与`Http`令牌关联的提供者，并发现它需要使用`DummyHttp`服务来创建所需的依赖项。当Angular发现我们已声明一个`useClass`提供者时，它将使用`new
    DummyHttp()`创建`DummyHttp`服务的实例。
- en: This code is available at `ch6/configuring-providers/dummy-http/app.ts`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码位于`ch6/configuring-providers/dummy-http/app.ts`。
- en: Using existing providers
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用现有提供者
- en: 'Another way to proceed is using the `useExisting` property of the provider''s
    configuration object:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种进行的方式是使用提供者配置对象的`useExisting`属性：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding snippet, we register providers for three tokens: `DummyHttp`,
    `UserService`, and `Http`. We declare that we want to bind the `Http` token to
    the existing token, `DummyHttp`. This means that, when the `Http` service is requested,
    the injector will find the provider for the token used as the value of the `useExisting`
    property and instantiate it or get the value associated with it (in case it was
    already instantiated). We can think of `useExisting` as creating an alias of the
    given token:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们为三个令牌注册了提供者：`DummyHttp`、`UserService`和`Http`。我们声明我们想要将`Http`令牌绑定到现有的令牌`DummyHttp`。这意味着当请求`Http`服务时，注入器将找到用作`useExisting`属性值的令牌的提供者，并实例化它或获取与之关联的值（如果它已经被实例化）。我们可以将`useExisting`视为创建给定令牌的别名：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding snippet will create an alias of the `Http` token to the `DummyHttp`
    token. This means that once the `Http` token is requested, the call will be forwarded
    to the provider associated with the `DummyHttp` token, which will be resolved
    to the value of `dummyHttp`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上述片段将创建`Http`令牌到`DummyHttp`令牌的别名。这意味着一旦请求`Http`令牌，调用将被转发到与`DummyHttp`令牌关联的提供者，它将被解析为`dummyHttp`的值。
- en: The `useValue` provider returns the value set to the `useValue` property of
    the provider's declaration.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`useValue`提供者返回设置到提供者声明中`useValue`属性的值。'
- en: Defining factories for instantiating services
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义用于实例化服务的工厂
- en: Now, let's suppose that we want to create a complex object, for example, one
    that represents a **Transport Layer Security** (**TLS**) connection. A few of
    the properties of such an object are a socket, a set of crypto protocols, and
    a certificate. In the context of this problem, the features of the DI mechanism
    of Angular we have looked at so far might seem a bit limited.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要创建一个复杂对象，例如，一个代表**传输层安全性**（**TLS**）连接的对象。此类对象的一些属性包括套接字、一组加密协议和证书。在这个问题的背景下，我们迄今为止所查看的Angular的DI机制的功能可能看起来有点有限。
- en: For example, we might need to configure some of the properties of the `TLSConnection`
    class without coupling the process of its instantiation with all the configuration
    details (choose appropriate crypto algorithms, open the TCP socket over which
    we will establish the secure connection, and so on).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能需要配置`TLSConnection`类的一些属性，而不将其实例化过程与所有配置细节耦合（选择合适的加密算法、打开我们将通过它建立安全连接的TCP套接字等）。
- en: 'In this case, we can take advantage of the `useFactory` property of the provider''s
    configuration object:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以利用提供者配置对象的`useFactory`属性：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding snippet seems a bit complex at first, but let''s take a look
    at it step by step. We can start with the parts we''re already familiar with:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的片段看起来可能有点复杂，但让我们一步一步地来看。我们可以从我们已经熟悉的部分开始：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Initially, we register a number of providers: `Buffer`, `Socket`, `Certificate`,
    and `Crypto`. Just like in the previous example, we also register the `BUFFER_SIZE`
    token and associated it with the value `42`. This means that we can already inject
    dependencies of the `Buffer`, `Socket`, `Certificate`, and `Crypto` types in the
    constructors of the classes in our application.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们注册了多个提供者：`Buffer`、`Socket`、`Certificate`和`Crypto`。就像在之前的例子中一样，我们也注册了`BUFFER_SIZE`令牌并将其关联到值`42`。这意味着我们已经在我们的应用程序中类的构造函数中注入了`Buffer`、`Socket`、`Certificate`和`Crypto`类型的依赖项。
- en: 'We can create and configure an instance of the `TLSConnection` object in the
    following way:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式创建和配置`TLSConnection`对象的一个实例：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, in order to allow Angular to use the previous snippet for the instantiation
    of `TLSConnection`, we can use the `useFactory` property of the provider's configuration
    object. This way, we can specify a function in which we can manually create the
    instance of the object associated with the provider's token.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了允许Angular使用前面的片段来实例化`TLSConnection`，我们可以使用提供者配置对象的`useFactory`属性。这样，我们可以指定一个函数，在其中我们可以手动创建与提供者令牌关联的对象的实例。
- en: 'We can use the `useFactory` property together with the `deps` property in order
    to specify the dependencies to be passed to the factory:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`useFactory`属性与`deps`属性一起指定要传递给工厂的依赖项：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding snippet, we define the factory function used for the instantiation
    of `TLSConnection`. As dependencies, we declare `Socket`, `Certificate`, and `Crypto`.
    These dependencies are resolved by the DI mechanism of Angular and injected into
    the factory function. You can take a look at the entire implementation and play
    with it at `ch6/configuring-providers/factory/app.ts`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了用于 `TLSConnection` 实例化的工厂函数。作为依赖项，我们声明了 `Socket`、`Certificate`
    和 `Crypto`。这些依赖项由 Angular 的 DI 机制解析并注入到工厂函数中。您可以查看整个实现并在 `ch6/configuring-providers/factory/app.ts`
    中尝试它。
- en: Interesting to note is that, internally, Angular translates the `useClass` providers
    to `useFactory`. Angular lists the dependencies of the class in the `deps` array
    and invokes the class with the `new` operator, passing its dependencies received
    as arguments of the factory.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，内部，Angular 将 `useClass` 提供者转换为 `useFactory`。Angular 在 `deps` 数组中列出类的依赖项，并使用
    `new` 操作符调用该类，将工厂接收到的依赖项作为参数传递。
- en: Declaring optional dependencies
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明可选依赖项
- en: Angular introduced the `@Optional` decorator, which allows us to deal with dependencies
    that don't have a registered provider associated with them. Let's suppose that
    a dependency of a provider is not available in any of the target injectors responsible
    for its instantiation. If we use the `@Optional` decorator, during the instantiation
    of the dependent provider a value of the missing dependency will be passed as `null`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 引入了 `@Optional` 装饰器，它允许我们处理没有与它们关联已注册提供者的依赖项。假设一个提供者的依赖项在任何负责其实例化的目标注入器中都不可用。如果我们使用
    `@Optional` 装饰器，在依赖提供者的实例化过程中，缺失的依赖项的值将被传递为 `null`。
- en: 'Now, let''s take a look at the following example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下以下示例：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, we define an abstract class called `SortingAlgorithm` and a class
    called `Collection`, which as dependency accepts an instance of a concrete class
    that extends `SortingAlgorithm`. Inside the `Collection` constructor, we set the
    `sort` instance property to the passed dependency or to a default sorting algorithm
    implementation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们定义了一个名为 `SortingAlgorithm` 的抽象类和一个名为 `Collection` 的类，它作为依赖项接受一个扩展 `SortingAlgorithm`
    的具体类的实例。在 `Collection` 构造函数内部，我们将 `sort` 实例属性设置为传递的依赖项或默认排序算法实现。
- en: We didn't define any providers for the `SortingAlgorithm` token in the providers
    of `@NgModule` we declared. So, if we want to inject an instance of the `Collection`
    class in the `AppComponent`, we'll get a runtime error. This means that if we
    want to get an instance of the `Collection` class using the DI mechanism of the
    framework, we must register a provider for the `SortingAlgorithm` token, although
    we may want to fall back to a default sorting algorithm, returned by the `getDefaultSort`
    method.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在声明的 `@NgModule` 提供者中没有为 `SortingAlgorithm` 标记定义任何提供者。因此，如果我们想在 `AppComponent`
    中注入 `Collection` 类的实例，我们将得到一个运行时错误。这意味着，如果我们想使用框架的 DI 机制获取 `Collection` 类的实例，我们必须为
    `SortingAlgorithm` 标记注册一个提供者，尽管我们可能希望回退到由 `getDefaultSort` 方法返回的默认排序算法。
- en: 'Angular provides a solution to this problem with the `@Optional` decorator.
    This is how we can approach the problem using it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 通过 `@Optional` 装饰器提供了这个问题的解决方案。以下是我们可以如何使用它来解决这个问题：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding snippet, we declare the `sort` dependency as optional, which
    means that if Angular doesn't find any provider for its token, it will pass the
    `null` value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将 `sort` 依赖项声明为可选的，这意味着如果 Angular 没有找到任何为其标记提供提供者的，它将传递 `null` 值。
- en: Understanding multiproviders
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解多提供者
- en: Multiproviders is another new concept introduced to the DI mechanism of Angular.
    They allow us to associate multiple providers with the same token. This can be
    quite useful if we're developing a third-party library that comes with some default
    implementations of different services, but you want to allow the users to extend
    it with custom ones. For instance, in the Angular's form module, multiproviders
    are exclusively used to declare multiple validations over a single control. We
    will explain this module in [Chapter 7](0880a64a-a64d-41a9-9ffd-7b2d55270110.xhtml),
    *Working with the Angular Router and Forms*, and [Chapter 8](503e1c1c-afb1-4dd4-98e2-657ceb32cc59.xhtml),
    *Explaining Pipes and Communicating with RESTful Services*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 多提供者（Multiproviders）是 Angular 依赖注入（DI）机制中引入的另一个新概念。它们允许我们将多个提供者与同一个令牌关联起来。如果我们正在开发一个带有一些默认服务实现的第三方库，但希望用户能够用自定义实现来扩展它，这将非常有用。例如，在
    Angular 的表单模块中，多提供者专门用于对单个控件声明多个验证。我们将在 [第 7 章](0880a64a-a64d-41a9-9ffd-7b2d55270110.xhtml)，*使用
    Angular 路由和表单*，和 [第 8 章](503e1c1c-afb1-4dd4-98e2-657ceb32cc59.xhtml)，*解释管道和与 RESTful
    服务通信*中解释这个模块。
- en: Another sample of an applicable use case of multiproviders is what Angular uses
    for event management in its web workers implementation. Users create multiproviders
    for event management plugins. Each of the providers return a different strategy,
    which supports a different set of events (touch events, keyboard events, and so
    on). Once a given event occurs, Angular can choose the appropriate plugin that
    handles it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 多提供者的另一个适用用例示例是 Angular 在其 Web Workers 实现中用于事件管理。用户为事件管理插件创建多提供者。每个提供者返回不同的策略，支持不同的事件集（触摸事件、键盘事件等）。一旦发生特定事件，Angular
    可以选择处理该事件的适当插件。
- en: 'Let''s take a look at an example that illustrates a typical usage of multiproviders:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例，它说明了多提供者（multiproviders）的典型用法：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding snippet, we declare a constant called `VALIDATOR` and as its
    value, we set a new instance of `InjectionToken`. We also create `@NgModule` where
    we register three providers: two of them provide functions that, based on different
    criteria, validate instances of the `Employee` class. These functions are of the
    `EmployeeValidator` type.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了一个名为 `VALIDATOR` 的常量，并将其值设置为 `InjectionToken` 的新实例。我们还创建了一个 `@NgModule`，在其中注册了三个提供者：其中两个提供者提供基于不同标准的函数，这些函数用于验证
    `Employee` 类的实例。这些函数的类型是 `EmployeeValidator`。
- en: 'In order to declare that we want the injector to pass all the registered validators
    to the constructor of the `Employee` class, we need to use the following `constructor`
    definition:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了声明我们希望注入器将所有注册的验证器传递给 `Employee` 类的构造函数，我们需要使用以下 `constructor` 定义：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the example, we declare a `Employee` class that accepts a single dependency:
    an array of `EmployeeValidator`. In the `validate` method, we apply the individual
    validators over the current class instance and filter the results in order to
    get only the ones that have returned an error message.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们声明了一个 `Employee` 类，它接受单个依赖项：一个 `EmployeeValidator` 数组。在 `validate` 方法中，我们对当前类实例应用单个验证器，并过滤结果以仅获取返回错误消息的验证器。
- en: Note that the `validators` constructor argument is of the `EmployeeValidator[]`
    type. Since we can't use the *array of objects* type as a token for a provider,
    because it is not a valid value in JavaScript and can't be used as a token, we
    will need to use the `@Inject` parameter decorator.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`validators` 构造函数参数的类型是 `EmployeeValidator[]`。由于我们不能使用 *对象数组* 类型作为提供者的令牌，因为它在
    JavaScript 中不是一个有效的值，也不能用作令牌，因此我们需要使用 `@Inject` 参数装饰器。
- en: 'Later, we can inject an instance of the `Employee` type as usual:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以像往常一样注入 `Employee` 类型的实例：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Child injectors and visibility
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子注入器和可见性
- en: In this section, we will take a look at how we can build a hierarchy of injectors.
    There's no alternative to this concept in AngularJS. Each injector can have either
    zero or one parent injectors, and each parent injector can have one or more children.
    In contrast to AngularJS, where all the registered providers are stored in a flat
    structure, in Angular they are stored in a tree. The flat structure is more limited;
    for instance, it doesn't support the namespacing of tokens; we cannot declare
    different providers for the same token. So far, we looked at an example of an
    injector that doesn't have any children or a parent. Now, let's build a hierarchy
    of injectors.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何构建注入器的层次结构。在 AngularJS 中，这个概念没有替代方案。每个注入器可以有零个或一个父注入器，每个父注入器可以有一个或多个子注入器。与
    AngularJS 中所有注册的提供者都存储在扁平结构中不同，在 Angular 中它们存储在树形结构中。扁平结构更为有限；例如，它不支持令牌的命名空间；我们不能为相同的令牌声明不同的提供者。到目前为止，我们已经看到了一个没有子注入器或父注入器的注入器示例。现在，让我们构建一个注入器的层次结构。
- en: 'In order to gain a better understanding of this hierarchical structure of injectors,
    let''s take a look at the following diagram:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解注入器的这种分层结构，让我们看一下下面的图示：
- en: '![](img/863d4bb1-1b86-4fa5-b44d-798f056b7c93.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图示](img/863d4bb1-1b86-4fa5-b44d-798f056b7c93.png)'
- en: Figure 2
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图2
- en: 'Here, we see a tree where each node is an injector, and each of these injectors
    keeps a reference to its parent. The `House` injector has three child injectors:
    `Bathroom`, `Kitchen`, and `Garage`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到一个树，每个节点都是一个注入器，这些注入器都保留对其父注入器的引用。`House` 注入器有三个子注入器：`Bathroom`、`Kitchen`
    和 `Garage`。
- en: '`Garage` has two child injectors: `Car` and `Storage`. We can think of these
    injectors as containers with registered providers inside of them.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Garage` 有两个子注入器：`Car` 和 `Storage`。我们可以将这些注入器视为内部注册了提供者的容器。'
- en: Let's suppose that we want to get the value of the provider associated with
    the `Tire` token. If we use the `Car` injector, this means that Angular's DI mechanism
    will try to find the provider associated with this token in `Car` and all of its
    parents, `Garage` and `House`, until it reaches the root injector.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要获取与 `Tire` 令牌关联的提供者的值。如果我们使用 `Car` 注入器，这意味着 Angular 的依赖注入机制将尝试在 `Car`
    以及其所有父注入器 `Garage` 和 `House` 中找到与该令牌关联的提供者，直到达到根注入器。
- en: Instantiating an injector
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化注入器
- en: Internally, Angular builds this hierarchy of injectors, but everything happens
    implicitly. In order to do this ourselves, we'll have to use lower level APIs
    which will be unusual for our day-to-day development process.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，Angular 构建了这个注入器的层次结构，但所有操作都是隐式的。为了我们自己实现这一点，我们将不得不使用较低级别的 API，这对于我们的日常开发过程来说是不寻常的。
- en: 'First, let''s create an instance of an injector, in order to use it for the
    instantiation of registered tokens:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个注入器的实例，以便使用它来实例化注册的令牌：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, first we import `Injector` from `@angular/core`. This abstraction has
    a static method called `create`, which is used for instantiation of injectors.
    Inside of the `create` method, we pass as argument an array of providers. We can
    see syntax that we're already familiar with from the *Configuring providers* section.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先从 `@angular/core` 中导入 `Injector`。这个抽象类有一个名为 `create` 的静态方法，用于注入器的实例化。在
    `create` 方法内部，我们传递一个提供者数组作为参数。我们可以看到从 *配置提供者* 部分已经熟悉的语法。
- en: We declare a provider for `BUFFER_SIZE` to use the value `42`; we declare a
    factory for `Buffer` and list all of its dependencies (in this case, only `BUFFER_SIZE`);
    finally, we declare a factory provider for `Socket` as well. The `create` method
    is going to create an instance of `StaticInjector`, which we can use to get instances
    for the individual `tokens`. As a reminder, the **injector** is the abstraction
    which contains the individual providers and knows how to instantiate the dependencies
    associated with them.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个提供者用于 `BUFFER_SIZE`，使用值 `42`；我们声明一个 `Buffer` 的工厂，并列出其所有依赖项（在这种情况下，只有 `BUFFER_SIZE`）；最后，我们还声明了一个
    `Socket` 的工厂提供者。`create` 方法将创建一个 `StaticInjector` 的实例，我们可以使用它来获取单个 `tokens` 的实例。提醒一下，**注入器**是包含单个提供者的抽象，并且知道如何实例化与它们关联的依赖项。
- en: An important detail in the preceding example is that in `StaticInjector`, we
    can use only a limited types of providers, for instance, we can't use the `useClass`
    provider. This is due to the fact that Angular uses `StaticInjector` with the
    normalized version of the providers, and the normalized version of `useClass`
    is `useFactory`. Internally, Angular will collect the providers passed to `@NgModule`,
    transform them to their normalized version, and instantiate `StaticInjector`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，一个重要的细节是，在`StaticInjector`中，我们只能使用有限类型的提供者，例如，我们不能使用`useClass`提供者。这是因为Angular使用`StaticInjector`与提供者的标准化版本一起使用，而`useClass`的标准化版本是`useFactory`。内部，Angular会收集传递给`@NgModule`的提供者，将它们转换为它们的标准化版本，并实例化`StaticInjector`。
- en: Building a hierarchy of injectors
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建注入器层次结构
- en: 'In order to gain a better understanding of the paragraph, let''s take a look
    at this simple example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解段落，让我们看看这个简单的例子：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The imports are omitted since they are not essential to explaining the code.
    We have two services, `Http` and `UserService`, where `UserService` depends on
    the `Http` service.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 省略了导入，因为它们对于解释代码不是必需的。我们有两个服务，`Http`和`UserService`，其中`UserService`依赖于`Http`服务。
- en: 'Initially, we create an injector using the `create` static method of the `Injector`
    class. We pass a factory provider to this injector, with an `Http` token. Later,
    again using `create`, we instantiate the child injector by passing an array that
    contains the provider for `UserService`. Notice that as second argument, we pass
    the `parentInjector` constant, so, we get the same relation as the one between
    `Garage` and `House`, shown in the previous diagram: `parentInjector` is the parent
    of `childInjector`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们使用`Injector`类的`create`静态方法创建一个注入器。我们向这个注入器传递一个带有`Http`令牌的工厂提供者。稍后，再次使用`create`，我们通过传递包含`UserService`提供者的数组来实例化子注入器。请注意，作为第二个参数，我们传递了`parentInjector`常量，因此我们得到了与前面图中`Garage`和`House`之间相同的关系：`parentInjector`是`childInjector`的父级。
- en: Now, using `childInjector.get(UserService)`, we are able to get the value associated
    with the `UserService` token. Similarly, using `childInjector.get(Http)` and `parentInjector.get(Http)`,
    we get the same value associated with the `Http` token. This means that `childInjector`
    asks its parent for the value associated with the requested token.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`childInjector.get(UserService)`，我们能够获取与`UserService`令牌关联的值。同样，使用`childInjector.get(Http)`和`parentInjector.get(Http)`，我们获取与`Http`令牌关联的相同值。这意味着`childInjector`会向其父级请求请求令牌关联的值。
- en: However, if we try to use `parentInjector.get(UserService)`, we won't be able
    to get the value associated with the token since its provider is registered in
    `childInjector`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试使用`parentInjector.get(UserService)`，由于它的提供者在`childInjector`中注册，我们将无法获取与令牌关联的值。
- en: Using dependency injection with components and directives
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件和指令进行依赖注入
- en: In [Chapter 5](1b60c28e-5f34-493d-8371-c69968f09020.xhtml), *Getting Started
    with Angular Components and Directives*, when we developed our first Angular directive,
    we saw how we can take advantage of the DI mechanism to inject services into our
    UI-related building blocks (that is, directives and components).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](1b60c28e-5f34-493d-8371-c69968f09020.xhtml)“使用Angular组件和指令入门”中，当我们开发我们的第一个Angular指令时，我们看到了如何利用DI机制将服务注入到我们的UI相关构建块（即指令和组件）中。
- en: 'Let''s take a quick look at what we did earlier, but from a DI perspective:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下我们之前做了什么，但从一个DI的角度来看：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Most of the code from the earlier implementation is omitted because it is not
    directly related to our current focus.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分早期实现中的代码都被省略了，因为它与我们当前的关注点没有直接关系。
- en: 'Note that the constructor of `Tooltip` accepts two dependencies:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Tooltip`的构造函数接受两个依赖项：
- en: An instance of the `ElementRef` class
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ElementRef`类的实例'
- en: An instance of the `Overlay` class
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Overlay`类的实例'
- en: The types of dependencies are the tokens associated with their providers and
    the corresponding values obtained from the providers will be injected with the
    DI mechanism of Angular.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项的类型是与它们的提供者关联的令牌，以及从提供者获得的相应值将通过Angular的DI机制注入。
- en: 'The declaration of the dependencies of the `Tooltip` class looks exactly the
    same as what we did in the previous sections: we''re just listing them as parameters
    of the constructor of the class. However, note that in this case, we don''t have
    any explicit provider declaration for the `ElementRef` token, we only have a provider
    for the `Overlay` token, declared within the metadata of the `App` component.
    In this case, Angular internally creates and configures the so called **element
    injector**.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tooltip` 类的依赖声明与我们在前面的章节中所做的一样：我们只是将它们作为类的构造函数的参数列出。然而，请注意，在这种情况下，我们没有为 `ElementRef`
    标记进行任何显式的提供者声明，我们只有一个为 `Overlay` 标记的提供者，它在 `App` 组件的元数据中声明。在这种情况下，Angular 内部创建并配置了所谓的
    **元素注入器**。'
- en: Introducing the element injectors
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍元素注入器
- en: 'Under the hood, Angular will create injectors for all the directives and components,
    and add a default set of providers to them. These are the so called **element
    injectors** and are something the framework takes care of itself. The injectors
    associated with the components are called **host injectors**. One of the providers
    in each element injector is associated with the `ElementRef` token; it will return
    a reference to the host element of the directive. But what about the provider
    for the `Overlay` class? Let''s take a look at the implementation of the top-level
    component:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，Angular 将为所有指令和组件创建注入器，并向它们添加一组默认的提供者。这些被称为 **元素注入器**，并且是框架自己负责处理的事情。与组件关联的注入器被称为
    **宿主注入器**。每个元素注入器中的一个提供者与 `ElementRef` 标记相关联；它将返回指令的主元素引用。那么 `Overlay` 类的提供者怎么办？让我们看看顶级组件的实现：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We configure the element injector for the `App` component by declaring the `providers`
    property inside the `@Component` decorator. At this point, the registered providers
    will be visible by the directive or the component associated with the corresponding
    element injector and the component's entire component subtree, unless they are
    overridden somewhere in the hierarchy.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 `@Component` 装饰器内部声明 `providers` 属性来配置 `App` 组件的元素注入器。在这个时候，注册的提供者将对与相应元素注入器关联的指令或组件以及组件的整个组件子树可见，除非它们在层次结构中的某个地方被覆盖。
- en: Declaring providers for the element injectors
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明元素注入器的提供者
- en: Having the declaration of all the providers in the same place might be quite
    inconvenient. For example, imagine we're developing a large-scale application
    that has hundreds of components depending on thousands of services. In this case,
    configuring all the providers in the root component is not a practical solution.
    There will be name collisions when two or more providers are associated with the
    same token. The configuration will be huge, and it will be hard to trace where
    the different dependencies need to be injected.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有提供者的声明放在同一个地方可能相当不方便。例如，想象一下我们正在开发一个大型应用程序，该应用程序有数百个组件依赖于数千个服务。在这种情况下，在根组件中配置所有提供者不是一个实际的解决方案。当两个或多个提供者与同一个标记相关联时，将发生名称冲突。配置将非常庞大，并且很难追踪不同的依赖项需要注入的位置。
- en: 'As we mentioned, Angular''s `@Directive` (and `@Component`) decorator allows
    us to declare a set of providers for the element injector corresponding to a given
    directive using the `providers` property. Here is how we can approach this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所提到的，Angular 的 `@Directive`（和 `@Component`）装饰器允许我们使用 `providers` 属性为给定指令对应的元素注入器声明一组提供者。以下是我们可以采取的方法：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding example overrides the provider for the `Overlay` token in the
    declaration of the `Tooltip` directive. This way, Angular will inject an instance
    of `OverlayMock` instead of `Overlay` during the instantiation of the tooltip.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例在 `Tooltip` 指令的声明中覆盖了 `Overlay` 标记的提供者。这样，Angular 将在提示框实例化期间注入 `OverlayMock`
    实例而不是 `Overlay`。
- en: Exploring dependency injection with components
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索组件中的依赖注入
- en: Since components are generally directives with templates, everything we've seen
    so far regarding how the DI mechanism works with directives is valid for components
    as well. However, because of the extra features that the components provide, we're
    allowed to have further control over their providers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于组件通常是带有模板的指令，因此到目前为止我们所看到的所有关于 DI 机制如何与指令一起工作的内容也适用于组件。然而，由于组件提供的额外功能，我们允许对它们的提供者有更多的控制。
- en: As we said, the injector associated with each component will be marked as a
    **host** injector. There's a parameter decorator called `@Host`, which allows
    us to retrieve a given dependency from any injector until it reaches the closest
    host injector. This means that, using the `@Host` decorator in a directive, we
    can declare that we want to retrieve the given dependency from the current injector
    or any parent injector until we reach the injector of the closest parent component.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，与每个组件关联的注入器将被标记为**宿主**注入器。有一个名为`@Host`的参数装饰器，它允许我们从任何注入器中检索给定的依赖项，直到它达到最近的宿主注入器。这意味着，在指令中使用`@Host`装饰器，我们可以声明我们想要从当前注入器或任何父注入器中检索给定的依赖项，直到我们达到最近父组件的注入器。
- en: On top of that, the Angular's API allows us to be even more specific regarding
    the visibility of the providers in the component tree using the `viewProviders`
    property, part of the configuration object of the `@Component` decorator.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Angular的API允许我们通过`viewProviders`属性，它是`@Component`装饰器的配置对象的一部分，在组件树中更具体地指定提供者的可见性。
- en: View providers versus providers
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图提供者与提供者
- en: 'Let''s take a look at an example of a component called `MarkdownPanel`. This
    component will be used in the following way:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个名为`MarkdownPanel`的组件的例子。这个组件将被以下方式使用：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The content of each section of the panel will be translated from markdown to
    HTML. We can delegate this functionality to a service called `Markdown`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 面板每个部分的内文将是从Markdown转换为HTML。我们可以将此功能委托给一个名为`Markdown`的服务：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `Markdown` service wraps the `markdown` module in order to make it injectable
    through the DI mechanism.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Markdown`服务将`markdown`模块包装起来，以便通过DI机制进行注入。'
- en: Now let's implement `MarkdownPanel`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现`MarkdownPanel`。
- en: 'In the following snippet, we can find all the important details from the implementation
    of the component:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们可以找到组件实现的所有重要细节：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the `@Component` decorator, we use the `markdown-panel` selector and set
    the `viewProviders` property. In this case, there''s only a single view provider:
    the one for the `Markdown` service. By setting this property, we declare that
    all the providers declared in it will be accessible from the component itself
    and all of its **view children**.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在`@Component`装饰器中，我们使用`markdown-panel`选择器并设置`viewProviders`属性。在这种情况下，只有一个视图提供者：为`Markdown`服务提供的那个。通过设置此属性，我们声明其中声明的所有提供者都将从组件本身及其所有**视图子项**中可访问。
- en: 'Now, let''s suppose we have a component called `MarkdownButton`, and we want
    to add it to our template in the following way:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有一个名为`MarkdownButton`的组件，并且我们想以下这种方式将其添加到我们的模板中：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `Markdown` service will not be accessible by `MarkdownButton` used below
    the `panel-content` element; however, it''ll be accessible if we use the button
    in the template of the component:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`Markdown`服务将无法通过位于`panel-content`元素下方的`MarkdownButton`访问；然而，如果我们使用组件模板中的按钮，它将是可访问的：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If we need the provider to be visible in all the content and view children,
    all we should do is change the name of the `viewProviders` property to `providers`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要提供者在所有内容和视图子项中可见，我们只需将`viewProviders`属性的名称更改为`providers`即可。
- en: You can find this example in the examples directory at `ch6/directives/app.ts`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`ch6/directives/app.ts`目录下的示例目录中找到这个例子。
- en: Note that, for any component or directive, we can override an existing provider
    declared in `@NgModule` using the `providers` properties of the object literal
    we pass to the `@Component` or `@Directive` decorators. If we want to override
    a specific provider only for the view children of a given component, we can use
    `viewProviders`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于任何组件或指令，我们可以使用传递给`@Component`或`@Directive`装饰器的对象字面量的`providers`属性来覆盖在`@NgModule`中声明的现有提供者。如果我们只想为给定组件的视图子项覆盖特定的提供者，我们可以使用`viewProviders`。
- en: Using the @SkipSelf decorator
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`@SkipSelf`装饰器
- en: 'There are cases when in an hierarchy, we have defined providers for the same
    token in different injectors. For instance, let''s suppose that we have the preceding
    example, but with the following injector configuration:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候在层次结构中，我们在不同的注入器中为相同的令牌定义了提供者。例如，假设我们有前面的示例，但具有以下注入器配置：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding example, in case we try to inject the `Markdown` service in
    the constructor of `MarkdownPanel`, we'll get `null`, because that's the value
    associated with the `Markdown` token in the `viewProviders` declaration in the
    metadata of the component.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，如果我们尝试在`MarkdownPanel`的构造函数中注入`Markdown`服务，我们会得到`null`，因为这是与组件元数据中`viewProviders`声明中的`Markdown`令牌关联的值。
- en: 'However, notice that in the `App` component, we have another declaration of
    providers, which will be used for the instantiation of `ElementInjector` of the
    `App` component. How can we use the `Markdown` provider declared in the metadata
    of `App` instead of the one declared in the metadata of `MarkdownPanel`? All we
    need to do is to add the `@SkipSelf()` decorator in the constructor of `MarkdownPanel`.
    This will hint Angular to skip the current injector and instead, look for the
    provider associated with the required token in the parent injector and above in
    the hierarchy:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，在`App`组件中，我们还有另一个提供者声明，它将被用于实例化`App`组件的`ElementInjector`。我们如何使用在`App`组件元数据中声明的`Markdown`提供者而不是在`MarkdownPanel`元数据中声明的提供者？我们只需要在`MarkdownPanel`的构造函数中添加`@SkipSelf()`装饰器。这将提示Angular跳过当前注入器，并在层次结构中向上查找与所需令牌关联的提供者：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Angular also provides the `@Self` decorator, which hints the framework to get
    the provider for a given token from the current injector. In that case, if Angular
    doesn't find the provider in the current injector, it'll throw an error.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Angular还提供了`@Self`装饰器，它向框架提示从当前注入器获取给定令牌的提供者。在这种情况下，如果Angular在当前注入器中找不到提供者，它将抛出一个错误。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the DI mechanism of Angular. We briefly discussed
    the positives of using DI in our projects by introducing it in the context of
    the framework. The second step in our journey was how to configure injectors using
    `@NgModule`; we also explained the hierarchy of injectors and the visibility of
    the registered providers. In order to enforce a better separation of concerns,
    we mentioned how we can inject services carrying the business logic of our application
    in our directives and components.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Angular的依赖注入（DI）机制。我们通过在框架的上下文中介绍它，简要讨论了在我们的项目中使用DI的优点。我们旅程的第二步是如何使用`@NgModule`配置注入器；我们还解释了注入器的层次结构和注册提供者的可见性。为了强制更好的关注点分离，我们提到了如何在我们的指令和组件中注入携带我们应用程序业务逻辑的服务。
- en: In the next chapter, we'll introduce the new routing mechanism of the framework.
    We'll explain how we can configure the component-based router and add multiple
    views to our application. Another important topic we will cover is the new form
    module. By building a simple application, we will demonstrate how we can create
    and manage forms.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍框架的新路由机制。我们将解释如何配置基于组件的路由器并将多个视图添加到我们的应用程序中。我们还将涵盖另一个重要主题，即新的表单模块。通过构建一个简单的应用程序，我们将演示如何创建和管理表单。
