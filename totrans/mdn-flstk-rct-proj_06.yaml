- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrating a Frontend Using React and TanStack Query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After designing, implementing, and testing our backend service, it’s now time
    to create a frontend to interface with the backend. First, we will start by setting
    up a full-stack React project based on the Vite boilerplate and the backend service
    created in the previous chapters. Then, we are going to create a basic user interface
    for our blog application. Finally, we will use TanStack Query, a data fetching
    library to handle backend state, to integrate the backend API into the frontend.
    By the end of this chapter, we will have successfully developed our first full-stack
    application!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Principles of React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a full-stack React project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the user interface for our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the backend service using TanStack Query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start, please install all requirements from [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016),
    *Preparing for Full-stack Development*, and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028),
    *Getting to Know Node.js* *and MongoDB*.
  prefs: []
  type: TYPE_NORMAL
- en: The versions listed in those chapters are the ones used in the book. While installing
    a newer version should not be an issue, please note that certain steps might work
    differently on a newer version. If you are having an issue with the code and steps
    provided in this book, please try using the versions mentioned in [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016)
    and *2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch4](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch4)'
  prefs: []
  type: TYPE_NORMAL
- en: If you cloned the full repository for the book, Husky may not find the `.git`
    directory when running `npm install`. In that case, just run `git init` in the
    root of the corresponding chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be found at: [https://youtu.be/WXqJu2Ut7Hs](https://youtu.be/WXqJu2Ut7Hs)'
  prefs: []
  type: TYPE_NORMAL
- en: Principles of React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start learning how to set up a full-stack React project, let’s revisit
    the three fundamental principles of React. These principles allow us to easily
    write scalable web applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declarative**: Instead of telling React how to do things, we tell it what
    we want it to do. As a result, we can easily design our applications and React
    will efficiently update and render just the right components when the data changes.
    For example, the following code, which duplicates strings in an array is imperative,
    which is the opposite of declarative:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we can see, in imperative code, we need to tell JavaScript exactly what
    to do, step by step. However, with declarative code, we can simply tell the computer
    what we want, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this declarative code, we tell the computer that we want to map each element
    of the `input` array from `str` to `str + str`. As you can see, declarative code
    is much more concise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Component-based**: React encapsulates components that manage their own state
    and views and then allows us to compose them in order to create complex user interfaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Learn once, write anywhere**: React does not make assumptions about your
    technology stack and tries to ensure that you can develop apps without rewriting
    existing code as much as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React’s three fundamental principles make it easy to write code, encapsulate
    components, and share code across multiple platforms. Instead of reinventing the
    wheel, React tries to make use of existing JavaScript features as much as possible.
    As a result, we will learn software design patterns that will be applicable in
    many more cases than just designing user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned the fundamental principles of React, let’s get started
    setting up a full-stack React project!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a full-stack React project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can start developing our frontend application, we first need to merge
    our previously created frontend boilerplate based on Vite with the backend service
    created in [*Chapter 3*](B19385_03_split_000.xhtml#_idTextAnchor050), *Implementing
    a Backend Using Express, Mongoose ODM, and Jest*. Let’s merge them now by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the **ch1** folder to a new **ch4** folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy the **ch3** folder to a new **ch4/backend** folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Delete* the **.git** folder in the copied **ch4/backend** folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the new **ch4** folder in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Remove* the Husky **prepare** script (the line is highlighted in the code
    snippet) from the **backend/package.json** file, as we already have Husky set
    up in the root directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also *remove* the following **lint-staged** config from the **backend/package.json**
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, *remove* the **backend/.husky**, **backend/.vscode**, and **backend/.git**
    folders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To make sure all dependencies are installed properly, run the following command
    in the root of the **ch4** folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also go to the **backend/** directory and install all dependencies there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now also remove the **husky**, **lint-staged**, and **@commitlint**
    packages from the backend project, as we already have it set up in the main project
    folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: It is always a good idea to regularly check which packages you still need and
    which you can get rid of, to keep your project clean. In this case, we copied
    code from another project, but do not need the Husky / lint-staged / commitlint
    setup, as we already have it set up in the root of our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now go back to the root of the **ch4** folder and run the following command
    to start the frontend server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the frontend in your browser by going to the URL shown by Vite: **http://localhost:5173/**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open **src/App.jsx**, change the title as follows, and save the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will see that the change is reflected instantly in the browser!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After successfully setting up our full-stack project by combining our projects
    from previous chapters, let’s now get started designing and creating the user
    interface for our blog application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user interface for our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When designing the structure of a frontend, we should also consider the folder
    structure, so that our app can grow easily in the future. Similar to how we did
    for the backend, we will also put all our source code into a `src/` folder. We
    can then group the files in separate folders for the different features. Another
    popular way to structure frontend projects is to group code by routes. Of course,
    it is also possible to mix them, for example, in Next.js projects we can group
    our components by features and then create another folder and file structure for
    the routes, where the components are used. For full-stack projects, it additionally
    makes sense to first separate our code by creating separate folders for the API
    integration and UI components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s define the folder structure for our project:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **src/api/** folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new **src/components/** folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea to start with a simple structure at first, and only nest more
    deeply when you actually need it. Do not spend too much time thinking about the
    file structure when starting a project, because usually, you do not know upfront
    how files should be grouped, and it may change later anyway.
  prefs: []
  type: TYPE_NORMAL
- en: After defining the high-level folder structure for our projects, let’s now take
    some time to consider the component structure.
  prefs: []
  type: TYPE_NORMAL
- en: Component structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Based on what we defined in the backend, our blog application is going to have
    the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Viewing a single post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea of components in React is to have each component deal with a single
    task or UI element. We should try to make components as fine-grained as possible,
    in order to be able to reuse code. If we find ourselves copying and pasting code
    from one component to another, it might be a good idea to create a new component
    and reuse it in multiple other components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, when developing a frontend, we start with a UI mock-up. For our blog
    application, a mock-up could look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – An initial mock-up of our blog application](img/B19385_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – An initial mock-up of our blog application
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will not cover UI or CSS frameworks. As such, the components
    are designed and developed without styling. Instead, the book focuses on the full-stack
    aspect of the integration of backends with frontends. Feel free to use a UI framework
    (such as MUI), or a CSS framework (such as Tailwind) to style the blog application
    on your own.
  prefs: []
  type: TYPE_NORMAL
- en: When splitting up the UI into components, we use the **single-responsibility
    principle**, which states that every module should have responsibility over a
    single encapsulated part of the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our mock-up, we can draw boxes around each component and subcomponent, and
    give them names. Keep in mind that each component should have exactly one responsibility.
    We start with the fundamental components that make up the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Defining the fundamental components in our mock-up](img/B19385_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Defining the fundamental components in our mock-up
  prefs: []
  type: TYPE_NORMAL
- en: We defined a `CreatePost` component, with a form to create a new post, a `PostFilter`
    component to filter the list of posts, a `PostSorting` component to sort posts,
    and a `Post` component to display a single post.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined our fundamental components, we are going to look at
    which components logically belong together, thereby forming a group: we can group
    the `Post` components together in `PostList`, then make an `App` component to
    group everything together and define the structure of our app.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are done with structuring our React components, we can move on to
    implementing the static React components.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing static React components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before integrating with the backend, we are going to model the basic features
    of our application as static React components. Dealing with the static view structure
    of our application first makes sense, as we can play around and re-structure the
    application UI if needed, before adding integration to the components, which would
    make it harder and more tedious to move them around. It is also easier to deal
    only with the UI first, which helps us to get started quickly with projects and
    features. Then, we can move on to implementing integrations and handling state.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started implementing the static components now.
  prefs: []
  type: TYPE_NORMAL
- en: The Post component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already thought about which elements a post has during the creation
    of the mock-up and the design of the backend. A post should have a `title`, `contents`,
    and an `author`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement the `Post` component now:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a new **src/components/Post.jsx** file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In that file, import **PropTypes**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function component, accepting **title**, **contents**, and **author**
    props:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, render all props in a way that resembles the mock-up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Please note that you should always prefer spacing via CSS, rather than using
    the **<br />** HTML tag. However, we are focusing on the UI structure and integration
    with the backend in this book, so we simply use HTML whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, define **propTypes**, making sure only **title** is required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Info
  prefs: []
  type: TYPE_NORMAL
- en: '**PropTypes** are used to validate the props passed to React components and
    to ensure that we are passing the correct props when using JavaScript. When using
    a type-safe language, such as TypeScript, we can instead do this by directly typing
    the props passed to the component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test out our component by *replacing* the **src/App.jsx** file with the
    following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **src/main.jsx** and update the import of the **App** component, because
    we are now not using **export** **default** anymore:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Info
  prefs: []
  type: TYPE_NORMAL
- en: I personally tend to prefer not using default exports, as they make it harder
    to re-group and re-export components and functions from other files. Also, they
    allow us to change the names of the components, which could be confusing. For
    example, if we change the name of a component, the name when importing it is not
    changed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, *remove* the following line from **src/main.jsx**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we can *delete* the **index.css** and **App.css** files, as they are
    not needed anymore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that our static `Post` component has been implemented, we can move on to
    the `CreatePost` component.
  prefs: []
  type: TYPE_NORMAL
- en: The CreatePost component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll now implement a form to allow for the creation of new posts. Here, we
    provide fields for `author` and `title` and a `<textarea>` element for the contents
    of the blog post.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement the `CreatePost` component now:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **src/components/CreatePost.jsx** file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the following component, which contains a form to enter the title, author,
    and contents of a blog post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code block, we defined an `onSubmit` handler and called `e.preventDefault()`
    on the event object to avoid a page refresh when the form is submitted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s test the component out by *replacing* the **src/App.jsx** file with the
    following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the `CreatePost` component renders fine. We can now move on
    to the `PostFilter` and `PostSorting` components.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you want to test out multiple components at once and keep the tests around
    for later, or build a style guide for your own component library, you should look
    into Storybook ([https://storybook.js.org](https://storybook.js.org)), which is
    a useful tool to build, test, and document UI components in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: The PostFilter and PostSorting components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similar to the `CreatePost` component, we will be creating two components that
    provide input fields to filter and sort posts. Let’s start with `PostFilter`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **src/components/PostFilter.jsx** file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this file, we import **PropTypes**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we define the **PostFilter** component and make use of the **field** prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we are going to define the `PostSorting` component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new **src/components/PostSorting.jsx** file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this file, we create a **select** input to select which field to sort by.
    We also create another **select** input to select the sort order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we have successfully defined UI components to filter and sort posts. In
    the next step, we are going to create a `PostList` component to combine the filter
    and sorting with a list of posts.
  prefs: []
  type: TYPE_NORMAL
- en: The PostList component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After implementing the other post-related components, we can now implement the
    most important part of our blog app, that is, the feed of blog posts. For now,
    the feed is simply going to show a list of blog posts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start implementing the `PostList` component now:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **src/components/PostList.jsx** file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we import **Fragment**, **PropTypes**, and the **Post** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define the **PostList** function component, accepting a **posts**
    array as a prop. If **posts** is not defined, we set it to an empty array, by
    default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we render all posts by using the **.map** function and the spread syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We return the `<Post>` component for each post, and pass all the keys from
    the `post` object to the component as props. We do this by using the spread syntax,
    which has the same effect as listing all the keys from the object manually as
    props, like so:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If we are rendering a list of elements, we have to give each element a unique
    **key** prop. React uses this **key** prop to efficiently compute the difference
    between two lists when the data has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used the `map` function, which applies a function to all the elements of
    an array. This is similar to using a `for` loop and storing all the results, but
    it is more concise, declarative, and easier to read! Alternatively, we could do
    the following instead of using the `map` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: However, using this style is *not* recommended with React.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also still need to define the prop types. Here, we can make use of the prop
    types from the **Post** component, by wrapping it inside the **PropTypes.shape()**
    function, which defines an object prop type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the mock-up, we have a horizontal line after each blog post. We can implement
    this without an additional **<div>** container element, by using **Fragment**,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The **key** prop always has to be added to the uppermost parent element that
    is rendered within the **map** function. In this case, we had to move the **key**
    prop from the **Post** component to **Fragment**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we test our component by editing the **src/App.jsx** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we can see that our app lists all the posts that we defined in the `posts`
    array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, listing multiple posts via the `PostList` component works fine.
    We can now move on to putting the app together.
  prefs: []
  type: TYPE_NORMAL
- en: Putting the app together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After implementing all the components, we now have to put everything together
    in the `App` component. Then, we will have successfully reproduced the mock-up!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start modifying the `App` component and putting our blog app together:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open **src/App.jsx** and add imports for the **CreatePost**, **PostFilter**,
    and **PostSorting** components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Adjust the **App** component to contain all the components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After saving the file, the browser should automatically refresh, and we can
    now see the full UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Full implementation of our static blog app, according to the
    mock-up](img/B19385_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Full implementation of our static blog app, according to the mock-up
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, all of the static components that we defined earlier are rendered
    together in one `App` component. Our app now looks just like a mock-up. Next,
    we can move on to integrating our components with the backend service.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the backend service using TanStack Query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After finishing creating all the UI components, we can now move on to integrating
    them with the backend we created in the previous chapter. For the integration,
    we are going to use TanStack Query (previously called React Query), which is a
    data fetching library that can also help us with caching, synchronizing, and updating
    data from a backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'TanStack Query specifically focuses on managing the state of fetched data (server
    state). While other state management libraries can also deal with server state,
    they specialize in managing client state instead. Server state has some stark
    differences from client state, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Being persisted remotely in a location the client does not control directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requiring asynchronous APIs to fetch and update state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having to deal with shared ownership, which means that other people can change
    the state without your knowledge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State becoming stale (“out of date”) at some point when changed by the server
    or other people
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These challenges with server state result in issues such as having to cache,
    deduplicate multiple requests, update “out of date” state in the background, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: TanStack Query provides solutions to these issues out of the box and thus makes
    dealing with server state simple. You can always combine it with other state management
    libraries that focus on client state as well. For use cases where the client state
    essentially just reflects the server state though, TanStack Query on its own can
    be good enough as a state management solution!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The reason why React Query got renamed to TanStack Query is that the library
    now also supports other frameworks, such as Solid, Vue, and Svelte!
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know why and how TanStack Query can help us integrate our frontend
    with the backend, let’s get started using it!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up TanStack Query for React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To set up TanStack Query, we first have to install the dependency and set up
    a query client. The query client is provided to React through a context and will
    store information about active requests, cached results, when to periodically
    re-fetch data, and everything needed for TanStack Query to function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started setting it up now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new Terminal (do not quit Vite!) and install the **@tanstack/react-query**
    dependency by running the following command in the root of our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Rename the **src/App.jsx** file to **src/Blog.jsx**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not update imports yet. If VS Code asks you to update imports, click **No**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, in **src/Blog.jsx**, change the function name from **App** to **Blog**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new **src/App.jsx** file. In this file, import **QueryClient** and
    **QueryClientProvider** from TanStack React Query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, import the **Blog** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a new query client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the **App** component and render the **Blog** component wrapped inside
    **QueryClientProvider**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s all there is to setting up TanStack Query! We can now make use of it
    inside our `Blog` component (and its children).
  prefs: []
  type: TYPE_NORMAL
- en: Fetching blog posts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we should do is fetch the list of blog posts from our backend.
    Let’s implement that now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, in the second Terminal window opened (not where Vite is running),
    run the backend server (do not quit Vite!), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you get an error, make sure Docker and MongoDB are running properly!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you want to develop the backend and frontend at the same time, you can start
    the backend using **npm run dev** to make sure it hot reloads when you change
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a **.env** file in the root of the project, and enter the following
    contents into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Vite supports `dotenv` out of the box. All environment variables that should
    be available to be accessed within the frontend need to be prefixed with `VITE_`.
    Here, we set an environment variable to point to our backend server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new **src/api/posts.js** file. In this file, we are going to define
    a function to fetch posts, which accepts the query params for the **/posts** endpoint
    as an argument. These query params are used to filter by author and tag and define
    sorting using **sortBy** and **sortOrder**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remember that we can use the **fetch** function to make a request to a server.
    We need to pass the environment variable to it and add the **/posts** endpoint.
    After the path, we add query params, which are prefixed with the **?** symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to use the **URLSearchParams** class to turn an object into query
    params. That class will automatically escape the input for us and turn it into
    valid query params:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Like we did before in the browser, we need to parse the response as JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **src/Blog.jsx** and *remove* the sample **posts** array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, import the **useQuery** function from **@tanstack/react-query** and the
    **getPosts** function from our **api** folder in the **src/Blog.jsx** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the **Blog** component, define a **useQuery** hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the **useQuery** hook, we get the posts from our query and fall back
    to an empty array if the posts are not loaded yet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Check your browser, and you will see that the posts are now loaded from our
    backend!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have successfully fetched blog posts, let’s get the filters and
    sorting working!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing filters and sorting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement filters and sorting, we need to handle some local state and pass
    it as query params to `postsQuery`. Let’s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by editing the **src/Blog.jsx** file and importing the **useState**
    hook from React:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we add state hooks for the **author** filter and the sorting options inside
    the **Blog** component, before the **useQuery** hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we adjust **queryKey** to contain the query params (so that whenever
    a query param changes, TanStack Query will re-fetch unless the request is already
    cached). We also adjust **queryFn** to call **getPosts** with the relevant query
    params:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now pass the values and relevant **onChange** handlers to the filter and sorting
    components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity’s sake, we are only using state hooks for now. A state management
    solution or context could make dealing with filters and sorting much easier, especially
    for larger applications. For our small blog application, it is fine to use state
    hooks though, as we are focusing mostly on the integration of the backend and
    frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, edit **src/components/PostFilter.jsx** and add the **value** and **onChange**
    props:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also do the same for **src/components/PostSorting.jsx**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In your browser, enter **Daniel Bugl** as the author. You should see TanStack
    Query re-fetch the posts from the backend as you type, and once a match is found,
    the backend will return all posts by that author!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After testing it out, make sure to clear the filter again, so that newly created
    posts are not filtered by the author anymore later on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you do not want to make that many requests to the backend, make sure to use
    a debouncing state hook, such as **useDebounce**, and then pass only the debounced
    value to the query param. If you are interested in gaining further knowledge about
    the **useDebounce** hook and other useful hooks, I recommend checking out my book
    titled *Learn* *React Hooks*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application should now look as follows, with the posts being filtered by
    the author entered in the field, and sorted by the selected field, in the selected
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Our first full-stack application – a frontend fetching posts
    from a backend!](img/B19385_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Our first full-stack application – a frontend fetching posts from
    a backend!
  prefs: []
  type: TYPE_NORMAL
- en: Now that sorting and filtering are working properly, let’s learn about mutations,
    which allow us to make requests to the server that change the state of the backend
    (for example, inserting or updating entries in the database).
  prefs: []
  type: TYPE_NORMAL
- en: Creating new posts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now going to implement a feature to create posts. To do this, we need
    to use the `useMutation` hook from TanStack Query. While queries are meant to
    be idempotent (meaning that calling them multiple times should not affect the
    result), mutations are used to create/update/delete data or perform operations
    on the server. Let’s get started using mutations to create new posts now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit **src/api/posts.js** and define a new **createPost** function, which accepts
    a **post** object as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also make a request to the **/posts** endpoint, like we did for **getPosts**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, now we also set **method** to a **POST** request, pass a header to
    tell the backend that we will be sending a JSON body, and then send our **post**
    object as a JSON string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Like with **getPosts**, we also need to parse the response as JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After defining the `createPost` API function, let’s use it in the `CreatePost`
    component by creating a new mutation hook there.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Edit **src/components/CreatePost.jsx** and import the **useMutation** hook
    from **@tanstack/react-query**, the **useState** hook from React, and our **createPost**
    API function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the **CreatePost** component, define state hooks for **title**, **author**,
    and **contents**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, define a mutation hook. Here, we are going to call our **createPost**
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we are going to define a **handleSubmit** function, which will prevent
    the default submit action (which refreshes the page), and instead call **.mutate()**
    to execute the mutation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We add the **onSubmit** handler to our form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also add the **value** and **onChange** props to our fields, as we did before
    for the sorting and filters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the submit button, we make sure it says **Creating…** instead of **Create**
    while we are waiting for the mutation to finish, and we also disable the button
    if no title was set (as it is required), or if the mutation is currently pending:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we add a message below the submit button, which will be shown if the
    mutation is successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In addition to **isPending** and **isSuccess**, mutations also return **isIdle**
    (when the mutation is idle or in a fresh/reset state) and **isError** states.
    The same states can also be accessed from queries, for example, to show a loading
    animation while posts are fetching.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can try adding a new post, and it seems to work fine, but the post list
    is not updating automatically, only after a refresh!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The issue is that the query key did not change, so TanStack Query does not refresh
    the list of posts. However, we also want to refresh the list when a new post is
    created. Let’s fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: Invalidating queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To ensure that the post list is refreshed after creating a new post, we need
    to invalidate the query. We can make use of the query client to do this. Let’s
    do it now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit **src/components/CreatePost.jsx** and import the **useQueryClient** hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the query client to invalidate all queries starting with the **''posts''**
    query key. This will work with any query params to the **getPosts** request, as
    it matches all queries starting with **''posts''** in the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Try creating a new post, and you will see that it works now, even with active
    filters and sorting! As we can see, TanStack Query is great for handling server
    state with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned how to create a React frontend and integrate it
    with our backend using TanStack Query. We have covered the main functionality
    of our backend: listing posts with sorting, creating posts, and filtering by author.
    Dealing with tags and deleting and editing posts are similar to the already explained
    functionalities and are left as an exercise for you.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [*Chapter 5*](B19385_05.xhtml#_idTextAnchor090), *Deploying
    the Application with Docker and CI/CD*, we are going to deploy our application
    with Docker and set up CI/CD pipelines to automate the deployment of our application.
  prefs: []
  type: TYPE_NORMAL
