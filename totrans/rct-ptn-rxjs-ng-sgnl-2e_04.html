<html><head></head><body>
<div id="_idContainer038">
<h1 class="chapter-number" id="_idParaDest-67"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-68"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.2.1">Handling Errors Reactively</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Errors in programming happen all the time, and RxJS is no exception. </span><span class="koboSpan" id="kobo.3.2">Handling those errors is a crucial part of every application. </span><span class="koboSpan" id="kobo.3.3">As I always say to my students in every training session, implementing a process that only covers happy cases determines the failure of your application. </span><span class="koboSpan" id="kobo.3.4">However, in RxJS, there are a lot of error handling strategies that you need to learn in order to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">errors efficiently.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We will start by explaining the contract of the Observable in RxJS, which is crucial to understanding what comes after. </span><span class="koboSpan" id="kobo.5.2">Then, we will learn the different error handling patterns and the operators provided by RxJS for that purpose. </span><span class="koboSpan" id="kobo.5.3">Next, we will shed light on the different error handling strategies and the use case of every strategy. </span><span class="koboSpan" id="kobo.5.4">Finally, we will practice one of the error handling strategies in our </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">recipe</span></span><span class="No-Break"><span class="koboSpan" id="kobo.7.1"> app.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.10.1">Understanding the anatomy of an </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">Observable contract</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Exploring error handling patterns </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">and strategies</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Handling errors in our </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">recipe</span></span><span class="No-Break"><span class="koboSpan" id="kobo.16.1"> app</span></span></li>
</ul>
<h1 id="_idParaDest-69"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.17.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.18.1">This chapter assumes that you have a basic understanding of RxJS. </span><span class="koboSpan" id="kobo.18.2">The source code of this chapter (except the samples) is available </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">at </span></span><a href="https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap04"><span class="No-Break"><span class="koboSpan" id="kobo.20.1">https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap04</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.21.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">Please also refer to the </span><em class="italic"><span class="koboSpan" id="kobo.23.1">Technical requirements</span></em><span class="koboSpan" id="kobo.24.1"> section in </span><a href="B21180_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.25.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.26.1">, </span><em class="italic"><span class="koboSpan" id="kobo.27.1">Fetching Data </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.28.1">as Streams</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">.</span></span></p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.30.1">Understanding the anatomy of an Observable contract</span></h1>
<p><span class="koboSpan" id="kobo.31.1">Understanding the</span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.32.1"> anatomy of an </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">Observable contract</span></strong><span class="koboSpan" id="kobo.34.1"> is crucial in order to learn error handling patterns. </span><span class="koboSpan" id="kobo.34.2">Let’s dig deep into the Observable execution timeline by exploring the marble diagram explained in </span><a href="B21180_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.35.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.36.1">, </span><em class="italic"><span class="koboSpan" id="kobo.37.1">Diving into the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.38.1">Reactive Paradigm</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.40.1"><img alt="Figure 4.1 – The marble diagram elements" src="image/B21180_04_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.41.1">Figure 4.1 – The marble diagram elements</span></p>
<p><span class="koboSpan" id="kobo.42.1">Let’s examine the previous diagram. </span><span class="koboSpan" id="kobo.42.2">If we take a look at the stream’s lifecycle, we can figure out that a stream has two </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">final statuses:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.44.1">Completion status</span></strong><span class="koboSpan" id="kobo.45.1">: Where</span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.46.1"> the stream has ended without errors and will not emit any further values. </span><span class="koboSpan" id="kobo.46.2">It is a shutdown, i.e., the </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">Observable completes.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.48.1">Error status</span></strong><span class="koboSpan" id="kobo.49.1">: Where the </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.50.1">stream has ended with an error and will not emit any further values after the error is thrown. </span><span class="koboSpan" id="kobo.50.2">It is also </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">a shutdown.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.52.1">Only one of those two states can occur, not both, and every stream can error out once. </span><span class="koboSpan" id="kobo.52.2">This is the </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">Observable contract.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">At this point, you may be </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.55.1">wondering, How we can recover from an error then? </span><span class="koboSpan" id="kobo.55.2">This is what we will be learning in the </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">following sections.</span></span></p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.57.1">Exploring error handling patterns and strategies</span></h1>
<p><span class="koboSpan" id="kobo.58.1">The first classic</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.59.1"> pattern we will learn for handling errors is based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">subscribe()</span></strong><span class="koboSpan" id="kobo.61.1"> method. </span><span class="koboSpan" id="kobo.61.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">subscribe()</span></strong><span class="koboSpan" id="kobo.63.1"> method takes as input the object Observer, which has </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">three callbacks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.65.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.66.1">success callback</span></strong><span class="koboSpan" id="kobo.67.1">: This is</span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.68.1"> called every time the stream emits a value and receives as input the </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">value emitted</span></span></li>
<li><span class="koboSpan" id="kobo.70.1">An </span><strong class="bold"><span class="koboSpan" id="kobo.71.1">error callback</span></strong><span class="koboSpan" id="kobo.72.1">: This is </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.73.1">called when an error occurs and receives as input the </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">error itself</span></span></li>
<li><span class="koboSpan" id="kobo.75.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.76.1">completion callback</span></strong><span class="koboSpan" id="kobo.77.1">: This is </span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.78.1">called when the </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">stream completes</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.80.1"> This is a basic example of a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">subscribe</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.82.1"> implementation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.83.1">
stream$.subscribe({
    next: (value) =&gt; console.log('Value Emitted', value),
    error: (error) =&gt; console.log('Error Occurred', error),
    complete: () =&gt; console.log('Stream Completed'),
});</span></pre> <p><span class="koboSpan" id="kobo.84.1">In the code sample, </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">stream$</span></strong><span class="koboSpan" id="kobo.86.1"> represents our Observable, and we passed an object that has three callbacks to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">subscribe</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.88.1"> method:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.89.1">A success callback that logs the received value in </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">the console</span></span></li>
<li><span class="koboSpan" id="kobo.91.1">An error callback that logs the received error in </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">the console</span></span></li>
<li><span class="koboSpan" id="kobo.93.1">A complete callback that logs the </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">stream completion</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.95.1">So, in order to handle errors, the first possibility is implementing the error callback and tracing the error message, displaying an error popup to the user, or doing any other custom behavior. </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">Pretty simple!</span></span></p>
<p><span class="koboSpan" id="kobo.97.1">But wait! </span><span class="koboSpan" id="kobo.97.2">In </span><a href="B21180_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.98.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.99.1">, </span><em class="italic"><span class="koboSpan" id="kobo.100.1">Fetching Data as Streams</span></em><span class="koboSpan" id="kobo.101.1">, we saw that we need to avoid the explicit </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">subscribe()</span></strong><span class="koboSpan" id="kobo.103.1"> to streams and learned the reasons and limitations behind this, namely, that it is impossible to recover from the error or emit an </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">alternative fallback.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">That’s right; in most cases, we will not be using </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">subscribe()</span></strong><span class="koboSpan" id="kobo.107.1"> explicitly. </span><span class="koboSpan" id="kobo.107.2">I just wanted to show you the classic way to do this, which is not the best way. </span><span class="koboSpan" id="kobo.107.3">Instead, let’s see some advanced error handling patterns and learn more operators that will help us in the error </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">handling process.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">I think you may be familiar with the try-catch statement available in many programming languages, which</span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.110.1"> consists of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">try</span></strong><span class="koboSpan" id="kobo.112.1"> block followed by one or more </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">catch</span></strong><span class="koboSpan" id="kobo.114.1"> clauses. </span><span class="koboSpan" id="kobo.114.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">try</span></strong><span class="koboSpan" id="kobo.116.1"> block, you place your risky statements, and inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">catch</span></strong><span class="koboSpan" id="kobo.118.1">, you handle the </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">possible exceptions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.120.1">
    try {
      // risky statements
  }
  catch(error) {
      // handle exceptions
   }</span></pre> <p><span class="koboSpan" id="kobo.121.1">RxJS ships with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">catchError</span></strong><span class="koboSpan" id="kobo.123.1"> operator, which provides us with something similar to the try-catch statement. </span><span class="koboSpan" id="kobo.123.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">catchError</span></strong><span class="koboSpan" id="kobo.125.1"> operator is defined</span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.126.1"> in the </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.127.1">RxJS official documentation as an operator that “</span><em class="italic"><span class="koboSpan" id="kobo.128.1">catches errors on the Observable to be handled by returning a new Observable or throwing </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.129.1">an error</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">.”</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">catchError</span></strong><span class="koboSpan" id="kobo.133.1"> operator subscribes to the source Observable that might error out and emits values to the observer until an error occurs. </span><span class="koboSpan" id="kobo.133.2">When an error happens, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">catchError</span></strong><span class="koboSpan" id="kobo.135.1"> operator executes a callback function, passing in the error. </span><span class="koboSpan" id="kobo.135.2">This callback function is responsible for handling errors and always returns </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">an Observable.</span></span></p>
<p><span class="koboSpan" id="kobo.137.1">If there are no errors, the output Observable returned by </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">catchError</span></strong><span class="koboSpan" id="kobo.139.1"> works exactly the same way as the </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">source Observable.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">You can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">catchError</span></strong><span class="koboSpan" id="kobo.143.1"> multiple times in an Observable chain, </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.145.1">
import { catchError} from 'rxjs/operators';
//stream$ is the source Observable that might error out
stream$.pipe(
      catchError(error =&gt; {
          //handle the error received
      })
).subscribe()</span></pre> <p><span class="koboSpan" id="kobo.146.1">After calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">catchError</span></strong><span class="koboSpan" id="kobo.148.1"> operator, we need to implement the callback function that will handle the error. </span><span class="koboSpan" id="kobo.148.2">When it comes</span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.149.1"> to handling</span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.150.1"> errors, there are </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">three strategies:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.152.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">replace strategy</span></span></li>
<li><span class="koboSpan" id="kobo.154.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">rethrow strategy</span></span></li>
<li><span class="koboSpan" id="kobo.156.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">retry strategy</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.158.1">Let’s break down these three strategies one by one in the following sections and explore some examples and </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">use cases.</span></span></p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.160.1">The replace strategy</span></h2>
<p><span class="koboSpan" id="kobo.161.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.162.1">replace strategy</span></strong><span class="koboSpan" id="kobo.163.1"> is named</span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.164.1"> as such because the Observable returned by the error </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.165.1">handling function will replace the Observable that has just errored out. </span><span class="koboSpan" id="kobo.165.2">This replacement Observable is then subscribed to, and its values are used instead of the errored-out input Observable. </span><span class="koboSpan" id="kobo.165.3">The following code is an example </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">of this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.167.1">
import { from, of } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
const stream$ = from(['5', '10', '6', 'Hello', '2']);
stream$
  .pipe(
    map((value) =&gt; {
      if (isNaN(value as any)) {
        throw new Error('This is not a number');
      }
      return parseInt(value);
    }),
    catchError((error) =&gt; {
      console.log('Caught Error', error);
      return of();
    })
  )
  .subscribe({
    next: (res) =&gt; console.log('Value Emitted', res),
    error: (err) =&gt; console.log('Error Occurred', err),
    complete: () =&gt; console.log('Stream Completed'),
  });
//output
Value Emitted 5
Value Emitted 10
Value Emitted 6
Caught Error Error: This is not a number
Stream Completed</span></pre> <p><span class="koboSpan" id="kobo.168.1">Let’s break down what is happening in </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">this example.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">First, we have an </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.171.1">Observable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">stream$</span></strong><span class="koboSpan" id="kobo.173.1">, created </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.174.1">from an array of string values, </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">['5', '10', '6', 'Hello', '2']</span></strong><span class="koboSpan" id="kobo.176.1">, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">from</span></strong><span class="koboSpan" id="kobo.178.1"> creation operator. </span><span class="koboSpan" id="kobo.178.2">This operator creates an Observable that, when subscribing to it, will emit the array’s values one by one and </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">then complete.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.180.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.181.1">For more details about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">from</span></strong><span class="koboSpan" id="kobo.183.1"> operator, please refer to the official </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">documentation: </span></span><a href="https://rxjs.dev/api/index/function/from#description"><span class="No-Break"><span class="koboSpan" id="kobo.185.1">https://rxjs.dev/api/index/function/from#description</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.186.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">Next, we combined two operators in the pipe method </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">stream$</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.191.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">map</span></strong><span class="koboSpan" id="kobo.193.1"> operator: This is used to transform the string values emitted to integers using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">parseInt()</span></strong><span class="koboSpan" id="kobo.195.1"> method. </span><span class="koboSpan" id="kobo.195.2">If the value emitted is not a number, then an error is thrown with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">"This is not a </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">number"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.198.1"> message.</span></span></li>
<li><span class="koboSpan" id="kobo.199.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">catchError</span></strong><span class="koboSpan" id="kobo.201.1"> operator: We pass the error handling function to it, which will log the caught error and return </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">of()</span></strong><span class="koboSpan" id="kobo.203.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">of()</span></strong><span class="koboSpan" id="kobo.205.1"> creates an Observable that has no values to emit, so it will </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">immediately complete.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.207.1">Then, we subscribe to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">stream$</span></strong><span class="koboSpan" id="kobo.209.1"> and log a custom message in every callback to see what exactly happens at </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">execution time.</span></span></p>
<p><span class="koboSpan" id="kobo.211.1">At execution time, </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">stream$</span></strong><span class="koboSpan" id="kobo.213.1"> will emit the string values of the array one by one (</span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">'5'</span></strong><span class="koboSpan" id="kobo.215.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">'10'</span></strong><span class="koboSpan" id="kobo.217.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">'6'</span></strong><span class="koboSpan" id="kobo.219.1">, respectively). </span><span class="koboSpan" id="kobo.219.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">map</span></strong><span class="koboSpan" id="kobo.221.1"> takes those values one by one as input and returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">5</span></strong><span class="koboSpan" id="kobo.223.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">10</span></strong><span class="koboSpan" id="kobo.225.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">6</span></strong><span class="koboSpan" id="kobo.227.1">, respectively. </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">catchError()</span></strong><span class="koboSpan" id="kobo.229.1"> takes the values emitted from the map operator and forwards them as output; the error handling function will not get called, as there is no error. </span><span class="koboSpan" id="kobo.229.2">Hence, the subscribers will receive </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">5</span></strong><span class="koboSpan" id="kobo.231.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">10</span></strong><span class="koboSpan" id="kobo.233.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">6</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.237.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">catchError()</span></strong><span class="koboSpan" id="kobo.239.1"> operator comes into play when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">'Hello'</span></strong><span class="koboSpan" id="kobo.241.1"> value is emitted. </span><span class="koboSpan" id="kobo.241.2">The map operator will throw an error, and the error handling function in </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">catchError()</span></strong><span class="koboSpan" id="kobo.243.1"> will, consequently, get called. </span><span class="koboSpan" id="kobo.243.2">The error handling function, in our case, simply logs an error in the console and returns an Observable (created by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">of()</span></strong><span class="koboSpan" id="kobo.245.1"> operator) that will immediately complete. </span><span class="koboSpan" id="kobo.245.2">This Observable will replace the current Observable that had an error; that’s why we call it the </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">replacement Observable.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">catchError()</span></strong><span class="koboSpan" id="kobo.248.1"> will subscribe under the hood to the returned Observable. </span><span class="koboSpan" id="kobo.248.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">of()</span></strong><span class="koboSpan" id="kobo.250.1"> Observable will complete immediately. </span><span class="koboSpan" id="kobo.250.2">Then, </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">stream$</span></strong><span class="koboSpan" id="kobo.252.1"> is completed, so the next value, </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">'2'</span></strong><span class="koboSpan" id="kobo.254.1">, will not </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">get emitted.</span></span></p>
<p><span class="koboSpan" id="kobo.256.1">As you may have noticed, the error callback in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">subscribe()</span></strong><span class="koboSpan" id="kobo.258.1"> method will not get called because we handled it in </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">catchError</span></strong><span class="koboSpan" id="kobo.260.1">. </span><span class="koboSpan" id="kobo.260.2">I added it on purpose to understand the behavior of error handling with </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">catchError</span></strong><span class="koboSpan" id="kobo.262.1">. </span><span class="koboSpan" id="kobo.262.2">Therefore, when an error occurs, the current stream that had an error out will get replaced by the stream</span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.263.1"> returned from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">catchError()</span></strong><span class="koboSpan" id="kobo.265.1">; the values of the replaced</span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.266.1"> Observable will then get emitted instead of the original stream values. </span><span class="koboSpan" id="kobo.266.2">This is what we </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.267.1">call </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.268.1">fallback values</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.270.1">So, to summarize, the replace strategy is useful when we want to handle the error inside the stream itself and don’t want the error to get propagated to </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">the subscribers.</span></span></p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.272.1">The rethrow strategy</span></h2>
<p><span class="koboSpan" id="kobo.273.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.274.1">rethrow strategy</span></strong><span class="koboSpan" id="kobo.275.1"> consists </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.276.1">of rethrowing</span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.277.1"> the error or, in other words, propagating the error to the subscribers of the output Observable of </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">catchError</span></strong><span class="koboSpan" id="kobo.279.1">. </span><span class="koboSpan" id="kobo.279.2">Notifying the subscribers about the error will help them perform side effects, such as displaying an error message in </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">a popup.</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">To understand more about this strategy, let’s look at the following example; it is the same as the one in the previous section, with the only difference being the error </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">handling function</span></span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.284.1">
import { from, throwError } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
const stream$ = from(['5', '10', '6', 'Hello', '2']);
stream$
  .pipe(
    map((value) =&gt; {
      if (isNaN(value as any)) {
        throw new Error('This is not a number');
      }
      return parseInt(value);
    }),
    catchError((error) =&gt; {
      console.log('Caught Error', error);
      return throwError(() =&gt; error);
    })
  )
  .subscribe({
    next: (res) =&gt; console.log('Value Emitted', res),
    error: (err) =&gt; console.log('Error Occurred', err),
    complete: () =&gt; console.log('Stream Completed'),
  });
//output
Value Emitted 5
Value Emitted 10
Value Emitted 6
Caught Error Error: This is not a number
Error Occurred Error: This is not a number</span></pre> <p><span class="koboSpan" id="kobo.285.1">In the error handling function, we </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.286.1">return an </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.287.1">Observable that is created using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">throwError</span></strong><span class="koboSpan" id="kobo.289.1"> operator. </span><span class="koboSpan" id="kobo.289.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">throwError</span></strong><span class="koboSpan" id="kobo.291.1"> operator creates an Observable that never emits any value; instead, it errors out immediately using the same error caught by </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">catchError</span></strong><span class="koboSpan" id="kobo.293.1">. </span><span class="koboSpan" id="kobo.293.2">In this way, the error will get pushed to the subscribers and can be further handled by the rest of the Observable chain </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">if needed.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">As you may have noticed, the same error was logged both in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">catchError</span></strong><span class="koboSpan" id="kobo.297.1"> block and the subscriber error handler function, as expected, so the rethrow strategy </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">has worked.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">Please note </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.300.1">that in the previous examples, we</span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.301.1"> simply log the error in the console for demonstration purposes. </span><span class="koboSpan" id="kobo.301.2">However, in a real-world scenario, you can do much more, such as showing messages to </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">the users.</span></span></p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.303.1">The retrying strategy</span></h2>
<p><span class="koboSpan" id="kobo.304.1">With the </span><strong class="bold"><span class="koboSpan" id="kobo.305.1">retry strategy</span></strong><span class="koboSpan" id="kobo.306.1">, you can </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.307.1">retry the </span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.308.1">Observable using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">retry</span></strong><span class="koboSpan" id="kobo.310.1"> operator to give another chance to the stream. </span><span class="koboSpan" id="kobo.310.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">retry</span></strong><span class="koboSpan" id="kobo.312.1"> operator retries an Observable a specific number of times and is useful for retrying HTTP requests or connections. </span><span class="koboSpan" id="kobo.312.2">We can see an </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">example here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.314.1">
import { catchError, map, retry } from 'rxjs/operators';
import { from, throwError } from 'rxjs';
const stream$ = from(['5', '10', '6', 'Hello', '2']);
stream$
  .pipe(
    map((value) =&gt; {
      if (isNaN(value as any)) {
        throw new Error('This is not a number');
      }
      return parseInt(value);
    }),
    retry(2),
    catchError((error) =&gt; {
      console.log('Caught Error', error);
      return throwError(() =&gt; error);
    })
  )
  .subscribe({
    next: (res) =&gt; console.log('Value Emitted', res),
    error: (err) =&gt; console.log('Error Occurred', err),
    complete: () =&gt; console.log('Stream Completed'),
  });
//output
Value Emitted 5
10
6
5
10
6
5
10
6
Caught Error Error: This is not a number
Error Occurred Error: This is not a number</span></pre> <p><span class="koboSpan" id="kobo.315.1">As you may have </span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.316.1">noticed, the values of the source stream were emitted two </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.317.1">times since we called the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">retry</span></strong><span class="koboSpan" id="kobo.319.1"> operator with </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">2</span></strong><span class="koboSpan" id="kobo.321.1"> as a parameter; we gave the Observable two chances before throwing </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">the error.</span></span></p>
<p><span class="koboSpan" id="kobo.323.1">Now, in this case, we are retrying immediately. </span><span class="koboSpan" id="kobo.323.2">However, what if we want to retry in only specific cases or wait </span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.324.1">for a delay before retrying? </span><span class="koboSpan" id="kobo.324.2">This </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.325.1">is where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">retryWhen</span></strong><span class="koboSpan" id="kobo.327.1"> operator comes </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">into play!</span></span></p>
<p><span class="koboSpan" id="kobo.329.1">To </span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.330.1">understand the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">retryWhen</span></strong><span class="koboSpan" id="kobo.332.1"> operator, there’s nothing better than a </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">marble diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.334.1"><img alt="Figure 4.2 – The retryWhen operator" src="image/B21180_04_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.335.1">Figure 4.2 – The retryWhen operator</span></p>
<p><span class="koboSpan" id="kobo.336.1">Let’s explain what’s going </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">on here:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.338.1">The Observable in the </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.339.1">first line is the </span><strong class="bold"><span class="koboSpan" id="kobo.340.1">notifier Observable</span></strong><span class="koboSpan" id="kobo.341.1"> that is going to determine when the retry </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">should occur</span></span></li>
<li><span class="koboSpan" id="kobo.343.1">The Observable in the second line is the </span><strong class="bold"><span class="koboSpan" id="kobo.344.1">source Observable</span></strong><span class="koboSpan" id="kobo.345.1"> that will error out after</span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.346.1"> emitting </span><strong class="bold"><span class="koboSpan" id="kobo.347.1">1</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.348.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.349.1">2</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.350.1">When we subscribe to the source Observable it will emit </span><strong class="bold"><span class="koboSpan" id="kobo.351.1">1</span></strong><span class="koboSpan" id="kobo.352.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.353.1">2</span></strong><span class="koboSpan" id="kobo.354.1">. </span><span class="koboSpan" id="kobo.354.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">retryWhen</span></strong><span class="koboSpan" id="kobo.356.1"> forwards those values as output. </span><span class="koboSpan" id="kobo.356.2">Then, the source Observable errors out </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">and completes.</span></span></p>
<p><span class="koboSpan" id="kobo.358.1">Nothing will happen until the notifier Observable emits the first value, </span><strong class="bold"><span class="koboSpan" id="kobo.359.1">r</span></strong><span class="koboSpan" id="kobo.360.1">. </span><span class="koboSpan" id="kobo.360.2">At that moment, the source Observable will get retried, and as you see, </span><strong class="bold"><span class="koboSpan" id="kobo.361.1">1</span></strong><span class="koboSpan" id="kobo.362.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.363.1">2</span></strong><span class="koboSpan" id="kobo.364.1"> get emitted again. </span><span class="koboSpan" id="kobo.364.2">In fact, </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">retryWhen</span></strong><span class="koboSpan" id="kobo.366.1"> will subscribe to the source Observable because it is already completed, so even if it is completed, it can </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">be retried.</span></span></p>
<p><span class="koboSpan" id="kobo.368.1">The notifier Observable is then going to emit another </span><strong class="bold"><span class="koboSpan" id="kobo.369.1">r</span></strong><span class="koboSpan" id="kobo.370.1"> value, and the same </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">thing occurs.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">Next, </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">retryWhen</span></strong><span class="koboSpan" id="kobo.374.1"> starts to emit the first </span><strong class="bold"><span class="koboSpan" id="kobo.375.1">1</span></strong><span class="koboSpan" id="kobo.376.1"> value, but soon after, the notifier Observable completes; that’s why the </span><strong class="bold"><span class="koboSpan" id="kobo.377.1">2</span></strong><span class="koboSpan" id="kobo.378.1"> value will not </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">get emitted.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">As you may </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.381.1">have guessed, </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">retryWhen</span></strong><span class="koboSpan" id="kobo.383.1"> retries the source Observable each time the notifier emits a value! </span><span class="koboSpan" id="kobo.383.2">This means that you can use this notifier Observable to emit values at the moment you want your source Observable to get retried and complete it at the moment you want your retry attempts </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">to stop.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">Now, let’s have a look at the signature of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">retryWhen</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.387.1"> operator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.388.1">
export declare function retryWhen&lt;T&gt;(notifier: (errors:
Observable&lt;any&gt;) =&gt; Observable&lt;any&gt;):
MonoTypeOperatorFunction&lt;T&gt;;</span></pre> <p><span class="koboSpan" id="kobo.389.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">notifier</span></strong><span class="koboSpan" id="kobo.391.1"> parameter represents the callback that returns the notifier Observable and gets the error Observable as the argument. </span><span class="koboSpan" id="kobo.391.2">The error Observable will emit every time the source</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.392.1"> Observable errors out. </span><span class="koboSpan" id="kobo.392.2">So, </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">retryWhen</span></strong><span class="koboSpan" id="kobo.394.1"> will subscribe to the </span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.395.1">notifier Observable and behave as </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">described previously.</span></span></p>
<p><span class="koboSpan" id="kobo.397.1">Here is the same example given in the replace and rethrow strategies, but using </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">retryWhen</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.399.1"> instead:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.400.1">
import { from} from 'rxjs';
import { map, retryWhen, tap } from 'rxjs/operators';
const stream$ = from(['5', '10', '6', 'Hello', '2']);
stream$
  .pipe(
    map((value) =&gt; {
      if (isNaN(value as any)) {
        throw new Error('This is not a number');
      }
      return parseInt(value);
    }),
    retryWhen((errors) =&gt; {
      return errors.pipe(
        tap(() =&gt; console.log('Retrying the source
                              Observable...'))
      );
    })
  )
  .subscribe({
    next: (res) =&gt; console.log('Value Emitted', res),
    error: (err) =&gt; console.log('Error Occurred', err),
    complete: () =&gt; console.log('Stream Completed'),
  });
//Code runs infinitely</span></pre> <p><span class="koboSpan" id="kobo.401.1">In the previous code, the first error is thrown when receiving the value </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">'Hello'</span></strong><span class="koboSpan" id="kobo.403.1">, which is not a number. </span><span class="koboSpan" id="kobo.403.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">retryWhen</span></strong><span class="koboSpan" id="kobo.405.1"> operator will catch this error and get executed. </span><span class="koboSpan" id="kobo.405.2">Then, the notifier</span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.406.1"> callback (the argument of </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">retryWhen</span></strong><span class="koboSpan" id="kobo.408.1">) simply takes the error</span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.409.1"> Observable as input and </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">returns it.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">We also used the pipe to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">tap</span></strong><span class="koboSpan" id="kobo.413.1"> operator in order to log a message in the console (</span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">'Retrying the source Observable...'</span></strong><span class="koboSpan" id="kobo.415.1"> ). </span><span class="koboSpan" id="kobo.415.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">tap()</span></strong><span class="koboSpan" id="kobo.417.1"> operator is used to perform a side effect for each </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">emitted value.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.419.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.420.1">For more details about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">tap</span></strong><span class="koboSpan" id="kobo.422.1"> operator, please refer to this link from the official </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">documentation: </span></span><a href="https://rxjs.dev/api/operators/tap"><span class="No-Break"><span class="koboSpan" id="kobo.424.1">https://rxjs.dev/api/operators/tap</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.425.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">If you execute that code, you will find out that it runs infinitely. </span><span class="koboSpan" id="kobo.426.2">Why? </span><span class="koboSpan" id="kobo.426.3">Because the source will always error out, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">retryWhen</span></strong><span class="koboSpan" id="kobo.428.1"> will, consequently, subscribe infinitely to the </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">source Observable.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">If the source always errors out, it is not correct to retry immediately. </span><span class="koboSpan" id="kobo.430.2">However, the error will not always occur, for example, in the case of HTTP requests. </span><span class="koboSpan" id="kobo.430.3">Sometimes, the HTTP request fails because the server is down, or there is another temporary reason that may disappear, and the </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.431.1">request might go through in the next attempts without </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">any problem.</span></span></p>
<p><span class="koboSpan" id="kobo.433.1">In that case, you can use the immediate retry or even a delayed retry, which retries after a certain delay, where </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.434.1">we can wait, for </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.435.1">example, for 5 seconds after the error occurs before retrying. </span><span class="koboSpan" id="kobo.435.2">That’s what we will be learning in the </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.437.1">Now, let’s have a look at another operator </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.438.1">that will help us implement the retry strategy: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">delayWhen</span></strong><span class="koboSpan" id="kobo.440.1"> operator. </span><span class="koboSpan" id="kobo.440.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">delayWhen()</span></strong><span class="koboSpan" id="kobo.442.1"> operator is used to delay values emitted from the source Observable by a given duration. </span><span class="koboSpan" id="kobo.442.2">It is similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">delay()</span></strong><span class="koboSpan" id="kobo.444.1"> operator, but the delay duration is determined by an </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">input Observable.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">For more detail, </span><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.447.1">let’s take a look at a </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">marble diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.449.1"><img alt="Figure 4.3 – The delayWhen operator" src="image/B21180_04_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.450.1">Figure 4.3 – The delayWhen operator</span></p>
<p><span class="koboSpan" id="kobo.451.1">The first Observable is the source Observable. </span><span class="koboSpan" id="kobo.451.2">Each of the values, </span><strong class="bold"><span class="koboSpan" id="kobo.452.1">a</span></strong><span class="koboSpan" id="kobo.453.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.454.1">b</span></strong><span class="koboSpan" id="kobo.455.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.456.1">c</span></strong><span class="koboSpan" id="kobo.457.1">, has its own duration selector Observable, respectively, in the diagram: the </span><strong class="bold"><span class="koboSpan" id="kobo.458.1">a</span></strong><span class="koboSpan" id="kobo.459.1"> duration selector Observable, the </span><strong class="bold"><span class="koboSpan" id="kobo.460.1">b</span></strong><span class="koboSpan" id="kobo.461.1"> duration selector Observable, and the </span><strong class="bold"><span class="koboSpan" id="kobo.462.1">c</span></strong><span class="koboSpan" id="kobo.463.1"> duration selector Observable, which will emit one value, </span><strong class="bold"><span class="koboSpan" id="kobo.464.1">x</span></strong><span class="koboSpan" id="kobo.465.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">then </span></span><span class="No-Break"><a id="_idIndexMarker164"/></span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">complete.</span></span></p>
<p><span class="koboSpan" id="kobo.468.1">Every value </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.469.1">emitted </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.470.1">by the source Observable will be delayed before being emitted to the output Observable. </span><span class="koboSpan" id="kobo.470.2">In fact, when the source Observable emits the value </span><strong class="bold"><span class="koboSpan" id="kobo.471.1">a</span></strong><span class="koboSpan" id="kobo.472.1"> at </span><strong class="bold"><span class="koboSpan" id="kobo.473.1">ta</span></strong><span class="koboSpan" id="kobo.474.1"> in the timeline, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">delayWhen</span></strong><span class="koboSpan" id="kobo.476.1"> operator will not immediately emit the value to the source Observable; instead, it will wait for the </span><strong class="bold"><span class="koboSpan" id="kobo.477.1">a</span></strong><span class="koboSpan" id="kobo.478.1"> duration selector Observable to emit a value at </span><strong class="bold"><span class="koboSpan" id="kobo.479.1">ta+delay</span></strong><span class="koboSpan" id="kobo.480.1">, and at that exact time, the value </span><strong class="bold"><span class="koboSpan" id="kobo.481.1">a</span></strong><span class="koboSpan" id="kobo.482.1"> will get emitted to the </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">Output Observable.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">This carries on for the other values; the </span><strong class="bold"><span class="koboSpan" id="kobo.485.1">b</span></strong><span class="koboSpan" id="kobo.486.1"> value will show up in the Output Observable at </span><strong class="bold"><span class="koboSpan" id="kobo.487.1">tb+delay</span></strong><span class="koboSpan" id="kobo.488.1"> when the </span><strong class="bold"><span class="koboSpan" id="kobo.489.1">b</span></strong><span class="koboSpan" id="kobo.490.1"> duration selector emits a value, and the value </span><strong class="bold"><span class="koboSpan" id="kobo.491.1">c</span></strong><span class="koboSpan" id="kobo.492.1"> will get emitted at </span><strong class="bold"><span class="koboSpan" id="kobo.493.1">tc+delay</span></strong><span class="koboSpan" id="kobo.494.1"> when the </span><strong class="bold"><span class="koboSpan" id="kobo.495.1">c</span></strong><span class="koboSpan" id="kobo.496.1"> duration selector Observable emits a value. </span><span class="koboSpan" id="kobo.496.2">Note that here, </span><strong class="bold"><span class="koboSpan" id="kobo.497.1">tb</span></strong><span class="koboSpan" id="kobo.498.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.499.1">tc</span></strong><span class="koboSpan" id="kobo.500.1"> represent the emission time of the values </span><strong class="bold"><span class="koboSpan" id="kobo.501.1">a</span></strong><span class="koboSpan" id="kobo.502.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.503.1">b</span></strong><span class="koboSpan" id="kobo.504.1"> by the source </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">Observable, respectively.</span></span></p>
<p><span class="koboSpan" id="kobo.506.1">As you may have noticed, the value </span><strong class="bold"><span class="koboSpan" id="kobo.507.1">b</span></strong><span class="koboSpan" id="kobo.508.1"> was emitted before </span><strong class="bold"><span class="koboSpan" id="kobo.509.1">c</span></strong><span class="koboSpan" id="kobo.510.1"> by the source Observable (as </span><strong class="bold"><span class="koboSpan" id="kobo.511.1">tb</span></strong><span class="koboSpan" id="kobo.512.1"> precedes </span><strong class="bold"><span class="koboSpan" id="kobo.513.1">tc</span></strong><span class="koboSpan" id="kobo.514.1">); however, the value </span><strong class="bold"><span class="koboSpan" id="kobo.515.1">b</span></strong><span class="koboSpan" id="kobo.516.1"> was shown after the value </span><strong class="bold"><span class="koboSpan" id="kobo.517.1">c</span></strong><span class="koboSpan" id="kobo.518.1"> in the output Observable (as </span><strong class="bold"><span class="koboSpan" id="kobo.519.1">tb+delay</span></strong><span class="koboSpan" id="kobo.520.1"> succeeds </span><strong class="bold"><span class="koboSpan" id="kobo.521.1">tc+delay</span></strong><span class="koboSpan" id="kobo.522.1">); that’s because the selector of </span><strong class="bold"><span class="koboSpan" id="kobo.523.1">b</span></strong><span class="koboSpan" id="kobo.524.1"> (the </span><strong class="bold"><span class="koboSpan" id="kobo.525.1">b</span></strong><span class="koboSpan" id="kobo.526.1"> duration selector in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.527.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.528.1">.3</span></em><span class="koboSpan" id="kobo.529.1">) is emitted after the selector of </span><strong class="bold"><span class="koboSpan" id="kobo.530.1">c</span></strong><span class="koboSpan" id="kobo.531.1"> (the </span><strong class="bold"><span class="koboSpan" id="kobo.532.1">c</span></strong><span class="koboSpan" id="kobo.533.1"> duration selector also shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.534.1">Figure 4</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.535.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.537.1">So, as you can see, the delay is completely flexible through the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">durationSelector</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.539.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.540.1">Another function, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">timer</span></strong><span class="koboSpan" id="kobo.542.1"> function, can be useful in the delayed </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">retry strategy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.544.1">
export declare function timer(dueTime?: number | Date,
periodOrScheduler?: number | SchedulerLike, scheduler?:
SchedulerLike): Observable&lt;number&gt;;</span></pre> <p><span class="koboSpan" id="kobo.545.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">timer</span></strong><span class="koboSpan" id="kobo.547.1"> function returns an Observable and takes </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">two arguments:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">due</span></strong><span class="koboSpan" id="kobo.550.1">: A time period or exact date before which no values will </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">be emitted</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">scheduler</span></strong><span class="koboSpan" id="kobo.553.1">: A periodic interval, in case we want to emit new </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">values periodically</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.555.1">An example is </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">timer(5000,1000)</span></strong><span class="koboSpan" id="kobo.557.1">. </span><span class="koboSpan" id="kobo.557.2">The first value of the returned Observable will get emitted after 5 seconds, and a new value is emitted each second. </span><span class="koboSpan" id="kobo.557.3">The second argument is optional, which means that </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">timer(5000)</span></strong><span class="koboSpan" id="kobo.559.1"> will emit a value after 5 seconds and </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">then complete.</span></span></p>
<p><span class="koboSpan" id="kobo.561.1">Now, it is </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.562.1">time</span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.563.1"> to combine the </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">delayWhen</span></strong><span class="koboSpan" id="kobo.565.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">retryWhen</span></strong><span class="koboSpan" id="kobo.567.1"> operators </span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.568.1">to see how we can retry a failing HTTP request 5 seconds after </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">each error:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.570.1">
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Recipe } from '../model/recipe.model';
import { catchError, delayWhen, of, retryWhen, tap, timer } from 'rxjs';
@Injectable({
  providedIn: 'root'
})
export class RecipesService {
recipes$ =
this.http.get&lt;Recipe[]&gt;('http://localhost:3001/recipes')
.pipe(
       retryWhen(errors =&gt; {
         return errors
           .pipe(
             delayWhen(() =&gt; timer(5000)),
             tap(() =&gt; console.log('Retrying the HTTP
                                   request...'))
           );
       }),
);
constructor(private http: HttpClient) { }
}</span></pre> <p class="callout-heading"><span class="koboSpan" id="kobo.571.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.572.1">You will not find the preceding code in the GitHub repository, as it serves merely as an illustrative example. </span><span class="koboSpan" id="kobo.572.2">However, you can copy and paste it into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">RecipesService</span></strong><span class="koboSpan" id="kobo.574.1"> class in order to test the delayed retry. </span><span class="koboSpan" id="kobo.574.2">Additionally, remember to stop </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">the recipes-book-api</span></strong><span class="koboSpan" id="kobo.576.1"> mocked server to simulate </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">retry attempts.</span></span></p>
<p><span class="koboSpan" id="kobo.578.1">Our source </span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.579.1">Observable, in this case, is the result of an HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">get</span></strong><span class="koboSpan" id="kobo.581.1"> request. </span><span class="koboSpan" id="kobo.581.2">Each time the request fails, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">delayWhen</span></strong><span class="koboSpan" id="kobo.583.1"> operator creates a duration selector Observable through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">timer</span></strong><span class="koboSpan" id="kobo.585.1"> function. </span><span class="koboSpan" id="kobo.585.2">This duration selector Observable is going to emit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">0</span></strong><span class="koboSpan" id="kobo.587.1"> value after 5 seconds and then complete. </span><span class="koboSpan" id="kobo.587.2">Therefore, the notifier Observable of </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">retryWhen</span></strong><span class="koboSpan" id="kobo.589.1"> will emit a value, and at that moment, the source Observable will get retried, after 5 seconds to </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">be exact.</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">When you open the console, you will see </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">this output:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.593.1"><img alt="Figure 4.4 – The failing HTTP request" src="image/B21180_04_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.594.1">Figure 4.4 – The failing HTTP request</span></p>
<p><span class="koboSpan" id="kobo.595.1">As you may have noticed, every time the GET HTTP request fails, it is retried again after 5 seconds. </span><span class="koboSpan" id="kobo.595.2">That’s how we achieved a delayed retry! </span><span class="koboSpan" id="kobo.595.3">So, to wrap up, each of the error handling strategies has</span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.596.1"> its</span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.597.1"> own techniques and serves a different purpose. </span><span class="koboSpan" id="kobo.597.2">In the following section, we will explore when to use </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">each strategy.</span></span></p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.599.1">Choosing the right error handling strategy</span></h2>
<p><span class="koboSpan" id="kobo.600.1">Choosing the most</span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.601.1"> appropriate error handling strategy in RxJS depends on various factors, such as the nature of the application, the type of errors encountered, and the desired user experience. </span><span class="koboSpan" id="kobo.601.2">Here’s some guidance on when to use </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">each strategy.</span></span></p>
<p><span class="koboSpan" id="kobo.603.1">The replace strategy involves replacing the error with a fallback value or Observable. </span><span class="koboSpan" id="kobo.603.2">It’s suitable in the </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">following scenarios:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.605.1">You have a predefined fallback value or behavior to use when an error occurs, such as displaying placeholder content or default settings. </span><span class="koboSpan" id="kobo.605.2">For example, in a weather application, if fetching current weather data fails, you can replace the error with a default weather forecast for the </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">user’s location.</span></span></li>
<li><span class="koboSpan" id="kobo.607.1">The error is recoverable and doesn’t require immediate intervention from </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">the user.</span></span></li>
<li><span class="koboSpan" id="kobo.609.1">You want to provide a seamless user experience by gracefully handling errors without disrupting the </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">application flow.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.611.1">The rethrow strategy involves rethrowing the error to propagate it to the subscriber for handling. </span><span class="koboSpan" id="kobo.611.2">It’s</span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.612.1"> suitable in the </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">following scenarios:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.614.1">You want to delegate error-handling responsibility to the subscriber or consumer of the Observable. </span><span class="koboSpan" id="kobo.614.2">For example, in an authentication service, if login fails due to invalid credentials, you can rethrow the error to allow the UI component to display an error message to </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">the user.</span></span></li>
<li><span class="koboSpan" id="kobo.616.1">The error requires specific handling logic or customization based on the context in which </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">it occurs.</span></span></li>
<li><span class="koboSpan" id="kobo.618.1">You want to provide flexibility for different parts of the application to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">errors differently.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.620.1">The retry strategy involves retrying the operation that resulted in the error a certain number of times. </span><span class="koboSpan" id="kobo.620.2">It’s suitable in the </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">following scenarios:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.622.1">The error is transient or intermittent, such as network errors or temporary service disruptions where retrying the operation may succeed after subsequent attempts. </span><span class="koboSpan" id="kobo.622.2">For example, in a file upload service, if uploading a file fails due to a network error, you can retry the upload operation multiple times before giving up to ensure the file is </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">successfully uploaded.</span></span></li>
<li><span class="koboSpan" id="kobo.624.1">Retrying the operation has a reasonable chance of success and can mitigate the impact of </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">transient failures.</span></span></li>
<li><span class="koboSpan" id="kobo.626.1">You want to improve the reliability and robustness of operations that are prone to </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">occasional failures.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.628.1">Additionally, consider the following factors when choosing an error </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">handling strategy:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.630.1">User experience</span></strong><span class="koboSpan" id="kobo.631.1">: Consider </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.632.1">how each strategy affects the user experience, such as whether it leads to delays, retries, </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">or fallbacks.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.634.1">Application requirements</span></strong><span class="koboSpan" id="kobo.635.1">: Align the chosen strategy with the specific requirements and constraints of your application, such as reliability, responsiveness, and </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">error tolerance.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.637.1">Performance implications</span></strong><span class="koboSpan" id="kobo.638.1">: Retry strategies may introduce additional overhead, especially if the operation involves expensive or </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">time-consuming tasks.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.640.1">Ultimately, the most appropriate error handling strategy depends on the specific context and requirements of your application. </span><span class="koboSpan" id="kobo.640.2">It’s often beneficial to experiment with different strategies and observe their effects in real-world scenarios to determine the </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">optimal </span></span><span class="No-Break"><a id="_idIndexMarker176"/></span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">approach.</span></span></p>
<p><span class="koboSpan" id="kobo.643.1">Now that we have</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.644.1"> learned the different strategies and operators to handle errors, let’s practice in our Recipes Book app in the </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">next section.</span></span></p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.646.1">Handling errors in our recipe app</span></h1>
<p><span class="koboSpan" id="kobo.647.1">The first thing</span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.648.1"> we are going to do is stop our mock service. </span><span class="koboSpan" id="kobo.648.2">Yes, you heard it</span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.649.1"> right; stop it. </span><span class="koboSpan" id="kobo.649.2">This way, the call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">getRecipes</span></strong><span class="koboSpan" id="kobo.651.1"> service will fail because the server </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">is down.</span></span></p>
<p><span class="koboSpan" id="kobo.653.1">Now, if you refresh the front app, you will see that nothing, including our list of recipes, is displayed. </span><span class="koboSpan" id="kobo.653.2">Why do we get this behavior? </span><span class="koboSpan" id="kobo.653.3">Because we did not handle the errors. </span><span class="koboSpan" id="kobo.653.4">The error was thrown, the stream was completed, and nothing happened afterward. </span><span class="koboSpan" id="kobo.653.5">We have a white screen where nothing </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">is displayed.</span></span></p>
<p><span class="koboSpan" id="kobo.655.1">Now open the console, and you will see the </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">failed request:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.657.1"><img alt="" role="presentation" src="image/B21180_04_5.jpg"/></span>
</div>
</div>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.658.1"><img alt="" role="presentation" src="image/B21180_04_6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.659.1">Figure 4.5 – The console showing the failed request</span></p>
<p><span class="koboSpan" id="kobo.660.1">A failing HTTP request would never have broken our app if it was handled correctly. </span><span class="koboSpan" id="kobo.660.2">That’s why you should be very careful when raising HTTP requests in your </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">front application.</span></span></p>
<p><span class="koboSpan" id="kobo.662.1">So, how can we fix this? </span><span class="koboSpan" id="kobo.662.2">Which strategy that we’ve previously discussed will fit </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">the best?</span></span></p>
<p><span class="koboSpan" id="kobo.664.1">If we choose the rethrow or retry strategy, then we will block the display of the recipes list. </span><span class="koboSpan" id="kobo.664.2">The user will get a blank page and will have to wait for the request to get executed successfully in order to see the list of recipes rendered in the screen. </span><span class="koboSpan" id="kobo.664.3">This is a valid option when you handle</span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.665.1"> processes in the</span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.666.1"> background that are not related to the UI display; however, if you raise requests in order to get results and display them in your UI components, then you should provide a replacement for that data to continue rendering the page. </span><span class="koboSpan" id="kobo.666.2">The user interface should keep on working regardless of whether or not there is an error; if there is an error, then we will display an empty list; if not, we will display the returned list from </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.668.1">That’s why the replacement strategy fits the most in this particular case. </span><span class="koboSpan" id="kobo.668.2">In fact, we want to get the list of recipes from the service, but if the service fails for whatever reason, I don’t want my application to be frozen; I want to see a collection of zero elements (no elements), an empty table, or a list, and that is all. </span><span class="koboSpan" id="kobo.668.3">So, what we are going to do is use </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">catchError</span></strong><span class="koboSpan" id="kobo.670.1"> and return an empty Observable, which is our </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">fallback value.</span></span></p>
<p><span class="koboSpan" id="kobo.672.1">Our service will look </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.674.1">
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Recipe } from '../model/recipe.model';
import { environment } from 'src/environments/environment';
import { catchError, of } from 'rxjs';
const BASE_PATH = environment.basePath
@Injectable({
  providedIn: 'root'
})
export class RecipesService {
  recipes$ = this.http.get&lt;Recipe[]&gt;(
    `${BASE_PATH}/recipes`).pipe(
      catchError(()=&gt; of([])));
  constructor(private http: HttpClient) { }
}</span></pre> <p><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.675.1">This approach</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.676.1"> ensures that your application remains functional, displaying an empty list if you access the app. </span><span class="koboSpan" id="kobo.676.2">Moreover, you have the flexibility to customize the user interface by incorporating a message such as </span><strong class="bold"><span class="koboSpan" id="kobo.677.1">There are no recipes</span></strong><span class="koboSpan" id="kobo.678.1">. </span><span class="koboSpan" id="kobo.678.2">To implement this, we’ll make adjustments to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">recipes-list.component.html</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.680.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.681.1">
@if (recipes$ | async; as recipes) {
&lt;div class="card"&gt;
    &lt;div&gt;{{recipes.length}} Results&lt;/div&gt;
    &lt;p-dataView #dv [value]="recipes" [paginator]="true"
    [rows]="9" filterBy="name" layout="grid"&gt;
        &lt;ng-template let-recipes pTemplate="gridItem"&gt;
            &lt;div class="grid grid-nogutter"&gt;
                @for (recipe of recipes; track recipe.id) {
                    &lt;div class="col-12" class="recipe-grid-
                        item card"&gt;
                        /** Extra code here **/
                    &lt;/div&gt;
                } @empty {
                    &lt;div&gt;There are no recipes&lt;/div&gt;
                }
            &lt;/div&gt;
        &lt;/ng-template&gt;
    &lt;/p-dataView&gt;
&lt;/div&gt;
} @else {
    &lt;div&gt;There are no recipes&lt;/div&gt;
}</span></pre> <p><span class="koboSpan" id="kobo.682.1">As you may have noticed, we</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.683.1"> used the new built-in control flow mechanism explained in </span><a href="B21180_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.684.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.685.1">, </span><em class="italic"><span class="koboSpan" id="kobo.686.1">Fetching Data as Streams</span></em><span class="koboSpan" id="kobo.687.1">. </span><span class="koboSpan" id="kobo.687.2">By employing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">@else</span></strong><span class="koboSpan" id="kobo.689.1"> block to the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">if</span></strong><span class="koboSpan" id="kobo.691.1"> condition, we’re able to display the message when no value is emitted from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">recipes$</span></strong><span class="koboSpan" id="kobo.693.1"> Observable. </span><span class="koboSpan" id="kobo.693.2">Additionally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">@empty</span></strong><span class="koboSpan" id="kobo.695.1"> statement added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">@for</span></strong><span class="koboSpan" id="kobo.697.1"> statement allows us to show the same message when the list of recipes </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">is empty.</span></span></p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.699.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.700.1">In this chapter, we learned about the Observable contract and explored some of the most commonly used RxJS error handling strategies available and the different operators, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">catchError()</span></strong><span class="koboSpan" id="kobo.702.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">delayWhen()</span></strong><span class="koboSpan" id="kobo.704.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">retry()</span></strong><span class="koboSpan" id="kobo.706.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">retryWhen()</span></strong><span class="koboSpan" id="kobo.708.1">. </span><span class="koboSpan" id="kobo.708.2">We also shed light on the different strategies for error handling and when to choose each strategy. </span><span class="koboSpan" id="kobo.708.3">Finally, we handled the error in our Recipes Book app for the first </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">implemented feature.</span></span></p>
<p><span class="koboSpan" id="kobo.710.1">Now that we know how to handle errors in RxJS, let’s move on to the next reactive pattern: </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">combining streams.</span></span></p>
</div>
</body></html>