- en: <st c="0">2</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Using Jasmine and Karma to Test Angular Applications</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="54">Jasmine</st> <st c="62">and Karma</st> <st c="72">are two powerful
    tools that developers can use to test their Angular applications.</st> <st c="156">Testing
    is an essential part of the development process as it helps ensure that the application
    works as expected and avoids any potential bugs</st> <st c="300">or issues.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="310">Jasmine is a</st> **<st c="324">behavior-driven development</st>**
    <st c="351">(</st>**<st c="353">BDD</st>**<st c="356">) framework</st> <st c="368">for
    testing JavaScript code.</st> <st c="398">It provides a simple and readable syntax
    for writing tests, making it easier to understand and maintain the code.</st>
    <st c="512">With Jasmine, developers can define test suites and test cases, and
    then use various matchers to check the expected behavior of</st> <st c="640">their
    code.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="651">Karma, on the other hand, is a test runner that allows developers
    to execute their tests in multiple browsers and environments.</st> <st c="780">It
    provides a seamless integration with Jasmine, allowing developers to easily run
    their Jasmine tests in different browsers and get real-time feedback on the test
    results.</st> <st c="953">Karma also offers additional features, such as code
    coverage reporting and continuous</st> <st c="1039">integration support.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1059">Using Jasmine and Karma together can greatly enhance the testing
    process for Angular applications.</st> <st c="1159">Developers can write comprehensive
    test suites using Jasmine’s expressive syntax, and then use Karma to run these
    tests in various browsers, ensuring compatibility across different environments.</st>
    <st c="1354">This helps catch any potential issues or bugs early on and promotes
    a more robust and</st> <st c="1440">reliable application.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1461">In this chapter, we will look into the basics of using Jasmine
    and Karma for testing Angular applications.</st> <st c="1569">We will learn how
    to set up the testing environment, write unit tests with Jasmine, and configure
    Karma to run the tests in</st> <st c="1693">different browsers.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1712">The following topics will be covered in</st> <st c="1753">this
    chapter:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1766">Mastering Jasmine’s unit</st> <st c="1792">testing techniques</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1810">Writing your</st> <st c="1824">first unit tests in Angular related
    to</st> **<st c="1863">test-driven</st>** **<st c="1875">development</st>** <st
    c="1886">(</st>**<st c="1888">TDD</st>**<st c="1891">)</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1893">Utilizing code coverage and test result analysis</st> <st c="1942">with
    Karma</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1952">Technical requirements</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1975">To follow along with the examples and exercises in this chapter,
    you will need to have a basic understanding of Angular and TypeScript, as well
    as the following</st> <st c="2137">technical requirements:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2160">Node.js LTS and npm LTS installed on</st> <st c="2198">your computer</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2211">Angular 17 or later CLI</st> <st c="2236">installed globally</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2254">A code editor, such as Visual Studio Code, installed on</st> <st
    c="2311">your computer</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2324">The code files of this chapter can be found</st> <st c="2369">at</st>
    [<st c="2372">https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%202</st>](https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%202)<st
    c="2470">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2471">Mastering Jasmine’s unit testing techniques</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2515">In this section, we’ll explore the Jasmine framework by writing
    descriptive test suites, utilizing matchers, using spies for function testing,
    and testing asynchronous code.</st> <st c="2690">By leveraging these techniques,
    you can ensure the quality and reliability of your</st> <st c="2773">code base.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2783">What is Jasmine?</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="2800">Jasmine</st> <st c="2808">is a widely used testing framework for
    JavaScript that’s commonly employed for writing tests for web applications and
    Node.js projects.</st> <st c="2945">With its clean and expressive syntax, Jasmine
    allows developers to create easy-to-understand and maintainable test suites and
    cases.</st> <st c="3078">It offers built-in functionalities for assertions, test
    spies, and asynchronous testing.</st> <st c="3167">Jasmine seamlessly integrates
    with numerous libraries and frameworks, including AngularJS and React, enabling
    developers to compose comprehensive and dependable tests for JavaScript applications.</st>
    <st c="3363">Its popularity stems from its simplicity, flexibility, and ability
    to facilitate the creation of robust and reliable tests for</st> <st c="3490">JavaScript
    code.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3506">With Jasmine, developers can structure their tests using a BDD
    style, making it easy to write tests that are both descriptive and readable.</st>
    <st c="3647">It provides a set of built-in functions for assertions, which allow
    developers to verify the expected behavior of their code.</st> <st c="3773">These
    assertions cover a wide range of scenarios and make it simple to write tests that
    validate the correctness of the code</st> <st c="3898">being tested.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3911">Jasmine also includes features such as test spies, which enable
    developers to track function calls and arguments, as well as</st> <st c="4036">mock
    and stub function behavior.</st> <st c="4070">This helps in testing code that
    interacts with other components or</st> <st c="4137">external dependencies.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4159">Furthermore, Jasmine supports asynchronous testing, making it easy
    to write tests for code that involves asynchronous operations such as AJAX requests
    or timers.</st> <st c="4322">It provides mechanisms to handle asynchronous tasks
    and ensure that tests wait for completion before</st> <st c="4423">making assertions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4441">Jasmine is highly extensible and can be used in conjunction with
    various libraries and frameworks, such as AngularJS, Angular, and React.</st>
    <st c="4580">It integrates seamlessly with these ecosystems, allowing developers
    to write comprehensive and reliable tests for their</st> <st c="4700">JavaScript
    applications.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4724">Overall, Jasmine’s simplicity, flexibility, and</st> <st c="4773">comprehensive
    feature set have contributed to its popularity as a testing framework for JavaScript.</st>
    <st c="4873">It empowers developers to write robust and reliable tests, ultimately
    leading to higher-quality code and more</st> <st c="4983">confident deployments.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5005">Writing descriptive test suites</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="5037">One of the fundamental principles of effective unit testing is
    writing descriptive test suites.</st> <st c="5134">By logically organizing your
    tests and using descriptive names, you make it easier for yourself and other developers
    to understand the purpose and behavior of each test.</st> <st c="5304">In this
    section, we will explore strategies for creating meaningful test suite names and
    describing the expected behavior in clear and concise language.</st> <st c="5457">Additionally,
    we will discuss how descriptive test suites can serve as documentation for</st>
    <st c="5546">future reference.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5563">A descriptive test suite is</st> <st c="5592">a collection of related
    test cases that focuses on a specific functionality or component of your code.</st>
    <st c="5695">It serves as a documentation tool and helps developers understand
    the purpose and behavior of each test.</st> <st c="5800">Descriptive test suites
    are essential for maintaining code quality, facilitating collaboration among team
    members, and ensuring that tests remain relevant and up-to-date over time.</st>
    <st c="5981">By investing time in creating descriptive test suites, you can improve
    the maintainability and readability of your</st> <st c="6096">test code.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6106">Let’s consider a simple scenario where we have a JavaScript function
    called</st> `<st c="6183">calculateTotal</st>` <st c="6197">that calculates the
    total price of items in a shopping cart.</st> <st c="6259">We want to write a
    test to ensure that the function returns the correct total when given a set of
    items with their</st> <st c="6374">respective prices.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6392">Choosing meaningful names</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="6418">The first step in creating</st> <st c="6445">descriptive test suites
    is choosing meaningful names for your test suites and test cases.</st> <st c="6536">Use
    clear and concise language to describe the functionality or behavior being tested.</st>
    <st c="6623">Avoid ambiguous or generic names that don’t provide enough context.</st>
    <st c="6691">For example, instead of naming a test suite “Test Suite 1,” consider
    naming it “User Authentication Tests” to convey the purpose of the tests.</st>
    <st c="6834">Meaningful names make it easier for developers to locate specific
    tests and understand their purpose, even when revisiting the code base after a</st>
    <st c="6979">long time.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6989">Structuring test suites</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="7013">Organizing your</st> <st c="7029">test suites in a logical and
    hierarchical structure is crucial for creating descriptive test suites in Jasmine.</st>
    <st c="7142">A well-structured test suite mirrors the structure of your code base,
    making it easier to locate and understand specific tests.</st> <st c="7270">Group
    related tests together to improve readability and maintainability.</st> <st c="7343">For
    example, if you are testing a user authentication module, create a test suite
    specifically for login functionality and another for registration.</st> <st c="7492">This
    separation helps you isolate and focus on specific features, making it easier
    to identify and resolve issues.</st> <st c="7607">Additionally, consider using
    nested describe blocks to further organize your tests hierarchically.</st> <st
    c="7706">Here’s</st> <st c="7713">an example:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="7898">Writing clear and concise test descriptions</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="7942">Within each test</st> <st c="7960">case, write clear and concise
    descriptions that accurately describe the expected behavior.</st> <st c="8051">Use
    language that is easily understandable and avoids technical jargon whenever possible.</st>
    <st c="8141">A well-written test description should provide enough information
    for you and others to understand the purpose of the test without needing to dive
    into the implementation details.</st> <st c="8321">Consider using the “should”
    format to describe the expected behavior – for example, “should correctly calculate
    the total for a cart with multiple items.” By using descriptive language, future
    developers can quickly grasp the intent of the test and identify any deviations
    from the</st> <st c="8603">expected behavior.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8621">In addition to the test description, it is also helpful to include
    comments within the test code to provide further clarification or context where
    needed.</st> <st c="8777">These comments can explain the reasoning behind certain
    assertions or provide additional information about the test scenario.</st> <st
    c="8903">However, it is important to strike a balance and avoid excessive commenting
    that may clutter the</st> <st c="9000">test code.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9010">Maintaining and updating descriptive test suites</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="9059">Descriptive</st> <st c="9071">test suites are not a one-time effort
    but require ongoing maintenance and updates as the code base evolves.</st> <st
    c="9180">It is essential to review and update test suites regularly to ensure
    they remain relevant and accurate.</st> <st c="9284">When making changes to the
    code, developers should also update the corresponding tests to reflect the updated
    behavior.</st> <st c="9404">Additionally, if a test case becomes obsolete or redundant,
    it should be removed</st> <st c="9485">or refactored.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9499">When up</st><st c="9507">dating</st> <st c="9515">test suites,
    it is crucial to keep their descriptive nature intact.</st> <st c="9583">If a
    test case needs significant changes, it may be beneficial to create a new test
    case with an appropriate description instead of modifying the existing one.</st>
    <st c="9743">This helps maintain the clarity and transparency of the</st> <st
    c="9799">test suite.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9810">Let’s</st> <st c="9817">consider a simple scenario where we have
    a JavaScript</st> <st c="9871">function called</st> `<st c="9887">calculateTotal</st>`
    <st c="9901">that calculates the total price of items in a shopping cart.</st>
    <st c="9963">We want to write a test to ensure that the function returns the correct
    total when given a set of items with their</st> <st c="10078">respective prices:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <st c="10795">In the</st> <st c="10802">preceding example, we have created a
    test suite for</st> <st c="10855">the</st> `<st c="10859">calculateTotal</st>`
    <st c="10873">function.</st> <st c="10884">Within the test suite, we have two
    test cases, and the descriptions of the test cases clearly state what behavior
    is</st> <st c="11001">being tested:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11014">The first test case,</st> *<st c="11036">“should return 0 for
    an empty cart,”</st>* <st c="11072">verifies that the function correctly handles
    an empty shopping cart and returns a total</st> <st c="11161">of 0</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="11165">The second test case,</st> *<st c="11188">“should correctly calculate
    the total for a cart with multiple items,”</st>* <st c="11258">tests the function
    with a cart containing multiple items and checks if the calculated total is</st>
    <st c="11354">as expected</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="11365">By providing descriptive test case descriptions, other developers
    can easily understand the intent and behavior of each test.</st> <st c="11492">These
    descriptions act as documentation, making it easier to maintain and update the
    tests as the code</st> <st c="11595">base evolves.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11608">In the next section, we’ll look at how to write our first unit
    tests using</st> <st c="11684">TDD principles.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11699">Writing your first unit tests in an Angular project</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="11751">Unit testing</st> <st c="11764">is a critical aspect of Angular
    development that ensures code quality, reliability, and maintainability.</st>
    <st c="11870">TDD is</st> <st c="11877">a software development approach that emphasizes
    writing tests before implementing the actual code.</st> <st c="11976">In this
    section, you’ll learn how to write your first unit tests in an Angular project
    while following the principles of TDD.</st> <st c="12102">By leveraging the Jasmine
    testing framework and Angular’s testing utilities, developers can create effective
    and robust unit tests that verify the correctness of</st> <st c="12264">their
    code.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12275">We’ll be</st> <st c="12285">using the project we created in</st>
    [*<st c="12317">Chapter 1</st>*](B21146_01.xhtml#_idTextAnchor018) <st c="12326">to
    practice.</st> <st c="12340">Follow these</st> <st c="12352">steps to write your
    first</st> <st c="12379">unit test:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12389">Create a new component called</st> `<st c="12420">CalculatorComponent</st>`
    <st c="12439">by running the</st> <st c="12455">following command:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: import { ComponentFixture, TestBed } from '@angular/core/testing';
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: import { CalculatorComponent } from './calculator.component';
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: describe('CalculatorComponent', () => {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let calculator: CalculatorComponent;'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let fixture: ComponentFixture<CalculatorComponent>;'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: beforeEach(async () => {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: await TestBed.configureTestingModule({
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'declarations: [ CalculatorComponent ]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .compileComponents();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: fixture = TestBed.createComponent(CalculatorComponent);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: calculator = fixture.componentInstance;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: fixture.detectChanges();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '});'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it('should create', () => {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: expect(calculator).toBeTruthy();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '});'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '});'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="14000">Now, we’ll</st> <st c="14012">write the actual test case using
    the</st> `<st c="14049">it</st>` <st c="14051">function.</st> <st c="14062">In</st>
    <st c="14065">this case, we’ll test the</st> `<st c="14091">add</st>` <st c="14094">method
    of</st> `<st c="14105">CalculatorComponent</st>` <st c="14124">by passing it two
    numbers and expecting the result to be</st> `<st c="14182">5</st>`<st c="14183">.
    The</st> `<st c="14189">expect</st>` <st c="14195">function is used to define
    the expected behavior and check the actual result.</st> <st c="14274">The following
    code must be added to the test suite – that is, inside the</st> `<st c="14347">describe</st>`
    <st c="14355">function:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="14481">You will get an error in your code editor telling you that the</st>
    `<st c="14545">add</st>` <st c="14548">function</st> <st c="14558">doesn’t exist:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Code error](img/B21146_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="14684">Figure 2.1 – Code error</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14707">This is normal as it hasn’t been</st> <st c="14741">created yet.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14753">Upon</st> <st c="14758">returning to our Karma server, we’ll see
    that</st> <st c="14804">our test case isn’t displayed in</st> `<st c="14838">CalculatorComponent</st>`
    <st c="14857">and that in the terminal, we have an error related to the non-existence
    of the function and a message indicating that no test</st> <st c="14984">has succeeded.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14998">Don’t panic – it’s the red of TDD!</st> <st c="15034">Well done!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15044">Next, we will implement the</st> `<st c="15073">add</st>` <st
    c="15076">function in</st> `<st c="15089">calculator.component.ts</st>`<st c="15112">.
    Having defined our first test case, we can proceed to implement</st> `<st c="15178">calculator.component.ts</st>`
    <st c="15201">for the test to pass.</st> <st c="15224">Following the TDD approach,
    write the minimum amount of code necessary to pass</st> <st c="15303">the tests:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="15365">You’ll see the following result on your</st> <st c="15406">Karma
    server:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.2 – The test succeeded](img/B21146_02_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="15665">Figure 2.2 – The test succeeded</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15696">In your terminal, you will receive the</st> <st c="15736">following
    message:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – The test was executed successfully](img/B21146_02_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="15890">Figure 2.3 – The test was executed successfully</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15937">With that, we’re</st> <st c="15954">at the green stage of TDD
    and writing the</st> <st c="15997">minimum amount of code needed for our test
    to pass.</st> <st c="16049">Well done!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16059">Once the tests have passed, you can refactor the code to improve
    its design, readability, and maintainability.</st> <st c="16171">Refactoring is
    an essential step in the TDD process as it helps eliminate duplication and improves
    code structure and overall quality.</st> <st c="16306">It is essential to ensure
    that tests continue to run after refactoring.</st> <st c="16378">Regularly reviewing
    and updating tests as the code base evolves will help maintain the integrity and
    reliability of</st> <st c="16494">unit tests.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16505">In our example, we don’t need to refactor the test.</st> <st c="16558">Don’t
    worry – we’ll have the opportunity to do so in</st> [*<st c="16611">Chapter 3</st>*](B21146_03.xhtml#_idTextAnchor065)<st
    c="16620">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16621">In the next section, we’ll look at how to use code coverage and
    test result analysis</st> <st c="16707">with Karma.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16718">Utilizing code coverage and test result analysis with Karma</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="16778">Code coverage</st> <st c="16793">and test result analysis</st>
    <st c="16817">are essential aspects of the software development process.</st>
    <st c="16877">By measuring code coverage, developers can assess the effectiveness
    of their unit tests and identify areas that require additional testing.</st> <st
    c="17017">Karma, a popular testing framework in the JavaScript ecosystem, provides
    built-in support for code coverage and test result analysis.</st> <st c="17151">In
    this section, we’ll learn how to leverage Karma to measure code coverage, generate
    detailed reports, and analyze test results.</st> <st c="17281">By utilizing these
    features, developers can ensure comprehensive testing and improve the overall
    quality and reliability of</st> <st c="17405">their code.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17416">Before going any further, it’s worth noting that all the configurations
    we’ll be looking at are already present in our Angular project.</st> <st c="17553">When
    we create our project, Angular takes care of all</st> <st c="17607">the configuration.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17625">Here</st> <st c="17630">are</st> <st c="17634">the different</st>
    <st c="17648">steps</st> <st c="17655">Angular performs</st> <st c="17672">for
    us:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="17679">Step 1 – setting up Karma with</st>** **<st c="17711">code
    coverage</st>**<st c="17724">:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="17726">To</st> <st c="17729">utilize code coverage</st> <st c="17751">with
    Karma, start by</st> <st c="17771">installing</st> <st c="17782">the</st> <st
    c="17787">necessary dependencies:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: module.exports = function(config) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: config.set({
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '// ... reporters: [''progress'', ''coverage''],'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'coverageReporter: {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'dir: ''coverage/'','
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'reporters: ['
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{ type: ''html'', subdir: ''report-html'' },'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{ type: ''lcov'', subdir: ''report-lcov'' }'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // ... });
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`<st c="18860">coverage</st>` <st c="18868">directory to view the generated
    reports.</st> <st c="18910">Open the HTML report (</st>`<st c="18932">coverage/report-html/index.html</st>`<st
    c="18964">) in a web browser to visualize the code coverage details.</st> <st
    c="19024">The report highlights covered lines, uncovered lines, and overall coverage
    percentages.</st> <st c="19112">Additionally, the LCOV report (</st>`<st c="19143">coverage/report-lcov/lcov-report/index.html</st>`<st
    c="19187">) provides a more detailed breakdown of</st> <st c="19228">code coverage.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="19682">mocha-reporter</st>` <st c="19696">displays</st> <st c="19705">detailed
    information about test failures, including stack traces and error messages, whereas</st>
    `<st c="19799">junit-reporter</st>` <st c="19813">generates JUnit-style XML reports
    that can be consumed by CI tools for</st> <st c="19885">further analysis.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="19902">To integrate Karma with CI tools, configure the respective plugin
    or reporter in your Karma configuration file.</st> <st c="20015">For example,
    to generate JUnit reports for Jenkins, add the</st> `<st c="20075">karma-junit-reporter</st>`
    <st c="20095">plugin and configure</st> <st c="20117">it accordingly.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="20132">Step 4 – utilizing thresholds and</st>** **<st c="20167">quality
    gates</st>**<st c="20180">:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="20182">Karma</st> <st c="20187">allows developers to define thresholds</st>
    <st c="20226">and quality gates for code coverage and</st> <st c="20267">test
    results.</st> <st c="20281">By setting these thresholds, developers</st> <st c="20321">can
    establish the minimum requirements for code coverage and test success rates.</st>
    <st c="20402">This ensures that the code base maintains a certain level of quality
    and reduces the risk of shipping untested or poorly</st> <st c="20523">covered
    code.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="20536">To set thresholds for code coverage, update your Karma configuration
    file</st> <st c="20611">as follows:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="20800">In this</st> <st c="20809">example, the thresholds have been set</st>
    <st c="20847">to 80% for statements, branches, functions, and</st> <st c="20894">lines.</st>
    <st c="20902">If any of these thresholds are not</st> <st c="20936">met, Karma
    will report a failed</st> <st c="20969">test result.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="20981">Code coverage visualization</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="21009">In our project, we started by writing</st> <st c="21047">tests
    on</st> `<st c="21057">CalculatorComponent</st>`<st c="21076">. Now, we can see
    the code coverage using Karma.</st> <st c="21125">Let’s run the following command
    in our</st> <st c="21164">project’s terminal:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: <st c="21208">After executing the preceding command, we’ll observe the following</st>
    <st c="21276">three things:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21289">In the terminal, we’ll have the following, if all</st> <st c="21340">goes
    well:</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Test coverage in the terminal](img/B21146_02_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="21893">Figure 2.4 – Test coverage in the terminal</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21935">Karma launches our browser, showing us the various tests that
    were</st> <st c="22003">carried out:</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.5 – A successful test](img/B21146_02_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="22376">Figure 2.5 – A successful test</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22406">A</st> `<st c="22409">coverage</st>` <st c="22417">folder</st>
    <st c="22424">is created in our</st> <st c="22443">project’s arborescence:</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.6 – The test coverage folder](img/B21146_02_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="22644">Figure 2.6 – The test coverage folder</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22681">Inside is an</st> `<st c="22695">index.html</st>` <st c="22705">file.</st>
    <st c="22712">When we launch the file in the browser, we’ll see a table summarizing
    all the files tested, and in each file, we’re told how much of a given piece of
    code has</st> <st c="22871">been tested.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22883">The following</st> <st c="22898">screenshots show</st> <st c="22915">test
    coverage:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Test coverage visualization on the web – part 1](img/B21146_02_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="23233">Figure 2.7 – Test coverage visualization on the web – part 1</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Test coverage visualization on the web – part 2](img/B21146_02_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="23574">Figure 2.8 – Test coverage visualization on the web – part 2</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Test coverage visualization on the web – part 3](img/B21146_02_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="24073">Figure 2.9 – Test coverage visualization on the web – part 3</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Test coverage visualization on the web – part 4](img/B21146_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="24435">Figure 2.10 – Test coverage visualization on the web – part 4</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Test coverage visualization on the web – part 5](img/B21146_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="25038">Figure 2.11 – Test coverage visualization on the web – part 5</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25099">By utilizing code</st> <st c="25117">coverage and test result
    analysis with Karma, developers can enhance their testing practices and ensure
    comprehensive code coverage.</st> <st c="25251">Karma’s built-in support for code
    coverage enables developers to measure the effectiveness of their tests and identify
    areas that require additional attention.</st> <st c="25411">Additionally, Karma’s
    test reporting and integration capabilities allow for deeper analysis of test
    results, enabling developers to track the health of their test suite and identify
    patterns in test failures.</st> <st c="25620">By setting thresholds and quality
    gates, developers can establish minimum requirements for code coverage and test
    success rates, ensuring a higher level of code quality</st> <st c="25789">and
    reliability.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25805">Summary</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="25813">This chapter covered how to set up the testing environment, write
    unit tests with Jasmine, and configure Karma to run the tests in different browsers.</st>
    <st c="25965">Jasmine and Karma are powerful tools for testing Angular applications.</st>
    <st c="26036">Jasmine is a BDD framework that provides an intuitive syntax for
    writing test cases.</st> <st c="26121">Karma, on the other hand, is a test runner
    that allows you to execute tests in various environments and provides features
    such as code coverage and test</st> <st c="26274">result analysis.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26290">To use Jasmine and Karma to test Angular applications, you need
    to set up the testing environment by installing the necessary dependencies and
    configuring Karma.</st> <st c="26453">Jasmine provides a rich set of matchers
    and assertions to validate the behavior of Angular components, services, and directives.</st>
    <st c="26582">You can create test suites and test cases to cover different scenarios</st>
    <st c="26653">and expectations.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26670">Karma allows you to run tests in real browsers or headless environments,
    making it easy to simulate user interactions and test the application’s behavior
    across different platforms.</st> <st c="26853">It also provides support for code
    coverage, generating reports that help identify areas of the code base that require</st>
    <st c="26971">additional testing.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26990">By using Jasmine and Karma together, you can write complete unit
    tests for your Angular applications and practice the principles</st> <st c="27120">of
    TDD.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27127">In the next chapter, we’ll learn how to write effective unit tests
    for Angular components, services,</st> <st c="27229">and directives.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="0">Part 2: Writing Effective Unit Tests</st>'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="37">In this part, you’ll write unit tests for components, services, and
    directives, using pipes, forms, and reactive programming while respecting</st>
    <st c="180">TDD principles.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="195">This part has the</st> <st c="214">following chapters:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[*<st c="233">Chapter 3</st>*](B21146_03.xhtml#_idTextAnchor065)<st c="243">,</st>
    *<st c="245">Writing Effective Unit Tests for Angular Components, Services, and
    Directives</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="322">Chapter 4</st>*](B21146_04.xhtml#_idTextAnchor108)<st c="332">,</st>
    *<st c="334">Mocking and Stubbing Dependencies in Angular Tests</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="384">Chapter 5</st>*](B21146_05.xhtml#_idTextAnchor200)<st c="394">,</st>
    *<st c="396">Testing Angular Pipes, Forms, and Reactive Programming</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
