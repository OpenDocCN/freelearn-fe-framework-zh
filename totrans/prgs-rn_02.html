<html><head></head><body>
		<div id="_idContainer011">
			<h1 id="_idParaDest-28" class="chapter-number"><a id="_idTextAnchor030"/>2</h1>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor031"/>Understanding the Essentials of JavaScript and TypeScript</h1>
			<p>Since React Native apps are written in JavaScript, it is important to have a very good understanding of this language to build high-quality apps. JavaScript is very easy to learn, but very hard to master, because it allows you to do nearly everything without giving you a hard time. However, just because you can do everything does not mean that you should. </p>
			<p>The overall goal of this chapter is to show important underlying concepts for avoiding the most common mistakes, bad patterns, and very expensive <em class="italic">don’ts</em>. You will get useful tips, learn best practices, and repeat the most important basics to use JavaScript in your apps. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Exploring modern JavaScript</li>
				<li>JavaScript knowledge for React Native development</li>
				<li>Working with asynchronous JavaScript</li>
				<li>Using typed JavaScript</li>
			</ul>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor032"/>Technical requirements</h1>
			<p>There are no technical requirements except a browser to run the examples of this chapter. Just go to <a href="https://jsfiddle.com/">https://jsfiddle.com/</a> or <a href="https://codesandbox.io/">https://codesandbox.io/</a> and type and run your code.</p>
			<p>To access the code for this chapter, follow this link to the book’s GitHub repository: </p>
			<p>This chapter is not a complete tutorial. If you are not familiar with the JavaScript basics, please have a look at <a href="https://javascript.info">https://javascript.info</a>, which is the JavaScript tutorial I would recommend to start.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor033"/>Exploring modern JavaScript</h1>
			<p>When we<a id="_idIndexMarker032"/> speak of modern <strong class="bold">JavaScript</strong>, this refers to ECMAScript 2015 (which also is known as ES6) or newer. It contains<a id="_idIndexMarker033"/> a lot of useful<a id="_idIndexMarker034"/> features, which are not included<a id="_idIndexMarker035"/> in older JavaScript versions. Since 2015 there has been an update to the specification released every year.</p>
			<p>You can have a look at the features that were implemented in previous releases in the TC39 GitHub repository (<a href="https://bit.ly/prn-js-proposals">https://bit.ly/prn-js-proposals</a>). You can also find a lot of information about upcoming features and release plans there.</p>
			<p>Let’s start our journey to understand the most important parts of JavaScript by having a look under the hood. To truly understand modern JavaScript and the tooling around it, we have to take a little look at the basics and the history of the language. JavaScript is a script language, which can run nearly everywhere.</p>
			<p>The most common use case clearly is building dynamic frontends for the web browser, but it also runs on the server (Node.js), as part of other software, on microcontrollers, or (most importantly for us) in apps. </p>
			<p>Every place where JavaScript runs has to have a JavaScript engine, which is responsible for executing the JavaScript code. In older browsers, the engines were only simple interpreters that transformed the code to executable bytecode at runtime without any optimizations.</p>
			<p>Today there is a lot of optimization going on inside the different JS engines, depending on which metrics are important for the engine’s use case. The Chromium V8 engine, for example, introduced just-in-time compilation, which resulted in a huge performance boost while executing JavaScript.</p>
			<p>To be able to have a common understanding of what JavaScript is on all those platforms and between all those engines, JavaScript <a id="_idIndexMarker036"/>has a standardized specification called ES. This specification is constantly evolving as more and more features (such as improved asynchrony or a cleaner syntax) are introduced to JavaScript. </p>
			<p>This constantly evolving feature set is awesome for developers but introduced a big problem. To be able to use the new features of the ES language specification, the JavaScript engine in question has to implement the new features and then the new version of the engine has to be rolled out to all users.</p>
			<p>This is a big problem especially when it comes to browsers, since a lot of companies rely on very old browsers for their infrastructure. This would make it impossible for developers to use the new features for years. </p>
			<p>This is where<a id="_idIndexMarker037"/> transcompilers such as Babel (<a href="https://babeljs.io">https://babeljs.io</a>) come into play. These transcompilers convert modern JavaScript into a backward-compatible version, which can be executed by older JavaScript engines. This transcompilation is an important step of the build process in modern web applications as well as in React Native apps.</p>
			<p>When writing modern JavaScript<a id="_idIndexMarker038"/> applications, it works like this:</p>
			<ol>
				<li>You write your code in modern JavaScript.</li>
				<li>A transcompiler converts your code to pre-ES6 JavaScript.</li>
				<li>A JavaScript engine interprets your code and transforms it into bytecode, which is then executed on the machine.</li>
				<li>Modern JavaScript engines optimize execution with features such as just-in-time compilation.</li>
			</ol>
			<p>When it comes to React Native, you can choose from different JavaScript engines with different strengths and weaknesses. You can read more on this in <a href="B16694_08.xhtml#_idTextAnchor268"><em class="italic">Chapter 8</em></a>, <em class="italic">JavaScript Engines and Hermes</em>.</p>
			<p>In this section, you learned<a id="_idIndexMarker039"/> what modern JavaScript is and how it works under the hood. Let’s continue with the specific parts of JavaScript required when developing with React Native.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor034"/>Exploring JavaScript for React Native development</h1>
			<p>In this section, you will learn some<a id="_idIndexMarker040"/> basic JavaScript concepts, all of which<a id="_idIndexMarker041"/> are important to truly understand how to work with React Native. Again, this is not a complete tutorial; it includes only the most important things that you have to keep in mind if you don’t want to run into errors that are very hard to debug. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When you are not sure<a id="_idIndexMarker042"/> how JavaScript behaves in a special scenario, just create<a id="_idIndexMarker043"/> an isolated example an<a id="_idTextAnchor035"/>d try it on <a href="https://jsfiddle.com/">https://jsfiddle.com/</a> or <a href="https://codesandbox.io/">https://codesandbox.io/</a>.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor036"/>Understanding the assigning and passing of objects</h2>
			<p>Assigning or passing data<a id="_idIndexMarker044"/> is one of the most<a id="_idIndexMarker045"/> basic operations in any programming language. You do it a lot in every project. When working with JavaScript, there is a difference when working with primitive types (Boolean, number, string, and so on) or with objects (or arrays, which are basically objects).</p>
			<p>Primitives are assigned and passed by values, while objects are assigned and passed by references. This means for primitives, a real copy of the value is created and stored, while for objects, only a new reference to the same object is created and stored.</p>
			<p>This is important to keep in mind, because when you edit an assigned or passed object, you also edit the initial object. </p>
			<p>This will be clearer in the following code example:</p>
			<pre class="source-code">
function paintRed(vehicle){
     vehicle.color = '￼red￼›;
}
const bus = {
     color: 'blue'
}
paintRed(bus);
console.log(bus.color); // red</pre>
			<p>The <strong class="source-inline">paintRed</strong> function<a id="_idIndexMarker046"/> does not return anything and we do not write anything in <strong class="source-inline">bus</strong> after initializing <a id="_idIndexMarker047"/>it as a blue bus. So, what happens? The <strong class="source-inline">bus</strong> object is passed as a reference. This means the <strong class="source-inline">vehicle</strong> variable in the <strong class="source-inline">paintRed</strong> function and the <strong class="source-inline">bus</strong> variable outside of the function reference the same object in storage.</p>
			<p>When changing the color of <strong class="source-inline">vehicle</strong>, we change the color of the object that is also referenced by <strong class="source-inline">bus</strong>.</p>
			<p>This is expected behavior, but you should avoid using it in most cases. In larger projects, code can get very hard to read (and debug) when objects are passed down a lot of functions and are then changed. As Robert C. Martin already wrote in the book <em class="italic">Clean Code</em>, functions should have no side effects, which means they should not change values outside of the function’s scope.</p>
			<p>If you want to change an object in a function, I recommend using a return value in most cases. This is much easier to understand and read. The following example shows the code from the previous example, but without side effects:</p>
			<pre class="source-code">
function paintRed(vehicle){
const _vehicle = { ...vehicle }
     _vehicle.color = 'red'
return _vehicle;
}
let bus = {
     color: 'blue'
}
bus = paintRed(bus); 
console.log(bus.color); // red</pre>
			<p>In this code example, it is absolutely clear that <strong class="source-inline">bus</strong> is a new object, which was created by the <strong class="source-inline">paintRed</strong> function. </p>
			<p>Please keep this in mind<a id="_idIndexMarker048"/> when working on your<a id="_idIndexMarker049"/> projects. It really can cost you a lot of time when you have to debug a change in your object, but you don’t know where it’s coming from.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor037"/>Creating real copies of an object</h2>
			<p>A very common problem<a id="_idIndexMarker050"/> that results from the previous point is that you have to clone an object. There are multiple ways to do that, each with different limitations. Three options are shown in the following code example:</p>
			<pre class="source-code">
const car = {
color: 'red',
       extras: {
            radio: "premium",
            ac: false
       },
       sellingDate: new Date(),
         writeColor: function() {
           console.log('This car is ' + this.color);
}
};
const _car = {...car};
const _car2 = Object.assign({}, car);
const _car3 = JSON.parse(JSON.stringify(car));
car.extras.ac = true;
console.log(_car);
console.log(_car2); 
console.log(_car3);</pre>
			<p>We create an object with different types as properties. This is important, because the different ways to clone the object will not work for all properties. We use a string for <strong class="source-inline">color</strong>, an object for <strong class="source-inline">extras</strong>, a date for <strong class="source-inline">sellingDate</strong>, and a function in <strong class="source-inline">writeColor</strong> to return a string with the color of the car.</p>
			<p>In the next lines, we use three different ways to clone the object. After creating the <strong class="source-inline">_car</strong>, <strong class="source-inline">_car2</strong>, and <strong class="source-inline">_car3</strong> cloned objects, we change <strong class="source-inline">extras</strong> in the initial <strong class="source-inline">car</strong> object. We then log all three objects. </p>
			<p>We will now have a detailed look at the different options regarding how to clone objects in JavaScript. These are the following: </p>
			<ul>
				<li>Spread operator and <strong class="source-inline">Object.assign</strong></li>
				<li><strong class="source-inline">JSON.stringify</strong> and <strong class="source-inline">JSON.parse</strong></li>
				<li>Real deepclone</li>
			</ul>
			<p>We’ll start with<a id="_idIndexMarker051"/> spread operator and <strong class="source-inline">Object.assign</strong>, which basically work the same way.</p>
			<h3>Spread operator and Object.assign</h3>
			<p>The three dots we use<a id="_idIndexMarker052"/> to create <strong class="source-inline">_car</strong> is called a <strong class="bold">spread operator</strong>. It returns all properties<a id="_idIndexMarker053"/> of the object. So basically, in line 13 we created a new object and populated it with all properties of <strong class="source-inline">car</strong>. In line 14, we did a very similar thing; we assigned all properties of <strong class="source-inline">car</strong> to a new empty object with <strong class="source-inline">Object.assign</strong>.</p>
			<p>In fact, lines 13 and 14 work<a id="_idIndexMarker054"/> the same way. They create a <strong class="bold">shallow clone</strong>, which means they clone all property values of the object. </p>
			<p>This works great for values, but it doesn’t for complex data types, because, again, objects are assigned by reference. So, these ways of creating a copy of a complex object only clone the references to the data of the properties of the object and don’t create real copies of every property.</p>
			<p>In our example, we wouldn’t create a real copy of <strong class="source-inline">extras</strong>, <strong class="source-inline">sellingDate</strong>, and <strong class="source-inline">writeColor</strong>, because the values of the properties in the <strong class="source-inline">car</strong> object are only references to the objects. This means that by changing <strong class="source-inline">_car.extras</strong> in line 17, we also change <strong class="source-inline">_car2.extras</strong>, because it references the same object.</p>
			<p>So these ways of cloning objects <a id="_idIndexMarker055"/>work fine for objects with just one level. As soon<a id="_idIndexMarker056"/> as there is an object with multiple levels, cloning with the spread operator or <strong class="source-inline">Object.assign</strong> can create serious problems in your application.</p>
			<h3>Stringify and parse again</h3>
			<p>A very common pattern<a id="_idIndexMarker057"/> to clone objects is to use the built-in <strong class="source-inline">JSON.stringify</strong> and <strong class="source-inline">JSON.parse</strong> features of JavaScript. This converts <a id="_idIndexMarker058"/>the object to a primitive type (a JSON string) and creates a new object by parsing the string again.</p>
			<p>This forces a <strong class="bold">deepclone</strong>, which means even sub-objects<a id="_idIndexMarker059"/> are copied by value. The downside of this approach is that it only works for values that have an equivalent in JSON.</p>
			<p>So, you will lose all functions, properties that are undefined, and values such as infinity that do not exist in JSON. Other things such as date objects will be simplified as strings, resulting in a lost time zone. So, this solution works great for deep objects with primitive values.</p>
			<h3>Real deepclone</h3>
			<p>When you want to create<a id="_idIndexMarker060"/> a real deepclone of an object, you have to get creative and write your own function. There are a lot of different approaches when you search the web. I would recommend using<a id="_idIndexMarker061"/> a well-tested and maintained library such as Lodash (<a href="https://lodash.com/">https://lodash.com/</a>). It offers a simple <strong class="source-inline">cloneDeep</strong> function, which does the work for you.</p>
			<p>You can use all solutions, but you have to keep in mind the limitations of every single approach. You should also have a look at the performance of the different solutions when you use them. In most cases, all cloning methods are fast enough to use, but when you’re experiencing performance issues in your application, you should have a closer look at which method you are using.</p>
			<p>Please find a summary<a id="_idIndexMarker062"/> in the following table:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B16694_02_01.jpg" alt="Figure 2.1 – Comparison of JavaScript cloning solutions&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Comparison of JavaScript cloning solutions</p>
			<p>Knowing how to clone objects in certain situations is very important, because using the wrong cloning technique can lead to errors that are very hard to debug. </p>
			<p>After understanding<a id="_idIndexMarker063"/> how to clone objects, let’s have a look at destructuring objects.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor038"/>Working with destructuring in JavaScript</h2>
			<p>Another thing you will need to do a lot when<a id="_idIndexMarker064"/> working with React Native is destructuring objects and arrays. Destructuring basically<a id="_idIndexMarker065"/> means <em class="italic">unpacking</em> the properties of objects or the elements of arrays. Especially when working with Hooks, this is something you have to know very well. Let’s start with arrays.</p>
			<h3>Destructuring arrays</h3>
			<p>Have a look at the following<a id="_idIndexMarker066"/> code example, which shows how an arra<a id="_idTextAnchor039"/>y<a id="_idTextAnchor040"/><a id="_idIndexMarker067"/> gets <a id="_idTextAnchor041"/>d<a id="_idTextAnchor042"/>estructured:</p>
			<pre class="source-code">
let name = ["John", "Doe"];
let [firstName, lastName] = name;
console.log(firstName); // John
console.log(lastName); // Doe</pre>
			<p>You can see an array with two elements. In the second line, we <em class="italic">destructure</em> the <strong class="source-inline">name</strong> array by assigning <strong class="source-inline">name</strong> to an array with two variables inside. The first variable gets assigned the first value of the array, and the second variable the second value. This can also be done with more than two values.</p>
			<p>Array destructuring is used, for example, every time you work with a <strong class="source-inline">useState</strong> Hook (more on this in <a href="B16694_03.xhtml#_idTextAnchor061"><em class="italic">Chapter 3</em></a><em class="italic">, Hello React Native</em>).</p>
			<p>Now that you know how to destructure an array, let’s go on to destructuring objects.</p>
			<h3>Destructuring objects</h3>
			<p>The following code example<a id="_idIndexMarker068"/> shows how to<a id="_idIndexMarker069"/> destructure an obj<a id="_idTextAnchor043"/>e<a id="_idTextAnchor044"/>ct:</p>
			<pre class="source-code">
let person = {
     firstName: "John", 
     lastName: "Doe",
     age: 33
}
let {firstName, age} = person;
console.log(firstName); // John
console.log(age); // 33</pre>
			<p>Object destructuring works the same way as destructuring arrays. But please note the curly brackets in line 6 of the code example. This is important when destructuring objects instead of arrays. You <em class="italic">can</em> get all properties of the object just by using the key in the destructuring, but you don’t have to use all properties. In our example, we only use <strong class="source-inline">firstName</strong> and <strong class="source-inline">age</strong>, but not <strong class="source-inline">lastName</strong>.</p>
			<p>When working with destructuring, you can also<a id="_idIndexMarker070"/> collect all the elements that weren’t specified<a id="_idIndexMarker071"/> during the destructuring. This is done with the spread operator, as described in the following section.</p>
			<h3>Using the spread operator during destructuring</h3>
			<p>The spread operator<a id="_idIndexMarker072"/> can be used as shown in the following<a id="_idIndexMarker073"/> code exa<a id="_idTextAnchor045"/>mple:</p>
			<pre class="source-code">
const person = {
     firstName: '￼￼￼n', 
     lastName: 'Doe',
     age: 33,
     height: 176
}
const {firstName, age, ...rest} = person;
console.log(firstName); // John
console.log(age); // 33
console.log(Object.keys(rest).length); // 2</pre>
			<p>When destructuring arrays or objects, you can use the spread operator to collect all elements that weren’t included in the destructuring. In the code example, we use <strong class="source-inline">firstName</strong> and <strong class="source-inline">age</strong> in the destructuring.</p>
			<p>All other properties, in this example <strong class="source-inline">lastName</strong> and <strong class="source-inline">height</strong>, are collected in a new object, the <strong class="source-inline">rest</strong> variable. This is used a lot in React and React Native, for example when passing properties (or props) down to components and destructuring these props. </p>
			<p>When you work with React or React Native, especially with functional components and Hooks, destructuring is something that you will use in every component. Basically, it is nothing more than <em class="italic">unpacking</em> the properties of an object or elements of an array. </p>
			<p>Now that we <a id="_idIndexMarker074"/>understand destructuring, let’s move<a id="_idIndexMarker075"/> on to another important topic – the <strong class="source-inline">this</strong> keyword and its scope in JavaScript. </p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor046"/>Understanding this in JavaScript</h2>
			<p>JavaScript<a id="_idIndexMarker076"/> has quite a unique behavior<a id="_idIndexMarker077"/> when it comes to the <strong class="source-inline">this</strong> keyword. It does not always refer to the function or scope where it is used. By default, <strong class="source-inline">this</strong> is bound to the global scope. This can be changed via implicit or explicit binding.</p>
			<h3>Implicit and explicit binding</h3>
			<p><strong class="bold">Implicit binding</strong> means that if a function<a id="_idIndexMarker078"/> is called as part<a id="_idIndexMarker079"/> of an object, <strong class="source-inline">this</strong> always refers to the object. <strong class="bold">Explicit binding</strong> means that you can bind <strong class="source-inline">this</strong> to another<a id="_idIndexMarker080"/> context. This<a id="_idIndexMarker081"/> is something that was used a lot in React and React Native to bind <strong class="source-inline">this</strong> in the handlers of class components. </p>
			<p>Please have a look at the following code example:</p>
			<pre class="source-code">
class MyClass extends Component{
       constructor( props ){
              this.handlePress = 
        <a id="_idTextAnchor047"/>          this.handlePress.bind(this);
       }
handlePress(event){
              console.log(this);
       }
render(){
              return (
                &lt;Pressable type="button" 
                     onPress={this.handlePress}&gt;
                     &lt;Text&gt;Button&lt;/Text&gt;
                &lt;/Pressable &gt;
              );
       }
}</pre>
			<p>In the preceding code, we bind the <strong class="source-inline">this</strong> value of the class explicitly to the <strong class="source-inline">handlePress</strong> function. This is necessary, because if we don’t do it, <strong class="source-inline">this</strong> would be implicitly bound to the object where it is called, which in this case would be anywhere in the <strong class="source-inline">Pressable</strong> component. Since we want to have access to the data of our <strong class="source-inline">MyClass</strong> component in our <strong class="source-inline">handlePress</strong> function in most cases, this explicit binding is needed. </p>
			<p>You can see this kind of code<a id="_idIndexMarker082"/> in a lot of applications, because for a long time<a id="_idIndexMarker083"/> it was the only method to access class<a id="_idIndexMarker084"/> properties from inside<a id="_idIndexMarker085"/> a function. This led to a lot of explicit binding statements in constructors, especially in larger class components. Fortunately, today there is a much better solution – arrow functions!</p>
			<h3>Arrow functions to the rescue</h3>
			<p>In modern JavaScript, there is another solution<a id="_idIndexMarker086"/> that makes this<a id="_idIndexMarker087"/> implicit/explicit binding redundant: <strong class="bold">arrow functions</strong>. This is a new syntax to define functions, which is not only shorter than the old way of declaring functions, but it also changes the way that the value of the <strong class="source-inline">this</strong> keyword is bound. Instead of writing <strong class="source-inline">function myFunction(param1){}</strong>, you simply write <strong class="source-inline">const myFunction = (param1) =&gt; {}</strong>.</p>
			<p>The important thing here is that arrow functions always use the lexical scope of <strong class="source-inline">this</strong>, which means they won’t rebind <strong class="source-inline">this</strong> implicitly. </p>
			<p>The following example shows how to use arrow functions to make explicit binding <a id="_idTextAnchor048"/>s<a id="_idTextAnchor049"/>tatements redundant:</p>
			<pre class="source-code">
class MyClass extends Component{
handlePress = (event) =&gt; {
              console.log(this);
       }
render(){
              return (
                &lt;Pressable type="button" 
                     onPress={this.handlePress}&gt;
                     &lt;Text&gt;Button&lt;/Text&gt;
    <a id="_idTextAnchor050"/>            &lt;/Pressable &gt;
              );
       }
}</pre>
			<p>As you can see, we use an arrow function to define <strong class="source-inline">handlePress</strong>. Because of this, we don’t have to do an explicit binding like in the code example before. We simply can use <strong class="source-inline">this</strong> inside the <strong class="source-inline">handlePress</strong> function to access states and props of other properties of our <strong class="source-inline">MyClass</strong> component. This makes the code easier to write, read, and maintain.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Please keep in mind that regular functions and arrow functions are not only syntactically different, but they also change the way <strong class="source-inline">this</strong> is bound.</p>
			<p>Understanding the scope of <strong class="source-inline">this</strong> is crucial to avoid costly errors such as undefined object references. When it comes to app development, these undefined object references can hard-crash your app. So, keep in mind the scope you are referring to when using the <strong class="source-inline">this</strong> keyword.</p>
			<p>These are the most important things you must truly understand when using JavaScript to develop large-scale applications. If you don’t, you will make costly errors. </p>
			<p>The next thing<a id="_idIndexMarker088"/> that is very important when<a id="_idIndexMarker089"/> developing apps with React Native is asynchronous programming.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor051"/>Working with asynchronous JavaScript</h1>
			<p>Because of the architecture<a id="_idIndexMarker090"/> of React Native (more on this in <a href="B16694_03.xhtml#_idTextAnchor061"><em class="italic">Chapter 3</em></a>, <em class="italic">Hello React Native</em>) and the<a id="_idIndexMarker091"/> typical use cases of apps, understanding asynchronous JavaScript is crucial. A typical example of an asynchronous call is a call to an API.</p>
			<p>In a synchronous world, after making the call, the application would be blocked until the answer from the API is received. This is, obviously, unexpected behavior. The application should respond to user interaction while it waits for the response. This means the call to the API has to be done asynchronously.</p>
			<p>There are multiple ways of working with asynchronous calls in JavaScript. The first one is callbacks.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor052"/>Exploring callbacks</h2>
			<p>Callbacks are the most basic<a id="_idIndexMarker092"/> way to work with asynchrony<a id="_idIndexMarker093"/> in JavaScript. I would recommend using them as little as possible, because there are better alternatives. But since a lot of libraries rely on callbacks, you have to have a good understanding of them. </p>
			<p>A callback<a id="_idIndexMarker094"/> is a JavaScript function A that is passed as an argument to another function B. At some point in function B, function A is called. This behavior is called a <strong class="bold">callback</strong>. The following code shows a simple callback example:</p>
			<pre class="source-code">
const A = (callback) =&gt; {
     console.log("function A called");
     callback();
} 
const B = () =&gt; {
     console.log("function B called");
}
A(B);
// function A called
// function B called</pre>
			<p>When you look at the code, function A is called. It logs some text and then calls the callback. This callback is the function passed to function A as a property when function A was called – in this example, function B.</p>
			<p>So, function B is called<a id="_idIndexMarker095"/> at the end of function A. Function B then logs some more text. As a result of this code, you will see two lines of text: first, the one logged<a id="_idIndexMarker096"/> by function A, and second, the one logged by function B.</p>
			<p>While callbacks can be a little hard to understand, let’s have a look at what’s happening under the hood.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor053"/>Understanding the implementation</h2>
			<p>To be able to truly understand<a id="_idIndexMarker097"/> callbacks, we’ll have to dig a little into the implementation of a JavaScript engine. JavaScript is single-threaded, so inside of the JavaScript code execution, asynchrony won’t be possible. The following figure shows the important parts of a JavaScript engine and how they work together to achieve asynchrony:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B16694_02_02.jpg" alt="Figure 2.2 – JavaScript engine asynchronous code execution&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – JavaScript engine asynchronous code execution</p>
			<p>Your commands<a id="_idIndexMarker098"/> will be pushed to the <strong class="bold">callstack</strong> and processed in a last-in, first-out order. To achieve asynchrony, JavaScript engines provide APIs that are called from within your JavaScript code. These APIs execute code on another thread. Most of these APIs expect a callback passed as an argument.</p>
			<p>When this code execution on the second thread<a id="_idIndexMarker099"/> is finished, this<a id="_idIndexMarker100"/> callback will be pushed to the <strong class="bold">message queue</strong>. The message queue is monitored by the <strong class="bold">event loop</strong>. As soon as the callstack is empty<a id="_idIndexMarker101"/> and the message queue is not, the event loop takes the first item of the message queue and pushes it on the callstack. Now we are back in our JavaScript context and the JavaScript code execution continues with the given callback.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor054"/>What’s better than callbacks? Promises!</h2>
			<p>With ES 2015, promises<a id="_idIndexMarker102"/> were introduced. Under the hood, they<a id="_idIndexMarker103"/> work quite similar to callbacks, except that there is another queue called a job or microtask queue. This queue works like the message queue but has a higher priority when getting processed by the event loop.</p>
			<p>The difference from callbacks is that promises have a much cleaner syntax. While you can pass any number of callbacks to a function, a promise returns a function with exactly one or two arguments – <strong class="source-inline">resolve</strong> and (optionally) <strong class="source-inline">reject</strong>. <strong class="source-inline">resolve</strong> is called when the promise is processed successfully, and <strong class="source-inline">reject</strong> if there was an error while processing the promise. </p>
			<p>The following code shows a generic example of a promise and how it is used:</p>
			<pre class="source-code">
const myPromise = () =&gt; new Promise((resolve) =&gt; {
     setTimeout(() =&gt; {
          resolve();
          }, 500);
});
console.log('start promise');
myPromise()
.then(() =&gt; {
     console.log('promise resolved');
});
// start promise
// -- 500ms delay
// promise resolved</pre>
			<p>The promise is created with <strong class="source-inline">new Promise</strong> and then called. Inside the promise, there is a 500 ms delay before the promise is resolved. When the promise is resolved, the function inside <strong class="source-inline">.then</strong> is called.</p>
			<p>One of the simplest examples<a id="_idIndexMarker104"/> of this asynchronous behavior using a promise is fetching <a id="_idIndexMarker105"/>data from a server. You can use the Fetch API in JavaScript. This API contacts the server and waits for an answer.</p>
			<p>As soon as the answer is received, <strong class="source-inline">resolve</strong> or <strong class="source-inline">reject</strong> is pushed to the queue and processed by the event loop. The following example shows the code for a simple fetch:</p>
			<pre class="source-code">
fetch("https://fakerapi.it/api/v1/texts?_quantity=1")
     .then(response =&gt; response.json())
     .then(data =&gt; {
          console.log(data);
     })
     .catch(error =&gt; {
          console.log(error); // handle or report the error
     })</pre>
			<p>This code example even contains two promises: </p>
			<ul>
				<li>The <strong class="source-inline">fetch</strong> operation, which returns the server response</li>
				<li>The unwrapping of the JSON data, which is included in the response</li>
			</ul>
			<p>If one of the promises is rejected, the <strong class="source-inline">catch</strong> block is called with some error information.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You should always catch your errors and promise rejections and handle – or at least report – them. While unhandled promise rejections don’t crash your application in most cases, it indicates that something went wrong. It can be very hard to realize and debug this error without proper error reporting in place. It is always a good idea to use reporting tools such as Sentry or Bugsnag. You can read more on this in <em class="italic">Chapter 14</em>, <em class="italic">Tips, Tricks, and Best Practices</em>. </p>
			<p>Promises also provide some interesting<a id="_idIndexMarker106"/> features such as <strong class="source-inline">Promises.all</strong> and <strong class="source-inline">Promises.first</strong>, which<a id="_idIndexMarker107"/> make it possible<a id="_idIndexMarker108"/> to work with multiple promises. If you want to learn more about this, you can have a look at <a href="http://bit.ly/prn-promises">bit.ly/prn-promises</a>.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor055"/>Improved syntax with async/await</h2>
			<p>With ES 2017, the <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> keywords<a id="_idIndexMarker109"/> were introduced to work<a id="_idIndexMarker110"/> with Promises. This is the syntax I recommend you use in your projects because it makes the code easy to read and understand. Instead of chaining <strong class="source-inline">.then</strong> with a callback function to the promise call, you can simply <strong class="source-inline">await</strong> the promise.</p>
			<p>The only requirement is that the function you write code in is declared as an async function. You can also wrap the call with a <strong class="source-inline">try/catch</strong> block. This is similar to <strong class="source-inline">.catch</strong> in the regular promise syntax. The following example shows how to work with <strong class="source-inline">async/await</strong> property:</p>
			<pre class="source-code">
const fetchData = async () =&gt; {
try {     
const response = await fetch(
"https://fakerapi.it/api/v1/texts?_quantity=1");
const data = await response.json();
console.log(data);
} catch (error) {
     console.log(error);
     }
}
fetchData();</pre>
			<p>We specify <strong class="source-inline">fetchData</strong> as an <strong class="source-inline">async</strong> function with the <strong class="source-inline">async</strong> keyword. Inside the async function, we use <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> for proper error handling. Inside the <strong class="source-inline">try</strong> block, we await the <strong class="source-inline">fetch</strong> call and the unpacking of the JSON body with the <strong class="source-inline">await</strong> keyword. </p>
			<p>Basically, every promise<a id="_idIndexMarker111"/> can be used with the async/await syntax. Also, an<a id="_idIndexMarker112"/> async function can be handled as a Promise with <strong class="source-inline">.then</strong> and <strong class="source-inline">.catch</strong>. Again, this is the syntax I would recommend for use in large-scale projects. Since it is compatible with Promises, you can use a lot of libraries with it out of the box. But when you have to work with a library that relies on promises in its API, you will have to patch it.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor056"/>Patching callback libraries</h2>
			<p>When working with React Native, you will find some libraries<a id="_idIndexMarker113"/> that work with callbacks<a id="_idIndexMarker114"/> in their JavaScript. This is because the transfer between the JavaScript and React Native contexts relies on callbacks in most cases. I would recommend patching these libraries and reworking them to provide a promise API, which you can then use with async/await in your project. This is quite simple and improves the code quality a lot. A very simple example is shown in the following code block:</p>
			<pre class="source-code">
// libraryFunction(successCallback, errorCallback);
const libraryFunctionPromise = new Promise((resolve, reject) =&gt; {
     libraryFunction(resolve, reject);
}</pre>
			<p>In this code example, we have a library that provides a function that expects a <strong class="source-inline">successCallback</strong> and an <strong class="source-inline">errorCallback</strong>. We create a promise, which just calls this function and passes <strong class="source-inline">resolve</strong> as <strong class="source-inline">successCallback</strong> and <strong class="source-inline">reject</strong> as <strong class="source-inline">errorCallback</strong>. That’s all, now we can work with async/await to call our promise, which then calls the library function for us.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Try to use async/await syntax over promises wherever possible. This makes your code easier to read and understand.</p>
			<p>In this section, you learned how asynchrony is implemented in JavaScript, how callbacks and promises work, and why you should rely on async/await, especially in large-scale projects. </p>
			<p>This leads to the last<a id="_idIndexMarker115"/> section of this chapter, which<a id="_idIndexMarker116"/> is also very important when working on large-scale projects – static type checking in JavaScript.</p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor057"/>Using typed JavaScript</h1>
			<p>JavaScript is a dynamically<a id="_idIndexMarker117"/> typed language. This means you can change the type of a variable after its initialization. While this can be very handy for small scripts, it can lead to difficult problems when working on large-scale projects. Debugging such errors, especially in apps with a lot of users, can get really messy.</p>
			<p>This is where extensions to JavaScript come into play. There are multiple solutions to extend JavaScript to be a typed language. This not only prevents errors; it also enables better refactoring and code completion as well as pointing out problems directly when writing the code.</p>
			<p>This speeds up the development process a lot. I would definitely recommend using typed JavaScript and I want to introduce the two most popular solutions here. </p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor058"/>Flow</h2>
			<p>Created and open sourced<a id="_idIndexMarker118"/> by Facebook, Flow is a static type checker that works<a id="_idIndexMarker119"/> with normal JavaScript. It was created as a command-line tool that scans your files for type safety and reports errors to the console. Nowadays, all common JavaScript IDEs have Flow support built in or offer it via excellent plugins. </p>
			<p>To enable static type checking with Flow, you just have to add the <strong class="source-inline">// @flow</strong> annotation to the top of your file. This tells the Flow type checker to include the file in the check. Then you can directly add your types behind the declaration of variables and parameters (inline), or you can declare more complex types and use these types to specify the type of a variable when it is declared.</p>
			<p>This is shown in the following code block:</p>
			<pre class="source-code">
type Person = {
     name: string,
     height: number, 
     age: number
}
let john: Person = {
     name: "John",
     height: 180, 
     age: 35
}</pre>
			<p>We created a <strong class="source-inline">Person</strong> type, which is then used to create a person, <strong class="source-inline">john</strong>. If we had missed one of the properties or had assigned a value with the wrong type, the Flow IDE integration would have given us an error. </p>
			<p>Since Flow<a id="_idIndexMarker120"/> isn’t a separate language but only a tool on top of JavaScript, we have<a id="_idIndexMarker121"/> to transform our files from Flow annotated files back to <em class="italic">normal</em> JavaScript files. This basically means, we have to use a transformer to remove all the Flow annotations from our files. Flow provides a Babel plugin for this, which has to be installed for your project to work.</p>
			<p>Flow can be configured via a <strong class="source-inline">.flowconfig</strong> file. Here you can define which files and folders should be checked and which shouldn’t, as well as specifying some options, such as how to deal with imports, but also how many workers Flow can start in parallel to check your code or how much memory Flow is allowed to use.</p>
			<p>If you want to have<a id="_idIndexMarker122"/> a deeper look at Flow, please visit the website at <a href="https://flow.org/">https://flow.org/</a>.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor059"/>TypeScript</h2>
			<p>Another option for typed<a id="_idIndexMarker123"/> JavaScript is <a id="_idIndexMarker124"/>TypeScript. It is an open source language on top of JavaScript that is developed and maintained by Microsoft. It also has awesome integrations for all common JavaScript IDEs and works very similar to Flow.</p>
			<p>Your TypeScript code will be transformed into plain JavaScript via the TypeScript transpiler or Babel, before you are able to execute it in production. Even the syntax of the annotations is nearly the same. The example code in the <em class="italic">Flow</em> section would work perfectly fine in TypeScript. </p>
			<p>If you want to have a deeper<a id="_idIndexMarker125"/> look at TypeScript, please visit the website at <a href="http://www.typescriptlang.org">www.typescriptlang.org</a>.</p>
			<p>In general, I prefer TypeScript over Flow, because<a id="_idIndexMarker126"/> it is used much more widely with much<a id="_idIndexMarker127"/> larger support from the community. The docs are better and so are the IDE integration and code completion. If you start a new project, I recommend going with TypeScript. But Flow is also a good solution. If you have a working Flow integration in your project, there is no need to migrate to TypeScript at the moment. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">If you work on a large-scale project, I would definitely recommend using Flow or TypeScript. Even if you have some overhead at the beginning, it will save you much more time and money in the end.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor060"/>Summary</h1>
			<p>In this chapter, we learned how modern JavaScript works, along with some especially important basics for when working with React Native, and how asynchrony works in JavaScript. You have acquired a basic understanding of the underlying technology, as well as how misuse can lead to costly errors and how to avoid them. </p>
			<p>In the next chapter, we will learn about React, how it works internally, and which parts of React it is important to know well when working with React Native.</p>
		</div>
	</body></html>