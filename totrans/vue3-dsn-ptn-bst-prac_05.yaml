- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Single-Page Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we continue to increase our skills in Vue 3 with the introduction
    of **single-page applications** (**SPAs**). We will learn what distinguishes them
    from regular websites and will dive into their key characteristics. To put this
    into action, we will build a new version of our To-Do application using the Vue
    Router and a different pattern of communication than the previous chapters. We
    will also learn authentication methods with code samples.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will know the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create SPAs with Vue 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to organize your application to make use of the Vue Router with different
    routing strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to reimplement our To-Do application with a practical application of different
    patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement different patterns of authentication in your SPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the previous chapter was somewhat heavy with foundational knowledge, from
    now onward, we center more on practical matters. Because of this, you will need
    access to the example applications to follow through.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub, at [https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter05](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://packt.link/RnAyz](https://packt.link/RnAyz)'
  prefs: []
  type: TYPE_NORMAL
- en: What is a SPA?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To explain what a SPA is, we should first explain how we interact with the **World
    Wide Web** (**WWW** or **W3**). When we enter an address in a web browser, we
    receive a web page sent by a web server. In the most basic form, a website is
    just a collection of pages, mostly what we call “static pages”. Static in this
    context means that the same files in the server are sent without modification.
    This makes a website very fast and secure. However, a purely static site does
    not offer much interactivity with the end user. Sometimes this is referred to
    as **Web 1.0**. Server and browser scripting came in to solve this limitation
    and gave birth to **multi-page applications** (**MPAs**). Pages could now be either
    static or dynamically generated on the server, which in turn could also receive
    calls for new pages with additional data that processes them and returns a new
    page in response. These new pages “generated on the fly” are called **dynamic**
    and made it possible to have applications. These technologies made it possible
    for blogs, services, and businesses to proliferate.
  prefs: []
  type: TYPE_NORMAL
- en: It was with the introduction of key technologies such as asynchronous communications
    (**AJAX**), more powerful JavaScript, local storage methodologies, increased network
    speeds, and computational power that we came to what is known as **Web 2.0**.
    It was now possible to load a single file into the browser and use JavaScript
    to take control of the entire interface and interactivity, producing rich and
    heavily interactive applications without generating new pages on the server. The
    SPA only contacts the server to load bits of data, the UI, and so on, as needed.
    It is now possible to migrate to web technologies what were traditional “desktop-only”
    applications, such as text editors, spreadsheets, rich email clients, graphic
    design suites, and so on. *Office 365*, *Google Docs*, *Photoshop online*, *Telegram*,
    *Discord*, *Netflix*, *YouTube*, and so on are good examples of SPAs. It is important
    to acknowledge that the introduction of SPAs does not invalidate the use of MPAs
    or make them obsolete—each has its utility in certain contexts. Most blogs and
    news sites today are, in fact, MPAs and still constitute a significant part of
    the internet. The most complex web applications today include a mixture of MPAs
    and SPAs, working together. SPAs can even be installed as hybrid applications
    on desktop and mobile devices. We will see how to implement this in [*Chapter
    6*](B18602_06.xhtml#_idTextAnchor148), *Progressive* *Web Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, with the explosion of distributed and decentralized computing,
    and smart blockchains, the technology that makes up SPAs has gained even more
    relevance. While not fully rooted in general use, this new era in web evolution
    is called **Web 3.0**. We will see in this chapter more about this topic, with
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the applications that we have made this far fall into the SPA category,
    even if we have not used their full potential yet. Vue 3 is specially designed
    to create these types of applications, and is one of the most relevant technologies
    for such an approach, together with *React*, *Angular*, *Svelte*, and others.
    But not everything is sugar, glitter, and rainbows. As with any technology, there
    are trade-offs to using SPAs. In the next table, we list some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Advantages** | **Disadvantages** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Faster and smarter loading times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local caching for improved performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rich UIs and interactivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier to develop and test than MPAs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More efficient use of code and templates, with less network communication (as
    compared to full-page re/loads)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Difficult for search engines to index or discover
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased load time and slower time for first interactivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.1 – Advantages and trade-offs for SPAs
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the list of advantages is by far more important than the disadvantages.
    You should consider using a SPA when the application requires significant user
    interactivity and real-time feedback. Now that we have a better idea of what a
    SPA is, let’s see the key concept at the core of their functionality: the application
    **router**.'
  prefs: []
  type: TYPE_NORMAL
- en: The Vue 3 router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vue is a great framework to build SPAs, but without a router, the task would
    soon become quite complex. The Vue router is an official plugin that takes over
    the navigation of the application and matches a URL to a component. This gives
    us the advantages of an MPA. With the router, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create and manage dynamic routes to components, matching parameters to props
    automatically if needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify routes (addresses and components) by name and trigger navigation by
    code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load components dynamically when needed, thus reducing the bundle size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a natural and logical way to approach website navigation and code splitting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control navigation with well-known events, before and after navigation occurred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create page transition animations in a way that is not possible with MPAs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of the Vue 3 router is simple and follows the same methodology
    as with other components of the ecosystem. Let’s take our project from [*Chapter
    4*](B18602_04.xhtml#_idTextAnchor102), *User Interface Composition with Components*,
    and modify it to use the Vue router.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When starting a new project, you may have noticed that the installer menu gives
    you the option to install the Vue router. If you have not selected this option,
    as we did in our example app, the installation afterward is quite simple. In a
    terminal, in the project directory, just execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will download and install the dependencies, just as with any other
    package in the `node_modules` directory. In order to use it in our application,
    we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create our routes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Link the routes to our components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include the router in our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set our templates where the router will display our components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As with much of the framework, the router does not specify in which directories
    or organization your routes should be placed, or your components for that matter.
    However, there is a convention that we will use that has become the de facto standard
    in the industry. In the `/src` folder, create the following directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/router` (or `/routes`): Here, we will have our JavaScript files with the
    routes for our application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/views`: This folder will contain the top-level components that match the
    application navigation (as a best practice)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these directories in place, we are ready to start modifying our application
    to include route navigation. Before that, let’s take a look at what we want to
    achieve with our router.
  prefs: []
  type: TYPE_NORMAL
- en: A new To-Do application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our new application will reuse the components to display our To-Do list, but
    also will accommodate the creation of multiple lists or projects. We will display
    a sidebar with all our projects, and when selecting them, the list will be updated11\.
    These projects will also be persisted in the browser, so we can come back to them
    later by using `localStorage`. We will then have a very simple navigation, with
    two top-level pages (components):'
  prefs: []
  type: TYPE_NORMAL
- en: A landing page where we can create new projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A project page where we can work with our to-do list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following these simple premises, our application once finished will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Our landing page](img/Figure_5.01_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Our landing page
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in *Figure 5**.1*, the landing page is also the place where
    we can create new projects. We use modal dialogs to collect user input, just as
    we did before. On the sidebar, we display a link to the **Home** page (the landing
    page) and a list with all the names of the different projects that we have created.
    When you click on each one, the route in the browser (URL) will update as well
    as the page, and we will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – A To-Do project page](img/Figure_5.02_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – A To-Do project page
  prefs: []
  type: TYPE_NORMAL
- en: You may recognize this last screenshot, as it is what our `ToDoProject.vue`
    component displays. As a matter of fact, it will require very little modification
    to reach this result. For now, let’s begin with the routes.
  prefs: []
  type: TYPE_NORMAL
- en: Routes’ definition and the Router object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create routes for our project, we need to first define them in their own
    module. In the `/router` directory, create an `index.js` file with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: /src/router/index.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We start our file by importing two constructors from the `vue-router` package,
    in line `//1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`createRouter`, which will create a router object that we can inject into our
    application as a plugin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createWebHashHistory`, which is a constructor that we will pass to our router
    object and indicates how it will manage the URL rewriting in the browser'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Web hash history` will display `#` (a numeral sign) in the URL and will indicate
    that all navigation points to a single file. All navigation and URL parameters
    will follow this sign. It is the easiest method and does not require any special
    configuration. However, the other available methods are **Web history** (also
    known as *HTML5 mode* or *pretty URLs*) and **Memory**. Web history does not use
    the hash notation, but does require a special server configuration. We will see
    how to accomplish this with examples in [*Chapter 10*](B18602_10.xhtml#_idTextAnchor224),
    *Deploying Your Application*. Memory mode does not modify the URL and is mostly
    used for web views (as in hybrid frameworks such as NW.js, Electron, Tauri, Cordova,
    Capacitor, and so on) and **server-side rendering** (**SSR**). For now, we will
    stay with the **Web hash** **history** method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In line `//2`, we import a component using the static notation, and we define
    a `routes` array with our routes. Each route is represented by an object with
    at least the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`path`: A string that represents the URL associated with the component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: A string that behaves like a unique ID for the route and that we can
    call programmatically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`component`: The component to render'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice how in line `//2` we import a static component, but in line `//3`, we
    use the dynamic import notation. This implies that the first route (named `"landing"`)
    will be included in the main bundle, but the second route ( in line `//3`, named
    `"project"`) will only be loaded the first time it is needed, from a separate
    bundle. Using routes, we can create a strategy for improving our application loading
    and bundle size.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in line `//4`, we create our `router` object using the constructor
    and passing an options object. Notice in line `//5` how we pass the `history`
    field a constructor for our chosen `history` method. We also pass our routes (obviously),
    and also as an example here, we create one of the possible *navigation guards*,
    to make sure that after navigating to each route, the window scrolls all the way
    to the top. Without this, we may encounter a strange side effect, with the scroll
    not changing between “*pages*." Navigation guards are triggered before and after
    a navigation event. They can be used in a multitude of situations, such as authentication
    control or data preloading. Please refer to the official documentation for a complete
    list of guards, with examples ([https://router.vuejs.org/guide/advanced/navigation-guards.html](https://router.vuejs.org/guide/advanced/navigation-guards.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our second route, we have also included a variant in the notation of the
    path, with the inclusion of a named parameter prefixed by a semicolon (`:id`).
    This route will match anything following `/project/` and assign it to a reactive
    variable, which we can access programmatically (we will see how this works later).
    The route also has an additional field, `props: true`. This indicates that the
    parameter named in the path will be automatically passed as a prop to the component
    if the component has defined a prop with the same name. This will become useful
    and apparent in the next sections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With our routes and router defined, it is time to import them into our `main.js`
    file and attach them to our application. The file will look now like this:'
  prefs: []
  type: TYPE_NORMAL
- en: /src/main.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Easy enough—it is now time to create components that are currently missing and
    adapt the ones we have. Before dealing with the code, let’s see which new components
    the router provides our application with.
  prefs: []
  type: TYPE_NORMAL
- en: Router template components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we include the router in the application, it injects into the global scope
    the following new components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RouterView`: This component provides the placeholder where the route components
    will be rendered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RouterLink`: Provides an easy way to link to routes; through the use of handy
    props and styles, we can control the appearance and final render element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Together with the router and routes definition, these two components in our
    template make it possible to offer navigation and better organize our code. Before
    we dig into their details, let’s see them in action in our application. Let’s
    start modifying our `App.vue` component to turn it into a layout container (styles
    omitted):'
  prefs: []
  type: TYPE_NORMAL
- en: App.vue
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we include a new component, `Sidebar`, which will contain the
    main navigation for our application. Then, we just place a single `<router-view>`
    component, where our router will render each page. When it comes to the styles,
    I will refer to the code in GitHub for the details. Now, it is time to create
    the `Sidebar` component in the `/src/components/Sidebar/Sidebar.vue` path and
    copy the code from the repository. There is a lot to see in this small file. Let’s
    start looking into the template and how we use the `RouterLink` instances. The
    first one is static and points to the landing page. Instead of just using a link
    or an anchor tag, we define the target of the link as an object where we reference
    the name of the route directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When this component is rendered, by default, it will become an anchor tag,
    and the `href` attribute will be dynamically converted to the appropriate route.
    If we change our route’s definition and give it another path, it won’t affect
    this code. It is a good practice to reference routes by their names, instead of
    by their URL. In the case that we need to pass some query string parameters to
    the URL, we can easily do it by passing an object with key/value members as a
    `params` attribute. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `params` attribute will be rendered as a URI with the `?text=abc`
    query string. As we mentioned, if the route has the `props` attribute active and
    the receiving component has defined a prop of the same name, the value will be
    automatically assigned. This is a situation that allows us to generate a list
    of links and pass to our project page the ID of each project, as you can see next
    in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we create a project on the landing page, we automatically assign a unique
    ID to each one, which we use in the previous code. Just as with other props, we
    can watch the changes and react by loading the respective To-Do items for each
    project. With that in mind, we modified the `ToDoProject.vue` file to define the
    prop (no need to define the type):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, we also set a watcher to detect changes with these lines in the `script`
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This watch receives a function that returns the `prop` attribute and then runs
    the `loadProject()` function. At this point, you may ask why we need to do this
    since each URL is different. The answer is that Vue and the router only load a
    component the first time it’s needed. As long as it remains in view, it doesn’t
    reload it and only updates reactive properties. Since our `script setup` code
    only runs during the first load, at the moment of creation, we need a way to detect
    changes to run non-reactive operations, such as loading the To-Do items for the
    project from `localStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can follow the rest of the changes in the repository. There is very little
    that changes in the components that work with the To-Do list, and that is the
    point of the encapsulation. Even the modification of `ToDoProject.vue` is small.
    However, there is one design decision that we need to point out: the use of the
    *pub/sub model* to keep the sidebar menu synchronized.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created a singleton with an event bus (`eventBus`). When we create
    a new project or delete it, we trigger an update event with this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We register the listening events in those components that need it during the
    *mounting* lifecycle event of the component, and we de-register it before is *unmounted*.
    In our case, we only need this in the `Sidebar` component, but we could have it
    anywhere in our application as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The name of the event is trivial and does not follow any convention. In this
    book, we prefix it with a numeral sign, as a personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: In previous implementations, as well as in the `ToDoProject.vue` component,
    we use the parent as the conduit to share information between sibling components,
    as we discussed previously. Here, we use another model, the *pub/sub pattern*,
    to avoid polluting the `App.vue` component with such a task. In [*Chapter 7*](B18602_07.xhtml#_idTextAnchor173),
    *Data Flow Management*, we will see other approaches for central state management.
    Let’s now take a closer look into more examples and details of using the router
    with more advanced scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Nested routes, named views, and programmatic navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This far, we have created static and dynamic routes, even with some parameters
    in the address. But the router can do even more than that. By using named routes,
    we can also create “sub-routes” and named “sub-views” to create deeper navigation
    trees and complex layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with an example. Suppose we have a data structure on three levels,
    and we want to reactively present this to the user in such a way that they can
    choose one level, and then “drill down” to the details. We also want to have this
    reflected in the URL, in such a way that we can share or reference the full case.
    The levels, in this case, would be country, state, and city. The UI would then
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – A selection using multiple named views and sub-routes](img/Figure_5.03_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – A selection using multiple named views and sub-routes
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can already guess from the screenshot, when the user selects the country,
    the state list is populated, and the URL is updated. When selecting a state, the
    city list is updated... and finally, when selecting the city, the information
    appears in the last column. You may have seen this method of navigation before.
    There are multiple ways to implement this, some more efficient than others. Our
    intent is to implement this as a learning exercise, so let’s start with the routes’
    definition. Here is a segment of our routes’ definition array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Nested routes’ definition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At first sight, you will notice that not much has changed, save for the inclusion
    of a new attribute on the route: `children[]`. This attribute receives an array
    of routes, which in turn can have other children, as we see in the previous code
    snippet. Children routes will be rendered in the `RouteView` component of their
    parents, and their paths will be concatenated with their parents as well, unless
    they start with the root (with a backslash).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To navigate to each route, we could use any of the methods recognized by the
    router. However, it is a good practice to use their names and pass any parameter
    or query string through an object, and let the router resolve the URL. As an example,
    see how in the `Directory.vue` component we use the `RouterLink` element:'
  prefs: []
  type: TYPE_NORMAL
- en: /src/views/Directory.vue component, lines 13-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have included our `RouterLink` component inside of a loop, to create as many
    links as needed based on our data. The target of the link is set to an object,
    where we pass the name of the route (`states`), and pass parameters respecting
    the route and props definition for the component. Notice that the path of the
    component has been defined as a parameter (it starts with a colon character—`:country`)
    and it also matches the props definition of the object in `State.vue`. This correlation
    is what enables the router to automatically pass the data for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you inspect the code, you will notice that in our smallest child component,
    the `City.vue` file, we define in our props both country and state. However, in
    the route definition, only one parameter appears: the state (`:state`). Nevertheless,
    when you run the example, you will notice that the prop is also populated. This
    happens because children components inherit, together with the URL path, all the
    parameters defined in the route of the parents. In this case, our component then
    also receives the `:country` parameter that was passed to the parent, even if
    it doesn’t show up in its specific route.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the application, you will see something similar to this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Nested routes example, with selections](img/Figure_5.04_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Nested routes example, with selections
  prefs: []
  type: TYPE_NORMAL
- en: Only two countries have been included from static files, for simplicity. In
    a real-life project, this data would be retrieved from a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have used until now “default” `RouteView` components, but the Vue router
    allows us to include multiple views in one component, by assigning them different
    names. We will only see the notation here, as the implementation is trivial. Consider
    a component with the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we give our routes an identification with the `name`
    attribute. We also have a view without a name, in which case it is considered
    the “default” view, or with the name `default` as well. To make use of this new
    layout, the routes’ definition changes slightly. In each definition now, we do
    not have a `component` attribute, but instead, a `components` (in plural) attribute
    that expects an object. Each field’s name in the object must match the names given
    to our `RouterView` components and be equal to an object. For the previous piece
    of code, the equivalent route definition would be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using this type of definition, we can create complex layouts, as we can also
    define sub-routes to make use of—for example—the header and sidebar from the parent
    and only render in the default view. We have an impressive number of possibilities
    for building dynamic UIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important topic that we must cover before moving to the next section is
    that of programmatic navigation. We have used thus far the new components provided
    by the router, but we can also trigger navigation directly from our JavaScript
    without having to rely on the user triggering an event. For this, the Vue Router
    provides us with two handy constructors to use in our components’ scripts: `useRoute`
    and `useRouter`. We import these constructors into our components with the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can imagine, `$route` provides us with information about the current
    route, while `$router` allows us to modify and trigger navigation events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$router` object provides several methods, of which the most often used
    are summarized in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `.``push()` | The most important method. It pushes a new URL into the web
    history and navigates to the corresponding component. It is the programmatic equivalent
    of using `RouterLink`. It accepts either a string with the URL to navigate or
    an object with optional attributes. Here are some examples for each accepted parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you can create complex routes by passing parameters and query strings.
    What is important to remember is that `.push` will update the navigation history
    in the browser. |
  prefs: []
  type: TYPE_NORMAL
- en: '| `.``replace()` | Replace the current navigation component, without modifying
    the URL. It accepts the same parameters as `.push`. |'
  prefs: []
  type: TYPE_TB
- en: '| `.``go()` | This method receives an integer number as a parameter and triggers
    navigation using the browser’s history. Positive numbers navigate forward and
    negative numbers go backward in the navigation history. Its most common use is
    for implementing a “go back” link in an application. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, these are the most commonly used methods and the ones you should
    have present. I can say that using these will cover the vast majority of regular
    necessities. A full list of methods available can be found in the official documentation
    and allow you to manage also edge cases that may arise. I encourage you to check
    them out, at least to be aware of them, at [https://router.vuejs.org/api/interfaces/Router.html](https://router.vuejs.org/api/interfaces/Router.html)#properties.
    Some of these edge cases could be: add and remove routes dynamically (`.addRoute()`
    and `.removeRoute()`), retrieve the registered routes (`.getRoutes()`), check
    whether a route exists before navigating to it (`.hasRoute()`), and so on. We
    will not use them, so it is not relevant to see them in detail here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, the `$route` object gives us information about the current path
    (URL) where our component is being rendered. As with the previous example, here
    is a list of the most commonly used attributes, and their function:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attributes** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `.``name` | Returns the current name of the route. |'
  prefs: []
  type: TYPE_TB
- en: '| `.``params` | Returns an object with the parameters provided with the path
    (URL). If these have been matched to props, the values may overlap. |'
  prefs: []
  type: TYPE_TB
- en: '| `.``query` | Returns an object with the decoded query string attached to
    the current path. |'
  prefs: []
  type: TYPE_TB
- en: '| `.``hash` | If any, it returns the path in the URL following and including
    the hash sign (`#`). |'
  prefs: []
  type: TYPE_TB
- en: '| `.``fullPath` | Returns a string with the full path of the route. |'
  prefs: []
  type: TYPE_TB
- en: In the examples of this book, we will use `.name()`, `.params()`, and `.query()`
    on more than one occasion, as they tend to be the most commonly used as well.
    A full list of methods and properties can be found in the official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Important notation differences
  prefs: []
  type: TYPE_NORMAL
- en: We have been using the `useRoute` and `useRouter` constructors in the Composition
    API with the `script setup` notation. In the Options API, there is no need to
    initialize these objects. Both are available automatically through `this.$route`
    and `this.$router`. Also, the `$route` and `$router` objects are available automatically
    in the template, when using the Composition API.
  prefs: []
  type: TYPE_NORMAL
- en: 'A full code example can be found in the GitHub repository, under `Chapter 5``/Nested
    Routes`, at this URL: [https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/chapter05](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to handle routes, parameters, and query strings, it is
    time to look into some common patterns for authentication in SPAs, since different
    paths (URLs) are necessary for many of them.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring authentication patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The power of SPAs becomes apparent when there is also a server behind them providing
    additional services. One such service is authentication. In most applications,
    there will be the need to identify users and provide additional services based
    on their rights, status, privacy, group, or any other category pertaining to the
    context of the application. A clear example of this is webmail applications, such
    as *Outlook* or *Gmail*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Current web standards provide us with several options to perform asynchronous
    communications with a server. These are often called `XMLHttpRequest` object for
    these network communications, but the new specifications provide us with a direct
    function, `fetch()`, which is more convenient and standard between browsers. While
    these methods are perfectly valid, for other uses than simple needs, it is better
    to use a library that provides more functionalities built on top of these technologies—for
    example, one that provides an `GET`, `POST`, `PUT`, `OPTIONS`, and `DELETE`) to
    easily consume **RESTful APIs** (where **REST** stands for **Representational
    State Transfer**, a type of architecture used in network communications). We will
    see more about this in [*Chapter 8*](B18602_08.xhtml#_idTextAnchor186), *Multithreading
    with Web Workers*. For now, just keep in mind that a library to handle network
    asynchronous communications is a better path. In our case, we will use the excellent
    **Axios** library ([https://axios-http.com/](https://axios-http.com/)), which
    you can install in your application with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in your service or component, you can import and use the library with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The library exposes methods to match each HTTP request (`.get()`, `.post()`,
    `.put()`, and so on), each one returning a promise that resolves to the result
    of the request or rejects it in the case of error.
  prefs: []
  type: TYPE_NORMAL
- en: With this introduction, we are ready to see some common patterns for authenticating
    users in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Simple username and password authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the simplest approach to authenticating users, where the validation
    of credentials is made by our implementation on the server. In this case, our
    server backend provides the API to validate a set of credentials, gathered by
    our SPA. Traditionally, the credentials are stored in the server, on a database,
    and the communication will be performed on top of **Secure Sockets Layer** (**SSL**)
    or encrypted communication, which are the same thing. Let’s see the workflow graphically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Simple username and password authentication](img/Figure_5.05_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Simple username and password authentication
  prefs: []
  type: TYPE_NORMAL
- en: 'In this workflow, the following occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: The SPA collects username and password values and transmits them to a specific
    endpoint in our server for authentication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server uses information stored in a database to validate the username and
    password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result of the operation is returned to the client SPA in response to their
    initial query (*1*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Even though *Figure 5**.5* shows the number of steps, consider that all this
    is done in just one network call and its reply. Developing the validation code
    on the server is beyond the scope of this book, but the code inside our service
    or Vue 3 component would look something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the implementation is quite straightforward and depends on our
    own logic and server API design. What is important to remember is to check the
    status of the response (everything between `200` and `299` is a success) and the
    data sent back by the server to act accordingly. Axios handles all the communication
    and data conversion for us (assuming our API receives and process JSON data).
  prefs: []
  type: TYPE_NORMAL
- en: In the case of success, we should save the result in our application state and
    allow access to the user accordingly, mostly by unlocking the navigation to private
    or restricted routes. We could apply this protection in a fair number of different
    ways, the most common being the use of navigation guards, the creation of dynamic
    routes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is perfectly valid, and commonly implemented by most applications.
    However, it has several drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: We are responsible for maintaining a database with usernames and passwords (encrypted,
    please!) and implementing the validation logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are legally responsible for handling the user data according to local legislation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are responsible for the entire security of the system, end to end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user has to remember or be responsible for their own credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should provide ways to handle edge cases, as well as user problems and credential
    retrievals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These drawbacks are in no way a deterrent, but huge bullet points to keep in
    mind if we go this way. One way or another, most applications need to have a way
    to authenticate users, which depends on their own logic and implementation since
    not all of our users (depending on the context) will be willing to use another
    form of authentication, as we will see next.
  prefs: []
  type: TYPE_NORMAL
- en: OpenID and third-party authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Beyond security concerns, a major issue when dealing with authentication is
    how easily these credentials are lost or mishandled by the end user. This happens
    to us all. The more services we access online, the larger the number of credentials
    a user needs to “remember." There are many different methods to tackle this issue,
    to reduce the load on the user in keeping track of all these usernames and passwords.
    One such standard is the **OpenID** protocol ([https://openid.net/](https://openid.net/)).
  prefs: []
  type: TYPE_NORMAL
- en: The OpenID protocol authenticates users without the need to share credentials
    (usernames and passwords) between sites. It is based on the workflow of the **OAuth
    2.0** protocol, which is used to securely shared information and resources without
    the need to use passwords as well. This is achieved by sharing tokens between
    the different actors. The standard for these communications is to use **JSON Web
    Tokens** (**JWTs**). There is a lot to unravel in this paragraph, so let’s see
    each one of these terms in a bit more detail so that we can better understand
    how this protocol works.
  prefs: []
  type: TYPE_NORMAL
- en: 'A JWT is a string that contains three sections, separated by a dot (`.`), and
    that have been encoded in Base64\. Each section then encodes a JSON object with
    the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Header`: This contains cryptographic information used to encode the token,
    such as the algorithm, the type of token (usually `JWT`), and in some cases even
    the type of data submitted in the payload.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Payload`: This object contains the information we want (need) to share, and
    is mostly “free format”, meaning that it can contain any `key:value` pair as needed.
    However, there are a few well-defined fields that can also be used, such as “`iat`”(`sub`”field,
    for subject).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Signature`: The signature is a string form by concatenating the encrypted
    string representations of the header and payload, expressed in Base64\. For the
    encryption, a secret key (a password) is used, only known to both the authenticating
    server and the website server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When a website in the workflow receives a token, it decodes and validates it
    using the secret key, using the same method as the issuer. If the signatures don’t
    match, then it is assumed that the token is corrupted or compromised, and it is
    rejected. A JWT can be intercepted and decoded by a third party, so this method
    acts as a failsafe against tampering. Let’s see an example of the creation of
    a token:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{"alg": "HS256", "typ": "JWT"}`. Here, we use the `HS256` algorithm and declare
    the type used as `JWT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{"sub":"1234567890","name":"Pablo` `D. Garaguso","iat":``1516239022}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`secret key`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the preceding information, a signature field is created with this formula
    (assuming we have a function that encrypts text using the HS256 algorithm):'
  prefs: []
  type: TYPE_NORMAL
- en: '`HMACSHA256(base64UrlEncode(header) + "." +` `base64UrlEncode` **(**`payload),"secret
    key")`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the resulting strings in Base64 encoding are concatenated again to
    give us a perfectly functional token. Also, notice how each section (header, payload,
    and signature) appears separated by a period (`.`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwi bmFtZSI6IlBhYmxvIEQuIEdhcmFndXNvIiwiaWF0IjoxNTE2MjM5MDIyfQ.mPr551``xpsCgmIzp8EZuSCoy7t7iQNpp_iGzIR14E_Jo`'
  prefs: []
  type: TYPE_NORMAL
- en: To test this token, you can use a service such as [https://jwt-decoder.com/](https://jwt-decoder.com/).
    To validate it, however, you will need to use the secret key. You can test this
    at [https://jwt.io](https://jwt.io), where you can also find more information
    about this standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the OpenID protocol, JWTs are used to transmit and validate information
    between parties, hence why is so important to understand this concept well. There
    are several workflows recognized by the protocol. Let’s see here a simplified
    representation of the **authorization code flow** ([https://openid.net/specs/openid-connect-core-1_0.html](https://openid.net/specs/openid-connect-core-1_0.html))
    of the protocol with all the actors, and then see the parts we need to implement
    this in our Vue 3 SPAs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – The OpenID authorization code flow in all its beauty](img/Figure_5.06_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – The OpenID authorization code flow in all its beauty
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, for this workflow to happen, we need three actors: 1) our SPA,
    handling multiple routes, 2) the authentication **service provider** (**SP**)
    server, and 3) our own backend server. It is possible to do the authentication
    and validation of our backend in the browser, then only needing two actors, but
    this is not recommended as it exposes the secret key in our JavaScript. The option
    is there, however, for embedded applications such as mobile apps where the user
    has no easy access to the page code (in hybrid applications).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement the workflow, the client (our application) must register
    with the authentication service. The process depends on each entity, but as a
    result, we will have registered the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A `client_id` identification string, unique to our application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `secret_key` value, which will be known only to the authentication server
    and our backend application. This will be used to encode and sign our tokens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A series of *endpoints* in the authentication server, and in our application
    where the user will be redirected in each step. Appropriate exchange of tokens
    will be done in these redirects as part of the query string in the URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, let’s see these steps in detail, and how to implement them in our Vue 3
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Step** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | The user needs to be authenticated, so we redirect them to the endpoint
    given to us by the authentication server. The query string needs to be included
    with the following (mandatory) fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`scope`: **openid**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`response_type`: **code**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`client_id`: The client identification given by the authentication server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redirect_uri`: The same address that we registered with the server where the
    user will be redirected upon successful authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state`: Any data or application state that we want to receive in return after
    the authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To prepare the redirection URL, we first create an object with the preceding
    fields and values, and use the `URLSearchParams` creator to create a query string
    (see [https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)):`const`
    `query_data={scope:"openid", ...},``query_string=new URLSearchParams(query_data).toString()`Next,
    we can use the location object to execute the redirection:`location.assign("https://auth_endpoint"
    + "?" +` `query_string)` |
  prefs: []
  type: TYPE_NORMAL
- en: '| 2 | On successful authentication, the authentication server will redirect
    the user to the endpoint that we registered as the receiver. The query parameters
    sent will depend on the result of the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Successful sign-in:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`code`: The `identity_token`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state`: Any data we sent to the server and want back. We can use this to redirect
    the user inside our application, for example.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unsuccessful sign-in:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`: An error code as specified by the protocol (`interaction_required`,
    `invalid_request_uri`, and so on).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | The redirect will trigger our application being loaded, and the router
    will render our designated component. In our script setup, we need to capture
    the query string passed to us, to be used later in the next step. One approach
    to do this without the use of third-party libraries is with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 3 | In this step, we just send the code received to our backend, which would
    mean implementing the `sendToServer()` function mentioned previously. Since now
    we are dealing with our own implementation, the way to do this is trivial. In
    this example, we are using Axios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we have sent to our server the `code_token` string
    and received from our server the `identity_token` string as response. We then
    go one step beyond and set the default headers for our application to use the
    standard `Authorization` header, with a `Bearer` token. From then on, our server
    only needs to check the headers and verify that the operation requested belongs
    to a valid user. |
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the validation of the tokens and *steps 4* and *5* go beyond the
    scope of this book, as we are focusing on Vue 3 applications. As you can see,
    the part that our SPA needs to handle is quite simple and does not really involve
    much code (some error checking was omitted for the sake of brevity).
  prefs: []
  type: TYPE_NORMAL
- en: There is a good number of syndicated authentication services, both free and
    paid, that we can implement in our application. Most common these days is to see
    badges redirecting users to use them, such as signing in with *Google*, *Facebook*,
    *Twitter*, *GitHub*, *Microsoft*, and so on. There are also meta-services that
    provide all the aforementioned providers inside well-packaged libraries, such
    as **Auth0** ([https://auth0.com/](https://auth0.com/), now part of **Okta**,
    [https://www.okta.com/](https://www.okta.com/)). When it comes to implementing
    this workflow, we are certainly not short of options.
  prefs: []
  type: TYPE_NORMAL
- en: Passwordless or one-time password (OTP) authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another solution to remove the use of credentials is to remove them altogether
    with passwordless access. The basic idea is to rely on the security of another
    system (email, mobile texts, authenticator apps, and so on) to validate the user.
    The process generates a time-sensitive “one-time use only” code and sends it to
    the user through the supporting system via the backend service. The frontend service
    (the application) awaits the right to be entered by the user in a determined time
    frame. For example, a common implementation is for the backend to send a text
    message to the user’s phone containing the code, which has to be entered into
    the application before the time expires.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a visual representation of this workflow, considering that the user
    has been registered with an email or phone number. These are supposed to be *well
    known*, meaning that the ownership has been verified:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Passwordless authentication based on email](img/Figure_5.07_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Passwordless authentication based on email
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding workflow, notice that the OTP code never reaches the web application
    until the user inputs it. The validation occurs in the backend, not in the frontend.
    This makes our application very simple, as it only needs to collect the email
    first and submit it to the server, and then wait for the specified time for a
    new input. In a service or component, using Axios, this code would look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have omitted the imports and the template, as at this
    point they should be trivial for the reader. Our template should have at least
    an input to collect the email of the user, and a second input to collect the OTP
    code, plus two buttons to trigger on click the `signInUser()` function and the
    `checkOTP()` function. The first one will pass the email to the backend, and wait
    for a reply with at least a time in seconds to wait, which we use to start a timer
    (it is always good to let the user know how much time they have to enter the code).
    Nowadays, for emails and text messages, the standard is 60 seconds. When this
    happens, we also hide the first input and then show the “OTP” input form. When
    the user enters the code and clicks `checkOTP()` function is activated, and we
    pass the code again to the server waiting for a reply. On success, we can redirect
    the user to a protected area according to our application logic. Considering the
    triviality of the template, it would be a good exercise for the reader to create
    the component and template by themself. Then, a possible solution can be found
    in the code examples, in the [*Chapter* *5*](B18602_05.xhtml#_idTextAnchor130)
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following a progressive approach to security, the next step is to join the
    previous approaches into a common new process: **two-factor authentication** (**2FA**),
    which we will see now.'
  prefs: []
  type: TYPE_NORMAL
- en: 2FA - Two Factors Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In 2FA, our application merges two or more of the previous approaches to validate
    a user. The key concept behind this method is that even a third party or simple
    username and password are not enough, and the user needs to have a “secondary
    factor” to be validated—for example, the use of a registered email, phone number
    (for SMS submission of codes), authentication apps (example: Google Authenticator),
    a USB device, a security card (with a chip or band reader), and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: The workflow is simple but does require more from our backend than from our
    frontend application. Once our SPA authenticates our user using any of the methods
    listed previously, a second request is triggered on the backend to submit the
    proper query to the security device. Let’s assume that our user receives an SMS
    from our server with a code. Our SPA will wait and collect this code during a
    specific time frame (usually, 60 seconds), and submit it to the backend to a specific
    endpoint. It is the server that then validates the code. In reality, this is like
    having two or multiple passwords, whose validation is made in cascade. Any step
    fails, and the entire operation is discarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a visualization of the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – A simplified view of our SPA and server interactions with 2FA](img/Figure_5.08_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – A simplified view of our SPA and server interactions with 2FA
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the simplified workflow, the process of validating a user
    with 2FA (as with passwordless and OTM methods) does not rely so much on the code
    or some specific cryptography but on the use of clever communication and data
    isolation. The data and validation process never leaves our server or could be
    visible to an end user, even if opening the code of our SPA. In a way, you can
    think of this workflow as the concatenation of an OpenID or credentials authentication,
    followed by an OTP implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Our application’s main responsibility is just to collect the bits of data that
    make up each step and relay them to the server. In between, we could change the
    route or update the interface, but this implementation is trivial, so we won’t
    see specific code here (you can see previously how to programmatically change
    a route, for example).
  prefs: []
  type: TYPE_NORMAL
- en: In general, 2FA is considered a “more secure method”, but it is not without
    its drawbacks, and it may not be the right fit for every application. For example,
    what happens if you know your username and password, but lose your secondary device
    (your mobile gets stolen, hacked, and so on)? Organizations that use this method
    often provide a way to recover your identity, often with expensive implementations
    (think of a bank and phone service). In the end, this method does apply one more
    layer of complexity in the authentication of users, and with it, another possible
    point of failure, ending with very frustrated users if not handled properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see next another authentication method that is gaining traction as the
    new kid on the block of authentication patterns: Web3 authentication.'
  prefs: []
  type: TYPE_NORMAL
- en: Web3 authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we dig into the topic, we need to define what **Web3** is. There seems
    to be some confusion as to the extent of the definition, so for our purposes,
    Web3 is believed to be the next iteration or evolution of the internet, where
    the processing power is done in decentralized and distributed servers, using blockchain
    technologies. The most well-known and popular applications of these technologies
    nowadays are cryptocurrencies, decentralized self-governing organizations, decentralized
    finances, play-to-earn games, distributed cloud storage, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: A **blockchain** is a ledger that is maintained by a network of distributed
    computers. Anything written to it is immutable, and publicly visible by anyone
    on the network. Some blockchains are “smart”, meaning that they can contain not
    only data but also run applications, much like any backend service. The frontend
    applications that connect to a blockchain are called **distributed applications
    (DApps**), which are, for the most part, *SPAs*. For this task, the Vue 3 framework
    is very well suited, as we have seen thus far. A DApp must connect with a backend
    server that is part of the target blockchain network. These types of servers are
    known as **nodes**. In some cases, the DApp can interact directly with the blockchain.
    Most, if not all, blockchains use cryptocurrencies to regulate operations and
    reward the contributing nodes supporting the network. Cryptocurrencies are logically
    assigned to a unique blockchain ID called a “wallet”. These wallets implement
    some very smart cryptographic techniques to validate each other when performing
    operations, through the use of public and private keys. A user may have many wallets.
    There are no emails or ways to recover lost keys in a blockchain, and each wallet
    is unique.
  prefs: []
  type: TYPE_NORMAL
- en: In order to resolve all this cryptographic signage and validation, and to make
    it easier for users, there are special plugins for browsers called “digital wallets,"
    as well as mobile application wallets that also implement web browsing. These
    applications hold the credentials and do the heavy lifting when dealing with the
    blockchain. There are, of course, numerous libraries to do the same tasks in pure
    JavaScript, but this goes beyond the scope of this book. What we will see next
    is how in our SPA, we can leverage the power of these technologies to identify
    a user, even automatically when visiting our application page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will focus mainly on the biggest smart blockchain, the Ethereum network,
    as an example. The same workflow with more or fewer steps applies to other networks
    using different SDKs, so the migration or incorporation of additional blockchains
    is not too far away from our examples. The basic conceptual workflow is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Import a library to connect to the network in our JavaScript, either through
    a library such as `web3js` ([https://www.npmjs.com/package/web3](https://www.npmjs.com/package/web3)),
    `ethjs``window.ethereum`
  prefs: []
  type: TYPE_NORMAL
- en: Using the `ethereum` object, we request the user to connect their wallet to
    our site and retrieve the selected wallet address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our application then can send to our backend the wallet ID (that is public)
    and use it as the unique ID for the user’s account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As just mentioned, we will use the object injected by **MetaMask** (https://metamask.io/)
    since it is one of the best-known browser wallets. In this case, here is the code
    that requests the current user’s wallet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: That’s it! The highlighted line prompts *MetaMask* to open a new window and
    request the user’s permission to connect their wallet to your web application,
    and then return a handy promise. If approved, the result will be an array of strings,
    where the first position is the wallet address for the current network. If rejected,
    an error will be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: With MetaMask, you can open the **Developer Tools** in the browser and type
    in one line the preceding code to test it.
  prefs: []
  type: TYPE_NORMAL
- en: Using `windows` object a new object called `.solana`. Check the documentation
    of your target blockchain to become acquainted with the details of each implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with each blockchain and the code thereof is beyond the scope of
    this book, so we will limit ourselves to identifying the user by their wallet
    address. Having obtained this identification, it is up to our application logic
    to store them for future reference, as it acts like the user ID.
  prefs: []
  type: TYPE_NORMAL
- en: There are also third-party solutions to authenticate and interact with multiple
    blockchains, and we should consider them before implementing our own solution.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we considerably improved our application and created a sound
    SPA with navigation using the Vue router. This is an important concept to segment
    our application and organize the work between the members of a development team.
    Fractioning our application following the navigation path makes development and
    maintenance easier to approach and better organized. We also learned several authentication
    standard patterns that we can consider for our applications, covering a good number
    of scenarios used today in the industry, from the very basic username and password,
    all the way to the new Web3 DApps. We also took time to understand how standard
    protocols such as OAuth work, as well as OTPs, and how these can be implemented
    for an extra layer of security as a second-factor authentication. All these skills
    are relevant and necessary for today’s web application standards.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we continue expanding our technical knowledge with the
    introduction of **progressive web** **applications** (**PWAs**).
  prefs: []
  type: TYPE_NORMAL
- en: Review questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have covered multiple different topics and introduced new concepts in this
    chapter. Use the following questions to solidify what you just learned:'
  prefs: []
  type: TYPE_NORMAL
- en: When is better to use a SPA instead of an MPA and vice versa?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the benefits of using a router in our SPA? Name at least three from
    your own analysis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you use views to define the layout of your application?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you access the parameters and query string passed to your route in your
    JavaScript?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are some common standard patterns to authenticate users?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are some security considerations when authenticating users in a SPA?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
