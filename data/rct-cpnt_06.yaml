- en: Chapter 6. Changing Views
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。更改视图
- en: In the previous chapter, we covered a bit about material design, and as a result,
    we split the login and page admin sections into different files. We stopped short
    of making the login redirect us to the page admin section.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了材料设计，因此我们将登录和页面管理部分分成了不同的文件。我们还没有将登录重定向到页面管理部分。
- en: In this chapter, you will learn how to change sections without reloading the
    page. We'll use this knowledge to create public pages for the website our CMS
    is meant to control.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何在不重新加载页面的情况下更改部分。我们将使用这些知识来创建我们 CMS 意图控制的网站的公共页面。
- en: We'll see how to work with the browser's address bar and location history. We'll
    also learn how to use popular libraries to abstract these things for us, so we
    can save time on writing boilerplate and concentrate on making our interfaces
    great!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将了解如何与浏览器的地址栏和位置历史记录一起工作。我们还将学习如何使用流行的库来抽象这些功能，这样我们就可以节省编写样板代码的时间，专注于使我们的界面更加出色！
- en: Location, location, location!
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位置，位置，位置！
- en: Before we can learn about alternatives to reloading pages, let's take a look
    at how the browser manages reloads.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解页面重新加载的替代方案之前，让我们看看浏览器是如何管理重新加载的。
- en: 'You''ve probably encountered the `window` object. It''s a global catch-all
    object for browser-based functionality and state. It''s also the default `this`
    scope in any HTML page:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经遇到了 `window` 对象。它是浏览器功能状态的全球通用对象。它也是任何 HTML 页面的默认 `this` 作用域：
- en: '![Location, location, location!](img/5268_06_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![位置，位置，位置！](img/5268_06_01.jpg)'
- en: We've even accessed `window` earlier. When we rendered to `document.body` or
    used `document.querySelector`, these properties and methods were called on the
    `window` object. It's the same as calling `window.document.querySelector`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至之前已经访问过 `window`。当我们渲染到 `document.body` 或使用 `document.querySelector` 时，这些属性和方法是在
    `window` 对象上被调用的。这和调用 `window.document.querySelector` 是一样的。
- en: 'Most of the time, `document` is the only property we need. That doesn''t mean
    it''s the only property useful to us. Try the following in the console:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，`document` 是我们需要的唯一属性。但这并不意味着它是我们唯一有用的属性。在控制台中尝试以下操作：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should see something similar to the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到以下类似的内容：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we were trying to work out which components to show based on the browser
    URL, this would be an excellent place to start. Not only can we read from this
    object, but we can also write to it:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们试图根据浏览器 URL 来确定要显示哪些组件，这将是一个绝佳的起点。我们不仅可以从这个对象中读取，还可以写入它：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Putting this in an HTML page or entering that line of JavaScript in the console
    will redirect the browser to [www.material-ui.com](http://www.material-ui.com).
    It's the same as clicking on a link to that website. And, if it's redirected to
    a different page (than the one the browser is pointing at), then it will cause
    a full page reload.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将此内容放入 HTML 页面或输入控制台中的那一行 JavaScript 代码，将使浏览器重定向到 [www.material-ui.com](http://www.material-ui.com)。这和点击该网站的链接是一样的。而且，如果它重定向到了不同的页面（而不是浏览器指向的页面），那么它将导致整个页面刷新。
- en: A bit of history
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一点历史
- en: So how does this help us? We're trying to avoid full page reloads, after all.
    Let's experiment with this object.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这如何帮助我们呢？毕竟，我们试图避免整个页面的刷新。让我们通过这个对象进行实验。
- en: Let's see what happens when we add something like `#page-admin` to the URL.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们在 URL 中添加类似 `#page-admin` 的内容时会发生什么。
- en: '![A bit of history](img/5268_06_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![一点历史](img/5268_06_02.jpg)'
- en: Adding `#page-admin` to the URL leads to the `window.location.hash` property
    being populated with the same. What's more, changing the hash value won't reload
    the page! It's the same as clicking on a link that had a hash in the `href` attribute.
    We can modify it without causing full page reloads, and each modification will
    store a new entry in the browser history.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `#page-admin` 添加到 URL 中会导致 `window.location.hash` 属性被填充相同的值。更重要的是，更改哈希值不会刷新页面！这和点击具有
    `href` 属性中哈希的链接是一样的。我们可以修改它而不会导致整个页面刷新，并且每次修改都会在浏览器历史记录中存储一个新的条目。
- en: Using this trick, we can step through a number of different states without reloading
    the page, and we will be able to backtrack each with the browser's back button.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个技巧，我们可以不重新加载页面地逐步通过多个不同的状态，并且我们将能够使用浏览器的后退按钮回退每个状态。
- en: Using browser history
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用浏览器历史记录
- en: 'Let''s put this trick to use in our CMS. First, let''s add a couple of functions
    to our `Nav` component:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的 CMS 中使用这个技巧。首先，让我们在我们的 `Nav` 组件中添加几个函数：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We add an `onClick` attribute to our navigation links. We created a special
    function that will change `window.location.hash` and prevent the default full
    page reload behavior the links would otherwise have caused.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给我们的导航链接添加了一个`onClick`属性。我们创建了一个特殊函数，该函数将改变`window.location.hash`并阻止链接可能引起的默认完整页面刷新行为。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is a neat use of the arrow functions, but we're ultimately creating three
    new functions in each render call. Remember that this can be expensive, so it's
    best to move the function creation out of render. We'll replace this shortly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对箭头函数的一个巧妙应用，但我们在每次渲染调用中实际上创建了三个新函数。记住，这可能会很昂贵，所以最好将函数创建移出渲染。我们很快就会替换它。
- en: It's also interesting to see template strings in action. Instead of `"#" + section`,
    we can use `'#${section}'` to interpolate the section name. It's not as useful
    in small strings, but becomes increasingly useful in large ones.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 看到模板字符串的实际应用也很有趣。我们不是使用`"#" + section`，而是可以使用`'#${section}'`来插入section名称。在短字符串中，这并不那么有用，但在长字符串中变得越来越有用。
- en: 'Clicking on the navigation links will now change the URL hash. We can add to
    this behavior by rendering different components when the navigation links are
    clicked on:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 点击导航链接现在会改变URL hash。我们可以通过在点击导航链接时渲染不同的组件来添加这种行为：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We've had to convert the `Nav` function to a `Nav` class. We want to create
    the redirect method outside of render (as that is more efficient) and also isolate
    the choice of which component to render.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不将`Nav`函数转换为`Nav`类。我们希望在渲染之外创建重定向方法（因为这样更高效），并且隔离渲染组件的选择。
- en: Using a class also gives us a way to name and reference the `Nav` component,
    so we can create a new instance to overwrite it from within the `redirect` method.
    It's not ideal to package this kind of code within a component, so we'll clean
    that up in a bit.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类也给我们提供了一种命名和引用`Nav`组件的方法，因此我们可以在`redirect`方法中创建一个新的实例来覆盖它。将这种代码包装在组件中并不理想，所以我们会稍后清理它。
- en: We can now switch between different sections without full page reloads.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在不进行完整页面刷新的情况下在不同的部分之间切换。
- en: 'There is one problem still to solve. When we use the browser''s back button,
    the components don''t change to reflect the component that should be shown for
    each hash. We can solve this in a couple of ways. The first approach we can try
    is checking the hash frequently:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个问题需要解决。当我们使用浏览器的后退按钮时，组件不会改变以反映每个hash应该显示的组件。我们可以通过几种方式解决这个问题。我们可以尝试的第一种方法是频繁检查hash：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our `redirect` method has an extra parameter, to apply the new hash whenever
    we're not responding to a hash change. We also wrapped the call to `event.preventDefault`
    in case we don't have a click event to work with. Other than these changes, the
    `redirect` method is the same.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`redirect`方法有一个额外的参数，用于在我们不响应hash更改时应用新的hash。我们还包装了对`event.preventDefault`的调用，以防我们没有点击事件可以处理。除了这些更改之外，`redirect`方法保持不变。
- en: We also added a `componentDidMount` method in which we make a call to `setInterval`.
    We stored the initial `window.location.hash` property and checked 10 times a second
    to see whether it has changed. The hash value is `#login` or `#page-admin`, so
    we sliced the first character off and passed the rest to the `redirect` method.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在其中添加了一个`componentDidMount`方法，在其中我们调用`setInterval`。我们存储了初始的`window.location.hash`属性，并且每秒检查10次是否已更改。hash值是`#login`或`#page-admin`，所以我们切掉了第一个字符，并将剩余的部分传递给`redirect`方法。
- en: Try clicking on the different navigation links and then using the browser's
    back button.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试点击不同的导航链接，然后使用浏览器的后退按钮。
- en: The second option is to use the newish `pushState` and `popState` methods on
    the `window.history` object. They're not very well supported yet, so you need
    to be careful when you handle older browsers, or ensure that you don't need to
    handle them.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选项是使用`window.history`对象上的较新的`pushState`和`popState`方法。它们目前支持得不是很好，所以当你处理旧浏览器时需要小心，或者确保你不需要处理它们。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about `pushState` and `popState` at [https://developer.mozilla.org/en-US/docs/Web/API/History_API](https://developer.mozilla.org/en-US/docs/Web/API/History_API).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://developer.mozilla.org/en-US/docs/Web/API/History_API](https://developer.mozilla.org/en-US/docs/Web/API/History_API)了解更多关于`pushState`和`popState`的信息。
- en: 'There''s an easier way to respond to users clicking links: the `hashchange`
    event. Instead of adding the `onClick` events to each of the links (and calling
    the `redirect` function every time), we can listen for the `hashchange` events
    and change to the appropriate view. There''s a great tutorial on this at [https://medium.com/@tarkus/react-js-routing-from-scratch-246f962ededf](https://medium.com/@tarkus/react-js-routing-from-scratch-246f962ededf).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种更简单的方式来响应用户点击链接：`hashchange` 事件。我们不需要给每个链接添加 `onClick` 事件（并且每次都调用 `redirect`
    函数），我们可以监听 `hashchange` 事件并切换到相应的视图。关于这个主题有一个很好的教程在 [https://medium.com/@tarkus/react-js-routing-from-scratch-246f962ededf](https://medium.com/@tarkus/react-js-routing-from-scratch-246f962ededf)。
- en: Using a router
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路由器
- en: Our hash code is functional but invasive. We shouldn't call the `render` method
    from inside a component (at least not the one we own). So, we will instead use
    a popular router to manage this stuff for us.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的哈希代码是功能性的但侵入性的。我们不应该在组件内部（至少不是我们自己的组件）调用 `render` 方法。因此，我们将使用一个流行的路由器来帮我们管理这些。
- en: 'Download the router with the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令下载路由器：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we need to put `login.html` and `page-admin.html` back into the same
    file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将 `login.html` 和 `page-admin.html` 放回到同一个文件中：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice how we''ve added the `ReactRouter` file to the import map? We''ll use
    that in `admin.js`. First, let''s define our `layout` component:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何将 `ReactRouter` 文件添加到导入映射中的？我们将在 `admin.js` 中使用它。首先，让我们定义我们的 `layout`
    组件：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This creates the page layout we''ve been using and allows a dynamic content
    component. Every React component has a `this.props.children` property (or `props.children`
    in the case of a `function` component), which is an array of nested components.
    For example, consider the following component:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了我们所使用的页面布局，并允许一个动态的内容组件。每个 React 组件都有一个 `this.props.children` 属性（或者对于函数组件来说是
    `props.children`），它是一个嵌套组件的数组。例如，考虑以下组件：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Inside the `App` component, `this.props.children` will contain a single item:
    an instance of the `Login`. Next, we''ll define handler components for the two
    sections we want to route:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `App` 组件内部，`this.props.children` 将包含一个单独的项目：一个 `Login` 实例。接下来，我们将为想要路由的两个部分定义处理组件：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We don't really need to wrap `Login` in `LoginHandler`, but I chose to do it
    to be consistent with `PageAdminHandler`. `PageAdmin` expects an instance of `Backend`,
    so we have to wrap it, as we see in this example.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上并不需要将 `Login` 包装在 `LoginHandler` 中，但我选择这样做是为了与 `PageAdminHandler` 保持一致。`PageAdmin`
    期望一个 `Backend` 实例，因此我们必须像在这个示例中看到的那样进行包装。
- en: 'Now, we can define routes for our CMS:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为我们的 CMS 定义路由：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There's a single root route for the path `/`. It creates an instance of `App`,
    so we always get the same layout. Then, we nest a `"login"` route and a `"page-admin"`
    route. These create instances of their respective components. We also define `IndexRoute`
    so that the login page will be displayed as a landing page.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于根路径 `/`，存在一个单一的根路由。它创建了一个 `App` 实例，因此我们总是得到相同的布局。然后，我们嵌套了一个 `"login"` 路由和一个
    `"page-admin"` 路由。这些创建了它们各自组件的实例。我们还定义了 `IndexRoute`，以便登录页面将显示为着陆页。
- en: 'We need to remove our custom history code from `Nav`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从 `Nav` 中移除我们的自定义历史代码：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Also, since we no longer need a separate `redirect` method, we can convert the
    class back into a statement component (`function`).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不再需要一个单独的 `redirect` 方法，我们可以将类转换回一个声明式组件（`function`）。
- en: Note that we swapped anchor components for a new `Link` component. This interacts
    with the router to show the correct section when we click on the navigation links.
    We can also change the route paths without the need to update this component (unless
    we also change the route names).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们用新的 `Link` 组件替换了锚点组件。这个组件与路由器交互，在我们点击导航链接时显示正确的部分。我们还可以更改路由路径，而无需更新此组件（除非我们同时更改路由名称）。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: In the preceding chapter, we split `index.html` into `login.html` and `page-admin.html`
    to see both sections just by changing the URL. In this chapter, we joined them
    back together, since we have a router to switch between them. You'll need to make
    the same changes or use the example code for this chapter in order for the examples
    to work.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们将 `index.html` 分割成 `login.html` 和 `page-admin.html`，以便通过更改 URL 来查看这两个部分。在这一章中，我们将它们重新组合在一起，因为我们有一个路由器可以在它们之间切换。你需要做出同样的更改或使用本章的示例代码，以便使示例正常工作。
- en: Creating public pages
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建公共页面
- en: 'Now that we can easily switch between CMS sections, we can use the same trick
    to show the public pages of our website. Let''s create a new HTML page just for
    these:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够轻松地在 CMS 各个部分之间切换，我们可以使用同样的技巧来显示我们网站的公共页面。让我们创建一个全新的 HTML 页面专门用于这些：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a reduced form of `admin.html` without the material design resources.
    I think we can ignore the appearance of these pages for the moment while we focus
    on the navigation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个没有材料设计资源的`admin.html`的简化形式。我认为在我们专注于导航的同时，我们可以暂时忽略这些页面的外观。
- en: 'The public pages are stateless, so we can use the `function` components for
    them. Let''s begin with the layout component:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 公共页面是无状态的，因此我们可以为它们使用函数组件。让我们从布局组件开始：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is similar to the `App` admin component, but it also has a reference to
    `Backend`. We then define it when we render the components:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`App`管理组件类似，但它还有一个对`Backend`的引用。然后我们在渲染组件时定义它：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For this to work, we also need to define `StaticPage`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这可行，我们还需要定义`StaticPage`：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This component is more interesting. We access the `params` property, which is
    a map of all the URL path parameters defined for this route. We have `:page` in
    the path (`pages/:page`), so when we go to `pages/1`, the `params` object is `{"page":1}`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件更有趣。我们访问`params`属性，这是一个包含所有为该路由定义的URL路径参数的映射。路径中有`:page`（`pages/:page`），所以当我们访问`pages/1`时，`params`对象是`{"page":1}`。
- en: We also pass `Backend` to `Page`, so we can fetch all pages and filter them
    by `page.id`. If no `page.id` is provided, we default to `1`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`Backend`传递给`Page`，这样我们就可以获取所有页面并通过`page.id`进行过滤。如果没有提供`page.id`，则默认为`1`。
- en: After filtering, we check whether there are any pages. If not, we return a simple
    **Not found** message. Otherwise, we render the content of the first page in the
    array (since we expect the array to have a length of at least `1`).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤后，我们检查是否有任何页面。如果没有，我们返回一个简单的**未找到**信息。否则，我们渲染数组中第一个页面的内容（因为我们期望数组长度至少为`1`）。
- en: 'We now have a page for the public pages of the website:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个网站公共页面的页面：
- en: '![Creating public pages](img/5268_06_03.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![创建公共页面](img/5268_06_03.jpg)'
- en: 'We can also add the `onEnter` and `onLeave` callbacks to each of our routes:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为每个路由添加`onEnter`和`onLeave`回调函数：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As the current route changes, the previous route will trigger `onLeave`, as
    will each parent component up the inheritance chain. Once all the `onLeave` callbacks
    are triggered, the router will begin to trigger the `onEnter` callbacks down the
    inheritance chain. We didn't really use inheritance much (owing to how simple
    our navigation is), but it's still important to remember that `onLeave` is triggered
    before `onEnter`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当当前路由发生变化时，前一个路由将触发`onLeave`，以及继承链上的每个父组件。一旦所有`onLeave`回调函数被触发，路由器将开始触发继承链下的`onEnter`回调函数。我们没有真正使用很多继承（由于我们的导航很简单），但仍然重要的是要记住`onLeave`是在`onEnter`之前触发的。
- en: This is useful if we want to commit any unsaved data to our backend, log the
    progress of a user through the interface or anything else that might depend on
    the user navigating between pages on the site.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将任何未保存的数据提交到我们的后端，记录用户通过界面的进度，或者任何可能依赖于用户在网站页面间导航的其他事情，这将很有用。
- en: In addition to this, we want to animate different pages as they are rendered.
    We can combine them with `React.addons.CSSTransitionGroup`, which we saw in [Chapter
    4](ch04.html "Chapter 4. Styling and Animating Components"), *Styling and Animating
    Components*. As new components are rendered inside the `App` component, we will
    be able to animate them in exactly the same way. Just include `div.layout` in
    a `React.addons.CSSTransitionGroup` component and you should be all set!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们希望在渲染不同页面时进行动画。我们可以将它们与`React.addons.CSSTransitionGroup`结合使用，我们在[第4章](ch04.html
    "第4章。组件的样式和动画")中见过，*样式和动画组件*。当新的组件在`App`组件内部渲染时，我们将能够以完全相同的方式对它们进行动画。只需在`React.addons.CSSTransitionGroup`组件中包含`div.layout`，你应该就设置好了！
- en: Summary
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about how the browser stores URL history, and how
    we can manipulate it to load different sections without full page reloads. It
    introduced a bit of complexity, but we also saw that there are other alternatives
    (for example, the `hashchange` event) that reduce the complexity while still reducing
    the number of full page reloads we need to perform.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了浏览器如何存储URL历史记录，以及我们如何操作它以在不进行完整页面刷新的情况下加载不同的部分。它介绍了一些复杂性，但我们还看到了其他替代方案（例如，`hashchange`事件），这些方案在减少复杂性的同时，仍然减少了我们需要执行的完整页面刷新次数。
- en: You also learned about a popular React router and used it to abstract the manual
    location tracking or changing we had to do before.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你还了解了一个流行的React路由，并使用它来抽象我们之前必须手动进行的定位跟踪或更改。
- en: In the next chapter, you'll learn about server-side rendering and application
    structure.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习关于服务器端渲染和应用程序结构的内容。
