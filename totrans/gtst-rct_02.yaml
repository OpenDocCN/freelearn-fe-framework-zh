- en: Chapter 2. Exploring JSX and the ReactJS Anatomy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：探索 JSX 和 ReactJS 结构
- en: 'In this chapter, you are going to explore the JSX syntax and learn what it
    is and why it makes it easier for us to understand UI components. You will learn
    about the ReactJS anatomy and code some common scenarios in order to demonstrate
    this efficient syntax so that we can step forward in next chapters and build a
    full application. This chapter will walk you through the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将探索 JSX 语法，了解它是什么以及为什么它使我们更容易理解 UI 组件。你将了解 ReactJS 的结构，并编写一些常见场景的代码，以展示这种高效的语法，以便我们可以在下一章中前进并构建一个完整的应用程序。本章将带你了解以下主题：
- en: What is JSX?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX 是什么？
- en: The ReactJS anatomy
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReactJS 的结构
- en: JSX Gotchas
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX 的陷阱
- en: What is JSX?
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX 是什么？
- en: '**JSX** is a JavaScript syntax extension that looks similar to XML. It is used
    to build UI components in ReactJS. It''s very similar to HTML with some subtle
    differences. JSX extends JavaScript in such a way that you can easily build ReactJS
    components with the same understanding as building HTML pages. It''s commonly
    mixed with your JavaScript code because ReactJS thinks about UI in a different
    way. This paradigm will be explained later in the chapter.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSX** 是一种类似于 XML 的 JavaScript 语法扩展。它用于在 ReactJS 中构建 UI 组件。它与 HTML 非常相似，但有细微的差别。JSX
    以一种方式扩展了 JavaScript，使得你可以用与构建 HTML 页面相同的方式轻松构建 ReactJS 组件。它通常与你的 JavaScript 代码混合使用，因为
    ReactJS 以不同的方式考虑 UI。这个范式将在本章后面解释。'
- en: It's wrong to say that you are mixing up your HTML with JavaScript. As already
    said, JSX extends JavaScript. Actually, you're not writing HTML tags, but you're
    writing JavaScript objects in the JSX syntax. Of course, it has to be transformed
    into plain JavaScript first.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 说你把 HTML 和 JavaScript 混在一起是错误的。如前所述，JSX 扩展了 JavaScript。实际上，你并不是在写 HTML 标签，而是在
    JSX 语法中写 JavaScript 对象。当然，它必须首先转换为纯 JavaScript。
- en: 'When you write this example:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写这个示例时：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It''s transformed into this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 它被转换成这样：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This transformer script file detects JSX notations and transforms them into
    plain JavaScript notations. These scripts and tools should never be placed in
    a production environment because it would be painful for the server to transform
    the script on every request. For the production environment, we should provide
    the transformed file. We will be covering that process later in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个转换器脚本文件检测 JSX 语法并将其转换为纯 JavaScript 语法。这些脚本和工具绝不应该放在生产环境中，因为每次请求都要转换脚本对服务器来说都是痛苦的。对于生产环境，我们应该提供转换后的文件。我们将在本章后面介绍这个过程。
- en: 'As discussed in [Chapter 1](part0015_split_000.html#page "Chapter 1. Getting
    Started with ReactJS"), *Getting Started with ReactJS*, note the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第一章](part0015_split_000.html#page "第一章：ReactJS 入门") 中所述，*ReactJS 入门*，请注意以下内容：
- en: '`ReactElement` is the primary API of React. ReactElement has four properties:
    `type`, `props`, `key`, and `ref`.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReactElement` 是 React 的主要 API。ReactElement 有四个属性：`type`、`props`、`key` 和 `ref`。'
- en: ReactElement has no methods of itself, and nothing has been defined on the prototype
    also.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReactElement 没有自己的方法，原型上也没有定义任何内容。
- en: ReactElement objects can be created by calling the `React.createElement` method.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过调用 `React.createElement` 方法来创建 ReactElement 对象。
- en: In the highlighted code mentioned earlier, we can see that the first argument
    for the `React.createElement` method is creating an `h1` element, with properties
    being passed as null and the actual content of the `h1` element being the string
    `Hello World from Learning ReactJS`
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面提到的突出显示的代码中，我们可以看到 `React.createElement` 方法的第一个参数是创建一个 `h1` 元素，属性被传递为 null，而
    `h1` 元素的实际内容是字符串 `Hello World from Learning ReactJS`。
- en: ReactElements are passed into DOM in order to create a new tree in DOM.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReactElements 被传递到 DOM 中，以在 DOM 中创建一个新的树。
- en: ReactElements are named virtual DOM and are not the same as DOM elements. Details
    of virtual DOM will be discussed in later chapters.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReactElements 被称为虚拟 DOM，并且与 DOM 元素不同。虚拟 DOM 的细节将在后面的章节中讨论。
- en: As per the official React documentation ([https://facebook.github.io/react/docs/glossary.html](https://facebook.github.io/react/docs/glossary.html)),
    "ReactElement is a light, stateless, immutable, virtual representation of a DOM
    Element".
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据官方 React 文档（[https://facebook.github.io/react/docs/glossary.html](https://facebook.github.io/react/docs/glossary.html)），"ReactElement
    是 DOM 元素的一个轻量级、无状态、不可变、虚拟表示"。
- en: 'Let''s check our previous example again when we didn''t use the JSX syntax:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次检查我们之前的示例，当时我们没有使用 JSX 语法：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code is creating an `h1` element. Think about it being like creating an
    element through JavaScript with the `document.createElement()` function, which
    makes the code very readable.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码正在创建一个`h1`元素。想想看，这就像通过JavaScript的`document.createElement()`函数创建一个元素，这使得代码非常易于阅读。
- en: 'JSX is not mandatory, but it''s highly recommended. It is painful to create
    large and complex components using JavaScript. For example, if we want to create
    nested elements using JSX, we would need to do the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: JSX不是强制性的，但强烈推荐。使用JavaScript创建大型和复杂的组件是非常痛苦的。例如，如果我们想使用JSX创建嵌套元素，我们需要做以下操作：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, using plain JavaScript ReactJS objects, it would look like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用纯JavaScript ReactJS对象，它看起来会是这样：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can see a big scary component that might grow in case of more complex logic.
    Such complex components are difficult to maintain and understand.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一个可能随着更复杂逻辑而增长的大而可怕的组件。这样的复杂组件难以维护和理解。
- en: Why JSX?
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用JSX？
- en: 'In general, HTML and JavaScript are segregated in frameworks by defining UI
    or a view to represent their mutable data, which normally is a template language
    and/or a display logic interpreter. The following is some jQuery code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在框架中通过定义UI或视图来表示它们可变的数据，这通常是一个模板语言和/或显示逻辑解释器。以下是一些jQuery代码：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `script` element represents a template component that will be rendered
    in the `my-awesome-app div` element. The code here is a JavaScript file that pushes
    data to that template and asks jQuery to do the job and render the UI:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`script`元素代表一个将在`my-awesome-app div`元素中渲染的模板组件。这里的代码是一个JavaScript文件，它将数据推送到模板，并要求jQuery完成工作并渲染UI：'
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Whenever you want to put some display logic on that code, you will need to rely
    on both JavaScript and HTML files. In other words, a single component is a mix
    of files—normally, a JavaScript file that controls the view, a template/markup
    file representing the view, and a model/service that fetches data from the server
    and sends it to the view. Typically in an MVC application, the logic of M(model),
    V(view), and C(controller) are separated in order to provide the separation of
    concern and better readability and maintenance of the code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你想在代码上添加一些显示逻辑，你都需要依赖于JavaScript和HTML文件。换句话说，一个组件是文件的混合体——通常，一个控制视图的JavaScript文件，一个代表视图的模板/标记文件，以及一个从服务器获取数据并发送到视图的模型/服务。在MVC应用程序中，M（模型）、V（视图）和C（控制器）的逻辑通常是分离的，以便提供关注点的分离，以及代码的更好可读性和维护性。
- en: Let's say that we now have to change this view and need to hide the list when
    the user is not logged in. Considering that the model/service code is already
    bringing this information, we'll have to change both the code that controls the
    view and the markup one in order to apply those changes. Harder the change is,
    more painful it is to apply those changes. Our code ends up in big JavaScript
    and HTML files, mixed up with display logic, template expressions, and business
    code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们现在必须更改这个视图，并在用户未登录时隐藏列表。考虑到模型/服务代码已经带来了这个信息，我们将不得不更改控制视图的代码和标记代码，以应用这些更改。更改越困难，应用这些更改就越痛苦。我们的代码最终变成了大型的JavaScript和HTML文件，混合了显示逻辑、模板表达式和业务代码。
- en: 'Although you are an experienced frontend developer, apply some separation of
    concerns, and split your UI into smaller views, you end up with hundreds of files
    just to represent a single piece of UI: view controller, HTML template, style
    sheet, and your model. It makes a small application look complex with that amount
    of files, and you''ll certainly get messy wondering which file is part of a specific
    view or component.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你是一位经验丰富的前端开发者，但应用一些关注点的分离，并将你的UI拆分成更小的视图，最终你会拥有数百个文件来表示单个UI元素：视图控制器、HTML模板、样式表以及你的模型。这么多文件会让一个小应用看起来很复杂，你肯定会感到混乱，不知道哪个文件是特定视图或组件的一部分。
- en: The thing we want to show here is that we've been mixing markup and logic code
    since the beginning, but other than that, we've also been splitting them into
    other files, making it more difficult to find and to modify them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在这里展示的是，我们一直在混合标记和逻辑代码，但除此之外，我们还把它们分到了其他文件中，这使得它们更难找到和修改。
- en: 'ReactJS with JSX drives you in the other way. There is a really interesting
    paragraph in the ReactJS official page that honestly reasons this powerful library
    and its paradigm:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS与JSX将你引向另一个方向。ReactJS官方页面中有一个非常有趣的段落，坦率地解释了这个强大的库及其范式：
- en: '*"We strongly believe that components are the right way to separate concerns
    rather than "templates" and "display logic." We think that markup and the code
    that generates it are intimately tied together. Additionally, display logic is
    often very complex and using template languages to express it becomes cumbersome.
    ([http://facebook.github.io/react/docs/displaying-data.html#jsx-syntax](http://facebook.github.io/react/docs/displaying-data.html#jsx-syntax))*'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"我们坚信，组件是分离关注点的正确方式，而不是“模板”和“显示逻辑”。我们认为标记和生成它的代码紧密相连。此外，显示逻辑通常非常复杂，使用模板语言来表示它变得繁琐。([http://facebook.github.io/react/docs/displaying-data.html#jsx-syntax](http://facebook.github.io/react/docs/displaying-data.html#jsx-syntax))*"'
- en: We like to think of ReactJS components as a single source of truth. All other
    locations that use your component will be just references. Every change you apply
    to the original one will be propagated to all other places referencing it. Customization
    is easily done through properties and child componentization. JSX is like a middleware
    that converts your markup code to objects where ReactJS can handle them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢将 ReactJS 组件视为单一的真实来源。所有其他使用您组件的位置都只是引用。您对原始组件所做的任何更改都将传播到所有引用它的其他地方。可以通过属性和子组件化轻松进行定制。JSX
    就像是一个中间件，将您的标记代码转换为 ReactJS 可以处理的对象。
- en: JSX speeds up the frontend development in ReactJS. Instead of creating literal
    objects to represent your UI, you create XML-like elements very similar to HTML,
    and you can even reference other components that you've created. Also, it's very
    straightforward to reuse third-party components or even publish your own. In a
    corporate environment, you could have a commonly used components repository that
    other projects can import from.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 加速了 ReactJS 的前端开发。您不是创建代表您 UI 的字面量对象，而是创建类似于 XML 的元素，非常类似于 HTML，您甚至可以引用您创建的其他组件。此外，重用第三方组件或甚至发布您自己的组件非常简单。在企业环境中，您可能有一个常用的组件仓库，其他项目可以从该仓库导入。
- en: Tools for transforming JSX
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换 JSX 的工具
- en: The JSX Transformer file and other tools, as already mentioned, are responsible
    for transforming your JSX syntax into plain JavaScript. The ReactJS team and the
    community provide some tools for that. Such tools can deal with any kind of file
    since they have JavaScript code and JSX syntax. In older versions of React, a
    comment was required on the first line of `.js` files such as `/** @jsx React.DOM
    */`. Thankfully, this was removed after version 0.12.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，JSX 转换器文件和其他工具负责将您的 JSX 语法转换为纯 JavaScript。ReactJS 团队和社区为此提供了一些工具。这些工具可以处理任何类型的文件，因为它们包含
    JavaScript 代码和 JSX 语法。在 React 的旧版本中，需要在 `.js` 文件的第一行添加注释，例如 `/** @jsx React.DOM
    */`。幸运的是，在版本 0.12 之后，这一要求被移除了。
- en: JSX Transformer has been deprecated now. Instead, we can use [https://babeljs.io/repl/](https://babeljs.io/repl/)
    to compile the JSX syntax into JavaScript. To include JSX in your script tag,
    either use `<script type="text/jsx">` or while transforming, use `babel`
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 转换器现在已被弃用。相反，我们可以使用 [https://babeljs.io/repl/](https://babeljs.io/repl/)
    将 JSX 语法编译成 JavaScript。要在脚本标签中包含 JSX，可以使用 `<script type="text/jsx">` 或在转换时使用 `babel`
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Earlier there was an online tool at [http://facebook.github.io/react/jsx-compiler.html](http://facebook.github.io/react/jsx-compiler.html).
    However, the React developer team discontinued it, and JSX Transformer has been
    deprecated.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以前有一个在线工具 [http://facebook.github.io/react/jsx-compiler.html](http://facebook.github.io/react/jsx-compiler.html)。然而，React
    开发团队已经停止了它，JSX 转换器也已弃用。
- en: 'Since such JSX transformation would take a substantial computation at the client
    side, we should *not* be doing these transformations in production environments.
    Instead, we should use:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种 JSX 转换将在客户端进行大量的计算，因此我们**不应该**在生产环境中进行这些转换。相反，我们应该使用：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Tools for transforming JSX](img/00004.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![转换 JSX 的工具](img/00004.jpeg)'
- en: 'We can also use the node `npm` package that the ReactJS team built to transform
    your JSX files. First, you need to install the `react-tools` NPM package with:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 ReactJS 团队构建的 node `npm` 包来转换您的 JSX 文件。首先，您需要使用以下命令安装 `react-tools`
    NPM 包：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will install `react-tools` globally. All you need now is to run the following
    command from your project folder:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将全局安装 `react-tools`。现在您只需要从您的项目文件夹中运行以下命令：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This command transforms every script in the `src` folder and puts it in the
    `build` folder. The `watch` parameter makes this tool run the same command every
    time a file changes in the `src` folder. This is a very useful tool because you're
    using node to bundle your frontend code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将`src`文件夹中的每个脚本转换，并将其放入`build`文件夹。`watch`参数使得每次`src`文件夹中的文件发生变化时，此工具都会运行相同的命令。这是一个非常有用的工具，因为您正在使用node来打包您的前端代码。
- en: 'If you''re familiar with task runner tools such as Grunt or Gulp, they also
    have JSX transformer packages that can be installed with `npm` as well. In this
    case, they provide more options that can fit better in our deployment/building
    process, mainly if you already use one of them. It''s not the purpose of this
    book to dive into Grunt or Gulp. In order to configure and install them, you can
    follow their guidelines in the following links: Details of these are covered in
    [Chapter 9](part0053_split_000.html#page "Chapter 9. Preparing Your Code for Deployment"),
    *Preparing Your Code for Deployment*.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉Grunt或Gulp等任务运行器工具，它们也有JSX转换器包，可以使用`npm`安装。在这种情况下，它们提供了更多选项，可以更好地适应我们的部署/构建过程，尤其是如果您已经使用其中之一。本书的目的不是深入探讨Grunt或Gulp。为了配置和安装它们，您可以遵循以下链接中的指南：这些细节将在[第9章](part0053_split_000.html#page
    "第9章. 准备代码以部署")，*准备代码以部署*中介绍。
- en: Grunt – [https://www.gruntjs.com](https://www.gruntjs.com)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grunt – [https://www.gruntjs.com](https://www.gruntjs.com)
- en: Gulp – [https://www.gulpjs.com](https://www.gulpjs.com)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gulp – [https://www.gulpjs.com](https://www.gulpjs.com)
- en: 'Both sites have a [/plugins](http:///plugins) page where you can search for
    available plugins. The following are the links of these download tools:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个网站都有一个[/plugins](http:///plugins)页面，您可以在其中搜索可用的插件。以下是一些下载工具的链接：
- en: Grunt React task—[https://www.npmjs.com/package/grunt-react](https://www.npmjs.com/package/grunt-react)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grunt React任务—[https://www.npmjs.com/package/grunt-react](https://www.npmjs.com/package/grunt-react)
- en: Gulp React task—[https://www.npmjs.com/package/gulp-react/](https://www.npmjs.com/package/gulp-react/)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gulp React任务—[https://www.npmjs.com/package/gulp-react/](https://www.npmjs.com/package/gulp-react/)
- en: They work much the same as do the React tools. We are going to use the `transformer`
    script file that is placed in `head` the element of our HTML page for the next
    examples, as this is easier to do. In [Chapter 9](part0053_split_000.html#page
    "Chapter 9. Preparing Your Code for Deployment"), *Preparing Your Code for Deployment*,
    we are going to use `webpack` and `gulp` as the `npm` packages to transform our
    JSX code and prepare it for deployment.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的工作方式与React工具非常相似。在接下来的示例中，我们将使用放置在我们HTML页面`head`元素中的`transformer`脚本文件，因为这更容易操作。在[第9章](part0053_split_000.html#page
    "第9章. 准备代码以部署")，*准备代码以部署*中，我们将使用`webpack`和`gulp`作为`npm`包来转换我们的JSX代码，并为其部署做准备。
- en: The ReactJS anatomy
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReactJS的解剖结构
- en: Before going any further into JSX, we need to understand some basic rules to
    build ReactJS components. First, we're going to detail the basic methods that
    you've already used to create and render components. Then, we'll move to some
    rules to create them, and finally, we'll talk about children components.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步探讨JSX之前，我们需要了解一些基本规则来构建ReactJS组件。首先，我们将详细介绍您已经用来创建和渲染组件的基本方法。然后，我们将转向创建它们的规则，最后，我们将讨论子组件。
- en: Creating a component
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个组件
- en: In order to create a component, we need to use the `React.createClass` function.
    ReactJS components are basically classes. This method returns a ReactJS component
    definition that has a method named `render`, which is mandatory to implement.
    There are many other methods to configure your component and change its behavior
    that we are going to cover throughout the book.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个组件，我们需要使用`React.createClass`函数。ReactJS组件基本上是类。此方法返回一个具有名为`render`的方法的ReactJS组件定义，这是必须实现的。本书将介绍许多其他方法来配置您的组件并改变其行为。
- en: 'This is an example of how to use the `createClass` and `render` method:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个如何使用`createClass`和`render`方法的示例：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's a good practice to name all the classes and components in PascalCase. In
    addition to being a common pattern in JavaScript, it also helps to distinguish
    them from other variables.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有类和组件命名为PascalCase是一个好的做法。除了在JavaScript中是一个常见的模式外，它还有助于将它们与其他变量区分开来。
- en: Rendering a component
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染一个组件
- en: 'Once you have your component definition, as seen in our last example, the `HelloMessage`
    component, we can render it with the render method of `ReactJS`. It requires the
    component definition and the target location, where the component will be rendered.
    Let''s demonstrate this with the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了组件定义，就像我们在最后一个例子中看到的`HelloMessage`组件，我们就可以使用`ReactJS`的`render`方法来渲染它。它需要组件定义和目标位置，即组件将被渲染的位置。让我们用以下示例来演示这一点：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the code mentioned earlier, you could change `document.body` with any other
    element in your page. For example, you could use the `document` object method
    `document.getElementById('id')` to find an element by its ID or any other helper
    that returns a DOM element. In the specific ID of the DOM (`id` in this case),
    the React component will be rendered.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面提到的代码中，你可以用你页面上的任何其他元素替换`document.body`。例如，你可以使用`document`对象的方法`document.getElementById('id')`通过ID找到元素，或者使用任何其他返回DOM元素的辅助方法。在特定的DOM
    ID（在这种情况下是`id`），React组件将被渲染。
- en: Maximum number of roots
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根的最大数量
- en: 'It''s not possible to return more than one element in the `render` method.
    Not for now, as they say in official ReactJS docs at [http://facebook.github.io/react/tips/maximum-number-of-jsx-root-nodes.html](http://facebook.github.io/react/tips/maximum-number-of-jsx-root-nodes.html):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`render`方法中返回超过一个元素是不可能的。至少现在还不行，正如官方ReactJS文档[http://facebook.github.io/react/tips/maximum-number-of-jsx-root-nodes.html](http://facebook.github.io/react/tips/maximum-number-of-jsx-root-nodes.html)中所说：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The ReactJS library will throw a strange error that doesn't address clearly
    that you have more than one element being rendered. Therefore, take care to not
    do this; otherwise, you can get stuck trying to find the problem.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS库将抛出一个奇怪的错误，这个错误并没有清楚地指出你正在渲染多个元素。因此，请注意不要这样做；否则，你可能会陷入寻找问题的困境。
- en: 'When you have more than one element being represented by a ReactJS component,
    you must wrap them in a single parent element. The next example demonstrates this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个ReactJS组件代表多个元素时，你必须将它们包裹在一个单一父元素中。下一个示例将演示这一点：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can use whichever valid HTML element you want that supports children elements.
    It is also possible to render a custom ReactJS component that has children support
    (more about this in the next section).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用任何支持子元素的有效的HTML元素。也可以渲染一个具有子支持的自定义ReactJS组件（更多内容将在下一节中介绍）。
- en: This is one of the reasons to choose a good text editor and a good linter/lint
    package that can watch your code and warn you whenever you make a mistake.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是选择一个好的文本编辑器和好的lint/lint包的原因之一，它可以监视你的代码，并在你犯错时提醒你。
- en: Children components
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子组件
- en: If there is a really necessary thing when you talk about creating reusable user
    interfaces, it has to do with nesting components. This way you can better structure
    and separate concerns of your application. It's a pretty common thing to do on
    web world as well, as HTML has this feature built-in. As you could see in the
    last section and earlier examples of this book, ReactJS supports this feature
    as well and JSX syntax makes it very straightforward.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你谈论创建可重用用户界面时，如果真的有必要的因素，那一定与组件嵌套有关。这样你可以更好地组织并分离你应用程序的各个部分。在Web世界中，这也是一个相当常见的事情，因为HTML内置了这一功能。正如你在本书的上一节和前面的示例中看到的那样，ReactJS也支持这一功能，JSX语法使得它非常直接。
- en: 'Let''s say that you have a `Header` component and you want to place other components
    inside. ReactJS allows this and includes support for placing other ReactJS components:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个`Header`组件，并且你想要在其中放置其他组件。ReactJS允许这样做，并且包括对放置其他ReactJS组件的支持：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can use either built-in components, such as `h2`, or custom components,
    such as the `Clock` component, described here. In this example, the expression
    `{this.props.children}` will be considered as a JavaScript array. If there was
    a single component like the one mentioned later, it will be addressed as a JavaScript
    object instead of an array. This saves array allocation, but we should be careful
    and not try to iterate it or check for its length:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用内置组件，如`h2`，或者自定义组件，如这里描述的`Clock`组件。在这个例子中，表达式`{this.props.children}`将被视为一个JavaScript数组。如果有单个组件，就像后面提到的那个，它将被视为一个JavaScript对象而不是数组。这节省了数组分配，但我们应该小心，不要尝试迭代它或检查它的长度：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Supported attributes
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持的属性
- en: 'Some HTML attributes conflict with JavaScript reserved words, and as ReactJS
    elements are basically JavaScript objects, such attributes have a different name
    in ReactJS to match the DOM API specification:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一些HTML属性与JavaScript保留字冲突，由于ReactJS元素基本上是JavaScript对象，因此这些属性在ReactJS中具有不同的名称，以匹配DOM
    API规范：
- en: The class is `className`
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类是`className`
- en: '`for` is `htmlFor`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`是`htmlFor`'
- en: 'Custom attributes, such as `data-*` and `aria-*`, are supported by ReactJS.
    There is an official list of HTML attributes supported, as follows:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持自定义属性，如`data-*`和`aria-*`，ReactJS。有一个官方支持的HTML属性列表，如下所示：
- en: '| `accept` `acceptCharset` `accessKey` `action` `allowFullScreen` `allowTransparency`
    `alt` `async` `autoComplete` `autoPlay` `cellPadding` `cellSpacing` `charSet`
    `checked` `classID` `className` `cols` `colSpan` `content` `contentEditable` `contextMenu`
    `controls` `coords` `crossOrigin` `data` `dateTime` `defer` `dir` `disabled` `download`
    `draggable` `encType` `form` `formAction` `formEncType` `formMethod` `formNoValidate`
    `formTarget` `frameBorder` `height` |'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `accept` `acceptCharset` `accessKey` `action` `allowFullScreen` `allowTransparency`
    `alt` `async` `autoComplete` `autoPlay` `cellPadding` `cellSpacing` `charSet`
    `checked` `classID` `className` `cols` `colSpan` `content` `contentEditable` `contextMenu`
    `controls` `coords` `crossOrigin` `data` `dateTime` `defer` `dir` `disabled` `download`
    `draggable` `encType` `form` `formAction` `formEncType` `formMethod` `formNoValidate`
    `formTarget` `frameBorder` `height` |'
- en: '| `hidden` `href` `hrefLang` `htmlFor` `httpEquiv` `icon` `id` `label` `lang`
    `list` `loop` `manifest` `marginHeight` `marginWidth` `max` `maxLength` `media`
    `mediaGroup` `method` `min` `multiple` `muted` `name` `noValidate` `open` `pattern`
    `placeholder` `poster` `preload` `radioGroup` `readOnly` `rel` `required` `role`
    `rows` `rowSpan` `sandbox` `scope` `scrolling` `seamless` `selected` `shape` `size`
    `sizes` `span` `spellCheck` `src` `srcDoc` `srcSet` `start` `step` `style` `tabIndex`
    `target` `title` `type` `useMap` `value` `width` `wmode` |'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `hidden` `href` `hrefLang` `htmlFor` `httpEquiv` `icon` `id` `label` `lang`
    `list` `loop` `manifest` `marginHeight` `marginWidth` `max` `maxLength` `media`
    `mediaGroup` `method` `min` `multiple` `muted` `name` `noValidate` `open` `pattern`
    `placeholder` `poster` `preload` `radioGroup` `readOnly` `rel` `required` `role`
    `rows` `rowSpan` `sandbox` `scope` `scrolling` `seamless` `selected` `shape` `size`
    `sizes` `span` `spellCheck` `src` `srcDoc` `srcSet` `start` `step` `style` `tabIndex`
    `target` `title` `type` `useMap` `value` `width` `wmode` |'
- en: At the time of writing this book, this is available at [http://facebook.github.io/react/docs/tags-and-attributes.html](http://facebook.github.io/react/docs/tags-and-attributes.html).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，此信息可在[http://facebook.github.io/react/docs/tags-and-attributes.html](http://facebook.github.io/react/docs/tags-and-attributes.html)找到。
- en: Supported elements
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持的元素
- en: The official ReactJS website also provides a list of supported elements. ReactJS
    supports mostly all HTML elements. A comprehensive list of all the supported elements
    are given on their website, [https://facebook.github.io/react/docs/tags-and-attributes.html](https://facebook.github.io/react/docs/tags-and-attributes.html).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的ReactJS网站还提供了一个支持的元素列表。ReactJS支持大多数HTML元素。所有支持的元素的综合列表可以在其网站上找到，[https://facebook.github.io/react/docs/tags-and-attributes.html](https://facebook.github.io/react/docs/tags-and-attributes.html)。
- en: HTML elements
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML元素
- en: 'The following are the elements that are supported. There are many more to the
    list as well:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些支持的元素。还有更多元素在列表中：
- en: '| `a` | `abbr` | `address` | `area` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `a` | `abbr` | `address` | `area` |'
- en: '| `article` | `aside` | `audio` | `b` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `article` | `aside` | `audio` | `b` |'
- en: '| `base` | `bdi` | `bdo` | `big` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `base` | `bdi` | `bdo` | `big` |'
- en: '| `blockquote` | `body` | `br` | `button` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `blockquote` | `body` | `br` | `button` |'
- en: '| `canvas` | `caption` | `cite` | `code` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `canvas` | `caption` | `cite` | `code` |'
- en: '| `col` | `colgroup` | `data` | `datalist` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `col` | `colgroup` | `data` | `datalist` |'
- en: '| `dd` | `del` | `details` | `dfn` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `dd` | `del` | `details` | `dfn` |'
- en: '| `dialog` | `div` | `dl` | `dt` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `dialog` | `div` | `dl` | `dt` |'
- en: '| `em` | `embed` | `footer` | `fieldset` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `em` | `embed` | `footer` | `fieldset` |'
- en: '| `figcaption` | `figure` | `form` | `h4` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `figcaption` | `figure` | `form` | `h4` |'
- en: '| `h1` | `h2` | `h3` | `h5` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `h1` | `h2` | `h3` | `h5` |'
- en: '| `h6` | `head` | `header` | `hr` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `h6` | `head` | `header` | `hr` |'
- en: '| `html` | `i` | `iframe` | `img` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `html` | `i` | `iframe` | `img` |'
- en: '| `input` | `ins` | `kbd` | `keygen` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `input` | `ins` | `kbd` | `keygen` |'
- en: '| `label` | `legend` | `li` | `link` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `label` | `legend` | `li` | `link` |'
- en: '| `main` | `map` | `mark` | `menu` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `main` | `map` | `mark` | `menu` |'
- en: '| `menuitem` | `meta` | `meter` | `nav` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `menuitem` | `meta` | `meter` | `nav` |'
- en: '| `noscript` | `object` | `ol` | `optgroup` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `noscript` | `object` | `ol` | `optgroup` |'
- en: '| `option` | `output` | `p` | `param` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `option` | `output` | `p` | `param` |'
- en: '| `picture` | `pre` | `progress` | `q` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `picture` | `pre` | `progress` | `q` |'
- en: '| `rp` | `rt` | `ruby` | `s` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `rp` | `rt` | `ruby` | `s` |'
- en: '| `samp` | `script` | `section` | `select` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `samp` | `script` | `section` | `select` |'
- en: '| `small` | `source` | `span` | `strong` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `small` | `source` | `span` | `strong` |'
- en: '| `style` | `sub` | `summary` | `sup` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `style` | `sub` | `summary` | `sup` |'
- en: '| `table` | `tbody` | `td` | `textarea` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `table` | `tbody` | `td` | `textarea` |'
- en: '| `tfoot` | `thead` | `time` | `tr` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `tfoot` | `thead` | `time` | `tr` |'
- en: '| `track` | `u` | `ul` | `video` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `track` | `u` | `ul` | `video` |'
- en: '| `wbr` |   |   |   |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `wbr` |   |   |   |'
- en: SVG elements
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SVG元素
- en: 'The following are some of the supported SVG elements:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些支持的SVG元素：
- en: '| `circle` `defs` `ellipse` `g` `line` `linearGradient` `mask` `path` `pattern`
    `polygon` `polyline` `radialGradient` `rect` `stop` `svg` `text` `tspan` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `circle` `defs` `ellipse` `g` `line` `linearGradient` `mask` `path` `pattern`
    `polygon` `polyline` `radialGradient` `rect` `stop` `svg` `text` `tspan` |'
- en: Learning JSX and Gotchas
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习JSX和注意事项
- en: Now it's time to master JSX and learn some Gotchas. You're going to learn some
    basic concepts to build ReactJS UI components using JSX. It includes practices
    when writing expressions, conditions, and creating lists of components. It will
    also walk you through how JSX differs from HTML (because it's not HTML) in some
    aspects.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候掌握JSX并学习一些注意事项了。你将学习一些基本概念，使用JSX构建ReactJS UI组件。这包括编写表达式、条件和创建组件列表的实践。它还将向您介绍JSX在某些方面如何与HTML（因为它不是HTML）不同。
- en: Expressions
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式
- en: 'Consider the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: JSX understands the curly braces `{}` whenever you want to put JavaScript code
    within your presentation code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: JSX在你想在演示代码中嵌入JavaScript代码时理解花括号`{}`。
- en: In the next example, let's improve our `Clock` component by supporting greetings
    depending on what the time is.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，让我们通过支持根据时间不同的问候语来改进我们的`Clock`组件。
- en: 'In the highlighted code mentioned later, if the current hour is lesser than
    `4`, it should return `day`, and if the hour is greater than `4` but less than
    `18`, it should return `night`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面提到的突出显示的代码中，如果当前小时数小于`4`，则应返回`day`，如果小时数大于`4`但小于`18`，则应返回`night`：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, it's possible to make a ternary within the curly braces. You
    can place any valid JavaScript code within them. It's more common to create a
    variable and address it to the result of this expression before rendering your
    component. This makes your code cleaner and more readable.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在花括号内可以创建三元表达式。您可以在其中放置任何有效的JavaScript代码。在渲染组件之前创建一个变量并将其分配给此表达式的结果更为常见。这使得您的代码更干净、更易于阅读。
- en: 'In the next example, we will demonstrate how to render a component based on
    a condition. There are two components, one for login and the other for the user
    details. It depends on the fact that if the user is logged in, the user details
    component will be shown; otherwise, the login one will be rendered. The code to
    detect whether the user is logged in or not will be skipped, as this is just to
    demonstrate how to put rendering logic inside ReactJS components using JSX syntax:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将演示如何根据条件渲染组件。有两个组件，一个用于登录，另一个用于用户详情。这取决于用户是否已登录；如果用户已登录，则显示用户详情组件；否则，将渲染登录组件。检测用户是否登录的代码将被跳过，因为这只是为了演示如何使用JSX语法在ReactJS组件中放置渲染逻辑：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can put this code inside a component that contains all other components
    as children, as demonstrated in the next example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此代码放入一个包含所有其他组件作为子组件的组件中，如下一个示例所示：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Properties/attributes
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性/属性
- en: Properties allow you to customize your components, and JSX supports them in
    a very similar way to HTML elements. You can pass properties to ReactJS elements
    and get them before rendering the component. This is a very key fundamental of
    ReactJS, and you're going to learn how to work with them using JSX. In the next
    chapter, we'll dive into how properties work and discuss good practices on how
    to use them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 属性允许您自定义组件，JSX以与HTML元素非常相似的方式支持它们。您可以将属性传递给ReactJS元素，并在渲染组件之前获取它们。这是ReactJS的一个非常关键的基本概念，你将学习如何使用JSX与它们一起工作。在下一章中，我们将深入了解属性的工作原理，并讨论如何使用它们的良好实践。
- en: 'Consider the following example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In order to render this component, you have to pass properties to it, just
    like we do in HTML elements:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染此组件，您必须向其传递属性，就像我们在HTML元素中所做的那样：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can also use expressions inside properties:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在属性中使用表达式：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If we don't set the properties (name) required by a component, in our last example,
    it will be rendered as an empty string. Thus, if there are expressions trying
    to access that property, then it will throw an error.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有设置组件所需的属性（名称），在我们的上一个示例中，它将被渲染为空字符串。因此，如果有表达式试图访问该属性，那么它将抛出错误。
- en: Transferring properties
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转移属性
- en: Passing properties throughout your component hierarchy is a very common thing
    to do in ReactJS. You can think of properties as a way of making your component
    dynamic, and because you are splitting your components into smaller ones, you
    need an efficient way to pass incoming configuration and data to them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ReactJS 中，在整个组件层次结构中传递属性是一个非常常见的做法。你可以把属性看作是一种使你的组件动态化的方式，因为你将组件拆分成更小的部分，你需要一种高效的方法来传递传入的配置和数据。
- en: 'Consider the following nested components:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下嵌套组件：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we can see, it's possible to pass properties to child components. If you
    have lots of properties to pass on, it becomes a tedious task to do and your code
    will get very messy.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，向子组件传递属性是可能的。如果你有很多属性需要传递，那么这变成了一项繁琐的任务，你的代码也会变得非常混乱。
- en: 'Fortunately, you can transfer them in a fancy way that JSX provides us. All
    you''re going to do is to change your `App` component, so it can pass all its
    properties on that were received by the `React.render` function. This is done
    using the spread operator `{...this.props}` notation that JSX understands. The
    following is an example explaining this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以使用 JSX 提供的优雅方式来传递它们。你所要做的就是更改你的 `App` 组件，使其能够传递通过 `React.render` 函数接收到的所有属性。这是通过
    JSX 理解的展开运算符 `{...this.props}` 表达式来实现的。以下是一个解释这个的例子：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Much clearer! However, there is still a problem with that solution. It can
    override properties on your subcomponents. Let''s take another example, imagine
    you have a property named `name`, and you want to pass it along. Some elements,
    basically HTML input elements, have this attribute to define their names inside
    forms. If you change it, it can result in unexpected consequences. Another example
    is the input checkbox or radio. Both have an attribute named `checked`, which
    defines whether the control will be visually checked. If you pass on a property
    named `checked,` it''d definitely result in a bad behavior. In order to avoid
    this, it''s possible to skip some properties using the same notation. You just
    need to specify them as:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰多了！然而，这个解决方案仍然存在一个问题。它可以覆盖子组件上的属性。让我们再举一个例子，假设你有一个名为 `name` 的属性，并且你想传递它。一些元素，基本上是
    HTML 输入元素，有这个属性来定义它们在表单中的名称。如果你改变它，可能会导致意外的后果。另一个例子是输入复选框或单选按钮。两者都有一个名为 `checked`
    的属性，它定义了控件是否会被视觉上选中。如果你传递一个名为 `checked` 的属性，它肯定会引起不良行为。为了避免这种情况，你可以使用相同的表示法跳过一些属性。你只需要指定它们为：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Everything that comes before the three dots, `...`, will be considered as separated
    variables, and the one that comes after the three dots, `...`, will be addressed
    to an array with all the remaining properties. This is an experimental ES6 (ECMA
    Script) syntax, and there are some ways you can transform that code into plain
    JavaScript. Details of ES6 are covered later in [Chapter 5](part0033_split_000.html#page
    "Chapter 5. Component Life cycle and Newer ECMAScript in React"), *Component Lifecycle
    and Newer ECMA Script in React*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在三个点 `...` 之前的所有内容都将被视为独立的变量，而在三个点之后的内容，`...`，将被分配到一个包含所有剩余属性的数组中。这是一个实验性的 ES6（ECMA
    Script）语法，有一些方法可以将这段代码转换为普通的 JavaScript。ES6 的详细信息将在[第 5 章](part0033_split_000.html#page
    "第 5 章。组件生命周期和 React 中的新 ECMAScript") *组件生命周期和 React 中的新 ECMAScript* 中介绍。
- en: By looking through [https://www.npmjs.com/package/react-tools](https://www.npmjs.com/package/react-tools),
    you can find the details of the different options you can pass with the JSX Transformer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看 [https://www.npmjs.com/package/react-tools](https://www.npmjs.com/package/react-tools)，你可以找到你可以通过
    JSX 转换器传递的不同选项的详细信息。
- en: '`--harmony`: turns on JS transformations such as ES6 classes and so on.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`--harmony`：开启 JS 转换，如 ES6 类等。'
- en: Thus, the ES6 syntax will be transformed into ES5-compatible syntaxes.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，ES6 语法将被转换为 ES5 兼容的语法。
- en: 'The first way is to put an extra argument named `harmony` on your HTML `script`
    element so that the transformer will know that it''s going to need to understand
    the new version of ECMAScript in order to transform. This is how your script tag
    should look like:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是在你的 HTML `script` 元素上添加一个名为 `harmony` 的额外参数，这样转换器就会知道它需要理解 ECMAScript
    的新版本才能进行转换。这是你的脚本标签应该看起来像的样子：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: ES6 (also known as Harmony) is a version (actual is ES5) of ECMAScript that
    is a standardized scripting language. The most known implementation of this standard
    is the JavaScript language, but there are many others.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ES6（也称为 Harmony）是 ECMAScript 的一个版本（实际上是 ES5），它是一种标准化的脚本语言。这个标准的最知名实现是 JavaScript
    语言，但还有许多其他语言。
- en: 'You can also use the `react-tools` node package. This exposes a command named
    `jsx` that can transform your files offline. In order to use it, you''re going
    to need to run this command from any console tool within your application''s folder:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`react-tools`节点包。它暴露了一个名为`jsx`的命令，可以离线转换您的文件。为了使用它，您需要从应用程序文件夹中的任何控制台工具运行此命令：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `-x` option allows you to specify the syntax to search for. In our examples,
    we are creating the `.jsx` files, but you could also do that with the `.js` files
    that have the JSX code inside. The `--harmony` option is the same from the last
    example. It tells the transformer to understand ES6/ES7 features of the JavaScript
    language.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`-x`选项允许您指定要搜索的语法。在我们的示例中，我们正在创建`.jsx`文件，但您也可以使用包含JSX代码的`.js`文件来完成此操作。`--harmony`选项与上一个示例相同。它告诉转换器理解JavaScript语言的ES6/ES7特性。'
- en: You can find out how to install `react-tools` in the earlier section *Tools
    for transforming JSX*, as discussed earlier in this chapter.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本章前面讨论的*转换JSX的工具*部分中找到如何安装`react-tools`的说明。
- en: The reason to use the `.jsx` files is it facilitates text editors to match an
    installed syntax highlight without the need for configuring it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.jsx`文件的原因是它使文本编辑器能够匹配已安装的语法高亮，而无需进行配置。
- en: Mutating properties
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改属性
- en: 'Once your React component is rendered, it''s not recommended to mutate its
    properties. This is considered an antipattern. Properties are immutable, and they
    roughly represent your presentation once it''s rendered. Consider the following
    code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的React组件被渲染，不建议修改其属性。这被认为是一种反模式。属性是不可变的，它们大致代表了渲染后的表示。考虑以下代码：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Although this work has a great chance to end up in unexpected results. The component's
    state is the only way to mutate data in a ReactJS component. The next two chapters
    cover details of props and states and when and where they should be used. States
    and properties are both keys in how ReactJS core works.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这项工作有很大可能产生意外结果。在ReactJS组件中，组件的状态是唯一修改数据的方式。接下来的两章将涵盖props和状态的详细信息以及它们何时何地应该被使用。状态和属性都是ReactJS核心工作方式的关键。
- en: Comments
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: 'JSX allows you to place comments in your code; they differ in syntax depending
    on whether you''re placing them in a nested component or outside of it. Follow
    the next example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: JSX允许您在代码中放置注释；它们的语法取决于您是将它们放置在嵌套组件内部还是外部。请参考以下示例：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When within a nested component, you just need to wrap your comment with curly
    braces (like expressions).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套组件内部时，您只需将注释用大括号（如表达式）括起来。
- en: Component style
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件样式
- en: You can either style your component with the `className` or `style` properties.
    The `className` property works in the same way HTML class does and the `style`
    property applies inline style to your component, also similar to HTML. It's up
    to you to choose one that you prefer; both of them have an easy way to be handled
    in ReactJS, mainly when you need it to be dynamic.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`className`或`style`属性来设置组件样式。`className`属性与HTML类的作用方式相同，而`style`属性则将内联样式应用于组件，这与HTML类似。您可以选择您更喜欢的其中一个；在ReactJS中，它们都有简单的方式来处理，尤其是在您需要它们动态时。
- en: Style
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式
- en: 'Whenever you want to apply style to your component, you can use a JavaScript
    object to do so. This object''s properties must match the DOM style specification,
    such as `height`, `width`, and so on. See the example here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您想为组件应用样式时，您可以使用一个JavaScript对象来实现。此对象的属性必须与DOM样式规范匹配，例如`height`、`width`等。请参见以下示例：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is going to render a red small square `div` with text inside. You can
    move this style object to a variable and dynamically set that depending on your
    component properties or state. Properties and state will be discussed later in
    [Chapter 3](part0025_split_000.html#page "Chapter 3. Working with Properties"),
    *Breaking Your UI into Components* and [Chapter 4](part0029_split_000.html#page
    "Chapter 4. Stateful Components and Events"), *Stateful Components and Events*,
    respectively. For demonstration purposes, this is how you move this style object
    out of the component markup:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这将渲染一个带有文本的红色小正方形`div`。您可以将此样式对象移动到变量中，并根据组件属性或状态动态设置它。属性和状态将在[第3章](part0025_split_000.html#page
    "第3章。使用属性")、*将UI拆分为组件*和[第4章](part0029_split_000.html#page "第4章。有状态组件和事件")、*有状态组件和事件*中详细讨论。为了演示目的，这是将此样式对象从组件标记中移出的方法：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When you have styles where names are separated by dashes `-`, you need to write
    them in CamelCase, as you can see in our example for the `backgroundColor` style
    property earlier. Vendor prefixes other than `ms` should begin with a capital
    letter; for example, `WebkitTransition` will be transformed to `webkit-transition`
    and `msTransition` will be transformed to `ms-transition`. All other vendor names
    must begin with a capital letter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的样式名称由破折号 `-` 分隔时，你需要将它们写成驼峰式，就像你可以在我们之前示例中的 `backgroundColor` 样式属性中看到的那样。除了
    `ms` 之外的其他供应商前缀应该以大写字母开头；例如，`WebkitTransition` 将被转换为 `webkit-transition`，而 `msTransition`
    将被转换为 `ms-transition`。所有其他供应商名称都必须以大写字母开头。
- en: CSS classes
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSS 类
- en: 'In order to add CSS classes to your component, you need to specify the `className`
    property for them: `<component className="class1 class2" />`. Unfortunately, `className`
    doesn''t support an object literal like style does. If we want to change them
    dynamically, you need to concatenate strings or use classnames from [https://github.com/JedWatson/classnames](https://github.com/JedWatson/classnames).
    Consider the following example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向你的组件添加 CSS 类，你需要为它们指定 `className` 属性：`<component className="class1 class2"
    />`。不幸的是，`className` 不支持像 `style` 那样的对象字面量。如果我们想动态地改变它们，我们需要连接字符串或使用来自 [https://github.com/JedWatson/classnames](https://github.com/JedWatson/classnames)
    的类名。考虑以下示例：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In this example, we are concatenating strings, but this is a very tedious task
    to do, and it might lead to mistakes and errors. There is a class manipulation
    utility provided by ReactJS add-ons. If we are using ReactJS library script file,
    you should get the one that comes with add-ons embedded, as mentioned in downloading
    the ReactJS section on [Chapter 1](part0015_split_000.html#page "Chapter 1. Getting
    Started with ReactJS"), *Getting Started with ReactJS*:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在连接字符串，但这是一项非常繁琐的任务，可能会导致错误和错误。ReactJS 插件提供了一个类操作实用工具。如果我们使用 ReactJS
    库脚本文件，我们应该获取带有插件内嵌的那个，如[第1章](part0015_split_000.html#page "第1章. ReactJS 入门")中提到的下载
    ReactJS 部分*ReactJS 入门*：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you are using node or other CommonJS/AMD package to require ReactJS dependency,
    you can reference add-ons through requiring `require('react/addons')` instead
    of just requiring React.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 node 或其他 CommonJS/AMD 包来要求 ReactJS 依赖项，你可以通过 `require('react/addons')`
    来引用插件，而不是仅仅要求 React。
- en: 'Now, let''s check how our code functions using this utility code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查我们的代码使用这个实用工具代码是如何工作的：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Try changing the `isUrgent` property and see that the class property changes
    when you reload the page.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改 `isUrgent` 属性，并查看当你重新加载页面时类属性是如何改变的。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned what JSX is, its syntax, and why it is necessary.
    We looked into some examples and how to build them using JSX. We covered very
    basic principles of ReactJS and how JSX helps you build components faster, easy
    to read, and reasonable.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了 JSX 是什么，它的语法，以及为什么它是必要的。我们查看了一些示例，并了解了如何使用 JSX 构建。我们涵盖了 ReactJS 的非常基本的原则，以及
    JSX 如何帮助你更快、更容易阅读和合理地构建组件。
- en: In the next chapter, we are going to dive into ReactJS properties and how to
    break the UI into smaller components. You are going to learn it by creating a
    small application that will consume the Facebook Open Graph API and list your
    liked pages.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨 ReactJS 属性以及如何将 UI 分解成更小的组件。你将通过创建一个小型应用程序来学习，该应用程序将消耗 Facebook
    Open Graph API 并列出你喜欢的页面。
