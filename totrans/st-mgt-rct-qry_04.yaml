- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fetching Data with React Query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Query allows you to fetch, cache, and handle your server state by leveraging
    one of its custom hooks called `useQuery`. For your data to be cached, React Query
    has a concept called a query key. In combination with the query keys and a couple
    of strict defaults, React Query takes your server state management to the next
    level.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will be introduced to the `useQuery` hook and understand
    how React Query allows you to fetch and cache your data. During this process,
    you will get to know all the defaults that are used in all of your queries. You
    will also be introduced to some options you can use to make your `useQuery` experience
    even better.
  prefs: []
  type: TYPE_NORMAL
- en: After becoming familiar with `useQuery`, you can start using it to refetch your
    queries in certain scenarios. You will also be able to leverage some extra properties
    of `useQuery` to fetch queries that depend on each other.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, we’ll review a code file to review what we learned
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is `useQuery` and how does it work?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refetching data with `useQuery`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching dependent queries with `useQuery`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_4](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_4).
  prefs: []
  type: TYPE_NORMAL
- en: What is useQuery and how does it work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you learned in the previous chapter, a query is a request you send to an
    asynchronous source to fetch data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the React Query documentation, queries are also defined in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: A query is a declarative dependency on an asynchronous source of data that is
    tied to a unique key.
  prefs: []
  type: TYPE_NORMAL
- en: ([https://tanstack.com/query/v4/docs/guides/queries](https://tanstack.com/query/v4/docs/guides/queries))
  prefs: []
  type: TYPE_NORMAL
- en: With that concept under your belt, you are now ready to understand how React
    Query leverages its custom hook, called `useQuery`, to enable you to subscribe
    to a query.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `useQuery` custom hook, you have to import it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `useQuery` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `useQuery` hook only needs two parameters for it to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A query key**: A unique key used to identify your query'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A query function**: A function that returns a promise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a query key?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The query key is a unique value used by React Query to identify your queries.
    It is also by using the query key that React Query caches your data in `QueryCache`.
    The query key also allows you to manually interact with the query cache.
  prefs: []
  type: TYPE_NORMAL
- en: The query key needs to be an array that can contain just one string or a bunch
    of other values, such as objects. All that matters is that the values inside this
    query key array are serializable.
  prefs: []
  type: TYPE_NORMAL
- en: Before React Query v4, the query key didn’t necessarily need to be an array.
    It could just be a single string because React Query would convert it internally
    into an array. So, don’t find it weird if you find some examples online that don’t
    use an array as a query key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some valid examples of query keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, so long as it is an array, the query key will be valid.
  prefs: []
  type: TYPE_NORMAL
- en: As good practice and to make your query key more distinct and easier to identify
    while reading through multiple `useQuery` hooks, you should add all the dependencies
    of your query as part of the query key. Think of it as the same model of the dependency
    array you have on your `useEffect` hook. This is helpful for reading purposes
    as well as because the query key also allows React Query to refetch queries automatically
    when a dependency of the query changes.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to keep in mind is that the query key is hashed deterministically.
    This means that the order of the items inside the array matters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some queries whose query keys, when hashed deterministically, are
    the same query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: All these examples are the same query – the order of the array in the query
    key is kept the same throughout the three examples.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you might be wondering how is that possible, considering that the inside
    of the object page and filters changed place every time, and in the last example,
    there was a third property called `random`. This is true, but they are still inside
    an object and that object doesn’t change its position inside the query key array.
    Also, the `random` property is undefined, so when hashing the object, it is excluded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at some queries whose query keys, when hashed deterministically,
    are not the same query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'All these examples represent different queries because when the query key is
    hashed deterministically, these examples end up being completely different queries.
    You might be wondering why the first example is not the same as the last one.
    Shouldn’t the `undefined` value disappear as it did from the `{ queryKey: [''users'',
    10, { page, random: undefined, filters }] })` object?'
  prefs: []
  type: TYPE_NORMAL
- en: No, because in this scenario, it’s not inside an object, and the order matters.
    When it’s hashed, this undefined value will be transformed into a null value inside
    the hashed key.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are familiar with query keys, you can learn more about query functions.
  prefs: []
  type: TYPE_NORMAL
- en: What is a query function?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A query function is a function that returns a promise. This returned promise
    will either resolve and return the data or throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: As the query function just needs to return a promise, it makes React Query even
    more powerful because the query function can support any client capable of performing
    asynchronous data fetching. This means that both **REST** and **GraphQL** are
    supported, so you can have both options at the same time if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at an example of a query function that uses GraphQL and another
    that uses REST:'
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we can see an example of using React Query with GraphQL.
    This is what we are doing:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating our GraphQL query and assigning it to our `customQuery`
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we create the `fetchGQL` function, which will be our query function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our `useQuery` hook, we pass the respective query key to the hook and our
    `fetchGQL` function as the query function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s see how to do this using REST:'
  prefs: []
  type: TYPE_NORMAL
- en: REST
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we can see an example of using React Query with REST.
    This is what we are doing:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating the `fetchData` function, which will be our query function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our `useQuery` hook, we pass the respective query key to the hook and our
    `fetchData` function as the query function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These examples make React Query shine even more because so long as you have
    a client that can perform asynchronous data fetching, the client can be used in
    your query function. As mentioned previously, just so that React Query can handle
    your error scenarios properly, one thing that we need to check when using these
    clients is if they automatically throw an error when your request fails. If they
    do not throw an error, you must throw the error yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you can do this in a query function that uses `fetch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, after performing a request using `fetch`, we check
    if our response is valid. If it is not, we throw an error. If everything is OK,
    we return the response data.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that will eventually pass through your mind as you keep creating queries
    and building your query functions is that it would be helpful to pass your query
    key to your query function. After all, if query keys represent the dependencies
    of your query, then it makes sense that you might need them in your query function.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this, and there are two patterns to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inline function**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QueryFunctionContext**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you don’t have many parameters in your query key that need to be passed
    to your query function, you can leverage this pattern. By writing an inline function,
    you can provide access to the variables in the current scope and pass them to
    your query function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we start by creating a `fetchData` function that will
    receive a parameter called `someVariable`. This parameter is then used to complement
    the URL used to fetch the data. When we get to our `useQuery` declaration, since
    we need our `someVariable` variable to be used as a dependency of our query, we
    include it in the query key. Finally, in the query function, we create an inline
    function that will call `fetchData` with our `someVariable` value.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this pattern is great whenever we don’t have many parameters.
    Now, think about the use case where your query key ended up with 12 parameters,
    and all of them were needed inside of the query function. It’s not a bad practice,
    but it will impact your code readability a bit. To avoid these cases, you can
    resort to the `QueryFunctionContext` object.
  prefs: []
  type: TYPE_NORMAL
- en: QueryFunctionContext
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every time the query function is called, React Query will take care of automatically
    passing your query key to the query function as the `QueryFunctionContext` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of using the `QueryFunctionContext` pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we start by creating our `fetchData` function. This
    function will be receiving `QueryFunctionContext` as a parameter, so from this
    object, we can immediately destructure `queryKey`. As you know from the *What
    is a query key?* section, the query key is an array, so the order in which we
    passed the parameters we need in our function to our query key matters. In this
    example, we need the `someVariable` variable, which was passed as the second element
    of our array, so we destructure our array to get the second element. We then use
    `someVariable` to complement the URL used to fetch the data. When we get to our
    `useQuery` declaration, since we need our `someVariable` variable to be used as
    a dependency of our query, we include it in the query key. As it is included in
    the query key, it will automatically be sent to our query function.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern reduces the need to create an inline function and enforces the
    need to add all the dependencies of your query to the query key. The one downside
    this pattern might have is that with so many parameters, you will have to remember
    the order you added them to the query key to use them in the query function. One
    way to fix this issue is by sending an object with all the parameters you need
    in your query function. This way, you remove the need to remember the order of
    the elements of your array.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: By passing an object as your query key, the object will be sent as the `QueryFunctionContext`
    object to your query function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in your function, you only need to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we destructure our `queryKey` from our `QueryFunctionContext`
    object. Then, since our object will be in the first position of the query key,
    we can destructure the value we need from our object there.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the two required options of every `useQuery` hook, we
    can start looking at what it returns.
  prefs: []
  type: TYPE_NORMAL
- en: What does useQuery return?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using the `useQuery` hook, it returns a couple of values. To access these
    values, you can just assign the return of the hook to a variable or destructure
    the values from the return of the hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we can see the two different ways to access the return values
    of the `useQuery` hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll review the following returns of the `useQuery` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetchStatus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This variable is the last successfully resolved data returned from your query
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you can use the `data` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We destructure our `data` variable from our `useQuery` hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On our return, we check if we already have data from our query. When we do,
    we render it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the query executes initially, this data will be undefined. Once it finishes
    executing and the query function successfully resolves your data, we will have
    access to the data. If, for some reason, our query function promise rejects, then
    we can use the next variable: `error`.'
  prefs: []
  type: TYPE_NORMAL
- en: error
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `error` variable lets you access the error object returned from your query
    function after failing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you can use the `error` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We destructure our `error` variable from our `useQuery` hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On our return, we check if we have any errors. If we do, we render the `error`
    message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the query executes initially, the `error` value will be null. If, for some
    reason, the query function rejects and throws an error, then this error will be
    assigned to our `error` variable.
  prefs: []
  type: TYPE_NORMAL
- en: In both the `data` and `error` examples, we checked if they were defined so
    that we could let our application users know the current status of our query.
    To make this easier and help you craft a better user experience for your application,
    the `status` variable was added.
  prefs: []
  type: TYPE_NORMAL
- en: status
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When performing a query, the query can go through several states. These states
    help you give more feedback to your user. For you to know what the current state
    of your query is, the `status` variable was created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the states that the `status` variable can have:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loading`: No query attempt has finished and there is still no cached data
    yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`: There was an error while performing a query. Whenever this is the
    status, the `error` property will receive the error returned from the query function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`success`: Your query was successful and it has returned data. Whenever this
    is the status, the `data` property will receive the successful data from the query
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how you can use the `status` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we are leveraging the `status` variable to create
    a better user experience for our users. This is what we are doing:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by destructuring the `status` variable from the `useQuery` hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We check if `status` is loading. This means that we still don’t have any data
    and our query has finished. If this is the case, we render a loading indicator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If our `status` is not loading, we check if there was any error during our query.
    If our `status` equals `error`, then we need to destructure our `error` variable
    and display the error message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, if our `status` is also not an error, then we can safely assume that
    our `status` equals success; therefore, we should have our `data` variable with
    the data our query function returned and we can display it to our user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, you know how to use the `status` variable. For convenience, React Query
    also introduced some Boolean variants to help us identify each state. They are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isLoading`: Your `status` variable is in the loading state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isError`: Your `status` variable is in the error state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isSuccess`: Your `status` variable is in the success state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s rewrite our previous snippet leveraging our `status` Boolean variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code is similar. All we had to do was replace our `status`
    variable with `isLoading` and `isError` in the destructuring and then use the
    `isLoading` and `isError` variables in the respective status check.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the `status` variable gives you information about your query data. However,
    this is not the only status variable that React Query has. In the next section,
    you will be introduced to `fetchStatus`.
  prefs: []
  type: TYPE_NORMAL
- en: fetchStatus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With React Query v3, they found that there was an issue when handling scenarios
    where the user would go offline. If the user triggered a query but for some reason
    lost connection during the request, the `status` variable would stay pending in
    the loading state until the user got the connection back and the query was automatically
    retried.
  prefs: []
  type: TYPE_NORMAL
- en: To deal with this type of issue, in React Query v4, they introduced a new property
    called `networkMode`. This property can have three states, but by default, it
    will use the online one. The good thing is that this mode enables you to use the
    `fetchStatus` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `fetchStatus` variable gives you information about your query function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the states this variable can have:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fetching`: Your query function is currently executing. This means that it’s
    currently fetching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paused`: Your query wanted to fetch but due to a lost connection, it has now
    stopped executing. This means that it’s currently paused.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`idle`: The query is not doing anything at the moment. This means that it’s
    currently idle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s learn how to use the `fetchStatus` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we are leveraging the `fetchStatus` variable to create
    a better user experience for our users. This is what we are doing:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by destructuring the `fetchStatus` variable from the return of our
    `useQuery` hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then check if the current state of our `fetchStatus` is paused. If this is
    `true`, then right now, there is no network connection, so we let our user know.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the previous `If check` is `false`, then we can validate if the current state
    of our `fetchStatus` is fetching. If the previous `If check` is `true`, then right
    now, the query function is running, so we let our user know.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we are not fetching, then we can assume our query function’s `fetchStatus`
    is idle; therefore, it has already finished fetching, so we should have the returned
    data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, you know how to use the `fetchStatus` variable. Just like for the `status`
    variable, React Query also introduced some Boolean variants to help identify two
    of these statuses. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isFetching`: Your `fetchStatus` variable is in the fetching state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isPaused`: Your `fetchStatus` variable is in the paused state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s rewrite our previous snippet leveraging our `fetchStatus` Boolean variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the snippet, the code is quite similar. All we had to do
    was replace our `fetchStatus` variable with `isFetching` and `isPaused` in the
    destructuring and then use these `isFetching` and `isPaused` variables in the
    respective `fetchStatus` check.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are aware of the values our `useQuery` hook returns, let’s see how
    we can customize the same hook with the use of some options.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly used options explained
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using the `useQuery` hook, more options can be passed into it than the
    query key and query function. These options help you craft a better developer
    experience, as well as a better user experience.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll look at some options that are more common and very important
    for you to be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the options we’ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: '`staleTime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cacheTime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retry`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retryDelay`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enabled`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onSuccess`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: staleTime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `staleTime` option is the duration in milliseconds until query data is no
    longer considered *fresh*. When the set time elapses, a query is called *stale*.
  prefs: []
  type: TYPE_NORMAL
- en: While the query is *fresh*, it will be pulled from the cache without triggering
    a new request to update the cache. When the query is marked as *stale*, data will
    still be pulled from the cache but an automatic refetch of the query can be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: By default, all queries use `staleTime` set to `0`. This means that all cached
    data will be considered *stale* by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we can configure `staleTime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we define that the query data of this hook will be considered
    *fresh* for one minute.
  prefs: []
  type: TYPE_NORMAL
- en: cacheTime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `cacheTime` option is the duration in milliseconds that the data in your
    cache that is inactive remains in memory. Once this time passes, the data will
    be garbage collected.
  prefs: []
  type: TYPE_NORMAL
- en: By default, queries are marked as inactive when they have no active instance
    of a `useQuery` hook. When this happens, this query data will be held in the cache
    for 5 minutes. After these 5 minutes, this data will be garbage collected.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how to use the `cacheTime` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the snippet, we define that after our query is inactive for 1 minute, the
    data will be garbage collected.
  prefs: []
  type: TYPE_NORMAL
- en: retry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `retry` option is a value that indicates whether your query will retry or
    not when it fails. When `true`, it will retry until it succeeds. When `false`,
    it won’t retry.
  prefs: []
  type: TYPE_NORMAL
- en: This property can also be a number. When it is a number, the query will retry
    that specified number of times.
  prefs: []
  type: TYPE_NORMAL
- en: By default, all queries that are failing will be retried three times.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how to use the `retry` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we set the `retry` option as `false`. This means that when
    failing to fetch a query, this hook won’t retry to fetch the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also configure the `retry` option this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we set the `retry` option with the number `1`. This means that
    if this hook fails to fetch a query, then it will only retry the request once.
  prefs: []
  type: TYPE_NORMAL
- en: retryDelay
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`retryDelay` option is the delay to apply before the next retry attempt in
    milliseconds.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, React Query uses an exponential backoff delay algorithm to define
    the retry timing between retries.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how to use the `retryDelay` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the snippet, we define a linear backoff function as our `retryDelay` option.
    Every time there is a retry, this function receives the attempt number and multiplies
    it by `2000`. This means that the time between every retry will be 2 seconds longer.
  prefs: []
  type: TYPE_NORMAL
- en: enabled
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `enabled` option is a Boolean value that indicates when your query can run
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: By default, this value is `true`, so all queries are enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we can use the `enabled` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we assign the return of the expression evaluation to the `enabled`
    option. This means that whenever the length of `arrayVariable` is greater than
    0, this query will execute.
  prefs: []
  type: TYPE_NORMAL
- en: onSuccess
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `onSuccess` option is a function that will be triggered when your query
    is successful while fetching.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we can use the `onSuccess` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we pass an arrow function to our `onSuccess` option. When our
    query fetches successfully, this function will be called with our `data`. We then
    use this `data` to log to our `console`.
  prefs: []
  type: TYPE_NORMAL
- en: onError
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `onError` option is a function that will be triggered when your query fails
    while fetching.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we can use the `onError` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we pass an arrow function to our `onError` option. When the
    query fails, this function will be called with the `thrown` error. We then log
    the error in our `console`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `useQuery` hook supports a lot of options and the ones that
    were presented were only the tip of the iceberg. In the upcoming sections and
    chapters, you’ll be introduced to more, so prepare yourself!
  prefs: []
  type: TYPE_NORMAL
- en: You are now familiar with the `useQuery` hook and should be able to use it to
    start fetching your server state data. Now, let’s see some patterns and ways we
    can use this hook to deal with some common server state challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Refetching data with useQuery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refetching is an important part of managing our server state. Sometimes, you
    need your data to be updated because your data has become stale or just because
    you haven’t interacted with your page in a while.
  prefs: []
  type: TYPE_NORMAL
- en: Manually or automatically, React Query supports and allows you to refetch your
    data.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll see how it works and what automatic and manual ways you
    can leverage to refetch your data.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic refetching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React Query has baked in a couple of options to make your life easier and keep
    your server state fresh. To do this, it automatically takes care of data refetching
    in certain cases.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the things that allow React Query to perform data refetching automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Query keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Query keys are used to identify your query.
  prefs: []
  type: TYPE_NORMAL
- en: When talking about query keys previously, I mentioned several times that we
    should include all of our query function dependencies as part of our query key.
    Why did I say that?
  prefs: []
  type: TYPE_NORMAL
- en: Because whenever some of those dependencies change, so will your query key,
    and when your query key changes, your query with be automatically refetched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we define a `useQuery` hook that has `someVariable`
    as part of its query key. This query will be fetched on the initial render like
    usual, but when we click on our button, the `someVariable` value will change.
    The query key will also change, which will trigger a query refetch for you to
    get your new data.
  prefs: []
  type: TYPE_NORMAL
- en: Refetching options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a couple of options I did not share in the *Commonly used options
    explained* section. This is because they are enabled by default, and it is often
    better to leave them on unless they don’t suit your use case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the options related to data refetching that `useQuery` has enabled
    by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '`refetchOnWindowFocus`: Whenever you focus on your current window, this option
    triggers a refetch. For example, if you change tabs when you return to your application,
    React Query will trigger a refetch of your data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`refetchOnMount`: Whenever your hook mounts, this option triggers a refetch.
    For example, when a new component that uses your hook mounts, React Query will
    trigger a refetch of your data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`refetchOnReconnect`: Whenever you lose your internet connection, this option
    will trigger a refetch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One thing that is important to note is that these options will only refetch
    your data by default if your data is marked as stale. This refetching of data
    even if its stale can be configured since all these options, excluding the Boolean
    value, also support receiving a string with a value of `always`. When the value
    of these options is `always`, it will always retrigger a refetch, even if the
    data is not stale.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how to configure them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we are doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: For the `refetchOnMount` option, we always want our hook to refetch our data
    whenever any component using it mounts, even if the cached data is not stale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `refetchOnReconnect`, we want our hook to refetch our data whenever we regain
    connection after being offline, but only if our data is stale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `refetchOnWindowFocus`, we never want our hook to refetch our data on window
    focus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, one thing that might cross your mind is if there is any way to force our
    hook to refetch our data every couple of seconds, even if our data is not stale.
    Well, even if you didn’t think about it, React Query allows you to do it.
  prefs: []
  type: TYPE_NORMAL
- en: React Query adds another refetch-related option called `refetchInterval`. This
    option allows you to specify a frequency in milliseconds for your query to refetch
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we configure our hook to always refetch every 2 seconds. We
    also add another option called `refetchIntervalInBackground` with `true` as its
    value. This option will allow your query to keep refetching, even if your window
    or tab is in the background.
  prefs: []
  type: TYPE_NORMAL
- en: This wraps up automatic refetching. Now, let’s see how we can trigger manual
    refetches in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Manual refetching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways to manually trigger a query refetch. You could use `QueryClient`
    or get the `refetch` function from the hook.
  prefs: []
  type: TYPE_NORMAL
- en: Using QueryClient
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you may recall from the previous chapter, `QueryClient` allows you to have
    an interface between the developer and the query cache. This allows you to leverage
    `QueryClient` to force a data refetch when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you can trigger a data refetch using `QueryClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we are doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `useQueryClient` hook to get access to our `QueryClient`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `QueryClient`, we are calling one of the functions it exposes, called
    `refetchQueries`. This function allows you to trigger a refetch of all the queries
    that match the given query key. In this snippet, we are triggering a request for
    all queries that have the `["api"]` query key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the refetch function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every `useQuery` hook exposes a `refetch` function for convenience. This function
    will allow you to trigger a refetch for just that query.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we are destructuring the `refetch` function from our `useQuery`
    hook. Then, we can call that function whenever we want to force that query to
    refetch.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how React Query enables you to manually and automatically
    refetch your data, let’s see how we can create queries that depend on other queries.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching dependent queries with useQuery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, during our development process, we need to have values that are returned
    from one query that we can use in another query or have a query execution depend
    on a previous query. When this happens, we need to have what is called a dependent
    query.
  prefs: []
  type: TYPE_NORMAL
- en: React Query allows you to make a query depend on others via the `enabled` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we are doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We are creating a query that will have `["api"]` as the query key and the `fetchData`
    function as the query function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we are creating a Boolean variable called `canThisDependentQueryFetch`
    that will check if our previous query has the data we need. This Boolean variable
    will help us decide if our next query can fetch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we are creating our second query with `["dependentAPI", firstQueryData?.hello]`
    as the query key, the `fetchDependentData` function as the query function, and
    our `canThisDependentQueryFetch` as our `Boolean` variable for the `enabled` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the previous query finishes fetching the data, the `canThisDependentQueryFetch`
    Boolean will be set to `true` and enable this dependent query to run.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you only need the `enabled` option to make a query depend on
    another one. Now, before wrapping up this chapter, let’s put all your earned knowledge
    into practice.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all into practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you should be able to start handling some use cases for data
    fetching using the `useQuery` hook.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at a file with three components called `ComponentA`,
    `ComponentB`, and `ComponentC` that are doing some data fetching. We will use
    this file to review the concepts we have learned about and see if we fully understood
    how `useQuery` works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the beginning of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we are doing in the preceding snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: We import our `useQuery` and `useQueryClient` custom hooks from the React Query
    package to use in our components that will be defined in the next few snippets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We create a `fetchData` function that will receive our `QueryFunctionContext`.
    We then destructure our `queryKey` from it. Inside this function, we do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will be using an object as our query key in these examples so that we know
    that the first position of the array will have our query key properties, so we
    destructure our `apiName` from it.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We use `fetch` to trigger a `GET` request to our URL and use `apiName` to help
    define the route.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Because we are using `fetch` and not `axios`, we need to manually handle the
    scenario where our request failed. If our response is not OK, then we need to
    throw an error so that `useQuery` will be able to handle error scenarios.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If our response is valid, then we can return our response data.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then create two API constant values called `apiA` and `apiB` that define
    the route our components will use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s continue with our file and look at our first component, called `ComponentA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s review `ComponentA`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating our query by using the `useQuery` hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This query is identified with an object as the query key. This object has `api`
    as the `queryIdentifier` property and `apiA` as the `apiName` property.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: This query has the `fetchData` function as the query function.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: By using the `retry` option, we also specify that if this query fails to fetch,
    then the hook will only retry the request one time.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We also destructure `data`, `isLoading`, `isError`, and `isFetching` from the
    hook.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If no query attempt has finished and there is still no cached data, we want
    to render to the user that we are loading data. We use `isLoading` with an `If`
    check to do this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there was an error, we want to display it. We use `isError` to check if there
    was any error. If so, we render that error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If our query is not loading or has an error, then we can assume it was successful.
    We then render a `div` with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `p tag` that will check if our hook `isFetching`. If it is fetching, it will
    display `Fetching Component A`. If not, it will display the fetched data.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `ComponentB`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s look at `ComponentB`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we are doing in `ComponentB`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating our query by using the `useQuery` hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This query is identified with an object as the query key. This object has `api`
    as the `queryIdentifier` property and `apiB` as the `apiName` property.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: This query has the `fetchData` function as the query function.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `onSuccess` option and pass it a function that will receive our `data`
    and log it on our `console`, as well as an indication that this component has
    fetched the data.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We also destructure `data` from the hook.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then return a `div` to be rendered with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our `hello` property from our fetched data. One thing that you might see is
    that we used the `?.` operator. We leverage optional chaining here to make sure
    there is no error, and we only render our `hello` property when our data is defined.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `ComponentC`. This component will receive our `ComponentB` data as its `parentData`
    prop.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s wrap up our file review by looking at `ComponentC`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'So, this is what is happening in `ComponentC`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating our query by using the `useQuery` hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This query is identified with an object as the query key. This object has `api`
    as the `queryIdentifier` property and `apiA` as the `apiName` property.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: This query has the `fetchData` function as the query function.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `enabled` option to make this query depend on `parentData`; therefore,
    this query will only run after the query in `ComponentB` finishes and resolves
    data.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We destructure `data` and `isFetching` from the hook.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `useQueryClient` hook to get access to our `QueryClient`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we return a `div` that will be rendered with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `p tag` that will check if our hook `isFetching`. If it is fetching, it displays
    `Fetching Component C`. If not, it displays the fetched data.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A button that, when clicked, will use `queryClient` to refetch the query whose
    query key has `api` as the `queryIdentifier` property and `apiA` as the `apiName`
    property. This means that on this button click, both `useQuery` in `ComponentA`
    and `useQuery` in `ComponentC` will refetch some data.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, in the preceding snippet, we do a default export of our `ComponentA`,
    so it is the entry point in this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve seen the code file, let’s review the life cycle of the hooks
    and understand what is happening in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When `ComponentA` renders, the following occurs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An instance of `useQuery` with the `[{ queryIdentifier: "api", apiName: apiA
    }]` query key mounts:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Since this is the first mount, there is no cache nor previous requests, so our
    query will start fetching our data, and its `status` will be loading. Also, our
    query function will receive our query key as part of `QueryFunctionContext`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When our data fetching succeeds, the data will be cached under the `[{ queryIdentifier:
    "api", apiName: apiA }]` query key.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we are assuming the default `staleTime`, which is `0`, the hook will mark
    its data as stale.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When `ComponentA` renders `ComponentB`, the following occurs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An instance of `useQuery` with the `[{ queryIdentifier: "api", apiName: apiB
    }]` query key mounts:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Since this is the first mount, there is no cache nor previous requests, so our
    query will start fetching our data, and its `status` will be loading. Also, our
    query function will receive our query key as part of `QueryFunctionContext`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When our data fetching succeeds, the data will be cached under the `[{ queryIdentifier:
    "api", apiName: apiB }]` query key and the hook will call the `onSuccess` function.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we are assuming the default `staleTime`, which is `0`, the hook will mark
    its data as stale.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When `ComponentB` renders `ComponentC`, the following occurs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An instance of `useQuery` with the `[{ queryIdentifier: "api", apiName: apiA
    }]` query key mounts:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As this hook has the same query key as the hook in `ComponentA`, the hook will
    already have cached data under it, so the data is immediately accessible.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Since this query was marked as stale after the previous fetch, this hook needs
    to refetch it, but it needs to wait for the query to be enabled first since this
    query depends on us having the data of `ComponentB` first.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once it’s been enabled, the query will trigger a refetch. This makes `isFetching`
    on both `ComponentA` and `ComponentC` to be `true`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the fetch request succeeds, the data will be cached under the `[{ queryIdentifier:
    "api", apiName: apiA }]` query key, and the query is marked as stale again.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, considering it is the parent component, let’s picture a scenario where
    `ComponentA` unmounts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since there is no longer any instance of the query with the `[{ queryIdentifier:
    "api", apiName: apiA }]` query key active, the default cache timeout of 5 minutes
    is set'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once 5 minutes pass, the data under this query is deleted and garbage collected
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since there is no longer any instance of the query with the `[{ queryIdentifier:
    "api", apiName: apiB }]` query key active, the default cache timeout of 5 minutes
    is set'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once 5 minutes pass, the data under this query is deleted and garbage collected
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you managed to keep track of this previous process and the life cycle of
    your queries during their usage, then congratulations: you understand how `useQuery`
    works!'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the `useQuery` custom hook and how it allows
    you to fetch and cache your data by using its required options, called query key
    and query function. You learned how to define your query key and how your query
    function allows you to use any data-fetching client such as GraphQL or REST, so
    long it returns a promise or throws an error.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned about some of the things that the `useQuery` hook returns,
    such as the query’s `data` and `error`. For you to craft a better user experience,
    you were also introduced to `status` and `fetchStatus`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For you to customize your developer experience and take it to the next level,
    you learned about some commonly used options you can use to customize your `useQuery`
    hook and make it behave as you want it to. For your convenience, here are the
    compiled defaults to be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: '`staleTime`: 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cacheTime`: 5 * 60 * 1,000 (5 minutes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retry`: 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retryDelay`: Exponential backoff delay algorithm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enabled`: True'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before wrapping up, you learned about some patterns for dealing with server
    state challenges such as refetching and dependent queries.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you put everything you learned into practice and reviewed an example
    that showed you how to leverage all this knowledge and how the `useQuery` hook
    works internally when you do.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B18501_05.xhtml#_idTextAnchor140), *More Data-Fetching Challenges*,
    you will continue to learn how you can use the `useQuery` hook to solve some more
    common server state challenges, such as data prefetching, paginated requests,
    and infinite queries. You will also put the DevTools to use to help you debug
    your queries.
  prefs: []
  type: TYPE_NORMAL
