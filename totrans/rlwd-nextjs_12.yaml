- en: '*Chapter 10*: Working with SEO and Managing Performance'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：与SEO合作并管理性能'
- en: '**SEO** (short for **Search Engine Optimization**) and performances are two
    topics that go hand in hand during the development process as a whole.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**SEO**（即**搜索引擎优化**）和性能是两个在整体开发过程中紧密相连的话题。'
- en: Even though there have been multiple enhancements on the Next.js side to improve
    performances and facilitate SEO best practices, we still need to know where our
    application could potentially create any problems that would result in poor search
    engine indexing and a lousy user experience.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Next.js方面已经进行了多次增强，以改进性能并促进SEO最佳实践，但我们仍然需要知道我们的应用程序可能在哪些方面可能产生问题，从而导致搜索引擎索引不佳和糟糕的用户体验。
- en: 'In this chapter, we will cover the following topics in detail:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细介绍以下主题：
- en: Choosing the proper rendering method for your application (SSR, SSG, CSR).
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的应用程序选择合适的渲染方法（SSR、SSG、CSR）。
- en: When an application will typically fail on the performance aspect
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序在性能方面通常会失败的情况
- en: How to use the Vercel Analytics module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Vercel Analytics模块
- en: Tools that help us to write SEO-friendly web applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助我们编写SEO友好型Web应用程序的工具
- en: By the end of this chapter, you'll be able to optimize your web application
    for SEO and performance by learning some of the best practices and tools for dealing
    with such complex topics.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将通过学习处理这些复杂主题的一些最佳实践和工具，能够优化您的Web应用程序以实现SEO和性能。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run the code examples in this chapter, you need to have both Node.js and
    npm installed on your local machine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码示例，您需要在您的本地计算机上安装Node.js和npm。
- en: 'If you prefer, you can use an online IDE such as [https://repl.it](https://repl.it)
    or [https://codesandbox.io](https://codesandbox.io); they both support Next.js,
    and you don''t need to install any dependency on your computer. As for the other
    chapters, you can find the code base for this chapter on GitHub: [https://github.com/PacktPublishing/Real-World-Next.js](https://github.com/PacktPublishing/Real-World-Next.js).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，可以使用在线IDE，例如[https://repl.it](https://repl.it)或[https://codesandbox.io](https://codesandbox.io)；它们都支持Next.js，您不需要在您的计算机上安装任何依赖项。至于其他章节，您可以在GitHub上找到本章的代码库：[https://github.com/PacktPublishing/Real-World-Next.js](https://github.com/PacktPublishing/Real-World-Next.js)。
- en: SEO and performance – an introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SEO和性能 - 简介
- en: Since the rise of the first big search engines, web developers have struggled
    to find a way to optimize their web applications to get better positioning in
    search results on Google, Bing, Yandex, DuckDuckGo, and many other popular search
    engines.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 自从第一个大型搜索引擎兴起以来，Web开发者一直在努力寻找一种方法来优化他们的Web应用程序，以便在Google、Bing、Yandex、DuckDuckGo和其他许多流行搜索引擎的搜索结果中获得更好的排名。
- en: With the evolution of frontend web frameworks, things became even more complicated.
    While React, Angular, Vue (and many others) provide a fantastic way to deal with
    complex UIs, they make things a bit harder for web spiders, the bots responsible
    for indexing websites into a search engine. They need to execute JavaScript, wait
    for the UI to render, and eventually index highly dynamic web pages. In addition,
    many contents would be initially hidden, as they get generated dynamically by
    JavaScript on the frontend directly following user interaction.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着前端Web框架的演变，事情变得更加复杂。虽然React、Angular、Vue（以及许多其他框架）提供了一种处理复杂UI的绝佳方式，但它们让网络爬虫（负责将网站索引到搜索引擎中的机器人）的工作变得更加困难。它们需要执行JavaScript，等待UI渲染，并最终索引高度动态的网页。此外，许多内容最初都是隐藏的，因为它们在用户交互后由前端JavaScript直接动态生成。
- en: That caused many problems and made countless developers regret *the good old
    days* when the web was essentially server side rendered, where JavaScript was
    used to add just a touch of dynamism inside the UI.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了许多问题，让无数开发者后悔“那些美好的旧时光”，当时Web基本上是服务器端渲染的，JavaScript仅用于在UI中添加一点动态效果。
- en: OK, I exaggerated a bit. Developers eventually faced the fact that React, Angular,
    Vue, and all the other fellow frameworks bring such significant innovation to
    the web development sphere, and they wouldn't give up on them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我有点夸张了。开发者最终面对了这样一个事实：React、Angular、Vue以及其他同行框架给Web开发领域带来了如此重大的创新，他们不会放弃它们。
- en: Next.js is, in part, a response to those problems. While there are frameworks
    that only care about SEO and performance by generating all the web pages statically
    at build time (with all the limitations that this can bring, as seen in [*Chapter
    2*](B16985_02_Final_SB_epub.xhtml#_idTextAnchor029), *Exploring Different Rendering
    Strategies*), Next.js lets you decide which page needs to be statically generated
    and server side rendered, and which components need to be rendered exclusively
    on the client side.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js部分是对这些问题的回应。虽然有一些框架只关心SEO和性能，通过在构建时静态生成所有Web页面（如[第2章](B16985_02_Final_SB_epub.xhtml#_idTextAnchor029)中所述，*探索不同的渲染策略*），Next.js允许你决定哪些页面需要静态生成和服务器端渲染，哪些组件需要仅在客户端渲染。
- en: In [*Chapter 2*](B16985_02_Final_SB_epub.xhtml#_idTextAnchor029), *Exploring
    Different Rendering Strategies*, we described the differences between those rendering
    methods. In the next section, we will discuss some real-world examples of how
    to choose a rendering strategy when it comes to rendering a web page using Next.js.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](B16985_02_Final_SB_epub.xhtml#_idTextAnchor029)，*探索不同的渲染策略*中，我们描述了这些渲染方法之间的差异。在下一节中，我们将讨论一些使用Next.js渲染网页时选择渲染策略的实际例子。
- en: Rendering strategies, from a performance and SEO perspective
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从性能和SEO的角度来看，渲染策略
- en: Depending on the website or web application you want to build, you may consider
    different rendering strategies.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你想要构建的网站或Web应用，你可能需要考虑不同的渲染策略。
- en: Every rendering strategy has its pros and cons, but the great thing about Next.js
    is that you don't have to compromise. Instead, you can choose the best rendering
    strategy for every single page in your web application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每种渲染策略都有其优缺点，但Next.js的伟大之处在于你不必做出妥协。相反，你可以为你的Web应用中的每一页选择最佳的渲染策略。
- en: Let's pretend Next.js doesn't exist for a moment. Pretty scary, isn't it?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设一下，Next.js此刻并不存在。这听起来是不是很可怕？
- en: We want to build a web application using React, but we have to compromise between
    rendering strategies.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想使用React构建一个Web应用，但我们必须在渲染策略之间做出妥协。
- en: Client-side rendering is a great starting point. The application would be deployed
    as a JavaScript bundle that dynamically generates the HTML content once it gets
    downloaded to the web browser. The performances will be outstanding, as all the
    computation will be done on the client side. In addition, the user experience
    will be amazing, as the customers would feel as if they were using a native app.
    On the other hand, you'd have to struggle with SEO, as client-side rendering makes
    life harder for search engine bots.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端渲染是一个很好的起点。应用将以JavaScript包的形式部署，一旦下载到浏览器，就会动态生成HTML内容。性能将非常出色，因为所有计算都在客户端完成。此外，用户体验将非常出色，因为客户会感觉自己就像在使用原生应用。另一方面，你将不得不在SEO上挣扎，因为客户端渲染让搜索引擎爬虫的工作变得更难。
- en: On second thought, we may consider server-side rendering. We would render all
    the content that is important for SEO purposes on the server side, allowing the
    client to generate the rest. This could be the best option security-wise, as we
    can hide many data fetch, validation, and sensitive API calls on the backend.
    That's a good alternative but has some drawbacks. With client-side rendering,
    we've seen how the app could be bundled into a unique JavaScript file. With SSR,
    we will need to set up, maintain, and scale a server. With an increase in traffic,
    it would get slower, more expensive, and harder to maintain. Time to look for
    a third option.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重新考虑一下，我们可能会考虑服务器端渲染。我们会将所有对SEO重要的内容在服务器端渲染，允许客户端生成其余内容。这在安全性方面可能是最佳选择，因为我们可以在后端隐藏许多数据获取、验证和敏感的API调用。这是一个好的替代方案，但也有一些缺点。在客户端渲染中，我们已经看到应用如何被捆绑成一个独特的JavaScript文件。在SSR（服务器端渲染）中，我们需要设置、维护和扩展服务器。随着流量的增加，它将变慢、更昂贵，且更难维护。是时候寻找第三个选项了。
- en: Our last option is to generate the whole website at build time statically. We
    would achieve the best possible performance, while SEO scores would increase significantly,
    but we'd still have some significant drawbacks.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的选项是在构建时静态生成整个网站。我们会实现最佳的性能，同时SEO评分将显著提高，但仍然有一些显著的缺点。
- en: If our SEO-sensitive content changes frequently, we may need to re-render the
    whole website multiple times in a few hours. That could be a significant issue
    on large websites, as building can require quite a long time. Also, it would be
    harder to handle user security, as every sensitive API call (occurring after the
    building phase) or computation would happen on the client side exclusively.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的SEO敏感内容频繁更改，我们可能需要在几小时内多次重新渲染整个网站。这在大网站上可能是一个重大问题，因为构建可能需要相当长的时间。此外，处理用户安全性也会更困难，因为每个敏感API调用（在构建阶段之后发生）或计算都会在客户端独家进行。
- en: 'Let''s recap our options:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们的选择：
- en: '**Client-side rendering**(**CSR**): Great performance, highly dynamic content,
    but lousy SEO and security'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端渲染**（**CSR**）：出色的性能，高度动态的内容，但SEO和安全性较差'
- en: '**Server-side rendering**(**SSR**): Better SEO, excellent security, but possibly
    inferior performance, and more challenging to manage the server'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端渲染**（**SSR**）：更好的SEO，出色的安全性，但可能性能较差，且管理服务器更具挑战性'
- en: '**Static site generation**(**SSG**): Best possible performance, best possible
    SEO score, but lacking security and bad for highly dynamic content'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态站点生成**（**SSG**）：最佳性能，最佳SEO评分，但缺乏安全性且不适合高度动态的内容'
- en: Now we can finally stop pretending that Next.js doesn't exist and start appreciating
    the possibilities that this framework is giving us.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于可以停止假装Next.js不存在，并开始欣赏这个框架为我们提供的可能性。
- en: We don't have to choose one single rendering methodology to implement our web
    app. We can choose them all.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必选择单一渲染方法来实现我们的Web应用。我们可以选择所有这些方法。
- en: '![Figure 10.1 – Next.js rendering strategies'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 – Next.js渲染策略'
- en: '](img/Figure_10.01_B16985.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 – Next.js渲染策略](img/Figure_10.01_B16985.jpg)'
- en: Figure 10.1 – Next.js rendering strategies
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – Next.js渲染策略
- en: One of the key features of Next.js is the ability to choose whether to render
    a page on the server or generate it at build time (or even on the client side
    entirely).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js的一个关键特性是能够选择是否在服务器上渲染页面或在其构建时生成（甚至完全在客户端端进行）。
- en: Given that possibility, we can start reasoning about our website as a composition
    of different sections rendered in many different ways, depending on the purpose
    of each individual section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这种可能性，我们可以开始将我们的网站视为由不同部分组成，这些部分以多种不同的方式渲染，具体取决于每个部分的目的。
- en: In the next section, we will see how to choose the right rendering approach
    in a real-world website example.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过一个真实网站示例来了解如何选择正确的渲染方法。
- en: The reasoning behind a real-world website example
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真实网站示例背后的推理
- en: Let's pretend we're building a photography website. Users can upload their pictures
    and receive feedback and votes from the other users on the platform. When a user
    logs in, the home page will display a list of images posted by the user-followed
    profiles. Clicking on any of these pictures will open the picture detail page
    where we can read the comments, feedback, and history behind the photo.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们正在构建一个摄影网站。用户可以上传他们的照片，并从平台上的其他用户那里获得反馈和投票。当用户登录时，主页将显示用户关注者的照片列表。点击任何这些照片将打开图片详情页面，我们可以阅读关于照片的评论、反馈和历史。
- en: Given this information, we can start to think about how we want to render these
    website sections.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些信息，我们可以开始思考我们想要如何渲染这些网站部分。
- en: First, we know that the home page content changes depending on how the user
    browses it. We can then exclude statically generating the main list of pictures
    on the home page at build time, as the content is highly dynamic.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们知道主页内容会根据用户的浏览方式而变化。因此，我们可以在构建时排除静态生成主页上的主要图片列表，因为内容高度动态。
- en: 'We have the following options:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下几种选择：
- en: We statically render the home page with some placeholders for the images, which
    will be loaded later after React hydration on the client side, depending on whether
    the user is logged in and following anyone on the website.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用一些占位符静态渲染主页上的图片，这些图片将在客户端的React hydration之后加载，具体取决于用户是否登录以及是否关注网站上的任何人。
- en: We can render the page on the server side. Thanks to session cookies, we may
    already know if the user is logged in, and we can pre-render this list on the
    server before sending the page to the client.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在服务器端渲染页面。多亏了会话cookie，我们可能已经知道用户是否登录，我们可以在将页面发送到客户端之前在服务器上预先渲染这个列表。
- en: 'One thing is for sure: we don''t really care about SEO when dealing with this
    specific list of pictures. Google bots will never log in to this website, as there''s
    no reason to index custom content that is different for each user.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一件事是肯定的：当我们处理这个特定的图片列表时，我们并不真的关心SEO。谷歌机器人永远不会登录到这个网站，因为没有理由索引每个用户都不同的自定义内容。
- en: Talking about performance, we should consider a couple of points before deciding
    how we want to render the home page. If the API used for generating a customized
    stream of pictures is fast enough and the images are highly optimized, we can
    surely pre-render the whole list on the server side. Otherwise, we could create
    some good-looking skeleton loading placeholders that can entertain the user while
    we're waiting for the API to respond and the images to render on the frontend.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到性能，我们在决定如何渲染主页之前应该考虑几个因素。如果用于生成定制图片流的API足够快，并且图片高度优化，我们当然可以在服务器端预先渲染整个列表。否则，我们可以创建一些看起来不错的骨架加载占位符，在我们等待API响应和前端渲染图片时，可以娱乐用户。
- en: The worst-case scenario is that the API is slow, and the images are not optimized,
    hence we need to be prepared for that eventuality. We then decide to generate
    the whole page statically at build time, but we'll wait for React hydration to
    make the API call and generate the optimized images (maybe using the Next.js built-in
    image component, as seen in [*Chapter 3*](B16985_03_Final_SB_epub.xhtml#_idTextAnchor038),
    *Next.js Basics and Built-In Components*).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最坏的情况是API很慢，图片没有优化，因此我们需要为此做好准备。然后我们决定在构建时静态生成整个页面，但我们将在React水合后进行API调用并生成优化后的图片（也许使用Next.js内置的图片组件，如[第3章](B16985_03_Final_SB_epub.xhtml#_idTextAnchor038)，*Next.js基础和内置组件*所示）。
- en: So, the final verdict is SSG and CSR. We'll statically generate the home page
    and create the list of images on the client side.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终决定是SSG和CSR。我们将静态生成主页并在客户端创建图像列表。
- en: In the next section, we will see the best way to handle the image detail page.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到处理图片详情页的最佳方式。
- en: Rendering the image detail page
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染图片详情页
- en: Moving on to the following sections of our websites, we want to create a single
    image page template. Here, we will render the photo posted by a user, its description,
    some tags, and all the comments and feedback given by other users.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要为我们的网站创建一个单独的图片页面模板。在这里，我们将渲染用户发布的照片、描述、一些标签以及其他用户给出的所有评论和反馈。
- en: In that case, we want this page to be indexed by search engines, as its content
    doesn't depend on user sessions or any other variable of that kind.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们希望这个页面被搜索引擎索引，因为其内容不依赖于用户会话或任何其他此类变量。
- en: Again, we must choose how we want to render this page. We already know that
    SEO is essential, so we exclude full client-side rendering as an option. We have
    to choose between statically generating this page at build time or server-side
    rendering it with each request.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们必须选择我们想要渲染此页面的方式。我们已经知道SEO至关重要，因此我们排除了全客户端渲染作为选项。我们必须在构建时静态生成此页面或在每个请求时服务器端渲染它之间做出选择。
- en: We know that either choice will help us with SEO, but the wrong decision here
    would affect the performance of this website as soon as it needs to scale. It's
    time to compare the pros and cons of SSG and SSR for this specific use case.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道无论选择哪个选项都会帮助我们进行SEO，但在这里做出错误的决定将会在网站需要扩展时立即影响其性能。是时候比较SSG和SSR在这个特定用例中的优缺点了。
- en: Static site generation pros and cons for dynamic pages
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态站点生成动态页面的优缺点
- en: 'Static site generation provides many pros for that kind of application:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 静态站点生成为这种类型的应用程序提供了许多优点：
- en: Once we generate a static page during the build process, the server won't need
    to re-render it on each request. That brings less load to the server, which leads
    to cheaper infrastructure costs and effortless scalability under high loads.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦在构建过程中生成静态页面，服务器就不需要在每次请求时重新渲染它。这减少了服务器的负载，从而降低了基础设施成本，并在高负载下轻松扩展。
- en: 'The picture author may want to change some of the static content following
    generation. However, at this point, we don''t want to wait for the next build
    to occur: we can just use incremental static regeneration for re-rendering the
    static page on the server once every (let''s say) 30 minutes if anything changes.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片作者可能希望在生成后更改一些静态内容。然而，在这个时候，我们不想等待下一次构建发生：我们可以在（比如说）每30分钟更改一次内容的情况下，仅使用增量静态重新生成，在服务器上重新渲染静态页面。
- en: Page performances will be the best possible.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面性能将是最佳可能的。
- en: Dynamic parts such as comments and like counts (that might not be important
    for SEO) can be rendered later on the client side.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态部分，如评论和点赞数（可能对SEO不重要）可以在客户端稍后渲染。
- en: 'When a user wants to add a new picture, they don''t have to wait for the next
    build for their image to appear on the website. In fact, we can set the `fallback:
    true` parameter inside the returning object of the `getStaticPaths` function to
    let Next.js statically render a new page at request time.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '当用户想要添加一张新图片时，他们不必等待下一次构建才能在网站上看到他们的图片。实际上，我们可以在`getStaticPaths`函数的返回对象中设置`fallback:
    true`参数，让Next.js在请求时静态渲染一个新页面。'
- en: 'There is just one big disadvantage when rendering this kind of web page at
    build time: if you have thousands of pages, it will take a lot of time for your
    website to build. That''s something to keep in mind when choosing SSG for dynamic
    routes. How many dynamic pages are we likely to support in the future? How much
    would it take for the build process to generate them?'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建时渲染这类网页有一个很大的缺点：如果你有成千上万的页面，你的网站构建将花费大量时间。选择SSG进行动态路由时，这是需要考虑的事情。我们未来可能支持多少动态页面？构建过程生成它们需要多少时间？
- en: Now let's move on looking at the pros and cons of server-side rendering for
    the single picture detail page.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续探讨单张图片详情页服务器端渲染的优缺点。
- en: Server-side rendering pros and cons for dynamic pages
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器端渲染动态页面的优缺点
- en: Server-side rendering provides a couple of important pros when compared to static
    site generation for this specific page.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与针对此特定页面的静态网站生成相比，服务器端渲染提供了一些重要的优点。
- en: The first one is that if a user changes the content of a page, we don't have
    to wait for incremental static regeneration to occur. We can see the changes reflected
    on the production page as soon as the picture author changes any information about
    their photo.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点是，如果用户更改了页面的内容，我们不必等待增量静态再生成发生。当图片作者更改其照片的任何信息时，我们可以在生产页面上立即看到更改的反映。
- en: The second pro is even more critical. As seen before, SSG can take up to several
    minutes to complete when generating a large number of static pages. Server-side
    rendering solves this problem by just rendering the page at request time, making
    the whole deployment pipeline faster.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个优点甚至更为关键。正如之前所见，当生成大量静态页面时，SSG可能需要几分钟才能完成。服务器端渲染通过仅在请求时渲染页面来解决这个问题，使得整个部署管道更快。
- en: If you think about large-scale websites such as Google and Facebook, you can
    easily understand why generating those pages at build time could be a problem.
    It can work fine if you want to render dozens or hundreds of pages, but it will
    become a huge bottleneck if you generate millions or even billions of them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑像Google和Facebook这样的大型网站，你很容易理解为什么在构建时生成这些页面可能是个问题。如果你只想渲染几十或几百个页面，这可以工作得很好，但如果你生成数百万甚至数十亿个页面，它将变成一个巨大的瓶颈。
- en: In our case, we expect to host thousands of pictures, with each picture having
    a detail page. Therefore, we will eventually decide to adopt server-side rendering
    for them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们预计将托管成千上万张图片，每张图片都有一个详情页。因此，我们最终将决定为它们采用服务器端渲染。
- en: Another option would be statically generating the most popular pages at build
    time (let's say the first thousand pages), then using the "fallback" property
    to generate them at runtime.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是在构建时静态生成最受欢迎的页面（比如说前一千页），然后使用“回退”属性在运行时生成它们。
- en: We now only need to define the rendering strategy for private routes, where
    users can change their own profile details. We will cover that right in the next
    section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在只需要定义私有路由的渲染策略，用户可以在那里更改自己的个人资料详情。我们将在下一节中详细说明。
- en: Private routes
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有路由
- en: As the adjective "private" suggests, private pages are not meant to be reached
    by everybody. Instead, they should be accessible by logged-in users only and contain
    the essential information needed to manage their account settings (username, password,
    email, and so on).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如形容词“私有”所暗示的，私有页面不是为了让每个人都能访问。相反，它们应该只对已登录用户开放，并包含管理账户设置所需的基本信息（用户名、密码、电子邮件等）。
- en: That said, we won't really care about SEO, but we'll focus on security instead.
    The data contained in those pages is sensitive, and we want to protect it at all
    costs.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们不会真正关心SEO，但我们会专注于安全。这些页面中的数据是敏感的，我们不惜一切代价来保护它。
- en: This is one of those rare cases where we want to sacrifice some performance
    to improve our security.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们想牺牲一些性能以改善我们安全性的罕见情况之一。
- en: We could quickly generate the private routes statically and then make all the
    required API calls on the client side, but this could expose some personal (or
    private) data if not handled correctly. So instead, we will adopt the server-side
    rendering strategy to detect anonymous users right before rendering the page and
    redirect them away. Also, if the user making the request is logged in, we can
    preload all of their data on the backend and pass it to the client side via `getServerSideProps`,
    which drastically improves security while transmitting data to the client.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速生成私有路由的静态版本，然后在客户端执行所有必要的API调用，但如果不正确处理，这可能会暴露一些个人（或私有）数据。因此，我们将采用服务器端渲染策略，在渲染页面之前检测匿名用户并将他们重定向走。此外，如果请求的用户已登录，我们可以在后端预加载所有数据，并通过`getServerSideProps`将其传递到客户端，这极大地提高了在向客户端传输数据时的安全性。
- en: Now that we've defined how to manage private routes, we've completed the basic
    rendering strategy analysis, so it's time for a quick recap. We'll see that in
    the next section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了如何管理私有路由，我们已经完成了基本渲染策略分析，因此现在是快速回顾的时候了。我们将在下一节中看到这一点。
- en: A quick recap regarding our decisions
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于我们决策的快速回顾
- en: In the previous sections, we made some decisions based on the kind of pages
    that we'll need to render for our photography website.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们根据我们需要为我们的摄影网站渲染的页面类型做出了一些决定。
- en: This analysis is critical and should be considered for every website we will
    be working on in the future. If we need to add new pages to an existing Next.js
    website, we will need to perform a similar analysis to understand the best solution
    possible to get the best performances, security, and SEO compliance.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这项分析至关重要，应该考虑我们未来将要工作的每一个网站。如果我们需要向现有的Next.js网站添加新页面，我们将需要执行类似的分析，以了解最佳解决方案，以获得最佳性能、安全性和SEO合规性。
- en: 'For our photography website, we came up with the following structure:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的摄影网站，我们提出了以下结构：
- en: '**Home page**: We will statically generate the whole home page except for the
    custom list of images, which will be rendered on the client side depending on
    the user browsing it.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主页**：我们将静态生成整个主页，除了自定义图片列表，它将根据用户浏览情况进行客户端渲染。'
- en: '**Image detail page**: We can either choose to server-side render it (as this
    will allow us to optimize the page for SEO and guarantees an excellent way of
    scaling our website up to millions of different image detail pages) or statically
    generate the most popular pages at build time and then use the "fallback" property
    to generate missing pages at runtime.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图片详情页**：我们可以选择在服务器端渲染它（因为这将允许我们优化页面以适应SEO，并保证以最佳方式扩展我们的网站以适应数百万个不同的图片详情页）或者，在构建时静态生成最受欢迎的页面，然后使用“回退”属性在运行时生成缺失的页面。'
- en: '**Private pages**: We will server side render them to determine whether a user
    is logged in before rendering the page. Also, we will be able to fetch all the
    private data on the server side, hiding that API call from the frontend.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有页面**：我们将服务器端渲染它们，以确定在渲染页面之前用户是否已登录。此外，我们将在服务器端获取所有私有数据，将此API调用隐藏在前端。'
- en: In [*Chapter 13*](B16985_13_Final_SB_epub.xhtml#_idTextAnchor131), *Building
    an E-Commerce Website with Next.js and GraphCMS*, for example, we will need to
    make this kind of decision to build a real-world Next.js e-commerce website. However,
    if you want to practice before getting into that, I'd suggest you think about
    how you would recreate your favorite websites.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[*第13章*](B16985_13_Final_SB_epub.xhtml#_idTextAnchor131)，“使用Next.js和GraphCMS构建电子商务网站”，我们将需要做出这样的决定来构建一个真实的Next.js电子商务网站。然而，如果你想在进入之前练习，我建议你考虑如何重新创建你最喜欢的网站。
- en: Facebook, Google, YouTube, Amazon – they all have specific needs, security requirements,
    and SEO specifications. So, how would you handle that? How are they dealing with
    those features?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook、Google、YouTube、Amazon——它们都有特定的需求、安全要求和SEO规范。那么，你将如何处理？他们是如何处理这些功能的？
- en: In the next section, we will concentrate on improving SEO by using some open
    source tools that will help us deal with search engine bots.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将专注于通过使用一些开源工具来提高SEO，这些工具将帮助我们处理搜索引擎爬虫。
- en: Working with SEO
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与SEO合作
- en: SEO in Next.js is not different from any other framework. Search engine bots
    make no difference; they only care about website content and quality. So, even
    though Next.js tries to simplify things, we still need to respect specific rules
    and develop our websites on the basis of the search engine specifications to get
    a good indexing score.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Next.js 中的 SEO 与其他任何框架并无不同。搜索引擎机器人不会区分差异；它们只关心网站内容和质量。因此，尽管 Next.js 试图简化事情，我们仍然需要尊重特定的规则，并在搜索引擎规范的基础上开发我们的网站，以获得良好的索引评分。
- en: Given the rendering possibilities that Next.js provides for us, we already know
    that particular decisions can negatively impact the final SEO score (for example,
    rendering important data on the client side). We talked about that in the previous
    sections, so we won't go deep into it again.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 Next.js 为我们提供的渲染可能性，我们已经知道特定的决策可能会对最终的 SEO 评分产生负面影响（例如，在客户端渲染重要数据）。我们已经在前面的章节中讨论过这一点，所以不会再深入探讨。
- en: 'There are specific SEO metrics that might be a bit out of our control when
    developing the website. Domain authority, referring domains, page impressions,
    click-through rate, and organic market share are just a few of them. Even though
    we are unlikely to improve those metrics during the development process (as they
    are the product of good content management on the website), we should do our best
    to improve whatever we can by coding the website. This includes a series of optimizations
    and developments that include (but are not limited to) the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发网站时，有一些特定的 SEO 指标可能超出了我们的控制范围。域名权威性、引用域名、页面浏览量、点击率和有机市场份额只是其中的一些。尽管我们不太可能在开发过程中提高这些指标（因为它们是网站良好内容管理的结果），但我们应尽最大努力通过编码网站来改善我们能控制的部分。这包括一系列优化和发展，包括但不限于以下内容：
- en: '*Creating an SEO-friendly routing structure*: A well-made routing system is
    essential for search engine bots to index a website correctly. URLs should always
    be human-friendly and composed according to a certain logic. For example, if we''re
    creating a blog, we should use a URL structure to help the user identify the page
    content by just looking at the page URL. While something like [https://myblog.com/posts/1](https://myblog.com/posts/1)
    can be easier to work with, it makes things harder for blog users (and search
    engines too!) since, by looking at the page address, we can''t tell what the content
    is about. [https://myblog.com/posts/how-to-deal-with-seo](https://myblog.com/posts/how-to-deal-with-seo)
    is a better URL, which tells us that on this page, we''re talking about SEO and
    how to deal with it.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个对 SEO 友好的路由结构*：一个制作精良的路由系统对于搜索引擎机器人正确索引网站至关重要。URL 应始终对人类友好，并按照一定的逻辑组成。例如，如果我们正在创建一个博客，我们应该使用
    URL 结构来帮助用户仅通过查看页面 URL 就能识别页面内容。虽然像 [https://myblog.com/posts/1](https://myblog.com/posts/1)
    这样的 URL 可能更容易处理，但它对于博客用户（以及搜索引擎！）来说更困难，因为通过查看页面地址，我们无法知道内容是什么。[https://myblog.com/posts/how-to-deal-with-seo](https://myblog.com/posts/how-to-deal-with-seo)
    是一个更好的 URL，它告诉我们在这个页面上，我们正在讨论 SEO 以及如何处理它。'
- en: '*Fill the pages with correct and complete metadata*: In *Chapter 3*, *Next.js
    Basics and Built-In Components*, we''ve already seen how to deal with metadata.
    This is essential data that we should always include in our pages, with no exception.
    There are great libraries such as `next-seo` ([https://github.com/garmeeh/next-seo](https://github.com/garmeeh/next-seo))
    that can drastically reduce the development time required to manage the metadata
    during the development process.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在页面中填充正确的完整元数据*：在 *第 3 章*，*Next.js 基础和内置组件* 中，我们已经看到了如何处理元数据。这是我们应该始终包含在页面中的基本数据，没有例外。有一些优秀的库，如
    `next-seo` ([https://github.com/garmeeh/next-seo](https://github.com/garmeeh/next-seo))，可以在开发过程中显著减少管理元数据所需的时间。'
- en: '*Optimize your images*: We''ve already talked about how we can optimize images.
    The built-in image component has been developed in cooperation with the Google
    Chrome team to give better support for images, and that is also reflected in some
    SEO metrics (such as Cumulative Layout Shift and First Contentful Paint).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*优化你的图片*：我们已经讨论了如何优化图片。内置的图片组件是与 Google Chrome 团队合作开发的，以提供更好的图片支持，这也在一些 SEO
    指标（如累积布局偏移和首次内容绘制）中得到了体现。'
- en: '*Generate a proper sitemap*: Once we''re ready to deploy a website, we can
    submit the sitemap to search engines to help them index our content. A well-made
    sitemap is essential for any website as it allows the creation of a neat, structured
    path for search engines to follow to index the site. As for today, there''s no
    built-in solution in Next.js for creating a sitemap, but there are several great
    libraries, including `nextjs-sitemap-generator` ([https://github.com/IlusionDev/nextjs-sitemap-generator](https://github.com/IlusionDev/nextjs-sitemap-generator)),
    that can help to create it.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生成合适的网站地图*：一旦我们准备好部署网站，我们可以将网站地图提交给搜索引擎，以帮助他们索引我们的内容。一个制作精良的网站地图对任何网站都是必不可少的，因为它允许搜索引擎创建一个整洁、结构化的路径，以便索引网站。至于今天，Next.js中没有内置的解决方案来创建网站地图，但有一些优秀的库，包括`nextjs-sitemap-generator`([https://github.com/IlusionDev/nextjs-sitemap-generator](https://github.com/IlusionDev/nextjs-sitemap-generator))，可以帮助创建它。'
- en: '*Use the correct HTML tags*: Using semantic HTML tags to build a website is
    essential as they tell the search engine bots how to index the content in terms
    of priority and importance. As an example, while we always want our content to
    be indexed, using `<h1>` HTML tags for every text content is not the best choice
    for SEO. We always need to find the right balance in order for our HTML tags to
    be meaningful for users and search engine bots.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用正确的HTML标签*：使用语义HTML标签构建网站是至关重要的，因为它们告诉搜索引擎机器人如何根据优先级和重要性索引内容。例如，虽然我们总是希望我们的内容被索引，但使用`<h1>`HTML标签为所有文本内容并不是SEO的最佳选择。我们总是需要找到合适的平衡，以便我们的HTML标签对用户和搜索引擎机器人都有意义。'
- en: Dealing with SEO is not an easy task. It has always been challenging and can
    only become harder in the future as new technologies and rules rise. The good
    thing is that every rule is the same for every website, so you can bring your
    experience with other frameworks, CMSes, and development tools to Next.js with
    ease, as it can only help you create more optimized websites with less effort.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 处理SEO不是一个容易的任务。它一直具有挑战性，并且随着新技术和规则的兴起，未来可能会变得更加困难。好消息是，每条规则对每个网站都是相同的，所以你可以轻松地将你在其他框架、CMS和开发工具上的经验带到Next.js中，因为它只能帮助你以更少的努力创建更优化的网站。
- en: One other metric that can impact SEO is the performance of the website. Again,
    this is a crucial topic, and we will look into that in the next section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能影响SEO的指标是网站的性能。这同样是一个关键话题，我们将在下一节中探讨。
- en: Dealing with performance
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理性能
- en: Performance and SEO are two important aspects of any web application. Performance,
    in particular, can affect the SEO score, as a lousy-performing website will lower
    the SEO score.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 性能和SEO是任何Web应用的两个重要方面。特别是性能，它可以影响SEO评分，因为性能差的网站会降低SEO评分。
- en: At the beginning of this chapter, we've already seen how choosing the right
    rendering strategy can help us improve performance, but sometimes, we have to
    compromise between a slightly lower performance in favor of security, business
    logic, and suchlike.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们已经看到了选择正确的渲染策略如何帮助我们提高性能，但有时，我们不得不在为了安全、业务逻辑等因素而略微降低性能之间做出妥协。
- en: Another thing that can potentially increase (or decrease) performance is the
    deployment platform. For instance, if you're deploying a Next.js static website
    to a CDN such as Cloudflare or AWS Cloudfront, you're likely to get the best possible
    performance. On the other hand, deploying a server-side rendered application to
    a small, cheap server will probably give you some trouble once the website starts
    to scale and the server is not prepared for handling all the incoming requests,
    leading to bad performance. We will discuss this topic in depth in [*Chapter 11*](B16985_11_Final_SB_epub.xhtml#_idTextAnchor113),
    *Different Deployment Platforms*. As for now, keep in mind that this is another
    big topic to consider during performances analysis.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能影响（或降低）性能的因素是部署平台。例如，如果你将Next.js静态网站部署到CDN如Cloudflare或AWS Cloudfront，你很可能会获得最佳性能。另一方面，将服务器端渲染的应用程序部署到小型、便宜的服务器上，一旦网站开始扩展而服务器无法处理所有传入的请求，很可能会遇到一些麻烦，导致性能下降。我们将在[*第11章*](B16985_11_Final_SB_epub.xhtml#_idTextAnchor113)深入讨论这个话题，*不同的部署平台*。至于现在，请记住，这也是性能分析期间需要考虑的另一个重要话题。
- en: When we talk about performance, we don't always refer to server-side metrics;
    even the frontend performance is essential, and if not carefully handled, this
    can lead to lousy SEO scores and a bad user experience.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论性能时，我们并不总是指代服务器端指标；前端性能同样至关重要，如果不加以妥善处理，这可能会导致糟糕的SEO评分和不良的用户体验。
- en: 'With the release of Next.js 10, the Vercel team has announced a new built-in
    function to be used in our pages: `reportWebVitals`.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Next.js 10 的发布，Vercel 团队宣布了一个新的内置函数，我们可以在我们的页面中使用：`reportWebVitals`。
- en: 'It has been developed in collaboration with Google and allows us to collect
    valuable information about our frontend performances, including the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它是与 Google 合作开发的，使我们能够收集有关我们前端性能的宝贵信息，包括以下内容：
- en: '**Largest contentful paint (LCP)**: This measures the loading performance,
    which should occur within 2.5 seconds of the initial page load.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大内容渲染 (LCP)**：这衡量的是加载性能，应该在页面初始加载后的 2.5 秒内完成。'
- en: '**First input delay (FID)**: This measures how much time it takes for the page
    to be interactive. It should take less than 100 milliseconds.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**首次输入延迟 (FID)**：这衡量的是页面变得可交互所需的时间。它应该少于 100 毫秒。'
- en: '**Cumulative layout shift (CLS)**: This measures visual stability. Remember
    when we talked about images? A heavy picture might take a long time to load. Once
    it appears, it would shift the layout, causing the user to lose track of the section
    they were looking at. The image is a typical example, but other elements could
    be involved in this: ADV banners, third-party widgets, and so on.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**累积布局偏移 (CLS)**：这衡量的是视觉稳定性。还记得我们讨论图片的时候吗？一张重量级的图片可能需要很长时间才能加载。一旦它出现，就会改变布局，导致用户失去他们正在查看的部分的跟踪。图片是一个典型的例子，但其他元素也可能涉及其中：广告横幅、第三方小部件等等。'
- en: 'When we deploy our Next.js website, we can enable the platform to track those
    values to help us understand the performance of our web application on real-world
    data. Vercel will give us a well-made dashboard that will keep track of deployments
    and how new features affect overall website performance. Let''s look at the following
    example dashboard:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们部署我们的 Next.js 网站时，我们可以启用平台跟踪这些值，以帮助我们了解我们的 Web 应用程序在实际数据上的性能。Vercel 将为我们提供一个精心制作的仪表板，该仪表板将跟踪部署以及新功能如何影响整体网站性能。让我们看看以下示例仪表板：
- en: '![Figure 10.2 – Vercel analytics dashboard'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.2 – Vercel 分析仪表板'
- en: '](img/Figure_10.02_B16985.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.02_B16985.jpg)'
- en: Figure 10.2 – Vercel analytics dashboard
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – Vercel 分析仪表板
- en: As you can see, the preceding dashboard shows the average data for a whole website.
    While CLS and FID values are well implemented, we can clearly see that FCP and
    LCP can be improved.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，前面的仪表板显示了整个网站的平均数据。虽然 CLS 和 FID 值已经得到很好的实现，但我们明显可以看出 FCP 和 LCP 可以得到改善。
- en: 'If you''re unwilling to host your web application on Vercel, you can still
    collect that data by implementing the `reportWebVitals` function on your `_app.js`
    page. Let''s make a simple example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不愿意在 Vercel 上托管你的 Web 应用程序，你仍然可以通过在 `_app.js` 页面上实现 `reportWebVitals` 函数来收集这些数据。让我们举一个简单的例子：
- en: '[PRE0]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Thanks to this one-line function, we will see the following output in the console
    every time we enter a new page:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这个单行函数，每次我们进入新页面时，我们都会在控制台看到以下输出：
- en: '![Figure 10.3 – Web vitals'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.3 – Web Vitals'
- en: '](img/Figure_10.03_B16985.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.03_B16985.jpg)'
- en: Figure 10.3 – Web vitals
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – Web Vitals
- en: 'We can then decide to send this data to any external service, such as Google
    Analytics or Plausible, to collect this helpful information:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以决定将此数据发送到任何外部服务，例如 Google Analytics 或 Plausible，以收集这些有用的信息：
- en: '[PRE1]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you want to learn more about web vitals, the official website maintained
    by Google is always up to date with the latest improvements and rules: [https://web.dev/vitals](https://web.dev/vitals).
    I strongly suggest you read this before getting started with collecting and measuring
    frontend performances in your web application.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 Web Vitals 的信息，Google 维护的官方网站总是更新最新的改进和规则：[https://web.dev/vitals](https://web.dev/vitals)。我强烈建议你在开始收集和测量你的
    Web 应用程序前端性能之前阅读此内容。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've seen how to reason in relation to our pages regarding
    SEO, performance, and security. Even though those topics are quite complex, the
    primary purpose of this chapter was to give a kind of framework of thinking. In
    fact, those topics are likely to evolve in the future, as the web itself is moving
    forward fast with new performance metrics, SEO rules, and security standards.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何就我们的页面与 SEO、性能和安全进行推理。尽管这些主题相当复杂，但本章的主要目的是提供一个思考框架。实际上，随着网络本身以新的性能指标、SEO
    规则和安全标准快速前进，这些主题很可能会在未来发生变化。
- en: In the next chapter, we will continue talking about these topics from another
    perspective. We will see how to deploy our web applications and choose the right
    hosting platform with respect to our needs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从另一个角度继续讨论这些主题。我们将了解如何根据我们的需求部署我们的Web应用程序并选择合适的托管平台。
