<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Mixins and the DOM"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Mixins and the DOM</h1></div></div></div><p>In the previous chapter, we took a deep dive into React Forms. We took a look at building multiple components and interactivity between them, Controller and Uncontrolled Components, building Forms and Form elements, and Form events and handlers for the events. We build a form to capture cart-checkout flow and orders being placed in a multi-step form.</p><p>In this chapter, we will focus on abstracting content using mixins and touch upon DOM handling.</p><p>Here, we will cover the following points:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Mixins</li><li class="listitem" style="list-style-type: disc">PureRender mixin</li><li class="listitem" style="list-style-type: disc">React and the DOM</li><li class="listitem" style="list-style-type: disc">Refs</li></ul></div><p>At the end of this chapter, we will be able to abstract and reuse logic across our components and learn how to handle DOM from within the components.</p><div class="section" title="Back at the office"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec53"/>Back at the office</h1></div></div></div><p>The duo was back at <a id="id131" class="indexterm"/>work. Mike entered with a cup of coffee. It was morning and the office had just started to buzz.</p><p>"So Shawn, we did a lot of complex forms stuff last time. Our cart flow is now complete. However, now we have been asked to add a timeout to the cart. We need to show a timer to the user that they need to checkout and complete the order in 15 minutes."</p><p>"Any idea how we can do this?"</p><p>"Umm, maintain a state for timer and keep updating every second? Take some action when the timer hits zero."</p><p>"Right! We will use intervals to reduce the timeout values and keep updating our views to display the timer. As we have been storing the form data in a single place, our <code class="literal">Bookstore</code> component, let's go ahead and add a state value that will track this timeout value. Let's change our initial state to something similar to the following:"</p><div class="informalexample"><pre class="programlisting">getInitialState() {
    return ({currentStep: 1, formValues: {}, cartTimeout: 60 * 15});
  }</pre></div><p>"60 X 15, that's 15 minutes in seconds value. We will also need to add a method to keep updating this state so that we can use it freely from here as well as the child components."</p><div class="informalexample"><pre class="programlisting">updateCartTimeout(timeout){
    this.setState({cartTimeout: timeout});
}</pre></div><p>"Cool."</p><p>"Now, what we will do is define what are called as mixins."</p><p>"Mixins?"</p><p>"Yeah, mixins allow us to <a id="id132" class="indexterm"/>share a code across components. Let's take a look at how we are going to use it before moving ahead."</p><div class="informalexample"><pre class="programlisting">var SetIntervalMixin = {

  componentWillMount: function() {
    this.intervals = [];
  },

  setInterval: function() {
    this.intervals.push(setInterval.apply(null, arguments));
  },

  componentWillUnmount: function() {
    this.intervals.map(clearInterval);
  }
};

module.exports = SetIntervalMixin;</pre></div><p>"So what we are doing here is nothing much but defining an object. We will see how we use it in our components."</p><p>"As you can see, what we are trying to achieve here is add a way to track all our interval handlers, as follows:"</p><div class="informalexample"><pre class="programlisting">componentWillMount: function() {
    this.intervals = [];
  }
  </pre></div><p>"Here, we are first initializing an array to hold instances to intervals that we will be creating. Next, we will define a method that can be used to define new intervals, as follows:"</p><div class="informalexample"><pre class="programlisting">  setInterval: function() {
    this.intervals.push(setInterval.apply(null, arguments));
  }</pre></div><p>"Got it. I see the last bit is defining the <code class="literal">componentWillUnmount</code> method and we have already defined <code class="literal">componentWillMount</code>; but this isn't a React component. Why do we have these method here?"</p><p>"Oh right. Let's take a look <a id="id133" class="indexterm"/>at the following method first:"</p><div class="informalexample"><pre class="programlisting">  componentWillUnmount: function() {
    this.intervals.map(clearInterval);
  }</pre></div><p>"What this method does is clean up the intervals, which we might have created, before we unmount our component."</p><p>"Got it."</p><p>"Now, as you mentioned, we have two life cycle methods here—<code class="literal">componentWillMount</code> and <code class="literal">componentWillUnmount</code>."</p><p>"When we start using this in our component, they are called just like the other similar methods, which we have in our component for life cycle."</p><p>"Oh nice. Will both this and the existing method get called?" Shawn asked.</p><p>"Exactly. Now that we have the mixing defined, let's start using it!"</p><p>"The first place we want to start using this is on the delivery details page. This is as simple as doing the following:"</p><div class="informalexample"><pre class="programlisting">var DeliveryDetails = React.createClass({
…
mixins: [SetIntervalMixin]
…</pre></div><p>"Awesome, next we would like to start using this to take care of storing <code class="literal">cartTimout</code> values and updating them. Can you define a mixin to do just that?" asked Mike.</p><p>"Okay, I will first define a method to decrement the cart timer, something that will keep updating the state. Next, we will need to actually set the timeout, to call the method at an interval so that it is called every second to decrement the time?"</p><p>"Exactly, let's see how you would do it."</p><div class="informalexample"><pre class="programlisting">var CartTimeoutMixin = {
  componentWillMount: function () {
    this.setInterval(this.decrementCartTimer, 1000);
  },

  decrementCartTimer(){
    if (this.state.cartTimeout == 0) {
      this.props.alertCartTimeout();
      return;
    }
    this.setState({cartTimeout: this.state.cartTimeout - 1});
  },

};</pre></div><p>"Nice, that's exactly what we need. But we missed one piece; we need to be able to send this back to that parent component to store back the timer value that we are updating here."</p><p>"We will also take care of <a id="id134" class="indexterm"/>passing the current state of timer from the parent to the children."</p><p>"Oh, right."</p><p>"Let's go back to our parent component to start passing the cart timer value to the children. Here's how our render method should look now:"</p><div class="informalexample"><pre class="programlisting">……
render() {
    switch (this.state.currentStep) {

      case 1:
        return &lt;BookList updateFormData={this.updateFormData}/&gt;;

      case 2:
        return &lt;ShippingDetails updateFormData={this.updateFormData}
                                cartTimeout={this.state.cartTimeout}
                                updateCartTimeout={this.updateCartTimeout} /&gt;;

      case 3:
        return &lt;DeliveryDetails updateFormData={this.updateFormData}
                                cartTimeout={this.state.cartTimeout}
                                updateCartTimeout={this.updateCartTimeout} /&gt;;
                              
……</pre></div><p>"Notice that we are <a id="id135" class="indexterm"/>passing the <code class="literal">updateCartTimeout</code> method here. This is something that we will start using next in our mixin."</p><p>"Next, we are going to update the <code class="literal">DeliveryDetails</code> component to start storing the <code class="literal">cartTimeout</code> value."</p><div class="informalexample"><pre class="programlisting">getInitialState() {
    return { deliveryOption: 'Primary', cartTimeout: this.props.cartTimeout };
 } </pre></div><p>"With this setup, we can now set up our render method for the delivery options page, this should now look similar to the following:"</p><div class="informalexample"><pre class="programlisting">  render() {

    var minutes = Math.floor(this.state.cartTimeout / 60);
    var seconds = this.state.cartTimeout - minutes * 60;

    return (
      &lt;div&gt;
        &lt;h1&gt;Choose your delivery options here.&lt;/h1&gt;
        &lt;div style={{width:200}}&gt;
          &lt;form onSubmit={this.handleSubmit}&gt;
            &lt;div className="radio"&gt;
              &lt;label&gt;

                &lt;input type="radio"
                       checked={this.state.deliveryOption === "Primary"}
                       value="Primary"
                       onChange={this.handleChange} /&gt;
                Primary -- Next day delivery
              &lt;/label&gt;
            &lt;/div&gt;

            &lt;div className="radio"&gt;
              &lt;label&gt;
                &lt;input type=e"radio"
                       checked={this.state.deliveryOption === "Normal"}
                       value="Normal"
                       onChange={this.handleChange} /&gt;
                Normal -- 3-4 days
              &lt;/label&gt;
            &lt;/div&gt;

            &lt;button className="btn btn-success"&gt;
              Submit
            &lt;/button&gt;

          &lt;/form&gt;
        &lt;/div&gt;

        &lt;div className="well"&gt;
          &lt;span className="glyphicon glyphicon-time" aria-hidden="true"&gt;&lt;/span&gt; You have {minutes} Minutes, {seconds} Seconds, before confirming order
        &lt;/div&gt;

      &lt;/div&gt;
    );
  }</pre></div><p>"We also need to start using the <code class="literal">CartMixin</code>, so our <code class="literal">mixins</code> import should look similar to the following:"</p><div class="informalexample"><pre class="programlisting">…
mixins: [SetIntervalMixin, CartTimeoutMixin],
…</pre></div><p>"Nice, let me see how the shipping <a id="id136" class="indexterm"/>information looks like now."</p><div class="mediaobject"><img src="graphics/4730_05_01.jpg" alt="Back at the office"/></div><p>"It works!" exclaimed Shawn.</p><p>"Awesome. Remember, Shawn, now we need to pass the information back to our parent component when we change to some other page."</p><p>"Yeah, we should add it to the components, where we used the mixin?"</p><p>"Better yet, let's add the following code to the mixin:"</p><div class="informalexample"><pre class="programlisting">….
componentWillUnmount(){
    this.props.updateCartTimeout(this.state.cartTimeout);
  }
….</pre></div><p>"Now our mixin should look similar to the following:"</p><div class="informalexample"><pre class="programlisting">var CartTimeoutMixin = {
  componentWillMount: function () {
    this.setInterval(this.decrementCartTimer, 1000);
  },

  decrementCartTimer(){
    if (this.state.cartTimeout == 0) {
      this.props.alertCartTimeout();
      return;
    }
    this.setState({cartTimeout: this.state.cartTimeout - 1});
  },

  componentWillUnmount(){
    this.props.updateCartTimeout(this.state.cartTimeout);
  }

};

module.exports = CartTimeoutMixin;</pre></div><p>"Our mixin will now update <a id="id137" class="indexterm"/>the current cart value when it gets unmounted."</p><p>"We missed one thing that is part of this mixin. We call <code class="literal">this.props.alertCartTimeout()</code> when the timer hits zero."</p><p>"We are going to define this on the <span class="emphasis"><em>parent component</em></span> and pass it around to be called from child component, as follows:"</p><div class="informalexample"><pre class="programlisting">  alertCartTimeout(){
    this.setState({currentStep: 10});
  },</pre></div><p>"Then update our render method to take care when we reach the timeout step, as shown in the following:"</p><div class="informalexample"><pre class="programlisting">render() {
    switch (this.state.currentStep) {
      case 1:
        return &lt;BookList updateFormData={this.updateFormData}/&gt;;
      case 2:
        return &lt;ShippingDetails updateFormData={this.updateFormData}
                                cartTimeout={this.state.cartTimeout}
                                updateCartTimeout={this.updateCartTimeout}
                                alertCartTimeout={this.alertCartTimeout}/&gt;;
      case 3:
        return &lt;DeliveryDetails updateFormData={this.updateFormData}
                                cartTimeout={this.state.cartTimeout}
                                updateCartTimeout={this.updateCartTimeout}
                                alertCartTimeout={this.alertCartTimeout}/&gt;;
      case 4:
        return &lt;Confirmation data={this.state.formValues}
                             updateFormData={this.updateFormData}
                             cartTimeout={this.state.cartTimeout}/&gt;;
      case 5:
        return &lt;Success data={this.state.formValues} cartTimeout={this.state.cartTimeout}/&gt;;

      case 10:
       /* Handle the case of Cart timeout */
        return &lt;div&gt;&lt;h2&gt;Your cart timed out, Please try again!&lt;/h2&gt;&lt;/div&gt;;
      default:
        return &lt;BookList updateFormData={this.updateFormData}/&gt;;
    }
  }</pre></div><p>Let's see how the <a id="id138" class="indexterm"/>
<code class="literal">DeliveryDetails</code> component looks after completing it, now:"</p><div class="informalexample"><pre class="programlisting">import React from 'react';
import SetIntervalMixin from './mixins/set_interval_mixin'
import CartTimeoutMixin from './mixins/cart_timeout_mixin'

var DeliveryDetails = React.createClass({
  propTypes: {
    alertCartTimeout: React.PropTypes.func.isRequired,
    updateCartTimeout: React.PropTypes.func.isRequired,
    cartTimeout: React.PropTypes.number.isRequired
  },

  mixins: [SetIntervalMixin, CartTimeoutMixin],

  getInitialState() {
    return { deliveryOption: 'Primary', cartTimeout: this.props.cartTimeout };
  },

  componentWillReceiveProps(newProps){
    this.setState({cartTimeout: newProps.cartTimeout});
  },


  handleChange(event) {
    this.setState({ deliveryOption: event.target.value});
  },

  handleSubmit(event) {
    event.preventDefault();
    this.props.updateFormData(this.state);
  },

  render() {
    var minutes = Math.floor(this.state.cartTimeout / 60);
    var seconds = this.state.cartTimeout - minutes * 60;
    return (
      &lt;div&gt;
        &lt;h1&gt;Choose your delivery options here.&lt;/h1&gt;
        &lt;div style={{width:200}}&gt;
          &lt;form onSubmit={this.handleSubmit}&gt;
            &lt;div className="radio"&gt;
              &lt;label&gt;
                &lt;input type="radio"
                       checked={this.state.deliveryOption === "Primary"}
                       value="Primary"
                       onChange={this.handleChange} /&gt;
                Primary -- Next day delivery
              &lt;/label&gt;
            &lt;/div&gt;
            &lt;div className="radio"&gt;
              &lt;label&gt;
                &lt;input type="radio"
                       checked={this.state.deliveryOption === "Normal"}
                       value="Normal"
                       onChange={this.handleChange} /&gt;
                Normal -- 3-4 days
              &lt;/label&gt;
            &lt;/div&gt;

            &lt;button className="btn btn-success"&gt;
              Submit
            &lt;/button&gt;
          &lt;/form&gt;
        &lt;/div&gt;
        &lt;div className='well'&gt;
          &lt;span className="glyphicon glyphicon-time" aria-hidden="true"&gt;&lt;/span&gt; You have {minutes} Minutes, {seconds} Seconds, before confirming order
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
});

module.exports = DeliveryDetails;</pre></div><p>"We are also going to <a id="id139" class="indexterm"/>update our <code class="literal">ShippingDetails</code> component to look similar to the following:"</p><div class="informalexample"><pre class="programlisting">import React from 'react';
import SetIntervalMixin from './mixins/set_interval_mixine'
import CartTimeoutMixin from './mixins/cart_timeout_mixin'



var ShippingDetails = React.createClass({
  propTypes: {
    alertCartTimeout:React.PropTypes.func.isRequired,
    updateCartTimeout: React.PropTypes.func.isRequired,
    cartTimeout: React.PropTypes.number.isRequired
  },

  mixins: [SetIntervalMixin, CartTimeoutMixin],

  getInitialState() {
    return {fullName: '', contactNumber: '', shippingAddress: '', error: false, cartTimeout: this.props.cartTimeout};
  },
  _renderError() {
    if (this.state.error) {
      return (
        &lt;div className=e"alert alert-danger"&gt;
          {this.state.error}
        &lt;/div&gt;
      );
    }
  },

  _validateInput() { 
  …..
  },

  handleSubmit(event) {
  ….
  },

  handleChange(event, attribute) {
    var newState = this.state;
    newState[attribute] = event.target.value;
    this.setState(newState);
    console.log(this.state);
  },

  render() {
    var errorMessage = this._renderError();
    var minutes = Math.floor(this.state.cartTimeout / 60);
    var seconds = this.state.cartTimeout - minutes * 60;

    return (
      &lt;div&gt;
        &lt;h1&gt;Enter your shipping information.&lt;/h1&gt;
           …..
      
      
        &lt;div className='well'&gt;
          &lt;span className="glyphicon glyphicon-time" aria-hidden="true"&gt;&lt;/span&gt; You have {minutes} Minutes, {seconds} Seconds, before confirming order
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
});

module.exports = ShippingDetails;</pre></div><p>It should start <a id="id140" class="indexterm"/>looking similar to the following screenshot now:</p><div class="mediaobject"><img src="graphics/4730_05_02.jpg" alt="Back at the office"/></div><p>"Awesome," exclaimed Shawn.</p><p>"In case of timeouts, we have a simple display:"</p><div class="mediaobject"><img src="graphics/4730_05_03.jpg" alt="Back at the office"/></div></div></div>
<div class="section" title="Adding a modal"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec54"/>Adding a modal</h1></div></div></div><p>"Alright, this <a id="id141" class="indexterm"/>works well," continued Mike.</p><p>"However, it's a bit clumsy right now. After the timeout, there's nothing a user can do. We can add a popup to notify the user. Instead of showing the error page, let's display a modal with an alert and redirect the user to the first page so that the user can restart the flow. We can use Bootstrap modal to achieve this."</p><p>"Got it. Want me to give it a try?" asked Shawn.</p><p>"Go ahead!"</p><p>"Let me start with setting up the modal first. I will use a simple bootstrap modal to display it. After that's done, I will need to invoke display of the modal from <code class="literal">alertCartTimeout</code>, I <a id="id142" class="indexterm"/>guess. I will also be setting up to display the first page and reset form data."</p><p>"Correct."</p><p>"This is how the modal will look"</p><div class="informalexample"><pre class="programlisting">import React from 'react';

var ModalAlertTimeout = React.createClass({
  render() {
    return (

      &lt;div className="modal fade" ref='timeoutModal'&gt;
        &lt;div className="modal-dialog"&gt;
          &lt;div className="modal-content"&gt;
            &lt;div className="modal-header"&gt;
              &lt;button type="button" className="close" data-dismiss="modal" aria-label="Close"&gt;&lt;span aria-hidden="true"&gt;×&lt;/span&gt;&lt;/button&gt;
              &lt;h4 className="modal-title"&gt;Timeout&lt;/h4&gt;
            &lt;/div&gt;
            &lt;div className="modal-body"&gt;
              &lt;p&gt;The cart has timed-out. Please try again!&lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
});
module.exports = ModalAlertTimeout;</pre></div><p>"Nice. Next, you will be updating the <code class="literal">Bookstore</code> component <code class="literal">alertCartTimeout</code> method."</p><p>"Yeah, I added a new empty HTML element with the <code class="literal">modalAlertTimeout</code> ID to the body. This will be used to display new modal and mount component on top of it. I also changed alert timeout method to the following:"</p><div class="informalexample"><pre class="programlisting">alertCartTimeout(){
    React.render(&lt;ModalAlertTimeout /&gt;, document.getElementById('modalAlertTimeout'));
    this.setState({currentStep: 1, formValues: {}, cartTimeout: 1});
  }</pre></div><p>"Ah, let's see what this does" continued Mike, checking the changes that Shawn had done."</p><p>"Shawn, looks like the timeout is taking us to the first page, but its not displaying the modal alert"</p><p>"Oh, right. We still need to invoke the display of the modal from bootstrap."</p><p>"Correct. Let me take care of <a id="id143" class="indexterm"/>that, Shawn. In our <code class="literal">ModalAlertTimeout</code>, we will add a method call to display the modal after the component has successfully mounted, as follows:"</p><div class="informalexample"><pre class="programlisting">componentDidMount(){
    setTimeout(()=&gt; {
      let timeoutModal = this.refs.timeoutModal.getDOMNode();
      $(timeoutModal).modal('show');
    }, 100);
  }</pre></div><p>"Ah, I see we are doing some DOM stuff here."</p><p>"Yeah, let me go over them."</p></div>
<div class="section" title="Refs"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec55"/>Refs</h1></div></div></div><p>"I think we have <a id="id144" class="indexterm"/>used this before," asked Shawn.</p><p>"Yeah. What refs do is give us a handle to refer to some part of the component. We have done this in forms. Here, we are using it to get a handle to the modal so that we can invoke the <code class="literal">modal()</code> method on top of it."</p><p>"This would, in turn, display the modal."</p><p>"Now, notice how we are using the <code class="literal">getDOMNode()</code> method."</p><p>"Yup. What does it do?"</p><p>"The <code class="literal">getDOMNode()</code> method helps us to get the underlying DOM node, where the React element is rendered. In our case, we want to invoke a method on the DOM node."</p><p>"When we call <code class="literal">this.refs.timeoutModal</code>, it returns us a ref object of the component."</p><p>"This is different from the actual <a id="id145" class="indexterm"/>DOM component. It's actually a React-wrapped object. To grab the underlying DOM object, we invoked <code class="literal">getDOMNode()</code>."</p><p>"Got it."</p><p>"Next, we have wrapped all this in a <code class="literal">setTimeout</code> call so that we can call it after the React component is successfully rendered and modal content exists on the page.</p><p>"Finally, we called <code class="literal">$(timeoutModal).modal('show')</code> to invoke the modal!"</p><p>"Let's see how our <a id="id146" class="indexterm"/>modal looks now."</p><div class="informalexample"><pre class="programlisting">import React from 'react';

var ModalAlertTimeout = React.createClass({
  componentDidMount(){
    setTimeout(()=&gt; {
      let timeoutModal = this.refs.timeoutModal.getDOMNode();
      $(timeoutModal).modal('show');
    }, 100);
  },

  render() {
    return (

      &lt;div className="modal fade" ref='timeoutModal'&gt;
        &lt;div className="modal-dialog"&gt;
          &lt;div className="modal-content"&gt;
            &lt;div className="modal-header"&gt;
              &lt;button type="button" className="close" data-dismiss="modal" aria-label="Close"&gt;&lt;span aria-hidden="true"&gt;×&lt;/span&gt;&lt;/button&gt;
              &lt;h4 className="modal-title"&gt;Timeout&lt;/h4&gt;
            &lt;/div&gt;
            &lt;div className="modal-body"&gt;
              &lt;p&gt;The cart has timed-out. Please try again!&lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
});
module.exports = ModalAlertTimeout;</pre></div><p>"Let's see how this looks now."</p><div class="mediaobject"><img src="graphics/4730_05_04.jpg" alt="Refs"/></div><p>"One last thing since we are discussing this, is about DOM. We can invoke <code class="literal">getDOMNode()</code> to also get the node for the current component. Therefore, we can simply call <code class="literal">this.getDOMNode()</code> and that will also return us an element!"</p><p>"Alright, let's do this. We will <a id="id147" class="indexterm"/>unmount the modal when someone closes it so that we can invoke it afresh on the second render."</p><p>"Let's define a callback <a id="id148" class="indexterm"/>method to do just that, as follows:"</p><div class="informalexample"><pre class="programlisting">unMountComponent () {
    React.unmountComponentAtNode(this.getDOMNode().parentNode);
  }</pre></div><p>"Finally, we will set this as a callback on close of our modal, as follows:"</p><div class="informalexample"><pre class="programlisting">$(timeoutModal).on('hidden.bs.modal', this.unMountComponent);</pre></div><p>"With this, we are done! The component will unmount on modal hide."</p><p>"Notice how we are using the <code class="literal">parentNode</code> attribute on the DOM node to hide the modal. This helps us to get the container on which the React element is and that we are using to remove the modal."</p><p>"Nice. That has been a refresher. Thanks Mike!"</p><p>With that, the duo headed back to check the various changes they had just done.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec56"/>Summary</h1></div></div></div><p>In this chapter, we took a look at refactoring our components. We saw how to make use of mixins and extract similar functionalities to use seamlessly across components. We also took a look at DOM interactions, using refs, and related DOM actions from a component.</p><p>In the next chapter, we will explore how React functions on the the server side. We will see how React allows us to render and handle components on the server to pre-render HTML, which is useful for several reasons. We will also take a look at how this affects the React component life cycle.</p></div></body></html>