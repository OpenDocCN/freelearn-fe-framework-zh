- en: Chapter 2. Ready, Set, Go!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will start building our task management application. We''ll
    jump right into the core of the application and create the initial components
    required to manage a simple task list. In the process of going through this chapter,
    you''ll learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping an Angular application using a main component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component input and output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Host property binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling and view encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing HTML templates using the SystemJS text loader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `EventEmitter` to emit custom events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two-way data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After picking up the basics from the previous chapter, we will now go on and
    create a task management application together in the upcoming chapters. You'll
    learn about some concepts during the chapters and then use them with practical
    examples. You'll also learn how to structure an application using components.
    This begins with the folder structure and ends with setting up the interaction
    between components.
  prefs: []
  type: TYPE_NORMAL
- en: Vision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The task management application should enable users to manage tasks easily and
    help them organize small projects. Usability is the central aspect of any application;
    therefore, you'll need to design a modern and flexible user interface that will
    support the user.
  prefs: []
  type: TYPE_NORMAL
- en: '![Vision](img/image00304.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A preview of the task management application we are going to build
  prefs: []
  type: TYPE_NORMAL
- en: 'Our task management application will consist of components that will allow
    us to design a platform providing a great user experience for the purpose of managing
    tasks. Let''s define the core features of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing tasks within multiple projects and providing a project overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple scheduling as well as a time-and-effort-tracking mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overviewing the dashboard using graphical charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking activities and providing a visual audit log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple commenting system that would work across different components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The task management application is the main example in this book. Therefore,
    the building blocks within the book should only contain the code that is relevant
    to the theme of the book. Of course, other than components, an application needs
    other functionalities, such as visual design, data, session management, and other
    important parts, to work. While the required code for each chapter can be downloaded
    online, we'll only discuss the code relevant to the topics learned within the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from scratch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start out by creating a new folder called `angular-2-components` in
    order to create our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a console window inside our newly created folder and run the following
    command to initialize a new Node.js project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finish the initialization wizard by confirming all the steps with the *Enter*
    key (default settings).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since we''re using JSPM to manage our dependencies, we need to install it as
    a project Node.js package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s also initialize a new JSPM project within our project folder. Be sure
    to use the default settings (just hit the *Enter* key) for all settings, except
    for the step where you are asked which transpiler you''d like to use. Enter TypeScript
    at this stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll now use JSPM to install the relevant Angular 2 packages into our project
    as dependencies. We''ll also install a SystemJS loader plugin to load text files
    as modules. We''ll provide some details around this later on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's examine what we've been creating so far by using the NPM and JSPM command-line
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `package.json` file is our Node.js configuration file that we''re using
    as the base to work with JSPM (the package manager) and SystemJS (the module loader
    with transpiler). If you check out the `package.json` file, you will see an additional
    section for JSPM dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a quick look at the dependencies we have installed using JSPM and
    their purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Package | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@angular/core` | This is the core package of Angular 2, hosted on NPM. If
    you remember from [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Component-Based
    User Interfaces"), *Component-Based User Interfaces*, JSPM is only a broker, and
    it delegates to other package repositories. The core package contains all Angular-core
    modules, such as the `@Component` decorator, change detection, dependency injection,
    and more. |'
  prefs: []
  type: TYPE_TB
- en: '| `@angular/common` | The Angular `common` package provides us with base directives,
    such as `NgIf` and `NgFor`. It also contains all the base pipes and the directives
    that are used to control forms. |'
  prefs: []
  type: TYPE_TB
- en: '| `@angular/compiler` | The compiler package contains all the artifacts required
    to compile view templates. Angular not only provides the ability to precompile
    templates to gain faster booting time, but it also uses the compiler at runtime
    to convert text templates into compiled templates. This package is required if
    we''re compiling templates at runtime. |'
  prefs: []
  type: TYPE_TB
- en: '| `@angular/platform-browser-dynamic` | This package includes the bootstrapping
    functionality that will help us start our application. The bootstrap initiated
    by the platform-browser-dynamic package is dynamic in the sense of compiling templates
    at runtime. |'
  prefs: []
  type: TYPE_TB
- en: '| `typescript` | This development dependency is the TypeScript transpiler for
    SystemJS. It transpiles our ECMAScript 6 and TypeScript code to ECMAScript 5,
    from where it can run in the browser. |'
  prefs: []
  type: TYPE_TB
- en: '| `text` | This SystemJS loader supports the loading of text files in the form
    of JavaScript strings. This is especially useful if you like to load HTML templates
    and avoid asynchronous requests. |'
  prefs: []
  type: TYPE_TB
- en: 'Our main entry point for displaying our application within the browser is our
    index site. The `index.html` file completes the following five actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading ECMAScript 6 polyfill es6-shim from a CDN. This script is required to
    make sure the browser understands the latest ECMAScript 6 APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading the Angular 2 polyfills required by the framework. This includes various
    patches for the browser that are required to run an Angular 2 application. It's
    important to load these polyfills before we load any other code within our application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading SystemJS and the SystemJS `config.js` file that contains the mapping
    information generated by JSPM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `System.import` function to load and execute the main entry point,
    which is our `boostrap.js` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a new `index.html` file within the root folder of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's move on to our application component. You can think of it as the outermost
    component of your application. It's the main component in that it represents your
    whole application. Every application needs one and just one main component. This
    is where your component tree has its roots.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll name our main component `App` because it represents our whole application.
    Let''s go ahead and create the component within a new `lib` folder in our project
    folder. Create a file, `app.js`, with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s nothing different here from what we already know about structuring
    a component, something that we learned in the previous chapter. However, there
    are two main differences here compared to how we created the components before.
    If you look at how we configured the `template` property, you could tell that
    we didn''t write the HTML template directly within the JavaScript file inside
    the ECMAScript 6 template strings. Instead, we''re going to load the template
    into a JavaScript string using the text loader plugin in SystemJS. We can just
    load any text file from the file system by appending `!text` to our regular ECMAScript
    6 imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will load the file, `app.html`, from the current directory and make a default
    export with its content as a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second difference is that we''re using `ViewEncapsulation` to specify how
    Angular should handle view encapsulation. Angular has three ways, to handle view
    encapsulation, which provides different levels of granularity and has their own
    pros and cons. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Encapsulation type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ViewEncapsulation.Emulated` | If a component is set to emulated view encapsulation,
    it will emulate style encapsulation by attaching the generated attributes to the
    component element and modifying CSS selectors to include these attribute selectors.
    This will enable certain forms of encapsulation, although the outer styles can
    still leak into the component if there are other global styles.This view encapsulation
    mode is the default mode, if not specified otherwise. |'
  prefs: []
  type: TYPE_TB
- en: '| `ViewEncapsulation.Native` | Native view encapsulation is supposed to be
    the ultimate goal of the view encapsulation concept within Angular. It makes use
    of Shadow DOM, as described in the previous chapter, to create an isolated DOM
    for the whole component. This mode depends on the browser to support Shadow DOM
    natively, and therefore, can''t always be used. It''s also important to note that
    global styles will no longer be respected and local styles need to be placed within
    the component in inline style tags (or use the `styles` property on the component
    annotation). |'
  prefs: []
  type: TYPE_TB
- en: '| `ViewEncapsulation.None` | This mode tells Angular not to provide any template
    or style encapsulation. Within our application, we mainly rely on styles coming
    from a global CSS; therefore, we use this mode for most of the components. Neither
    Shadow DOM, nor attributes will be used to create style encapsulation; we can
    simply use the classes specified within our global CSS file. |'
  prefs: []
  type: TYPE_TB
- en: 'As this component is now relying on a template to be loaded from the file system,
    we need to create the `app.html` file in the `lib` folder with some initial content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For the time being, that''s everything we put in our template. Our directory
    should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have created our main application component, we can add the component''s
    host element to our `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Bootstrapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `index.html` file will load the `bootstrap.js` module using SystemJS in
    an inline `script` tag. It's a best practice to have a main entry point for your
    scripts when working with SystemJS. Our `bootstrap.js` file is responsible for
    loading all the necessary JavaScript dependencies for our application as well
    as bootstrapping the Angular framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can go ahead and bootstrap our Angular application by providing our main
    application component, `App`. We need to import the `bootstrap` function from
    the `angular2` module. We can then import our `App` component and call the `bootstrap`
    function, passing it as parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Running the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code we''ve produced so far should now be in a state where we can run it.
    Before we run our code using the live-server module, let''s ensure we have all
    the files ready. At this stage, our directory should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s start live server to start a server and a browser with live reload.
    For this, we need to simply execute the following command on the command line
    within our project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If everything goes well, you will have an open web browser that shows **Hello
    World!**.
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s recap what we have done so far:'
  prefs: []
  type: TYPE_NORMAL
- en: We initialized a new project using NPM and JSPM and installed the Angular dependencies
    using JSPM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created our main application component in `app.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also created a `bootstrap.js` script to include the Angular framework boot
    of our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We added our component to the `index.html` file by including an element that
    matches our component selector property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we used live server to start a basic web server and launch a web browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a task list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our main application component set up, we can go on and flesh
    out our task application. The second component that we're going to create will
    be responsible for listing tasks. Following the concept of composition, we'll
    create a `task-list` component as a subcomponent of our main application component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a folder within the `lib` folder called `task-list` and a new
    JavaScript file called `task-list.js`, where we will write our component code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We've created a very simple `task-list` component that has a list of tasks stored
    internally. This component will be attached to HTML elements that match the CSS
    element selector `ngc-task-list`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create a view for this component to display the tasks. As you can
    see from the import within the component JavaScript file, we are looking for a
    file called `task-list.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We use the `NgFor` directive to repeat the `<div>` element with the class task
    for as many tasks as we have in the task list of our component. The `NgFor` directive
    in Angular will create a template element from its underlying content and instantiate
    as many elements from the template as the expression evaluates to. We currently
    have two tasks in our `task-list` component, so this will create two instances
    of our template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your folder structure inside the `lib` folder should now look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'All that''s left to do in order to make our task list work is the inclusion
    of the `task-list` component within the main application component. We can go
    ahead and modify our `app.js` file and add the following line on top of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As we want to add the `task-list` component to our main application view template,
    we also need to make sure that Angular knows about the component when compiling
    the view. For this, we need to add the `directives` property to our main application
    component within the `app.js` file and include our imported `TaskList` component
    class within the list of directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to include the host element of our `task-list` component in
    the template of the main application, which is located within the `app.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: These were the last changes we needed to make in order to make our `task-list`
    component work. To view your changes, you can start the live server by executing
    the `live-server` command within your `angular-2-components` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at what we have done in the previous building block. We achieved
    a simple listing of tasks within an encapsulated component by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We created the component JavaScript file that contains the logic of our component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created the component's view within a separate HTML file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We included the component class within the configuration of our main application
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We included the component HTML element within our main application view template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The right level of encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our task list is displayed correctly and the code we used to achieve this looks
    quite okay. However, if we want to follow a better approach for composition, we
    should rethink the design of our `task-list` component. If we draw a line at enlisting
    the task list responsibilities, we would come up with things such as listing tasks,
    adding new tasks to the list, and sorting and filtering the task list; however,
    operations are not performed on an individual task itself. Also, rendering the
    task itself falls outside of the responsibilities of the task list. The `task-list`
    component should only serve as a container for tasks.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at our code again, we will see that we're violating the single responsibility
    principle and rendering the whole task body within our `task-list` component.
    Let's take a look at how we can fix this by increasing the granularity of the
    encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: The goal now is to do a code refactoring exercise, also known as extraction.
    We are pulling our task's relevant template out of the task list template and
    creating a new component that encapsulates the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we need to create a new sub folder within the `task-list` folder
    called `task`. Within this folder, we will create a template file with the name
    `task.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The content of our new `task.html` file is pretty much the same as what we already
    have within our `task-list.html` template. The only difference is that we will
    now refer to a new model called `task`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, within the `task` folder, let''s create the JavaScript file, `task.js`,
    which will contain the controller class of our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the previous chapter of this book, we spoke about encapsulation and the preconditions
    to establish a clean encapsulation for UI components. One of these preconditions
    is the possibility to design proper interfaces in and out of the component. Such
    input and output methods are necessary to make the component work within compositions.
    That's how a component will receive and publish information.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from our task component implementation, we are now building such
    an interface using the `@Input` annotation on a class instance field. In order
    to use this annotation, we will first need to import it from the angular core
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Input properties in Angular allow us to bind the expressions in our templates
    to class instance fields on our components. This way, we can pass data from the
    outside of the component to the component inside, using the components template.
    This can be thought of as an example of one-way binding, from the view to the
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we''re using property binding on a regular DOM property, Angular will create
    a binding of the expression directly to the element''s DOM property. We''re using
    such a type of binding to bind the task completed flag to the `checked` property
    of the checkbox''s `input` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Usage | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@Input() inputProp;` | This allows us to bind the `inputProp` attribute
    to the component element within the parent component.Angular assumes that the
    attribute of the element has the same name as that of the `input` property. |'
  prefs: []
  type: TYPE_TB
- en: '| `@Input(''inp'') inputProp;` | You can also override the name of the attribute
    that should be mapped to this input. Here, the `inp` attribute of the component''s
    HTML element is mapped to the component''s input property, `inputProp`. |'
  prefs: []
  type: TYPE_TB
- en: The last missing piece to use our newly created task component is the modification
    of the existing template of the task list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We include the task component within our task list template by using an `<ngc-task>`
    element, as specified in the selector within our task component. Also, we create
    a property binding on the task element. There, we pass the `task` object from
    the current `NgFor` iteration to the `task` input of the `task` component. We
    need to replace all the existing content in the `task.html` file with the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make our `task-list` component recognize the task component element,
    we need to add it to the `task-list` component''s `directives` property within
    the `task-list.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You've successfully refactored your task list by extracting
    the task into its own component and have established a clean encapsulation. Also,
    we can now say that our task list is a composition of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: If you think about maintainability and reusability, this was actually a very
    important step in the process of building our application. You should constantly
    look out for such encapsulation opportunities, and if you feel something could
    be arranged into multiple subcomponents, you should probably go for it. Of course,
    you can also overdo this. There's simply no golden rule to determine what granularity
    of encapsulation is the right one.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The right granularity of encapsulation for a component architecture always depends
    on the context. My personal tip here is to use known principles from OOP, such
    as single responsibility, to lay the groundwork for a good design of your component
    tree. Always make sure your components are only doing things that they are supposed
    to do as their names suggest. A task list has the responsibility of listing tasks
    and providing some filters or other controls for the list. The responsibility
    of operating on individual task data and rendering the necessary view clearly
    belongs to a task component and not the task list.
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this building block, we cleaned up our component tree and established clean
    encapsulation using subcomponents. Then, we set up the interfaces provided by
    Angular using input bindings. We performed these actions by following the ensuing
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a task subcomponent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We used the task subcomponent with the `task-list` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We used input bindings and DOM element property bindings to establish one-way
    data binding in the task component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input generates output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our task list looks nice already, but it would be quite useless if the user
    is unable to add new tasks to the list. Let's create a component for entering
    new tasks together. As this component belongs to the `task-list` component, we're
    going to create a new folder called `enter-task` within the `task-list` folder.
    The responsibilities of this component will be to handle all the UI logic necessary
    for entering a new task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the same naming convention as with the rest of our components, let''s
    create a file called `enter-task.html` to store the template of our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This template consists of an input field as well as a button to enter a new
    task. Here, we're making use of the so-called local view variables by specifying
    that our input field should have the reference name `#titleInput`. We can reference
    this variable within the current component view by the name `titleInput`.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are actually using the variable to pass the input field DOM
    element to the `enterTask` function that we call on a click event on the `Add
    Task` button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the implementation of our `Component` class for entering
    a new task by using the following code in a newly-created `enter-task.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: For this component, we've chosen a design approach where we use a loose relation
    to our task list where the actual task will be created. Although this component
    is closely related to the task list, it's better to keep the components as loosely
    coupled as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the simplest forms of inversion of control, a callback function or event
    listener is a great principle to establish loose coupling. In this component,
    we are using the `@Output` annotation to create an event emitter. The output properties
    need to be instance fields that hold an event emitter within the component. On
    the component''s HTML element, we can then use event bindings to capture any events
    emitted. This gives us great flexibility that we can use to create a clean application
    design, where we glue components together through the binding within the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Usage | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@Output() outputProp = new EventEmitter();` | When `outputProp.next()` is
    called, a custom event with the name `outputProp` will be emitted on the component.
    Angular will look for event bindings on the component''s HTML element (where the
    component is used) and execute them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Within the expressions in event bindings, you will always have access to a synthetic
    variable called `$event`. This variable is a reference to the data emitted by
    `EventEmitter`. |
  prefs: []
  type: TYPE_NORMAL
- en: '| `@Output(''out'') outputProp = new EventEmitter();` | Use this way of declaring
    your output properties if you''d want to name your events differently from what
    your property name is. In this example, a custom event with the name `out` will
    be fired when `outputProp.next()` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s use this newly created component to add new tasks within our `task-list`
    component. First, let''s modify the existing template of the `task-list` component.
    Open the file, `task-list.html`, in the `task-list` component folder. We need
    to add the `EnterTask` component to the template and also handle the custom event
    that we''re going to emit, once a new task is entered within the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Since the output property within the `enter-task` component is called `taskEntered`,
    we can bind it with the event binding attribute, `(taskEntered)=""`, on the host
    element.
  prefs: []
  type: TYPE_NORMAL
- en: Within the event binding expression, we then call a function on our `task-list`
    component called `addTask`. Also, we use the synthetic variable `$event`, which
    contains the task title emitted from the `enter-task` component. Now, whenever
    we push the button in our `enter-task` component and an event gets emitted from
    the component, we catch the event in our event binding and handle it within the
    `task-list` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to make some minor changes to the `task-list` component''s JavaScript
    file. Let''s open `task-list.js` and modify it with the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The only thing we changed within the `task-list` component module is its ability
    to declare the `EnterTask` component in the directives property so that the compiler
    recognizes our `enter-task` component correctly.
  prefs: []
  type: TYPE_NORMAL
- en: We have also added a function, `addTask`, which will add a new task to our task
    list with a title that is passed to the function. Now the circle is closed and
    our event from the `enter-task` component is routed to this function within the
    view of the `task-list` component.
  prefs: []
  type: TYPE_NORMAL
- en: You can now start live server from your project directory in order to test the
    newly added functionality using the `live-server` command.
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have added a new subcomponent of the task list that is responsible for providing
    the UI logic to add new tasks. In other words, we have covered the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a subcomponent that is loosely coupled using output properties and
    event emitters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We learned about the `@Output` annotation and how to use it to create output
    properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We used event bindings to link the behavior together, from the view of a component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Custom UI elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard UI elements in the browser are great, but sometimes, modern web
    applications require more complex and intelligent input elements than the ones
    available within the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll now create two specific custom UI elements that we''ll use within our
    application going forward in order to provide a nice user experience:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Checkbox**: There''s already a native checkbox input in the browser, but
    sometimes, it''s hard to fit it into the visual design of an application. Native
    checkboxes are limited in their styling possibilities, and therefore, it''s hard
    to make them look great. Sometimes, it''s those minor details that make an application
    look appealing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Toggle buttons**: This is a list of toggle buttons, where only one button
    can be toggled within the list. They could also be represented with a native radio
    button list. However, like with native checkboxes, radio buttons are sometimes
    not really the nicest visual solution to the problem. A list of toggle buttons
    that also represents a select-one-user input element is much more modern and provides
    the visual aspect that we are looking for. Besides, who does not like to push
    buttons?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's create our custom checkbox UI element first. As we'll probably come up
    with a few custom UI elements, first let's create a new subfolder called `ui`
    within the `lib` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `ui` folder, we now create a folder with the name `checkbox` for
    our checkbox component. Starting with the template of our new component, we now
    create a file with the name `checkbox.html` within the `checkbox` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: On the `checkbox` input, we have two bindings. First, we have a property binding
    for the `checked` property on the DOM element. We are binding the DOM property
    to the `checked` member field on our component, which we are going to create in
    a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we have an event binding on the input element where we listen for the
    checkbox change DOM event and call the method `onCheckedChange` on our component
    class. We use the synthetic variable `$event` to pass the `checked` property on
    the checkbox DOM element where the change event is originated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on to our `component` class implementation, we need to create a file
    with the name `checkbox.js` within the `checkbox` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing special about this `component` class if we first look at it.
    It uses an input property to set the checked state from the outside, and it also
    has an output property with an event emitter that allows us to notify the outer
    component about the changes of the checked state using a custom event. However,
    there's a naming convention that makes this component a bit special. The convention
    of using an input property name also as an output property name but appending
    the word *change* is actually enabling a developer who uses the component to make
    use of the two-way data binding template shorthand.
  prefs: []
  type: TYPE_NORMAL
- en: Angular does not come with two-way data binding out of the box. However, creating
    two-way binding is quite easy. Actually, two-way data binding is no different
    than combining a property binding with an event binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example creates a very simple two-way data binding process on
    an input field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The simplicity of Angular and the general approach of extending the native functionality
    of the browser makes implementing this mechanism a breeze.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing two-way data binding between a component and its subcomponent isn't
    really too difficult. The only thing we need to take care about is that there
    are input and output properties of the subcomponent involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please have a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom UI elements](img/image00305.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A two-way data binding between member variables of a component and a subcomponent
  prefs: []
  type: TYPE_NORMAL
- en: 'Since two-way data binding was a highly requested feature in Angular, there''s
    a handy shorthand to write it. Let''s look at some examples on how to implement
    data bindings between a template of a component and its subcomponent:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Subcomponent properties | Bindings in component template |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@Input() text;``@Output() textOut = new EventEmitter();` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We bind the component's `myText` property to the subcomponent's text input.
    Also, we capture the `textOut` event emitted from the subcomponent and update
    our `myText` property. |
  prefs: []
  type: TYPE_NORMAL
- en: '| `@Input() text;``@Output() textChange = new EventEmitter();` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We can simplify this two-way data binding by using the naming convention to
    append the word "change" to our event emitter identifier. This way, we can use
    the two-way data binding shorthand within our template using the `[(property)]`
    notation. |
  prefs: []
  type: TYPE_NORMAL
- en: If we look at our `checkbox` component implementation again, we will see that
    we are using the two-way data binding naming convention for the checked property
    of our component. This way, we enable the use of the template shorthand for two-way
    data binding wherever we use our custom checkbox UI component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s integrate our checkbox in the task component to replace the native checkbox
    input we''re currently using there. For this, we need to modify the `task.html`
    file within the `task-list/task` folder, by replacing the native input checkbox
    that we have in the `task.html` file with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As always, we also need to tell the task component that we''d like to use the
    component within the template. Let''s change the code within the `task.js` file
    accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We've already learned about the host property on components. It allows us to
    set property and event bindings on our component host element. The host element
    is the DOM element where our component is initialized within the parent component.
  prefs: []
  type: TYPE_NORMAL
- en: There's another way through which we can set properties on our component host
    element, which becomes handy when we want to set a property based on some data
    within our component.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `@HostBinding` annotation, we can create property bindings on the
    component host element based on the members within our component. Let's use this
    annotation in order to create a binding that will conditionally set the `task--done`
    class on the component's HTML element. This is used to make some visual distinctions
    of finished tasks within our styles.
  prefs: []
  type: TYPE_NORMAL
- en: This was just the last step to integrate our custom checkbox UI component within
    the task component. You can now start `live-server` in order to view your changes
    and play around with these large new checkboxes in the task list. Isn't that much
    more fun to do than activating regular checkboxes? Don't underestimate the effect
    of a user interface that is pleasing to use. This can have a very positive impact
    on the usage of your product.
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom UI elements](img/image00306.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our task list after adding our custom checkbox component
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve created our `checkbox` component, let''s go ahead and create
    another UI component for toggle buttons that we''ll use in the next topic. We
    need to create a folder named `toggle` within the `ui` folder and create a template
    called `toggle.html` within the `toggle` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Nothing special here, really! We repeat a button by iterating over an instance
    field called `buttonList` using the `NgFor` directive. This button list will contain
    the labels of our toggle buttons. Conditionally, we set a class called `button--active`
    using a property binding and checking it against our current button within the
    iteration against an instance field called `selectedButton`. When the button is
    clicked, we call a method, `onButtonActivate`, on our component class and pass
    the current button label from the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create `toggle.js` inside the `toggle` folder and implement the `component`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Within our `toggle` component, we rely on the `buttonList` member to be an array
    of objects, as we are using this array within our template on an `NgFor` directive.
    The `buttonList` member is annotated to be an input property; this way, we can
    pass the array into the component.
  prefs: []
  type: TYPE_NORMAL
- en: For the `selectedButton` member, which holds the object of the `buttonList`
    array that is currently selected, we use a two-way data binding approach. This
    way, we can not only set the toggled button from the outside of the component,
    but also get notified via the `toggle` component, when a button is toggled in
    the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `onButtonActivate` function, we are setting the `selectedButton`
    member as well as triggering the event emitter.
  prefs: []
  type: TYPE_NORMAL
- en: The `ngOnInit` method is actually called by Angular within the life cycle of
    directives and components. In the case where the `selectedButton` input property
    was not specified, we'll add a check and select the first button from the available
    button list. Since `selectedButton` as well as `buttonList` are instance fields
    that are also input properties at the same time, we need to wait for them to be
    initialized in order to execute this logic. It's important not to perform this
    initialization within the component constructor. The life cycle hook, `OnInit`,
    will be called after the directive input and output properties have been checked
    for the first time. It is invoked only once when the directive is constructed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Angular will call any life cycle hooks that have been implemented on your component
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: The next diagram illustrates the life cycle of an Angular component. Upon component
    construction, all the life cycle hooks will be called as per the order shown in
    the diagram, except the `OnDestroy` hook, which will be called upon component
    destruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change detection will also start a subset of life cycle hooks, where there
    will be at least two cycles in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`doCheck`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`afterContentChecked`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`afterViewChecked`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onChanges` (if any changes are detected)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A detailed description of the life cycle hooks and their purpose is available
    on the Angular documentation website at [https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html](https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html).
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom UI elements](img/image00307.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An illustration of the life cycle of an Angular component
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this block, you learned how to build custom UI components that are generic
    and loosely coupled so that they can be used in other components as subcomponents.
    We also completed the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a subcomponent that is loosely coupled using output properties and
    event emitters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We learned what the `@Output` annotation is and how to use it to create output
    properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We used the `@HostBinding` annotation to create property bindings declaratively
    from within our component class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We used event bindings to link the behavior together from the view of a component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We built two-way data binding using a binding shorthand.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We learned about the working of the Angular component life cycle and how we
    can use the `OnInit` life cycle hook to initialize the component after the input
    and output have been processed for the first time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filtering tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the last building block of this chapter. We have already learned a lot
    about building basic components and how to compose them together in order to form
    larger components. In the previous building block, we created generic UI components
    that could be used in other components. In this topic, we will use the toggle
    button component not only to create a filter for our task list, but also to improve
    the way we receive and store tasks by using data services.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue with another refactoring exercise. So far, we have stored our
    task list data directly within the `task-list` component, but let's change that
    here and use a service that will provide tasks for us.
  prefs: []
  type: TYPE_NORMAL
- en: Our service will still not use a database, but we'll get the task data out of
    our component. In order to use the service, we're making use of Angular's dependency
    injection for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file called `task-list-service.js` within the `lib/task-list`
    folder of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We've moved all our task data into the newly created service. In order to make
    our service class injectable, we need to decorate it with the `@Injectable` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s apply some changes to our `task-list` component and modify the `task-list.js`
    file within the `task-list` folder. The modified code in the file is highlighted
    in the following code excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the import section of our module, we're going to import the task list service.
    We will use dependency injection to receive an instance of the `TaskListService`
    class within our component constructor. For this, we'll use a new annotation,
    which lets us specify the type we'd like to inject. The `Inject` decorator needs
    to be imported from the Angular core module in order to use the `@Inject` annotation.
    If you take a look at our constructor, you'll find that we're using the `@Inject`
    annotation there to specify what instance type we'd like to inject.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `@Inject` annotation on the constructor, we need one last
    thing to make the injection work. We need to register `TaskListService` as a provider
    within the `providers` property of our `@Component` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Now we get the `TaskListService` injected when the directive is constructed,
    and we can store a reference to it inside an instance field.
  prefs: []
  type: TYPE_NORMAL
- en: Within the constructor of the component, we also want to store a list of states
    the task status filter can have. This list will also serve as input for our toggle
    button list. If you recall the input properties on our toggle button, we have
    a `buttonList` input that accepts a list of button labels. To store the currently
    selected filter type, we use an instance field called `selectedTaskFilter`.
  prefs: []
  type: TYPE_NORMAL
- en: The last piece that we need to add to our `task-list` component is the method,
    `getFilteredTasks`. We no longer need to store the task list directly within an
    instance field, and tasks should only be received within the component using this
    method. The logic inside the method checks the `selectedTaskFilter` property and
    returns a filtered list that meets this condition.
  prefs: []
  type: TYPE_NORMAL
- en: Since we want to use the toggle button component that we've created within the
    previous topic to create a filter button list, we will need to import the toggle
    component within the import section and also add the `Toggle` class to our `directives`
    property. Now we can use the toggle component within the template of our `task-list`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, that''s all we are going to change in our component implementation. We
    want to change our view template though to use the filtered task list coming from
    the data service and show a toggle button list to activate the different filter
    types. Let''s open the template file, `task-list.html`, inside the `task-list`
    folder and modify it with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Since we've added the toggle component within the `directives` property of our
    `task-list` component, we can use it now within our view template. We bind the
    input property `buttonList` to `taskFilterList` that we store within our `task-list`
    component. Also, we're using two-way data binding to bind the `selectedButton`
    input property of the toggle button list to the `selectedTaskFilter` instance
    field of the task list. This way, we can not only update the selected task filer
    from our `task-list` component programmatically, but also allow a user to change
    the value using the toggle button list.
  prefs: []
  type: TYPE_NORMAL
- en: Now we only need to make a small change to the `NgFor` directive that repeats
    our task elements within the task list. Since we need to access the tasks of the
    `task-list` component with the `getFilteredTasks` method now, we also need to
    use that method within our repeater expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it already, congratulations! You''ve successfully added a filtering
    mechanism to your task list by reusing the toggle component that we created in
    the previous topic. You can now start your live server (using the `live-server`
    command) and should see a fully functional task list where you can enter new tasks
    and also filter the task list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Filtering tasks](img/image00308.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot of the task list with the newly added toggle button component for
    filtering the task state
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned a lot of new concepts on building UI-component-based
    applications with Angular. Also, we built the core component of our task management
    application, which is the task list itself. You learned about the concept of input
    and output properties and how to use them to build two-way data binding.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered the basics of the Angular component life cycle and how to use
    life cycle hooks to execute post initialization steps.
  prefs: []
  type: TYPE_NORMAL
- en: As the last step, we integrated a toggle button list component within our task
    list to filter the task states. We refactored our `task-list` component to use
    a service in order to obtain task data. For this, we used Angular's dependency
    injection.
  prefs: []
  type: TYPE_NORMAL
