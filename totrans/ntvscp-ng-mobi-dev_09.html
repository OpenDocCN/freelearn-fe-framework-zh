<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Empowering Your Views</h1>
                
            
            <article>
                
<p class="mce-root">The combination of Angular and NativeScript is fun to develop with and powerful beyond measure for mobile development. Whether you need to provide services to engage with a mobile device's hardware capabilities, such as audio recording or enrich your app's usability with engaging views, NativeScript for Angular provides exciting opportunities.</p>
<p class="mce-root">Let's continue with several concepts we developed in the preceding chapter to provide an alternate rich view of our tracks while reusing everything we've covered so far, in addition to a few new tips/tricks.</p>
<p class="mce-root"><span>In this chapter, we will cover the following topics:</span></p>
<ul class="calibre13">
<li class="calibre14">Using multiple item row templates with <kbd class="calibre11">ListView</kbd> and <kbd class="calibre11">templateSelector</kbd></li>
<li class="calibre14">Handling row template changes with <kbd class="calibre11">ListView</kbd> and when/how to refresh them</li>
<li class="calibre14">Using <kbd class="calibre11">ngModel</kbd> data binding via <kbd class="calibre11">NativeScriptFormsModule</kbd></li>
<li class="calibre14">Leveraging a shared singleton service for sharing state across multiple modules</li>
<li class="calibre14">Serializing data before storing and hydrating upon retrieval from a persisted state</li>
<li class="calibre14">Leveraging and reusing Angular directives to enrich the NativeScript Slider with more unique characteristics</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Multiple item templates with NativeScript's ListView</h1>
                
            
            <article>
                
<p class="mce-root">All throughout <a href="part0101.html#30A8Q0-289fe2426d594f99a90e4363b2c9c34d" class="calibre3">Chapter 8</a>, <em class="calibre21">Building an audio recorder</em>, we designed a dual-purpose custom NativeScript Waveform view, which taps into various native libraries for iOS and Android, specifically to enrich our composition's track listing view. Let's proceed by reusing our versatile Waveform view for our track listing view. This will also give us a way to display mixing slider controls (often referred to in audio production and sound engineering as a Fader) alongside our tracks to allow the user to mix each track's volume level in the overall composition. Let's set up our <kbd class="calibre11">ListView</kbd> of <kbd class="calibre11">TrackListComponent</kbd> with the ability to provide the user with two different ways to view and work with their tracks, each with their own unique utility. While we're at it, we'll also take this opportunity to finally wire up the <kbd class="calibre11">mute</kbd> switch on our tracks.</p>
<p class="mce-root">Let's make the following modifications to <kbd class="calibre11">app/modules/player/components/track-list/track-list.component.html</kbd>:</p>
<pre class="calibre22">&lt;ListView #listview [items]="tracks | orderBy: 'order'" class="list-group" <br class="title-page-name"/>  [itemTemplateSelector]="templateSelector"&gt;<br class="title-page-name"/>  &lt;ng-template let-track="item" nsTemplateKey="default"&gt;<br class="title-page-name"/>    &lt;GridLayout rows="auto" columns="100,*,100" class="list-group-item" <br class="title-page-name"/>      [class.muted]="track.mute"&gt;<br class="title-page-name"/>      &lt;Button text="Record" (tap)="record(track)" row="0" col="0" class="c-ruby"&gt;&lt;/Button&gt;<br class="title-page-name"/>      &lt;Label [text]="track.name" row="0" col="1" class="h2"&gt;&lt;/Label&gt;<br class="title-page-name"/>      &lt;Switch row="0" col="2" class="switch" [(ngModel)]="track.mute"&gt;&lt;/Switch&gt;<br class="title-page-name"/>    &lt;/GridLayout&gt;<br class="title-page-name"/>  &lt;/ng-template&gt;<br class="title-page-name"/><br class="title-page-name"/>  &lt;ng-template let-track="item" nsTemplateKey="waveform"&gt;<br class="title-page-name"/>    &lt;AbsoluteLayout [class.muted]="track.mute"&gt;<br class="title-page-name"/>      &lt;Waveform class="waveform w-full" top="0" left="0" height="80"<br class="title-page-name"/>        [model]="track.model"<br class="title-page-name"/>        type="file"<br class="title-page-name"/>        plotColor="#888703"<br class="title-page-name"/>        fill="true"<br class="title-page-name"/>        mirror="true"<br class="title-page-name"/>        plotType="buffer"&gt;&lt;/Waveform&gt;<br class="title-page-name"/> <br class="title-page-name"/>      &lt;Label [text]="track.name" row="0" col="1" class="h3 track-name-float"<br class="title-page-name"/>        top="5" left="20"&gt;&lt;/Label&gt;<br class="title-page-name"/>      &lt;Slider slim-slider="fader.png" minValue="0" maxValue="1" <br class="title-page-name"/>        width="94%" top="50" left="0"<br class="title-page-name"/>        [(ngModel)]="track.volume" class="slider fader"&gt;&lt;/Slider&gt;<br class="title-page-name"/>    &lt;/AbsoluteLayout&gt;<br class="title-page-name"/>  &lt;/ng-template&gt;<br class="title-page-name"/>&lt;/ListView&gt;</pre>
<p class="mce-root">There's a lot of interesting things happening here. First of all, <kbd class="calibre11">[itemTemplateSelector]="templateSelector"</kbd> provides the ability to change our <kbd class="calibre11">ListView</kbd> item rows on the fly. The result of the <kbd class="calibre11">templateSelector</kbd> <span>function </span>should be a string, which matches the value provided on any ng-template's <kbd class="calibre11">ngTemplateKey</kbd> attribute. To make all this work, we will need several things in place, starting with the <kbd class="calibre11">Component</kbd> that has access to the <kbd class="calibre11">ListView</kbd> via <kbd class="calibre11">#listview</kbd> and <kbd class="calibre11">ViewChild</kbd>:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Component, Input, <strong class="calibre1">ViewChild, ElementRef</strong> } from '@angular/core';<br class="title-page-name"/>import { Router } from '@angular/router';<br class="title-page-name"/><br class="title-page-name"/>// nativescript<br class="title-page-name"/><strong class="calibre1">import { ListView } from 'ui/list-view';</strong><br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/>import { ITrack } from '../../../shared/models';<br class="title-page-name"/>import { AuthService, DialogService } from '../../../core/services';<br class="title-page-name"/><strong class="calibre1">import { PlayerService } from '../../services/player.service';</strong><br class="title-page-name"/><br class="title-page-name"/>@Component({<br class="title-page-name"/> moduleId: module.id,<br class="title-page-name"/> selector: 'track-list',<br class="title-page-name"/> templateUrl: 'track-list.component.html',<br class="title-page-name"/>})<br class="title-page-name"/>export class TrackListComponent {<br class="title-page-name"/> <br class="title-page-name"/>  <strong class="calibre1">public templateSelector: Function;</strong><br class="title-page-name"/>  @Input() tracks: Array&lt;ITrack&gt;;<br class="title-page-name"/>  <strong class="calibre1">@ViewChild('listview') _listviewRef: ElementRef;</strong><br class="title-page-name"/><strong class="calibre1">  private _listview: ListView;</strong><br class="title-page-name"/><strong class="calibre1">  private _sub: any;</strong><br class="title-page-name"/> <br class="title-page-name"/>  constructor(<br class="title-page-name"/>    private authService: AuthService,<br class="title-page-name"/>    private dialogService: DialogService,<br class="title-page-name"/>    private router: Router,<br class="title-page-name"/>    <strong class="calibre1">private playerService: PlayerService</strong><br class="title-page-name"/>  ) { <br class="title-page-name"/>    <strong class="calibre1">this.templateSelector = this._templateSelector.bind(this);</strong><br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">ngOnInit() {</strong><br class="title-page-name"/><strong class="calibre1">    this._sub = this.playerService.trackListViewChange$.subscribe(() =&gt; {<br class="title-page-name"/></strong>      // since this involves our templateSelector, ensure ListView knows about it<br class="title-page-name"/>      // refresh list<br class="title-page-name"/><strong class="calibre1">      this._listview.refresh();</strong><br class="title-page-name"/><strong class="calibre1">    });</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  ngAfterViewInit() {</strong><br class="title-page-name"/><strong class="calibre1">    this._listview = &lt;ListView&gt;this._listviewRef.nativeElement;</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  private _templateSelector(item: ITrack, index: number, items: ITrack[]) {</strong><br class="title-page-name"/><strong class="calibre1">    return this.playerService.trackListViewType;</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/>  ...</pre>
<p class="mce-root">We set up a <kbd class="calibre11">ViewChild</kbd> to retain a reference to our <kbd class="calibre11">ListView</kbd> which we will use<span> later</span> to call <kbd class="calibre11">this._listview.refresh()</kbd> . This is required in Angular when we need the <kbd class="calibre11">ListView</kbd> to update <span>the </span>display after changes. The first surprise will likely be the injection of <kbd class="calibre11">PlayerService</kbd>, and the second might be the <kbd class="calibre11">this.templateSelector = this._templateSelector.bind(this)</kbd>. The <kbd class="calibre11">templateSelector</kbd> binding is not scope bound, and since we need it to return a property reference from our <kbd class="calibre11">this.playerService</kbd> on the <kbd class="calibre11">Component</kbd>, we ensure that it is properly bound to the scope of the <span><kbd class="calibre11">Component</kbd> </span>by binding a <kbd class="calibre11">Function</kbd> reference. <strong class="calibre1"> </strong>We will use <kbd class="calibre11">PlayerService</kbd> as a conduit at this point to help communicate the state from the <kbd class="calibre11">ActionBarComponent</kbd> that lives in the <kbd class="calibre11">MixerModule</kbd>.</p>
<div class="packt_tip">This example shows how services can help communicate the state throughout your app. However, this practice can be greatly improved by utilizing <kbd class="calibre29">ngrx</kbd> to help lessen interwoven dependencies and unlock a purely reactive setup with Redux-style architecture. @ngrx enhancements will be covered in <a href="part0121.html#3JCK20-289fe2426d594f99a90e4363b2c9c34d" class="calibre35">Chapter 10</a>, <em class="calibre23">@ngrx/store + @ngrx/effects for State Management</em>.</div>
<p class="mce-root">Our <span>View Toggle</span> button will be in the <kbd class="calibre11">ActionBar</kbd> (in the <kbd class="calibre11">MixerModule</kbd>), and we will want to tap there to switch our <kbd class="calibre11">ListView</kbd>, which lives inside our <kbd class="calibre11">PlayerModule</kbd>. The <kbd class="calibre11">PlayerService</kbd> is a singleton at the moment (provided by <kbd class="calibre11">CoreModule</kbd>) and is shared across the entire app, so it's a perfect candidate to aid here. Let's take a look at our <kbd class="calibre11">ActionBarComponent</kbd> changes first in <kbd class="calibre11">app/modules/mixer/components/action-bar/action-bar.component.ios.html</kbd>:</p>
<pre class="calibre22">&lt;ActionBar [title]="title" class="action-bar"&gt;<br class="title-page-name"/>  &lt;ActionItem nsRouterLink="/mixer/home"&gt;<br class="title-page-name"/>    &lt;Button text="List" class="action-item"&gt;&lt;/Button&gt;<br class="title-page-name"/>  &lt;/ActionItem&gt;<br class="title-page-name"/>  <strong class="calibre1">&lt;ActionItem (tap)="toggleList()" ios.position="right"&gt;</strong><br class="title-page-name"/><strong class="calibre1">    &lt;Button [text]="toggleListText" class="action-item"&gt;&lt;/Button&gt;</strong><br class="title-page-name"/><strong class="calibre1">  &lt;/ActionItem&gt;</strong><br class="title-page-name"/>  &lt;ActionItem (tap)="record()" ios.position="right"&gt;<br class="title-page-name"/>    &lt;Button text="Record" class="action-item"&gt;&lt;/Button&gt;<br class="title-page-name"/>  &lt;/ActionItem&gt;<br class="title-page-name"/>&lt;/ActionBar&gt;</pre>
<p class="mce-root">Then, we'll take a look at the changes in <kbd class="calibre11">app/modules/mixer/components/action-bar/action-bar.component.android.html</kbd>:</p>
<pre class="calibre22">&lt;ActionBar class="action-bar"&gt;<br class="title-page-name"/>  &lt;GridLayout rows="auto" columns="auto,*,auto,auto" class="action-bar"&gt;<br class="title-page-name"/>    &lt;Button text="List" nsRouterLink="/mixer/home" <br class="title-page-name"/>      class="action-item" row="0" col="0"&gt;&lt;/Button&gt;<br class="title-page-name"/>    &lt;Label [text]="title" class="action-bar-title text-center" row="0" col="1"&gt;&lt;/Label&gt;<br class="title-page-name"/>    <strong class="calibre1">&lt;Button [text]="toggleListText" (tap)="toggleList()" </strong><br class="title-page-name"/><strong class="calibre1">      class="action-item" row="0" col="2"&gt;&lt;/Button&gt;</strong><br class="title-page-name"/>    &lt;Button text="Record" (tap)="record()" <br class="title-page-name"/>      class="action-item" row="0" col="3"&gt;&lt;/Button&gt;<br class="title-page-name"/>  &lt;/GridLayout&gt;<br class="title-page-name"/>&lt;/ActionBar&gt;</pre>
<p class="mce-root"><span>We'll also take a look at the changes in </span>the <kbd class="calibre11">Component</kbd>:</p>
<pre class="calibre22">...<br class="title-page-name"/><strong class="calibre1">import { PlayerService } from '../../../player/services/player.service';</strong><br class="title-page-name"/><br class="title-page-name"/>@Component({<br class="title-page-name"/>  moduleId: module.id,<br class="title-page-name"/>  selector: 'action-bar',<br class="title-page-name"/>  templateUrl: 'action-bar.component.html'<br class="title-page-name"/>})<br class="title-page-name"/>export class ActionBarComponent {<br class="title-page-name"/>  ...<br class="title-page-name"/>  <strong class="calibre1">public toggleListText: string = 'Waveform';</strong><br class="title-page-name"/><br class="title-page-name"/>  constructor(<br class="title-page-name"/>    private router: RouterExtensions,<br class="title-page-name"/>    private playerService: PlayerService<br class="title-page-name"/>  ) { }<br class="title-page-name"/>  ...<br class="title-page-name"/>  <strong class="calibre1">public toggleList() {</strong><br class="title-page-name"/>    // later we can use icons, using labels for now<strong class="calibre1"><br class="title-page-name"/>    let type = this.playerService.trackListViewType === 'default' ? 'waveform' : 'default';<br class="title-page-name"/>    this.playerService.trackListViewType = type;<br class="title-page-name"/>    this.toggleListText = type === 'default' ? 'Waveform' : 'Default';</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/>}</pre>
<p class="mce-root">As you can see, we added a button to the <kbd class="calibre11">ActionBar</kbd>, which will use the label <kbd class="calibre11">Waveform</kbd> or <kbd class="calibre11">Default</kbd>, depending on its state. Then, we used <kbd class="calibre11">PlayerService</kbd> to modify a new setter, <kbd class="calibre11"><strong class="calibre1">this.playerService.trackListViewType</strong> <strong class="calibre1">=</strong> <strong class="calibre1">type</strong></kbd>. Let's take a look at <kbd class="calibre11">app/modules/player/services/player.service.ts</kbd> now:</p>
<pre class="calibre22">...<br class="title-page-name"/>@Injectable()<br class="title-page-name"/>export class PlayerService {<br class="title-page-name"/>  ...<br class="title-page-name"/>  // communicate state changes from ActionBar to anything else<br class="title-page-name"/>  <strong class="calibre1">public trackListViewChange$: Subject&lt;string&gt; = new Subject();<br class="title-page-name"/>  </strong>...<strong class="calibre1"><br class="title-page-name"/>  public get trackListViewType() {<br class="title-page-name"/>    return this._trackListViewType;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public set trackListViewType(value: string) {<br class="title-page-name"/>    this._trackListViewType = value;<br class="title-page-name"/>    this.trackListViewChange$.next(value);<br class="title-page-name"/>  }<br class="title-page-name"/>  </strong>...</pre>
<p class="mce-root">This gets the job done<strong class="calibre1">.</strong></p>
<div class="packt_infobox">As mentioned, we will improve this setup in the next chapter with ngrx, which is all about polishing and simplifying the way we handle our app's state.</div>
<p class="mce-root">There are a couple more things that we will need to do to ensure that all our new additions work. For starters, the <kbd class="calibre11">[(ngModel)]</kbd> bindings will <em class="calibre21">not</em> work at all without the <kbd class="calibre11">NativeScriptFormsModule</kbd>.</p>
<div class="packt_tip">If you use the <kbd class="calibre29">ngModel</kbd> bindings in your component's view, you must ensure that the module that declares your <kbd class="calibre29">Component</kbd> imports the <kbd class="calibre29">NativeScriptFormsModule</kbd>. If it uses a <kbd class="calibre29">SharedModule</kbd>, ensure that the <kbd class="calibre29">SharedModule</kbd> imports and exports the <span class="calibre31"><kbd class="calibre29">NativeScriptFormsModule</kbd>.</span></div>
<p class="mce-root">Let's add the module mentioned in the preceding tip to our <kbd class="calibre11">SharedModule</kbd> so that all of our modules can use <kbd class="calibre11">ngModel</kbd> wherever needed:</p>
<pre class="calibre22">...<br class="title-page-name"/><strong class="calibre1">import { NativeScriptFormsModule } from 'nativescript-angular/forms';</strong> <br class="title-page-name"/>...<br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  imports: [<br class="title-page-name"/>    NativeScriptModule, <br class="title-page-name"/>    NativeScriptRouterModule,<br class="title-page-name"/>    <strong class="calibre1">NativeScriptFormsModule</strong><br class="title-page-name"/>  ],<br class="title-page-name"/>  ...<br class="title-page-name"/>  exports: [<br class="title-page-name"/>    NativeScriptModule,<br class="title-page-name"/>    NativeScriptRouterModule,<br class="title-page-name"/>    <strong class="calibre1">NativeScriptFormsModule,</strong><br class="title-page-name"/>    ...PIPES<br class="title-page-name"/>  ]<br class="title-page-name"/>})<br class="title-page-name"/>export class SharedModule {}</pre>
<p class="mce-root">We will now need each track's mute and volume property changes to notify our audio player. This involves changing our <kbd class="calibre11">TrackModel</kbd> slightly to account for this new functionality; to do that, open <kbd class="calibre11">app/modules/shared/models/track.model.ts</kbd>:</p>
<pre class="calibre22"><strong class="calibre1">import { BehaviorSubject } from 'rxjs/BehaviorSubject';</strong><br class="title-page-name"/>...<br class="title-page-name"/>export class TrackModel implements ITrack {<br class="title-page-name"/>  public id: number;<br class="title-page-name"/>  public filepath: string;<br class="title-page-name"/>  public name: string;<br class="title-page-name"/>  public order: number;<br class="title-page-name"/>  public model: any;<br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">public volume$: BehaviorSubject&lt;number&gt;;</strong><br class="title-page-name"/> <br class="title-page-name"/>  <strong class="calibre1">private _volume: number = 1;</strong> // default full volume<br class="title-page-name"/>  <strong class="calibre1">private _mute: boolean;</strong><br class="title-page-name"/>  <strong class="calibre1">private _origVolume: number;</strong> // return to after unmute<br class="title-page-name"/><br class="title-page-name"/>  constructor(model?: ITrack) {<br class="title-page-name"/>    <strong class="calibre1">this.volume$ = new BehaviorSubject(this._volume);<br class="title-page-name"/></strong>    ...<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">public set mute(value: boolean) {</strong><br class="title-page-name"/><strong class="calibre1">    this._mute = value;</strong><br class="title-page-name"/><strong class="calibre1">    if (this._mute) {</strong><br class="title-page-name"/><strong class="calibre1">      this._origVolume = this._volume;</strong><br class="title-page-name"/><strong class="calibre1">      this.volume = 0;</strong><br class="title-page-name"/><strong class="calibre1">    } else {</strong><br class="title-page-name"/><strong class="calibre1">      this.volume = this._origVolume;</strong><br class="title-page-name"/><strong class="calibre1">    }</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  public get mute() {</strong><br class="title-page-name"/><strong class="calibre1">    return this._mute;</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  public set volume(value: number) {</strong><br class="title-page-name"/><strong class="calibre1">    this._volume = value;</strong><br class="title-page-name"/><strong class="calibre1">    this.volume$.next(this._volume);</strong><br class="title-page-name"/><strong class="calibre1">    if (this._volume &gt; 0 &amp;&amp; this._mute) {</strong><br class="title-page-name"/>      // if just increasing volume from a muted state<br class="title-page-name"/>      // ensure it's unmuted<strong class="calibre1"> </strong><br class="title-page-name"/><strong class="calibre1">      this._origVolume = this._volume;</strong><br class="title-page-name"/><strong class="calibre1">      this._mute = false;</strong><br class="title-page-name"/><strong class="calibre1">    }</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  public get volume() {</strong><br class="title-page-name"/><strong class="calibre1">    return this._volume;</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/>}</pre>
<p class="mce-root">We now want to modify our <kbd class="calibre11">TrackPlayerModel</kbd> to work in tandem with these new features. Earlier, we used to retain just the <kbd class="calibre11">trackId</kbd>; however, with this new addition, it would be helpful to keep a reference to the entire <kbd class="calibre11">TrackModel</kbd> object, so open <kbd class="calibre11">app/modules/shared/models/track-player.model.ts</kbd> and make the following changes:</p>
<pre class="calibre22">...<br class="title-page-name"/><strong class="calibre1">import { Subscription } from 'rxjs/Subscription';</strong><br class="title-page-name"/>...<br class="title-page-name"/>interface ITrackPlayer {<br class="title-page-name"/>  <strong class="calibre1">track: TrackModel; </strong>// was trackId only<br class="title-page-name"/>  duration: number;<br class="title-page-name"/>  readonly player: TNSPlayer;<br class="title-page-name"/>}<br class="title-page-name"/>...<br class="title-page-name"/>export class TrackPlayerModel implements ITrackPlayer {<br class="title-page-name"/>  <strong class="calibre1">public track: TrackModel;</strong><br class="title-page-name"/>  ...<br class="title-page-name"/>  <strong class="calibre1">private _sub: Subscription;</strong><br class="title-page-name"/>  ...<br class="title-page-name"/>  public load(track: TrackModel, complete: Function, error: Function): Promise&lt;number&gt; {<br class="title-page-name"/>    return new Promise((resolve, reject) =&gt; {<br class="title-page-name"/>      <strong class="calibre1">this.track = track;</strong><br class="title-page-name"/><br class="title-page-name"/>      this._player.initFromFile({<br class="title-page-name"/>        ...<br class="title-page-name"/>      }).then(() =&gt; {<br class="title-page-name"/>        ...<br class="title-page-name"/>        // if reloading track, clear subscription before subscribing again<br class="title-page-name"/>        <strong class="calibre1">if (this._sub) this._sub.unsubscribe();</strong><br class="title-page-name"/><strong class="calibre1">        this._sub = this.track.volume$.subscribe((value) =&gt; {</strong><br class="title-page-name"/><strong class="calibre1">          if (this._player) {</strong><br class="title-page-name"/><strong class="calibre1">            // react to track model property changes</strong><br class="title-page-name"/><strong class="calibre1">            this._player.volume = value;</strong><br class="title-page-name"/><strong class="calibre1">          }</strong><br class="title-page-name"/><strong class="calibre1">        });</strong><br class="title-page-name"/>      }, reject);<br class="title-page-name"/>    });<br class="title-page-name"/>  }<br class="title-page-name"/>  ...<br class="title-page-name"/>  public cleanup() {<br class="title-page-name"/>    // cleanup and dispose player<br class="title-page-name"/>    if (this.player) this.player.dispose();<br class="title-page-name"/>    <strong class="calibre1">if (this._sub) this._sub.unsubscribe();</strong> <br class="title-page-name"/>  }<br class="title-page-name"/>  ...</pre>
<p class="mce-root">Our audio player can now react to volume changes made via data binding from each track by observing the <kbd class="calibre11">volume$</kbd> subject observable. Since mute essentially just requires the modification of the player's volume, we ensure that we update the volume accordingly and maintain the original volume if toggling mute on/off, so any custom volume set will be retained.</p>
<p class="mce-root">Our new enriched view of our tracks includes our reusable Waveform view but this time with <kbd class="calibre11">type="file"</kbd>, since this will engage the audio file static Waveform to be rendered so that we can <em class="calibre21">see</em> our audio. We also provide the ability to adjust each track's volume (mixing control) and float a label off to the top-left corner so that the user still knows what is what. This is all done by utilizing an <kbd class="calibre11">AbsoluteLayout</kbd> container, which allows us to overlap components and manually position them on top of each other.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Serializing data for persistence and hydrating it back upon retrieval</h1>
                
            
            <article>
                
<p class="mce-root">This all works really nicely, however, we have introduced a problem. Our <kbd class="calibre11">MixerService</kbd> provides the ability to save these compositions with all their tracks. However the tracks now contain complex objects such as Observables and even private references with getters and setters. </p>
<div class="packt_infobox">When persisting data, you will often want to use <kbd class="calibre29">JSON.stringify</kbd> to serialize objects when storing them so that they can be retrieved later and hydrated into more complex models if needed.</div>
<p class="mce-root">In fact, if you were to attempt to process our <kbd class="calibre11">TrackModel</kbd> with <kbd class="calibre11">JSON.stringify</kbd> now, it would fail because you cannot stringify certain structures. So, we now need a way to serialize our data before storing it, as well as a way to hydrate that data when retrieving to restore our more sophisticated models. Let's make a few changes to our <kbd class="calibre11">MixerService</kbd> to account for this. Open <kbd class="calibre11">app/modules/mixer/services/mixer.service.ts</kbd>and make the following changes:</p>
<pre class="calibre22">// nativescript<br class="title-page-name"/><strong class="calibre1">import { knownFolders, path } from 'file-system';</strong><br class="title-page-name"/>...<br class="title-page-name"/>@Injectable()<br class="title-page-name"/>export class MixerService {<br class="title-page-name"/><br class="title-page-name"/>  public list: Array&lt;IComposition&gt;;<br class="title-page-name"/><br class="title-page-name"/>  constructor(<br class="title-page-name"/>    private databaseService: DatabaseService,<br class="title-page-name"/>    private dialogService: DialogService<br class="title-page-name"/>  ) {<br class="title-page-name"/>    // restore with saved compositions or demo list<br class="title-page-name"/>    this.list = <strong class="calibre1">this._hydrateList(</strong>this._savedCompositions() || this._demoComposition()<strong class="calibre1">)</strong>;<br class="title-page-name"/>  }<br class="title-page-name"/>  ...<br class="title-page-name"/>  private _saveList() {<br class="title-page-name"/>    this.databaseService.setItem(DatabaseService.KEYS.compositions, <strong class="calibre1">this._serializeList()</strong>);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">private _serializeList() {</strong><br class="title-page-name"/><strong class="calibre1">    let serialized = [];</strong><br class="title-page-name"/><strong class="calibre1">    for (let comp of this.list) {</strong><br class="title-page-name"/><strong class="calibre1">      let composition: any = Object.assign({}, comp);</strong><br class="title-page-name"/><strong class="calibre1">      composition.tracks = [];</strong><br class="title-page-name"/><strong class="calibre1">      for (let track of comp.tracks) {</strong><br class="title-page-name"/><strong class="calibre1">        let serializedTrack = {};</strong><br class="title-page-name"/><strong class="calibre1">        for (let key in track) {</strong><br class="title-page-name"/>          // ignore observable, private properties and waveform model (redundant)<br class="title-page-name"/>          // properties are restored upon hydration<br class="title-page-name"/><strong class="calibre1">          if (!key.includes('_') &amp;&amp; !key.includes('$') &amp;&amp; key != 'model') {</strong><br class="title-page-name"/><strong class="calibre1">            serializedTrack[key] = track[key];</strong><br class="title-page-name"/><strong class="calibre1">          }</strong><br class="title-page-name"/><strong class="calibre1">        }</strong><br class="title-page-name"/><strong class="calibre1">        composition.tracks.push(serializedTrack);</strong><br class="title-page-name"/><strong class="calibre1">      }</strong><br class="title-page-name"/>      // serialized composition<br class="title-page-name"/><strong class="calibre1">      serialized.push(composition);</strong><br class="title-page-name"/><strong class="calibre1">    }</strong><br class="title-page-name"/><strong class="calibre1">    return serialized;</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  private _hydrateList(list: Array&lt;IComposition&gt;) {</strong><br class="title-page-name"/><strong class="calibre1">    for (let c = 0; c &lt; list.length; c++) {</strong><br class="title-page-name"/><strong class="calibre1">      let comp = new CompositionModel(list[c]);</strong><br class="title-page-name"/><strong class="calibre1">      for (let i = 0; i &lt; comp.tracks.length; i++) {</strong><br class="title-page-name"/><strong class="calibre1">        comp.tracks[i] = new TrackModel(comp.tracks[i]);</strong><br class="title-page-name"/>        // for waveform<br class="title-page-name"/><strong class="calibre1">        (&lt;any&gt;comp.tracks[i]).model = {</strong><br class="title-page-name"/>          // fix is only for demo tracks since they use files from app folder<br class="title-page-name"/><strong class="calibre1">          target: fixAppLocal(comp.tracks[i].filepath)</strong><br class="title-page-name"/><strong class="calibre1">        };</strong><br class="title-page-name"/><strong class="calibre1">      }</strong><br class="title-page-name"/><strong class="calibre1">      // ensure list ref is updated to use hydrated model</strong><br class="title-page-name"/><strong class="calibre1">      list[c] = comp;</strong><br class="title-page-name"/><strong class="calibre1">    }</strong><br class="title-page-name"/><strong class="calibre1">    return list;</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/>  ...<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">const fixAppLocal = function (filepath: string) {</strong><br class="title-page-name"/><strong class="calibre1">  if (filepath.indexOf('~/') === 0) {<br class="title-page-name"/></strong>    // needs to be absolute path and not ~/ app local shorthand<br class="title-page-name"/><strong class="calibre1">    return path.join(knownFolders.currentApp().path, filepath.replace('~/', ''));</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><strong class="calibre1">  return filepath;</strong><br class="title-page-name"/><strong class="calibre1">}</strong></pre>
<p class="mce-root">We will now ensure that any time our composition is saved, it's properly serialized into a safe and more simplified form, which can be processed by <kbd class="calibre11">JSON.stringify</kbd>. Then, when retrieving data out of our persistent store (in this case, via NativeScript's application-settings module being used under the hood of our <kbd class="calibre11">DatabaseService</kbd>; this is covered in <a href="part0037.html#1394Q0-289fe2426d594f99a90e4363b2c9c34d" class="calibre3">Chapter 2</a>, <em class="calibre21">Feature Modules</em>, we hydrate the data back into our models, which will enrich the data with our observable properties.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Leveraging Angular directives to enrich the NativeScript Slider with more unique characteristics</h1>
                
            
            <article>
                
<p class="mce-root">For each track fader (also known as our mixing/volume control), it'd be nice to actually render a fader-looking control knob so that it's clear that these Sliders are mixing knobs and are not mistaken for shuttling playback of that track, for instance. We can create a graphic to be used for these Sliders, which will look like this:</p>
<div class="mce-root1"><img class="image-border33" src="../images/00042.jpeg"/></div>
<p class="cdpalignleft1">For iOS, we will also want a down/highlighted state, so usability feels good when the user presses down on the fader:</p>
<div class="mce-root1"><img class="image-border33" src="../images/00043.jpeg"/></div>
<p class="mce-root">We can now create two versions of each of these files and drop them in <kbd class="calibre11">app/App_Resources/iOS</kbd>; the original will be 100x48 for standard resolution, then for iPhone Plus and above, we will have a @3x version at 150x72 (basically, 24 plus the standard 48 height):</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre11">fader-down.png</kbd></li>
<li class="calibre14"><kbd class="calibre11">fader-down@3x.png</kbd></li>
<li class="calibre14"><kbd class="calibre11">fader.png</kbd></li>
<li class="calibre14"><kbd class="calibre11">fader@3x.png</kbd></li>
</ul>
<p class="mce-root">We can now reuse our <kbd class="calibre11">SlimSliderDirective</kbd> (currently being used to customize the look of the shuttle slider) and provide an input so that we can provide the name of a file from our app's resources to use for the thumb. <br class="title-page-name"/>
Open <kbd class="calibre11">app/modules/player/directives/slider.directive.ios.ts</kbd> and make the following modifications:</p>
<pre class="calibre22">import { Directive, ElementRef, <strong class="calibre1">Input</strong> } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>@Directive({<br class="title-page-name"/>  selector: '[slim-slider]'<br class="title-page-name"/>})<br class="title-page-name"/>export class SlimSliderDirective {<br class="title-page-name"/>  <strong class="calibre1">@Input('slim-slider') imageName: string;</strong><br class="title-page-name"/><br class="title-page-name"/>  constructor(private el: ElementRef) { } <br class="title-page-name"/><br class="title-page-name"/>  ngAfterViewInit() {<br class="title-page-name"/>    let uiSlider = &lt;UISlider&gt;this.el.nativeElement.ios;<br class="title-page-name"/>    <strong class="calibre1">if (this.imageName) {</strong><br class="title-page-name"/><strong class="calibre1">      uiSlider.setThumbImageForState(</strong><br class="title-page-name"/><strong class="calibre1">        UIImage.imageNamed(this.imageName), UIControlState.Normal);</strong><br class="title-page-name"/>      // assume highlighted state always suffixed with '-down'<br class="title-page-name"/>      <strong class="calibre1">let imgParts = this.imageName.split('.');</strong><br class="title-page-name"/><strong class="calibre1">      let downImg = `${imgParts[0]}-down.${imgParts[1]}`;</strong><br class="title-page-name"/><strong class="calibre1">      uiSlider.setThumbImageForState(</strong><br class="title-page-name"/><strong class="calibre1">        UIImage.imageNamed(downImg), UIControlState.Highlighted);</strong><br class="title-page-name"/>    } else {<br class="title-page-name"/>      // used for shuttle control<br class="title-page-name"/>      uiSlider.userInteractionEnabled = false;<br class="title-page-name"/>      uiSlider.setThumbImageForState(UIImage.new(), UIControlState.Normal);<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="mce-root">This allows us to specify the filename to be used as the <kbd class="calibre11">Slider</kbd> thumb on the component itself:</p>
<pre class="calibre22">&lt;Slider <strong class="calibre1">slim-slider="fader.png"</strong> minValue="0" maxValue="1" <br class="title-page-name"/>  width="94%" top="50" left="0"<br class="title-page-name"/>  [(ngModel)]="track.volume" class="slider fader"&gt;&lt;/Slider&gt;</pre>
<p class="mce-root">With this in place, we now have these neat fader controls for iOS when the track mixing view toggle is engaged:</p>
<div class="mce-root1"><img class="image-border34" src="../images/00044.jpeg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Graphic and resource handling for Android</h1>
                
            
            <article>
                
<p class="mce-root">Now, let's handle this for Android as well. We start by taking our standard 48 height fader graphic and copying it into app/App_Resources/Android/drawable-hdpi folder. We can then create appropriate resolutions of this graphic and copy into the various resolution dependent folders. The one thing to keep in mind with Android is it does <em class="calibre21"><strong class="calibre1">not</strong></em> use the "@3x" suffix identifiers like iOS does so we just name all of these "fader.png". Here's a view of our graphic in one of the resolution dependent (in this case <strong class="calibre1">hdpi</strong> which handles "high density" screen resolutions) folders:</p>
<div class="mce-root1"><img class="image-border35" src="../images/00045.jpeg"/></div>
<p class="mce-root">We can now customize our Android slider directive with thumb image handling, open <kbd class="calibre11">app/modules/player/directives/slider.directive.android.ts</kbd>:</p>
<pre class="calibre22">import { Directive, ElementRef, <strong class="calibre1">Input</strong> } from '@angular/core';<br class="title-page-name"/><strong class="calibre1">import { fromResource } from 'image-source';</strong><br class="title-page-name"/><strong class="calibre1">import { getNativeApplication } from 'application';</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">let application: android.app.Application;</strong><br class="title-page-name"/><strong class="calibre1">let resources: android.content.res.Resources;</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">const getApplication = function () {</strong><br class="title-page-name"/><strong class="calibre1">  if (!application) {</strong><br class="title-page-name"/><strong class="calibre1">    application = (&lt;android.app.Application&gt;getNativeApplication());</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><strong class="calibre1">  return application;</strong><br class="title-page-name"/><strong class="calibre1">}</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">const getResources = function () {</strong><br class="title-page-name"/><strong class="calibre1">  if (!resources) {</strong><br class="title-page-name"/><strong class="calibre1">    resources = getApplication().getResources();</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><strong class="calibre1">  return resources;</strong><br class="title-page-name"/><strong class="calibre1">}</strong><br class="title-page-name"/><br class="title-page-name"/>@Directive({<br class="title-page-name"/> selector: '[slim-slider]'<br class="title-page-name"/>})<br class="title-page-name"/>export class SlimSliderDirective {<br class="title-page-name"/>  <strong class="calibre1">@Input('slim-slider') imageName: string;</strong><br class="title-page-name"/><strong class="calibre1">  private _thumb: android.graphics.drawable.BitmapDrawable;</strong><br class="title-page-name"/><br class="title-page-name"/>  constructor(private el: ElementRef) { <br class="title-page-name"/>    <strong class="calibre1">el.nativeElement[(&lt;any&gt;slider).colorProperty.setNative] = function (v) {</strong><br class="title-page-name"/><strong class="calibre1">      </strong>// ignore the NativeScript default color setter of this slider<br class="title-page-name"/><strong class="calibre1">    };</strong><br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  ngAfterViewInit() {<br class="title-page-name"/>    let seekBar = &lt;android.widget.SeekBar&gt;this.el.nativeElement.android;<br class="title-page-name"/>    <strong class="calibre1">if (this.imageName) {</strong><br class="title-page-name"/><strong class="calibre1">      if (!seekBar) {</strong><br class="title-page-name"/>        // part of view toggle - grab on next tick<br class="title-page-name"/>        // this helps ensure the seekBar instance can be accessed properly<br class="title-page-name"/>        // since this may fire amidst the view toggle switching on our tracks<br class="title-page-name"/>        <strong class="calibre1">setTimeout(() =&gt; {</strong><br class="title-page-name"/><strong class="calibre1">          seekBar = &lt;android.widget.SeekBar&gt;this.el.nativeElement.android;</strong><br class="title-page-name"/><strong class="calibre1">          this._addThumbImg(seekBar);</strong><br class="title-page-name"/><strong class="calibre1">        });</strong><br class="title-page-name"/><strong class="calibre1">      } else {</strong><br class="title-page-name"/><strong class="calibre1">        this._addThumbImg(seekBar);</strong><br class="title-page-name"/><strong class="calibre1">      }</strong><br class="title-page-name"/>    } else {<br class="title-page-name"/>      // seekBar.setEnabled(false);<br class="title-page-name"/>      seekBar.setOnTouchListener(new android.view.View.OnTouchListener({<br class="title-page-name"/>        onTouch(view, event) {<br class="title-page-name"/>          return true;<br class="title-page-name"/>        }<br class="title-page-name"/>      }));<br class="title-page-name"/>      seekBar.getThumb().mutate().setAlpha(0);<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">private _addThumbImg(seekBar: android.widget.SeekBar) {</strong><br class="title-page-name"/><strong class="calibre1">    if (!this._thumb) {</strong><br class="title-page-name"/><strong class="calibre1">      let imgParts = this.imageName.split('.');</strong><br class="title-page-name"/><strong class="calibre1">      let name = imgParts[0];</strong><br class="title-page-name"/><strong class="calibre1">      const res = getResources();</strong><br class="title-page-name"/><strong class="calibre1">      if (res) {</strong><br class="title-page-name"/><strong class="calibre1">        const identifier: number = res.getIdentifier(</strong><br class="title-page-name"/><strong class="calibre1">          name, 'drawable',  getApplication().getPackageName());</strong><br class="title-page-name"/><strong class="calibre1">        if (0 &lt; identifier) {</strong><br class="title-page-name"/>          // Load BitmapDrawable with getDrawable to make use of Android internal caching<br class="title-page-name"/><strong class="calibre1">          this._thumb = &lt;android.graphics.drawable.BitmapDrawable&gt;res.getDrawable(identifier);</strong><br class="title-page-name"/><strong class="calibre1">        }</strong><br class="title-page-name"/><strong class="calibre1">      }</strong><br class="title-page-name"/><strong class="calibre1">    }</strong><br class="title-page-name"/>    <strong class="calibre1">if (this._thumb) {</strong><br class="title-page-name"/><strong class="calibre1">      seekBar.setThumb(this._thumb);</strong><br class="title-page-name"/><strong class="calibre1">      seekBar.getThumb().clearColorFilter();</strong><br class="title-page-name"/><strong class="calibre1">      if (android.os.Build.VERSION.SDK_INT &gt;= 21) {</strong><br class="title-page-name"/><strong class="calibre1">        (&lt;any&gt;seekBar).setSplitTrack(false);</strong><br class="title-page-name"/><strong class="calibre1">      }</strong><br class="title-page-name"/><strong class="calibre1">    }</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/>}</pre>
<p class="mce-root">One of the most unusual and perhaps surprising aspects of the Android implementation above is this:</p>
<pre class="calibre22">constructor(private el: ElementRef) { <br class="title-page-name"/>  el.nativeElement[(&lt;any&gt;slider).colorProperty.setNative] = function (v) {<br class="title-page-name"/>    // ignore the NativeScript color setter of the slider<br class="title-page-name"/>  };<br class="title-page-name"/>}</pre>
<p class="mce-root">Normally you can reuse and extend controls in NativeScript quite easily. However, this is one of those exception cases where the default NativeScript setter on the slider control is actually going to cause us problems <strong class="calibre1">only on Android</strong>. The default setter will attempt to set the color of the thumb to blue along with a method to blend it. When it sets this flag on the slider, any graphic shape we then set gets the shape set to all blue. So for our version of the slider class to handle a custom graphic we have to eliminate the default slider thumb color setter on the control. We take control of this by attaching a new "color" setter that does absolutely nothing. This way when the NativeScript framework tries to setup the default color while initializing or resetting the control, nothing will happen allowing us to completely control what happens. As a precaution at the end of the <kbd class="calibre11">_addThumbImg</kbd> method we also call <kbd class="calibre11">seekBar.getThumb().clearColorFilter();</kbd> for good measure to make sure any potential sets to the colorFilter are undone before we were able to silence the default color setter.</p>
<p class="mce-root">Lastly we can customize the colors used in the audio w<span>aveform shown for each track when our track listing view is toggled to mixer mode. Since the waveform plugin for Android utilizes the color resources of the app, we can add the proper named attributes found in the plugin's documentation in app/App_Resources/Android/values/colors.xml and the same colors should also be copied into app/App_Resources/Android/values-v21/colors.xml:</span></p>
<div class="mce-root1"><img class="image-border36" src="../images/00046.jpeg"/></div>
<p class="mce-root">This now gives us a custom style for Android's file waveform display in mixing mode:</p>
<div class="mce-root1"><img class="image-border37" src="../images/00047.jpeg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="mce-root">We wanted to provide some extra goodies to go along with all the rich content you've been learning about throughout Part 3; we hope that you enjoyed it! Using multiple item row templates with <kbd class="calibre11">ListView</kbd> can be handy in many situations, but hopefully, this will give you the tools to know how to make it work for you and your app.</p>
<p class="mce-root">Special considerations with data persistence is an important factor to any engaging app, so we looked at serializing data before storing and hydrating the data when restoring it out of a persisted state.</p>
<p class="mce-root">Lastly, we looked at further enriching our view components with more Angular directive goodness. With Part 3 completed, we have now completed the core competency and feature set of our app for the book. However, we are far from done with the app. The development workflow and process presented in this book are the typical development cycle we bring to any app we build. We will cover improving our architecture and further polishing our app to prepare for a public release via Google Play and App Store in <a href="part0154.html#4IRMK0-289fe2426d594f99a90e4363b2c9c34d" class="calibre3">Chapter 14</a>, <em class="calibre21">Deployment Preparation with webpack Bundling</em>.</p>
<p class="mce-root">Let's now move on to improving the state handling of our app with <kbd class="calibre11">ngrx</kbd> integration in <a href="part0121.html#3JCK20-289fe2426d594f99a90e4363b2c9c34d" class="calibre3">Chapter 10</a>, <em class="calibre21">@ngrx/store + @ngrx/effects for State Management</em>. It's worth mentioning that using a Redux style architecture is a decision better made <em class="calibre21">before</em> building out your app as we have done here. However, it's not necessarily critical nor is it mandatory, therefore, we wanted to build the app excluding it to show that the app fundamentally works just fine. Now, we will move on to working it in to show off the various advantages you can gain with it.</p>
<p class="mce-root"> </p>
<p class="mce-root"> </p>


            </article>

            
        </section>
    </body></html>