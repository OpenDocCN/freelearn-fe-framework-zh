- en: '*Chapter 7*: Using UI Frameworks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how Next.js can improve our productivity by
    giving us many valid alternatives for writing CSS without the need to install
    and configure many different external packages.
  prefs: []
  type: TYPE_NORMAL
- en: Still, there are cases where we may want to use pre-built UI libraries to take
    advantage of their components, themes, and built-in features so that we don't
    have to build them from scratch and to take advantage of a vast community that
    can help us when any problem occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discover some modern UI libraries and learn how to
    integrate them properly in any Next.js application. We will look at the following
    in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: What UI libraries are and why we might need them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to integrate **Chakra UI**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to integrate **TailwindCSS**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use **Headless UI** components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to integrate any UI library by following
    the tips and principles that we'll see in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To run the code examples in this chapter, you need to have both Node.js and
    npm installed on your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer, you can use an online IDE such as [https://repl.it](https://repl.it)
    or [https://codesandbox.io](https://codesandbox.io); they both support Next.js,
    and you don''t need to install any dependency on your computer. As for the other
    chapters, you can find the code base for this chapter on GitHub: https://github.com/PacktPublishing/Real-World-Next.js.'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to UI libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UI libraries, frameworks, and utilities are not essential. We could build any
    user interface (despite its complexity) from scratch using vanilla JavaScript,
    HTML, and CSS. Still, we would often find ourselves using the same patterns, accessibility
    rules, optimizations, and utility functions on every user interface we build.
    So here comes the concept of a UI library.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to abstract our most common use cases, reuse most of the code on
    different user interfaces, improve our productivity, and use well-known, tested,
    and **themeable** UI components.
  prefs: []
  type: TYPE_NORMAL
- en: With "themeable," we refer to those libraries and components that allow us to
    customize the color scheme, spacing, and the whole design language of a given
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: We could take the popular *Bootstrap* library as an example. It allows us to
    override its default variables (such as colors, fonts, mixins, and so on) to customize
    the default theme. Thanks to that feature, we could potentially use Bootstrap
    on dozens of different UIs, with each UI having a very different look and feel.
  prefs: []
  type: TYPE_NORMAL
- en: While Bootstrap is still a good, tested, and well-known library, we will concentrate
    on more modern alternatives in the following sections. Each option will take a
    different approach, allowing you to understand what to look for when choosing
    a UI library.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Chakra UI in Next.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chakra UI is an open source component library used for building modular, accessible,
    and good-looking user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its main strengths are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Accessibility*: Chakra UI allows us to use pre-built components (such as buttons,
    modals, inputs, and many more) created by the Chakra UI team with extra attention
    to accessibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Themeable*: The library ships with a default theme, where (for instance) buttons
    have a particular default background color, border radius, padding, and so on.
    We can always customize the default theme using Chakra UI built-in functions for
    editing every style of the library components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Light and dark mode*: They''re both supported out of the box and can rely
    on the user''s system settings. If users set their computer to use dark mode by
    default, Chakra UI will load the dark theme as soon as it loads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Composability*: We can create more and more components starting from the Chakra
    UI ones. The library will give us the building blocks for creating custom components
    with ease.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TypeScript support*: Chakra UI is written in TypeScript and provides first-class
    types for a beautiful developer experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To see how to integrate Chakra UI into a Next.js application, we will be building
    a simple company employee directory using static Markdown documents as pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s start by creating a new Next.js project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to install Chakra UI and its dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re now ready to integrate Chakra UI with Next.js. To do that, let''s open
    the `pages/_app.js` file and wrap the default `<Component />` component in the
    Chakra provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `ChakraProvider`, we can also pass a `theme` prop containing an object
    representing the themes overrides. In fact, we can overwrite the default Chakra
    UI theme by using our custom colors, fonts, spacing, and so on, by using the built-in
    `extendTheme` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now open the `pages/index.js` file and add some Chakra UI components
    using our custom colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Opening the page in a web browser, we will see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Chakra UI buttons with custom theme colors'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.01_B16985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Chakra UI buttons with custom theme colors
  prefs: []
  type: TYPE_NORMAL
- en: You can feel free to add your custom styles to that Chakra UI installation before
    moving any further with the chapter so that the result will reflect your taste!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more about custom property names, I suggest you read the
    official guide before proceeding: https://chakra-ui.com/docs/theming/customize-theme.'
  prefs: []
  type: TYPE_NORMAL
- en: One thing we've already talked about but haven't seen yet is the built-in dark/light
    mode support provided by Chakra UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The library uses the light mode by default, but we can modify this behavior
    by opening the `pages/_document.js` file and adding the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `ColorModeScript` component will inject a script allowing our application
    to run in light/dark mode depending on the user's preference. Given the preceding
    configuration, we will adopt the user system's preference for rendering the components.
    For example, suppose the user has set their operating system to run in dark mode.
    In that case, our website will render the components in dark mode by default,
    and vice versa, it will render the components in light mode if the user sets their
    operating system to that preference.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test that the script is working correctly by opening the `pages/index.js`
    file and replacing its content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to Chakra UI's `useColorMode` hook, we always know what color mode is
    being used and can render specific components (or changing colors) depending on
    that value. Also, Chakra UI will remember the user's decision, so if they set
    the color mode to dark, they will find the same color mode applied to the web
    page once they come back to the website.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now open our website''s home page, we will be able to change its color
    mode. The result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Chakra UI color mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.02_B16985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – Chakra UI color mode
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have taken our first steps with Chakra UI and Next.js, we're finally
    ready to start developing an employee directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The website will be pretty simple: it will only have a home page listing all
    the employees of a fictional company that we''ll call *ACME Corporation* and a
    single page for every single user.'
  prefs: []
  type: TYPE_NORMAL
- en: On every page, we will have a button for switching from dark to light mode and
    vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Building an employee directory with Chakra UI and Next.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can reuse the project we already set up in the introduction section for Chakra
    UI and Next.js to build our employee directory. Still, we will need to make some
    minor changes to the code we have already written.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have any doubts, you can see the complete website example on GitHub:
    https://github.com/PacktPublishing/Real-World-Next.js/tree/main/07-using-ui-frameworks/with-chakra-ui.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we will need the employee data. You can find a complete employee
    list (generated with fake data) at this URL: [https://github.com/PacktPublishing/Real-World-Next.js/blob/main/07-using-ui-frameworks/with-chakra-ui/data/users.js](https://github.com/PacktPublishing/Real-World-Next.js/blob/main/07-using-ui-frameworks/with-chakra-ui/data/users.js).
    If you prefer, you can write custom employee data by creating an array of objects,
    where each object must have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`first_name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`last_name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`job_title`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`avatar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cover_image`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now create a new directory called `/data` and a JavaScript file called `users.js`,
    where we''ll place our employee data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can leave the `pages/_document.js` file untouched from the introduction section.
    This way, we will have access to the dark/light theme switch for our website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going to the `pages/_app.js` page, we can modify its content by including a
    new `TopBar` component (which we will create in just a moment) and removing the
    custom theme, as we don''t need it for the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the previous code block, we've wrapped our `<Component />`
    component in a Chakra UI `Box` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `<Box>` acts as an empty `<div>`, and like any other Chakra UI
    component, it accepts any CSS directive as a prop. In this case, we''re using
    `margin="auto"` (which translates to `margin: auto`) and `maxWidth="container.xl"`,
    which translates to `max-width: var(--chakra-sizes-container-xl)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file, `/components/TopBar/index.js`, and create the `TopBar`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This component is not different from the one we already created in the previous
    section; every time the user clicks on the button, it will toggle dark/light mode
    using the Chakra UI built-in `toggleColorMode` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now create one more component inside a new `components/UserCard/index.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we're wrapping the whole component inside a Next.js `<Link>`
    component, passing the `href` value to an `<a>` child element.
  prefs: []
  type: TYPE_NORMAL
- en: We're then using the vertical stack (`VStack`) component, which uses *flexbox*
    under the hood, to help us to arrange the child elements vertically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the selected color theme, we may want different background colors
    for our user card. We can achieve that by using the Chakra UI built-in `useColorModeValue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first value (`'gray.50'`) will be applied by Chakra UI when the user selects
    the light theme. When the dark theme is selected, the UI library will use the
    second value (`'gray.700'`) instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now pass the right props to our `<UserCard>` component, we will see something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – The UserCard component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.03_B16985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – The UserCard component
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re finally ready to render the employee list on our home page! Let''s head
    to our `pages/index.js` file, import the employee list, and display them using
    the newly created `UserCard` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'On this page, we can spot another nice Chakra UI feature: responsive props.
    We''re using the `<Grid>` component to build a grid template for our users'' cards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Every Chakra UI prop can accept an array of values as input. In the preceding
    example, the UI library will render `'1fr'` on mobile screens, `'repeat(2, 1fr)'`
    on medium screens (for example, a tablet), and `'repeat(3, 1fr)'` on larger screens
    (desktop).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can finally run the development server and see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Employee directory home page in light mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.04_B16985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Employee directory home page in light mode
  prefs: []
  type: TYPE_NORMAL
- en: 'In my case, I had the system preference set to `TopBar` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Employee directory home page in dark mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.05_B16985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – Employee directory home page in dark mode
  prefs: []
  type: TYPE_NORMAL
- en: We now only need to create a single employee page.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a new file called `pages/users/[username].js`; here, we'll use
    the Next.js built-in methods to statically render each page at build time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start by importing the `users.js` file and create all the static paths
    using the Next.js `getStaticPaths` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With the `getStaticPaths` function, we're telling Next.js that we need to render
    a new page for each user found in the users' array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re also telling Next.js to display a 404 page if the requested path hasn''t
    been generated at build time; we do that by using the `fallback: false` property.'
  prefs: []
  type: TYPE_NORMAL
- en: If set to `true`, that property tells Next.js to try to render a page on the
    server side if it hasn't been rendered at build time. That's because we may want
    to get the pages from a database or external API, and we don't want to rebuild
    the whole website every time we create a new page. So, when we set `fallback`
    to `true`, Next.js will rerun the `getStaticProps` function on the server side,
    render the page, and serve it as a static page.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we don't need this feature as we're taking our data from a static
    JavaScript file, but we'll use the feature in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on by writing the `getStaticProps` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With that function, we're querying the specific user that we want to display
    on the page by filtering the users' array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to writing the page content, let''s import the required Chakra
    UI and Next.js dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can finally write our `UserPage` component. We will be wrapping everything
    inside a Chakra UI `<Center>` component, which uses flexbox under the hood to
    center all the child elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll then use other Chakra UI built-in components such as `<Image>`, `<Flex>`,
    `<Avatar>`, `<Text>`, and so on, to create our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can notice other great Chakra UI features, such as the `as` prop used in
    the `Back to all users` button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're telling Chakra UI to render the `Button` component as an `<a>` HTML
    element. That way, we can use the `passHref` prop in its parent Next.js `Link`
    component to pass its `href` value to the button, making a more accessible UI;
    in doing so, we will create an actual `<a>` element with a proper `href` property
    attached to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run the development server and test the final result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Single employee in light mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.06_B16985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – Single employee in light mode
  prefs: []
  type: TYPE_NORMAL
- en: 'By clicking on the **Toggle theme** button, we can also access the dark version
    of our user interface, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Single employee in dark mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.07_B16985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – Single employee in dark mode
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also used responsive styles, so we can test our UI by resizing the
    browser page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 7.8 – Single employee page (mobile view)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.08_B16985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Image 7.8 – Single employee page (mobile view)
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, implementing a responsive user interface with Chakra UI's built-in
    components was straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to dig deeper into all the existing components, hooks, and utilities,
    you can learn more at [https://chakra-ui.com](https://chakra-ui.com).
  prefs: []
  type: TYPE_NORMAL
- en: Conclusive words about Chakra UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chakra UI is a great modern UI library, and I personally use it on many of the
    projects I work on. It's open source and free to use, with a great community that
    works every day to optimize it and make it even more accessible, performant, and
    complete.
  prefs: []
  type: TYPE_NORMAL
- en: It also provides a premium set of pre-made UI components built by the Chakra
    UI core team. If you're interested, you can look at them at [https://pro.chakra-ui.com/components](https://pro.chakra-ui.com/components).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we will change our focus to another popular yet completely
    different UI library: TailwindCSS.'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating TailwindCSS in Next.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**TailwindCSS** is a utility-first CSS framework that allows you to build any
    user interface using pre-made CSS classes that map CSS rules in a straightforward
    way.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Chakra UI, Material UI, and many other UI frameworks, it just provides
    CSS rules; the framework gives no JavaScript scripts or React components, so we'll
    need to write them by ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its main strengths are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Framework agnostic*: You can use TailwindCSS in React, Vue, Angular, and even
    in plain HTML and JavaScript. It''s just a set of CSS rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Themeable*: Just like Chakra UI, you can customize all the TailwindCSS variables
    to make them match your design tokens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dark and light theme support*: You can easily enable or disable the dark theme
    by modifying a specific CSS class from the `<html>` element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Highly optimized*: TailwindCSS is formed of many CSS classes, but it''s able
    to prune the unused ones at build time, reducing the final bundle size, as unused
    CSS classes get removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mobile-ready*: You can use specific CSS classes'' prefixes to apply certain
    rules to mobile, desktop, or tablet screens only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will see how to integrate, customize, and optimize TailwindCSS
    in Next.js by rebuilding the same project we did in the last section. That way,
    the differences between Chakra UI and TailwindCSS will be even more evident.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new project and install all the required dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'TailwindCSS only requires three `devDependencies`, so let''s enter the newly
    created project and install them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''ve already seen, TailwindCSS doesn''t ship with any JavaScript utility,
    so, unlike Chakra UI, we will need to manage the dark/light theme switch ourselves.
    However, we can take advantage of the `next-themes` library to help us manage
    the themes, so let''s install that package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have all the dependencies installed, we need to set up the basic
    TailwindCSS configuration files. We can do that by using the `tailwindcss init`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create two different files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tailwind.config.js`: This file will help us configure the TailwindCSS theme,
    unused CSS purge, dark mode, plugins, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postcss.config.js`: `postcss.config.js` that we can always edit as we prefer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First of all, we want to configure TailwindCSS to remove unused CSS from the
    final build. We can do that by opening the `tailwind.config.js` file and editing
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we're telling TailwindCSS to check every file ending with `.js`
    or `.jsx` inside both `pages/` and `components/` directories and remove all the
    CSS classes that are not used inside of any of those files.
  prefs: []
  type: TYPE_NORMAL
- en: We also set the `darkMode` property to `'class'`. That way, the framework will
    look at the `<html>` class element to determine whether we need to render the
    components using dark or light mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now only need to include the default `tailwind.css` CSS file on every single
    page of our application, and we''re ready to start. We can do that by importing
    `''tailwindcss/tailwind.css''` inside our `pages/_app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now start to include specific TailwindCSS classes. Keeping the `pages/_app.js`
    file open in our code editor, we can begin by importing `ThemeProvider` from the
    `next-themes` package, which will help us manage the dark/light theme switch,
    and wrap every other component inside of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we're following the same steps we did with Chakra UI. We're
    importing the `TopBar` component (which will be common to all the pages on our
    website) and wrapping the Next.js `<Component />` component inside a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll see how to write the `TopBar` component in just a moment; for now, let''s
    concentrate on the `<div>` that is wrapping the `<Component />` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We used four different CSS classes; let''s break them down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dark:bg-gray-900`: When the theme is set to dark mode, the background color
    for this `<div>` will be set to `bg-gray-900`, a TailwindCSS variable that maps
    to the `#111927` HEX color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bg-gray-50`: By default (so in light mode), the background color for this
    div will be set to `bg-gray-50`, which maps to the `#f9fafb` HEX color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w-full`: This means "full width," so the `<div>` will have the `width` property
    set to `100%`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min-h-screen`: This CSS class stands for *set the min-height property to the
    whole screen height*, shorthand for `min-height: 100vh`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can now create a new `/components/TopBar/index.js` file and add the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're creating the full-width horizontal green bar (`className="w-full
    p-2 bg-green-500"`) with 0.5rem of padding (`p-2` class) and `#12b981` as the
    background color (`bg-green-500`).
  prefs: []
  type: TYPE_NORMAL
- en: Inside that `<div>`, we're placing another centered `<div>` with 75% width (`w-10/12`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re then importing the `ThemeSwitch` button, which still needs to be created.
    Let''s do that by creating a new file under `components/ThemeSwitch/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This component is pretty straightforward; we use the `useTheme` hook packed
    with the `next-themes` library and change the theme value to `light` or `dark`,
    depending on the current set theme.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to notice is that we're doing that on the client side only (by writing
    `typeof window === 'undefined'`). In fact, this hook adds a `theme` entry in the
    browser's `localStorage`, which of course, is not accessible on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: For that reason, the `ThemeSwitch` component will be rendered on the client
    side only.
  prefs: []
  type: TYPE_NORMAL
- en: Talking about the `<button>` CSS classes, we can see that we're building a rounded
    button with a green background. The green tonality, by the way, will be different
    depending on the currently selected theme.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s write the `UserCard` component. Create a new file under `components/UserCard/index.js`
    and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Except for the CSS class names, this component is not that different from the
    Chakra UI one.
  prefs: []
  type: TYPE_NORMAL
- en: Image Optimizations
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we're not currently optimizing the images, and we're serving
    them using the default `<img />` HTML element. Unfortunately, that can make our
    website slower and lead to a lousy SEO score.
  prefs: []
  type: TYPE_NORMAL
- en: Try to configure automatic image optimization and serve them using the Next.js
    `<Image />` component!
  prefs: []
  type: TYPE_NORMAL
- en: Can't remember how to do it? You can go over [*Chapter 3*](B16985_03_Final_SB_epub.xhtml#_idTextAnchor038),
    *Next.js Basics and Built-In Components*.
  prefs: []
  type: TYPE_NORMAL
- en: We're now ready to write the home page for our ACME employee directory. First,
    make sure to have the same `users.js` file we used in the previous section positioned
    under `data/users.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to download it again, you can do it by copying the content from
    here: [https://github.com/PacktPublishing/Real-World-Next.js/blob/main/07-using-ui-frameworks/with-tailwindcss/data/users.js](https://github.com/PacktPublishing/Real-World-Next.js/blob/main/07-using-ui-frameworks/with-tailwindcss/data/users.js).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can open the `pages/index.js` file, import both the `users.js` file
    and the `UserCard` component, then put everything together to create a user grid
    as we did with Chakra UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, here we''re starting to use some responsive directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `sm:` prefix is used to apply a specific rule when the window width is greater
    than or equal to `640px`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, TailwindCSS classes are mobile-first, and if we want to apply a
    specific class to wider screens, we will need to prefix those classes with one
    of the following prefixes: `sm:` (`640px`), `md:` (`768px`), `lg:` (`1024px`),
    `xl:` (`1280px`), or `2xl:` (`1536px`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run the development server and head to the home page. We will see
    the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Employee directory built with TailwindCSS (light theme)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.09_B16985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.9 – Employee directory built with TailwindCSS (light theme)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also switch the theme to **dark** by clicking on the button on the green
    bar at the top of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Employee directory built with TailwindCSS (dark theme)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.10_B16985.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.10 – Employee directory built with TailwindCSS (dark theme)
  prefs: []
  type: TYPE_NORMAL
- en: If you compare the visual results of the Chakra UI implementation and the TailwindCSS
    one, you will see how similar they look!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s complete our website by creating the single-user page. If you haven''t
    already, create a new page called `pages/user/[username].js`, and start by importing
    the required dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now write the `getStaticPaths` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s write the `getStaticProps` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that those functions are the same as we wrote in the Chakra
    UI section. In fact, with this implementation, we only change the way we render
    the page content; all the server-side data fetching and manipulation will remain
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re finally ready to write the single-user page component. Here, we will
    be creating a similar structure to the one we wrote with Chakra UI, but of course,
    using TailwindCSS classes and standard HTML elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: And we're done! We've rewritten our entire application by using TailwindCSS.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the original TailwindCSS stylesheet size is around 4.7
    MB. After building the website for production by just running `yarn build`, the
    final TailwindCSS file will be about 6 KB.
  prefs: []
  type: TYPE_NORMAL
- en: You can quickly test this by commenting on the `purge` property inside of the
    `tailwind.config.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've seen two different (yet very modern) approaches to styling a web
    application, and they both have their pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: While they share some ideas about how to write styles for any website, Chakra
    UI has the advantage of providing pre-built React components, which can come in
    handy when you want to integrate the library in your Next.js/React application
    and make it more dynamic with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, the TailwindCSS team came up with the innovative idea of providing
    a dynamic interface to TailwindCSS (and possibly any other UI framework): Headless
    UI.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at Headless UI and how it can make things
    easier for us when building modern, performant, and optimized web applications
    with Next.js.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Headless UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous section, TailwindCSS only provides CSS classes to
    be used inside any web component.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to implement something dynamic, such as a modal, a switch button,
    and so on, we need to write some JavaScript logic on our own.
  prefs: []
  type: TYPE_NORMAL
- en: '**Headless UI** solves this problem by providing the opposite of TailwindCSS:
    dynamic components without any CSS class or style. That way, we''re free to use
    TailwindCSS or any other CSS framework to style pre-built components in a straightforward
    way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Headless UI is a free and open source project created by the *Tailwind Labs*
    team (the same organization behind TailwindCSS), and if you''re interested, you
    can browse the source code at the following URL: [https://github.com/tailwindlabs/headlessui](https://github.com/tailwindlabs/headlessui).'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Headless UI and TailwindCSS is not very different from integrating
    TailwindCSS alone. We can set up a new project and install all the TailwindCSS
    dependencies just like we did in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we can install Headless UI itself. We will also install `classnames`,
    a simple and widely used utility that will help us create dynamic CSS class names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We will now develop a simple menu component by using Headless UI and TailwindCSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go to the `pages/index.js` file and import Headless UI, `classnames`,
    and Next.js'' `Link` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the same page, let''s create an array of menu elements. We will
    be using them to populate the menu with mocked data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now destructure the Headless UI `Menu` component and take all the components
    we need to build our menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Every menu entry will be wrapped inside an `Item` component. Given that every
    menu entry will behave the same way, we can create a generic `MenuEntry` component
    and apply it to our array of entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Headless UI will pass an `active` state to all the elements
    inside of `Item`. We will use that state to show the user which element of the
    menu is currently active.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now only need to wrap everything together inside the `Menu` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If we now launch the development server, we will see an utterly unstyled button
    at the top right of our screen. We can click on this button to reveal – and then
    hide – its content.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now proceed to style our menu, beginning with the `MenuEntry` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving on to the main component, we can simply add the CSS classes required
    for styling `Button` and `Item` components. We want the menu button to be purple
    with white text, and the drop-down menu to have rounded corners with a nice box
    shadow, so let''s add the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also apply a transition to our menu, making the reveal/hide part smoother.
    We just need to import the `Transition` component from Headless UI and wrap the
    menu items inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We just styled our first headless component with TailwindCSS, but we can use
    our own CSS rules or any other CSS framework!
  prefs: []
  type: TYPE_NORMAL
- en: Just like Chakra UI, TailwindCSS provides a series of premium components, and
    many of those components rely on Headless UI for managing their interactions.
    If you're interested in that, you can learn more at [https://tailwindui.com](https://tailwindui.com).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen three different and modern approaches for building
    user interfaces with Next.js, React, and even plain HTML.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapters, where we will be working on real-world web applications,
    we will be using the lessons learned in these sections to speed up the UI development,
    always keeping an eye on performance, accessibility, and developer experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re interested in learning more about the differences between Chakra
    UI and TailwindCSS specifically, you can read the official guide on the Chakra
    UI website: https://chakra-ui.com/docs/comparison.'
  prefs: []
  type: TYPE_NORMAL
- en: Both libraries provide excellent support for implementing beautiful user interfaces,
    and even though they share some features, they are quite different in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Chakra UI exposes a fantastic set of components, but they are only available
    for React and Vue. What if your project uses Angular or Svelte?
  prefs: []
  type: TYPE_NORMAL
- en: 'TailwindCSS, on the other hand, is 100% framework-agnostic: you can use it
    for writing the frontend of any web application independently of the technology
    you''re using.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In my opinion, there is no clear winner: choosing either of these libraries
    is entirely up to personal taste.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will change our focus to the backend of our applications,
    learning how to dynamically serve a Next.js web application from a custom Node.js
    server.
  prefs: []
  type: TYPE_NORMAL
