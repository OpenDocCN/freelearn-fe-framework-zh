- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Implementing User Authentication and Global Notifications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现用户认证和全局通知
- en: In the previous chapters, we configured the pages, created mocked APIs, and
    made the API calls from our application. However, the application still relies
    on test data when it comes to the authentication of the users in the admin dashboard.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们配置了页面，创建了模拟API，并从我们的应用程序中进行了API调用。然而，当涉及到管理仪表板中用户的认证时，应用程序仍然依赖于测试数据。
- en: In this chapter, we will build the application’s authentication system, allowing
    users to authenticate and access protected resources in the admin dashboard. We
    will also be creating a toast notification system to provide feedback to users
    if an action happens that we want to notify them about.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建应用程序的认证系统，允许用户在管理仪表板中认证并访问受保护资源。我们还将创建一个吐司通知系统，以便在发生我们希望通知用户的行为时向用户提供反馈。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Implementing the authentication system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现认证系统
- en: Implementing notifications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现通知
- en: By the end of the chapter, we will have learned how to authenticate users in
    our application and also how to handle the global application state with Zustand.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将学会如何在我们的应用程序中认证用户，以及如何使用Zustand处理全局应用程序状态。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we get started, we need to set up the project. To be able to develop
    the project, you will need the following things installed on your computer:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要设置项目。为了能够开发项目，你需要在你的计算机上安装以下内容：
- en: '**Node.js** version 16 or above and **npm** version 8 or above.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js**版本16或以上以及**npm**版本8或以上。'
- en: 'There are multiple ways to install Node.js and npm. Here is a great article
    that goes into more detail: [https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js](https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Node.js和npm有多种方法。这里有一篇很好的文章，详细介绍了更多细节：[https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js](https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js)。
- en: '**VSCode** (optional) is currently the most popular editor/IDE for JavaScript/TypeScript,
    so we will be using it. It is open source, has great integration with TypeScript,
    and you can extend its features via extensions. It can be downloaded from here:
    [https://code.visualstudio.com/](https://code.visualstudio.com/).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VSCode**（可选）是目前最流行的JavaScript/TypeScript编辑器/IDE，因此我们将使用它。它是开源的，与TypeScript有很好的集成，并且你可以通过扩展来扩展其功能。可以从这里下载：[https://code.visualstudio.com/](https://code.visualstudio.com/)。'
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/React-Application-Architecture-for-Production](https://github.com/PacktPublishing/React-Application-Architecture-for-Production).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在此处找到：[https://github.com/PacktPublishing/React-Application-Architecture-for-Production](https://github.com/PacktPublishing/React-Application-Architecture-for-Production)。
- en: 'The repository can be cloned locally with the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令在本地克隆存储库：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the repository is cloned, we need to install the application’s dependencies:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦克隆了存储库，我们需要安装应用程序的依赖项：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can provide the environment variables using the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令提供环境变量：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the dependencies have been installed, we need to select the right stage
    of the code base that matches this chapter. We can do that by executing the following
    command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了依赖项，我们需要选择与本章匹配的正确代码库阶段。我们可以通过执行以下命令来完成：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command will prompt us with a list of stages for each chapter:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将为我们提供每个章节的阶段列表：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is the seventh chapter, so you can select `chapter-07-start` if you want
    to follow along, or `chapter-07` to see the final results of the chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第七章，所以如果你想跟随，可以选择`chapter-07-start`，或者选择`chapter-07`来查看本章的最终结果。
- en: Once the chapter has been selected, all files required to follow along with
    the chapter will appear.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了章节，所有必要的文件将出现，以便跟随本章内容。
- en: For more information about the setup details, check out the `README.md` file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于设置细节的信息，请查看`README.md`文件。
- en: Implementing the authentication system
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现认证系统
- en: Authentication is the process of identifying who the user on a platform is.
    In our application, we need to identify users when they access the admin dashboard.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 认证是识别平台上的用户的过程。在我们的应用程序中，我们需要在用户访问管理仪表板时识别用户。
- en: Before implementing the system, we should look closely at how it will work.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现系统之前，我们应该仔细研究它的工作方式。
- en: Authentication system overview
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证系统概述
- en: We are going to authenticate the users with a token-based authentication system.
    That means the API will expect the user to send their authentication token with
    the request to access protected resources.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用基于令牌的认证系统来认证用户。这意味着API将期望用户在请求中发送他们的认证令牌以访问受保护资源。
- en: 'Let’s take a look at the following diagram and the subsequent steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下图表和后续步骤：
- en: '![Figure 7.1 – Authentication system overview ](img/B17297_07_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 认证系统概述](img/B17297_07_01.jpg)'
- en: Figure 7.1 – Authentication system overview
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 认证系统概述
- en: 'The preceding diagram is explained as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对先前图表的解释：
- en: The user submits the login form with the credentials by creating a request to
    the `/``auth/login` endpoint.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户通过向`/auth/login`端点创建请求来使用凭据提交登录表单。
- en: If the user exists and the credentials are valid, a response with the user data
    returns. In addition to the response data, we are also attaching an `httpOnly`
    cookie, which will be used from this point onward for authenticated requests.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户存在且凭据有效，将返回包含用户数据的响应。除了响应数据外，我们还在附加一个`httpOnly` cookie，从现在起将用于认证请求。
- en: Whenever the user authenticates, we will store the user object from the response
    in react-query’s cache and make it available to the application.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当用户进行认证时，我们将从响应中存储用户对象到react-query的缓存中，并使其对应用程序可用。
- en: Since the authentication is cookie-based with `httpOnly` cookies, we do not
    need to handle the authentication token on the frontend. Any subsequent requests
    will include the token automatically.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于认证是基于`httpOnly` cookie的cookie，我们不需要在前端处理认证令牌。任何后续请求都将自动包含令牌。
- en: Persisting user data on page refreshes will be handled by calling the `/auth/me`
    endpoint, which will fetch the user data and store it in the same react-query
    cache.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面刷新时持久化用户数据将通过调用`/auth/me`端点来处理，该端点将获取用户数据并将其存储在相同的react-query缓存中。
- en: 'To implement this system, we need the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个系统，我们需要以下内容：
- en: Auth features (login, logout, and accessing the authenticated user)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证功能（登录、登出和访问认证用户）
- en: Protect resources that require the user to be authenticated
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护需要用户认证的资源
- en: Building authentication features
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建认证功能
- en: To build the authentication features, we already have the endpoints implemented..
    We created them in [*Chapter 5*](B17297_05.xhtml#_idTextAnchor084), *Mocking the
    API*. Now we need to consume them in our application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建认证功能，我们已经有实现了端点。我们在[*第五章*](B17297_05.xhtml#_idTextAnchor084)，“模拟API”中创建了它们。现在我们需要在我们的应用程序中消费它们。
- en: Logging in
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 登录
- en: To allow users to log in to the dashboard, we’ll require them to enter their
    email and password and submit the form.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许用户登录到仪表板，我们将要求他们输入他们的电子邮件和密码并提交表单。
- en: 'To implement the login feature, we will need to make an API call to the login
    endpoint on the server. Let’s create the `src/features/auth/api/login.ts` file
    and add the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现登录功能，我们需要向服务器上的登录端点发起API调用。让我们创建`src/features/auth/api/login.ts`文件并添加以下内容：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We are defining the API request and the API mutation hook, allowing us to call
    the API from our application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在定义API请求和API突变钩子，允许我们从我们的应用程序中调用API。
- en: Then, we can update the login form to make the API call. Let’s modify `src/features/auth/components/login-form/login-form.tsx`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以更新登录表单以进行API调用。让我们修改`src/features/auth/components/login-form/login-form.tsx`。
- en: 'First, let’s import the `useLogin` hook:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们导入`useLogin`钩子：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, inside the `LoginForm` component body, we want to initialize the login
    mutation and submit it in the submit handler:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`LoginForm`组件体内部，我们希望在提交处理程序中初始化登录突变并提交它：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We should also indicate that the action is being submitted by disabling the
    **Submit** button:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该指出操作正在提交，通过禁用**提交**按钮：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When the form is submitted, it will call the login endpoint, which will authenticate
    the user if the credentials are valid.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单提交时，它将调用登录端点，如果凭据有效，将认证用户。
- en: Logging out
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 登出
- en: 'To implement the logout feature, we need to call the logout endpoint, which
    will clear the auth cookie. Let’s create the `src/features/auth/api/logout.ts`
    file and add the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现登出功能，我们需要调用登出端点，这将清除认证cookie。让我们创建`src/features/auth/api/logout.ts`文件并添加以下内容：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We are defining the logout API request and the logout mutation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在定义登出API请求和登出突变。
- en: 'Then, we can expose that from the auth feature by re-exporting it from the
    `src/features/auth/index.ts` file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过从`src/features/auth/index.ts`文件中重新导出它来从认证功能中公开它：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We want to use it when the user clicks the `src/layouts/dashboard-layout.tsx`
    file and import additional dependencies:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在用户点击`src/layouts/dashboard-layout.tsx`文件并导入额外依赖项时使用它：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, in the `Navbar` component, let’s use the `useLogout` hook:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Navbar`组件中，让我们使用`useLogout`钩子：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice how we redirect the user to the login page when the logout action succeeds.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当注销操作成功时，我们如何将用户重定向到登录页面。
- en: 'Let’s finally wire the action to the logout button:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们最终将操作连接到注销按钮：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, when the user clicks the **Log Out** button, the logout endpoint will be
    called, and then the user will be taken to the login page.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用户点击**注销**按钮时，将调用注销端点，然后用户将被带到登录页面。
- en: Getting an authenticated user
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取经过认证的用户
- en: 'To get started, let’s create the `src/features/auth/api/get-auth-user.ts` file
    and add the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们创建`src/features/auth/api/get-auth-user.ts`文件并添加以下内容：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This endpoint will return information about the user currently logged in.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此端点将返回当前登录用户的信息。
- en: 'Then, we want to export it from the `src/features/auth/index.ts` file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们希望从`src/features/auth/index.ts`文件中导出它：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Back to the `src/layouts/dashboard-layout.tsx` file, we need the user data there.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`src/layouts/dashboard-layout.tsx`文件，我们需要那里的用户数据。
- en: 'Let’s replace the `useUser` hook from the test data with the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用以下内容替换测试数据中的`useUser`钩子：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Another place where we need the user data is the dashboard jobs page. Let’s
    open `src/pages/dashboard/jobs/index.tsx` and import the `useUser` hook:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要用户数据的地方是仪表板工作页面。让我们打开`src/pages/dashboard/jobs/index.tsx`并导入`useUser`钩子：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Protecting resources that require the user to be authenticated
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护需要用户认证的资源
- en: What should happen if an unauthenticated user tries to view a protected resource?
    We want to ensure that any such attempt will redirect the user to the login page.
    To do that, we want to create a component that will wrap protected resources and
    let users view protected content only if they are authenticated.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未经认证的用户尝试查看受保护资源，会发生什么？我们希望确保任何此类尝试都将用户重定向到登录页面。为此，我们希望创建一个组件，该组件将包装受保护资源，并且只有在用户经过认证的情况下才允许用户查看受保护内容。
- en: The `Protected` component will fetch the user from the `/auth/me` endpoint,
    and if the user exists, it will allow the content to be shown. Otherwise, it will
    redirect the user to the login page.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Protected`组件将从`/auth/me`端点获取用户，如果用户存在，它将允许内容显示。否则，它将重定向用户到登录页面。'
- en: 'The component has already been defined in the `src/features/auth/components/protected/protected.tsx`
    file, but it isn’t doing much right now. Let’s modify the file to the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件已在`src/features/auth/components/protected/protected.tsx`文件中定义，但现在并没有做什么。让我们修改该文件如下：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The component accepts children as props, meaning it will wrap nested content
    and decide whether it should be rendered.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件接受子内容作为props，这意味着它将包裹嵌套内容并决定是否应该渲染。
- en: We are accessing the user from the same `useUser` hook. Initially, while the
    data is being fetched, the component renders the `Loading` component. Once the
    data is fetched, we check in `useEffect` to see whether the user exists, and if
    it doesn’t, we will redirect to the login page. Otherwise, we can render children
    as usual.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从相同的`useUser`钩子中访问用户。最初，在数据正在获取时，组件渲染`Loading`组件。一旦数据被获取，我们在`useEffect`中检查用户是否存在，如果不存在，我们将重定向到登录页面。否则，我们可以像往常一样渲染子组件。
- en: The `Protected` component is meant to be used in the dashboard. Since we already
    have a reusable layout for the dashboard, rather than wrapping every page with
    `Protected`, we can do that only once in the dashboard layout.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Protected`组件旨在在仪表板中使用。由于我们已经有了一个可重用的仪表板布局，我们不需要在每一页上包裹`Protected`，我们可以在仪表板布局中只做一次。'
- en: 'Let’s open `src/layouts/dashboard-layout.tsx` and import the `Protected` component:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`src/layouts/dashboard-layout.tsx`并导入`Protected`组件：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, in the JSX of the `DashboardLayout` component, let’s wrap everything
    with `Protected` as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`DashboardLayout`组件的JSX中，让我们将一切包裹在`Protected`中，如下所示：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you try to visit the `http://localhost:3000/dashboard/jobs` page, you will
    be redirected to the login page.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试访问`http://localhost:3000/dashboard/jobs`页面，您将被重定向到登录页面。
- en: 'Go ahead and try to log in with the existing credentials (email: user1@test.com;
    password: password). If everything is successful, you can access the dashboard
    with the data that belongs to the given user organization.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用现有的凭据（电子邮件：user1@test.com；密码：password）进行登录。如果一切顺利，您可以使用属于给定用户组织的数据访问仪表板。
- en: Implementing notifications
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现通知
- en: Whenever something happens in the application, such as a successful form submission
    or a failed API request, we want to notify our users about it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每当应用程序中发生某些事情，例如表单提交成功或API请求失败时，我们希望通知我们的用户。
- en: We will need to create a global store that will keep track of all notifications.
    We want it to be global because we want to show these notifications from anywhere
    in the application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个全局存储库，用于跟踪所有通知。我们希望它是全局的，因为我们希望从应用程序的任何地方显示这些通知。
- en: For handling global states, we will be using Zustand, a state management library
    that is lightweight and very simple to use.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理全局状态，我们将使用Zustand，这是一个轻量级且非常简单的状态管理库。
- en: Creating the store
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建存储库
- en: 'Let’s open the `src/stores/notifications/notifications.ts` file and import
    the dependencies we will use:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`src/stores/notifications/notifications.ts`文件并导入我们将要使用的依赖项：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, let’s declare the notification types for the store:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们声明存储库的通知类型：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The store will keep track of active notifications in an array. To show a notification,
    we need to call the `showNotification` method, and to dismiss it, we will call
    `dismissNotification`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库将跟踪活动通知的数组。要显示通知，我们需要调用`showNotification`方法，要关闭它，我们将调用`dismissNotification`。
- en: 'Let’s create the store:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建存储库：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To create the store, we use `createStore` from `zustand/vanilla` to make it
    more portable and testable. The function provides us with the `set` and `get`
    helpers, which allow us to modify and access the store, respectively.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建存储库，我们使用来自`zustand/vanilla`的`createStore`来使其更便携和可测试。该函数为我们提供了`set`和`get`辅助函数，分别允许我们修改和访问存储库。
- en: 'Since we created the store using the vanilla approach, we need to make it compatible
    with React. We do that by exposing the store with the `useStore` hook provided
    by Zustand as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用纯方法创建了存储库，我们需要使其与React兼容。我们通过以下方式使用Zustand提供的`useStore`钩子来实现这一点：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: And that’s the notification store. As you can see, it is very simple with minimal
    boilerplate.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是通知存储库。如您所见，它非常简单，几乎没有样板代码。
- en: Any time we need to access the store inside React components or hooks, we can
    use the `useNotifications` hook. Alternatively, if we want to access the store
    from a plain JavaScript function outside React, we can use `notificationStore`
    directly.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候我们需要在React组件或钩子内部访问存储库，我们都可以使用`useNotifications`钩子。或者，如果我们想从React之外的纯JavaScript函数中访问存储库，我们可以直接使用`notificationStore`。
- en: Creating the UI
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户界面
- en: Now that we have the notifications store, we need to build a UI to display those
    notifications when active.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了通知存储库，我们需要构建一个UI来在活动时显示这些通知。
- en: 'Let’s open the `src/components/notifications/notifications.tsx` file and import
    the required dependencies:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`src/components/notifications/notifications.tsx`文件并导入所需的依赖项：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, let’s create the `Notifications` component, which will display the notifications:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们创建`Notifications`组件，它将显示通知：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We are accessing the notifications via the `useNotifications` hook, which provides
    us with access to the store.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`useNotifications`钩子访问通知，它为我们提供了对存储库的访问。
- en: 'As you can see, we are mapping through the active notifications. We render
    the `NotificationToast` component for each active notification and pass the notification
    object and the dismiss handler as props. Let’s implement it by describing the
    variants and prop types:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在映射活动通知。我们为每个活动通知渲染`NotificationToast`组件，并将通知对象和关闭处理程序作为属性传递。让我们通过描述变体和属性类型来实现它：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, implement the `NotificationToast` component:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，实现`NotificationToast`组件：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now that we have the notifications store and the UI created, it is time to integrate
    them into the application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了通知存储库和创建的UI，是时候将它们集成到应用程序中了。
- en: Integrating and using notifications
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成和使用通知
- en: 'To integrate notifications into the application, let’s open the `src/providers/app.tsx`
    file and import the `Notifications` component:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要将通知集成到应用程序中，让我们打开`src/providers/app.tsx`文件并导入`Notifications`组件：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, let’s render the component in `AppProvider`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们在`AppProvider`中渲染组件：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Perfect! Now we are ready to start showing some notifications.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在我们准备好开始显示一些通知了。
- en: As mentioned, we can use the store both in the React world and outside it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以在React世界和其外部使用该存储。
- en: We will need to use it in a React component from the page for creating jobs.
    Any time we create a job successfully, we want to let the user know.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在创建作业的页面React组件中使用它。每当成功创建一个作业时，我们希望让用户知道。
- en: 'Let’s open the `src/pages/dashboard/jobs/create.tsx` file and import the `useNotifications`
    hook:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`src/pages/dashboard/jobs/create.tsx`文件并导入`useNotifications`钩子：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, let’s initialize the hook inside the `DashboardCreateJobPage` component
    body:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们在`DashboardCreateJobPage`组件体内部初始化钩子：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we can call `showNotification` in the `onSuccess` handler:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在`onSuccess`处理程序中调用`showNotification`：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We are showing a new success notification that will disappear after 5 seconds.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了一个新的成功通知，它将在5秒后消失。
- en: 'To see it in action, let’s open [http://localhost:3000/dashboard/jobs/create](http://localhost:3000/dashboard/jobs/create)
    and submit the form. If the submission is successful, we should see something
    like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看其操作效果，让我们打开[http://localhost:3000/dashboard/jobs/create](http://localhost:3000/dashboard/jobs/create)并提交表单。如果提交成功，我们应该看到如下内容：
- en: '![Figure 7.2 – Notifications in action ](img/B17297_07_02.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 通知在操作中](img/B17297_07_02.jpg)'
- en: Figure 7.2 – Notifications in action
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 通知在操作中
- en: Perfect! Any time a job is created, the user will be notified about it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！每当创建一个作业时，用户都会收到通知。
- en: Another place that we can utilize notifications is in API error handling. Whenever
    an API error happens, we want to let the user know something went wrong.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用通知的另一个地方是在API错误处理中。每当发生API错误时，我们希望让用户知道出了些问题。
- en: We can handle it on the API client level. Since Axios supports interceptors,
    and we already have them configured, we just need to modify the response error
    interceptor.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在API客户端级别处理它。由于Axios支持拦截器，并且我们已经配置了它们，我们只需要修改响应错误拦截器。
- en: 'Let’s open `src/lib/api-client.ts` and import the store:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`src/lib/api-client.ts`并导入存储：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, in the response error interceptor, let’s locate the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在响应错误拦截器中，让我们定位以下内容：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We’ll replace it with the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用以下内容替换它：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To access values and methods on a vanilla Zustand store, we need to call the
    `getState` method.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问vanilla Zustand存储上的值和方法，我们需要调用`getState`方法。
- en: Any time an error on the API happens, an error notification will be shown to
    the user.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每当API发生错误时，都会向用户显示错误通知。
- en: It’s worth mentioning that Chakra UI has its own toast notification system out
    of the box, which is very simple to use and would fit our needs, but we made our
    own to learn how to manage the global application state in a nice and simple way.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Chakra UI自带一个开箱即用的toast通知系统，使用起来非常简单，非常适合我们的需求，但我们还是自己构建了一个，以便学习如何以优雅且简单的方式管理全局应用程序状态。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to handle authentication and manage the global
    state of the application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何处理身份验证和管理应用程序的全局状态。
- en: We started with an overview of the authentication system and how it works. Then,
    we implemented authentication features such as login, logout, and getting the
    authenticated user info. We also built the `Protected` component, which controls
    whether the user is allowed to see a page based on their authentication status.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从对身份验证系统及其工作原理的概述开始。然后，我们实现了登录、注销和获取认证用户信息等身份验证功能。我们还构建了`Protected`组件，该组件根据用户的认证状态控制用户是否可以查看页面。
- en: Then, we built a toast notification system where the user can trigger and display
    notifications from anywhere in the application. The main goal of building it was
    to introduce Zustand, a very simple and easy-to-use state management library for
    handling global application state.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们构建了一个toast通知系统，用户可以从应用程序的任何地方触发和显示通知。构建它的主要目的是介绍Zustand，这是一个非常简单且易于使用的全局状态管理库，用于处理全局应用程序状态。
- en: In the next chapter, we will learn how to approach testing the application with
    unit, integration, and end-to-end tests.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用单元测试、集成测试和端到端测试来测试应用程序。
