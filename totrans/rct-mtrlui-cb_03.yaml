- en: Drawers - A Place for Navigation Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll learn about the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Drawer types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawer item state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawer item navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawer sections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AppBar interaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Material-UI uses drawers to present the user with the main navigation of the
    app. The `Drawer` component acts like a physical drawer that can move out of view
    when it is not being used.
  prefs: []
  type: TYPE_NORMAL
- en: Drawer types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three types of `Drawer` components that you''ll use in your app,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Temporary**: A transient drawer that closes when an action is taken.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistent**: A drawer that can be opened and stays open until explicitly
    closed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permanent**: A drawer that is always visible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that you want to support different types of drawers in your app.
    You can control the `Drawer` component type using the `variant` property. Here''s
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `variant` property defaults to `temporary`. When you first load this screen,
    you''ll only see the button to toggle the drawer display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d6c488b-915a-49f0-a0e2-164daaa0f241.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you click on this button, you''ll see a temporary drawer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31351208-3f04-4717-9dc1-a008497baef6.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you start changing the `variant` property, let''s walk through the code
    in this example, starting with the `Drawer` markup, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Drawer` component takes an `open` property, which displays the drawer when
    true. The `variant` property determines the type of drawer to render. The screenshot
    shown previously is a temporary drawer, the default variant value. The `Drawer`
    component has `List` as its child, where each of the items displayed in the drawer
    are rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at the `Button` component that toggles the display
    of the `Drawer` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When this button is clicked, the `open` state of your component is toggled.
    Likewise, the text of the button is toggled depending on the value of the `open`
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s try changing the value of the `variant` property to `permanent`.
    Here''s what the drawer looks like when rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f39ffc3-b127-46f2-8c84-f1e140add015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A permanent drawer, as the name suggests, is always visible and is always in
    the same place on the screen. If you click on the SHOW DRAWER button, the `open`
    state of your component is toggled to true. You''ll see the text of the button
    change, but since the `Drawer` component is using the `permanent` variant, the
    `open` property has no effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ac0e855-67c2-43e3-988d-5b0773d3367a.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, let's try the `persistent` variant. Persistent drawers are similar to
    permanent drawers in that they stay visible on the screen while the user interacts
    with the app, and they're similar to temporary drawers in that they can be hidden
    by changing the `open` property.
  prefs: []
  type: TYPE_NORMAL
- en: Let's change the `variant` property to `persistent`. When the screen first loads,
    the drawer isn't visible because the `open` state of your component is `false`.
    Try clicking on the SHOW DRAWER button. The drawer is displayed, and it looks
    like the permanent drawer. If you click the HIDE DRAWER button, the `open` state
    of your component is toggled to `false` and the drawer is hidden.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent drawers should be used when you want the user to be able to control
    the visibility of the drawer. For example, with temporary drawers the user can
    close the drawer by clicking on the overlay or by hitting the *Esc *key. Permanent
    drawers are useful when you want to use the left-hand navigation as an integral
    part of the page layout—they are always visible and other items are laid out around
    them.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you click on any of the items in the drawer, the event handlers set the
    `open` state of your component to `false`. This might not be what you want and
    could potentially confuse your users. For example, if you're using a persistent
    drawer, your app probably has a button outside of the drawer that controls the
    visibility of the drawer. If the user clicks on a drawer item, they're probably
    not expecting the drawer to close.
  prefs: []
  type: TYPE_NORMAL
- en: 'To address this issue, your event handlers can take into consideration a variant
    of the `Drawer` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you click on any of these items, the `open` state is only changed
    to `false` if the `variant` property is `temporary`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Drawer` demos: [https://material-ui.com/demos/drawers/](https://material-ui.com/demos/drawers/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Drawer` API documentation: [https://material-ui.com/api/drawer/](https://material-ui.com/api/drawer/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawer item state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The items that are rendered in `Drawer` components are rarely static. Instead,
    the drawer items are rendered based on the state of your component, allowing for
    more control over how items are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say that you have a component that renders drawer navigation using the
    `Drawer` component. Instead of writing the `items` state directly in the component
    markup, you want to have the `items` state stored in the state of the component.
    For example, in response to permission checks on the user, items might be disabled
    or completely hidden.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example that uses an array of `item` objects from the component
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the drawer looks like when you click on the SHOW DRAWER button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca571334-0b02-485f-bb77-8c48a771ba1c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you select one of these items, the drawer will close and the content of
    the screen will be updated; for example, after clicking on Page 2, you should see
    something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d23b7e85-7e2e-4b52-bcbf-80d90409243c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by looking at the state of your component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `open` state controls the visibility of the `Drawer` component, and the
    `content` state is the text that's displayed on the screen depending on which
    drawer item is clicked on. The `items` state is an array of objects that is used
    to render the drawer items. Every object has a `label` property and an `Icon`
    property that are used to render the item text and icon respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `Icon` property is capitalized in order to maintain the React convention
    of capitalizing components. This makes it easier to differentiate React components
    from other data when reading the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `disabled` property is used to render the item as disabled; for example,
    Page 3 is marked as disabled by setting this property to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb518bc4-d0f0-4f9b-85d7-746bf7944c89.png)'
  prefs: []
  type: TYPE_IMG
- en: This could be due to permission restrictions for the user on this particular
    page, or some other reason. Because this is controlled through the component state
    instead of rendered statically, you could update the `disabled` state for any
    menu item at any time using any mechanism that you like, such as an API call.
    The `hidden` property uses the same principle, except when this value is `true`,
    the item isn't rendered at all. In this example, Page 5 isn't rendered because
    it's marked as hidden.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at how the `List` items are rendered based on the `items`
    state, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First, the `items` array is filtered to remove `hidden` items. Then, `map()`
    is used to render each `ListItem` component. The `disabled` property is passed
    to `ListItem` and it will be visibly disabled when rendered. The `Icon` component
    also comes from the list item state. The `onClick()` event handler hides the drawer
    and updates the `content` label.
  prefs: []
  type: TYPE_NORMAL
- en: The `onClick()` handler isn't executed when disabled list items are clicked
    on.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might want to separate the rendering of list items into its own component.
    This way, you can use the list items in other places. For example, you might want
    to use the same rendering logic to render a list of buttons elsewhere in your
    app. Here''s an example of how you can extract the `ListItems` component into
    its own component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `ListItems` component will return an array of `ListItem` components. It
    takes the `items` state to render as an array property. It also takes an `onClick()`
    function property. This is a higher-order function that takes the `label` component
    to display as an argument and returns a new function that will update the content
    when the item is clicked on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the new JSX markup looks like, updated to use the new `ListItems`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There is no more list item rendering code in this component. Instead, `ListItems`
    is rendered as the child of `List`. You pass it the items to render and the `onClick()`
    handler. You now have a generic `ListItems` component that can be used anywhere
    that you show lists in your app. It will consistently handle the `Icon`, `disabled`,
    and display logic wherever it is used.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Drawer` demos: [https://material-ui.com/demos/drawers/](https://material-ui.com/demos/drawers/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Drawer` API documentation: [https://material-ui.com/api/drawer/](https://material-ui.com/api/drawer/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawer item navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your Material-UI app uses a router such as `react-router` to navigate from
    page to page, you'll probably want links as your `Drawer` items. To do so, you
    have to integrate components from the `react-router-dom` package.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that your app is composed of three pages. To navigate from page
    to page, you want to provide your users with links in the `Drawer` component.
    Here''s what the code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When you first load the screen, you''ll see the SHOW DRAWER button and the
    home screen content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46804d4b-9540-467d-ae24-d84a125efcf1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s what the drawer looks like when it''s opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2009526a-078d-4682-a60a-fdee2a67dcc0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click on Page 2, which points to `/page2`, the drawer should close and
    you should be taken to the second page. Here''s what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f731a302-e6f9-4372-bd33-fcce103055b0.png)'
  prefs: []
  type: TYPE_IMG
- en: You should see something similar if you click on Page 3 or on Home. The content
    on the left side of the screen is updated.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by looking at the `Route` components that `render` content based
    on the active the `Route` components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There's a `Route` component used for each `path` in your app. The `render()`
    function returns the content that should be rendered within this `Grid` item when
    the `path` property matches the current URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at one of the `ListItem` components within the `Drawer` component,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By default, the `ListItem` component will render a `div` element. It accepts
    a `button` property that when true, will render a `button` element. You don't
    want either of these. Instead, you want the list items to be links that `react-router`
    will process. The `component` property accepts a custom component to use; in this
    example, you want to use the `Link` component from the `react-router-dom` package.
    This will render the appropriate link while maintaining the proper styles.
  prefs: []
  type: TYPE_NORMAL
- en: The properties that you pass to `ListItem` are also passed to your custom component,
    which, in this case, is `Link`. This means that the required `to` property is
    passed to `Link`, pointing the link to `/`. Likewise, the `onClick` handler is
    also passed to the `Link` component, which is important because you want to close
    the temporary drawer whenever a link is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the items in your drawer are links, you probably want a visual indication
    for the active link. The challenge is that you want to style the active link using
    Material-UI theme styles. Here''s what the modified example looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when the screen first loads and you open the drawer, it should look similar
    to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a885787-b548-4c9b-bb81-0a939229c273.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since the Home link is active, it''s styled using the primary color from the
    Material-UI theme. If you click on the Page 2 link and then open the drawer again,
    it should look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e655bd5-9ef9-4e4c-b642-fb132e5a2657.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at the two new components that you''ve added, starting with
    `NavItem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This component is used to determine whether or not the item is active, based
    on the current URL. It uses the `Switch` component from `react-router-dom`. Instead
    of just rendering `Route` components, `Switch` will only render the first route
    whose path matches the current URL. The first `Route` component in `NavItem` is
    the specific path (as it uses the `exact` property). If this `Route` component
    matches, it renders a `NavListItem` component with the `active` property set to
    true. Because it's in a `Switch` component, the second `Route` component will
    not be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, on the other hand, the first `Route` component doesn''t match, the second
    `Route` component will always match. This will render a `NavListItem` component
    without the `active` property. Now, let''s take a look at the `NavListItem` component,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `NavListItem` component is now responsible for rendering the `ListItem`
    components in the `Drawer` component. It takes a `text` property and an `Icon`
    property to render the label and the icon respectively, just like before your
    enhancements. The `active` property is used to determine the class that gets applied
    to the `ListItemIcon` and `ListItemText` components. The `activeListItem` CSS
    class is applied to both of these components if `active` is true. This is how
    you're able to style the `active` item based on the Material-UI theme.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `clsx()` function is used extensively by Material-UI–this isn''t an extra
    dependency. It allows you to dynamically change the class of an element without
    introducing custom logic into your markup. For example, the `clsx({ [classes.activeListItem]:
    active })` syntax will only apply the `activeListItem` class if `active` is true.
    The alternative will involve introducing more logic into your component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, let''s take a look at the `activeListItem` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `activeListItem` class sets the color CSS property by using the `theme.palette.primary.main`
    value. This means that if the theme changes, your active link in the drawer will
    be styled accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React Router documentation: [https://reacttraining.com/react-router/](https://reacttraining.com/react-router/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Drawer` demos: [https://material-ui.com/demos/drawers/](https://material-ui.com/demos/drawers/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Drawer` API documentation: [https://material-ui.com/api/drawer/](https://material-ui.com/api/drawer/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawer sections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have lots of items in your `Drawer`, you might want to divide your
    drawer into sections. When you have lots of drawer items and no sections, you
    end up having to put section names into the items themselves, which leads to messy
    and awkward drawer item labels.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that you''re working on an app that has screens for managing different
    aspects of the CPU, memory, storage, and network. Instead of having a flat list
    of drawer items, you could display drawer items in their relevant sections, making
    it easier to navigate. Here''s the code to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When you click on the SHOW DRAWER button, your drawer should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9693127-5df8-4733-b79e-d538d65b573c.png)'
  prefs: []
  type: TYPE_IMG
- en: There are lots of add and usage items in this drawer. The sections make the
    items easier for your users to scan.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by taking a look at the state of your component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of the `items` state being a flat array of items, it''s now an object
    with arrays grouped by category. These are the drawer sections that you want to
    render. Next, let''s look at the `List` markup for rendering the `items` state
    and the section headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `ListSubheader` component is used when you need a label above the list items.
    For example, underneath the Storage header, you have the `ListItems` component
    that renders items from the `items.storage` state.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have a lot of drawer items and sections, you can still overwhelm your
    users with the amount of information to parse. One solution is to have collapsible
    sections. For this, you can add a `Button` component to the `ListSubheader` component
    so that it's clickable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The ripple effect that would normally happen when you click on a button is
    disabled here because you want the header text to still look like header text.
    This also requires a little bit of CSS customization in the `listSubheader` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When the section header button is clicked, it toggles the state of the section,
    which in turn, toggles the visibility of the section items. Here''s the `toggleSection()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is a higher-order function that returns a new function as the `onClick`
    handler for the button. The `name` argument is the name of the section state to
    toggle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the new state that was added to support toggling sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When the screen first loads, the CPU section will be the only section with
    visible items since it''s the only state that''s `true`. Next, let''s look at
    how the `ListItems` are actually collapsed when their corresponding section state
    is `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ListItems` component now accepts a `visible` property. This is used by
    the `Collapse` component, which will hide its children using a collapsing animation
    when hiding components. Finally, here''s how the new `ListItems` component is
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When the screen first loads, and you click on the SHOW DRAWER button, you should
    see something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/850d28a3-cfd7-4162-8b22-e46b98fb0e93.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There''s way less information for the user to parse now. They can click on
    the section headers to see the list items, and they can click again to collapse
    the section; for example, they could collapse the CPU section and expand the MEMORY
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e66d110-145f-43b1-b1db-33c4d932d747.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Drawer` demos: [https://material-ui.com/demos/drawers/](https://material-ui.com/demos/drawers/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Drawer` API documentation: [https://material-ui.com/api/drawer/](https://material-ui.com/api/drawer/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AppBar interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common place to put a button that toggles the visibility of `Drawer` components
    is the `AppBar` component at the top of every page in your app. Furthermore, by
    selecting items in a drawer, the title of the `AppBar` component needs to change
    to reflect this selection. `Drawer` and `AppBar` components often need to interact
    with one another.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that you have a `Drawer` component with a few items in it. You also
    have an `AppBar` component with a menu button and a title. The menu button should
    toggle the visibility of the drawer, and clicking on a drawer item should update
    the title in the `AppBar`. Here''s the code to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the screen looks like when it first loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/787e6390-a40a-415c-ac4a-8949de696a90.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you click on the menu icon button to the left of the title, you''ll see
    the drawer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2bd42494-2c19-45ad-8187-67695e0bd04f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click on the Page 2 item, the drawer will close and the title of the
    `AppBar` will change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92a5a840-a69e-4f7e-a3ed-a334cfacc96d.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This example defines three components, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `MyToolbar` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MyDrawer` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main app component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s walk through each of these individually, starting with `MyToolbar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MyToolbar` component renders an `AppBar` component that accepts a `title`
    property and a `onMenuClick()` property. Both of these properties are used to
    interact with the `MyDrawer` component. The `title` property changes when a drawer
    item selection is made. The `onMenuClick()` function changes state in your main
    app component, causing the drawer to display. Next, let''s take a look at `MyDrawer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `MyDrawer` component is functional like `MyToolbar`. It accepts properties
    instead of maintaining its own state. For example, the `open` property is how
    the visibility of the drawer is controlled. The `onClose()` and `setTitle()` properties
    are functions that are called when drawer items are clicked on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s look at the app component where all of the state lives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `title` state is passed to the `MyDrawer` component, along with the `toggleDrawer()`
    function. The `MyDrawer` component is passed the drawer state to control visibility,
    the `toggleDrawer()` function to change visibility, and the `setTitle()` function
    to update the title in `MyToolbar`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if you want the flexibility of having a persistent drawer that can be toggled
    using the same menu button in the App bar? Let's add a `variant` property to the
    `AppBarInteraction` component that is passed to `MyDrawer`. This can be changed
    from `temporary` to `persistent` and the menu button will still work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what a persistent drawer looks like when you click on the menu button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b71eabc1-a4e7-4d3d-893f-fba1c4ca06c4.png)'
  prefs: []
  type: TYPE_IMG
- en: The drawer overlaps the App bar. Another problem is that if you click on any
    of the drawer items, the drawer is closed, which isn't ideal for a persistent
    drawer. Let's fix both of these issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s address the `z-index` issue that''s causing the drawer to appear
    on top of the App bar. You can create a CSS class that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can apply this class to the `AppBar` component in `MyToolbar`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when you open the drawer, it appears underneath the `AppBar`, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee5575fd-6c33-4051-a601-da8c0650534b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now you just have to fix the margin. When the drawer uses the `persistent`
    variant, you can add the `toolbarMargin` class to a `<div>` element as the first
    element in the `Drawer` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With the help of the `clsx()` function, the `toolbarMargin` class is only added
    when needed – that is, when the drawer is persistent. Here''s what it looks like
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25865580-0027-47d7-865e-431ec73cd544.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, let''s fix the issue where the drawer closes when a drawer item is
    clicked on. In the main app component, you can add a new method that looks like
    the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onItemClick()` function takes care of setting the text in the App bar,
    as well as closing the drawer if it''s temporary. To use this new function, you
    can replace the `setTitle` property in `MyDrawer` with an `onItemClick` property.
    You can then use it in your list items, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now when you click on items in the drawer when it's persistent, the drawer will
    stay open. The only way to close it is by clicking on the menu button beside the
    title in the App bar.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Drawer` demos: [https://material-ui.com/demos/drawers/](https://material-ui.com/demos/drawers/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AppBar` demos: [https://material-ui.com/demos/app-bar/](https://material-ui.com/demos/app-bar/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Drawer` API documentation: [https://material-ui.com/api/drawer/](https://material-ui.com/api/drawer/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AppBar` API documentation: [https://material-ui.com/api/app-bar/](https://material-ui.com/api/app-bar/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
