- en: Chapter 1. Thinking in Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章. 组件化思维
- en: React was the first interface library that got me thinking about component-based
    design. React promotes many good patterns and habits, but this one stands out
    for me. To understand why, we need to think about how React works under the hood.
    React is primarily a rendering engine. It was created (and is used) for generating
    user interfaces.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: React 是第一个让我开始思考组件化设计的界面库。React 推崇许多良好的模式和习惯，但对我来说，这一点最为突出。要理解为什么，我们需要思考 React
    在底层是如何工作的。React 主要是一个渲染引擎。它是为了生成用户界面而被创建（并使用）的。
- en: How interfaces used to work (and indeed still work apart from React) was that
    someone would come up with a design. That image file would then be split up into
    assets for each interactive part of the interface. A library such as jQuery would
    manage user interactions and connect different interface components, often with
    an assortment of plugins.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 接口过去是如何工作的（实际上除了 React 之外仍然如此）是有人会提出一个设计。然后，这个图像文件会被分割成界面每个交互部分的资产。例如，jQuery
    这样的库会管理用户交互并连接不同的界面组件，通常还会附带一系列插件。
- en: Individual interface components can be quite clean and complete individually.
    However, when they are combined, interactions between components and shared, mutable
    component state often make a messy codebase. One of the main reasons why React
    was created was to simplify the interactions between components, so they can remain
    clean and easy to understand.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 单个界面组件可以非常干净和完整。然而，当它们组合在一起时，组件之间的交互和共享的可变组件状态往往会使代码库变得混乱。React 被创建的主要原因之一就是为了简化组件之间的交互，使它们保持干净且易于理解。
- en: Why components?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么是组件？
- en: Component-based design is powerful, especially when we use immutable data and
    unidirectional data flow. It forces me to stop thinking about how different technologies
    or tools interact. It gets me thinking about the single most important function
    of each interface element.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 基于组件的设计非常强大，尤其是当我们使用不可变数据和单向数据流时。它迫使我停止思考不同技术或工具之间的交互方式。它让我开始思考每个界面元素最重要的功能。
- en: When we start building an application, it's tempting to think of every piece
    as part of the whole. All interface elements blend into the same big picture,
    until it becomes so big that separating parts of it out seems impossible.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始构建一个应用程序时，很容易认为每个部分都是整体的一部分。所有界面元素都融合成同一个大画面，直到它变得如此之大，以至于分离出其部分似乎是不可能的。
- en: Imagine you had to build a space ship. What a huge task! You'd need some rocket
    boosters, a couple of wings, life support, and so on. Now consider how you would
    approach it if one of the constraints was that each moving part of the space ship
    would need to be individually tested.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你必须建造一艘宇宙飞船。这是一项多么庞大的任务！你需要一些火箭助推器、几对翅膀、生命维持系统等等。现在考虑一下，如果其中一个约束是宇宙飞船的每个活动部件都需要单独测试，你会如何处理？
- en: Testing is the great divide between designing systems as a whole and designing
    systems as large collections of small pieces. Component-based design is fantastic
    because it makes sure that every part is testable.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是整体设计系统与将系统设计为大量小部件集合之间的巨大差异。基于组件的设计非常出色，因为它确保每个部分都是可测试的。
- en: Using modern JavaScript
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用现代 JavaScript
- en: React components are wonderfully encapsulated. Each component is a blueprint
    for what a focused bit of markup should look like at any moment. They're reusable
    and can change their behavior depending on the context provided. Does that remind
    you of another programming paradigm?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: React 组件被巧妙地封装。每个组件都是任何时刻一个专注的标记片段应该呈现的蓝图。它们是可重用的，并且可以根据提供的上下文改变其行为。这让你想起了另一种编程范式吗？
- en: Let's talk about JavaScript. JavaScript has a prototypical inheritance model.
    That means different objects can have a common structure. The structure of one
    object can be derived from the structure of another.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈 JavaScript。JavaScript 有一个原型继承模型。这意味着不同的对象可以有一个共同的架构。一个对象的架构可以源自另一个对象的架构。
- en: 'It also means that changes to the original object are inherited in all derivative
    objects. Let me illustrate this with some code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这还意味着对原始对象的更改会继承到所有派生对象中。让我用一些代码来解释这一点：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I begin by creating a function called `Page`, which requires a `content` parameter.
    A simple `render` method returns that content, wrapped in a `div` tag. This seems
    like a good starting point for a website.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先创建了一个名为 `Page` 的函数，它需要一个 `content` 参数。一个简单的 `render` 方法返回该内容，并用 `div` 标签包裹。这似乎是一个构建网站的不错起点。
- en: Next, I decide to make a second type called `Post`. Objects of this type have
    tags, so I create a new initialization function to store them. I want `Post` to
    behave almost like a `Page` type, so I call the `Page` initialization function.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我决定创建第二种类型，称为`Post`。这种类型的对象有标签，所以我创建了一个新的初始化函数来存储它们。我希望`Post`的行为几乎像`Page`类型，所以我调用了`Page`的初始化函数。
- en: To inherit the `Page` methods in `Post`, I need to link their prototypes. I
    can then choose to override the `render` method and add new methods to the derived
    type. I can also change the `Page` type and these changes will be inherited by
    objects of the `Post` type. The connection happens because a prototype is a reference
    and not a copy.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`Post`中继承`Page`的方法，我需要链接它们的原型。然后我可以选择覆盖`render`方法并为派生类型添加新方法。我还可以更改`Page`类型，这些更改将继承到`Post`类型的对象中。这种连接发生是因为原型是一个引用而不是一个副本。
- en: Depending on the programming languages you grew up with, prototypical inheritance
    might be tricky at first. Many new developers learn (incorrectly) that object-oriented
    code means class-oriented code. Dynamic concepts such as prototypes are foreign
    to them. In the past, this led to a few libraries implementing "pretend" classes.
    They created patterns that would make code appear as if it was class-oriented.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你成长过程中所使用的编程语言，原型继承一开始可能有些棘手。许多新开发者错误地认为面向对象代码意味着面向类代码。动态概念如原型对他们来说很陌生。在过去，这导致了一些库实现了“假装”类。它们创建了使代码看起来像面向类模式的模式。
- en: Then, ES6 added the `class` keyword. It's a formalization of the pattern I just
    showed you. It's a syntactic shortcut to prototypical inheritance.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，ES6添加了`class`关键字。它是刚才展示模式的正式化。它是原型继承的语法捷径。
- en: 'We could reduce the previous code to:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将之前的代码简化为：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're trying to run this using Node (preferably a version greater than 4.1),
    you may need to add `use strict` at the top of the file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用Node（最好是版本大于4.1）运行此代码，你可能在文件顶部需要添加`use strict`。
- en: Notice how much clearer things are? If you want to use classes, then this syntactic
    shortcut is brilliant!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一下事情变得有多清晰？如果你想使用类，那么这种语法捷径是非常棒的！
- en: 'Let''s look at a typical ES5-compatible React component:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个典型的ES5兼容的React组件：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You've probably seen this kind of code before. It's called JSX and it's a JavaScript
    superset language. The idea is that the markup and the supporting logic are created
    and stored together.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能之前见过这种代码。它被称为JSX，是一种JavaScript超集语言。其理念是标记和支撑逻辑被创建并存储在一起。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: React components must return a single React node, which is why we wrap the tags
    and page elements in a `div` element. If you are using React in the browser, you
    also need to render your components to an existing DOM node (like I've just rendered
    the post to `.react`).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: React组件必须返回一个单一的React节点，这就是为什么我们将标签和页面元素包裹在一个`div`元素中。如果你在浏览器中使用React，你还需要将你的组件渲染到一个现有的DOM节点（就像我刚刚将帖子渲染到`.react`中）。
- en: We'll get into some of the specifics in later chapters, but this is doing pretty
    much the same thing as before. We create a base component called `Page`. It renders
    a property instead of a constructor parameter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中详细介绍一些具体内容，但这是与之前几乎相同的事情。我们创建了一个名为`Page`的基本组件。它渲染一个属性而不是构造函数参数。
- en: 'The `Post` component composes the `Page` component. This style of React code
    doesn''t support component inheritance. For that, we need ES6 code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Post`组件组合了`Page`组件。这种风格的React代码不支持组件继承。为此，我们需要ES6代码：'
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We could still compose `Page` within `Post`, but that's not the only option
    with ES6\. This code resembles the non-React version we saw earlier.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以在`Post`中组合`Page`，但这不是ES6的唯一选项。这段代码与之前看到的非React版本相似。
- en: In upcoming chapters, we'll learn many useful features of ES6 that'll allow
    us to create modern, expressive React components.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习ES6的许多有用特性，这将使我们能够创建现代、表达式的React组件。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to look ahead a little, check out [http://babeljs.io/docs/learn-es2015](http://babeljs.io/docs/learn-es2015).
    It's a great place to learn the main features of ES6!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要提前了解一下，请查看[http://babeljs.io/docs/learn-es2015](http://babeljs.io/docs/learn-es2015)。这是一个学习ES6主要特性的绝佳地方！
- en: 'Babel is the cross-compilation tool we''ll use to turn ES6 code into ES5 code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Babel是我们将使用的跨编译工具，将ES6代码转换为ES5代码：
- en: '![Using modern JavaScript](img/5268_01_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![使用现代JavaScript](img/5268_01_01.jpg)'
- en: Compiling modern JavaScript
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译现代JavaScript
- en: 'It''s time for us to look at how to compile ES6 and JSX code into formats that
    most browsers can read. Create a folder for your React components and run the
    following commands inside it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看如何将 ES6 和 JSX 代码编译成大多数浏览器都能读取的格式了。为你的 React 组件创建一个文件夹，并在其中运行以下命令：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first command will kick off a series of questions, most of which should
    have reasonable defaults. The second command will download a builder and a cross-compiler
    for your ES6 code. Place the following component in a file called `page.js`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令将启动一系列问题，其中大部分应该有合理的默认值。第二个命令将下载用于你的 ES6 代码的构建器和跨编译器。将以下组件放在一个名为 `page.js`
    的文件中：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are a couple of important differences between this and the previous `Page`
    component. We import the main `React` object from within the `node_modules` folder.
    We also export the class definition so that importing this file immediately references
    this class. It''s a good idea to limit each file to a single class. It''s also
    a good idea to make each file define types or use them. We use this class in `main.js`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的 `Page` 组件相比，这里有几个重要的区别。我们从 `node_modules` 文件夹中导入主要的 `React` 对象。我们还导出类定义，以便导入此文件立即引用此类。将每个文件限制为单个类是一个好主意。同样，让每个文件定义类型或使用它们也是一个好主意。我们在
    `main.js` 中使用这个类：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code imports `React` and `ReactDOM` from within the `node_modules` folder,
    so we can render the `Page` class. Here we''re referencing an element in the DOM
    again. We can use this JavaScript within an HTML page:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从 `node_modules` 文件夹中导入 `React` 和 `ReactDOM`，因此我们可以渲染 `Page` 类。这里我们再次引用
    DOM 中的元素。我们可以在 HTML 页面中使用这段 JavaScript：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The final step is to compile the ES6/JSX code in `main.js` to ES5-compatible
    code in `main.dist.js`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将 `main.js` 中的 ES6/JSX 代码编译成 `main.dist.js` 中的 ES5 兼容代码：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first command creates a shortcut to the `browserify` command in the `node_modules/.bin`
    folder. This is useful for repeated calls to `browserify`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令在 `node_modules/.bin` 文件夹中创建 `browserify` 命令的快捷方式。这对于重复调用 `browserify`
    非常有用。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to keep that alias around, be sure to add it to your `~/.bashrc`,
    `~/.zshrc` or `~/.profile` file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要保留那个别名，请确保将其添加到你的 `~/.bashrc`、`~/.zshrc` 或 `~/.profile` 文件中。
- en: The second command starts a build. *Browserify* will combine all imported files
    into a single file, so they can be used in a browser.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令开始构建。*Browserify* 将所有导入的文件合并成一个文件，以便在浏览器中使用。
- en: We use the `babelify` transformer, so the ES6 code becomes ES5-compatible code.
    Babel supports JSX, so we don't need additional steps for that. We specify `main.js`
    as the file to transform and `main.dist.js` as the output file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `babelify` 转换器，因此 ES6 代码变成了 ES5 兼容的代码。Babel 支持 JSX，所以我们不需要额外的步骤。我们指定 `main.js`
    作为要转换的文件，并将 `main.dist.js` 作为输出文件。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to compile React and ReactDOM into their own file, you can exclude
    them with the `-x` switch. Your command should be something like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将 React 和 ReactDOM 编译成单独的文件，你可以使用 `-x` 开关来排除它们。你的命令应该是这样的：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Debugging in the browser
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器调试
- en: 'We can also use our code directly in the browser. There may be times when we
    want to see the effects of a change, without a build step. In such cases, we can
    try something like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以直接在浏览器中使用我们的代码。有时我们可能想在构建步骤之前看到更改的效果。在这种情况下，我们可以尝试以下操作：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'These will give us access to a browser-based dependency manager and cross-compiler;
    that is, we can use unbundled source code in an example HTML file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将为我们提供一个基于浏览器的依赖管理器和跨编译器；也就是说，我们可以在一个示例 HTML 文件中使用未打包的源代码：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This uses the same unprocessed `main.js` file as before, but we no longer need
    to rebuild it after each change to the source code. The `System` is a reference
    to the *SystemJS* library we just installed through NPM. It takes care of the
    import statements, loading those dependencies with Ajax requests.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用的是之前相同的未处理 `main.js` 文件，但我们在每次更改源代码后不再需要重新构建它。`System` 是对通过 NPM 安装的 *SystemJS*
    库的引用。它负责处理导入语句，通过 Ajax 请求加载这些依赖项。
- en: You may notice the references to `react` and `react-dom`. We import these in
    `main.js`, but where do they come from? Browserify fetches them out of the `node_modules`
    folder. When we skip the Browserify step, we need to let SystemJS know where to
    find them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到对 `react` 和 `react-dom` 的引用。我们在 `main.js` 中导入这些，但它们是从哪里来的？Browserify
    从 `node_modules` 文件夹中获取它们。当我们跳过 Browserify 步骤时，我们需要让 SystemJS 知道它们的位置。
- en: The easiest place to find these files is at [https://facebook.github.io/react](https://facebook.github.io/react).
    Click on the download button, extract the archive, and copy the `JS` files in
    the `build` folder to where they are referenced in the HTML page.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件最易找到的地方是[https://facebook.github.io/react](https://facebook.github.io/react)。点击下载按钮，解压存档，并将`build`文件夹中的`JS`文件复制到HTML页面中引用的位置。
- en: 'The ReactJS website is a great place to download ReactJS, and find documentation
    about how you can use it:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS网站是一个下载ReactJS和查找如何使用它的文档的好地方：
- en: '![Debugging in the browser](img/5268_01_02.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![浏览器中的调试](img/5268_01_02.jpg)'
- en: Managing common tasks
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理常见任务
- en: As our collection of React components grows, we'll need ways of bundling them
    all together. It would also be a good idea for us to minify the resulting JavaScript
    to reduce the time it takes to load them in a browser.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们React组件集合的增长，我们需要将它们全部捆绑在一起的方法。同时，将生成的JavaScript代码压缩以减少在浏览器中加载它们所需的时间也是一个好主意。
- en: 'We can perform these kinds of tasks using scripts in `package.json`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`package.json`中的脚本执行这类任务：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: NPM scripts are fine for small, simple tasks. When the tasks get more complex,
    we'll start to see the drawbacks of using NPM scripts for this. There's no easy
    way to use variables in these scripts, so parameters are often repeated. The scripts
    are also a bit inflexible and frankly ugly.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: NPM脚本对于小型、简单的任务来说很好。当任务变得更加复杂时，我们开始看到使用NPM脚本进行此操作的缺点。在这些脚本中使用变量没有简单的方法，因此参数经常被重复。这些脚本也有些不够灵活，坦白说，看起来也不太美观。
- en: There are a few tools that address these problems. We're going to use one of
    them, called **Grunt**, to create flexible, repeatable tasks.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具可以解决这些问题。我们将使用其中之一，名为**Grunt**，来创建灵活、可重复的任务。
- en: 'The Grunt website has instructions for using Grunt and a list of popular plugins
    you can use to customize your workflow:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt网站提供了使用Grunt的说明以及你可以用来定制工作流程的流行插件列表：
- en: '![Managing common tasks](img/5268_01_03.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![管理常见任务](img/5268_01_03.jpg)'
- en: 'Grunt is a JavaScript task runner. There are three steps for using it:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt是一个JavaScript任务运行器。使用它的三个步骤如下：
- en: First, we need to install the CLI tool. We'll use this to run different tasks.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要安装CLI工具。我们将使用它来运行不同的任务。
- en: Then, we need to install the libraries our tasks will use, via NPM.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要安装我们的任务将使用的库，通过NPM。
- en: Finally, we need to create a `gruntfile.js` file where we'll put our tasks.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要创建一个`gruntfile.js`文件，我们将在这里放置我们的任务。
- en: 'We can install the CLI tool using the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令安装CLI工具：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding command installs the Grunt CLI tool globally. If you don't want
    that, omit the `-g` flag. You'll need to alias/run it directly with `node_modules/.bin/grunt`
    from here on though.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令全局安装了Grunt CLI工具。如果你不希望这样做，请省略`-g`标志。但是，从现在开始，你需要直接使用`node_modules/.bin/grunt`来别名/运行它。
- en: 'We will need the following task libraries:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要以下任务库：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The global CLI tool needs a local copy of `grunt`. In addition, we also want
    the glue libraries to run Browserify, Uglify, and a file watcher in Grunt. We
    configure them with something like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 全局CLI工具需要一个本地的`grunt`副本。此外，我们还想在Grunt中运行Browserify、Uglify和文件监视器的粘合库。我们用类似以下的方式配置它们：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can configure each task in `gruntfile.js`. Here, we create a `browserify`
    task, defining the source and destination files. We include the `babelify` transformation
    to convert our ES6 classes into ES5-compatible code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`gruntfile.js`中配置每个任务。在这里，我们创建一个`browserify`任务，定义源文件和目标文件。我们包括`babelify`转换，将我们的ES6类转换为ES5兼容的代码。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I've added the `external` option so you can see how. If you don't need it, just
    delete it and your bundle file should then include the full React source code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经添加了`external`选项，这样你就可以看到如何使用它。如果你不需要它，只需删除它，然后你的包文件应该包含完整的React源代码。
- en: After the ES6 code is transformed, we can run *Uglify* to remove unnecessary
    whitespace. This reduces the size of the file, so browsers can download it quicker.
    We can target the file Browserify created and create a new minified file from
    it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6代码转换后，我们可以运行*Uglify*来删除不必要的空白。这减少了文件的大小，因此浏览器可以更快地下载它。我们可以针对Browserify创建的文件，并从中创建一个新的压缩文件。
- en: 'Finally, we create a `watch` task. This watches for changes to `main.js` and
    triggers the Browserify and Uglify tasks. We need to register a default set of
    tasks, which we set to `browserify` and `uglify`. This configuration enables the
    following commands:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个`watch`任务。这个任务会监视`main.js`的变化，并触发Browserify和Uglify任务。我们需要注册一组默认任务，我们将它们设置为`browserify`和`uglify`。此配置启用以下命令：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are other great tools like Grunt:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些优秀的工具，如Grunt：
- en: '[http://gulpjs.com](http://gulpjs.com)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://gulpjs.com](http://gulpjs.com)'
- en: '[https://webpack.github.io](https://webpack.github.io)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://webpack.github.io](https://webpack.github.io)'
- en: They work with similar configuration files, but the configuration is done through
    functional composition. The important thing to take from this is that there are
    tools we can use to automate tasks we would have run by hand. They make these
    repetitive tasks easy!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 他们使用类似的配置文件，但配置是通过功能组合来完成的。从这个例子中我们可以得到的重要信息是，有一些工具我们可以用来自动化我们本需要手动执行的任务。这使得这些重复性任务变得简单易行！
- en: Testing in JSBin
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JSBin中进行测试
- en: 'If you''re anything like me, you''ll often just want a quick place to test
    some small component or ES6 code. Setting up these build chains or live browser
    environments takes time. There is a quicker way. It''s called JSBin and you can
    find it at [https://jsbin.com](https://jsbin.com):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您像我一样，您通常会想要一个快速的地方来测试一些小的组件或ES6代码。设置这些构建链或实时浏览器环境需要时间。有一种更快的方法。它被称为JSBin，您可以在[https://jsbin.com](https://jsbin.com)找到它：
- en: '![Testing in JSBin](img/5268_01_04.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![在JSBin中进行测试](img/5268_01_04.jpg)'
- en: To get the most out of JSBin, be sure to set the **JavaScript** dropdown to
    **ES6/Babel** and include the ReactJS scripts from *CDNJS*. These are pre-built
    versions of ReactJS, so you can create React components (using ES6 features) straight
    from the browser.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分利用JSBin，请确保将**JavaScript**下拉菜单设置为**ES6/Babel**，并包含来自*CDNJS*的ReactJS脚本。这些是预构建的ReactJS版本，因此您可以直接从浏览器中创建React组件（使用ES6功能）。
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for this book from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)上的账户下载此书的示例代码文件。如果您在其他地方购买了此书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: 'You can download the code files by following these steps:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下步骤下载代码文件：
- en: Log in or register to our website using your e-mail address and password.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您的电子邮件地址和密码登录或注册我们的网站。
- en: Hover the mouse pointer on the SUPPORT tab at the top.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将鼠标指针悬停在顶部的“支持”标签上。
- en: Click on Code Downloads & Errata.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击“代码下载与勘误”。
- en: Enter the name of the book in the Search box.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在搜索框中输入书籍名称。
- en: Select the book for which you're looking to download the code files.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择您想要下载代码文件的书籍。
- en: Choose from the drop-down menu where you purchased this book from.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择您购买此书籍的地方。
- en: Click on Code Download.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击“代码下载”。
- en: You can also download the code files by clicking on the Code Files button on
    the book's webpage at the Packt Publishing website. This page can be accessed
    by entering the book's name in the Search box. Please note that you need to be
    logged in to your Packt account.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过点击Packt Publishing网站上的书籍网页上的“代码文件”按钮来下载代码文件。您可以通过在搜索框中输入书籍名称来访问此页面。请注意，您需要登录到您的Packt账户。
- en: 'Once the file is downloaded, please make sure that you unzip or extract the
    folder using the latest version of:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 文件下载完成后，请确保使用最新版本的以下软件解压缩或提取文件夹：
- en: WinRAR / 7-Zip for Windows
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows上的WinRAR / 7-Zip
- en: Zipeg / iZip / UnRarX for Mac
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mac上的Zipeg / iZip / UnRarX
- en: 7-Zip / PeaZip for Linux
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux上的7-Zip / PeaZip
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw why component-based design is good. We saw what simple
    React components look like. We saw a few interesting differences between ES5 and
    ES6, and we also saw how those differences influence React components.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了基于组件的设计为什么是好的。我们看到了简单的React组件的样子。我们看到了ES5和ES6之间的一些有趣的不同之处，我们还看到了这些差异如何影响React组件。
- en: We also saw a few ways to make ES6 code work in an ES5-compatible way. We can
    write cutting-edge code that works on common browsers. We can even bundle that
    code into single, efficient files, or debug it live in a browser.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了一些方法可以使ES6代码以ES5兼容的方式运行。我们可以编写适用于常见浏览器的尖端代码。我们甚至可以将这些代码打包成单个高效文件，或者在浏览器中实时调试它。
- en: In the next chapter, we're going to look at some intricacies of state and properties.
    We'll begin by creating reusable React components to use in our example application.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨状态和属性的某些复杂性。我们将从创建可重用React组件以在我们的示例应用程序中使用开始。
