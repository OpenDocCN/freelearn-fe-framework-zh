- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling Application State with Grace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn about application state. Understanding and handling
    the state of your application is one of the most essential parts of frontend development.
    If the state of your applications becomes messy, entangled, and hard to understand,
    your development process and the quality of your application will suffer.
  prefs: []
  type: TYPE_NORMAL
- en: To help you better manage your application state, we will talk about the different
    state levels you’ll find within your applications. You will learn how to partition
    and divide your state for maximum efficiency. You will also create a state management
    solution using RxJS and Signals and build a facade service to access your state
    from the component layer.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will learn how to handle more complex states with the NgRx library.
    NgRx is the most commonly used state management library within the Angular community
    and uses the Redux pattern to manage state. Since the introduction of Angular
    Signals, NgRx also provides different approaches to working with Signals while
    using the tools we love from NgRx.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have implemented state management solutions
    using different methods. You’ll have learned how easy it is to change your state
    management solution when using a facade service and seen how Angular Signals has
    changed the way we handle state within Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding application state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling global application state using RxJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling global application state using Signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling global application state with NgRx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding application state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In simple terms, **application state** is a snapshot of the current condition
    (or state) of your data, configurations, and views at a specific point in time.
    Application state is the sum of all actions that are performed within your application
    from the moment it is loaded in the browser. The state is a dynamic landscape
    that influences your application’s view, user interactions, data flow, and overall
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: It’s essential to have good state management within your application so that
    all your components can display the correct data to the end user and you have
    accurate data to work with within your application code. Good state management
    prevents unintended data changes, resulting in incorrect views and operations
    being performed within your application code that you did not intend to perform.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an idea of what application state is and why you need it,
    let’s dive deeper, starting with the different levels of application state.
  prefs: []
  type: TYPE_NORMAL
- en: Different levels of application state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the realm of frontend development, we can distinguish between two levels
    of state: global and local state. In this section, we’ll delve into the nuanced
    distinction between global and local application states within the context of
    Angular, shedding light on their roles in crafting robust and maintainable frontend
    applications.'
  prefs: []
  type: TYPE_NORMAL
- en: As their names imply, **local state** is localized to a file, component, or
    element within your application, whereas **global state** is shared through your
    entire application. The global application state serves as the central repository
    for shared information across various components, ensuring coherence and synchronicity
    in the application’s behavior. On the other hand, the local application state
    encapsulates the internal data and configuration specific to individual Angular
    components and services.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding the dual nature of global and local states, your Angular applications
    can strike a harmonious balance between reusability, encapsulation, and shared
    data integrity. Let’s start by diving a bit deeper into the local application
    state within Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Local application state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we refer to local state, we’re talking about properties that have been
    localized to a component or service that determine how that component or service
    behaves and presents data to your application’s user.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example of a local state would be a `Counter` component with a `count`
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `count` property is used to display the current count to the user. The declaration
    and update behavior of the `count` property is handled locally within the current
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Within components, you can consider the state as local when the stateful property
    isn’t shared between multiple smart components and doesn’t need to be persisted
    when you navigate from one page to another.
  prefs: []
  type: TYPE_NORMAL
- en: Within services, the state can be considered local whenever it entails a private
    property that isn’t shared with the outside world, and the property doesn’t have
    to persist longer than the life cycle of the service file. If the property doesn’t
    meet these criteria, you probably need to locate it somewhere within your global
    application state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some common examples of local state within Angular applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Disabled button state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form validity state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modal visibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting and filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accordion state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selected tab state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You now have a good understanding of local state. You know what local state
    is, how you can recognize it, and what the preferred tool is to handle local state
    within your Angular applications. You also learned about some common examples
    of local state. Next, you will learn about global application state.
  prefs: []
  type: TYPE_NORMAL
- en: Global application state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In contrast to local state, global application state refers to the data and
    configurations you share across multiple components and services within an Angular
    application. You can think of your global application state as a centralized repository
    for your data. This centralized repository of information is pivotal in ensuring
    consistency, synchronization, and efficient communication between various application
    parts.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike local state, which is confined to a specific component or service, global
    application state persists throughout the entire application, making it particularly
    useful for scenarios where data needs to be shared and synchronized across different
    components and services, as well as during the whole user session.
  prefs: []
  type: TYPE_NORMAL
- en: Within Angular application, global state is commonly handled inside services.
    By creating a service dedicated to managing global state, developers can ensure
    that components have a centralized access point to crucial information. Services
    that contain global application state are often named *stores*. For example, you
    can call the service to store global user state `user.store.ts` with a `UserStore`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Within smaller Angular applications, state is commonly managed using `Subjects`.
    More specifically, `BehaviorSubject` stores and distributes stateful properties,
    and the regular `Subject` distributes global events. With the introduction of
    Signals, some `BehaviorSubject` classes can be replaced with Signals. We will
    see this in detail in the *Handling global application state using RxJS* section
    when we start building global state management.
  prefs: []
  type: TYPE_NORMAL
- en: For larger Angular applications, libraries such as NgRx, NgXs, Akita, and Angular
    Query are the preferred methods for handling global state. These libraries enhance
    your capabilities to manage the states gracefully and implement structured and
    battle-tested design patterns for managing and updating the global state in a
    predictable and scalable manner.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding when to utilize the global application state is crucial. A global
    state might be more appropriate if a stateful property needs to be shared across
    multiple smart components or persists beyond a single component’s life cycle.
    Now that you know what local and global state are, when to use which, and what
    tools are available to manage both gracefully, let’s learn about some important
    concepts within state management.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamental concepts within state management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To build a robust state management system within your Angular applications,
    you need to understand the fundamental concepts of state management. You need
    to know these concepts, why they are essential, and the dangers of not using them.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn about unidirectional data flow, immutability,
    and side effects. Other important fundamentals for state management include reactivity
    and design patterns such as the Redux pattern, but we already discussed both in
    *Chapters 6* and *7*, so we won’t dive deeper into this.
  prefs: []
  type: TYPE_NORMAL
- en: Unidirectional data flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Unidirectional data flow** is the first concept of state management we will
    discuss. As its name suggests, the concept states that data should only flow in
    one direction throughout your application. Changes to the data occur through well-defined
    actions or events, ensuring a clear and predictable flow of information. Unidirectional
    data flow simplifies debugging, makes code more predictable, and enhances maintainability.
    It prevents unexpected side effects by enforcing a clear flow of data through
    the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Without unidirectional data flow, tracing the origin of state changes becomes
    challenging, leading to debugging difficulties and potential issues with data
    consistency. Uncontrolled data flow can result in unpredictable behavior, especially
    in large and complex applications.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of unidirectional data flow is important throughout your entire
    application and for both local and global application state. For the global application
    state, I recommend always having a unidirectional data flow. Within the local
    component state, you can sometimes make an exception by using Angular two-way
    data binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help you understand how unidirectional data flow looks in an Angular application,
    here’s an example of flow:'
  prefs: []
  type: TYPE_NORMAL
- en: The state is passed from the store to the facade service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The state is passed from the facade service to the smart component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The smart component passes the data to the (dumb) child components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The view is rendered based on the state of the smart component and its child
    components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An action can be triggered in the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The event of the action and the related data move from the (dumb) child component
    up to the smart component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The smart component or facade dispatches an action to the store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The store updates the state based on the dispatched action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The state is passed from the store to the facade.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, the data starts in the store and flows in one direction until
    the view can be rendered. When the user triggers an action within the view, the
    data flows in one direction and in a predictable manner back into the store until
    we reach full circle. Now that you know what unidirectional data flow is and why
    it’s important in state management, let’s learn about immutability.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Immutability** involves the practice of not modifying existing data structures
    directly. Instead, new copies are created with the desired changes, preserving
    the integrity of the original data. Immutability simplifies state management by
    providing a single place to mutate your state. It helps prevent unintended state
    changes and side effects and is particularly valuable when you’re tracking and
    managing complex state in Angular applications.'
  prefs: []
  type: TYPE_NORMAL
- en: With immutability, you may find it easier to track state changes and keep your
    state synchronized. Directly modifying state objects can lead to bugs and unexpected
    behavior. Immutability was mainly used within global state management, but with
    the introduction of Signals, it’s now also applied within the local state of Angular
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Side effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Side effects** refer to an operation or changes you perform when a specific
    piece of your state changes. Side effects can include things such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the local storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dispatching additional actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting local variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By isolating side effects, you can maintain a clear separation of concerns in
    your application. The core application logic (reducers, actions, and selectors)
    remains focused on state changes, while side effects are handled separately. Side
    effects are natively introduced in the Angular framework within the Signals API,
    and they are used in popular state management libraries such as NgRx and NgXs.
  prefs: []
  type: TYPE_NORMAL
- en: So, to summarize, there is local and global state within your applications.
    Local state is localized to components or services, whereas global state affects
    the entire application. Some of the fundamental concepts of state management are
    unidirectional data flow, immutability, and side effects. You learned about the
    advantages of these concepts and why they are important for a state management
    solution. You also learned what state management is and why you need it within
    your applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will start building a global state management solution
    and create a facade service to access the state from within your smart components.
  prefs: []
  type: TYPE_NORMAL
- en: Handling global application state using RxJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will create a simple state management solution using RxJS.
    At the core of this state management solution lies the RxJS `BehaviorSubject`
    class. You will also create a facade service to interact with the state management
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: The facade will do all the communication with the state management solution
    and the smart components. This decouples our smart components from the state management
    solution, making it easy to swap our state management implementation when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve created the RxJS state management solution and connected it with
    the component layer of the application, we can change the state management and
    facade to use Signals where it is possible and makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: By converting the state management solution from RxJS into Signals, you’ll be
    able to understand both concepts and learn about the differences. Building both
    approaches will also serve you best so that you can recognize and work with both
    systems when you encounter them in a project you join. Let’s start by building
    the RxJS state management solution.
  prefs: []
  type: TYPE_NORMAL
- en: Building a state management solution using RxJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start building the state management solution, create a folder named `stores`
    in the `data-access` library of the finance domain. The `stores` folder should
    be located inside the `lib` folder, at the same level as the `adapters`, `HTTP`,
    `models`, and `services` folders.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you can create a service by using the *Nx generator* in the newly created
    `stores` folder. Name the new service `expenses.store`. Because we’re using the
    Nx generator, it will create a file named `expenses.store.service.ts`; you can
    remove the `.service` part manually and do the same for the `spec` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, rename the class `ExpensesStore` instead of `ExpensesStoreService` and
    remove `constructor`; this should be in your file when you’re ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next, you need something that can hold the state for your list of expenses.
    We will use a `BehaviorSubject` class that will emit an array of `ExpenseModel`.
    The `BehaviorSubject` class will be a private property, so you cannot directly
    mutate the state from outside our `ExpensesStore` class.
  prefs: []
  type: TYPE_NORMAL
- en: Only the `ExpenseStore` class should be able to mutate the state directly; all
    other parts of the application should mutate it through `ExpenseStore` and, more
    precisely, through the facade, which will call `ExpenseStore`. Allowing the state
    to be directly mutated from other parts of your application can lead to unintended
    state mutations, breaking your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the `BehaviorSubject` class is private, you also need a public property
    that exposes the `BehaviorSubject` class to the outside world as an Observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we first defined the `expenses` `BehaviorSubject` class, and
    we created the public `expenses$` Observable by taking the `expenses` `BehaviorSubject`
    class and calling the `asObservable()` method on the `BehaviorSubject` class.
    We gave the `expenses` `BehaviorSubject` class an empty array as its default value.
    Next, let’s add some logic to fetch and distribute our data.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching and distributing data in our store
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we’ll add some logic to make an API request that retrieves the expenses
    and emits the received expenses through the `BehaviorSubject` class. To achieve
    this, start by injecting the `ExpensesHttpService` class we created in [*Chapter
    6*](B21625_06.xhtml#_idTextAnchor115):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you need to create a method to make the API request and update the `BehaviorSubject`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we made a method named `fetchExpenses`, and inside this method,
    we used `expensesApi` to make a `get` request. We subscribed to the `get` request
    and handled the `next` and `error` events of the subscription. The `next` error
    is handled when the subscription of the `get` request receives a response, and
    the `error` event is handled whenever the `get` request fails and returns with
    an error status.
  prefs: []
  type: TYPE_NORMAL
- en: If the API request responds successfully, we call the `next()` method on the
    `expenses` `BehaviorSubject` class and give it the received `expenses` as a parameter.
    If the API responds with an error, we simply log the error. In a production application,
    you should handle this better and alert the user with a toaster message or something
    similar.
  prefs: []
  type: TYPE_NORMAL
- en: Adding additional expense methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, you’ll want to add methods to get an expense by ID, as well as update,
    delete, and add expenses. Before you create these methods, `MockInterceptor` must
    be adjusted to handle the `delete` and `getByID` requests. You can modify the
    interceptor yourself or get the adjusted `MockInterceptor` from this book’s GitHub
    repository: [https://github.com/PacktPublishing/Effective-Angular](https://github.com/PacktPublishing/Effective-Angular).'
  prefs: []
  type: TYPE_NORMAL
- en: 'After adjusting `MockInterceptor`, you can start to implement the `add`, `delete`,
    `update`, and `getByID` methods in our expenses store. Inside all these methods,
    we need access to the current list of expenses. You can access the current list
    of expenses through the `value` property of the `expenses` `BehaviorSubject` class.
    Let’s create a getter that retrieves the current expenses from our state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can start adding the methods.
  prefs: []
  type: TYPE_NORMAL
- en: Adding expenses
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s start by creating a method to add an expense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `addExpense` code takes `expense` as a function parameter.
    This `expense` parameter is used to call the `POST` request on `expenseApi`.
  prefs: []
  type: TYPE_NORMAL
- en: When the API returns with the response, we update the `ID` property (we’re only
    updating the `ID` property because we don’t have an actual backend. Normally,
    `ID` would be populated by the backend). After updating the `ID` property, we
    add the newly created `expense` to the `expenses` state.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting expenses
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After creating the `addExpense` method, you can make a method to delete an
    expense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `delete` method is pretty straightforward. We make the API request, and
    when the API responds, we update the `expenses` state with the new list of expenses
    by calling the `next()` method. As a parameter for the `next()` method, we use
    the current list of `expenses` and `filter` out the deleted expenses. If the API
    responds with an error, we log the error, again in a production application, and
    we show some sort of message to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching, getting, and selecting expenses
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After adding the `delete` method, we will add the `getExpense`, `selectExpense`,
    and `fetchExpenseById` methods. The `getExpense` and `selectExpense` methods will
    be public methods, while the `fetchExpenseById` will be private. We will also
    create an `expense` `Subject` class and a `selectedExpense` state using a `BehaviorSubject`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by adding the `Subject` class and the `selectedExpense` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `expense` `Subject` class and `selectedExpense` state can be used to retrieve
    the selected expense reactively. The `selectedExpense` state is used when you
    need to persist the selection in your global application state. In contrast, the
    `expense Subject` class can be used to emit an expense as an event that is only
    received by Observers who are subscribed when the event is emitted. After adding
    the `expense Subject` class and the `selectedExpense` state, we will continue
    with the private `fetchExpenseById` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `fetchExpenseById` method has `id` and `select` parameters. The `id` parameter
    is required, and the `select` property is optional with a default value of `false`.
    The method starts by making an API call to retrieve an expense by ID. When the
    API responds with an expense, we emit a new value using `expense Subject` or emit
    a value and set the `selectedExpense` state using the `BehaviorSubject` class.
    Depending on the needs of your application, you can also add the fetched expense
    to the `expenses` state, but for our demo application, this isn’t necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to finish up the get expense by `id` logic, we need to implement the public
    `getExpense` and `selectExpense` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `getExpense` and `selectExpense` methods are very similar.
    Both methods receive `id` as a parameter and check if the expense with the provided
    `id` parameter can be found inside the current `expenses` state.
  prefs: []
  type: TYPE_NORMAL
- en: When the expense is found in the current state, the `next()` method is called
    on the `expense Subject` class or the `selectedExpense` `BehaviorSubject` class.
    When no expense is found in the current `expenses` state, the `fetchExpenseById`
    method is called to get the expense from the backend; in that case, the `fetchExpenseById`
    method will call the `expense Subject` or `selectedExpense BehaviorSubject` class.
    Now that we’ve added everything to get or select an expense reactively, let’s
    add the `updateExpense` method.
  prefs: []
  type: TYPE_NORMAL
- en: Updating expenses
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `update` method will receive `expense` as a function parameter. Next, it
    will make a `PUT` request using `expensesApi` to update the request in the backend.
    After the API responds successfully, the method will update the `expenses` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we make the API request and use the `next()` method on `expenses
    BehaviorSubject` to update the `expenses` state. As an argument for the `next()`
    method, we take the `currentExpenses` getter and use the `map()` function to replace
    the updated expense.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve added the methods to add, update, delete, and get expenses, let’s
    finish up the store with some additional state and methods to reset the state.
  prefs: []
  type: TYPE_NORMAL
- en: Extending ExpensesStore
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will start by adding an additional piece of state to manage whether we show
    prices, including or excluding VAT. We can do this by creating a new `BehaviorSubject`
    class and a method to adjust the `BehaviorSubject` class’ value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the VAT state is just a simple Boolean indicating whether we
    show the prices, including or excluding VAT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we need some logic to reset our application state and clear the selected
    product state. We will create two different methods for this `resetState` to reset
    all the states to the default values. We’ll use a `clearExpenseSelection` method
    to clear the `selectedExpense` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This was the last piece of the puzzle for our expense store. You created a simple
    yet effective state management solution to handle the global application state
    of the expenses. You did so using the RxJS `Subject` and `BehaviorSubject` classes.
    This `ExpensesStore` can now be used as the single source of truth for all your
    expense data throughout your application.
  prefs: []
  type: TYPE_NORMAL
- en: If a component needs the current state of some expense data, it will come from
    this `ExpensesStore`. When your application grows, and you have other entities
    with a state besides the expenses, such as users, reports, or settings, each entity
    will have a store file to manage the state of that entity.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve created a state management solution using RxJS, we will start
    building the facade service and connect the view layer with the store through
    the facade.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting your state management and view layer with a facade service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have a state management solution in place, it’s time to connect
    it to the view layer of your application. As mentioned several times in this book,
    the best approach is to create a facade service for this. This facade provides
    an additional layer of abstraction, providing a simple interface for your view
    layer to interact with the application state. *Figure 8**.1* provides a visual
    representation of the facade service and how data flows from your state through
    the facade into your components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: Data flow with a facade, components, and state](img/B21625_08_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Data flow with a facade, components, and state'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, your components make a simple request to the facade service,
    and the facade will collect the data from your different state services and send
    it back to the component in the format that the component needs. This ensures
    your components only have one dependency and your facade will host all other necessary
    dependencies to retrieve the data you need in your components.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a facade service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Start by creating a `facades` folder inside the `lib` folder of your `expenses`
    `data-access` library. The new `facades` folder will be located in the same folder
    as the `store` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the new `facades` folder, you must create a file named `expenses.facade.ts`
    with an injectable class called `ExpensesFacade`. You can use the Nx generator
    to create a service and rename it or create the facade manually. Also, add an
    export inside the `index.ts` file so that you can consume the facade outside the
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re finished, you should have the following in the `expenses.facade.ts`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Creating the facade interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, create a file next to the `expenses.facade.ts` file named `expensesFacade.interface.ts`.
    In this interface, we will declare the blueprint of our facade. So long as your
    facade implements this interface, you can switch the implementation of the state
    without touching the component layer. If you change the interface, you also need
    to adjust the component layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the interface file, declare the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining the interface, we can start with the facade service. Start by
    implementing the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you want to inject `ExpensesStore` inside the facade service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve injected the store, we will add a method to fetch the expenses.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the facade with the store
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s add a simple method to the facade that simply calls the `fetch` method
    inside the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a method to get the fetched expenses. But before we do
    this, we will create a new interface called `ExpensesViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can also adjust `ExpenseModel` a bit and rename the `amountExclVat` property
    to `value`. If you’re using VS Code, you can select the property and press *F2*
    to rename it. When you rename using the *F2* key, the property will be renamed
    in every instance (besides the HTML templates).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve created `ExpensesViewModel` and adjusted `ExpenseModel`, let’s
    create the `getExpenses` method inside the facade:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is quite a lot going on in this method. This is one of
    the reasons why using a facade service is beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a large application, the chances are high that you need this `ExpensesViewModel`
    in multiple components. Instead of having to define this chunk of logic in multiple
    component classes, you can define it inside the facade, and inside the component
    layer, you can use a simple function call, keeping your components simple and
    clean. Also, when you need to adjust the logic, you only have to do it in this
    single place instead of in multiple component classes. Now, to better understand
    what we did inside the function, let’s break it down line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: We started by naming the method `getExpenses` and specified that it would return
    an `ExpensesViewModel` Observable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `getExpenses()` method, we returned an Observable using the `combineLatest()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `combineLatest()`, we combined the `expenses$` and `inclVat$` Observables
    from the store and applied the RxJS `pipe()` function to `combineLatest()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `pipe()` function, we applied two operators, starting with the `distinctUntilChanged()`
    operators, so that we only emitted a new value when the values changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we used the `map()` operator to map the two Observable streams into `ExpensesViewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Depending on the state of the `inclVat$` Observable, we returned the expense
    value properties and the total property, including or excluding VAT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you’ve created the `fetch-` and `getExpenses` methods inside the facade,
    let’s adjust the expenses overview page.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the expenses overview page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inside the page component, start by injecting the facade service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After injecting the facade, you can fetch the expenses inside the `ngOnInit()`
    method of the page component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can clean up the component. In [*Chapter 7*](B21625_07.xhtml#_idTextAnchor129),
    we used a Signal with mocked data for `expenses`; in this section, we will use
    the expenses we receive from the `getExpenses` method inside the facade. Start
    by reassigning the `expenses` property, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: After reassigning the `expenses` property, you will get some errors inside the
    component and template file of the expenses overview page because you don’t have
    the `expenses` Signal anymore. Go ahead and remove the `totalInclVat` computed
    Signal; you can also remove the Signal effect in the component and clear out the
    logic inside the `onAddExpense` method.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to make some adjustments to the HTML template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding an `if-else` block around the HTML table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `if` block, you will use the `expenses` property with an `async`
    pipe so that you can retrieve `expenses` from the facade and use those values
    within the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the `if` block, you need to adjust the `for` block inside the
    HTML template and switch the `expenses` Signal for the `expenses` property you
    retrieved from the facade:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'After adjusting the `for` block, you need to adjust the table rows to correctly
    reflect the new model structure and to improve the UI. Do this by rounding the
    value to two decimals, and then adding a `currency` pipe and percentage (`%`)
    sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, you need to switch the `totalInclVat` computed Signal we used inside
    the template for the `total` property on `expensesVm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, we adjusted the text to `total` because we now show the total, including
    or excluding VAT, depending on the global state. After making these adjustments,
    you should see the total amount and expenses inside the table again, only now
    using RxJS and the global state instead of the Signals with mocked `expenses`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you want something to toggle the VAT so that you can see the expenses
    and total amount being automatically updated when the VAT status changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding a new method inside the facade service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is just a simple method calling the `adjustVat` method
    inside the store. This will change the `inclVat` `BehaviorSubject` class inside
    the store. This, in turn, will trigger the `combineLatest()` method we used inside
    the `getExpenses` method inside the facade.
  prefs: []
  type: TYPE_NORMAL
- en: So, when you change the VAT status, `ExpensesViewModel`, which we retrieved
    through the `getExpenses` method, will automatically be updated and show the total
    and expense amounts, including or excluding VAT, depending on the state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve added the method to adjust the VAT, you also need something to
    retrieve the `inclVat` status inside the facade. You can simply create a property
    for this and assign it with the `inclVat$` Observable from the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the method and property to adjust and retrieve the VAT status,
    let’s add a toggle inside the HTML template of the expenses overview page to adjust
    the VAT state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: I’ve added the VAT toggle next to the `inclVatSelector$` from the facade combined
    with an `async` pipe to set the `checked` property of the VAT toggle.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve also added a `click` event to the `input` value of the toggle to call
    the `adjustVat` method in the facade. If you click on the toggle, you will see
    the expense amounts in the table and the total amount in the table summary change
    to include or exclude the VAT amount, depending on the VAT state.
  prefs: []
  type: TYPE_NORMAL
- en: As you might have noticed, this is a very reactive approach because everything
    reacts upon the state changes automatically. The code is also very performant
    because the updates are performed in a non-blocking manner, allowing all your
    code to keep running.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve implemented the `getExpenses` method and the VAT status, let’s
    finish up the facade service.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing up the facade service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For all the other methods exposed by the store, you can add simple methods inside
    the facade service that call them from the store, similar to what we did with
    the `fetchExpenses` and `adjustVat` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `selectedExpense` and `expense` properties inside the store, you need
    to add a selector property inside the facade service. Because we will also map
    the expenses emitted by `selectedExpense` and `expense`, we will abstract the
    mapping behavior into a new function so that we can reuse it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can adjust the mapping of the expenses inside the `getExpenses` method
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we will add the selector properties for `selectedExpense` and `expense`,
    starting with `expenseSelector$`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, for `expenseSelector$`, we used the `withLatestFrom()` operator
    and didn’t use `combineLatest()`. We did this because `expenseSelector$` will
    only emit a value as an event using the `Subject` class instead of `BehaviorSubject`.
    There is no state here, and we don’t want the selector to emit a new value when
    the VAT toggle changes. We only want it to respond when the `expense` `Subject`
    class emits a value, and when that happens, take the current value of the `inclVat$`
    Observable to map the expense.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `selector` property for `selectedExpense` will use the `combineLatest()`
    function to combine the `selectedExpense$` Observable and the `inclVat$` Observable,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: For `selectedExpenseSelector$`, we used the `combineLatest()` function because
    the selected expense is stateful and persists in our store. We might use the selected
    expense in our view while we can change the VAT, and because of that, we want
    it to react when the VAT status changes and update the amount in the view. Because
    we want `selectedExpense` to be reactive on the VAT status as well, we used the
    `combineLatest()` operator, which triggers whenever one of the combined Observables
    emits a new value.
  prefs: []
  type: TYPE_NORMAL
- en: This was the last part of implementing the state management solution using RxJS.
    This approach to state management is commonly used within smaller Angular applications
    where the state isn’t used in many different components and services. The solution
    offers good reactivity and is easy to build and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to convert this state management solution so that it uses
    Signals instead of RxJS. Using Signals will simplify your facade service and component
    layer. It also allows Angular to perform better change detection. If you need
    to combine many data streams with tailored logic and apply modifications to them,
    the RxJS approach will fit your application better.
  prefs: []
  type: TYPE_NORMAL
- en: That said, using Signals is much simpler for simple state and data streams.
    Even if you need to combine some data streams without needing to have too much
    control over how this happens, the Signal approach will be best suited for you.
    Signals are the way to go for your state if you find yourself only using `combineLatest()`
    and `withLatestFrom()` and some basic operators such as `map()` and `filter()`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling global application state using Signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To convert your state management solution so that it uses Signals instead of
    RxJS, you must change the `BehaviorSubject` classes in the `ExpensesStore` to
    Signals. You still want to ensure that the state only emits a new value when it’s
    set in the store; you don’t want to be able to set the state outside of the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we will create a private `WritableSignal` and a public Signal
    that is read-only. You can change all the `BehaviorSubject` classes to Signals
    using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, we declared a private Signal using the `signal()` function. Declaring
    a Signal in this manner will create `WritableSignal`. In the line after, we created
    a public property and assigned it with `WritableSignal` but cast it to a `Signal`
    type with the `as` keyword; here, the `Signal` type is read-only. After adjusting
    all your `BehaviorSubject` classes, you need to change the references you had
    to them inside the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by removing the `currentExpenses` getter and change all instances of
    `this.current` **Expenses** to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, inside the `adjustVat()` function, change `!this.incluVat.value` to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, you need to adjust all instances where you used the `next()` method
    on one of your `BehaviorSubject` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how to convert the `resetState()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now, change all other instances of the `next()` method to the `Subject` class
    and the `set()` method. That’s all we need to do for `ExpensesStore`; you now
    have state management that uses Signals instead of RxJS `BehaviorSubject` classes.
    After adjusting the state, we need to change `ExpensesFacade` so that it can work
    with Signals instead of Observables.
  prefs: []
  type: TYPE_NORMAL
- en: Normally speaking, one of the advantages of a facade service is that it is an
    abstraction layer, and we don’t need to touch the component layer when changing
    the state management solution. But in this situation, we need to adjust both the
    facade service and the component layer; this is because we will be changing the
    interface of the facade service.
  prefs: []
  type: TYPE_NORMAL
- en: In theory, we could maintain the interface and still return Observables by converting
    the Signals back into Observables in the service; doing so would allow you to
    leave the component layer untouched. However, we want to utilize the full power
    of these Signals and also implement them in our components so that Angular can
    perform better change detection and we can make our templates synchronous. To
    achieve this, we need to return Signals from our facade service instead of Observables,
    changing the interface of the facade.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start changing the facade by changing the interface. Replace the `getExpenses`
    method inside the interface with an `expenses` property and adjust the `selectedExpenseSelector$`
    and `inclVatSelector$` properties like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'After making the preceding adjustments in the interface, you can start implementing
    the interface inside the facade service. To implement the changes in the interface,
    remove the `getExpenses` method. Instead of the `getExpenses` method, you must
    create a computed Signal that returns the same value as the `getExpenses` method
    did:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the computed Signal is very similar to the `getExpenses` method.
    The main difference is that we no longer need the `combineLatest()` and `map()`
    operators. We can now use the `inclVat` and `expenses` Signals inside the computed
    Signals.
  prefs: []
  type: TYPE_NORMAL
- en: When one of the two Signals receives a new value, the computed Signal will automatically
    compute a new one. The computed Signals can be seen as `combineLatest()` of the
    Signals realm. The equivalent of `withLatestFrom()` would be using a Signal inside
    the computed Signal and wrapping the Signal using the `untracked()` function,
    as we discussed in [*Chapter 7*](B21625_07.xhtml#_idTextAnchor129).
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the computed Signal, we need to implement the `inclVat` and `selectedExpense`
    Signals inside the facade service. This is pretty straightforward – you simply
    define the property and assign it with the Signal from `ExpensesStore`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we assign the property with the Signal from the store; we do not call
    the Signal by adding function brackets, `()`. We don’t add these function brackets
    because we want to use the actual Signal inside the component layer, not the `Signal`
    value. If you were to call the Signal here and retrieve the value inside the component
    layer, the update behavior wouldn’t work as expected, and the view wouldn’t be
    updated when your state changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to do is adjust `ExpensesOverviewPageComponent` and its template.
    Inside the component class, you can adjust the `expenses` property and assign
    it with the `expenses Subject` class from the facade instead of the `getExpenses()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the HTML template, you need to change `inclVatSelector$` to `inclVat()`,
    remove the `async` pipe, and change `expenses` with the `async` pipe to `expenses()`
    without the `async` pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding changes, you’ve adjusted the component class and the HTML
    template to use Signals instead of Observables. As you can see, using the Signal
    approach is slightly simpler and needs fewer lines of code. It also makes your
    HTML template synchronous and helps Angular to perform better change detection,
    leading to better performance.
  prefs: []
  type: TYPE_NORMAL
- en: The flip side is that you have less control over the data streams, and it’s
    not as easy to modify the stream before it reaches your application logic. Compared
    to RxJS, Signals also offers less control when you want to combine different streams
    of data, so depending on your needs, you can decide whether to use Signals or
    RxJS.
  prefs: []
  type: TYPE_NORMAL
- en: You can also make a hybrid solution and convert Observables into Signals, giving
    you the best of both worlds. In that case, you can use the RxJS operators you
    need and still consume the values as Signals in your component classes and HTML
    templates.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you’ve learned how to create a state management solution using RxJS
    and Signals. You made a facade service as an additional abstraction layer and
    learned when you have to change the component layer and when you only have to
    change the state management layer when working with a facade service.
  prefs: []
  type: TYPE_NORMAL
- en: Both state management solutions we’ve created work well for small applications
    with relatively simple global states. The RxJS method is implemented a lot, and
    with the popularity of Signals, I imagine the Signal approach will be implemented
    a lot as well. But when you have a larger application where the state is used
    in a lot of components and services, you will run into issues with our current
    implementation. In the next section, you will learn about these issues and how
    to resolve them.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with using RxJS or Signals for global state management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While our current state management solution is used in many applications and
    works well for our current application, there’s a huge problem: our current global
    state management solution isn’t immutable.'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot modify your `BehaviorSubject` classes or Signals from outside the
    store, so in that sense, it is immutable. Also, when using primitive values for
    your state, the state itself is immutable. However, when you’re using reference
    objects as values for your `BehaviorSubject` classes or Signals, the state itself
    isn’t immutable.
  prefs: []
  type: TYPE_NORMAL
- en: When you use an array or object for your state and retrieve the state through
    `BehaviorSubject` or `Signal`, you can modify the value of the state unintentionally.
    When you adjust the retrieved state object within a component or service class,
    the value of `BehaviorSubject` or `Signal` is also modified!
  prefs: []
  type: TYPE_NORMAL
- en: This is also the reason why we used the `structuredClone()` function inside
    our `mapExpenses()` function. If you remove `structuredClone()` and toggle the
    VAT a couple of times in the view, you will notice that the amounts keep increasing
    instead of adding and removing the VAT. This happens because we modify the object
    inside `Signal` or `BehaviorSubject` whenever we adjust it inside the facade service.
  prefs: []
  type: TYPE_NORMAL
- en: The next time we retrieve the state, it still has the adjusted values instead
    of the real state we expect. Relying on developers to always clone the object
    when it’s modified is risky and not how you want it to be.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing your state to be modified outside the store and without calling the
    `next()` or `set()` method on `BehaviorSubject` or `Signal` opens the door for
    unintended state changes, resulting in a corrupted state. When your state is not
    what you expect it to be, you can display incorrect values to the user and perform
    actions within your code that aren’t intended.
  prefs: []
  type: TYPE_NORMAL
- en: For small applications where the state isn’t used in many places, this might
    be a manageable problem, but when your application grows, your state is used in
    multiple places and often the retrieved state is modified locally, so the problem
    will surface quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have a state management system that is truly immutable, reactive, and can
    handle the state of any application no matter how large it becomes, your best
    bet is to go with a good library that focuses on state management. Some popular
    choices within the Angular community are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: NgRx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NgXs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxAngular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Akita
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular Query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these libraries have their advantages and disadvantages. My personal
    favorites are RxAngular, NgXs, and NgRx. NgRx is by far the most commonly used
    state management solution within the community and offers support for Observable
    and Signal-based state management. RxAngular is gaining a lot of popularity and
    has a very intuitive approach for reactively managing state with little to no
    boilerplate code; it also enables you to ditch ZoneJS and boost the performance
    of your application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will convert our state management solution into an NgRx
    state management solution. I’ve picked NgRx because this is the most commonly
    used solution, but I recommend that you investigate some of the other solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Handling global application state with NgRx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working on enterprise software or an application with extensive or complex
    state management, you should use a battle-tested state management solution that
    provides true immutability, unidirectional data flow, and good tools to perform
    side effects and modify the state securely. The best way forward is to use a battle-tested
    library that focuses on state management.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most commonly used library for state management within the Angular community
    is **NgRx**; it has a huge community and all the tools you might need to handle
    even the most complex state. NgRx implements the Redux pattern and consists of
    four main building blocks: actions, reducers, selectors, and effects.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will change our custom-made state management solution so
    that it uses NgRx. We will keep the store file we made in the previous section
    for reference purposes and build the NgRx state management in new files.
  prefs: []
  type: TYPE_NORMAL
- en: In a production environment, you should remove the old unused store file. Inside
    the facade service, we will simply replace the current implementation with the
    NgRx implementation, and this time, we will not adjust the `IExpensesFacade` interface,
    meaning we do not have to change our component layer. Let’s go over the step-by-step
    process of implementing NgRx state management.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the @ngrx/store and @ngrx/effects packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start implementing NgRx state management, you need to install some packages
    by running the following `npm` commands in the root of your *Nx monorepo*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: After installing the `@ngrx/store` and `@ngrx/effects` packages, you need to
    create some folders and files. There is an Nx generator to create the initial
    setup for your NgRx store, but we will set up everything manually so that you
    get a better understanding of how everything works and what’s needed when using
    NgRx.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a folder named `state` inside the `lib` folder of the expenses
    data-access library (next to the `stores` folder). Inside the newly created `state`
    folder, create another folder named `expenses`. Now, inside the newly created
    `expenses` folder, create these five files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`expenses.actions.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expenses.reducers.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expenses.selectors.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expenses.effects.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you’re done creating the folders and files, you can start adding some actions
    inside the `expenses.actions.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: Defining your first NgRx actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`createAction()` function, which the `@ngrx/store` package exposes to you.'
  prefs: []
  type: TYPE_NORMAL
- en: You must provide the `createAction()` function with a description of the action
    and, optionally, with a `props()` function to define the properties you have to
    provide the action with to perform the action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can use the `createActionGroup()` function to create multiple
    events and group them under a single constant. We won’t use the `createActionGroup()`
    function, but you can always read about it yourself in the official NgRx documentation:
    [https://ngrx.io/docs](https://ngrx.io/docs).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start with a simple task: defining an action to fetch the expenses from
    the API. You don’t have to provide any argument to fetch the expenses, so the
    action will only contain a description. The descriptions of NgRx actions commonly
    use the following naming conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `expenses.actions.ts` file, define the action to fetch expenses,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Commonly, when defining NgRx actions that include API requests, you also define
    a success and failure action. So, go ahead and define an action for when fetching
    the expenses succeeds or fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here, we declared two actions; both received a description, and the `fetchExpensesSuccess`
    action also received the `props()` function. Inside the arrow brackets, we defined
    the type of the `props()` function – in this case, an object with an `expenses`
    property containing an `ExpenseModel` array. The `fetchExpensesSuccess` action
    needs `expenses` as `props()` because we will use the `fetchExpensesSuccess` action
    to update the state with the expenses that are retrieved from the API request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve added the `fetchExpenses`, `fetchExpensesSuccess`, and `fetch`
    **ExpensesFailed** actions, let’s update the `index.ts` file inside the `state/expenses`
    folder by defining an export for our expense actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: After adding the export to the `index.ts` file, we can move on to the next piece
    of the puzzle. The next step is to create an NgRx effect that will make an API
    request to fetch the expenses and dispatch the success of the failed action accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first NgRx effect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will create your `expenses.effects.ts` file. Effects allow you to perform
    side effects when an action is dispatched. Effects are commonly used for tasks
    such as fetching data, dispatching other events, or updating local storage. Side
    effects isolate some logic away from your components, allowing you to keep the
    component classes as simple as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The first effect you will create is the `fetchExpeses$` effect. This effect
    will run whenever the `fetchExpenses` action is dispatched. The effect will then
    make an API request to fetch the expenses and map the result of the API call into
    a newly dispatched action – the `fetchExpensesSuccess` or `fetchExpensesFailed`
    action.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, create an injectable class inside the `expenses.effects.ts`
    file named `ExpensesEffects`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the `ExpensesEffects` class, you need to inject the `Actions`
    class from `@ngrx/effects` and `ExpensesHttpService` inside your `ExpensesEffects`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use the `createEffect()` function that’s exposed by `@ngrx/effects` to
    create your first effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, you created your first effect named `fetchExpenses$`.
    As you can see, there is quite a lot going on there, so let’s break it down line
    by line.
  prefs: []
  type: TYPE_NORMAL
- en: We started by defining a property named `fetchExpenses$` and assigned it with
    the `createEffect()` function. Inside the `createEffect()` function, we defined
    a `callback` function that returns the `this.actions.pipe()` method. The `this.actions`
    instance refers to the `Actions` class we injected in the previous code block.
    The `Actions` class emits the actions we dispatched and extends the Observable
    class, meaning you can use the RxJS `pipe()` function on the class.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `pipe()` function’s chained-on actions, we defined a couple of operators,
    starting with the `ofType()` operator. The `ofType()` operator is a filter operator
    that filters out actions by the action type. Inside the function brackets of the
    `ofType()` operator, you defined the type of an action. In our case, we provided
    it with the type of our `fetchExpenses` action. Here, `ExpenseAction` is used
    to export and import our actions, `fetchExpenses` is the property name we gave
    our action, and `type` is a property that’s exposed on all the actions we created
    with the `createAction()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the `fetchExpenses` action is dispatched, we will move on to the next
    operator inside the `pipe()` function of our effect. The next operator is the
    `switchMap()` operator, which is used to flatten the additional Observable stream
    that was created by the HTTP request to fetch the expenses.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the callback of the `switchMap()` operator, we made the HTTP request
    and added an additional `pipe()` function to the HTTP request. Inside the `pipe()`
    function of the HTTP request, we used the `map()` operator to map a successful
    HTTP response to the `fetchExpensesSuccess` action, and we provided the `fetchExpensesSuccess`
    action with the expenses that were retrieved from the API response. If the API
    request fails, we use the `catchError` operator to map it to the `fetchExpensesFailed`
    action.
  prefs: []
  type: TYPE_NORMAL
- en: The `createEffect()` function will automatically dispatch the returned action;
    this is why we don’t have to call the `dispatch()` function explicitly but simply
    return an Observable with the action we want to dispatch. In our case, this is
    the `fetchExpensesSuccess` or `fetchExpensesFailed` action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, you need to export the effects inside the `index.ts` file inside the
    `state/expenses` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve defined the actions and created an effect to handle the `fetchExpenses`
    action and dispatch the `fetchExpensesSuccess` and `fetchExpensesFailed` actions,
    let’s cover the next building block of our NgRx state by creating our state and
    reducer functions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your initial state and first reducer functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve created some actions and your first effect, you need a state
    to perform these actions on and `expenses.reducer.ts` file, you will define your
    initial state object and reducers to adjust the state when actions are dispatched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new interface for your state object inside the `expenses.interface.ts`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the interface, you can create your initial state object inside
    the `expenses.reducer.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: After defining the interface and initial state object, you can create the reducer
    by using the `createReducer()` function. The `createReducer()` function takes
    in your initial state as a parameter and reduces your state based on dispatched
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by defining the reducer function and providing it with the initial
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we created a property named `expensesReducer`
    and assigned it to the `createReducer()` function. Inside the arrow brackets,
    we provided the type the reducer will modify; in our case, this is the `ExpensesState`
    interface. Inside the function brackets, we provided the initial state object,
    `initialExpensesState`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need to add functions inside the `createReducer()` function to update
    the state when an action is dispatched, starting with the `fetchExpenses` action.
    To update the state, you must define an `on()` function and provide the `on()`
    function with a reference to the action it needs to react on, as well as a `callback`
    function to modify the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’ve added an `on()` function underneath the initial state object inside
    the `createReducer()` function. We provided the `on()` function with `ExpenseActions.fetchExpenses`
    so that it reacts when `fetchExpenses` actions are dispatched.
  prefs: []
  type: TYPE_NORMAL
- en: After the reference to the action, we declare a `callback` function to modify
    the state. Inside the function brackets of the `callback` function, you can define
    a parameter that will be populated with the current state object for you; it’s
    the convention to name this parameter `state`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we return a new state object by spreading the current state into the
    object and setting the state properties we want to change. In the case of the
    `fetchExpenses` action, we only want to set the `isLoading` state property to
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can add the reducer function for the `fetchExpensesSuccess` and `fetch`
    **ExpensesFailed** actions underneath the `reducer` function for the `fetchExpenses`
    action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’ve declared two more `on()` functions and provided them with the `fetchExpensesSuccess`
    and `fetchExpensesFailed` actions. Inside the function brackets of the `callback`
    function of the `fetchExpensesSuccess` action reducer, we used destructuring to
    extract the `expenses` object from the dispatched action. As you might remember,
    you defined the `fetchExpensesSuccess` action to take the expenses that were fetched
    from the API request as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, inside the `callback` function, we updated the `expenses` property of
    the state, set `isLoading` to `false`, and set `error` to `null`. If we fetch
    the `expenses` property successfully, there will be no errors to show to the user.
  prefs: []
  type: TYPE_NORMAL
- en: For `fetchExpensesFailed`, we don’t provide parameters when we dispatch the
    action, so we only provide the state object in the callback, just like we did
    with the `fetchExpenses` action reducer. Inside the callback of the `fetchExpensesFailed`
    reducer, we set `isLoading` to `false` and set an error message.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you’ve created your initial state and a `reducer` function for each
    of the actions you defined. When the `fetchExpenses` action is dispatched, you
    use a `reducer` function to set the `isLoading` state to `true`. When you’re done
    fetching, and the `fetchExpensesSuccess` or `fetchExpensesFailed` action is dispatched,
    you use a `reducer` function to set the `isLoading` state to `false` and update
    the `expenses` or `error` state accordingly. You can use the `isLoading` state
    to show a spinner, the `error` state to show an error message, and `expenses`
    to display your list of expenses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, underneath `expensesReducer`, you need to define a unique key for the
    expenses state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'As a last step, you need to add the reducer file inside the `index.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'After exporting the file inside the `index.ts` file, your reducer file is ready.
    Before moving on to the last building block of NgRx state management, which is
    selectors, we will add our reducer to the `ApplicationConfig` object of our `expenses-registration`
    app. Inside the `app.config.ts` file, add the following inside the `providers`
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we added the `provideStore()` function and the `provideState()`
    function inside the `providers` array. Inside the `provideState()` function, we
    added an object with a name and a `reducer` property. The name receives the unique
    key we provided inside the reducer file and the `reducer` property receives the
    `expensesReducer` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve created the reducer and added the configuration inside the
    `ApplicationConfig` object, it’s time to move on to the last part of our NgRx
    state: selectors.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining NgRx selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`expenses` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we used a `createFeatureSelector()` function and provided it with the
    key we declared inside the `expenses.reducer.ts` file. Next, we can define additional
    selectors with the `createSelector()` function to retrieve specific parts of the
    `expenses` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we declared three additional selectors – one
    to retrieve the `expenses` state, one to retrieve the `error` state, and one to
    retrieve the `isLoading` state. To finish the selectors, let’s export the file
    inside the `index.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding this `export`, also export the `index.ts` file from your `state`
    folder; this can be found in the `index.ts` file of the `data-access` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have all the parts of our NgRx state management system in place,
    it’s time to adjust the facade services.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the facade service so that they use NgRx state management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will adjust the `fetchExpenses` method and the `expenses` Signal inside
    the facade service. We haven’t created actions, effects, reducers, and selectors
    for all the other properties yet. To convert the facade service, we need to start
    by injecting the `Store` class, which is exposed to you by the `@``ngrx/store`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'After injecting the `Store` class, we can adjust the `fetchExpenses` function
    in the facade service. Simply remove `this.expensesStore.fetchExpenses()` inside
    the `fetchExpenses` function and dispatch the `fetchExpenses` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Here, you used the `Store` class and called the `dispatch()` function on it
    to dispatch an action. After adjusting the `fetchExpenses()` method, it’s time
    to adjust the `expenses` computed Signal.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this computed Signal, we’re using the `expenses` `Subject` class from
    the store. We need to change this for a Signal based on `expenses` from your NgRx
    state.
  prefs: []
  type: TYPE_NORMAL
- en: To adjust the `expenses` computed Signal, you need to create a new property
    to retrieve the `expenses` state from the NgRx state and transform it into a Signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can retrieve `expenses` from the NgRx state through the `selectExpenses`
    selector using the `select()` method on the `Store` class. Using the `select()`
    method on the `Store` class combined with our selector will return the `expenses`
    state as an Observable, so we need to use the `toSignal()` function to transform
    it into a Signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the `expenses` state from the NgRx state as a Signal inside
    the facade service, we can adjust the `expenses` computed Signal so that it uses
    `expenses` from the NgRx state instead of `expenses` from the store. Simply replace
    the `this.expensesStore.expenses()` instances inside the computed Signal with
    `this.expensesSignal()` and that’s it.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you’ve changed everything you need to change and are fetching and
    retrieving the `expenses` state through the NgRx actions and state. Before moving
    on, let’s add one more piece of NgRx state together so that you can understand
    everything that’s going on in NgRx state management.
  prefs: []
  type: TYPE_NORMAL
- en: Adding additional actions, effects, reducers, and selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get a better grasp of the NgRx state management we’ve built, let’s extend
    it a bit with additional actions, effects, reducers, and selectors.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by adding an action to adjust the `inclVat` state, just like we
    did before, by adding an action. Because the `inclVat` state only entails a state
    change and no HTTP request, you only need an action to adjust the `inclVat` state
    and no success and failed actions because you aren’t making an HTTP request that
    can succeed or fail. The action to adjust the `inclVat` state also doesn’t need
    a parameter because we will simply change the state to what it currently isn’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can simply create an action and provide it with a description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: No effect is needed for the `inclVat` state change because you don’t perform
    an HTTP request or need to dispatch additional actions. However, you do need a
    new reducer function inside the `expensesReducer` to adjust the state object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `createReducer()` function of `expensesReducer`, add an additional
    `on()` function to change the `inclVat` state when the `adjustVat` action is dispatched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, upon dispatching the `adjustVat` action, we will change the
    `inclVat` state to what it currently isn’t. After adding the `reducer` function,
    you need to add a selector to retrieve the `inclVat` property from the state object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Now, the only thing that is left to do is adjust the facade service and use
    the `inclVat` property from the NgRx state instead of the Signal in `expenses.store.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To adjust the facade service, start by adding an `inclVat` property and use
    the `toSignal()` function to convert the `selectInclVat` selector into a Signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: After adding the `inclVat` property, all you have to do is change `this.expensesStore.inclVat()`
    to `this.inclVat()` inside the `expenses` computed Signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, you need to adjust the `adjustVat()` function inside the facade service.
    Remove what is currently in the function and replace it with a dispatch of the
    `adjustVat` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: After adding the preceding code, you’ve made all necessary changes and you’re
    now using the `inclVat` property from the NgRx state instead of the Signal from
    `expenses.store.ts`. Now, all you need to do is add the rest of the actions, effects,
    reducers, and selectors so that you can remove the store from the facade service
    entirely and use the NgRx state for everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an exercise, you can try to add the additional actions, effects, reducers,
    and selectors yourself based on what we did for the list of expenses. After adding
    the additional actions, effects, reducers, and selectors, you should be able to
    fully adjust the expenses facade and remove the store implementation completely.
    If you get stuck or simply want to copy the code, you can get it from this book’s
    GitHub repository: [https://github.com/PacktPublishing/Effective-Angular](https://github.com/PacktPublishing/Effective-Angular).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you explored NgRx and learned how to use it to manage the state
    of your application. We discussed the default NgRx implementation to manage the
    state. Note that the library has more solutions and packages to offer, but this
    is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the other things NgRx has to offer are `signalStore` and `signalState`,
    two solutions that you can use to manage your state using NgRx and signals without
    having to convert Observables using `toSignal()`, which is what we did in this
    section. There are useful RxJS operators in the NgRx library. We only used the
    `ofType()` operators, but NgRx offers more utility operators, such as `concatLatestFrom()`
    and `tapResponse()`.
  prefs: []
  type: TYPE_NORMAL
- en: NgRx also offers solutions to manage component state and to dispatch actions
    of access state on route changes. I highly recommend exploring NgRx and other
    state management libraries on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve learned a lot in this chapter and brought everything we learned in [*Chapter
    7*](B21625_07.xhtml#_idTextAnchor129) together. You learned what state management
    is and why you need a good state management solution. You also learned about immutability,
    unidirectional data flow, and side effects. After some theory, you started building
    a state management solution using RxJS’s `BehaviorSubject` and `Subject` classes.
  prefs: []
  type: TYPE_NORMAL
- en: When you finished building the state management solution using RxJS, you created
    a facade service that connects your component layer to the data-access and state
    management layers of your application. To end your custom state management solution,
    you converted the RxJS state implementation into a Signals implementation, further
    simplifying your component layer and facade service.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned about the shortcomings of using RxJS and Signals for your
    state management solution and replaced them with an NgRx implementation that uses
    actions, effects, reducers, and selectors.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn how to improve the performance and security
    of your Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Part 3:Getting Ready for Production with Automated Tests, Performance, Security,
    and Accessibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last part, you’ll learn how to improve the performance of your Angular
    applications and make them more secure and accessible for everyone. Starting with
    performance, you’ll do a deep dive into Angular’s change detection mechanism,
    learning how Angular detects changes and what actions you can take to reduce the
    number of change detection cycles. When you know how change detection works in
    detail, you’ll learn how to prevent other factors from impacting the performance
    of your Angular applications. Then, you will explore some common security risks
    when developing Angular applications and how to mitigate them. Furthermore, you’ll
    dive into accessibility, making your application content translatable using Transloco
    and learning how to develop applications accessible to users from different locations
    and abilities. Additionally, you’ll learn how to write and run unit tests using
    Jest, and end-to-end tests using Cypress, giving you the confidence to deploy
    your changes without breaking anything. Finally, you’ll make some final improvements,
    learn how to analyze and optimize your bundle sizes, and automate your deployment
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B21625_09.xhtml#_idTextAnchor170), *Enhancing the Performance
    and Security of Angular Applications*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B21625_10.xhtml#_idTextAnchor185), *Internationalization, Localization,
    and Accessibility of Angular Applications*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B21625_11.xhtml#_idTextAnchor200), *Testing Angular Applications*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B21625_12.xhtml#_idTextAnchor219), *Deploying Angular Applications*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
