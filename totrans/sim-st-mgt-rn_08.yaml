- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrating Jotai in a React Native App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we ventured into the mathematical world of **XState**.
    We will continue our journey by exploring another young state management library
    called **Jotai**. **Jotai** is inspired by an experimental state management library
    created at **Facebook** called Recoil. In this chapter, we will take a brief look
    at **Recoil**, an experimental state management library created by Facebook. Once
    we’re comfortable with the main ideas of this library, namely a new concept called
    an “atomic state”, we will take a deep dive into **Jotai**. We will configure
    Jotai in our app, and we’ll continue to work on data fetching and managing liked
    images with the help of **Jotai**. Here’s what we will go over in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is **Recoil** and an atomic state?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is **Jotai**?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring **Jotai** in the Funbook app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `FavoritedImages`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a new way of looking at global state
    management – by dividing it into small items, called **atoms**. You will also
    know how to set up **Jotai** in a new project, and how to use it for data fetching
    and data management.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to follow along with this chapter, you will need some knowledge of
    **JavaScript** and **ReactJS**. If you have followed at least *Chapters 1 to 4*
    of this book, you should be able to proceed without any issues.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to use an IDE of your choice, as **React** **Native** does not need
    any specific functionality. Currently, the most popular IDEs for frontend developers
    are Microsoft’s VSCode, Atom, Sublime Text, and WebStorm.
  prefs: []
  type: TYPE_NORMAL
- en: The code snippets provided in this chapter are here to illustrate what we should
    be doing with the code. They do not provide the whole picture. To code along easier,
    please open the GitHub repo in your IDE and look at the files in there. You can
    either start with the file in the folder named `example-app-full` or `chapter-8`.
    If you start with `example-app-full`, you will be responsible for implementing
    the solutions described in this chapter. If you choose to look at `chapter-8`,
    you will see the entire solution implemented by me.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you get stuck or lost, you can check the code in the GitHub repo: [https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-8](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-8).'
  prefs: []
  type: TYPE_NORMAL
- en: What is Recoil and an atomic state?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’ve been following this book chapter by chapter, you may be feeling as
    though the list of different types of state management libraries is never-ending.
    You would be right, to some extent. New state management libraries pop up every
    few weeks; they are sometimes purely open source, and sometimes company-backed.
    However, they rarely propose groundbreaking solutions. More often than not, they
    are newer implementations of known concepts. Those implementations are greatly
    appreciated, as every developer likes working comfortably – and what are those
    known concepts, you may ask?
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a consensus in the **ReactJS** world that state management libraries
    can be divided into three types:'
  prefs: []
  type: TYPE_NORMAL
- en: Flux type – these are state management libraries that hold the state outside
    of components and use a unidirectional data flow. They are inspired by **Facebook’s
    Flux**, the most famous example being **Redux**. There are modern implementations
    of this flow, such as **Redux Toolkit** or **Zustand**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Proxy type – these libraries “wrap” the state, conceptually similar to what
    a proxy does. When using this type of state management, the developer can subscribe
    to, and read, wrapped values like any other values in the component. The best
    examples of proxy-type state management are **React’s Context**, **MobX**, or
    **Valtio**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Atomic type – this is the state set at the lowest level, managed naturally by
    `setState` in class components and the `useState` hook in function components.
    Values set in this way can be passed around the app and used in a bigger context.
    **Facebook** created an experimental library to promote this type of state management,
    called **Recoil**. **Jotai** soon followed suit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Recoil** was created around mid-2020 and quickly garnered lots of attention.
    It was published by Facebook itself, the creators of React, so everyone was expecting
    a great new solution. The idea of using the smallest possible denomination of
    pieces of state, peppered and accessible throughout **React** apps, was enticing.
    Unfortunately, after the first gasp of excitement, a big part of the React community
    lost interest in **Recoil** and went about their days continuing to work mostly
    with Redux. Two years later, **Recoil’s** documentation still states that it’s
    experimental and few people are talking about it.'
  prefs: []
  type: TYPE_NORMAL
- en: A small community of developers was paying more attention than the rest of us
    though. *Poimandres*, an open source developer collective, went to work and created
    their implementation of an atomic state. They called it **Jotai**. If you visit
    their GitHub page, you will see they also developed **Valtio**, a proxy-type state
    management library, and **Zustand**, a lightweight flux-type state management
    library. **Valtio** and **Zustand** are so far in the shadow of their more famous
    alternatives, but **Jotai** has dominated the stage for atomic state management.
    This library is production-ready; it’s being actively developed through **GitHub**,
    and its developers provide constant support on an open Discord server. This is
    why we will talk about **Jotai**, and not **Recoil**, in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: What is Jotai?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in the previous section, `useState`) or externally. Daishi is
    continually working on new things; you can observe all his work in the *Jotai
    Labs* **GitHub** repo: [https://github.com/jotai-labs](https://github.com/jotai-labs).
    He’s also interested in developing features for fetching and **React’s Suspense**.
    You can find more links to his projects in the *Further* *reading* section.'
  prefs: []
  type: TYPE_NORMAL
- en: We now have a good understanding of why Jotai was created. It aims to solve
    state management problems from a new perspective, following React’s best practices
    and concepts proposed by the experimental Recoil library. It’s time we try this
    “atomic” state approach in our app. Let’s get to coding!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Jotai in the Funbook app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you’re a fan of simplicity, my dear reader, you may just fall in love with
    this state management library. Configuring it in our app only requires running
    the `install` command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s one hidden gem of configuration to be added: Suspense. I specifically
    used the word gem because this configuration requirement of **Jotai** will make
    your app crash less. Suspense is a new ReactJS functionality, created to only
    be able to render components that are ready to be rendered. As with any new functionality,
    the users need to get used to it, and sometimes need to be forced to try it. **Jotai**
    is doing exactly this: forcing the users to use Suspense, for their own good!
    Let’s go ahead and add it at the root of our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, our app can use `ListOfFavoritedImages`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Jotai for ListOfFavoritedImages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may have noticed that we didn’t give much of a theoretical introduction
    to **Jotai**. This is because this library is minimal. There is no boilerplate,
    no complex concepts. All we need to do is create an atom and use it thanks to
    a custom hook in the app. Let’s start by creating an atom with some mock data
    for the liked images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the mocked images array ready; all we need to do now is use it. Given
    our previous experiences with other state management libraries, you are probably
    expecting to see some sort of setup, wrapper, subscription, or something similar.
    I’m sorry to disappoint, but all we need to do to use the `ListOfFavoritedImages`
    component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we imported the `useAtom` and the atom we created in
    our `imagesAtom` file. And what is the result? Let’s run the app in the simulator
    and find out!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – App displaying images based on Jotai atoms ](img/Figure_8.01_B18396.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – App displaying images based on Jotai atoms
  prefs: []
  type: TYPE_NORMAL
- en: Everything works! I must admit, this feels almost magical. Surely, fetching
    will be more complicated?
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data with Jotai
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We successfully set up mocked image data in our app, but we would like to fetch
    real data from the server. Going back to the **Jotai** docs, we will find a guide
    on asynchronous atoms (you can find a link to this part of the documentation in
    the *Further reading* section). Here’s what our async atom for fetching images
    will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We add a `requestBase` import to use URLs more comfortably. Then, we proceed
    to create a basic atom with the specific URL. The last function is the async atom.
    We know it’s async because it uses the `async` keyword. The body of the async
    atom function is a `fetch` function and data return. The atom is ready, but it’s
    not connected to anything just yet. We will need to call it in the app and make
    it fill `imageListAtom`. Let’s start by invoking the fetching. A good place to
    do so will be at the root of the app once the user is logged in. This means we
    will not be fetching in the `App.js` root component, but rather in the `Home`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by importing the necessary pieces: a custom hook from `console.log`
    to the component and seeing whether the value of `json` is the same as expected.
    By the way, there is no rule for naming the returns of atoms. You may as well
    write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you’re using linter plugins (such as `json` value being declared but not
    used. What good does it do to fetch images if we’re not doing anything with them?
    And what should we do with them? We should make the newly fetched array of images
    fill `imageListAtom`. The way to accomplish this is to change our read-only `imageListAtom`
    to a read-write atom.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing atoms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ah! Finally, some theory! I’m sure you’ve been craving this, my dear reader!
    (Since it’s difficult to convey irony in a technical text, let me take this opportunity
    to explain: the previous sentence is sarcastic).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of atoms: read-only, write-only, and read-write atoms.
    The read-only atoms are the simplest: all you do is create them and set the value
    they need to hold on to, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Read-only atoms can hold more than simple values or strings. If you need more
    complex logic in your atom, you should use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding short snippet, you can observe that atoms have access to a
    `getter` function, which, in turn, can access other atoms.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to add a write functionality to our atom, we can add a `setter`
    function as the second argument to the atom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve added a new function, which will accept a new text and pass it to the
    `onlyReadMe` atom. If you were to use it in a component, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example component in the preceding screenshot, you can observe how a
    read-write atom can be implemented. We start by importing the atom, but we declare
    two values: the value and the setter, very similar to what we would use in a regular
    `useState` hook. Lower in the component, we use `{fancyText}` to display the text
    from the atom, and the `setFancyText` function to set a new text through a button
    press.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last type of atom we can talk about is the write-only atom. The only difference
    between this atom and a read-write atom is that we declare the read argument as
    `null`. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When using this type of atom, you always need to make sure to accommodate the
    hook with the non-existing default value. Here’s how this write-only hook would
    be used in the preceding example component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice the comma in the array with values derived from the `useAtom` hook. It
    indicates there is a null value on the first index, but we choose to not use it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding read-write functionality to the imageListAtom
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have a read-only `imageListAtom` and an async `fetchImagesAtom`.
    Let’s add a write functionality to `imageListAtom` so that it can accept values
    from `fetchImagesAtom`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The atom is ready to receive values, so let’s give it some. We have to go back
    to the `Home` component where we kicked off data fetching, and add a `useEffect`,
    which will update `imageListAtom`. Here’s what the code should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is a good moment to check again whether everything works fine in the app
    since we just implemented data fetching. If everything is, in fact, working as
    expected, we’ll move on to implementing functionality for the `console.log` to
    check that the atoms hold and return the values you are expecting them to have.
    If you continue to have issues, you can join the *Poimandres* Discord server (link
    in the *Further reading* section), where you’ll find a **Jotai**-dedicated channel.
    *Daishi Kato*, the author of **Jotai**, answers all sorts of questions on this
    channel himself.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are sure that everything is good, we’ll move on to implementing the
    `ImageDetailsModal`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Like button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The full functionality of the `ImageDetailsModal` consists of two parts: the
    heart icon being full or not – indicating whether the image has been liked, and
    the actual action of liking an image – which means adding the new image to the
    array of images on the Favorited surface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating the necessary atom for the heart icon. We need to know
    whether a given image has been liked or not. We can establish whether it has been
    liked by filtering the array of images and checking whether a given image is present
    in the array. Here’s what the resulting atom will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As per the atom syntax, we start by establishing the default value as `false`.
    We then add a setter function, which will receive the new image object. Inside
    the setter function, we use `get` function to get `imageListAtom` and check our
    current image object against it. Finally, we set `isImageLikedAtom` to the correct
    value. Once the atom is created, we need to use it in the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You may wonder why we are calling the `setIsLiked` function so crudely – why
    not add `useEffect`? The fact of the matter is that we need this function to be
    called when the component is rendered and only then. We could add a `useEffect`
    hook with an empty dependency array, but it would achieve the same result while
    looking more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: When does it run?
  prefs: []
  type: TYPE_NORMAL
- en: There are some subtleties to the React component life cycle. They are more obvious
    with class components, where we would use `componentDidMount`, `componentWillUnmount`,
    and so on. Functional components have the same life cycle, without being as obvious
    about it. And it so happens that the `useEffect` hook only runs after a given
    component has finished rendering, while functions called directly do not wait
    for the render to finish.
  prefs: []
  type: TYPE_NORMAL
- en: As far as our example goes, we do not need to make sure the rendering is complete
    before calling the `setIsLiked` function. However, big applications often ask
    a lot of their developers, and you may face a case where you need to closely control
    when a given atom setter function (or any other function for that matter) is run.
    You can read more on this topic in *Difference between ‘useEffect’ and calling
    function directly inside a component*, linked in the *Further* *reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Circling back to our use case: we have a very nice `isImageLiked` atom in place.
    You can test that it works correctly by opening image modals on the **Feed** surface
    – where the heart icon should be empty – and on the **Favorites** surface – where
    the heart icon should be full.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, on to the liking action! We will not need to do anything too fancy here.
    We must take `imageListAtom` and add a new image to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the example write-only atom, we start by declaring a null for the default
    atom value. In the setter function, we get `imageListAtom` and we add the new
    image using the `unshift` function, which adds items to the beginning of the original
    array. We finish by setting the newly created array as `imageListAtom` and by
    triggering the setter in `isImageLikedAtom`. Let’s add this to the modal component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We must import the `addImageToArray` atom into our component and then call it
    in the right place upon the button being tapped. Let’s test our app! Chances are
    everything is working perfectly fine. You can tap the heart icon when it’s empty
    and it becomes full, and when you close the modal and go to the `FlatList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'React Native’s `FlatList` is a pure component, which means it does not re-render
    unless specifically instructed to do so. We have encountered this same problem
    already when using `FlatList`. `extraData` prop from `FlatList` – we can pass
    atom values to `useState` and let the natural state re-render the component. We
    can also take advantage of the utilities provided by the React Navigation library.
    This is my favorite approach, and it is the one I chose to use. There’s a `useIsFocused`
    custom hook in `Favorites` surface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Using this hook, the `Favorites` surface will re-render every time this tab
    is focused. Of course, this is a hook to be used with great caution. Too many
    re-renders cause apps to crash unexpectedly. If you do decide to use it, make
    sure the re-render is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Time to visit the Funbook app again! In this section, we started by using a
    basic hook with a mock array of images. We then implemented data fetching using
    `ImageDetailsModal` and check whether your images on the **Favorites** surface
    are updated correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered **Jotai**, a new kid on the block of state management
    libraries. Inspired by a new, atomic approach to state management proposed by
    Facebook through their library named **Recoil**, **Jotai** has become more and
    more popular within the React community. It offers a bottom-up approach, as opposed
    to top-down libraries, such as **Redux** or **MobX**. It’s honestly stupidly easy
    to configure and use. It doesn’t offer many utilities, but the documentation is
    very clear and easy to use. In this chapter, we managed to use it to fetch and
    store data, and we also used it to implement actions on that data, such as adding
    items to an array. **Jotai** marks the end of our journey with classic state management
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll talk about **React Query**, which is not a state
    management library, but a data-fetching library. It does have its place in this
    book, however. More on that in the next chapter! See you there!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://marmelab.com/blog/2022/06/23/proxy-state-with-valtio.html](https://marmelab.com/blog/2022/06/23/proxy-state-with-valtio.html):
    A State Management Tour: Proxy State with Valtio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/facebookexperimental/Recoil/tree/main](https://github.com/facebookexperimental/Recoil/tree/main):
    *Recoil* GitHub page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://opencollective.com/pmndrs](https://opencollective.com/pmndrs): Poimandres
    website.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/dai-shi/react-suspense-fetch](https://github.com/dai-shi/react-suspense-fetch):
    `react-suspense-fetch`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/dai-shi/react-hooks-fetch](https://github.com/dai-shi/react-hooks-fetch):
    `react-hooks-fetch`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/dai-shi/react-hooks-worker](https://github.com/dai-shi/react-hooks-worker):
    `react-hooks-worker`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://jotai.org/docs/guides/async](https://jotai.org/docs/guides/async):
    *Jotai –* *Async*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/poimandres](https://discord.com/invite/poimandres):
    Poimandres Discord server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.geekyhub.in/post/difference-between-useeffect-and-direct-function-call/](https://www.geekyhub.in/post/difference-between-useeffect-and-direct-function-call/):
    *Difference between ‘useEffect’ and calling function directly inside* *a component*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://reactnavigation.org/docs/function-after-focusing-screen/#re-rendering-screen-with-the-useisfocused-hook](https://reactnavigation.org/docs/function-after-focusing-screen/#re-rendering-screen-with-the-useisfocused-hook):
    React Navigation `useIsFocused` hook.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
