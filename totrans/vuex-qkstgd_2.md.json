["```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Vuex condensed example</title>\n</head>\n<body>\n<div id=\"app\"></div>\n<script src=\"img/vuex.min.js\"></script>\n<script src=\"img/vue.min.js\"></script>\n<script>\n  Vue.use(Vuex);\n\n // Add code from examples here\n\n</script>\n</body>\n</html>\n```", "```js\n// Bugged example of counter\nVue.use(Vuex);\nconst CounterComponent = {\n  template: `\n  <div>\n   <p>I will count from 1 to {{end}}.</p>\n   <button @click=\"beginCounting\">Begin!</button>\n   <p>{{counter}}</p>\n  </div>\n  `,\n  created() {\n    this.counter = 0;\n  },\n  data() {\n    return {\n      end: 3,\n      // you should add counter property here\n    };\n  },\n  methods: {\n    beginCounting() {\n      this.counter = 0;\n      const increaseCounter = () => {\n        this.counter++;\n        if (this.counter < this.end) {\n          setTimeout(increaseCounter, 1000);\n        }\n      };\n      increaseCounter();\n    },\n  },\n};\n\nnew Vue({\n  el: '#app',\n  template: '<counter></counter>',\n  components: {\n    counter: CounterComponent,\n  },\n});\n```", "```js\ndata() {\n  return {\n      end: 3,\n      counter: 0\n  };\n},\n```", "```js\n// Replacing the array\nthis.items[1] = updatedItem;\nthis.items = this.items.slice();\n\n// Using splice to change element at index 1\nthis.items.splice(1,1,updatedItem);\n\n// Adding a new item\nthis.items.push(newItem);\n```", "```js\nconsole.log('start');\nPromise.resolve().then(() => console.log('promise'));\nsetTimeout(() => console.log('timeout'), 0);\nconsole.log('end')\n```", "```js\nstart\nend\npromise\ntimeout\n```", "```js\nconst NumUnreadMessages = {\n  template: `<div>Unread: {{ unreadCounter }}</div>`,\n  computed: {\n    unreadCounter() {\n      return this.$store.state.unreadCounter;\n    },\n  },\n};\n```", "```js\nVue.use(Vuex);\nconst store = new Vuex.Store({\n state: {\n unreadCounter: 1,\n  },\n});\n\nconst NumUnreadMessages = {\n  template: `<div>Unread: {{ unreadCounter }}</div>`,\n  computed: {\n    unreadCounter() {\n      return this.$store.state.unreadCounter;\n    },\n  },\n};\n\nconst app = new Vue({\n  el: '#app',\n  store,\n  components: {NumUnreadMessages},\n  template: `\n  <div class=\"app\">\n    <num-unread-messages></num-unread-messages>\n  </div>\n`,\n});\n```", "```js\nconst NumUnreadMessages = {\n  // ...\n  computed: Vuex.mapState({\n      unreadCounter: state => state.unreadCounter,\n  })\n}\n```", "```js\n   // Using functions with mapState\n    const NumUnreadMessages = {\n     data() {\n       return {label:' unread messages'};\n     },\n     computed: mapState({\n       unreadCounter: state => state.unreadCounter,\n       unreadCounterPlusLabel(state) {\n         // Here you can use *this* keyword to access\n         // the local state of the component.\n         return state.unreadCounter + this.label;\n       }\n     })\n   }\n```", "```js\n   // Using strings\n   computed: mapState({\n     // Equivalent to unreadCounter: state => state.unreadCounter\n     unreadCounter: 'unreadCounter'\n   })\n```", "```js\n   // Using string array\n   computed: mapState([\n     // map this.unreadCounter to store.state.unreadCounter\n     'unreadCounter'\n   ])\n```", "```js\n  computed: {\n   localComputed () {\n     // returning localProperty declared into data section\n     return this.localProperty;\n    },\n   ...mapState([\n     'unreadCounter'\n   ])\n }\n```", "```js\n  const obj = {b:'b', c:'c'};\n  console.log({a:'a', ...obj , d:'d'});\n  // prints {a: \"a\", b: \"b\", c: \"c\", d: \"d\"}\n```", "```js\nconst store = new Vuex.Store({\n  state: {\n    messages: [\n      { id: 1, text: 'First message', read: true },\n      { id: 2, text: 'Second message', read: false },\n    ],\n  },\n  getters: {\n    unreadMessages(state) {\n      return state.messages.filter(message => !message.read);\n    },\n  },\n});\n```", "```js\ngetters: {\n  // ...\n  unreadCounter(state, getters) => {\n    return getters.unreadMessages.length;\n  }\n}\n```", "```js\nVue.use(Vuex);\nconst store = new Vuex.Store({\n  state: {\n    messages: [\n      { id: 1, text: 'First message', read: true },\n      { id: 2, text: 'Second message', read: false },\n    ],\n  },\n  getters: {\n    unreadMessages(state) {\n      return state.messages.filter(message => !message.read);\n    },\n    unreadCounter(state, getters) {\n      return getters.unreadMessages.length;\n    },\n  },\n});\n\nconst NumUnreadMessages = {\n  template: `<div>Unread: {{ unreadCounter }}</div>`,\n  computed: {\n    unreadCounter() {\n      return this.$store.getters.unreadCounter;\n    },\n  },\n};\n\nnew Vue({\n  el: '#app',\n  store,\n  components: { NumUnreadMessages },\n  template: `\n  <div class=\"app\">\n    <num-unread-messages></num-unread-messages>\n  </div>\n`,\n});\n```", "```js\ngetters: {\n  // ...\n  getMessageById(state) {\n    return (id) => {\n return state.messages.find(msg => msg.id === id);\n }\n  }\n}\n```", "```js\nconst NumUnreadMessages = {\n  template: `<div>Unread: {{ unreadCounter }}</div>`,\n  computed: Vuex.mapGetters(['unreadCounter']),\n};\n```", "```js\n...mapGetters({\n  // map `this.numUnread` to `store.getters.unreadCounter`\n  numUnread: 'unreadCounter'\n```", "```js\nconst store = new Vuex.Store({\n  state: {\n    messages: []\n  },\n  mutations: {\n    addNewMessage (state, msgText) {\n      // mutating the state\n      state.messages.push({text: msgText, read: false});\n    }\n  }\n})\n```", "```js\nstore.commit('addNewMessage', 'A message');\n```", "```js\nstore.commit({\n  type: 'addNewMessage',\n  content: 'A message'\n});\n```", "```js\nVue.use(Vuex);\nconst store = new Vuex.Store({\n  state: {\n    messages: [],\n  },\n  mutations: {\n    addNewMessage(state, msgText) {\n      state.messages.push({ text: msgText, read: false });\n    },\n  },\n});\n\nconst MessageList = {\n  template: `<ul>\n      <li v-for=\"message in messages\">{{message.text}}</li>\n    </ul>\n  `,\n  computed: Vuex.mapState(['messages']),\n};\n\nconst MessageEditor = {\n  template: `<div>\n    <input type=\"text\" v-model=\"message\">\n    <button @click=\"addMessage\">Add message</button>\n  </div>\n  `,\n  data() {\n    return {\n      message: '',\n    };\n  },\n  methods: {\n    addMessage() {\n      this.$store.commit('addNewMessage', this.message);\n    },\n  },\n};\n\nnew Vue({\n  el: '#app',\n  store,\n  components: { MessageList, MessageEditor },\n  template: `\n  <div class=\"app\">\n    <message-editor></message-editor>\n    <message-list></message-list>\n  </div>\n`,\n});\n```", "```js\n// mutation-types.js\nexport const ADD_NEW_MESSAGE = 'addNewMessage';\n\n// store.js\nimport Vuex from 'vuex';\nimport { ADD_NEW_MESSAGE } from './mutation-types';\n\nconst store = new Vuex.Store({\n  state: { ... },\n  mutations: {\n    [ADD_NEW_MESSAGE] (state, msgText) {\n      state.messages.push({text: msgText, read: false});\n    }\n  }\n});\n```", "```js\n// Violation of rule \"mutations handlers must be synchronous\"\nmutations: {\n  updateBookDetailsById(state, partialBookData) {\n    state.currentBook = partialBookData;\n    const {bookId} = partialBookData;\n    api.getBookDetailsById(bookId, (bookDetails) => {\n      state.currentBook = bookDetails;\n    });\n  }\n}\n```", "```js\nconst MessageEditor = {\n  template: `<div>\n    <input type=\"text\" v-model=\"message\">\n    <button @click=\"addNewMessage(message)\">Add message</button>\n  </div>\n  `,\n  data() {\n    return {\n      message: '',\n    };\n  },\n  methods: Vuex.mapMutations([\n    // Payload is also supported\n    'addNewMessage'\n  ]),\n};\n```", "```js\nconst store = new Vuex.Store({\n  state: {\n    messages: [],\n  },\n  mutations: {\n    addNewMessage(state, msgText) {\n      state.messages.push({ text: msgText, read: false });\n    },\n  },\n  actions: {\n    addMessage(context, msgText) {\n      API.addMessage(msgText).then(() => {\n        context.commit('addNewMessage', msgText);\n      });\n    },\n  },\n});\n```", "```js\nstore.dispatch('addNewMessage', 'A message');\n```", "```js\nVue.use(Vuex);\n\n// Server API mock\nconst API = {\n  addMessage: () => Promise.resolve()\n};\n\nconst store = new Vuex.Store({\n  state: {\n    messages: [],\n  },\n  mutations: {\n    addNewMessage(state, msgText) {\n      state.messages.push({ text: msgText, read: false });\n    },\n  },\n  actions: {\n    addMessage(context, msgText) {\n      API.addMessage(msgText).then(() => {\n        context.commit('addNewMessage', msgText);\n      });\n    },\n  },\n});\n\nconst MessageList = {\n // ...\n};\n\nconst MessageEditor = {\n  template: `<div>\n    <input type=\"text\" v-model=\"message\">\n    <button @click=\"addMessage\">Add message</button>\n  </div>\n  `,\n  data() {\n    return {\n      message: '',\n    };\n  },\n  methods: {\n    addMessage() {\n this.$store.dispatch('addMessage', this.message);\n },\n  },\n};\n\nnew Vue({\n // ...\n});\n```", "```js\nconst MessageEditor = {\n  template: `<div>\n    <input type=\"text\" v-model=\"message\">\n    <button @click=\"addMessage(message)\">\n      Add message\n    </button>\n  </div>\n  `,\n  data() {\n    return {\n      message: '',\n    };\n  },\n  methods: Vuex.mapActions(['addMessage']),\n  // Or you can use the Object syntax\n  // methods: Vuex.mapActions({ addMessage: 'addMessage' }),\n};\n```", "```js\nconst subModule = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n};\n\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... },\n  modules: {\n    sub: subModule\n  }\n};\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n};\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n});\n\nstore.state.a // -> `moduleA`'s state\nstore.state.a.sub // -> `subModule`'s state\nstore.state.b // -> `moduleB`'s state\n```", "```js\nconst moduleA = {\n  // ...\n  actions: {\n    incrementIfOddOnRootSum ({ state, commit, rootState }) {\n      if ((state.count + rootState.count) % 2 === 1) {\n        commit('increment');\n      }\n    }\n  },\n  getters: {\n    sumWithRootCount (state, getters, rootState) {\n      return state.count + rootState.count;\n    }\n  }\n}\n```", "```js\nmodules: {\n auth: {\n  namespaced: true,\n  state: { ... }, // Already nested, not affected by namespace\n  mutations: {\n    setLogged() {...} // -> commit('auth.setLogged')\n  },\n  actions: {\n    login(){...} // -> dispatch('auth/login')\n  },\n  getters: {\n    logged() {...} // -> getters['auth/logged']\n  }\n};\n```", "```js\nmodules: {\n  foo: {\n    namespaced: true,\n    getters: {\n      someGetter (state, getters, rootState, rootGetters) {\n        getters.someOtherGetter // -> 'foo/someOtherGetter'\n        rootGetters.someOtherGetter // -> 'someOtherGetter'\n      },\n      someOtherGetter: state => { ... }\n    },\n    actions: {\n      someAction ({dispatch, commit, getters, rootGetters}) {\n        getters.someGetter // -> 'foo/someGetter'\n        rootGetters.someGetter // -> 'someGetter'\n\n        dispatch('someOtherAction'); //->'foo/someOtherAction'\n\n        // -> 'someOtherAction'\n        dispatch('someOtherAction', null, { root: true });\n\n        commit('someMutation') // -> 'foo/someMutation'\n\n        // -> 'someMutation'\n        commit('someMutation', null, { root: true }) \n      },\n      someOtherAction (ctx, payload) { ... }\n    }\n  }\n}\n```", "```js\ncomputed: {\n  ...mapState('some/nested/module', {\n    a: state => state.a,\n    b: state => state.b\n  })\n},\nmethods: {\n  ...mapActions('some/nested/module', [\n    'foo',\n    'bar'\n  ])\n}\n```", "```js\nconst { mapState, mapActions } = \n    Vuex.createNamespacedHelpers('some/nested/module');\n\nexport default {\n  computed: {\n    // look up in `some/nested/module`\n    ...mapState({\n      a: state => state.a,\n      b: state => state.b\n    })\n  },\n  methods: {\n    // look up in `some/nested/module`\n    ...mapActions([\n      'foo',\n      'bar'\n    ])\n  }\n};\n```", "```js\n// register a module `myModule`\nstore.registerModule('myModule', {\n  // ...\n})\n\n// register a nested module `nested/myModule`\nstore.registerModule(['nested', 'myModule'], {\n  // ...\n})\n```", "```js\n// Loading module asynchronously\n// index.js\nVue.use(Vuex);\n\nconst store = new Vuex.Store({\n  state: {\n    currentView: 'initial'\n  },\n});\n\nVue.component('initial', {\n  template: '<div>initial</div>',\n});\n\nimport ('./loaded-later-moudle.js').then((module) => {\n  module.default(store);\n});\n\nnew Vue({\n  el: '#app',\n  template: '<component :is=\"$store.state.currentView\"/>',\n  store,\n});\n```", "```js\n// loaded-later-moudle.js\nexport default function moduleFactory(store) {\n  Vue.component('later', {\n    template: '<div>later</div>',\n  });\n\n  store.registerModule('loadedLater', {});\n\n  setTimeout(() => {\n    store.state.currentView = 'later';\n  }, 500);\n}\n```", "```js\nconst ReusableModule = {\n  state () {\n    return {\n      foo: 'bar'\n    }\n  },\n  // mutations, actions, getters...\n};\n```", "```js\nconst store = new Vuex.Store({\n  // ...\n  strict: true\n});\n```", "```js\nconst store = new Vuex.Store({\n  // ...\n  strict: process.env.NODE_ENV !== 'production'\n})\n```", "```js\n<input v-model=\"$store.state.message\">\n```", "```js\n<input v-model=\"message\">\n// ...\ncomputed: {\n  message: {\n    get () {\n      return this.$store.state.obj.message;\n    },\n    set (value) {\n      this.$store.commit('updateMessage', value);\n    }\n  }\n}\n```", "```js\n// ...\nmutations: {\n  updateMessage (state, message) {\n    state.obj.message = message;\n  }\n}\n```", "```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Simple counter example</title>\n</head>\n<body>\n<div id=\"app\"></div>\n<script src=\"img/vuex.min.js\"></script>\n<script src=\"img/vue.min.js\"></script>\n<script>\n  Vue.use(Vuex);\n\n  // Sequential module\n  const sequential = {\n    namespaced: true,\n    state() {\n      return {\n        count: 1,\n      };\n    },\n    mutations: {\n      increment: state => state.count++,\n      decrement: state => state.count--\n    },\n    actions: {\n      increment: ({ commit }) => commit('increment'),\n      decrement: ({ commit }) => commit('decrement'),\n    },\n    getters: {\n      name: () => 'Sequential',\n      currentCount: state => state.count,\n    },\n  };\n\n  // FizzBuzz module that extends sequential module\n  // and redefine some functions.\n  const fizzBuzz = Object.assign({}, sequential, {\n    getters: {\n      name: () => 'FizzBuzz',\n      currentCount: state => {\n        const { count } = state;\n        let msg = '';\n        if (count % 3 === 0) msg += \"Fizz\";\n        if (count % 5 === 0) msg += \"Buzz\";\n        return `${count} ${msg}`;\n      },\n    },\n  });\n\n  // Application store with the two modules\n  const store = new Vuex.Store({\n    modules: {\n      sequential,\n      fizzBuzz,\n    },\n  });\n\n  // HTML template to show the result\n  const template = `\n  <div>\n    <button @click=\"increment\">+</button>\n    <button @click=\"decrement\">-</button>\n    <span>{{name}} value: {{currentCount}}</span>\n  </div>\n`;\n\n  // counter component\n  const counter = {\n    template,\n    computed: Vuex.mapGetters('sequential', [\n      'name',\n      'currentCount',\n    ]),\n    methods: Vuex.mapActions('sequential', [\n      'increment',\n      'decrement',\n    ]),\n  };\n\n  // fizzBuzzCounter component\n  const fizzBuzzCounter = {\n    template,\n    computed: Vuex.mapGetters('fizzBuzz', [\n      'name',\n      'currentCount',\n    ]),\n    methods: Vuex.mapActions('fizzBuzz', [\n      'increment',\n      'decrement',\n    ]),\n  };\n\n  // Vue instance with the store and the components\n  new Vue({\n    el: '#app',\n    store,\n    template: '<div><counter></counter>' +\n    '<fizzBuzzCounter></fizzBuzzCounter></div>',\n    components: {\n      counter,\n      fizzBuzzCounter,\n    },\n  });\n</script>\n</body>\n</html>\n```"]