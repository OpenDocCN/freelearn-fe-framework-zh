- en: Chapter 8. Advanced Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。高级组件
- en: This chapter describes the lifecycle of components and the methods that can
    be used at different stages of the lifecycle. In this chapter, we will analyze
    each stage of this cycle and we will learn how to make the most of the hook methods
    that are triggered when a component moves from one stage to another. This chapter
    also discusses how to create a multi-component application. Readers will be able
    to add more features to the app using Bootstrap.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了组件的生命周期以及可以在生命周期的不同阶段使用的方法。在本章中，我们将分析此周期的每个阶段，并学习如何充分利用在组件从一个阶段转移到另一个阶段时触发的钩子方法。本章还讨论了如何创建多组件应用程序。读者将能够使用Bootstrap为应用程序添加更多功能。
- en: 'At the end of the chapter, you will have a solid understanding of:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将对以下内容有扎实的理解：
- en: Component lifecycle hooks interfaces
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件生命周期钩子接口
- en: Lifecycle hook methods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期钩子方法
- en: Implementing hook interfaces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现钩子接口
- en: Change detection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更检测
- en: Communication between components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件之间的通信
- en: Directives
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令
- en: 'The directive is the fundamental building block of Angular 2 and allows you
    to connect behavior to an element in the DOM. There are three kinds of directives:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 指令是Angular 2的基本构建块，允许您将行为连接到DOM中的元素。有三种类型的指令：
- en: Attribute directives
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性指令
- en: Structural directives
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构指令
- en: Components
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件
- en: A directive is a class with an assigned `@Directive` decorator.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 指令是一个带有分配的类`@Directive`装饰器。
- en: Attribute directives
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性指令
- en: The attribute directive usually changes the appearance or behavior of an element.
    We can change several styles or use it to render text bold or italic by binding
    to a property.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 属性指令通常改变元素的外观或行为。我们可以通过绑定属性来改变多个样式或使用它来渲染文本为粗体或斜体。
- en: Structural directives
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构指令
- en: The structural directive changes the DOM layout by adding and removing other
    elements.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 结构指令通过添加和删除其他元素来改变DOM布局。
- en: Components
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件
- en: 'The component is a directive with a template. Every component is made up of
    two parts:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是带有模板的指令。每个组件由两部分组成：
- en: The class, where we define the application logic
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义应用程序逻辑的类
- en: The view controlled by the component which interacts with it through an API
    of properties and methods
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由组件控制的视图，通过属性和方法的API与其交互
- en: A component is a class with an assigned `@Component` decorator.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是一个带有分配的类`@Component`装饰器。
- en: The directive lifecycle
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令生命周期
- en: 'To develop custom directives for any project, you should understand the basics
    of the Angular 2 directive lifecycle. A directive goes through a number of distinct
    stages between when it is created and when it is destroyed:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要为任何项目开发自定义指令，您应该了解Angular 2指令生命周期的基础知识。指令在创建和销毁之间经历了许多不同阶段：
- en: Instantiation
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化
- en: Initialization
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化
- en: Change detection and rendering
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变更检测和渲染
- en: Content projection (only for components)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内容投影（仅适用于组件）
- en: After view (only for components)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图之后（仅适用于组件）
- en: Destruction
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 销毁
- en: The Angular lifecycle hooks
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 生命周期钩子
- en: Angular offers directive lifecycle hooks that give us the ability to act when
    these key moments occur. We can implement one or more of the lifecycle hook interfaces
    in the Angular `core` library. Each interface has a single method whose name is
    the interface name prefixed with `ng` . Interfaces are optional for TypeScript
    and Angular calls the hook methods if they are defined.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了指令生命周期钩子，使我们能够在发生这些关键时刻时采取行动。我们可以在Angular `core`库中实现一个或多个生命周期钩子接口。每个接口都有一个单一的方法，其名称是以`ng`为前缀的接口名称。接口对于TypeScript是可选的，如果定义了接口，Angular将调用钩子方法。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I recommend implementing the lifecycle hook interfaces to directive classes
    to benefit from strong typing and editor tooling.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议实现生命周期钩子接口到指令类中，以便从强类型和编辑器工具中受益。
- en: 读累了记得休息一会哦~
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
- en: Instantiation
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化
- en: 'The Injector creates the directive instance with the `new`  keyword. Each directive
    may contain, at most, one constructor declaration. If a class contains no constructor
    declaration, an automatic constructor is provided. The primary purpose of the
    constructor is to create a new instance of an object and to set initial properties
    for it. Angular 2 uses constructor for dependency injection, so we can save references
    to dependent instances for later use:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注入器使用`new`关键字创建指令实例。每个指令最多可以包含一个构造函数声明。如果一个类不包含构造函数声明，将提供自动构造函数。构造函数的主要目的是创建对象的新实例并为其设置初始属性。Angular
    2使用构造函数进行依赖注入，因此我们可以保存对依赖实例的引用以供以后使用：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, the class, `CategoryListComponent` , has a constructor
    with two parameters referencing on `Router` and `CategoryService` .
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`CategoryListComponent`类有一个构造函数，其中有两个参数引用`Router`和`CategoryService`。
- en: Initialization
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化
- en: 'There are data-bound input properties in every directive, and Angular saves
    the values of bounded properties at the initialization stage:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个指令中都有数据绑定的输入属性，并且Angular在初始化阶段保存了绑定属性的值：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The class `CategorySlideComponent` has a category-bounded to the property with
    the same name in the template.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`CategorySlideComponent`类有一个与模板中同名属性绑定的类别。'
- en: 'We can implement `OnInit` and `OnChanges` interfaces to respond accordingly:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现`OnInit`和`OnChanges`接口来做出相应的响应：
- en: Angular calls the `ngOnChanges` method when data-bound input property values
    change
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据绑定的输入属性值发生变化时，Angular调用`ngOnChanges`方法
- en: Angular calls the `ngOnInit` method after the first `ngOnChanges` and signals
    to us that the component has initialized
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular在第一次`ngOnChanges`之后调用`ngOnInit`方法，并向我们发出信号，表明组件已经初始化
- en: 'In the following code, we implement the `OnInit` interface to create the form
    controls and start listening to its value changes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们实现了`OnInit`接口来创建表单控件并开始监听其值的变化：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Mostly we relying on the `ngOnInit` method for the following reasons:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们依赖`ngOnInit`方法有以下原因：
- en: We need to perform an initialization after the constructor
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要在构造函数之后执行初始化
- en: To finalize the component setup after Angular sets the input properties
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular设置输入属性后，完成组件设置
- en: This method is a perfect location for the heavy initialization logic to fetch
    data from the server or to update the internal state depending on input properties.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是一个完美的位置，用于从服务器获取数据或根据输入属性更新内部状态的繁重初始化逻辑。
- en: Change detection and rendering
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变更检测和渲染
- en: This stage intentionally combines two important techniques that Angular 2 uses
    to bring life to the application. From one side, the change detection module of
    the framework looks after changes to the internal state of a program. It can detect
    changes in any data structure, from primitive to an array of objects. From the
    other side, the rendering part of Angular makes these changes visible in the DOM.
    Angular combines these two techniques in one stage to minimize the workload because
    rebuilding DOM trees is expensive.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段故意结合了Angular 2用来为应用程序注入生命的两种重要技术。一方面，框架的变更检测模块负责监视程序的内部状态的变化。它可以检测任何数据结构的变化，从基本类型到对象数组。另一方面，Angular的渲染部分使这些变化在DOM中可见。Angular将这两种技术结合在一个阶段中，以最小化工作量，因为重建DOM树是昂贵的。
- en: NgZone service
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NgZone服务
- en: 'Most of the time the application state changes because the following asynchronous
    tasks happen in the application:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，应用程序状态的变化是因为应用程序中发生了以下异步任务：
- en: An event triggered by a user or application
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户或应用程序触发的事件
- en: Directive and pipe properties change
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令和管道属性变化
- en: Callback functions calling from AJAX responses
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从AJAX响应中调用回调函数
- en: Callback functions calling from timers
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自定时器的回调函数调用
- en: 'Angular uses `NgZone` , an execution context from the Zone library, to hook
    into those asynchronous tasks to detect changes, error handling, and profiling.
    Zone can perform several significant operations whenever code enters or exits
    a zone such as:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Angular使用Zone库中的执行上下文“NgZone”来钩入这些异步任务以检测变化、处理错误和进行分析。当代码进入或退出区域时，区域可以执行几个重要的操作，例如：
- en: Starting or stopping a timer
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动或停止计时器
- en: Saving a stack trace
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存堆栈跟踪
- en: Overriding methods of execution code
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖执行代码的方法
- en: Association of data with individual zones, and so on
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据与各个区域关联等
- en: Every Angular application has a global zone object wrapping the executable code,
    but we can use the `NgZone` service for executing work inside or outside of the
    Angular zone as well. `NgZone` is a forked zone that extends the standard zone
    API and adds some additional functionality to the execution context. Angular uses
    `NgZone` to monkey-patch the global asynchronous operations such as `setTimeout`
    and `addEventListener` to update the DOM.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Angular应用程序都有一个包装可执行代码的全局区域对象，但我们也可以使用“NgZone”服务在Angular区域内外执行工作。 “NgZone”是一个扩展了标准区域API并向执行上下文添加了一些附加功能的分支区域。
    Angular使用“NgZone”来monkey-patch全局异步操作，例如“setTimeout”和“addEventListener”以更新DOM。
- en: Change detection
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变更检测
- en: Each directive in the Angular framework has a change detector, so we can define
    how change detection is performed. The hierarchical structure of directives brings
    change to the detector tree on the stage, so Angular always uses unidirectional
    data flow as a tool to deliver data from parents to children.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Angular框架中的每个指令都有一个变更检测器，因此我们可以定义如何执行变更检测。指令的分层结构将变更带入了舞台上的检测器树，因此Angular始终使用单向数据流作为一种工具，将数据从父级传递给子级。
- en: 'Most of the time, Angular''s change detection occurs on properties and updates
    the view accordingly, independent of the structure of data:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，Angular的变更检测发生在属性上，并相应地更新视图，与数据结构无关：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Property binding is used to supply data to a `product` , and event binding
    is used to inform other components of any updates, which it delegates to the store.
    The `product` is a reference to a real object with many fields:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定用于向“product”提供数据，事件绑定用于通知其他组件进行任何更新，并将其委托给存储。 “product”是一个指向具有许多字段的真实对象的引用：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Even though any field can be changed, the `product` reference itself stays the
    same. Angular will perform lots of check changes for properties of directives
    every time without performance degradation because the framework change detection
    system can execute hundreds and thousands of them within just a few milliseconds.
    Sometimes this massive change detection can be quite expensive so we can select
    a change detection strategy on a per-directive basis.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 即使任何字段都可以更改，“product”引用本身仍然保持不变。由于框架变更检测系统可以在几毫秒内执行数百甚至数千次检查指令属性的更改而不会降低性能，因此Angular将在每次执行大量的检查变更时执行大量的检查变更。有时这种大规模的变更检测可能非常昂贵，因此我们可以根据每个指令选择变更检测策略。
- en: The internal state of a directive only depends on its input properties, so if
    these properties have not changed from one check to the next, then the directive
    doesn't need to be re-rendered. Bear in mind that all JavaScript objects are mutable,
    so change detection should check all input property fields to re-render a directive
    when necessary. If we use immutable structures, then change detection can be much
    faster. Let's have a look how that might happen.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 指令的内部状态仅取决于其输入属性，因此如果这些属性从一次检查到下一次没有发生变化，那么指令就不需要重新渲染。请记住，所有的JavaScript对象都是可变的，因此变更检测应该检查所有输入属性字段，以在必要时重新渲染指令。如果我们使用不可变结构，那么变更检测可以更快。让我们看看可能发生的情况。
- en: Immutable objects
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变对象
- en: An immutable object can't change. It always has only one internal state, and
    if we want to make a change to such an object, we'll always get a new reference
    to that change.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象是不会改变的。它始终只有一个内部状态，如果我们想对这样的对象进行更改，我们将始终得到对该更改的新引用。
- en: Change detection strategy
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变更检测策略
- en: 'Angular supports the following change detection strategies:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Angular支持以下变更检测策略：
- en: The `Default` strategy means that the change detector will check the properties
    deeply per dirty check
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Default`策略意味着变更检测器将深度检查每个脏检查的属性'
- en: The `OnPush` strategy means that the change detector will check the changes
    of references on properties per dirty check
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnPush`策略意味着变更检测器将检查每个脏检查的属性引用的变化'
- en: 'We can instruct Angular as to which change detection strategy it can use for
    specific directives via the `changeDetection` property of the decorator:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过装饰器的`changeDetection`属性指示Angular可以为特定指令使用哪种变更检测策略：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `OnPush` strategy will only work properly if all the values supplied to
    a directive via input properties are immutable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当通过输入属性提供给指令的所有值都是不可变的时，`OnPush`策略才能正常工作。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't use mutable values with the `OnPush` check detection strategy because
    it can take the Angular application into an inconsistent or unpredictable state.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在`OnPush`检测策略中使用可变值，因为这可能会使Angular应用程序处于不一致或不可预测的状态。
- en: 'Angular automatically triggers the change detector to check the directive in
    `OnPush` mode if any of the followings happen:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Angular会自动触发变更检测，以检查指令在`OnPush`模式下是否发生以下情况：
- en: When any directive input property changes
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当任何指令输入属性发生变化时
- en: Whenever a directive fires an event
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当指令触发事件时
- en: When any observable belonging to this directive fires an event
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当属于该指令的任何可观察对象触发事件时
- en: Triggering change detection programmatically
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以编程方式触发变更检测
- en: 'As mentioned earlier, every directive has a change detector that works automatically.
    In cases when we need to trigger the change detection programmatically we can
    use the `ChangeDetectionRef` class. We can call the `markForCheck` method of this
    class in the place where changes happen, so it marks the path from this directive
    to the root, to be checked for the next change detection run:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个指令都有一个自动工作的变更检测器。在需要以编程方式触发变更检测的情况下，我们可以使用`ChangeDetectionRef`类。我们可以在发生变化的地方调用该类的`markForCheck`方法，这样它就会标记从该指令到根的路径，以便在下一次变更检测运行时进行检查：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we triggered change detection because the string value
    came from `searchControl` which is always immutable.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们触发了变更检测，因为字符串值来自`searchControl`，而该值始终是不可变的。
- en: 'As we mentioned, we can implement `OnChanges` interfaces to detect changes
    to input the properties of a directive to respond accordingly on:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所提到的，我们可以实现`OnChanges`接口来检测指令的输入属性的变化，并相应地做出响应：
- en: Angular calls the `ngOnChanges` method when a data-bound input property value
    changes. Most of the time, we do not use this method, but if you need to change
    the internal state dependence on the input properties, that's the right place
    to do so.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据绑定的输入属性值发生变化时，Angular调用`ngOnChanges`方法。大多数情况下，我们不使用这个方法，但如果需要根据输入属性改变内部状态的依赖关系，这就是合适的地方。
- en: 'In the following code, we use the `OnChanges` interface to look after changes
    that happen to the `category` input property:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们使用`OnChanges`接口来监视`category`输入属性的变化：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When the value assigns to the `category` the `ngOnChanges` method prints the
    following information:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当将值分配给`category`时，`ngOnChanges`方法打印以下信息：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `SimpleChanges` class keeps the current and previous values of each changed
    property name, so we can iterate through and log them.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleChanges`类保留了每个更改的属性名称的当前值和先前值，因此我们可以遍历并记录它们。'
- en: We can implement the `DoCheck` interface in our directive to detect and act
    upon changes that Angular doesn't catch on its own. Angular calls the `ngDoCheck`
    method during every change detection cycle. Please use this method with caution,
    because Angular calls it with enormous frequency, so an implementation must be
    very lightweight.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在指令中实现`DoCheck`接口来检测并对Angular无法捕捉到的变化做出反应。Angular在每次变化检测周期中调用`ngDoCheck`方法。请谨慎使用此方法，因为Angular会以极高的频率调用它，因此实现必须非常轻量级。
- en: Content projection (only for components)
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容投影（仅适用于组件）
- en: In general, the component is an HTML element and may have content such as text
    or markup. Angular 2 uses specific entry points marked with a `ng-content` tag
    to inject the content into the component template. This technique is known as
    a **content projection** and Angular uses Shadow DOM to achieve that.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，组件是一个HTML元素，可能包含文本或标记等内容。Angular 2使用带有`ng-content`标记的特定入口点将内容注入到组件模板中。这种技术被称为**内容投影**，Angular使用Shadow
    DOM来实现。
- en: 'Angular 2 takes advantages of web component standards and uses a set of the
    following technologies:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2利用Web组件标准并使用一组以下技术：
- en: Templates for structural DOM changes
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于结构性DOM更改的模板
- en: Shadow DOM for styles and DOM encapsulation
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shadow DOM用于样式和DOM封装
- en: We used templates in our project, so now it's time to talk about how Angular
    uses Shadow DOM in different encapsulation types.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在项目中使用了模板，现在是时候谈谈Angular如何在不同的封装类型中使用Shadow DOM了。
- en: The Shadow DOM allows us to hide DOM logic behind other elements and apply styles
    in the scope of it. Everything inside the Shadow DOM is unavailable to other components,
    so we call it encapsulation. In fact, the Shadow DOM is a new technique, and not
    all web browsers support it, so Angular uses emulation to mimic how Shadow DOM
    behaves.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Shadow DOM允许我们将DOM逻辑隐藏在其他元素后面，并在其范围内应用样式。Shadow DOM内部的所有内容对其他组件不可用，因此我们称之为封装。事实上，Shadow
    DOM是一种新技术，并非所有的Web浏览器都支持它，因此Angular使用模拟来模仿Shadow DOM的行为方式。
- en: 'There are three encapsulation types in Angular:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中有三种封装类型：
- en: '`ViewEncapsulation.None` : Angular doesn''t use Shadow DOM and style encapsulation'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewEncapsulation.None`：Angular不使用Shadow DOM和样式封装'
- en: '`ViewEncapsulation.Emulated` : Angular doesn''t use Shadow DOM but emulates
    the style encapsulation'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewEncapsulation.Emulated`：Angular不使用Shadow DOM，但模拟样式封装'
- en: '`ViewEncapsulation.Native` : Angular uses Native Shadow DOM with all the benefits'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewEncapsulation.Native`：Angular使用原生Shadow DOM并获得所有的好处'
- en: We will use the `encapsulation` property of the `@Component` decorator to instruct
    Angular what encapsulation type to use.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`@Component`装饰器的`encapsulation`属性来指示Angular使用哪种封装类型。
- en: Component styles
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件样式
- en: 'In Angular 2, we can apply styles for the whole document and for specific components.
    That change brings another level of granularity and helps organize more modular
    designs than regular style sheets. The component styles are different to any global
    styles. Any selector inside a component style is applied within the scope of this
    component and its children. The component styles bring the following benefits:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular 2中，我们可以为整个文档和特定组件应用样式。这种变化带来了另一种粒度级别，并有助于比常规样式表更模块化的设计。组件样式与任何全局样式都不同。组件样式中的任何选择器都在该组件及其子元素的范围内应用。组件样式带来以下好处：
- en: We can use any name of CSS classes or selectors within the context of the component
    without fear of getting name conflicts with classes and selectors used in other
    parts of the application.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在组件的上下文中使用任何CSS类或选择器，而不必担心与应用程序其他部分中使用的类和选择器发生名称冲突。
- en: The styles encapsulated in the component are invisible to the rest of the application
    and cannot be changed elsewhere. We can change or remove the component styles
    without affecting the styles of the whole application.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件中封装的样式对应用程序的其余部分是不可见的，也不能在其他地方更改。我们可以更改或删除组件样式而不影响整个应用程序的样式。
- en: Component styles can be taken to separate files and can co-locate with TypeScript
    and HTML codes, which makes the project code more structured and organized.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件样式可以放在单独的文件中，并且可以与TypeScript和HTML代码共存，这使得项目代码更加结构化和有组织。
- en: Special selectors
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊选择器
- en: The component styles may include several special selectors. All of these came
    from the Shadow DOM world.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 组件样式可能包括几个特殊选择器。所有这些都来自Shadow DOM世界。
- en: The :host pseudo-class
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: :host伪类
- en: 'Any element that hosts the component calls the host. The only one way to target
    the styles of the host element from the hosted component is to use the `:host`
    pseudo-class selector:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 托管组件的任何元素都称为宿主。从托管组件中的宿主元素中定位宿主元素的样式的唯一方法是使用`:host`伪类选择器：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code snippet, we changed the display and border styles in
    the parent''s component template. In cases when we need to apply the host styles
    conditionally, use another selector as a parameter of the styles function form:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们更改了父组件模板中的显示和边框样式。在需要有条件地应用宿主样式时，可以使用另一个选择器作为样式函数形式的参数：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding styles will apply to the host only when it has an `active` class.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的样式只有在宿主具有`active`类时才适用。
- en: The :host-context pseudo-class
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: :host-context伪类
- en: 'Just imagine a situation where you are creating a theme for your web application
    and you would like to apply specific styles to your component, dependent on the
    presence or absence of other selectors. You could easily implement it with the
    help of the `:host-context` function:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，当您为Web应用程序创建主题并希望根据其他选择器的存在或不存在应用特定样式到您的组件时。您可以轻松地使用`:host-context`函数来实现：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The logic behind the preeding code is looking for a `theme-dark` CSS class in
    any ancestor from the component host element up to the document root and applying
    `gray` to the `background-color` style to all the paragraph elements inside the
    component.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的逻辑是在组件宿主元素到文档根部之间查找`theme-dark` CSS类，并将`gray`应用于组件内所有段落元素的`background-color`样式。
- en: The /deep/ selector
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: /deep/选择器
- en: 'The styles of the component apply only to its template. If we need to apply
    them to all child elements then we need to use the `/deep/` selector:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的样式仅适用于其模板。如果我们需要将它们应用于所有子元素，那么我们需要使用`/deep/`选择器：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `/deep/` selector from the preceding code snippet will apply the `bold`
    to the `font-weight` style of all `h4` header elements from the component through
    the child components tree down to all the child component views.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码片段中的`/deep/`选择器将把`bold`应用于组件中所有`h4`标题元素的`font-weight`样式，通过子组件树一直到所有子组件视图。
- en: The `/deep/` selector has an alias `>>>` we can use interchangeably for an emulated
    view encapsulation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`/deep/`选择器有一个别名`>>>`，我们可以在模拟视图封装中互换使用。'
- en: Non-view encapsulation
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非视图封装
- en: 'Angular doesn''t use Shadow DOM and style encapsulation for this type. Let''s
    imagine we have a `ParentComponent` in our project:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Angular不使用此类型的Shadow DOM和样式封装。让我们想象一下，在我们的项目中有一个`ParentComponent`：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the code of an `AppComponent` , we have the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AppComponent`的代码中，我们有以下内容：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `ParentComponent` has its own style and it could override it with another
    component because it will be applied to the document head later:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParentComponent`有自己的样式，它可以用另一个组件覆盖它，因为它将稍后应用于文档头部：'
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Angular generates the following HTML code which runs in the browser:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Angular生成以下在浏览器中运行的HTML代码：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There is no Shadow DOM involvement, and the application applied styles to the
    entire document. Angular replaced `ng-content` with the contents of the child
    component.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 没有Shadow DOM的参与，应用程序将样式应用于整个文档。Angular用子组件的内容替换了`ng-content`。
- en: '![Non-view encapsulation](Image00132.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![非视图封装](Image00132.jpg)'
- en: Emulated view encapsulation
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟视图封装
- en: 'The emulated view is the default view encapsulation which Angular uses to create
    components. Angular doesn''t use Shadow DOM but emulates the style encapsulation.
    Let''s change the value of the `encapsulation` property to see the difference.
    Here is the style Angular generates for the emulated view encapsulation:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟视图是Angular用来创建组件的默认视图封装。Angular不使用Shadow DOM，但模拟样式封装。让我们改变`encapsulation`属性的值来看看区别。这是Angular为模拟视图封装生成的样式：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The style of the parent component looks different and belongs to a specific
    element. This is how Angular emulates the style encapsulation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 父组件的样式看起来不同，并属于特定元素。这就是Angular模拟样式封装的方式：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The markup part of the page looks very similar to the non-view encapsulation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 页面的标记部分看起来与非视图封装非常相似。
- en: Native view encapsulation
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原生视图封装
- en: 'The native view is one of the simplest encapsulations. It uses the native Shadow
    DOM to encapsulate content and style. Angular doesn''t need to generate any styles
    for the parent component:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 原生视图是最简单的封装之一。它使用原生Shadow DOM来封装内容和样式。Angular不需要为父组件生成任何样式：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, the styles for the parent component are unavailable for other applications
    as well as the markup code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，父组件的样式对其他应用程序以及标记代码都不可用：
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we need to project more than one child content, we can use `ng-content`
    with a dedicated `select` attribute:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要投影多个子内容，我们可以使用带有专用`select`属性的`ng-content`：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Bear in mind that the `select` attribute expects string values that Angular
    can use in the `document.querySelector` . In the application component, we have
    something similar:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`select`属性期望Angular可以在`document.querySelector`中使用的字符串值。在应用程序组件中，我们有类似的东西：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here is the resulting markup generated by Angular:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Angular生成的结果标记：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![Native view encapsulation](Image00133.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![原生视图封装](Image00133.jpg)'
- en: Tip
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can find the source code at `chapter_8/1.view-encapsulation` .
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter_8/1.view-encapsulation`找到源代码。
- en: 'Now, we know that content projection is the way Angular imports HTML content
    from outside of the component and inserts it into the designed part of the template.
    When Angular projects the external content into a component it calls the hook
    methods of the `AfterContentInit` and `AfterContentChecked` interfaces:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道内容投影是 Angular 从组件外部导入 HTML 内容并将其插入到模板的设计部分的方式。当 Angular 把外部内容投影到组件中时，它会调用
    `AfterContentInit` 和 `AfterContentChecked` 接口的钩子方法：
- en: After Angular projects the external content into its view and the content has
    been initialized, it calls the `ngAfterContentInit` method
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Angular 把外部内容投影到其视图中并且内容已初始化后，它会调用 `ngAfterContentInit` 方法
- en: After Angular checks the bindings of the external content that it has projected
    into its view, it calls the `ngAfterContentChecked` hook method
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Angular 检查它投影到其视图中的外部内容的绑定后，它会调用 `ngAfterContentChecked` 钩子方法
- en: 'We can use any of those to manipulate properties of the content''s elements.
    To organize access to one or many content elements, we must take the parent component''s
    property and decorate it with `@ContentChild` or `@ContentChildren` . Angular
    uses parameters passing into the decorator to select the content''s elements:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用其中任何一个来操作内容元素的属性。为了组织对一个或多个内容元素的访问，我们必须获取父组件的属性并用 `@ContentChild` 或 `@ContentChildren`
    进行装饰。Angular 使用传递给装饰器的参数来选择内容元素：
- en: If the parameter is a type, Angular will find an element bounded to a directive
    or a component with the same type
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数是一个类型，Angular 将找到与相同类型的指令或组件绑定的元素
- en: If the parameter is a string, Angular will interpret it as a selector to find
    corresponding elements
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数是一个字符串，Angular 将解释它为一个选择器，以查找相应的元素
- en: 'Angular sets the value of the decorated property before calling the `ngAfterContentInit`
    method so that we can access it within the method. Later, when Angular checks
    and updates the content elements, it calls `ngAfterContentChecked` to inform us
    that the containing elements were updated. Let''s have a look at how can we use
    it. Here is the child component we will use as a content of the parent component:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 在调用 `ngAfterContentInit` 方法之前设置装饰属性的值，以便我们可以在方法内部访问它。稍后，当 Angular 检查和更新内容元素时，它会调用
    `ngAfterContentChecked` 来通知我们包含元素已更新。让我们看看如何使用它。这是我们将用作父组件内容的子组件：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will look at the `status` property of the child component and print out
    the values on the console from the parent component:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看子组件的 `status` 属性，并从父组件在控制台上打印出值：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s combine them together inside the application component template:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将它们组合在应用程序组件模板中：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, run the application and we will get the following login console:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行应用程序，我们将在控制台上得到以下登录信息：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can find the source code for this at `chapter_8/2.after-content` .
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `chapter_8/2.after-content` 找到此源代码。
- en: After view (only for components)
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图之后（仅适用于组件）
- en: 'When Angular finishes the initialization of the component''s view and its children''s
    views, it calls the methods of the two hook interfaces, `AfterViewInit` and `AfterViewChecked`
    . We can use the moment of initialization to update or manipulate view elements:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Angular 完成组件视图及其子视图的初始化时，它会调用两个钩子接口 `AfterViewInit` 和 `AfterViewChecked` 的方法。我们可以利用初始化的时刻来更新或操作视图元素：
- en: Angular calls the `ngAfterViewInit` method when it finishes initialization of
    the component's view and its children's view
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 Angular 完成组件视图及其子视图的初始化时，它会调用 `ngAfterViewInit` 方法
- en: Angular calls the `ngAfterViewChecked` method after every check on the bindings
    of the component's view and the view of its children's view
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 在检查组件视图的绑定和其子视图的视图之后调用 `ngAfterViewChecked` 方法
- en: 'We can use either of these to manipulate view elements. To organize access
    to one or many view elements, we must have the property in the parent component
    and decorate it with `@ViewChild` or `@ViewChildren` . Angular uses parameters
    passing into the decorator to select view elements:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用其中任何一个来操作视图元素。为了组织对一个或多个视图元素的访问，我们必须在父组件中拥有该属性，并用`@ViewChild`或`@ViewChildren`装饰它。Angular使用传递到装饰器的参数来选择视图元素：
- en: If the parameter is a type, Angular will find an element bounded to a directive
    or a component with the same type
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数是一个类型，Angular将找到一个与相同类型的指令或组件绑定的元素
- en: If the parameter is a string, Angular will interpret it as a selector to find
    corresponding elements
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数是一个字符串，Angular会将其解释为一个选择器，以找到相应的元素
- en: 'Angular sets the value of the decorated property before calling the `ngAfterViewInit`
    method. Later, after every check and update of the view elements, it calls `ngAfterViewChecked`
    to inform us that the viewing elements were updated. Let''s have a look at how
    we can use it. Here is the child component we will use in the template of the
    parent component:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`ngAfterViewInit`方法之前，Angular会设置装饰属性的值。稍后，在检查和更新视图元素后，它会调用`ngAfterViewChecked`来通知我们视图元素已更新。让我们看看我们如何使用它。这是我们将在父组件模板中使用的子组件：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We are watching the `status` property of the child component and will print
    out the values on the console from parent component:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在观察子组件的`status`属性，并将从父组件打印出值：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Bear in mind that we use `OnPush` change detection in this code to prevent
    cycling invocation of the `ngAfterViewChecked` method. Here is the application
    component template:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们在这段代码中使用`OnPush`变更检测，以防止循环调用`ngAfterViewChecked`方法。这是应用程序组件模板：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, run application and we will get the following login console:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行应用程序，我们将得到以下登录控制台：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tip
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can find the source code for this at the `chapter_8/3.after-view` .
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`chapter_8/3.after-view`找到这个的源代码。
- en: Parent to child communications
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从父到子的通信
- en: Organizing the communication between parent and child components is not trivial,
    so let's talk about different techniques we can use to achieve that.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 组织父子组件之间的通信并不是微不足道的，所以让我们谈谈我们可以使用的不同技术来实现这一点。
- en: Parent to child communication via input binding
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过输入绑定进行父到子的通信
- en: 'Every directive may have one or more input properties. We can bind any property
    of a child component with static string or the parent component variables to organize
    communication between them. Here is the child component:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 每个指令可能有一个或多个输入属性。我们可以将子组件的任何属性与静态字符串或父组件变量绑定，以组织它们之间的通信。这是子组件：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It has three input properties marked with `@Input` decorators:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 它有三个用`@Input`装饰器标记的输入属性：
- en: The property `desc` is decorated by its natural name
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性`desc`由其自然名称装饰
- en: The property `parent` is decorated with an alias name so that the parent component
    will see it by name `owner`
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性`parent`用别名装饰，以便父组件将其视为`owner`的名称
- en: The property `emoji` is a combination of getter/setter methods so that we can
    add some logic to assign values to a private variable
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性`emoji`是一组getter/setter方法的组合，这样我们可以添加一些逻辑来为私有变量分配值
- en: 'It has one output property `status` to communicate from child to parent. I
    intentionally added an `OnInit` hook interface so that we can send a message back
    to the parent after the creation of a child. Here is the parent component:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个输出属性`status`，用于从子级到父级进行通信。我特意添加了一个`OnInit`钩子接口，这样我们可以在创建子级后向父级发送消息。这是父组件：
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The parent component sets all the input properties of the child and listens
    to the `status` event in the `onStatus` method. After creation, the child component
    emits the status event and the parent component prints that information close
    to the title.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 父组件设置子组件的所有输入属性，并在`onStatus`方法中监听`status`事件。创建后，子组件会发出状态事件，父组件会在标题附近打印该信息。
- en: '![Parent to child communication via input binding](Image00134.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![通过输入绑定进行父子通信](Image00134.jpg)'
- en: Tip
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can find the source code for this at `chapter_8/4.parent-child-input-binding`
    .
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter_8/4.parent-child-input-binding`找到此源代码。
- en: Parent to child communication via a local variable
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过本地变量进行父子通信
- en: 'The parent element has no access to properties or methods of the child component.
    We can create a template reference variable within the parent template to organize
    access to child component class members:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 父元素无法访问子组件的属性或方法。我们可以在父模板中创建一个模板引用变量，以便访问子组件的类成员：
- en: '[PRE34]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the preceding parent component, we created the `child` local template variable
    and used it within the `NgInit` directive to call the `setDesc` method of the
    child component:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的父组件中，我们创建了`child`本地模板变量，并在`NgInit`指令中使用它来调用子组件的`setDesc`方法：
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There is a `NgInit` directive we used to initialize the `desc` property of
    the child component:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`NgInit`指令来初始化子组件的`desc`属性：
- en: '[PRE36]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tip
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can find the source code for this at `chapter_8/5.parent-child-local-variable`
    .
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter_8/5.parent-child-local-variable`找到此源代码。
- en: Parent-child communication via a call to ViewChild
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过调用ViewChild进行父子通信
- en: 'When we need to have access to the child component from the parent we can use
    `AfterViewInit` and `AfterViewChecked` hooks. Angular calls them after it creates
    the child views of a component. Here is the child component:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要从父组件访问子组件时，我们可以使用`AfterViewInit`和`AfterViewChecked`钩子。Angular在创建组件的子视图后调用它们。以下是子组件：
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The parent component imports the necessary classes and implements the `AfterViewInit`
    interface:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 父组件导入必要的类并实现`AfterViewInit`接口：
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We are injecting the child component into the parent with the help of the `@ViewChild`
    decorator introduced previously. The `AfterViewInit` interface is very important
    in this scenario because the `child` component is unavailable until the Angular
    displays the parent view and calls the `ngAfterViewInit` method.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过之前介绍的`@ViewChild`装饰器将子组件注入到父组件中。在这种情况下，`AfterViewInit`接口非常重要，因为在Angular显示父视图并调用`ngAfterViewInit`方法之前，`child`组件是不可用的。
- en: Tip
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can find the source code for this at `chapter_8/6.parent-child-viewchild`
    .
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter_8/6.parent-child-viewchild`找到此源代码。
- en: Parent-child communication via a service
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过服务进行父子通信
- en: 'Another possible way to organize parent-child communication is via a common
    service. We assign the service to a parent component and lock the scope of the
    service instance between this parent component and its children. No single component
    outside of this subtree will have access to the service or their communications.
    Here, the child component has access to the service injectable via the constructor:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 组织父子通信的另一种可能方式是通过一个公共服务。我们将服务分配给父组件，并在该父组件和其子组件之间锁定服务实例的范围。此子树之外的任何单个组件都无法访问该服务或它们的通信。在这里，子组件可以通过构造函数注入来访问服务：
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We run a subscription on messages coming from the parent component in the constructor.
    Please be careful of the `OnDestroy` interface at implementation. The code in
    the `ngOnDestroy` method is a memory-leak guard step. The parent component has
    a `CommonService` registered as a provider and injected through the constructor:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构造函数中对来自父组件的消息进行订阅。请在实现时注意`OnDestroy`接口。`ngOnDestroy`方法中的代码是一个内存泄漏保护步骤。父组件已经注册了一个`CommonService`作为提供者，并通过构造函数注入：
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We don't need the memory-leak guard step here because the parent component controls
    the lifetime of the registered provider.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们不需要内存泄漏保护步骤，因为父组件控制着注册提供者的生命周期。
- en: Tip
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can find the source code for this at `chapter_8/7.parent-child-service`
    .
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter_8/7.parent-child-service`找到此源代码。
- en: Destroying
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁
- en: 'This stage is the last one whilst a directive still exists. We can implement
    the `OnDestroy` interface to catch this moment:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段是最后一个存在指令的阶段。我们可以实现`OnDestroy`接口来捕获这一时刻：
- en: Angular calls the `ngOnDestroy` method before destroying the directive
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在销毁指令之前，Angular会调用`ngOnDestroy`方法
- en: Angular adds cleanup logic to this method to unsubscribe observables and detach
    event handlers to avoid memory leaks
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular在这个方法中添加了清理逻辑，以取消订阅可观察对象并分离事件处理程序，以避免内存泄漏
- en: We can notify another component (parent or sibling) about the fact that the
    directive will disappear soon. We must free allocated resources, unsubscribe from
    observables and DOM event listeners, and unregister all callbacks from services.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通知另一个组件（父组件或同级组件），指令即将消失。我们必须释放分配的资源，取消订阅可观察对象和DOM事件监听器，并取消来自服务的所有回调。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discovered the lifecycle of components and the methods that
    can be used at different stages of them. We learned that Angular has interfaces
    with hook methods and how to make the most of the hook methods that are triggered
    when a component moves from one stage to another.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了组件的生命周期以及可以在不同阶段使用的方法。我们了解到Angular具有具有钩子方法的接口，以及如何充分利用这些钩子方法，这些钩子方法在组件从一个阶段转移到另一个阶段时触发。
- en: We unveiled how Angular change detection works and how we can manage it. We
    discussed how to organize communication between components.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们揭示了Angular变化检测的工作原理以及我们如何管理它。我们讨论了如何组织组件之间的通信。
- en: In [Chapter 9](text00085.html#page "Chapter 9. Communication and Data Persistence")
    , *Communication and Data Persistence* , we will work at HTTP requests and store
    data on the Firebase platform. We will learn how to use the built-in HTTP library
    to work with endpoints. Also, we will learn how to use observables to work with
    data. At the end of the chapter, we will learn how to work with Firebase as the
    persistence layer of the app. As usual, we will continue to build the project
    that we started to develop in previous chapters.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](text00085.html#page "第9章。通信和数据持久性")中，*通信和数据持久性*，我们将学习如何进行HTTP请求并在Firebase平台上存储数据。我们将学习如何使用内置的HTTP库来处理端点。此外，我们还将学习如何使用可观察对象来处理数据。在本章末尾，我们将学习如何将Firebase作为应用程序的持久性层。与往常一样，我们将继续构建我们在之前章节中开始开发的项目。
