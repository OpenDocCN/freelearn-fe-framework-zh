<html><head></head><body>
<div id="_idContainer062">
<h1 class="chapter-number" id="_idParaDest-113"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-114"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.2.1">Mastering Reactivity with Angular Signals</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Modern web applications thrive on reactivity, where data changes automatically, thereby triggering updates in the UI. </span><span class="koboSpan" id="kobo.3.2">Angular Signals, introduced in version 17, streamlines this process by offering a powerful and concise way to manage reactive data within your </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">Angular applications.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">This chapter delves into the core concepts, API functionalities, advantages, and relationship of Signals with RxJS. </span><span class="koboSpan" id="kobo.5.2">We will also see how we can improve the reactivity of our Recipe app further using </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">Angular Signals.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">So, in this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Understanding the motivation </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">behind Signals</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Unveiling the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">Signal API</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Unlocking the Power of RxJS and </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">Angular Signals</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Integrating Signals into our </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">recipe</span></span><span class="No-Break"><span class="koboSpan" id="kobo.17.1"> app</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Reactive data binding </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">with Signals</span></span></li>
</ul>
<h1 id="_idParaDest-115"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.20.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.21.1">The source code for this chapter is available at </span><a href="https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap08"><span class="koboSpan" id="kobo.22.1">https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap08</span></a><span class="koboSpan" id="kobo.23.1"> (this only includes the code related to the </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">recipe</span></span><span class="No-Break"><span class="koboSpan" id="kobo.25.1"> app).</span></span></p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.26.1">Understanding the motivation behind Signals</span></h1>
<p><span class="koboSpan" id="kobo.27.1">The main goal behind the Angular team’s introduction of Signals is to add more fine-grained reactivity to the </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.28.1">framework. </span><span class="koboSpan" id="kobo.28.2">This new Signal-based reactive system marks a significant leap forward in the framework’s ability to handle dynamic data and user interactions. </span><span class="koboSpan" id="kobo.28.3">It offers a fresh approach to detecting and triggering changes within the framework, replacing the traditional approach that relies </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">on Zone.js.</span></span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.30.1">The traditional Zone.js approach</span></h2>
<p><span class="koboSpan" id="kobo.31.1">Angular’s traditional change</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.32.1"> detection mechanism assumes that any event handler can potentially change any bound data to the template. </span><span class="koboSpan" id="kobo.32.2">That’s why, whenever an event </span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.33.1">happens in your Angular application, the framework scans all components and their data bindings for any potential changes. </span><span class="koboSpan" id="kobo.33.2">This can be a bit heavy-handed, especially for complex applications. </span><span class="koboSpan" id="kobo.33.3">For this reason, a more optimized mode </span><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">OnPush</span></strong><span class="koboSpan" id="kobo.35.1"> change detection was introduced. </span><span class="koboSpan" id="kobo.35.2">This mode leverages the concepts of immutability and Observables, allowing Angular to significantly reduce the number of components it needs to check for updates. </span><span class="koboSpan" id="kobo.35.3">This was explored in </span><a href="B21180_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.36.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.37.1">, </span><em class="italic"><span class="koboSpan" id="kobo.38.1">Fetching Data </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.39.1">as Streams</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">Whether you use the default change detection or the more optimized </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">OnPush</span></strong><span class="koboSpan" id="kobo.43.1"> mode, Angular still needs to stay informed when event handlers have finished running. </span><span class="koboSpan" id="kobo.43.2">This presents a challenge because the browser – not Angular itself – triggers these event handlers. </span><span class="koboSpan" id="kobo.43.3">This is where Zone.js steps in, essentially acting as a bridge. </span><span class="koboSpan" id="kobo.43.4">Zone.js can detect when an event handler has run, telling Angular, “Hey, there’s a new event; you can take care of any necessary </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">updates now.”</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">While this approach has worked well in the past, it still comes with a few downsides: when changes are made, the whole component tree and all the expressions on every component are always checked. </span><span class="koboSpan" id="kobo.45.2">There is no way for Angular to directly identify changed components or to just update the changed parts of a component. </span><span class="koboSpan" id="kobo.45.3">That is why Angular cannot make any assumptions about what happened and needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">check everything!</span></span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.47.1">The new Signals approach</span></h2>
<p><span class="koboSpan" id="kobo.48.1">With Signals, Angular can easily </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.49.1">detect when any part of the application data changes and update any dependencies automatically. </span><span class="koboSpan" id="kobo.49.2">Signals enable efficient change detection, smarter</span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.50.1"> re-rendering when data changes, and facilitate fine-grained updates to the DOM, reducing the runtime required for Angular to check all components, even if their consumed data remains unchanged. </span><span class="koboSpan" id="kobo.50.2">Ultimately, this can eliminate the</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.51.1"> need for Zone.js in one of the </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">future versions:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<span class="koboSpan" id="kobo.53.1"><img alt="Figure 8.1: Comparing the various change detection approaches" src="image/B21180_08_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.54.1">Figure 8.1: Comparing the various change detection approaches</span></p>
<p><span class="koboSpan" id="kobo.55.1">Apart from improving change detection, there are other advantages of </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">using Signals:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.57.1">It provides a more intuitive and declarative way to manage </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">reactive data</span></span></li>
<li><span class="koboSpan" id="kobo.59.1">The syntax aligns more closely with JavaScript, making code easier to read, understand, </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">and maintain.</span></span></li>
<li><span class="koboSpan" id="kobo.61.1">The compiler performs better type narrowing for improved type safety within your </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">reactive code.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.63.1">As we progress through this chapter, you’ll gain a clearer understanding of Signals. </span><span class="koboSpan" id="kobo.63.2">Eager to discover more? </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">Let’s continue.</span></span></p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.65.1">Unveiling the Signal API</span></h1>
<p><span class="koboSpan" id="kobo.66.1">In this section, we’ll delve into the world</span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.67.1"> of Signals, covering exactly what they are, how they work, and the revolutionary changes they bring to Angular. </span><span class="koboSpan" id="kobo.67.2">So, without further ado, let’s discover what a </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">Signal is.</span></span></p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.69.1">Defining Signals</span></h2>
<p><span class="koboSpan" id="kobo.70.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.71.1">Signal</span></strong><span class="koboSpan" id="kobo.72.1"> is a reactive entity within </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.73.1">Angular that encapsulates a value (serving as a container for a value) and automatically notifies consumers whenever that value changes. </span><span class="koboSpan" id="kobo.73.2">You can think of Angular’s Signals as a combination of a data value and a change notification mechanism, offering a streamlined approach to tracking changes and seamlessly updating the user interface in response to </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">those changes.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">While the concept of Signals is not novel and has existed in various forms across different frameworks for many years, their integration into Angular provides developers with a familiar yet powerful tool for managing reactive behavior within their applications. </span><span class="koboSpan" id="kobo.75.2">They act as wrappers around values, allowing you to efficiently track changes and </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">react accordingly.</span></span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.77.1">Creating Signals using the constructor function</span></h2>
<p><span class="koboSpan" id="kobo.78.1">We can create a Signal using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">signal</span></strong><span class="koboSpan" id="kobo.80.1"> constructor function available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">angular/core</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.83.1"> package.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">An initial value is always required as a</span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.85.1"> Signal must always have a value. </span><span class="koboSpan" id="kobo.85.2">Signals </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.86.1">can hold a wide range of values, including simple primitives, such as strings and numbers, as well as more complex data structures, such as arrays </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">and objects.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">Plus, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">signal</span></strong><span class="koboSpan" id="kobo.90.1"> function provides type flexibility. </span><span class="koboSpan" id="kobo.90.2">You can either explicitly define the type of the Signal’s value or leverage type inference based on the initial value. </span><span class="koboSpan" id="kobo.90.3">For example, the following code creates and initializes a Signal with a value of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">John Doe</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.93.1">
import { signal } from '@angular/core';
const name=signal('John Doe');</span></pre> <p><span class="koboSpan" id="kobo.94.1">In this example, we didn’t define a type for our Signal’s value. </span><span class="koboSpan" id="kobo.94.2">If you don’t explicitly specify a type, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">signal</span></strong><span class="koboSpan" id="kobo.96.1"> function can infer the type based on the initial value you provide. </span><span class="koboSpan" id="kobo.96.2">So, here, the type can be inferred from the initial value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">John Doe</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.98.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">string</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">But what if you want to be extra clear</span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.102.1"> about the type? </span><span class="koboSpan" id="kobo.102.2">That’s perfectly possible! </span><span class="koboSpan" id="kobo.102.3">Here’s how you would explicitly define </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">the type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.104.1">
name = signal&lt;string&gt;('John Doe');</span></pre> <p><span class="koboSpan" id="kobo.105.1">As you can see, we added </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">&lt;string&gt;</span></strong><span class="koboSpan" id="kobo.107.1"> after </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">signal</span></strong><span class="koboSpan" id="kobo.109.1"> to explicitly state that the Signal will hold string values. </span><span class="koboSpan" id="kobo.109.2">While type inference works well in many cases, explicitly defining types can improve </span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.110.1">code readability and maintainability, especially for </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">larger projects.</span></span></p>
<p><span class="koboSpan" id="kobo.112.1">Now, let’s look at an example of a Signal holding an array. </span><span class="koboSpan" id="kobo.112.2">Imagine that you want to define a Signal that represents an array </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">of currencies:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.114.1">
currencies=signal(['EURO', 'DOLLAR', 'Japanese yen', 'Sterling'])</span></pre> <p><span class="koboSpan" id="kobo.115.1">Here, the initial value is an array of strings, so the type of the Signal will be inferred as an array of </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">strings, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">string[]</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">Now, thinking of our Recipe app, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">favouriteRecipe</span></strong><span class="koboSpan" id="kobo.121.1"> Signal holds a </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">Recipe</span></strong><span class="koboSpan" id="kobo.123.1"> object and is of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">Recipe</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.125.1"> type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.126.1">
favouriteRecipe=signal&lt;Recipe&gt;({
  id: 1,
  title: "Lemon cake",
  prepTime: 10,
  cookingTime: 35,
  yield: 10,
  imageUrl: "lemon-cake.jpg"
})</span></pre> <p><span class="koboSpan" id="kobo.127.1">Here, we explicitly defined the specific type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">Recipe</span></strong><span class="koboSpan" id="kobo.129.1">. </span><span class="koboSpan" id="kobo.129.2">If you’re working with a specific type throughout your code, explicit type definition provides clarity and prevents potential type mismatches. </span><span class="koboSpan" id="kobo.129.3">However, when the type is different from the initial value or may vary, you can avoid explicitly writing it, making your code cleaner and </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">more concise.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">Once we have a Signal, we often </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.132.1">want to read it and retrieve its value. </span><span class="koboSpan" id="kobo.132.2">But how can we do that? </span><span class="koboSpan" id="kobo.132.3">We’ll find out in</span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.133.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">next section.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.135.1">Reading Signals</span></h2>
<p><span class="koboSpan" id="kobo.136.1">One way to read a Signal’s </span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.137.1">value is by using the Signal’s getter. </span><span class="koboSpan" id="kobo.137.2">Here’s an example that reads the value of the previously created Signals and logs it in </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">the console:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.139.1">
console.log(this.name());
console.log(this.favouriteRecipe());
//console output
John Doe
{"id": 1,"title": "Lemon cake","prepTime": 10, "cookingTime": 35,"yield": 10,"imageUrl": "lemon- cake.jpg" }
}</span></pre> <p><span class="koboSpan" id="kobo.140.1">You can use this getter to read Signals in your Angular components, services, </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">and directives.</span></span></p>
<p><span class="koboSpan" id="kobo.142.1">You can also read Signals in your component template to display </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">a value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.144.1">
@for (currency of currencies(); track currency) {
&lt;option&gt;{{currency}}&lt;/option&gt;
} @empty {
&lt;div&gt;There are no currencies&lt;/div&gt;
}
&lt;div&gt;{{favouriteRecipe().title}}&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.145.1">Reading a Signal in a template returns the current Signal’s value and registers the Signal as a dependency of the template. </span><span class="koboSpan" id="kobo.145.2">If the Signal changes, the portion of the template </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">is re-rendered.</span></span></p>
<p><span class="koboSpan" id="kobo.147.1">Signals that are created using</span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.148.1"> the signal creator function are </span><em class="italic"><span class="koboSpan" id="kobo.149.1">writable</span></em><span class="koboSpan" id="kobo.150.1">. </span><span class="koboSpan" id="kobo.150.2">This means you can modify their values after their creation. </span><span class="koboSpan" id="kobo.150.3">We’ll learn how to modify the value of a Signal in the </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">next section.</span></span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.152.1">Modifying a writable Signal</span></h2>
<p><span class="koboSpan" id="kobo.153.1">Signals that are created </span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.154.1">using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">creation</span></strong><span class="koboSpan" id="kobo.156.1"> function are of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">WritableSignal</span></strong><span class="koboSpan" id="kobo.158.1"> type and offer an API specifically for updating their values. </span><span class="koboSpan" id="kobo.158.2">There are two primary methods for modifying the stored value of a </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">writable Signal:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.160.1">Using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">set</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.162.1"> method</span></span></li>
<li><span class="koboSpan" id="kobo.163.1">Using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">update</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.165.1"> method</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.166.1">Let’s look at </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">them both.</span></span></p>
<h3><span class="koboSpan" id="kobo.168.1">Using the set method</span></h3>
<p><span class="koboSpan" id="kobo.169.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">set</span></strong><span class="koboSpan" id="kobo.171.1"> method lets you </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.172.1">directly set a new value for the Signal. </span><span class="koboSpan" id="kobo.172.2">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.174.1">
name = signal('John Doe');
console.log(this.name());
this.name.set('Mary Jane');
console.log(this.name());
//console output
John Doe
Mary Jane</span></pre> <p><span class="koboSpan" id="kobo.175.1">Here, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">set</span></strong><span class="koboSpan" id="kobo.177.1"> method to update the Signal’s value from </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">John Doe</span></strong><span class="koboSpan" id="kobo.179.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">Mary Jane</span></strong><span class="koboSpan" id="kobo.181.1">. </span><span class="koboSpan" id="kobo.181.2">This is a simple and effective way to assign a new value when you know how the value needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">be changed.</span></span></p>
<h3><span class="koboSpan" id="kobo.183.1">Using the update method</span></h3>
<p><span class="koboSpan" id="kobo.184.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">update</span></strong><span class="koboSpan" id="kobo.186.1"> method allows us to </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.187.1">compute a new value from the previous one, </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.189.1">
name = signal('John Doe');
console.log(this.name());
this.name.update(value=&gt;'Full Name: '+ value);
console.log(this.name());
//console output
Full Name: John Doe</span></pre> <p><span class="koboSpan" id="kobo.190.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">update</span></strong><span class="koboSpan" id="kobo.192.1"> method, we appended </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">Full Name:</span></strong><span class="koboSpan" id="kobo.194.1"> to the old Signal’s value, </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">John Doe</span></strong><span class="koboSpan" id="kobo.196.1">. </span><span class="koboSpan" id="kobo.196.2">The Signal maintains a record of value changes over time. </span><span class="koboSpan" id="kobo.196.3">When the value changes, the Signal notifies subscribed components or logic, prompting necessary UI or data flow modifications. </span><span class="koboSpan" id="kobo.196.4">Every part of the Angular component that depends on the Signal will be automatically updated once the </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">value changes.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">So far, so good! </span><span class="koboSpan" id="kobo.198.2">Now that you’re comfortable with the basics of Signals, what if you could create Signals that automatically react to changes in other Signals? </span><span class="koboSpan" id="kobo.198.3">In other words, what if you need Signals that depend on other Signals? </span><span class="koboSpan" id="kobo.198.4">Well, that’s where computed Signals come </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">into play!</span></span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.200.1">Computed Signals</span></h2>
<p><span class="koboSpan" id="kobo.201.1">Computed Signals deduce their value from other Signals, offering a declarative way to define relationships between Signals</span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.202.1"> and ensure your data remains consistent. </span><span class="koboSpan" id="kobo.202.2">Let’s focus on a simple example to understand </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">the behavior:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.204.1">
import { signal, computed } from '@angular/core';
const firstName = signal('John');
const lastName = signal('Doe');
const fullName = computed(() =&gt; `${firstName()} ${lastName()}`);</span></pre> <p><span class="koboSpan" id="kobo.205.1">In this code block, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">fullName</span></strong><span class="koboSpan" id="kobo.207.1"> computed Signal derives its value from both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">firstName</span></strong><span class="koboSpan" id="kobo.209.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">lastName</span></strong><span class="koboSpan" id="kobo.211.1"> Signals. </span><span class="koboSpan" id="kobo.211.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">computed</span></strong><span class="koboSpan" id="kobo.213.1"> function simply appends the </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">firstName</span></strong><span class="koboSpan" id="kobo.215.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">lastName</span></strong><span class="koboSpan" id="kobo.217.1"> values. </span><span class="koboSpan" id="kobo.217.2">So, </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">fullName</span></strong><span class="koboSpan" id="kobo.219.1"> depends on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">firstName</span></strong><span class="koboSpan" id="kobo.221.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">lastName</span></strong><span class="koboSpan" id="kobo.223.1"> Signals, which means that whenever either </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">firstName</span></strong><span class="koboSpan" id="kobo.225.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">lastName</span></strong><span class="koboSpan" id="kobo.227.1"> changes, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">fullName</span></strong><span class="koboSpan" id="kobo.229.1"> Signal automatically updates, reflecting the </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">complete name.</span></span></p>
<p><span class="koboSpan" id="kobo.231.1">Note that the computed Signal is lazy evaluated and cached. </span><span class="koboSpan" id="kobo.231.2">This means that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">computed</span></strong><span class="koboSpan" id="kobo.233.1"> function doesn’t execute to calculate its value until the first time you read the calculated Signal (</span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">fullName</span></strong><span class="koboSpan" id="kobo.235.1">, in our case). </span><span class="koboSpan" id="kobo.235.2">The calculated value is then cached, and if you read </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">fullName</span></strong><span class="koboSpan" id="kobo.237.1"> again, it will return the cached value without re-executing the calculation function. </span><span class="koboSpan" id="kobo.237.2">Then, if the </span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.238.1">value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">firstName</span></strong><span class="koboSpan" id="kobo.240.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">lastName</span></strong><span class="koboSpan" id="kobo.242.1"> changes, Angular knows that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">fullName</span></strong><span class="koboSpan" id="kobo.244.1"> cached value is no longer valid, and the next time you read </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">fullName</span></strong><span class="koboSpan" id="kobo.246.1">, its new value will be re-calculated. </span><span class="koboSpan" id="kobo.246.2">So, the calculation function will </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">re-execute again.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.248.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.249.1">Unlike </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">WritableSignals</span></strong><span class="koboSpan" id="kobo.251.1">, computed Signals are read-only, so you can’t change their values. </span><span class="koboSpan" id="kobo.251.2">Even trying to set a value will result in a </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">compilation error.</span></span></p>
<p><span class="koboSpan" id="kobo.253.1">Now that we’ve looked at computed Signals, which automatically react to changes in other Signals, what if you need to perform actions beyond simply updating data, such as making API calls or interacting with other components? </span><span class="koboSpan" id="kobo.253.2">This is where Signal effects </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">step in!</span></span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.255.1">Signal effects</span></h2>
<p><span class="koboSpan" id="kobo.256.1">Signal effects are functions that execute</span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.257.1"> in response to Signal changes. </span><span class="koboSpan" id="kobo.257.2">They provide us with a way to perform side effects, such as logging data, or manipulating the DOM to perform custom rendering or adding a </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">custom behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.259.1">Let’s look at an example. </span><span class="koboSpan" id="kobo.259.2">Here’s some code in the </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">HTML template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.261.1">
&lt;button (click)="update()"&gt;Update&lt;/button&gt;</span></pre> <p><span class="koboSpan" id="kobo.262.1">And here’s some TypeScript </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">code :</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.264.1">
counter = signal(0);
constructor() {
  effect(() =&gt; {
    console.log('The updated value is', this.counter());
  });
}
update() {
  this.counter.update((current) =&gt; current + 1);
}</span></pre> <p><span class="koboSpan" id="kobo.265.1">This code creates a counter that starts at </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">0</span></strong><span class="koboSpan" id="kobo.267.1">. </span><span class="koboSpan" id="kobo.267.2">Then, clicking the created </span><strong class="bold"><span class="koboSpan" id="kobo.268.1">Update</span></strong><span class="koboSpan" id="kobo.269.1"> button increments the counter value by </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">1</span></strong><span class="koboSpan" id="kobo.271.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">effect</span></strong><span class="koboSpan" id="kobo.273.1"> logs the updated value to </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">the console.</span></span></p>
<p><span class="koboSpan" id="kobo.275.1">Note that effects require an injection context to function properly, such as during the construction of a component</span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.276.1"> or service. </span><span class="koboSpan" id="kobo.276.2">That’s why we called it inside the constructor in the previous example. </span><span class="koboSpan" id="kobo.276.3">This means it needs to be called within a specific environment where Angular’s dependency injection system </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">is available.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">But why? </span><span class="koboSpan" id="kobo.278.2">Well, because Signal effects might internally rely on other Angular services or functionalities that are managed by the dependency injection system. </span><span class="koboSpan" id="kobo.278.3">So, we should ensure that all necessary dependencies are properly injected and accessible for effects to work as intended. </span><span class="koboSpan" id="kobo.278.4">Running it outside this context could lead to errors because these dependencies wouldn’t </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">be available.</span></span></p>
<p><span class="koboSpan" id="kobo.280.1">Having explored the core functionalities and concepts of Signals, you might be wondering how they compare to RxJS. </span><span class="koboSpan" id="kobo.280.2">Both offer mechanisms for managing data streams, so how do they differ? </span><span class="koboSpan" id="kobo.280.3">And can they work together? </span><span class="koboSpan" id="kobo.280.4">These are crucial questions we’ll address in the </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">next section.</span></span></p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.282.1">Unlocking the power of RxJS and Angular Signals</span></h1>
<p><span class="koboSpan" id="kobo.283.1">While Angular Signals serves as a</span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.284.1"> lightweight wrapper for reactive data with a simplified API, RxJS offers a comprehensive library for handling asynchronous streams, thus remaining crucial for handling more complex reactive </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">programming requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.286.1">Here’s a concise comparison of </span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.287.1">Signals and </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">RxJS</span></span><span class="No-Break"><a id="_idIndexMarker331"/></span><span class="No-Break"><span class="koboSpan" id="kobo.289.1"> Observables:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.290.1">Feature</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.291.1">Signals</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.292.1">Observables</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.293.1">Value representation</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.294.1">Hold a single value at </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">a time.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.296.1">Emit values </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">over time.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.298.1">Subscription</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.299.1">Subscription </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">is implicit.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.301.1">Require </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">explicit subscriptions.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.303.1">Updates capability</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.304.1">Updated by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">set</span></strong><span class="koboSpan" id="kobo.306.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">update</span></strong><span class="koboSpan" id="kobo.308.1"> method or using a </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">computed Signal.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.310.1">Updated by emitting </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">new values.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.312.1">Change detection</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.313.1">Improve change detection performance. </span><span class="koboSpan" id="kobo.313.2">Angular can efficiently track</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.314.1"> changes and re-render</span><a id="_idIndexMarker333"/> <span class="No-Break"><span class="koboSpan" id="kobo.315.1">when needed.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.316.1">Using Observables might trigger inefficient </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">change detection.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.318.1">Providing notification</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.319.1">Notify consumers when the hold data changes, facilitating value recalculation or </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">template re-rendering.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.321.1">Notify consumers when an event occurs or data is emitted, facilitating value recalculation or </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">template re-rendering.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.323.1">Reacting </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.324.1">to notification</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.325.1">React to notifications </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">using effects.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.327.1">React to notifications </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">using callbacks.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.329.1">Figure 8.2: Signals versus Observables</span></p>
<p><span class="koboSpan" id="kobo.330.1">But when should you use each one? </span><span class="koboSpan" id="kobo.330.2">Well, RxJS shines in scenarios demanding complex reactive data flows. </span><span class="koboSpan" id="kobo.330.3">These include </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.332.1">Managing multiple streams, often arising from asynchronous operations such as </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">HTTP requests</span></span></li>
<li><span class="koboSpan" id="kobo.334.1">Handling complex data manipulation such as combination, merging, transforming, </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">and filtering</span></span></li>
<li><span class="koboSpan" id="kobo.336.1">Reacting to </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">each</span></span><span class="No-Break"><a id="_idIndexMarker334"/></span><span class="No-Break"><span class="koboSpan" id="kobo.338.1"> emission</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.339.1">On the other hand, Signals </span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.340.1">are good for the </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">following aspects:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.342.1">Simple reactive data management within components, side effects, </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">and calculations</span></span></li>
<li><span class="koboSpan" id="kobo.344.1">Data binding scenarios where you want to track changes and trigger targeted </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">UI updates</span></span></li>
<li><span class="koboSpan" id="kobo.346.1">Situations where a simpler syntax and potentially improved change detection performance </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">are desired</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.348.1">Signals and RxJS are not mutually exclusive; they can be complementary tools in your Angular development. </span><span class="koboSpan" id="kobo.348.2">Angular has several RxJS interop features that make Signals and Observables play nicely in the same app, meaning you can get the benefits of both for a more powerful way to manage your data. </span><span class="koboSpan" id="kobo.348.3">These RxJS interop features can be found under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">@angular/core/rxjs-interop</span></strong><span class="koboSpan" id="kobo.350.1"> package and include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">toSignal()</span></strong><span class="koboSpan" id="kobo.352.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">toObservable()</span></strong><span class="koboSpan" id="kobo.354.1"> functions. </span><span class="koboSpan" id="kobo.354.2">We’ll look at both of </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">these now.</span></span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.356.1">Understanding the behavior of toSignal()</span></h2>
<p><span class="koboSpan" id="kobo.357.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">toSignal()</span></strong><span class="koboSpan" id="kobo.359.1"> function lets you</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.360.1"> create a Signal from an Observable. </span><span class="koboSpan" id="kobo.360.2">It provides synchronous access to the values that are emitted from the Observable, always containing the most recent emitted values by the Observable. </span><span class="koboSpan" id="kobo.360.3">But the coolest part is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">toSignal()</span></strong><span class="koboSpan" id="kobo.362.1"> automatically subscribes to the defined Observable and unsubscribes when the component or service that calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">toSignal()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.364.1">is destroyed.</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">So, we don’t have to manage subscriptions. </span><span class="koboSpan" id="kobo.365.2">Doesn’t this concept remind you of the async pipe? </span><span class="koboSpan" id="kobo.365.3">Indeed; both Signals and the async pipe offer ways to display reactive data in Angular templates. </span><span class="koboSpan" id="kobo.365.4">However, Signals provide greater flexibility. </span><span class="koboSpan" id="kobo.365.5">Unlike the async pipe, which is primarily used with Observables in templates, Signals can be used anywhere in your application for efficient </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">data management.</span></span></p>
<p><span class="koboSpan" id="kobo.367.1">But wait – earlier, we learned that a Signal should always have a value while Observables may not emit a value right away. </span><span class="koboSpan" id="kobo.367.2">And that’s true. </span><span class="koboSpan" id="kobo.367.3">That’s why </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">toSignal</span></strong><span class="koboSpan" id="kobo.369.1"> has the option to provide an initial value, which will represent the Signal’s value until the Observable emits. </span><span class="koboSpan" id="kobo.369.2">Here’s a</span><a id="_idIndexMarker337"/> <span class="No-Break"><span class="koboSpan" id="kobo.370.1">simple example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.371.1">
import { toSignal } from '@angular/core/rxjs-interop';
value$ = of([{ name: 'EURO', id: 1 }]);
valueAsSignal = toSignal(this.value$, { initialValue: [] });
constructor() {
effect = effect(() =&gt; console.log(this.valueAsSignal()));
}
//console output
{ name: 'EURO', id: 1 }</span></pre> <p><span class="koboSpan" id="kobo.372.1">In this example, we created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">value$</span></strong><span class="koboSpan" id="kobo.374.1"> Observable using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">of()</span></strong><span class="koboSpan" id="kobo.376.1"> creation function, which emits the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">[{ name: 'EURO', id: 1 }]</span></strong><span class="koboSpan" id="kobo.378.1"> array. </span><span class="koboSpan" id="kobo.378.2">Then, we created a Signal named </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">valueAsSignal</span></strong><span class="koboSpan" id="kobo.380.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">toSignal</span></strong><span class="koboSpan" id="kobo.382.1"> function. </span><span class="koboSpan" id="kobo.382.2">We pass two arguments to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">toSignal</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.384.1"> function:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">this.value$</span></strong><span class="koboSpan" id="kobo.386.1">: The Observable you want to convert into </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">a Signal.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">{ initialValue: [] }</span></strong><span class="koboSpan" id="kobo.389.1">: An optional object that allows you to customize the Signal’s behavior. </span><span class="koboSpan" id="kobo.389.2">Here, we’re setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">initialValue</span></strong><span class="koboSpan" id="kobo.391.1"> property to an empty array (</span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">[]</span></strong><span class="koboSpan" id="kobo.393.1">). </span><span class="koboSpan" id="kobo.393.2">This ensures that the Signal has a defined value even before the Observable emits its </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">first item.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.395.1">Finally, we registered an effect to log the Signal’s value in </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">the console.</span></span></p>
<p><span class="koboSpan" id="kobo.397.1">Note that if you don’t mention an initial value in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">toSignal</span></strong><span class="koboSpan" id="kobo.399.1"> function, the Signal will have </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">undefined</span></strong><span class="koboSpan" id="kobo.401.1"> as the initial value. </span><span class="koboSpan" id="kobo.401.2">Be aware that using </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">undefined</span></strong><span class="koboSpan" id="kobo.403.1"> as an initial value can always lead to many errors or inconsistencies, so it would be better to manage this when it’s created and provide an </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">initial value.</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">With that clear, why is this different from using an Observable? </span><span class="koboSpan" id="kobo.405.2">Let’s focus on </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">another example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.407.1">
import { toSignal } from '@angular/core/rxjs-interop';
values$ = of(10, 20, 30);
this.values$.subscribe(value=&gt; console.log(value));
//console output
10, 20, 30</span></pre> <p><span class="koboSpan" id="kobo.408.1">Here, we’re creating an Observable that uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">of</span></strong><span class="koboSpan" id="kobo.410.1"> creation function – we subscribe to it and log the values in the console. </span><span class="koboSpan" id="kobo.410.2">This Observable emits </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">10</span></strong><span class="koboSpan" id="kobo.412.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">20</span></strong><span class="koboSpan" id="kobo.414.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">30</span></strong><span class="koboSpan" id="kobo.416.1">, respectively, and those values will get logged in </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">the console.</span></span></p>
<p><span class="koboSpan" id="kobo.418.1">Now, let’s convert this </span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.419.1">Observable into </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">a Signal:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.421.1">
import { toSignal } from '@angular/core/rxjs-interop';
values$ = of(10, 20, 30);
valuesAsSignal = toSignal(this.values$, { initialValue: 0 });
Constructor() {
  effect = effect(() =&gt;
    console.log(this.valuesAsSignal()));
}
//console output
30</span></pre> <p><span class="koboSpan" id="kobo.422.1">Here, we used the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">values$</span></strong><span class="koboSpan" id="kobo.424.1"> Observable and converted it into a Signal using </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">toSignal</span></strong><span class="koboSpan" id="kobo.426.1"> while setting an initial value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">0</span></strong><span class="koboSpan" id="kobo.428.1">. </span><span class="koboSpan" id="kobo.428.2">Then, we defined an effect to log the value of the Signal. </span><span class="koboSpan" id="kobo.428.3">The console output is </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">30</span></strong><span class="koboSpan" id="kobo.430.1">. </span><span class="koboSpan" id="kobo.430.2">Yes, only </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">30</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">. </span><span class="koboSpan" id="kobo.432.2">Why?</span></span></p>
<p><span class="koboSpan" id="kobo.433.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">of()</span></strong><span class="koboSpan" id="kobo.435.1"> creation function emits its values immediately upon subscription. </span><span class="koboSpan" id="kobo.435.2">So, when </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">toSignal</span></strong><span class="koboSpan" id="kobo.437.1"> subscribes, all the values are immediately emitted. </span><span class="koboSpan" id="kobo.437.2">By the time the effect is scheduled to run, </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">30</span></strong><span class="koboSpan" id="kobo.439.1"> is already in the Signal as the last value emitted and that’s what it is logged as to </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">the Signal.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">Now, let’s delay the </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">values$</span></strong><span class="koboSpan" id="kobo.443.1"> emission by 5 seconds using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">delay</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.445.1"> operator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.446.1">
import { toSignal } from '@angular/core/rxjs-interop';
  values$ = of(10, 20, 30).pipe(delay(5));
valuesAsSignal = toSignal(this.values$, { initialValue: 0 });
  effect = effect(() =&gt;
    console.log(this.valuesAsSignal()));
//console output
10, 20, 30</span></pre> <p><span class="koboSpan" id="kobo.447.1">When you re-execute the </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.448.1">code, you will see </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">10</span></strong><span class="koboSpan" id="kobo.450.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">20</span></strong><span class="koboSpan" id="kobo.452.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">30</span></strong><span class="koboSpan" id="kobo.454.1"> in the console. </span><span class="koboSpan" id="kobo.454.2">The effect now has the opportunity to run after each emission because we set up a delay of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">5</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.456.1"> seconds.</span></span></p>
<p><span class="koboSpan" id="kobo.457.1">The point here is that when we create Signals, the Signal will not necessarily get notified of all emitted items; it depends on how the Observable is created and on its set </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">of operators.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.459.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.460.1">Signals created through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">toSignal()</span></strong><span class="koboSpan" id="kobo.462.1"> function are read-only – this makes sense as the Signal here is just a consumer of the values emitted by the Observable. </span><span class="koboSpan" id="kobo.462.2">Also, keep in mind that </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">toSignal()</span></strong><span class="koboSpan" id="kobo.464.1"> creates a subscription – you should avoid calling it repeatedly for the same Observable, and instead reuse the Signal </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">it returns.</span></span></p>
<p><span class="koboSpan" id="kobo.466.1">That is all you need to know about </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">toSignal()</span></strong><span class="koboSpan" id="kobo.468.1">. </span><span class="koboSpan" id="kobo.468.2">Now, let’s explore the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">toObservable()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.470.1"> function.</span></span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.471.1">Understanding the behavior of toObservable()</span></h2>
<p><span class="koboSpan" id="kobo.472.1">If you want to react to a Signal change and perform an async operation such as issuing an HTTP request, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">toObservable()</span></strong><span class="koboSpan" id="kobo.474.1"> function is </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">your friend!</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">toObservable()</span></strong><span class="koboSpan" id="kobo.478.1"> function </span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.479.1">allows you to convert a Signal into an Observable. </span><span class="koboSpan" id="kobo.479.2">Whenever the Signal’s value changes, the Observable automatically emits a notification with the new value. </span><span class="koboSpan" id="kobo.479.3">This allows you to easily trigger your async operation based on the updated Signal data. </span><span class="koboSpan" id="kobo.479.4">Under the hood, </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">toObservable()</span></strong><span class="koboSpan" id="kobo.481.1"> uses effects to track the Signal’s value and emit the latest value to the Observable, as discussed earlier in </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.483.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">toObservable()</span></strong><span class="koboSpan" id="kobo.485.1"> function might remind you of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">asObservable</span></strong><span class="koboSpan" id="kobo.487.1"> function that’s available for subjects, something</span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.488.1"> we explored in </span><a href="B21180_07.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.489.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.490.1">, </span><em class="italic"><span class="koboSpan" id="kobo.491.1">Sharing Data Between Angular Components</span></em><span class="koboSpan" id="kobo.492.1">, but these functions don’t have the </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">same behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.494.1">Let’s look at an example of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">asObservable</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.496.1">function first:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.497.1">
  value = new BehaviorSubject(10);
  constructor() {
    this.value.asObservable().pipe(tap(x=&gt;console.log(
      `The value is : ${x}`))).subscribe();
    this.value.next(20);
    this.value.next(30);
}
//console output
The value is : 10
The value is : 20
The value is : 30</span></pre> <p><span class="koboSpan" id="kobo.498.1">When using </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">Subject</span></strong><span class="koboSpan" id="kobo.500.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.502.1">, notifications are asynchronous. </span><span class="koboSpan" id="kobo.502.2">Here, we defined a </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">BehaviourSubject</span></strong><span class="koboSpan" id="kobo.504.1"> subject called </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">value</span></strong><span class="koboSpan" id="kobo.506.1"> with an initial value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">10</span></strong><span class="koboSpan" id="kobo.508.1">. </span><span class="koboSpan" id="kobo.508.2">Then, we extracted the </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">readonly</span></strong><span class="koboSpan" id="kobo.510.1"> Observable part of the subject using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">asObservable()</span></strong><span class="koboSpan" id="kobo.512.1"> function. </span><span class="koboSpan" id="kobo.512.2">Each emitted value is piped through a </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">tap</span></strong><span class="koboSpan" id="kobo.514.1"> operator to log it in the console. </span><span class="koboSpan" id="kobo.514.2">Then, we subscribe to start receiving notifications. </span><span class="koboSpan" id="kobo.514.3">Finally, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">constructor</span></strong><span class="koboSpan" id="kobo.516.1">, we emit new values (</span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">20</span></strong><span class="koboSpan" id="kobo.518.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">30</span></strong><span class="koboSpan" id="kobo.520.1">) using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">next</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.522.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.523.1">However, </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">toObservable</span></strong><span class="koboSpan" id="kobo.525.1"> operates differently. </span><span class="koboSpan" id="kobo.525.2">It uses an effect where Signal change notifications are scheduled rather than immediately processed, as Observable notifications are. </span><span class="koboSpan" id="kobo.525.3">Let’s modify the same example by using Signals and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">toObservable</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.527.1"> instead:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.528.1">
value = signal(10);
  constructor() {
    toObservable(this.value).pipe(tap(x=&gt;console.log(
      `The value is : ${x}`))).subscribe();
    this.value.set(20);
    this.value.set(30);
}
//console output
The value is : 30</span></pre> <p><span class="koboSpan" id="kobo.529.1">Here, we defined a Signal instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.531.1"> subject named </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">value</span></strong><span class="koboSpan" id="kobo.533.1"> with an initial value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">10</span></strong><span class="koboSpan" id="kobo.535.1">. </span><span class="koboSpan" id="kobo.535.2">Then, we called </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">toObservable(this.value)</span></strong><span class="koboSpan" id="kobo.537.1"> to emit a notification when the Signal’s value changes. </span><span class="koboSpan" id="kobo.537.2">In the pipeline, we once again logged the emitted values and subscribed to the Observable to start receiving notifications. </span><span class="koboSpan" id="kobo.537.3">Finally, the value of the Signal was</span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.538.1"> updated using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">set</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.540.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.541.1">However, look at the console output – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">The value is : 30</span></strong><span class="koboSpan" id="kobo.543.1"> . </span><span class="koboSpan" id="kobo.543.2">This may not be what you expected, right? </span><span class="koboSpan" id="kobo.543.3">This is because the effect behind </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">toObservable</span></strong><span class="koboSpan" id="kobo.545.1"> runs only after the Signal has settled values. </span><span class="koboSpan" id="kobo.545.2">The current value of the Signal at that time is the last emitted value, which </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">30</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.549.1">Keep this behavior in mind when you decide to use a subject or a Signal – a subject will emit all the values from its source, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">toObservable</span></strong><span class="koboSpan" id="kobo.551.1"> only emits the current value from </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">the Signal.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.553.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.554.1">Please note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">toObservable</span></strong><span class="koboSpan" id="kobo.556.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">toSignal</span></strong><span class="koboSpan" id="kobo.558.1"> functions require an injection context to </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">function properly.</span></span></p>
<p><span class="koboSpan" id="kobo.560.1">As we delved into the powerful capabilities of both </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">toSignal</span></strong><span class="koboSpan" id="kobo.562.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">toObservable</span></strong><span class="koboSpan" id="kobo.564.1">, you might have noticed the potential for synergy between RxJS and Signals. </span><span class="koboSpan" id="kobo.564.2">In the next section, we will learn how we can use both RxJS and Signals in our recipe app and get the best of </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">both worlds.</span></span></p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.566.1">Integrating Signals into our recipe app</span></h1>
<p><span class="koboSpan" id="kobo.567.1">In this section, we will level up the recipe app’s reactive patterns by integrating Signals. </span><span class="koboSpan" id="kobo.567.2">We’ll kick things off by revisiting</span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.568.1"> the data fetching use case we implemented in </span><a href="B21180_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.569.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.570.1">, and then see how we can adjust the implementation by using </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.571.1">Signals in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.573.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">maximize efficiency.</span></span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.575.1">Fetching data as streams using Signals</span></h2>
<p><span class="koboSpan" id="kobo.576.1">Let’s briefly review the code</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.577.1"> snippets we covered for implementing data fetching in </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">RecipesService</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.579.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">RecipesListComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.582.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">recipes.service.ts</span></strong><span class="koboSpan" id="kobo.584.1">, we have the </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.586.1">
export class RecipesService {
  recipes$ =
    this.http.get&lt;Recipe[]&gt;(`${BASE_PATH}/recipes`);
  constructor(private http: HttpClient) { }
}</span></pre> <p><span class="koboSpan" id="kobo.587.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">recipes-list.component.ts</span></strong><span class="koboSpan" id="kobo.589.1">, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">this code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.591.1">
export class RecipesListComponent {
  recipes$ = this.service.recipes$;
  constructor(private service: RecipesService) {
}</span></pre> <p><span class="koboSpan" id="kobo.592.1">Finally, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">recipes-list.component.html</span></strong><span class="koboSpan" id="kobo.594.1">, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">this code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.596.1">
@if (recipes$ | async; as recipes) {
// extra code here
}</span></pre> <p><span class="koboSpan" id="kobo.597.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">recipes$</span></strong><span class="koboSpan" id="kobo.599.1"> is created in </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">RecipesService</span></strong><span class="koboSpan" id="kobo.601.1"> and represents the Observable that holds the list of recipes. </span><span class="koboSpan" id="kobo.601.2">Then, </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">recipes$</span></strong><span class="koboSpan" id="kobo.603.1"> is defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.605.1"> and subscribed to in the template using the async pipe. </span><span class="koboSpan" id="kobo.605.2">This code snippet was explained in detail in </span><a href="B21180_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.606.1">Chapter 3</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.607.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.608.1">Now, instead of exposing </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">recipes$</span></strong><span class="koboSpan" id="kobo.610.1"> as an Observable in </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.612.1">, we can consider using a Signal to bind it in</span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.613.1"> the template. </span><span class="koboSpan" id="kobo.613.2">To achieve this, we will convert the </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">recipes$</span></strong><span class="koboSpan" id="kobo.615.1"> Observable into</span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.616.1"> a Signal named </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">recipes</span></strong><span class="koboSpan" id="kobo.618.1"> using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">toSignal()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.620.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.621.1">First, to centralize data</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.622.1"> management in a single place, we will create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">recipes</span></strong><span class="koboSpan" id="kobo.624.1"> Signal </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">inside </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">RecipesService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.628.1">
import { toSignal } from '@angular/core/rxjs-interop';
export class RecipesService {
  recipes$ =
    this.http.get&lt;Recipe[]&gt;(`${BASE_PATH}/recipes`);
  recipes=toSignal(this.recipes$, {initialValue: [] as
    Recipe[]});
  constructor(private http: HttpClient) { }
}</span></pre> <p><span class="koboSpan" id="kobo.629.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">recipes</span></strong><span class="koboSpan" id="kobo.631.1"> Signal is created using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">toSignal</span></strong><span class="koboSpan" id="kobo.633.1"> function, which takes </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">two arguments:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">This.recipes$</span></strong><span class="koboSpan" id="kobo.636.1">: The Observable to be converted into </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">a Signal.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">{initialValue: [] as Recipe[]}</span></strong><span class="koboSpan" id="kobo.639.1">: This is an optional configuration object that specifies an initial value of an empty array, </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">[]</span></strong><span class="koboSpan" id="kobo.641.1">. </span><span class="koboSpan" id="kobo.641.2">This ensures the Signal always has a value, even before the Observable emits any data. </span><span class="koboSpan" id="kobo.641.3">We used the TypeScript </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">as</span></strong><span class="koboSpan" id="kobo.643.1"> assertion to define the type </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">Recipe[]</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.647.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.648.1">We can optimize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">RecipesService</span></strong><span class="koboSpan" id="kobo.650.1"> code by deleting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">recipes$</span></strong><span class="koboSpan" id="kobo.652.1"> property and including its result in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">recipes </span></strong><span class="koboSpan" id="kobo.654.1">property, </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">as follows:</span></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">recipes = toSignal(this.http.get&lt;Recipe[]&gt;(`${BASE_PATH}/recipes`), { initialValue: [] as </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">Recipe[] });</span></strong></span></p>
<p><span class="koboSpan" id="kobo.658.1">Next, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.660.1">, we </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.661.1">will define the Signal we created </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">RecipesService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.665.1">
export class RecipesListComponent {
recipes = this.service.recipes;
constructor(private service: RecipesService) {}}</span></pre> <p><span class="koboSpan" id="kobo.666.1">Finally, as </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">toSignal</span></strong><span class="koboSpan" id="kobo.668.1"> automatically</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.669.1"> subscribes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">recipes$</span></strong><span class="koboSpan" id="kobo.671.1"> Observable, we will change </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">recipes$ |async</span></strong><span class="koboSpan" id="kobo.673.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">recipes()</span></strong><span class="koboSpan" id="kobo.675.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">RecipesListComponent </span></strong><span class="koboSpan" id="kobo.677.1">template so that it reads the</span><a id="_idIndexMarker351"/> <span class="No-Break"><span class="koboSpan" id="kobo.678.1">Signal’s value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.679.1">
@if (recipes(); as recipes) {
// extra code here
}</span></pre> <p><span class="koboSpan" id="kobo.680.1">No other changes are required. </span><span class="koboSpan" id="kobo.680.2">If you go to the app, the list is displayed, and our app still works. </span><span class="koboSpan" id="kobo.680.3">By doing this, we kept the Observable-based logic in </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">RecipesService</span></strong><span class="koboSpan" id="kobo.682.1"> for managing async operations using the HTTP client and then created a Signal from that Observable for use in the template. </span><span class="koboSpan" id="kobo.682.2">By doing this, we can improve change detection in </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">the template.</span></span></p>
<p><span class="koboSpan" id="kobo.684.1">Now, how do we handle errors in our Signals? </span><span class="koboSpan" id="kobo.684.2">If they are just simple containers of values, how can they generate </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">an error?</span></span></p>
<p><span class="koboSpan" id="kobo.686.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">RecipesService</span></strong><span class="koboSpan" id="kobo.688.1">, we handled the error using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">catchError</span></strong><span class="koboSpan" id="kobo.690.1"> operator (discussed in </span><a href="B21180_04.xhtml#_idTextAnchor071"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.691.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.692.1">, </span><em class="italic"><span class="koboSpan" id="kobo.693.1">Handling Errors Reactively</span></em><span class="koboSpan" id="kobo.694.1">) and provided a </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">replacement Observable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.696.1">
recipes$.pipe(catchError(() =&gt; of([])));</span></pre> <p><span class="koboSpan" id="kobo.697.1">This code works fine when using </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">toSignal</span></strong><span class="koboSpan" id="kobo.699.1">. </span><span class="koboSpan" id="kobo.699.2">It is an option to handle errors at the Observable level so that when the Observable that’s used in </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">toSignal</span></strong><span class="koboSpan" id="kobo.701.1"> throws an error, this is later caught using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">catchError</span></strong><span class="koboSpan" id="kobo.703.1"> operator, and a replacement Observable </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">is provided.</span></span></p>
<p><span class="koboSpan" id="kobo.705.1">However, if an Observable called in </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">toSignal</span></strong><span class="koboSpan" id="kobo.707.1"> rethrows an error and doesn’t handle it (the catch and rethrow strategy detailed in </span><a href="B21180_04.xhtml#_idTextAnchor071"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.708.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.709.1">), then this error will be thrown each time the Signal is read. </span><span class="koboSpan" id="kobo.709.2">Consequently, if the Signal is</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.710.1"> read multiple times, the error will be </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">thrown repeatedly.</span></span></p>
<p><span class="koboSpan" id="kobo.712.1">Therefore, if you intend to</span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.713.1"> rethrow the error and perform actions such as displaying a popup message in the UI, then it is highly recommended to catch the</span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.714.1"> error at the Observable level and return an error object as a value. </span><span class="koboSpan" id="kobo.714.2">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.716.1">
observable$.pipe(
    catchError((error: HttpErrorResponse) =&gt;of({ status: 'error', description: error })));</span></pre> <p><span class="koboSpan" id="kobo.717.1">Here, we have an Observable that catches errors of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">HttpErrorResponse</span></strong><span class="koboSpan" id="kobo.719.1"> type and returns an object containing the status (indicating whether it’s an error or success) and the error description. </span><span class="koboSpan" id="kobo.719.2">At this point, you can register an effect to handle this error at the </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">component level.</span></span></p>
<p><span class="koboSpan" id="kobo.721.1">Another option is to reject errors completely using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">rejectErrors</span></strong><span class="koboSpan" id="kobo.723.1"> parameter </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">toSignal</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.727.1">
  recipes = toSignal(this.http.get&lt;Recipe[]&gt;(`${BASE_PATH}/recipes`), { initialValue: [] as Recipe[], rejectErrors:true });</span></pre> <p><span class="koboSpan" id="kobo.728.1">When enabled, errors are thrown back into the Observable and will become uncaught exceptions. </span><span class="koboSpan" id="kobo.728.2">You can imagine </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">toSignal</span></strong><span class="koboSpan" id="kobo.730.1"> saying, “I don’t want your errors; take them back.” </span><span class="koboSpan" id="kobo.730.2">You can then register a global error handler to handle uncaught exceptions and perform </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">your actions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.732.1">
export class GlobalErrorHandler implements ErrorHandler {
    handleError(error: any): void {
      alert(error.message);
    }
}</span></pre> <p class="callout-heading"><span class="koboSpan" id="kobo.733.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.734.1">If an Observable that’s used in </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">toSignal</span></strong><span class="koboSpan" id="kobo.736.1"> completes, the Signal continues to return the most recently emitted value </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">before completion.</span></span></p>
<p><span class="koboSpan" id="kobo.738.1">Now that we’ve used </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">toSignal</span></strong><span class="koboSpan" id="kobo.740.1"> to improve our implementation and understood its behavior in handling errors, along with the various recommended options available, let’s circle back to the concept of filtering </span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.741.1">streams, a topic we explored in </span><a href="B21180_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.742.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.743.1">, </span><em class="italic"><span class="koboSpan" id="kobo.744.1">Combining Streams</span></em><span class="koboSpan" id="kobo.745.1">. </span><span class="koboSpan" id="kobo.745.2">We will use computed Signals to meet the filtering</span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.746.1"> requirement using RxJS </span><a id="_idIndexMarker357"/><span class="No-Break"><span class="koboSpan" id="kobo.747.1">and Signals.</span></span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.748.1">Combining streams using Signals</span></h2>
<p><span class="koboSpan" id="kobo.749.1">In the recipe app, we implemented filtering using </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">BehaviorSubjects</span></strong><span class="koboSpan" id="kobo.751.1">, which effectively notifies components</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.752.1"> when the filter changes to refine the results. </span><span class="koboSpan" id="kobo.752.2">However, Signals also offer a mechanism to react to value changes. </span><span class="koboSpan" id="kobo.752.3">They can trigger actions within effects or </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">computed Signals.</span></span></p>
<p><span class="koboSpan" id="kobo.754.1">This functionality overlaps somewhat with </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">BehaviorSubjects</span></strong><span class="koboSpan" id="kobo.756.1">, which begs the question, can we replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">BehaviorSubjects</span></strong><span class="koboSpan" id="kobo.758.1"> with Signals to filter streams? </span><span class="koboSpan" id="kobo.758.2">Let’s refresh our memory on the code provided in </span><a href="B21180_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.759.1">Chapter 5</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.760.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.761.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">recipes.service.ts</span></strong><span class="koboSpan" id="kobo.763.1">, we have the </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.765.1">
export class RecipesService {
  recipes$ =
    this.http.get&lt;Recipe[]&gt;(`${BASE_PATH}/recipes`);
  private filterRecipeSubject = new
    BehaviorSubject&lt;Recipe&gt;({ title: '' });
  filterRecipesAction$ =
    this.filterRecipeSubject.asObservable();
  constructor(private http: HttpClient) { }
  updateFilter(criteria: Recipe) {
    this.filterRecipeSubject.next(criteria);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.766.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">recipes-list.component.ts</span></strong><span class="koboSpan" id="kobo.768.1">, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">this code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.770.1">
export class RecipesListComponent {
  recipes$ = this.service.recipes$;
  filterRecipesAction$ = this.service.filterRecipesAction$;
  filteredRecipes$ = combineLatest([this.recipes$,
    this.filterRecipesAction$]).pipe(
    map(([recipes, filter]: [Recipe[], Recipe]) =&gt; {
    const filterTitle = filter?.title?.toLowerCase() ?? </span><span class="koboSpan" id="kobo.770.2">'';
    return recipes.filter(recipe =&gt;
    recipe.title?.toLowerCase() .includes(filterTitle))
  })
  );
  constructor(private service: RecipesService) {
}}</span></pre> <p><span class="koboSpan" id="kobo.771.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">filterRecipesAction$</span></strong><span class="koboSpan" id="kobo.773.1"> is the Observable</span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.774.1"> that holds the latest filter’s value. </span><span class="koboSpan" id="kobo.774.2">It’s defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">RecipesService</span></strong><span class="koboSpan" id="kobo.776.1"> and </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.777.1">used in </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.779.1"> to refine the search. </span><span class="koboSpan" id="kobo.779.2">The filter’s value is </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.780.1">updated through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">updateFilter</span></strong><span class="koboSpan" id="kobo.782.1"> method by </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">RecipesFilterComponent</span></strong><span class="koboSpan" id="kobo.784.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">filteredRecipes$</span></strong><span class="koboSpan" id="kobo.786.1"> represents the result of filtering; we subscribed to it in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.788.1"> template using the async pipe. </span><span class="koboSpan" id="kobo.788.2">This code snippet is explained in detail in </span><a href="B21180_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.789.1">Chapter 5</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.790.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.791.1">Now, using Signals, we can replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.793.1"> and the Observable we created in </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">RecipesService</span></strong><span class="koboSpan" id="kobo.795.1"> with a single Signal named </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">filterRecipe</span></strong><span class="koboSpan" id="kobo.797.1"> and initialize it with an </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">empty value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.799.1">
export class RecipesService {
  recipes =
    toSignal(this.http.get&lt;Recipe[]&gt;(
    `${BASE_PATH}/recipes`), { initialValue: [] as Recipe[]
    });
  filterRecipe = signal({ title: '' } as Recipe);
  constructor(private http: HttpClient) { }
  updateFilter(criteria: Recipe) {
    this.filterRecipe.set(criteria);
  }}</span></pre> <p><span class="koboSpan" id="kobo.800.1">Here, we created the </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">filterRecipe</span></strong><span class="koboSpan" id="kobo.802.1"> Signal and initialized it with an empty criteria. </span><span class="koboSpan" id="kobo.802.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">updateFilter</span></strong><span class="koboSpan" id="kobo.804.1"> method, which</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.805.1"> is used to notify the behavior subject of the change, we will simply update the value of the</span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.806.1"> Signal using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">set</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.808.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.809.1">Then, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.811.1">, instead of combining streams using </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">combineLatest</span></strong><span class="koboSpan" id="kobo.813.1">, we will </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.814.1">create a computed Signal that will return an array of recipes based on the Signal’s filter and the Signal’s recipes list. </span><span class="koboSpan" id="kobo.814.2">Then, we will refine the recipes list given the filter value using the same </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">filtering function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.816.1">
export class RecipesListComponent {
  recipes = this.service.recipes;
  recipesFilter = this.service.filterRecipe;
  filteredRecipes = computed(() =&gt; {
    const filterTitle =
      this.recipesFilter()?.title?.toLowerCase() ?? </span><span class="koboSpan" id="kobo.816.2">'';
    return this.recipes().filter(recipe =&gt;
      recipe.title?.toLowerCase()
      .includes(filterTitle));
  })
  constructor(private service: RecipesService) {
  }
}</span></pre> <p><span class="koboSpan" id="kobo.817.1">Finally, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.819.1"> template, we will be removing the async pipe and replacing it with</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.820.1"> the call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">filteredRecipes</span></strong><span class="koboSpan" id="kobo.822.1"> Signal, </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">as</span></span><span class="No-Break"><a id="_idIndexMarker366"/></span><span class="No-Break"><span class="koboSpan" id="kobo.824.1"> follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.825.1">
@if (filteredRecipes(); as recipes) {
    // Extra code here// Extra code here
}</span></pre> <p><span class="koboSpan" id="kobo.826.1">This way, we have much cleaner code and an enhanced change </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">detection mechanism.</span></span></p>
<p><span class="koboSpan" id="kobo.828.1">We used </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">BehaviorSubjects</span></strong><span class="koboSpan" id="kobo.830.1"> in </span><a href="B21180_07.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.831.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.832.1">, to share the last selected recipe </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">RecipesList</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">
Component</span></strong><span class="koboSpan" id="kobo.836.1"> throughout the entire recipe app. </span><span class="koboSpan" id="kobo.836.2">Then, we consumed the last shared selected recipe and </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.837.1">displayed its details in </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">RecipeDetailsComponent</span></strong><span class="koboSpan" id="kobo.839.1">. </span><span class="koboSpan" id="kobo.839.2">Let’s use Signals for the same purpose in </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">this implementation.</span></span></p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.841.1">Sharing data using Signals</span></h2>
<p><span class="koboSpan" id="kobo.842.1">Before diving into using Signals, let’s review the </span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.843.1">steps that were covered in </span><a href="B21180_07.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.844.1">Chapter 7</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.845.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.846.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">shared-data.service.ts</span></strong><span class="koboSpan" id="kobo.848.1"> file, we have the </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.850.1">
export class SharedDataService {
private selectedRecipeSubject = new BehaviorSubject&lt;Recipe&gt;({});selectedRecipeAction$ = this.selectedRecipeSubject.asObservable();updateSelectedRecipe(recipe: Recipe) { this.selectedRecipeSubject.next(recipe);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.851.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">recipe-details.component.ts</span></strong><span class="koboSpan" id="kobo.853.1"> file, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">this code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.855.1">
export class RecipeDetailsComponent {
constructor(private sharedService: SharedDataService) { }
selectedRecipe$ = this.sharedService.selectedRecipeAction$;
}</span></pre> <p><span class="koboSpan" id="kobo.856.1">And in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">recipe-details.component.html</span></strong><span class="koboSpan" id="kobo.858.1"> file, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.859.1">this code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.860.1">
@if (selectedRecipe$ | async; as recipe) {
}</span></pre> <p><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">selectedRecipeAction$</span></strong><span class="koboSpan" id="kobo.862.1"> is the Observable that holds the latest selected recipe. </span><span class="koboSpan" id="kobo.862.2">It’s defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">SharedDataService</span></strong><span class="koboSpan" id="kobo.864.1"> and used in </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">RecipeDetailsComponent</span></strong><span class="koboSpan" id="kobo.866.1"> to display the details. </span><span class="koboSpan" id="kobo.866.2">The last selected </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.867.1">recipe is updated through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">updateSelectedRecipe</span></strong><span class="koboSpan" id="kobo.869.1"> method by </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">RecipeListComponent</span></strong><span class="koboSpan" id="kobo.871.1">. </span><span class="koboSpan" id="kobo.871.2">Then, we subscribed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">selectedRecipe$</span></strong><span class="koboSpan" id="kobo.873.1"> in the template using the async pipe. </span><span class="koboSpan" id="kobo.873.2">This code snippet was explained</span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.874.1"> in detail in </span><a href="B21180_07.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.875.1">Chapter 7</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.876.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.877.1">Now, we’ll </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.878.1">switch from </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.880.1"> to Signals in </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">SharedDataService</span></strong><span class="koboSpan" id="kobo.882.1">. </span><span class="koboSpan" id="kobo.882.2">We’ll initialize the created Signal, </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">selectedRecipe</span></strong><span class="koboSpan" id="kobo.884.1">, with an empty object and change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">updateSelectedRecipe</span></strong><span class="koboSpan" id="kobo.886.1"> method so that it updates the value stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">selectedRecipe</span></strong><span class="koboSpan" id="kobo.888.1"> Signal using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">set</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.890.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.891.1">
export class SharedDataService {
  selectedRecipe = signal({} as Recipe);
  updateSelectedRecipe(recipe: Recipe) {
    this.selectedRecipe.set(recipe);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.892.1">So far, so good – we have a Signal that will always hold the last </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">selected recipe.</span></span></p>
<p><span class="koboSpan" id="kobo.894.1">Next, let’s consume this Signal’s value in </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">RecipeDetailsComponent</span></strong><span class="koboSpan" id="kobo.896.1">. </span><span class="koboSpan" id="kobo.896.2">We will start by defining the Signal created in </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">SharedDataService</span></strong><span class="koboSpan" id="kobo.898.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.899.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.900.1">
export class RecipeDetailsComponent {
  constructor(private sharedService: SharedDataService) { }
  selectedRecipe = this.sharedService.selectedRecipe;
}</span></pre> <p><span class="koboSpan" id="kobo.901.1">Then, in the template, replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">selectedRecipe$ | async</span></strong><span class="koboSpan" id="kobo.903.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">selectedRecipe()</span></strong><span class="koboSpan" id="kobo.905.1"> to read</span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.906.1"> the value of </span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">the Signal.</span></span></p>
<p><span class="koboSpan" id="kobo.908.1">And we’re done. </span><span class="koboSpan" id="kobo.908.2">When running this code, you’ll notice that the functionality remains intact. </span><span class="koboSpan" id="kobo.908.3">Each time a recipe is selected from the list, </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">RecipeDetailsComponent</span></strong><span class="koboSpan" id="kobo.910.1"> will display its details. </span><span class="koboSpan" id="kobo.910.2">Now. </span><span class="koboSpan" id="kobo.910.3">let’s </span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.911.1">use Signals and </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">toObservable</span></strong><span class="koboSpan" id="kobo.913.1"> to fetch a specific recipe from </span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">the server.</span></span></p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.915.1">Transforming streams using Signals</span></h2>
<p><span class="koboSpan" id="kobo.916.1">Considering the previous example, the recipes array that’s displayed in </span><strong class="source-inline"><span class="koboSpan" id="kobo.917.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.918.1"> already</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.919.1"> contains all the recipe objects, along with their details, so we simply used the client-side recipe object when clicking on a </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.920.1">recipe from </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">the list.</span></span></p>
<p><span class="koboSpan" id="kobo.922.1">Now, imagine that we need to dynamically fetch a recipe’s details based on its ID, from a backend service with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">/api/recipes/:recipeID</span></strong><span class="koboSpan" id="kobo.924.1"> endpoint (this service is implemented in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">recipes-book-api</span></strong><span class="koboSpan" id="kobo.926.1"> backend server; the code is available in this book’s GitHub repository). </span><span class="koboSpan" id="kobo.926.2">Here’s how we can adapt our previous implementation to handle this </span><span class="No-Break"><span class="koboSpan" id="kobo.927.1">use case.</span></span></p>
<p><span class="koboSpan" id="kobo.928.1">We can keep using Signals to track the currently selected recipe’s ID. </span><span class="koboSpan" id="kobo.928.2">So, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">SharedDataService</span></strong><span class="koboSpan" id="kobo.930.1">, we’ll adjust our implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.932.1">
export class SharedDataService {
  selectedRecipeId = signal&lt;number | undefined&gt;(undefined);
  updateSelectedRecipe(recipeId: number | undefined) {
    this.selectedRecipeId.set(recipeId);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.933.1">Here, we defined a Signal named </span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">selectedRecipeId</span></strong><span class="koboSpan" id="kobo.935.1"> that’s been initialized to </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">undefined</span></strong><span class="koboSpan" id="kobo.937.1"> as we don’t have an </span><span class="No-Break"><span class="koboSpan" id="kobo.938.1">initial selection.</span></span></p>
<p><span class="koboSpan" id="kobo.939.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">updateSelectedRecipe</span></strong><span class="koboSpan" id="kobo.941.1"> method now takes </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">recipeId</span></strong><span class="koboSpan" id="kobo.943.1"> (either a number or undefined) as input and updates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">selectedRecipeId</span></strong><span class="koboSpan" id="kobo.945.1"> Signal using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">set</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.947.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.948.1">Now, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">RecipeListComponent</span></strong><span class="koboSpan" id="kobo.950.1">, we will update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.951.1">editRecipe</span></strong><span class="koboSpan" id="kobo.952.1"> method so that it only sends the recipe’s</span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.953.1"> identifier instead of the whole </span><span class="No-Break"><span class="koboSpan" id="kobo.954.1">recipe object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.955.1">
editRecipe(recipe: Recipe) {
    this.sharedService.updateSelectedRecipe(recipe.id);
    this.router.navigate(['/recipes/details']);
}</span></pre> <p><span class="koboSpan" id="kobo.956.1">Now, we need to issue an</span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.957.1"> asynchronous HTTP request to fetch the recipe’s </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.958.1">details whenever a recipe is selected from the list. </span><span class="koboSpan" id="kobo.958.2">Observables are ideal for this process! </span><span class="koboSpan" id="kobo.958.3">As we learned in </span><a href="B21180_06.xhtml#_idTextAnchor097"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.959.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.960.1">, </span><em class="italic"><span class="koboSpan" id="kobo.961.1">Transforming Streams</span></em><span class="koboSpan" id="kobo.962.1">, we need a higher-order mapping operator that does </span><span class="No-Break"><span class="koboSpan" id="kobo.963.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.964.1">Transforms each emitted recipe’s identifier into a new Observable that issues an </span><span class="No-Break"><span class="koboSpan" id="kobo.965.1">HTTP request</span></span></li>
<li><span class="koboSpan" id="kobo.966.1">Cancels the previous HTTP request when a new recipe’s identifier arrives and switches to the newly created HTTP request for the </span><span class="No-Break"><span class="koboSpan" id="kobo.967.1">latest ID</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.968.1">You may have guessed already, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.969.1">switchMap</span></strong><span class="koboSpan" id="kobo.970.1"> is the ideal operator to </span><span class="No-Break"><span class="koboSpan" id="kobo.971.1">use here.</span></span></p>
<p><span class="koboSpan" id="kobo.972.1">But wait! </span><span class="koboSpan" id="kobo.972.2">We need two key streams involved in </span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">this situation:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.974.1">A HTTP request stream</span></em><span class="koboSpan" id="kobo.975.1">: This stream, which is created using </span><strong class="source-inline"><span class="koboSpan" id="kobo.976.1">this.http.get&lt;Recipe&gt;(`${BASE_PATH}/recipes/${id}`)</span></strong><span class="koboSpan" id="kobo.977.1">, represents the actual HTTP request to retrieve the recipe data based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.978.1">provided ID.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.979.1">A selected recipe ID stream</span></em><span class="koboSpan" id="kobo.980.1">: Currently, the selected recipe ID is stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.981.1">selectedRecipeId</span></strong><span class="koboSpan" id="kobo.982.1"> Signal. </span><span class="koboSpan" id="kobo.982.2">Here, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">toObservable</span></strong><span class="koboSpan" id="kobo.984.1"> function to convert the </span><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">selectedRecipeId</span></strong><span class="koboSpan" id="kobo.986.1"> Signal into an Observable stream that will emit a notification whenever the selected recipe ID changes in the Signal. </span><span class="koboSpan" id="kobo.986.2">It will look like </span><span class="No-Break"><span class="koboSpan" id="kobo.987.1">this: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.988.1">toObservable(this.selectedRecipeId)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.989.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.990.1">Now, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.991.1">switchMap</span></strong><span class="koboSpan" id="kobo.992.1"> operator, we will </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.993.1">define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">recipe$</span></strong><span class="koboSpan" id="kobo.995.1"> stream in </span><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">SharedDataService</span></strong><span class="koboSpan" id="kobo.997.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.998.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.999.1">
  recipe$ =
    toObservable(this.selectedRecipeId).pipe(filter(
    Boolean), switchMap(id =&gt;
    this.http.get&lt;Recipe&gt;(`${BASE_PATH}/recipes/${id}`)
  ));</span></pre> <p><span class="koboSpan" id="kobo.1000.1">The resulting Observable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">recipe$</span></strong><span class="koboSpan" id="kobo.1002.1">, represents a specific recipe object stream. </span><span class="koboSpan" id="kobo.1002.2">It emits a new recipe whenever</span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.1003.1"> the selected recipe ID changes and a successful HTTP </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.1004.1">request </span><span class="No-Break"><span class="koboSpan" id="kobo.1005.1">is made.</span></span></p>
<p><span class="koboSpan" id="kobo.1006.1">Finally, within </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">RecipeDetailsComponent</span></strong><span class="koboSpan" id="kobo.1008.1">, we can convert the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">recipe$ </span></strong><span class="koboSpan" id="kobo.1010.1">Observable back into a signal using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">toSignal</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1013.1">
selectedRecipe = toSignal(this.sharedService.recipe$);</span></pre> <p><span class="koboSpan" id="kobo.1014.1">This allows us to bind the recipe’s data in the component’s template </span><span class="No-Break"><span class="koboSpan" id="kobo.1015.1">using Signals.</span></span></p>
<p><span class="koboSpan" id="kobo.1016.1">Awesome, right? </span><span class="koboSpan" id="kobo.1016.2">This transformation pattern of using Signals is applicable for every similar use case where you need to combine or transform multiple data streams in your </span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1">Angular applications!</span></span></p>
<p><span class="koboSpan" id="kobo.1018.1">By leveraging both Angular Signals and RxJS, you can achieve a well-balanced approach to reactive data management in your Angular applications. </span><span class="koboSpan" id="kobo.1018.2">This harmonious blend allows you to build highly dynamic and responsive user interfaces. </span><span class="koboSpan" id="kobo.1018.3">Now, let’s delve into some interesting new features</span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.1019.1"> regarding reactive data binding </span><span class="No-Break"><span class="koboSpan" id="kobo.1020.1">with Signals.</span></span></p>
<h1 id="_idParaDest-134"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.1021.1">Exploring reactive data binding with Signals</span></h1>
<p><span class="koboSpan" id="kobo.1022.1">Angular’s data binding capabilities have been steadily improving to support reactivity. </span><span class="koboSpan" id="kobo.1022.2">Starting from version 17.1, Angular introduced</span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.1023.1"> some powerful features to leverage reactivity using Signals in component interaction and </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.1024.1">data binding, such as input Signals, model inputs (starting from 17.2), and support for content and view queries. </span><span class="koboSpan" id="kobo.1024.2">To align with input Signals, version 17.3 provides a new </span><span class="No-Break"><span class="koboSpan" id="kobo.1025.1">output API.</span></span></p>
<p><span class="koboSpan" id="kobo.1026.1">We will explore these new features in </span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">this section.</span></span></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.1028.1">Signal inputs</span></h2>
<p><span class="koboSpan" id="kobo.1029.1">The Angular </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">@Input</span></strong><span class="koboSpan" id="kobo.1031.1"> decorator is used to define an input property in a component, allowing data to be passed into the</span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.1032.1"> component from its parent component or template. </span><span class="koboSpan" id="kobo.1032.2">It essentially creates a one-way data flow from the parent to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1">child component.</span></span></p>
<p><span class="koboSpan" id="kobo.1034.1">Angular 17.1 introduces Signal inputs that allow input data to be passed as Signals. </span><span class="koboSpan" id="kobo.1034.2">This adds a powerful twist to data binding between parent and child components in Angular, transforming traditional Angular inputs into a reactive data source. </span><span class="koboSpan" id="kobo.1034.3">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1035.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1036.1">
TypeScript
@Component({
  selector: 'app-shipping',
})
export class ShippingComponent {
  addressLine2 = input&lt;string&gt;();
  identifier = input(0);
  addressLine1 = input.required&lt;string&gt;();
}</span></pre> <p><span class="koboSpan" id="kobo.1037.1">In this example, we defined three </span><span class="No-Break"><span class="koboSpan" id="kobo.1038.1">Signal inputs:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1039.1">addressLine2</span></strong><span class="koboSpan" id="kobo.1040.1">: An optional input that can hold a string value or </span><span class="No-Break"><span class="koboSpan" id="kobo.1041.1">be undefined.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1042.1">identifier</span></strong><span class="koboSpan" id="kobo.1043.1">: An optional input</span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.1044.1"> that holds a number and has a default value </span><span class="No-Break"><span class="koboSpan" id="kobo.1045.1">of 0.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1046.1">AddressLine1</span></strong><span class="koboSpan" id="kobo.1047.1">: A required input that holds a string value. </span><span class="koboSpan" id="kobo.1047.2">It is declared using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">input.required</span></strong><span class="koboSpan" id="kobo.1049.1"> function, and by default, the inputs are optional (that’s why Signal inputs are type-safe). </span><span class="koboSpan" id="kobo.1049.2">If not provided, a compilation error will be thrown, like so: </span><strong class="bold"><span class="koboSpan" id="kobo.1050.1">NG8008: Required input ‘ addressLine1’ from component ShippingComponent must </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1051.1">be specified</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1052.1">.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.1053.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1054.1">Required inputs cannot have a default value. </span><span class="koboSpan" id="kobo.1054.2">Therefore, you can’t read their values before they’ve been bound, and Angular throws an exception. </span><span class="koboSpan" id="kobo.1054.3">Consequently, you can’t access their values in the constructor. </span><span class="koboSpan" id="kobo.1054.4">However, you can safely access the values within </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">ngOnInit</span></strong><span class="koboSpan" id="kobo.1056.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">ngOnChanges</span></strong><span class="koboSpan" id="kobo.1058.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1059.1">computed</span></strong><span class="koboSpan" id="kobo.1060.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1061.1">effects</span></strong><span class="koboSpan" id="kobo.1062.1"> as they are only triggered when the component has </span><span class="No-Break"><span class="koboSpan" id="kobo.1063.1">been initialized.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1064.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1065.1">When referenced in templates, Signal inputs will automatically mark </span><strong class="source-inline"><span class="koboSpan" id="kobo.1066.1">OnPush</span></strong><span class="koboSpan" id="kobo.1067.1"> components </span><span class="No-Break"><span class="koboSpan" id="kobo.1068.1">as dirty.</span></span></p>
<p><span class="koboSpan" id="kobo.1069.1">Now that we’ve got a handle on creating Signal inputs and understanding their syntax, you might be curious about how to use them. </span><span class="koboSpan" id="kobo.1069.2">Signal inputs are read-only. </span><span class="koboSpan" id="kobo.1069.3">You can access the value by calling the getter function in the template, </span><span class="No-Break"><span class="koboSpan" id="kobo.1070.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1071.1">
{{addressLine1()}}
{{addressLine2()}}</span></pre> <p><span class="koboSpan" id="kobo.1072.1">You can also bind to an input Signal </span><span class="No-Break"><span class="koboSpan" id="kobo.1073.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1074.1">
&lt; app-shipping addressLine1 ="2300 Vision Lane"&gt;
&lt; app-shipping [addressLine1]="addressProperty"&gt;
&lt; app-shipping [label]="addressAsSignalProperty()"&gt;</span></pre> <p><span class="koboSpan" id="kobo.1075.1">In this example, we bound the Signal input property, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1076.1">addressLine1</span></strong><span class="koboSpan" id="kobo.1077.1">, to different values: a string named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">2300 Vision Lane</span></strong><span class="koboSpan" id="kobo.1079.1">, a component property named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1080.1">addressProperty</span></strong><span class="koboSpan" id="kobo.1081.1">, and a Signal’s value </span><span class="No-Break"><span class="koboSpan" id="kobo.1082.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1083.1">addressAsSignalProperty()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1084.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1085.1">Binding to Signals opens the door to a whole new level of dynamic data flow; any changes made to the input</span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.1086.1"> value in the parent component will be automatically reflected in the child component. </span><span class="koboSpan" id="kobo.1086.2">This is where the real magic happens. </span><span class="koboSpan" id="kobo.1086.3">In the following example, we’re using the Signal input property’s name to bind the values, but you can provide an alias to the input name using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1087.1">following syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1088.1">
  identifier = input(0,{alias: 'id'});</span></pre> <p><span class="koboSpan" id="kobo.1089.1">This allows you to reference the input by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1090.1">&lt;app-shipping [id]=50&gt;</span></strong><span class="koboSpan" id="kobo.1091.1"> as the alias in the template while still using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1092.1">this.identifier</span></strong><span class="koboSpan" id="kobo.1093.1"> as the property name inside </span><span class="No-Break"><span class="koboSpan" id="kobo.1094.1">your component.</span></span></p>
<p><span class="koboSpan" id="kobo.1095.1">In addition to using signal inputs for value binding in templates, they can also be used within </span><strong class="source-inline"><span class="koboSpan" id="kobo.1096.1">effects</span></strong><span class="koboSpan" id="kobo.1097.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">computed</span></strong><span class="koboSpan" id="kobo.1099.1"> functions. </span><span class="koboSpan" id="kobo.1099.2">Are you wondering how to do that? </span><span class="koboSpan" id="kobo.1099.3">Let’s look at </span><span class="No-Break"><span class="koboSpan" id="kobo.1100.1">some examples.</span></span></p>
<p><span class="koboSpan" id="kobo.1101.1">Here, we’re appending the values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1102.1">addressLine1</span></strong><span class="koboSpan" id="kobo.1103.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1104.1">addressLine2</span></strong><span class="koboSpan" id="kobo.1105.1"> in the computed function to </span><span class="No-Break"><span class="koboSpan" id="kobo.1106.1">build </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1107.1">fullAddress</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1108.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1109.1">
  fullAddress = computed(() =&gt; `${this.addressLine1()}
    ${this.addressLine2()}` );</span></pre> <p><span class="koboSpan" id="kobo.1110.1">It’s possible to track the Signal input changes using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1111.1">effect</span></strong><span class="koboSpan" id="kobo.1112.1"> function, </span><span class="No-Break"><span class="koboSpan" id="kobo.1113.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1114.1">
constructor() {
    effect(() =&gt; {
      console.log(this.identifier());
    });
}</span></pre> <p><span class="koboSpan" id="kobo.1115.1">In this example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1116.1">console.log</span></strong><span class="koboSpan" id="kobo.1117.1"> function is invoked every time the identifier input changes. </span><span class="koboSpan" id="kobo.1117.2">This is a new way to track </span><span class="No-Break"><span class="koboSpan" id="kobo.1118.1">value changes.</span></span></p>
<p><span class="koboSpan" id="kobo.1119.1">So, life cycle hooks such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1120.1">ngOnInit</span></strong><span class="koboSpan" id="kobo.1121.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1122.1">ngOnChanges</span></strong><span class="koboSpan" id="kobo.1123.1"> can now be replaced with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1124.1">computed</span></strong><span class="koboSpan" id="kobo.1125.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1126.1">effect</span></strong><span class="koboSpan" id="kobo.1127.1">, making value monitoring easier. </span><span class="koboSpan" id="kobo.1127.2">Instead of implementing extra code inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1128.1">ngOnInit</span></strong><span class="koboSpan" id="kobo.1129.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1130.1">ngOnChanges</span></strong><span class="koboSpan" id="kobo.1131.1">, we can simply register </span><strong class="source-inline"><span class="koboSpan" id="kobo.1132.1">effect</span></strong><span class="koboSpan" id="kobo.1133.1"> to monitor values and use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1134.1">computed</span></strong><span class="koboSpan" id="kobo.1135.1"> to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.1136.1">automatic calculations.</span></span></p>
<p><span class="koboSpan" id="kobo.1137.1">With that, we’ve covered</span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.1138.1"> the essentials of Signal inputs, which enable one-way data binding. </span><span class="koboSpan" id="kobo.1138.2">Next, we’ll explore how bidirectional data binding can be achieved </span><span class="No-Break"><span class="koboSpan" id="kobo.1139.1">using Signals.</span></span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.1140.1">Model inputs</span></h2>
<p><span class="koboSpan" id="kobo.1141.1">Model inputs are similar to the previously explained Signal inputs, allowing you to bind a value into a property. </span><span class="koboSpan" id="kobo.1141.2">However, model inputs allow the component to write values into the property, unlike other inputs, which are read-only. </span><span class="koboSpan" id="kobo.1141.3">This enables two-way reactive data binding, allowing the child </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.1142.1">component to not only receive data changes from the parent but also notify the parent of any changes it makes to </span><span class="No-Break"><span class="koboSpan" id="kobo.1143.1">the data.</span></span></p>
<p><span class="koboSpan" id="kobo.1144.1">Let’s look at an example. </span><span class="koboSpan" id="kobo.1144.2">Here’s some </span><span class="No-Break"><span class="koboSpan" id="kobo.1145.1">TypeScript code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1146.1">
    identifier = model(0,{alias: 'id'});;
  constructor() {
    setInterval(() =&gt; {
      this. </span><span class="koboSpan" id="kobo.1146.2">identifier.set("000524");
    }, 4000)
  }</span></pre> <p><span class="koboSpan" id="kobo.1147.1">And here’s some code in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1148.1">HTML template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1149.1">
&lt;app-shipping [(id)]=counter&gt;&lt;/ app-shipping&gt;
{{counter()}}</span></pre> <p><span class="koboSpan" id="kobo.1150.1">In the TypeScript code, we converted the Signal input named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1151.1">identifier</span></strong><span class="koboSpan" id="kobo.1152.1"> into a model input that initially contains a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1153.1">0</span></strong><span class="koboSpan" id="kobo.1154.1">. </span><span class="koboSpan" id="kobo.1154.2">Then, in the constructor, we set up a timer that will update the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1155.1">identifier</span></strong><span class="koboSpan" id="kobo.1156.1"> input after </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1157.1">4</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1158.1"> seconds.</span></span></p>
<p><span class="koboSpan" id="kobo.1159.1">Then, in the HTML template, we simply used the two-way data binding syntax to bind to a property called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">counter</span></strong><span class="koboSpan" id="kobo.1161.1"> that we defined in the parent component and then display the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1162.1">counter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1163.1"> value.</span></span></p>
<p><span class="koboSpan" id="kobo.1164.1">When running this code, you will see</span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.1165.1"> that the model’s input value will get updated after 4 seconds to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1166.1">000524</span></strong><span class="koboSpan" id="kobo.1167.1"> and the counter property will have </span><strong class="source-inline"><span class="koboSpan" id="kobo.1168.1">000524</span></strong><span class="koboSpan" id="kobo.1169.1"> as its value as well. </span><span class="koboSpan" id="kobo.1169.2">The parent component is </span><span class="No-Break"><span class="koboSpan" id="kobo.1170.1">automatically notified.</span></span></p>
<p><span class="koboSpan" id="kobo.1171.1">Another thing to note when defining a model input is that, under the hood, Angular generates an output for that model. </span><span class="koboSpan" id="kobo.1171.2">The output’s name is just the model input’s name suffixed </span><span class="No-Break"><span class="koboSpan" id="kobo.1172.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1173.1">Change</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1174.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1175.1">
&lt;app-shipping [(id)]=counter (idChange)="updateMessage()" &gt;&lt;/ app-shipping&gt;</span></pre> <p><span class="koboSpan" id="kobo.1176.1">Here, we called the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1177.1">idChange</span></strong><span class="koboSpan" id="kobo.1178.1"> output and triggered the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1179.1">updateMessagethat</span></strong><span class="koboSpan" id="kobo.1180.1"> method, which will display an alert when the model value changes. </span><span class="koboSpan" id="kobo.1180.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1181.1">idChange</span></strong><span class="koboSpan" id="kobo.1182.1"> event will be emitted whenever you write a new value into the </span><span class="No-Break"><span class="koboSpan" id="kobo.1183.1">model input.</span></span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.1184.1">Signal queries</span></h2>
<p><span class="koboSpan" id="kobo.1185.1">Signal queries present a reactive alternative to traditional queries declared with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1186.1">@ContentChild</span></strong><span class="koboSpan" id="kobo.1187.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1188.1">@ContentChildren</span></strong><span class="koboSpan" id="kobo.1189.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1190.1">@ViewChild</span></strong><span class="koboSpan" id="kobo.1191.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1192.1">@ViewChildren</span></strong><span class="koboSpan" id="kobo.1193.1"> decorators. </span><span class="koboSpan" id="kobo.1193.2">Signal queries expose </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.1194.1">query results as Signals, which means that query results can be composed with other Signals (using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1195.1">computed</span></strong><span class="koboSpan" id="kobo.1196.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1197.1">effect</span></strong><span class="koboSpan" id="kobo.1198.1">) and drive </span><span class="No-Break"><span class="koboSpan" id="kobo.1199.1">change detection.</span></span></p>
<p><span class="koboSpan" id="kobo.1200.1">For more details, you can check out the official </span><span class="No-Break"><span class="koboSpan" id="kobo.1201.1">documentation: </span></span><a href="https://angular.dev/guide/signals/queries"><span class="No-Break"><span class="koboSpan" id="kobo.1202.1">https://angular.dev/guide/signals/queries</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1203.1">.</span></span></p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.1204.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1205.1">This chapter took a deep dive into Angular Signals. </span><span class="koboSpan" id="kobo.1205.2">We started by figuring out why Signals exist and how they help manage </span><span class="No-Break"><span class="koboSpan" id="kobo.1206.1">data reactively.</span></span></p>
<p><span class="koboSpan" id="kobo.1207.1">Then, we explored the Signals API, from creating and reading the current value to using computed Signals and effects when the </span><span class="No-Break"><span class="koboSpan" id="kobo.1208.1">value changes.</span></span></p>
<p><span class="koboSpan" id="kobo.1209.1">Next, we compared Signals to RxJS Observables. </span><span class="koboSpan" id="kobo.1209.2">We saw what each is good at and when you’d use one over the other. </span><span class="koboSpan" id="kobo.1209.3">Angular even provides special interop functions that let Signals and Observables work together nicely, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.1210.1">toObservable()</span></strong><span class="koboSpan" id="kobo.1211.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1212.1">toSignals()</span></strong><span class="koboSpan" id="kobo.1213.1">, both of which </span><span class="No-Break"><span class="koboSpan" id="kobo.1214.1">we discussed.</span></span></p>
<p><span class="koboSpan" id="kobo.1215.1">Finally, to put everything into practice, we used Signals in our recipe app to see how they work with RxJS in real-world scenarios. </span><span class="koboSpan" id="kobo.1215.2">This hands-on experience helped us solidify what we learned about using Signals and RxJS together. </span><span class="koboSpan" id="kobo.1215.3">We also walked through the newest improvements regarding reactive data binding and component interaction using </span><span class="No-Break"><span class="koboSpan" id="kobo.1216.1">Angular Signals.</span></span></p>
<p><span class="koboSpan" id="kobo.1217.1">By incorporating Angular Signals into your Angular applications, you can streamline data management, enhance code readability, and leverage the power of reactive programming. </span><span class="koboSpan" id="kobo.1217.2">Remember, signals and RxJS work together to empower you to build dynamic and responsive </span><span class="No-Break"><span class="koboSpan" id="kobo.1218.1">user interfaces.</span></span></p>
<p><span class="koboSpan" id="kobo.1219.1">In the next chapter, we’ll move on to the essentials of multicasting, which will be helpful in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1220.1">following chapters.</span></span></p>
</div>


<div class="Content" id="_idContainer063">
<h1 id="_idParaDest-139" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.1.1">Part 4: Multicasting Adventures</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part, we will understand the essentials of multicasting in RxJS, as well as the recommended reactive patterns in many real-world use cases, such as caching data, multiple asynchronous operations, and </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">real-time features.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">You will also delve into the best practices when using multicast operators, Subjects, and Behavior Subjects and learn the pitfalls to avoid specifically in the context </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">of multicasting.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">This part includes the </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">following chapters:</span></span></p>
<ul>
<li><a href="B21180_09.xhtml#_idTextAnchor146"><em class="italic"><span class="koboSpan" id="kobo.8.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.9.1">, </span><em class="italic"><span class="koboSpan" id="kobo.10.1">Demystifying Multicasting</span></em></li>
<li><a href="B21180_10.xhtml#_idTextAnchor159"><em class="italic"><span class="koboSpan" id="kobo.11.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.12.1">, </span><em class="italic"><span class="koboSpan" id="kobo.13.1">Boosting Performance with Reactive Caching</span></em></li>
<li><a href="B21180_11.xhtml#_idTextAnchor170"><em class="italic"><span class="koboSpan" id="kobo.14.1">Chapter 11</span></em></a><span class="koboSpan" id="kobo.15.1">, </span><em class="italic"><span class="koboSpan" id="kobo.16.1">Performing Bulk Operations</span></em></li>
<li><a href="B21180_12.xhtml#_idTextAnchor180"><em class="italic"><span class="koboSpan" id="kobo.17.1">Chapter 12</span></em></a><span class="koboSpan" id="kobo.18.1">, </span><em class="italic"><span class="koboSpan" id="kobo.19.1">Processing Real-Time Updates</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer064">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer065">
</div>
</div>
</body></html>