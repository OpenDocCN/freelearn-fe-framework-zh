- en: Implementing Properties and Events in Our Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的组件中实现属性和事件
- en: So far, we have had the opportunity to take a bird's eye overview of what components
    are in the new Angular ecosystem, what their role is, how they behave, and what
    tools are required to start building our own components to represent widgets and
    pieces of functionality. In addition, TypeScript turns out to be the perfect companion
    for this endeavor, so we seem to have everything that we need to further explore
    the possibilities that Angular brings to the game with regards to creating interactive
    components that expose properties and emit events.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有机会俯瞰新的Angular生态系统中组件的概述，它们的角色是什么，它们的行为如何，以及开始构建我们自己的组件来表示小部件和功能块所需的工具是什么。此外，TypeScript证明是这项努力的完美伴侣，因此我们似乎拥有了进一步探索Angular为创建公开属性和发出事件所带来的可能性的一切所需的一切。
- en: 'In this chapter, we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Discover all the syntactic possibilities at our disposal to bind content in
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现我们可以使用的所有语法可能性来绑定内容
- en: our templates
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板
- en: Create public APIs for our components so that we can benefit from their properties
    and event handlers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的组件创建公共API，以便我们可以从它们的属性和事件处理程序中受益
- en: See how to implement data binding in Angular
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看如何在Angular中实现数据绑定
- en: Reduce the complexity of CSS management with view encapsulation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过视图封装来减少CSS管理的复杂性
- en: A better template syntax
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好的模板语法
- en: In [Chapter 1](17474bca-f7f9-41ec-ab4c-5f7ac741c0c9.xhtml), *Creating Our Very
    First Component in Angular*, we saw how to embed HTML templates in our components,
    but we didn't even scratch the surface of template development for Angular. As
    we will see later in this book, template implementation is tightly coupled with
    the principles of Shadow DOM design and it brings out a lot of syntactic sugar
    to ease the task of binding properties and events in our views in a declarative
    fashion.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](17474bca-f7f9-41ec-ab4c-5f7ac741c0c9.xhtml) *在Angular中创建我们的第一个组件*中，我们看到了如何在我们的组件中嵌入HTML模板，但我们甚至没有触及Angular模板开发的表面。正如我们将在本书中看到的，模板实现与Shadow
    DOM设计原则紧密耦合，并且它为我们在视图中以声明方式绑定属性和事件带来了大量的语法糖，以简化任务。
- en: In a nutshell, Angular components may expose a public API that allows them to
    communicate with other components or containers. This API may encompass input
    properties, which we use to feed the component with data. It also may expose output
    properties we can bind event listeners to, thereby getting prompt information
    about changes in the state of the component.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Angular组件可以公开一个公共API，允许它们与其他组件或容器进行通信。这个API可能包括输入属性，我们用它来向组件提供数据。它还可以公开输出属性，我们可以将事件监听器绑定到它，从而及时获取有关组件状态变化的信息。
- en: Let's take a look at the way Angular solves the problem of injecting data in
    and out of our components through quick and easy examples. Please focus on the
    philosophy behind these properties. We will have a chance to see them in action
    later.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Angular是如何通过快速简单的示例来解决将数据注入和注出我们的组件的问题的。请关注这些属性背后的哲学。我们将有机会在稍后看到它们的实际应用。
- en: Data bindings with input properties
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用输入属性进行数据绑定
- en: Let's revisit the timer component functionality that we already saw in [Chapter
    1](17474bca-f7f9-41ec-ab4c-5f7ac741c0c9.xhtml),
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视定时器组件的功能，这是我们在[第1章](17474bca-f7f9-41ec-ab4c-5f7ac741c0c9.xhtml)中已经看到的
- en: '*Creating Our Very First Component in Angular*, and let''s imagine that we
    want our component to have a configurable attribute so that we can increase or
    decrease the countdown time:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*在Angular中创建我们的第一个组件*，让我们假设我们希望我们的组件具有可配置的属性，以便我们可以增加或减少倒计时时间：'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Please note the attribute wrapped between brackets. This informs Angular that
    this is an input property. The class that models the `timer` component will contain
    a setter function for the `seconds` property, which will react to changes in that
    value by updating its own countdown duration. We can inject a data variable or
    an actual hardcoded value, in which case we will have to wrap it around single
    quotes within the double quotes should such a value be a text string.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意大括号之间的属性。这告诉Angular这是一个输入属性。模拟`timer`组件的类将包含一个`seconds`属性的setter函数，该函数将根据该值的变化来更新自己的倒计时持续时间。我们可以注入一个数据变量或一个实际的硬编码值，如果这样的值是文本字符串，则必须在双引号内用单引号括起来。
- en: 'Sometimes we will see this syntax while injecting data into our component''s
    custom properties, while at other times we will use this very bracket syntax to
    make native HTML attributes reactive to component fields, like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们会看到这种语法，用于将数据注入到组件的自定义属性中，而在其他时候，我们将使用这种括号语法使原生HTML属性对组件字段具有响应性，就像这样：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Some extra syntactic sugar when binding expressions
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在绑定表达式时的一些额外语法糖
- en: 'The Angular team has made some shortcuts available for performing common transformations
    in our component directives and DOM elements, such as tweaking attributes and
    class names or applying styles. Here, we have some examples of great time-savers
    when declaratively defining bindings in our properties:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Angular团队已经为我们的组件指令和DOM元素提供了一些快捷方式，用于执行常见的转换，比如调整属性和类名或应用样式。在这里，我们有一些在属性中声明性地定义绑定时的时间节省示例：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the first case, `div` will enable the hidden attribute should the`isHidden`expression
    evaluate to `true`. Besides Boolean values, we can bind any other data type, such
    as a string value. In the second case, the `is-valid` class name will be injected
    in the class attribute if the `isValid` expression evaluates to `true`. In our
    third example, `div` will feature a style attribute that shows off a `width` property
    meant to be set with the value of the `myWidth` expressions in pixels. You can
    find more examples of this syntactic sugar in the Angular cheat sheet ([https://angular.io/guide/cheatsheet](https://angular.io/cheatsheet))
    available at the official Angular site.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，如果`isHidden`表达式评估为`true`，`div`将启用隐藏属性。除了布尔值之外，我们还可以绑定任何其他数据类型，比如字符串值。在第二种情况下，如果`isValid`表达式评估为`true`，`is-valid`类名将被注入到class属性中。在我们的第三个例子中，`div`将具有一个样式属性，显示出一个以像素为单位设置的`width`属性的值，该值由`myWidth`表达式设置。您可以在Angular速查表（[https://angular.io/guide/cheatsheet](https://angular.io/cheatsheet)）中找到更多这种语法糖的例子，该速查表可在官方Angular网站上找到。
- en: Event binding with output properties
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用输出属性进行事件绑定
- en: 'Let''s imagine we want our timer component to notify us when the countdown
    is finished so that we can perform other actions outside the realm of the component.
    We can achieve such functionality with an output property like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望我们的计时器组件在倒计时结束时通知我们，以便我们可以执行组件范围之外的其他操作。我们可以通过输出属性实现这样的功能：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note the attribute wrapped between braces. This informs Angular that such an
    attribute is, in fact, an output property that will trigger the event handler
    we bind to it. In this case, we will want to create an `onCountownCompleted` event
    handler on the container object that wraps this component.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意大括号之间的属性。这告诉Angular，这样的属性实际上是一个输出属性，将触发我们绑定到它的事件处理程序。在这种情况下，我们将希望在包装此组件的容器对象上创建一个`onCountownCompleted`事件处理程序。
- en: By the way, the camel case is not a coincidence. It is a naming convention applied
    to all output and input property names in Angular.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，驼峰命名不是巧合。这是Angular中应用于所有输出和输入属性名称的命名约定。
- en: 'We will find output properties mapped to interaction events that we already
    know, such as `click`, `mouseover`, `mouseout`, `focus`, and more:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将找到与我们已知的交互事件映射的输出属性，例如`click`，`mouseover`，`mouseout`，`focus`等等：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Input and output properties in action
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入和输出属性的作用
- en: 'The best way to grasp the concepts detailed in the earlier sections is by practice.
    In the first chapter, we learned how to build an application from scratch by using
    either Webpack or Angular-CLI to set up the project. As Angular-CLI is considered
    the standard way of setting up the project, let''s use just that and scaffold
    ourselves a new project by typing:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握前面章节中详细介绍的概念的最佳方法是实践。在第一章中，我们学习了如何使用Webpack或Angular-CLI从头开始构建应用程序。由于Angular-CLI被认为是设置项目的标准方式，让我们只使用它，并通过输入以下内容来创建一个新项目：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At this point, we have a fully working project that we can easily serve up by
    typing `ng serve`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们有一个完全可用的项目，可以通过输入`ng serve`轻松启动。
- en: 'Let''s quickly remind ourselves of the anatomy of an Angular project so we
    know what to do with all the new constructs we are about to create. The following
    files are of extra interest:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下Angular项目的结构，这样我们就知道如何处理我们即将创建的所有新构造。以下文件特别值得关注：
- en: '`main.ts`: This file bootstraps our application.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.ts`：这个文件引导我们的应用程序。'
- en: '`app/app.module.ts`: This file declares our root module, any new constructs
    will have to be added to the declarations property of this module or you will
    need to add a dedicated module for those future constructs. It is generally recommended
    to have a dedicated module for new constructs we have.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app/app.module.ts`：这个文件声明了我们的根模块，任何新的构造都必须添加到这个模块的declarations属性中，或者您需要为这些未来的构造添加一个专门的模块。通常建议为我们的新构造拥有一个专门的模块。'
- en: In the previous bullet list, we mentioned the concept *root module*. We mentioned
    this concept to remind ourselves of Angular modules in general. An Angular module
    holds a bunch of constructs that belong together. You will recognize an Angular
    module by using the `@NgModule`decorator; the module itself is just a plain class.
    The `@NgModule` decorator takes an object literal as input and it is within this
    object literal that we register everything that belongs to the module.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的项目列表中，我们提到了*根模块*的概念。我们提到这个概念是为了提醒自己关于Angular模块的一般情况。Angular模块包含一堆彼此相关的构造。您可以通过使用`@NgModule`装饰器来识别Angular模块；模块本身只是一个普通的类。`@NgModule`装饰器以对象字面量作为输入，并且在这个对象字面量中注册属于模块的一切。
- en: 'As mentioned in the preceding bullet list, it is considered good practice to
    add a dedicated module for our new constructs, so let''s do just that:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的项目列表中所述，为我们的新构造添加一个专门的模块被认为是一个良好的做法，所以让我们这样做：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At this point, we are leaving the `declarations`property array empty. Once we
    have declared our component, we will add it to that array.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们将`declarations`属性数组留空。一旦声明了我们的组件，我们将把它添加到该数组中。
- en: 'This module doesn''t belong to the application just yet, but it will need to
    be registered with the root module. Open up the `app.module.ts` file and add the
    newly created module to the `import` array, like so:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块目前还不属于应用程序，但它需要在根模块中注册。打开`app.module.ts`文件，并将新创建的模块添加到`import`数组中，就像这样：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s strip down the timer example that we saw in [Chapter 1](17474bca-f7f9-41ec-ab4c-5f7ac741c0c9.xhtml),
    *Creating Our Very First Component in Angular*, and discuss a simpler example.
    Let''s have a look at the `TimerComponent` file and replace its contents with
    the following component class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们剥离我们在[第1章](17474bca-f7f9-41ec-ab4c-5f7ac741c0c9.xhtml)中看到的定时器示例，*在Angular中创建我们的第一个组件*，并讨论一个更简单的例子。让我们看一下`TimerComponent`文件，并用以下组件类替换其内容：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Great! We have just defined a simple but highly effective countdown timer component
    that will count down to 0 from 25 seconds (do you see the `seconds` field up there?
    TypeScript supports the initialisation of members upon declaring them). A simple `setInterval()` loop
    executes a custom private function named `tick()` that decreases the value of
    seconds until it reaches zero, in which case we just clear the interval.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们刚刚定义了一个简单但非常有效的倒计时组件，它将从25秒倒数到0（你看到上面的`seconds`字段了吗？TypeScript支持在声明时初始化成员）。一个简单的`setInterval()`循环执行一个名为`tick()`的自定义私有函数，它减少秒数的值直到达到零，此时我们只需清除间隔。
- en: 'However, now we just need to embed this component somewhere, so let''s create
    another component with no functionality other than acting as an HTML wrapper host
    for the previous component. Create this new component right after the `CountdownTimerComponent` class
    in the same file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在我们只需要在某个地方嵌入这个组件，所以让我们创建另一个组件，除了作为前一个组件的HTML包装主机之外，没有其他功能。在同一个文件中，在`CountdownTimerComponent`类之后创建这个新组件：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As promised earlier, we will also add our newly created components to the `declarations` array
    of the module it belongs to, like so:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 按照之前的承诺，我们还将把我们新创建的组件添加到它所属的模块的`declarations`数组中，就像这样：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The reason for doing this in the first place is to ensure that these components
    are made available for one another, as is the case with `CountdownTimerComponent`being
    used inside the template of `TimerComponent`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先这样做的原因是确保这些组件可以相互使用，就像`CountdownTimerComponent`在`TimerComponent`的模板中使用的情况一样。
- en: Components in Angular are basically directives with a view template. We can
    also find directives with no view, which basically add new functionalities to
    their host element, or they just act as custom elements without a UI that wraps
    other elements. Alternatively, they simply provide further functionalities to
    other components by means of their API.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，组件基本上是带有视图模板的指令。我们还可以找到没有视图的指令，它们基本上为宿主元素添加新功能，或者它们只是作为不带UI的自定义元素包装其他元素。或者，它们通过API为其他组件提供更多功能。
- en: We will explore directives in detail in the next chapter and also throughout
    the book. You must be wondering why we have created this host or parent `TimerComponent ` component
    with no implementation. Soon, we will flesh it out with some more features, but
    for now let's use it as a proof of concept for how to initiate a component tree.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章和整本书中详细探讨指令。你一定想知道为什么我们创建了这个没有实现的主机或父`TimerComponent`组件。很快，我们将为它增加一些更多的功能，但现在让我们将其用作初始化组件树的概念验证。
- en: Setting up custom values declaratively
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式设置自定义值
- en: 'You will probably agree on the fact that having the functionality of setting
    up custom countdown timers would be nice, right? Input properties turn out to
    be an excellent way to achieve this. In order to leverage this functionality,
    we will have to tweak the `import` statement at the top of the file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会同意，设置自定义倒计时器的功能会很好，对吧？输入属性证明是实现这一点的一个很好的方式。为了利用这个功能，我们将不得不调整文件顶部的`import`语句。
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You might have already noticed that we are no longer initializing the `seconds`field,
    and it is now decorated with a property decorator (as we saw in [Chapter 3](9b3ddd80-6ddf-43e5-92d7-a9260c11ff6d.xhtml),
    *Introducing TypeScript*). We have just started to define the API of our component.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们不再初始化`seconds`字段了，现在它被一个属性装饰器修饰（就像我们在[第3章](9b3ddd80-6ddf-43e5-92d7-a9260c11ff6d.xhtml)中看到的那样，*介绍TypeScript*）。我们刚刚开始定义我们组件的API。
- en: Property naming is case sensitive. The convention enforced by Angular is to
    apply camel case to component input and, as we will see shortly, output properties
    alike.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 属性命名区分大小写。Angular强制执行的约定是对组件输入和输出属性都应用驼峰命名法，正如我们很快将看到的那样。
- en: 'Next, we just need to add the desired property in our container component''s
    template:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们只需要在容器组件的模板中添加所需的属性：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Please note that we have not updated the `TimerComponent` at all. We only updated
    its `CountdownComponent` child component. However, its brand new API becomes available
    to any component that eventually includes it in its own template as a child component,
    so we can set up its properties declaratively right from the template, or even
    bind a value imperatively from a property located in the `TimerComponent` controller
    class if we wish.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们根本没有更新`TimerComponent`。我们只更新了它的`CountdownComponent`子组件。然而，它全新的API可以在任何最终将其包含在自己模板中作为子组件的组件中使用，因此我们可以从模板中声明性地设置其属性，或者甚至可以从`TimerComponent`控制器类中的属性中以命令方式绑定值。
- en: When flagging a class property with `@Input()`, we can configure the name we
    want this property to have upon instantiating the component in the HTML. To do
    so, we just need to introduce our name of choice in the decorator signature, like
    this: `@Input('name_of_the_property')`. In any event, this practice is discouraged
    since exposing property names in the component API distinct from the ones defined
    in its controller class can only lead to confusion.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`@Input()`标记类属性时，我们可以配置在HTML中实例化组件时希望该属性具有的名称。为此，我们只需要在装饰器签名中引入我们选择的名称，就像这样：`@Input('name_of_the_property')`。无论如何，这种做法是不鼓励的，因为在组件API中公开与其控制器类中定义的属性名称不同的属性名称只会导致混淆。
- en: Communicating between components through custom events
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过自定义事件在组件之间进行通信
- en: Now that our child component is being configured by its parent component, how
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的子组件正在被其父组件配置，如何
- en: can we achieve communication from the child to the parent? This is where custom
    events come to the rescue! In order to create proper event bindings, we just need to
    configure an output property in our component and attach an event handler function
    to it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现从子组件到父组件的通信吗？这就是自定义事件发挥作用的地方！为了创建适当的事件绑定，我们只需要在组件中配置一个输出属性，并将事件处理程序函数附加到它上面。
- en: 'In order to trigger custom events, we will need to bring `EventEmitter` to
    the party, along with the `@Output` decorator, whose functionality is exactly
    the opposite to what we learned regarding the `@Input` decorator:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了触发自定义事件，我们需要引入`EventEmitter`，以及`@Output`装饰器，其功能与我们学到的关于`@Input`装饰器完全相反：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`EventEmitter` is the built-in event bus of Angular. In a nutshell, the `EventEmitter` class
    provides support for emitting `Observable` data and subscribing `Observer` consumers
    to data changes. Its simple interface, which basically encompass two methods, `emit()` and `subscribe()`,
    can therefore be used to trigger custom events and listen to events as well, both
    synchronously and asynchronously. We will discuss Observables in more detail in
    [Chapter 7](113fea8a-41c0-4884-95ad-ac95ee0c4c65.xhtml), *Asynchronous Data Services
    with Angular*. For the time being, we can get away with the idea that we will
    be using the `EventEmitter` API to spawn events that listener methods in the components
    hosting our event-emitting component can observe and attach event handlers to.
    These events acquire visibility outside the scope of the component through any
    of its properties annotated with the `@Input()` decorator.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter`是Angular的内置事件总线。简而言之，`EventEmitter`类支持发出`Observable`数据并订阅`Observer`消费者对数据更改。它的简单接口基本上包括两种方法，`emit()`和`subscribe()`，因此可以用于触发自定义事件以及同步和异步地监听事件。我们将在[第7章](113fea8a-41c0-4884-95ad-ac95ee0c4c65.xhtml)中更详细地讨论Observables，*使用Angular进行异步数据服务*。目前，我们可以通过`EventEmitter`API来生成事件，组件中托管我们发出事件的组件可以观察并附加事件处理程序。这些事件通过使用`@Input()`装饰器注释的任何属性在组件范围之外获得可见性。'
- en: 'The following code shows an actual implementation that follows up from the
    previous example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了一个实际的实现，从前面的例子中跟进：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A new property named `complete` is conveniently annotated with the`EventEmitter` type
    and initialized on the spot. Later on, we will access its emit method to spawn
    a custom event as soon as the countdown ends. The `emit()` method needs one mandatory
    parameter of any type, so we can send a data value to the event subscribers (or
    null if not required).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为`complete`的新属性被方便地注释为`EventEmitter`类型，并立即初始化。稍后，我们将访问它的`emit`方法，以便在倒计时结束时生成一个自定义事件。`emit()`方法需要一个任意类型的必需参数，因此我们可以向事件订阅者发送数据值（如果不需要，则为null）。
- en: 'Now, we just need to set up our host component so that it will listen to this
    complete event or output property and subscribe an event handler to it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要设置我们的宿主组件，以便它将监听此完成事件或输出属性，并订阅一个事件处理程序：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Why `complete`and not `onComplete`? Angular provides support for an alternative
    syntax named canonical form for both input and output properties. In the case
    of input properties, a property represented as `[seconds]`could be represented
    as `bind-seconds`, without the need for brackets. With regards to output properties,
    these can be represented as `on-complete` instead of `(complete)`. That is why
    we never prefix output property names with an `on` prefix, since that would occur
    on output properties such as`on-complete`   in case we eventually decide to favor
    the canonical syntax form in our projects.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是`complete`而不是`onComplete`？Angular支持另一种语法形式，称为规范形式，用于输入和输出属性。在输入属性的情况下，一个属性表示为`[seconds]`可以表示为`bind-seconds`，无需使用括号。关于输出属性，这些可以表示为`on-complete`而不是`(complete)`。这就是为什么我们从不在输出属性名称前加上`on`前缀，因为这将出现在输出属性上，比如`on-complete`，如果我们最终决定在我们的项目中更喜欢规范语法形式。
- en: 'We have learned to use input data with our component. The data would live in
    the container and the component would be rendered inside of the container template.
    This means the component could suddenly gain access to the container''s data by
    us typing this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用组件的输入数据。数据将驻留在容器中，组件将在容器模板内呈现。这意味着组件可以通过我们输入的方式突然访问容器的数据：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And on the component side, the code looks as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件方面，代码如下所示：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We''ve also learned about output, that is, how to communicate back from component
    to container. To make this happen, we added another property on the component
    like so:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了输出，也就是如何从组件向容器进行通信。为了实现这一点，我们在组件上添加了另一个属性，如下所示：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And on the component side, we would instead use a decorator called `Output`,
    like so:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件方面，我们将使用一个名为`Output`的装饰器，如下所示：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And to actively invoke that bonded method, we would type:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 并积极调用绑定的方法，我们会输入：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Then next thing coming up is to learn how to pass data from component to container.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要学习的是如何从组件传递数据到容器。
- en: Emitting data through custom events
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过自定义事件发出数据
- en: Now that we know how to emit custom events from our component API, why don't
    we take a step further and send data signals beyond the scope of the component?
    We already discussed that the `emit()` event of the `EventEmitter<T>` class accepts
    in its signature any given data of the type represented by the `T` annotation.
    Let's extend our example to notify the progress of the countdown. Why would we
    ever want to do this? Basically, our component displays onscreen a visual countdown,
    but we might want to watch the countdown progress programmatically in order to
    take action once the countdown is finished or reaches a certain point.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道如何从组件API发出自定义事件，为什么不再进一步，将数据信号发送到组件范围之外呢？我们已经讨论过`EventEmitter<T>`类的`emit()`事件在其签名中接受由`T`注释表示的任何给定数据。让我们扩展我们的示例以通知倒计时的进度。为什么我们要这样做呢？基本上，我们的组件在屏幕上显示一个可视倒计时，但我们可能希望以编程方式观察倒计时的进度，以便在倒计时结束或达到某一点时采取行动。
- en: Let's update our timer component with another output property that matches
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用另一个输出属性更新我们的计时器组件，与之匹配
- en: the original and emits a custom event on each iteration of the `seconds` property,
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的并在每次迭代`seconds`属性时发出自定义事件，
- en: 'as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let''s rebuild our host component''s template to reflect the actual progress
    of the countdown. We already do so by displaying the countdown, but that is a
    feature handled internally by the `CountdownTimerComponent`. Now, we will keep
    track of the countdown outside this component:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重建主机组件的模板，以反映倒计时的实际进度。我们已经通过显示倒计时来做到这一点，但这是由`CountdownTimerComponent`在内部处理的功能。现在，我们将在该组件之外跟踪倒计时：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We took advantage of this round of changes to formalize the timeout value as
    a property of the host component. This allows us to bind new values to that property
    in our custom event handlers, as we did in the preceding example. Rather than
    binding an event handler method to the (`progress`) handler, we refer to the`$event` reserved
    variable. It is a pointer to the payload of the `progress output` property that
    reflects the value we pass to the`emit()` function when executing `this.progress.emit(this.seconds)`.
    In short, `$event` is the value assumed by `this.seconds` inside`CountdownTimerComponent`.
    By assigning such a value to the `timeout` class property within the template,
    we are also updating the binding expressed in the paragraph we just inserted into
    the template. This paragraph will only become visible when `timeout` is lower
    than `10`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用这一轮更改来将超时值正式化为主机组件的属性。这使我们能够在我们的自定义事件处理程序中将新值绑定到该属性，就像我们在前面的示例中所做的那样。我们不是将事件处理程序方法绑定到(`progress`)处理程序，而是引用`$event`保留变量。它是指向`progress
    output`属性的有效负载的指针，反映了我们在执行`this.progress.emit(this.seconds)`时传递给`emit()`函数的值。简而言之，`$event`是`CountdownTimerComponent`内`this.seconds`所假定的值。通过将这样的值分配给模板中的`timeout`类属性，我们还更新了模板中插入的段落中表达的绑定。当`timeout`小于`10`时，此段落将变为可见。
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'What we saw in this section was how we could send data from the component to
    the container. There are essentially two ways of doing that:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何从组件发送数据到容器。基本上有两种方法：
- en: Assign `$event` to the container property
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`$event`分配给容器属性
- en: Invoke the container method with `$event` as the function parameter
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`$event`作为函数参数调用容器方法
- en: 'The first version is what we demonstrated, that is:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个版本就是我们所演示的：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With the component invoking it as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 组件调用它如下：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The second version is a small rewrite of the preceding example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个版本是对前面示例的小改写：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We would invoke it the same way in the component, but the difference would
    be that we need to declare a container method, `onProgress`, so the `timeout`
    property gets set that way instead:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会以与组件相同的方式调用它，但不同之处在于我们需要声明一个容器方法`onProgress`，这样`timeout`属性就会以这种方式设置：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Local references in templates
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板中的本地引用
- en: We have previously seen how we can bind data to our templates using data interpolation
    with the double curly braces syntax. Besides this, we will quite often spot named
    identifiers prefixed by a hash symbol (`#`) in the elements belonging to our components
    or even regular HTML controls. These reference identifiers, namely local names,
    are used to refer to the components flagged with them in our template views and
    then access them programmatically. They can also be used by components to refer
    to other elements in the virtual DOM and access its properties.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到了如何使用双大括号语法通过数据插值将数据绑定到我们的模板。除此之外，我们经常会在属于我们组件或甚至常规HTML控件的元素中看到以井号（`#`）为前缀的命名标识符。这些引用标识符，即本地名称，用于在我们的模板视图中引用标记为它们的组件，然后以编程方式访问它们。它们也可以被组件用来引用虚拟DOM中的其他元素并访问其属性。
- en: In the previous section, we saw how we could subscribe to the countdown progress
    through the `progress` event. But what if we could inspect the component in depth,
    or at least its public properties and methods, and read the value that the `seconds`
    property takes on each tick interval without having to listen to the `progress`
    event? Well, setting a local reference on the component itself will open the door to
    its public façade.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看到了如何通过`progress`事件订阅倒计时的进度。但是，如果我们能深入检查组件，或者至少是它的公共属性和方法，并在不必监听`progress`事件的情况下读取`seconds`属性在每个滴答间隔中的值，那该多好啊？好吧，给组件本身设置一个本地引用将打开其公共外观的大门。
- en: 'Let''s flag the instance of our `CountdownTimerComponent` in the `TimerComponent`
    template with a local reference named`#counter`. From that very moment, we will
    be able to directly access the component''s public properties, such as `seconds`,
    and even bind it in other locations of the template. This way, we do not even
    need to rely on the `progress` event emitter or the `timeout` class field, and
    we can even manipulate the value of such properties. This is shown in the following
    code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`TimerComponent`模板中标记我们的`CountdownTimerComponent`实例，使用一个名为`#counter`的本地引用。从那一刻起，我们将能够直接访问组件的公共属性，比如`seconds`，甚至在模板的其他位置绑定它。这样，我们甚至不需要依赖`progress`事件发射器或`timeout`类字段，甚至可以操纵这些属性的值。这在下面的代码中显示：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Alternative syntax for input and output properties
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入和输出属性的替代语法
- en: Besides the `@Input()` and `@Output()` decorators, there is an alternative syntax
    where we can define `input` and `output` properties in our components by means
    of the`@Component` decorator. Its metadata implementation provides support for
    both features through the `inputs` and `outputs` property names, respectively.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`@Input()`和`@Output()`装饰器之外，还有一种替代语法，我们可以通过`@Component`装饰器来定义组件的`input`和`output`属性。它的元数据实现通过`inputs`和`outputs`属性名称分别提供对这两个功能的支持。
- en: 'The `CountdownTimerComponent` API could therefore be implemented like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`CountdownTimerComponent`的API可以这样实现：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: All in all, this syntax is discouraged and has been included here for reference
    purposes only. In the first place, we duplicate code by defining the names of
    our API endpoints in two places at the same time, increasing the risk of errors
    when refactoring code. It is also a common convention to keep the decorator implementations
    as lean as possible in order to improve readability.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这种语法是不鼓励的，仅出于参考目的而包含在这里。首先，我们通过在两个地方定义API端点的名称来重复代码，增加了重构代码时出错的风险。另外，通常惯例是尽量保持装饰器的实现尽可能简洁，以提高可读性。
- en: I strongly suggest that you stick to the `@Input` and `@Output` decorators.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您坚持使用`@Input`和`@Output`装饰器。
- en: Configuring our template from our component class
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从组件类配置我们的模板
- en: The component metadata also supports several settings that contribute to easy
    template management and configuration. On the other hand, Angular takes advantage
    of the CSS encapsulation functionalities of web components.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 组件元数据还支持一些设置，有助于简化模板管理和配置。另一方面，Angular利用了Web组件的CSS封装功能。
- en: Internal and external templates
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部和外部模板
- en: As our applications grow in size and complexity, chances are that our templates
    will grow as well, hosting other components and bigger chunks of HTML code. Embedding
    all this code in our component class definitions will become a cumbersome and
    unpleasant task and it will also be quite prone to errors. In order to prevent
    this from happening, we can leverage the `templateUrl` property, pointing to a
    standalone HTML file that contains our component HTML markup.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的规模和复杂性的增长，我们的模板也可能会增长，承载其他组件和更大的HTML代码块。将所有这些代码嵌入到我们的组件类定义中将变得繁琐和不愉快，而且也很容易出错。为了防止这种情况发生，我们可以利用`templateUrl`属性，指向一个包含我们组件HTML标记的独立HTML文件。
- en: 'Back to our previous example, we can refactor the `@Component` decorator of
    our `TimerComponent` class to point to an external HTML file containing our template.
    Create a new file named `timer.component.html` in the workspace where our `timer.component.ts`
    file lives and populate it with the same HTML we configured in our`TimerComponent` class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们之前的例子，我们可以重构`TimerComponent`类的`@Component`装饰器，指向一个包含我们模板的外部HTML文件。在我们的`timer.component.ts`文件所在的工作区中创建一个名为`timer.component.html`的新文件，并用我们在`TimerComponent`类中配置的相同HTML填充它：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we can polish our `@Component` decorator to point to that file instead
    of defining the HTML inside the decorator metadata:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以修改`@Component`装饰器，指向该文件，而不是在装饰器元数据中定义HTML：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: External templates follow a certain convention in Angular, enforced by the most
    popular Angular coding style guide out there, which is to share the same filename
    as the component they belong to, including any filename prefix or suffix we might
    append to the component filename. We will see this when exploring component naming
    conventions in [Chapter 6](93b8f637-859e-4e12-aaa0-4cec5f02c2c3.xhtml), *Building
    an Application with Angular Components*. This way, it is easier to recognize,
    or even search with your IDE's search built-in fuzzy finder tool, which HTML file
    is in fact the template of a specific component.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 外部模板遵循Angular中的某种约定，由最流行的Angular编码风格指南强制执行，即与它们所属的组件共享相同的文件名，包括我们可能附加到组件文件名的任何前缀或后缀。在[第6章](93b8f637-859e-4e12-aaa0-4cec5f02c2c3.xhtml)中探索组件命名约定时，我们将看到这一点，*使用Angular组件构建应用程序*。这样，更容易识别，甚至可以使用IDE的内置模糊查找工具搜索，哪个HTML文件实际上是特定组件的模板。
- en: What is the threshold for creating standalone templates rather than keeping
    the template markup inside the component? It depends on the complexity and size
    of the template. Common sense will be your best advisor in this case.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在哪种情况下创建独立模板而不是将模板标记保留在组件内？这取决于模板的复杂性和大小。在这种情况下，常识将是您最好的顾问。
- en: Encapsulating CSS styling
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装CSS样式
- en: In order to better encapsulate our code and make it more reusable, we can define
    CSS styling within our components. These internal style sheets are a good way
    to make our components more shareable and maintainable. There are three different
    ways of defining CSS styling for our components.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地封装我们的代码并使其更具重用性，我们可以在组件内定义CSS样式。这些内部样式表是使我们的组件更具共享性和可维护性的好方法。有三种不同的方法来定义我们组件的CSS样式。
- en: The styles property
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: styles属性
- en: 'We can define `styles` for our HTML elements and class names through the `styles` property
    in the component decorator, like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过组件装饰器中的`styles`属性为我们的HTML元素和类名定义样式，如下所示：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This property will take an array of strings, each containing CSS rules, and
    apply them to the template markup by embedding those rules at the head of the
    document as soon as we bootstrap our application. We can either inline the styling
    rules in a single line, or take advantage of ES2015 template strings to indent
    the code and make it more readable, as depicted in the preceding example.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性将接受一个字符串数组，每个字符串包含CSS规则，并在我们启动应用程序时将这些规则嵌入到文档的头部以应用于模板标记。我们可以将样式规则内联为一行，也可以利用ES2015模板字符串来缩进代码并使其更可读，就像前面的示例中所示。
- en: The styleUrls property
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: styleUrls属性
- en: 'Just like `styles`, `styleUrls` will accept an array of strings, although each
    one will represent a link to an external style sheet though. This property can
    be used alongside the `styles` property as well, defining different sets of rules
    where required:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`styles`一样，`styleUrls`也会接受一个字符串数组，尽管每个字符串都代表一个外部样式表的链接。这个属性也可以与`styles`属性一起使用，根据需要定义不同的规则集：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Inline style sheets
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联样式表
- en: 'We can also attach the styling rules to the template itself, no matter whether
    it''s an inline template or a template served through the `templateUrl` parameter:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将样式规则附加到模板本身，无论是内联模板还是通过`templateUrl`参数提供的模板：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Managing view encapsulation
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理视图封装
- en: All the preceding sections (`styles`, `styleUrls`, and inline style sheets)
    will be governed by the usual rules of CSS specificity ([https://developer.mozilla.org/en/docs/Web/CSS/Specificity](https://developer.mozilla.org/en/docs/Web/CSS/Specificity)).
    CSS management and specificity becomes a breeze on browsers that support Shadow
    DOM, thanks to scoped styling. CSS styles apply to the elements contained in the
    component, but they do not spread beyond its boundaries.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的部分（`styles`，`styleUrls`和内联样式表）都将受到CSS特异性的通常规则的约束（[https://developer.mozilla.org/en/docs/Web/CSS/Specificity](https://developer.mozilla.org/en/docs/Web/CSS/Specificity)）。在支持Shadow
    DOM的浏览器上，由于作用域样式，CSS管理和特异性变得轻而易举。CSS样式适用于组件中包含的元素，但不会超出其边界。
- en: On top of that, Angular will embed these style sheets at the head of the document,
    so they might affect other elements of our application. In order to prevent this
    from happening, we can set up different levels of view encapsulation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Angular将嵌入这些样式表到文档的头部，因此它们可能会影响我们应用程序的其他元素。为了防止这种情况发生，我们可以设置不同级别的视图封装。
- en: 'In a nutshell, encapsulation is the way Angular needs to manage CSS scoping
    within the component for both shadow DOM-compliant browsers and those that do
    not support it. For all this, we leverage the `ViewEncapsulation enum`, which
    can take any of these values:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，封装是Angular需要在组件内管理CSS作用域的方式，适用于支持阴影DOM的浏览器和不支持它的浏览器。为此，我们利用`ViewEncapsulation
    enum`，它可以采用以下任何值：
- en: '**Emulated**: This is the default option, and it basically entails an emulation
    of native scoping in Shadow DOM, through sandboxing the CSS rules under a specific
    selector that points to our component. This option is preferred to ensure that
    our component styles will not be affected by other existing libraries on our site.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟：这是默认选项，基本上是通过在特定选择器下沙盒化CSS规则来模拟阴影DOM中的本地作用域。推荐使用此选项，以确保我们的组件样式不会受到站点上其他现有库的影响。
- en: '**Native**: Use the native Shadow DOM encapsulation mechanism of the renderer,
    and it only works on browsers that support Shadow DOM.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地：使用渲染器的本地阴影DOM封装机制，仅适用于支持阴影DOM的浏览器。
- en: '**None**: Template or style encapsulation is not provided. The styles will
    be injected as is into the document''s header.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无：不提供模板或样式封装。样式将按原样注入到文档的头部。
- en: 'Let''s check out an actual example. First, import the `ViewEncapsulation enum`
    into the script, and then create an encapsulation property with the emulated value.
    Then, let''s create a style rule for our countdown text so any `<h1> (!)` tag
    is rendered in dark red:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个实际的例子。首先，将`ViewEncapsulation enum`导入脚本，然后创建一个模拟值的封装属性。然后，让我们为倒计时文本创建一个样式规则，以便任何`<h1>
    (!)`标签都呈现为深红色：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, click on the browser's dev tools inspector and check the generated HTML
    to discover how Angular injected the CSS inside the page `<head>` block. The just
    injected style sheet has been sandboxed to ensure that the global CSS rule we
    defined at the component setup in a very non-specific way for all `<h1>` elements
    only applies to matching elements scoped by the `CountdownTimerComponent` component
    exclusively.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击浏览器的开发工具检查器，并检查生成的HTML，以发现Angular如何将CSS注入到页面的`<head>`块中。刚刚注入的样式表已经被沙盒化，以确保我们在组件设置中以非常不具体的方式定义的全局CSS规则仅适用于由`CountdownTimerComponent`组件专门作用域的匹配元素。
- en: We recommend that you try out different values and see how the CSS code is injected
    into the document. You will immediately notice the different grades of isolation
    that each variation provides.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您尝试不同的值，并查看CSS代码如何注入到文档中。您将立即注意到每种变化提供的隔离等级不同。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter guided us through the options available in Angular for creating
    powerful APIs for our components, so we can provide high levels of interoperability
    between components, configuring its properties by assigning either static values
    or managed bindings. We also saw how a component can act as a host component for
    another child component, instantiating the former's custom element in its own
    template, setting the ground up for larger component trees in our applications.
    Output parameters give the layer of interactivity we need by turning our components
    into event emitters so they can properly communicate in an agnostic fashion with
    any parent component that might eventually host them. Template references paved
    the way to create references in our custom elements that we can use as accessors
    to their properties and methods from within the template in a declarative fashion.
    We also discussed how we could isolate the component's HTML template in an external
    file in order to ease its future maintainability and how to do the same with any
    style sheet we wanted to bind to the component, in case we do not want to bundle
    the component styles inline. An overview of the built-in features for handling
    view encapsulation in Angular gave us some additional insights on how we can benefit
    from Shadow DOM's CSS scoping on a per-component basis and how we can polyfill
    it when not supported.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本章引导我们了解了Angular中为组件创建强大API的选项，这样我们就可以在组件之间提供高水平的互操作性，通过分配静态值或管理绑定来配置其属性。我们还看到了一个组件如何可以作为另一个子组件的宿主组件，实例化前者的自定义元素在其自己的模板中，为我们的应用程序中更大的组件树奠定了基础。输出参数为我们提供了所需的交互层，通过将我们的组件转换为事件发射器，使它们可以以一种不可知的方式与任何可能最终托管它们的父组件进行通信。模板引用为我们的自定义元素创建了引用的途径，我们可以以声明性的方式从模板内部使用它们的属性和方法。我们还讨论了如何将组件的HTML模板隔离在外部文件中，以便于将来的维护，以及如何对我们想要绑定到组件的任何样式表执行相同的操作，以防我们不想将组件样式内联绑定。对Angular中处理视图封装的内置功能的概述为我们提供了一些额外的见解，让我们了解了如何可以从每个组件的角度受益于Shadow
    DOM的CSS封装，以及在不支持时如何进行polyfill。
- en: We still have much more to learn regarding template management in Angular, mostly
    with regards to the two concepts that you will use extensively along your journey
    with Angular. I am referring to Directives and Pipes, which we will cover extensively
    in [Chapter 5](3df2cad2-baa6-4076-a6ab-d84247af7817.xhtml), *Enhancing Our Components
    with Pipes and Directives*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，我们仍然有很多关于模板管理的东西要学习，主要是关于你在使用Angular过程中会广泛使用的两个概念。我指的是指令和管道，在[第5章](3df2cad2-baa6-4076-a6ab-d84247af7817.xhtml)中我们将对其进行详细介绍，《使用管道和指令增强我们的组件》。
