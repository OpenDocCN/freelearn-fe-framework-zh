- en: Our First View via Component Building
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过组件构建我们的第一个视图
- en: We've been working hard at framing the base of our app in [Chapter 2](part0037.html#1394Q0-289fe2426d594f99a90e4363b2c9c34d),
    *Feature Modules,* and now it's time to finally get a glimpse of what we're working
    with. This is all about getting that first view from our sketch to the mobile
    device screen.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在努力构建[第2章](part0037.html#1394Q0-289fe2426d594f99a90e4363b2c9c34d)中“功能模块”的基础，现在终于可以一窥我们所工作的内容。这全部关于将我们的草图中的第一个视图移动到移动设备屏幕上。
- en: Building views with NativeScript for Angular is not much different than view
    building for the web. We will use Angular's Component decorator to build various
    components our UI needs to achieve the desired usability we're after. Instead
    of using the HTML markup, we will be using NativeScript XML, which is an extremely
    powerful, yet simple and concise, abstraction of all native view components on
    both iOS and Android.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NativeScript 为 Angular 构建视图与网页视图构建没有太大区别。我们将使用 Angular 的组件装饰器来构建我们 UI 需要的各种组件，以实现我们追求的可用性。我们将使用
    NativeScript XML 而不是 HTML 标记，因为 NativeScript XML 是一个非常强大、简单且简洁的抽象，它代表了 iOS 和 Android
    上的所有原生视图组件。
- en: 'We won''t be covering all the benefits and types of components you have access
    to here; but to learn more, we recommend any of the following books:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会涵盖所有可用的组件的好处和类型；但若想了解更多，我们推荐以下任何一本书籍：
- en: '[https://www.packtpub.com/web-development/getting-started-nativescript](https://www.packtpub.com/web-development/getting-started-nativescript)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/web-development/getting-started-nativescript](https://www.packtpub.com/web-development/getting-started-nativescript)'
- en: '[https://www.manning.com/books/nativescript-in-action](https://www.manning.com/books/nativescript-in-action)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.manning.com/books/nativescript-in-action](https://www.manning.com/books/nativescript-in-action)'
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Using Component decorator to compose our views
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组件装饰器来组合我们的视图
- en: Creating reusable components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可重用组件
- en: Creating a custom view filter using Pipe
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管道创建自定义视图过滤器
- en: Running the app on the iOS and Android simulators
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 iOS 和 Android 模拟器上运行应用
- en: Our first view via component building
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过组件构建我们的第一个视图
- en: If we look at our sketch from [Chapter 1](part0023.html#LTSU0-289fe2426d594f99a90e4363b2c9c34d),
    *Get into Shape with @NgModule*, we can see a header at the top of the app, which
    will contain our app title with the record button to the right. We also see a
    listing of tracks with some player controls at the bottom. We can break these
    key elements of our UI design into essentially three primary components. One component
    is already provided by the NativeScript framework, the ActionBar, which we will
    use to represent the top header.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看[第1章](part0023.html#LTSU0-289fe2426d594f99a90e4363b2c9c34d)中的草图，“使用 @NgModule
    进入形状”，我们可以看到应用顶部的标题栏，其中将包含我们的应用标题和右侧的记录按钮。我们还可以看到底部的曲目列表和一些播放器控制。我们可以将这些 UI 设计的关键元素分解为基本上三个主要组件。一个组件是由
    NativeScript 框架提供的，即ActionBar，我们将用它来表示顶部标题栏。
- en: NativeScript provides many rich view components to build our UI. The markup
    is not HTML but rather XML with an `.html` extension, which may seem unusual.
    The reason the `.html` extension is used for XML view templates with NativeScript
    for Angular is that the custom renderer ([https://github.com/NativeScript/nativescript-angular](https://github.com/NativeScript/nativescript-angular))
    uses a DOM adapter to parse the view template. Each NativeScript XML component
    represents true native view widgets on each respective platform.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: NativeScript 提供了许多丰富的视图组件来构建我们的 UI。标记不是 HTML，而是具有 `.html` 扩展名的 XML，这可能会显得有些不寻常。使用
    NativeScript for Angular 的 `.html` 扩展名用于 XML 视图模板的原因是自定义渲染器（[https://github.com/NativeScript/nativescript-angular](https://github.com/NativeScript/nativescript-angular)）使用
    DOM 适配器来解析视图模板。每个 NativeScript XML 组件代表各自平台上的真实原生视图小部件。
- en: For the other two primary components, we will use Angular's Component decorator.
    It's important at this phase of the app development cycle to think about encapsulated
    pieces of UI functionality. We will encapsulate our track listing as a component
    and the player controls as another component. In this exercise, we will use an outside-in
    approach to building our UI from an abstract viewpoint down to the implementation
    details of each component.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他两个主要组件，我们将使用 Angular 的组件装饰器。在应用开发周期的这个阶段，考虑封装的 UI 功能块非常重要。我们将把我们的曲目列表封装为一个组件，并将播放器控制封装为另一个组件。在这个练习中，我们将从抽象的观点开始，逐步到每个组件的实现细节，采用自外向内的方法来构建我们的
    UI。
- en: 'To begin, let''s focus on the root component in our Angular app because it
    will define the basic layout of our first view. Open `app/app.component.html`,
    clear its contents, and replace with the following to rough out the initial UI
    concept from our sketch:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We are expressing our view with `ActionBar` and the primary layout container
    for the main view, `GridLayout`. With NativeScript, it''s important that each
    view starts with a layout container as the root node (outside of any `ActionBar`
    or `ScrollView`), much like `div` tags that are used with HTML markup. At the
    time of this writing, there are six layout containers provided by NativeScript:
    `StackLayout`, `GridLayout`, `FlexboxLayout`, `AbsoluteLayout`, `DockLayout`,
    and `WrapLayout`. For our layout here, `GridLayout` will work well.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: All about the GridLayout
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GridLayout is one of the three most used layouts you will use in your NativeScript
    application (the others are FlexboxLayout and StackLayout). This is the layout
    that allows you to build complex layouts easily.  To use the GridLayout is very
    much like the enhanced table in HTML.  You are basically going to want to take
    your screen area and divide your screen into the pieces you need. It will allow
    you to tell the columns (or rows) to be a percentage of the remaining width (and
    height) of the screen. The grid supports three types of values; **absolute size**,
    a percentage of **remaining space**, and **used space**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: For **absolute size**, you just type in the number. For example, `100` means
    it will use 100 dp of space.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Another name for **dp** is **dip**. They are the same. A device-independent
    pixel (also density-independent pixel, DIP, or DP) is a physical unit of measurement
    based on a coordinate system held by a computer and represents an abstraction
    of a pixel for use by an application that an underlying system then converts to
    physical pixels.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: If you take the smallest iOS device supported, it has a screen width of 320dp.
    For other devices, such as tablets, some have a width of 1024 dp. So, 100 dp would
    be almost one third of an iOS phone, where it is one tenth of the screen on a
    tablet. So, this is something you need to think about when using fixed absolute
    values. It is typically better to use the used space over a fixed value, unless
    you are needing to constrain the column to a specific size.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: To use **remaining space-**based values , that is, `***`, the `***` tells it
    to use the rest of the remaining space. If the columns (or rows) is set to *`*`, `*`*,
    then space will be divided into two equal remainders of space. Likewise, `rows="*,*,*,*,*"`
    will specify five equal sized rows. You can also specify things, such as `columns="2*,3*,*",`
    and you will get three columns; the first column will be two sixth of the screen,
    the second column will be three sixth of the screen, and the final column will
    be one sixth of the screen (that is, 2+3+1 = 6).  This allows you great flexibility
    in how to use the remainder of the space.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The third type of sizing is **space used**. So what happens is the content inside
    the grid is measured and then the column is assigned the size that is the max
    used in that column (or row). This is very useful when you have a grid where you
    have data but you aren't sure of the size or you don't really care; you just want
    it to look good. So, this is the auto keyword. I might have `columns="auto,auto,*,auto"`.
    This means columns 1,2, and 4 will all be automatically sized based on the content
    inside those columns; and column 3 will use whatever space is left over. This
    is very useful for laying out the entire screen or parts of the screen where you
    are looking for a certain look.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种尺寸是**空间使用**。所以，当网格内部的内容被测量后，列将被分配一个大小，这个大小是该列（或行）中使用的最大值。这在您有一个包含数据但不确定大小或您并不真的在乎的网格时非常有用；您只是希望它看起来不错。所以，这是auto关键字。我可能有`columns="auto,auto,*,auto"`。这意味着第1、2和4列将根据这些列中的内容自动调整大小；而第3列将使用剩余的空间。这对于布局整个屏幕或屏幕的某些部分非常有用，您希望达到某种特定的外观。
- en: The final reason why the GridLayout is one of the best layouts is that when
    you assign items to the GridLayout, you can actually assign multiple items to
    the same rows and/or columns and you can use row or column spans to allow items
    to use more than one row and/or column.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: GridLayout之所以是最佳布局之一，最后一个原因是当您将项目分配给GridLayout时，您实际上可以将多个项目分配给相同的行和/或列，并且您可以使用行或列跨度来允许项目使用多个行和/或列。
- en: To assign an object, you just assign it via `row="0"` and/or `col="0"` (keep
    in mind these are index-based positions). You can also use `rowSpan` and `colSpan`
    to make an element span multiple rows and/or columns. Overall, the GridLayout
    is the most versatile layout and allows you to easily create almost any layout
    you will need in your app.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要分配一个对象，您只需通过`row="0"`和/或`col="0"`进行分配（请注意，这些是基于索引的位置）。您还可以使用`rowSpan`和`colSpan`来使一个元素跨越多个行和/或列。总的来说，GridLayout是最灵活的布局，允许您轻松创建您在应用程序中需要的几乎任何布局。
- en: Back to our layout
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到我们的布局
- en: Inside the grid, we have declared a `track-list` component to represent our track
    listing, which will flex vertically, taking up all the vertical space and leaving
    only a height of 100 for `player-controls`. We indicate `track-list` as `row="0"
    col="0"`, since rows and columns are index-based. The flexible (remainder) vertical
    height is defined via the GridLayout's `*` in the rows attribute. The bottom section
    of the grid (row 1) will represent the player controls, allowing users to play/pause
    the mix and shuttle the playback position.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在网格内部，我们声明了一个`track-list`组件来表示我们的轨道列表，该组件将垂直伸缩，占据所有垂直空间，并为`player-controls`留下100像素的高度。我们将`track-list`标记为`row="0"
    col="0"`，因为行和列是基于索引的。网格的灵活（剩余）垂直高度是通过GridLayout的`*`在行属性中定义的。网格的底部部分（第1行）将代表播放器控制，允许用户播放/暂停混合并移动播放位置。
- en: Now that we have the app's primary view defined in a rather abstract way, let's
    dive into the two custom components we need to build, `track-list` and `player-controls`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经以相当抽象的方式定义了应用程序的主要视图，让我们深入了解我们需要构建的两个自定义组件，`track-list`和`player-controls`。
- en: Building TrackList component
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建TrackList组件
- en: The track list should be a listing of all the recorded tracks. Each row in the
    list should provide a single record button to re-record in addition to a name
    label for displaying the title provided by the user. It should also provide a
    switch to allow the user to solo just that particular track.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 轨道列表应该是所有已记录轨道的列表。列表中的每一行应提供一个单独的记录按钮以重新录制，以及一个名称标签来显示用户提供的标题。它还应提供一个开关，允许用户仅独奏该特定轨道。
- en: We can inject `PlayerService` and declare it `public` to allow us to bind directly
    to the service's tracks collection.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注入`PlayerService`并将其声明为`public`，以便我们可以直接绑定到服务中的轨道集合。
- en: We can also mock out some of our bindings to get things rolling like the `record`
    action. For now, let's just allow a track to be passed in and let's print out
    an inspection of that track via `LogService`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以模拟一些我们的绑定来启动一些操作，比如`record`动作。目前，我们只允许传入一个轨道，并通过`LogService`打印出该轨道的检查信息。
- en: 'Let''s start by creating `app/modules/player/components/track-list/ track-list.component.ts`(with
    a matching `.html` template):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建`app/modules/player/components/track-list/ track-list.component.ts`（与匹配的`.html`模板）开始：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For the view template `track-list.component.html`, we are going to employ the
    powerful `ListView` component. This widget represents the native UITableView ([https://developer.apple.com/reference/uikit/uitableview](https://developer.apple.com/reference/uikit/uitableview))
    on iOS and the native ListView ([https://developer.android.com/guide/topics/ui/layout/listview.html](https://developer.android.com/guide/topics/ui/layout/listview.html))
    on Android, offering 60 fps virtual scrolling with reused rows. Its performance
    is unparalleled on mobile devices:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视图模板 `track-list.component.html`，我们将使用强大的 `ListView` 组件。此小部件代表 iOS 上的原生 UITableView
    ([https://developer.apple.com/reference/uikit/uitableview](https://developer.apple.com/reference/uikit/uitableview))
    和 Android 上的原生 ListView ([https://developer.android.com/guide/topics/ui/layout/listview.html](https://developer.android.com/guide/topics/ui/layout/listview.html))，提供具有复用行的
    60 fps 虚拟滚动。在移动设备上的性能无与伦比：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There's a lot going on with this view template, so let's inspect it a bit.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图模板中有很多内容，让我们稍微检查一下。
- en: Since we made `playerService` `public` upon injection into our Component's constructor,
    we can bind directly to its tracks via the `ListView` items' attribute using standard
    Angular binding syntax expressed as `[items]`. This will be the collection our
    list will iterate on.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在组件构造函数中注入 `playerService` 时将其设置为 `public`，我们可以通过 `ListView` 项的属性直接绑定到其轨道，使用标准的
    Angular 绑定语法表示为 `[items]`。这将是我们列表迭代的集合。
- en: The `template` node inside allows us to encapsulate how each row of our list
    will be laid out. It also allows us to declare a variable name (`let-track`) for
    use as our iterator reference.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`template` 节点内部允许我们封装列表每一行布局的方式。它还允许我们声明一个变量名（`let-track`），用作我们的迭代器引用。'
- en: We start with a GridLayout, since each row will contain a Record button (to
    allow a track to be re-recorded), to which we will assign a width of 75\. This
    button will be bound to the `tap` event, which will activate a recording session
    if the user is authenticated.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 GridLayout 开始，因为每一行将包含一个记录按钮（允许重新录制轨道），我们将为其分配宽度 75。此按钮将绑定到 `tap` 事件，如果用户已认证，则将激活一个录制会话。
- en: Then, we will have a Label to display a user-provided name for the track, which
    we will assign `*` to ensure it expands to fill the horizontal space in between
    our left-hand and right-hand columns. We use the text attribute to bind to `track.name`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将有一个标签来显示用户提供的轨道名称，我们将将其分配为 `*` 以确保它扩展以填充我们左侧和右侧列之间的水平空间。我们使用文本属性将其绑定到
    `track.name`。
- en: Lastly, we will use `switch` to allow the user to toggle soloing the track in
    the mix. This provides the `checked` attribute to allow us to bind our `track.solo`
    property to.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用 `switch` 允许用户切换混音中的轨道独奏。这提供了 `checked` 属性，使我们能够将 `track.solo` 属性绑定到它。
- en: Building a dialog wrapper service to prompt the user
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个对话框包装服务以提示用户
- en: If you recall from [Chapter 1](part0023.html#LTSU0-289fe2426d594f99a90e4363b2c9c34d), *Get
    Into Shape with @NgModule*, recording is a feature that should only be available
    to authenticated users. Therefore, we will want to prompt the user with a login
    dialog when they tap the Record button on each track. If they are already logged
    in, we will want to prompt them to confirm if they want to re-record the track
    for good usability.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得 [第 1 章](part0023.html#LTSU0-289fe2426d594f99a90e4363b2c9c34d) 中 *使用 @NgModule
    进入形状*，录制是一个仅应提供给认证用户的功能。因此，当用户在每条轨道上点击记录按钮时，我们将想要提示用户登录对话框。如果他们已经登录，我们将想要提示他们确认是否想要重新录制轨道，以确保良好的用户体验。
- en: We could handle this dialog directly in the Component by importing a NativeScript
    dialog service that provides a consistent API across both platforms. The `ui/dialogs`
    module from the NativeScript framework ([https://docs.nativescript.org/ui/dialogs](https://docs.nativescript.org/ui/dialogs))
    is a very convenient service, allowing you to create native alerts, confirms,
    prompts, actions, and basic login dialogs. However, we may want to provide custom
    native dialog implementations on both iOS and Android down the road for an even
    nicer UX experience. There are several plugins that provide very elegant native
    dialogs, for example, [https://github.com/NathanWalker/nativescript-fancyalert](https://github.com/NathanWalker/nativescript-fancyalert).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: To prepare for this enriched user experience, let's build a quick Angular service
    that we can inject and use everywhere, which will allow us to easily implement
    these niceties down the road.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this should be considered a `core` service to our app, let''s create `app/modules/core/services/dialog.service.ts`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At first glance, this may appear incredibly wasteful! Why create a wrapper that
    provides the exact same API as a service that already exists from the NativeScript
    framework?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Yes, indeed, at this stage, it appears that way. However, we are preparing for
    greatness in flexibility and power with how we will handle these dialogs in the
    future. Stay tuned for a potential bonus chapter of material covering this fun
    and unique polish to the integration.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do before we move on to use this service is to ensure
    it is added to our core service `PROVIDERS` collection. This will make sure Angular's
    DI system knows our new service is a valid token available for injection.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `app/modules/core/services/index.ts` and modify as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are now ready to inject and use our new service.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Integrating DialogService into our component
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s open up `track-list.component.ts` and inject `DialogService` for use
    in our record method. We will also need to determine if the user is logged in
    to conditionally display a login dialog or confirm prompt, so let''s also inject `AuthService`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The record method now first checks to see whether a user is authenticated via
    the static `AuthService.CURRENT_USER` reference, which is set when `AuthService`
    is first constructed via Angular's dependency injection upon app launch (see [Chapter
    2](part0037.html#1394Q0-289fe2426d594f99a90e4363b2c9c34d), *Feature Modules*).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: If a user is authenticated, we present a confirmation dialog to ensure the action
    was intentional.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: If the user is not authenticated, we want to prompt the user to log in. To reduce
    the overload for this book, we will assume the user is already registered via
    a backend API, so we won't be asking the user to register.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: We need to implement the `promptLogin` method in `AuthService` to persist the
    user's login credentials, so every time they return to the app, it will automatically
    log them in. The record method now provides an extra optional argument `usernameAttempt`,
    which will be useful to repopulate the username field of the login prompt when
    reinitiating the login sequence after a user input validation error. We won't do
    a thorough validation of user input here, but we can at least do a lightweight
    check for a valid email.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: In your own app, you should probably do more user input validation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'To maintain a clean separation of concerns, open `app/modules/core/services/auth.service.ts`
    to implement `promptLogin`. Here''s the entire service with the modifications:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We use the `dialogService.login` method to open a native login dialog, allowing
    the user to input a username and password. Once they choose ok, we do minimal
    validation of the input and, if successful, proceed to persist the username and
    password via `DatabaseService`. Otherwise, we simply alert the user of an error
    and reject our promise, passing along the username that was entered. This allows
    us to help the user out by redisplaying the login dialog with the failed username
    they entered, so they can more easily make corrections.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: With these service level details complete, the `track-list` component is looking
    pretty good. However, there is one additional step we should take while we are
    working on this. If you recall, our TrackModel contains an order property that
    will help the user order the tracks in any way they'd like for convenience.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Angular Pipe - OrderBy
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular provides the Pipe decorator for ease in creating view filters. Let''s
    start by showing how we will use this in the view. You can see that it appears
    very similar to a command-line pipe used in Unix shell scripts; hence, it''s named:
    `Pipe`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will take the `playerService.tracks` collection and ensure it is ordered
    via the `order` property of each `TrackModel` for the view display.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we may want to use this anywhere in our app views, let''s add this pipe
    as part of `CoreModule`. Create `app/modules/core/pipes/order-by.pipe.ts` and
    here is how we will implement `OrderByPipe`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We won''t go into too much detail with what is going on here, since this is
    pretty typical in JavaScript to order a collection. To finish this off, ensure
    `app/modules/core/pipes/index.ts` follows our standard convention:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Lastly, import the preceding collection for use with `app/modules/core/core.module.ts`.
    Here is the full file with all the modifications:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since pipes are view level implementations, we ensure they are added as part
    of the `exports` collection to allow other modules to use them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we were to run our app at this point, you would notice that our `OrderBy`
    pipe used on our `track-list.component.html` view template would *NOT* work!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Angular modules compile in isolation of one another.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a critical point to understand: Angular compiles `PlayerModule` that
    declares `TrackListComponent`unto itself in an isolated sense. Since we declared `OrderByPipe`
    as part of `CoreModule` and `PlayerModule` has no dependency (at the moment) on
    `CoreModule`, the `TrackListComponent` gets compiled with no awareness of `OrderByPipe`!
    You would end up seeing this error generated in the console:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To remedy this, we want to make sure `PlayerModule` is aware of view-related declarations
    (such as pipes or other components) from `CoreModule` by ensuring `CoreModule`
    is added as part of the `imports` collection on `PlayerModule`. This also provides
    us with one additional convenience. If you notice, `CoreModule` specifies `NativeScriptModule`
    as an export, which means any module that imports `CoreModule` will inherently
    get `NativeScriptModule` along with it. Here are the final modifications to `PlayerModule`
    to allow everything to work together:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can now move on to the `player-controls` component.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Building PlayerControls component
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our player controls should contain a play/pause toggle button for the entire
    mix. It should also present a slider control to allow us to skip ahead and rewind our
    playback.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create `app/modules/player/components/player-controls/player-controls.component.html`(with
    a matching `.ts`):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We start with a single row `GridLayout` with an explicit 100 height. Then, the
    first column will be constrained to 75 wide to accommodate our play/pause toggle
    button. Then, the second column will take up the rest of the horizontal space,
    indicated with `*` with the `Slider` component. This component is provided by
    the NativeScript framework and allows us to bind the `maxValue` attribute to the
    total duration of our mix as well as a value to `currentTime` of the playback.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, for `player-controls.component.ts`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For now, we have placed `currentTime` and `duration` directly on the component,
    however, we will refactor those into  `PlayerService` later. Eventually, all of
    the state related to our player will come from `PlayerService` when we implement
    plugins to handle our audio in subsequent chapters. The `togglePlay` method also
    just stubs out some general behavior, toggling the text of our button to Play
    or Stop.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Quick preview
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we will take a quick look at what we have built so far. Currently,
    our player service returns an empty list of tracks. To see the results, we should
    add some dummy data to it. For example, in `PlayerService`, we could add:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Don't be surprised if it's not pretty; we'll cover that in the next chapter.
    We also won't cover all the runtime commands available to us yet; we'll cover
    that thoroughly in [Chapter 6](part0072.html#24L8G0-289fe2426d594f99a90e4363b2c9c34d), *Running
    the app on iOS and Android*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Preview  on iOS
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will have to be on a Mac with XCode installed to preview the iOS app:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This should launch the iOS Simulator and you should see the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00006.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: Preview on Android
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓预览
- en: 'You will have to have the AndroidSDKk and tools installed to preview on an
    Android emulator:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在安卓SDK和工具安装完毕后，才能在安卓模拟器上预览：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This should launch an Android emulator and you should see the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会启动一个安卓模拟器，你应该会看到以下截图：
- en: '![](img/00007.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00007.jpeg)'
- en: Congratulations! We have our first view.  Well hey, no one said it would be
    pretty yet!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们有了第一个视图。嘿，没人说过它现在就会很漂亮！
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have kicked off Part 2 with the component building, where we have laid out
    our root component `app.component.html` to house our primary view, where you learned
    about `GridLayout`, a very useful layout container.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开始构建第二部分，其中我们布置了根组件`app.component.html`以容纳我们的主要视图，在那里你学习了`GridLayout`，一个非常有用的布局容器。
- en: Angular's Component decorator allowed us to easily build `TrackListComponent`
    as well as `PlayerControlsComponent`.We also learned how to build an Angular `Pipe`
    to aid our view's ability to keep our track list in order. Angular's `NgModule` taught
    us we need to ensure any view-related declarations needed for any components are imported
    properly. This Angular design pattern helps maintain module isolation as standalone
    units of code that can be intermixed by importing modules into each other.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的组件装饰器使我们能够轻松构建`TrackListComponent`和`PlayerControlsComponent`。我们还学会了如何构建一个Angular
    `Pipe`来帮助我们的视图保持跟踪列表的顺序。Angular的`NgModule`教导我们，我们需要确保任何组件所需的任何与视图相关的声明都正确导入。这种Angular设计模式有助于保持模块隔离，作为可以相互导入模块的独立代码单元。
- en: We also enhanced a fair share of our services to support some of the usability
    we desire with our components.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还增强了一部分服务，以支持我们希望与组件一起使用的某些可用性。
- en: Finally, we were able to take a quick peek at what we were building. Even though
    it's not at all pretty at this point, we can see things coming together.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们终于能够快速瞥一眼我们所构建的内容。尽管目前看起来并不美观，但我们已经能看到事物正在逐渐融合。
- en: In [Chapter 4](part0059.html#1O8H60-289fe2426d594f99a90e4363b2c9c34d), *A prettier
    view with CSS*, you will learn how to use CSS to bring out the pretty from our
    views.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](part0059.html#1O8H60-289fe2426d594f99a90e4363b2c9c34d)《使用CSS美化视图》中，你将学习如何使用CSS来从我们的视图中提取美观。
