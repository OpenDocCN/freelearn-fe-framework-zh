- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Components and Props
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件和Props
- en: Learning Objectives
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下事情：
- en: Build reusable React components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建可重用的React组件
- en: Utilize a concept called **props** to make components configurable
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用名为**props**的概念来使组件可配置
- en: Build flexible user interfaces by combining components with props
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过组合组件和props构建灵活的用户界面
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In the previous chapter, you learned about the key building block of any React-based
    user interface: **components** . You learned why components matter, how they are
    used, and how you can build components yourself.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了任何基于React的用户界面的关键构建块：**组件**。你学习了组件的重要性、如何使用它们以及如何自己构建组件。
- en: You also learned about JSX, which is the HTML-like markup that’s typically returned
    by component functions. It’s this markup that defines what should be rendered
    on the final web page (in other words, which HTML markup should end up on the
    final web page that is being served to visitors).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了JSX，这是一种类似于HTML的标记，通常由组件函数返回。正是这种标记定义了最终网页上应该渲染的内容（换句话说，应该将哪个HTML标记放在最终提供给访客的网页上）。
- en: Can Components Do More?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件能做更多吗？
- en: However, so far, those components haven’t been too useful. While you could use
    them to split your web page content into smaller building blocks, the actual reusability
    of these components was pretty limited. For example, every course goal that you
    might have as part of an overall course goal list would go into its own component
    (if you decided to split your web page content into multiple components in the
    first place).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，到目前为止，这些组件并没有太多用处。虽然你可以使用它们将网页内容分割成更小的构建块，但这些组件的实际可重用性相当有限。例如，作为整体课程目标列表的一部分，你可能有的每个课程目标都会进入其自己的组件（如果你最初决定将网页内容分割成多个组件）。
- en: If you think about it, this isn’t too helpful; it would be much better if different
    list items could share one common component and you just configured that one component
    with different content or attributes—just like how HTML works.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这么想，这并不太有帮助；如果不同的列表项可以共享一个共同的组件，而你只需用不同的内容或属性来配置这个组件——就像HTML那样，那就更好了。
- en: 'When writing plain HTML code and describing content with it, you use reusable
    HTML elements and configure them with different content or attributes. For example,
    you have one `<a>` HTML element, but thanks to the `href` attribute and the element
    child content, you can build an endless amount of different anchor elements that
    point at different resources, as shown in the following snippet:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写纯HTML代码并使用它来描述内容时，你使用可重用的HTML元素，并通过不同的内容或属性来配置它们。例如，你有一个`<a>` HTML元素，但由于`href`属性和元素子内容，你可以构建无限数量的不同锚点元素，它们指向不同的资源，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These two elements use the exact same HTML element ( `<a>` ) but lead to totally
    different links that would end up on the web page (pointing to two totally different
    websites).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个元素使用完全相同的HTML元素（`<a>`），但会导致网页上完全不同的链接，最终指向两个完全不同的网站。
- en: To fully unlock the potential of React components, it would, therefore, be very
    useful if you could configure them just like regular HTML elements. And it turns
    out that you can do exactly that—with another key React concept called **props**
    .
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全释放React组件的潜力，如果你能够像常规HTML元素一样配置它们，那将非常有用。实际上，你可以通过另一个关键的React概念**props**来实现这一点。
- en: Using Props in Components
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在组件中使用Props
- en: How do you use props in your components? And when do you need them?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何在组件中使用props？你何时需要它们？
- en: The second question will be answered in greater detail a little bit later. For
    the moment, it’s enough to know that you typically will have some components that
    are reusable and, therefore, need props and some components that are unique and
    might not need props.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题将在稍后更详细地回答。目前，只需知道你通常会有一些可重用的组件，因此需要props，以及一些独特的组件，可能不需要props。
- en: 'The “how” part of the question is the more important part at this point, and
    this part can be split into two complementary problems:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，问题的“如何”部分更为重要，这部分可以分解为两个互补的问题：
- en: Passing props to components
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Props传递给组件
- en: Consuming props in a component
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件中消费Props
- en: Passing Props to Components
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Props传递给组件
- en: How would you want props and component configurability to work if you were to
    design React from the ground up?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要从头设计React，你希望props和组件的可配置性如何工作？
- en: 'Of course, there would be a broad variety of possible solutions, but there
    is one great role model that can be considered: HTML. As mentioned above, when
    working with HTML, you pass content and configuration either between element tags
    or via attributes.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可能会有各种各样的可能解决方案，但有一个伟大的榜样可以考虑：HTML。如上所述，当使用HTML时，你可以在元素标签之间或通过属性传递内容和管理配置。
- en: 'Fortunately, React components work just like HTML elements when it comes to
    configuring them. Props are simply passed as attributes (to your component) or
    as child data between component tags, and you can also mix both approaches:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，当配置组件时，React组件的工作方式与HTML元素类似。Props作为属性（传递给你的组件）或作为组件标签之间的子数据传递，你还可以混合这两种方法：
- en: '`<Product id="abc1" price="12.99" />`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Product id="abc1" price="12.99" />`'
- en: '`<FancyLink target="https://some-website.com">Click me</FancyLink>`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<FancyLink target="https://some-website.com">点击我</FancyLink>`'
- en: For this reason, configuring components is quite straightforward—at least, if
    you look at them from the consumer’s angle (in other words, at how you use them
    in JSX).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，配置组件相当直接——至少，如果你从消费者的角度看待它们（换句话说，在JSX中使用它们的角度）的话。
- en: Consuming Props in a Component
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在组件中消费属性
- en: How can you get access to the prop values passed into a component, when writing
    that component’s inner code?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写组件的内部代码时，如何获取传递给组件的prop值？
- en: Imagine you’re building a `GoalItem` component that is responsible for outputting
    a single goal item (for example, a course goal or project goal) that will be part
    of an overall goals list.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在构建一个`GoalItem`组件，该组件负责输出单个目标项（例如，课程目标或项目目标），这将作为整体目标列表的一部分。
- en: 'The parent component JSX markup could look like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 父组件JSX标记可能看起来像这样：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Inside `GoalItem` , the goal (no pun intended) would be to accept different
    goal titles so that the same component ( `GoalItem` ) can be used to output these
    different titles as part of the final list that’s displayed to website visitors.
    Maybe the component should also accept another piece of data (for example, a unique
    ID that is used internally).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GoalItem`中，目标（无意中开玩笑）是接受不同的目标标题，以便相同的组件（`GoalItem`）可以用来输出这些不同的标题，作为显示给网站访客的最终列表的一部分。也许该组件还应接受其他一些数据（例如，用于内部的一个唯一ID）。
- en: 'That’s how the `GoalItem` component could be used in JSX, as shown in the following
    example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如以下示例所示，这就是`GoalItem`组件在JSX中的使用方式：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Inside the `GoalItem` component function, the plan would probably be to output
    dynamic content (in other words, the data received via props) like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GoalItem`组件函数内部，计划可能是输出动态内容（换句话说，通过属性接收到的数据），如下所示：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But this component function would not work. It has a problem: `title` and `id`
    are never defined inside that component function. This code would, therefore,
    cause an error because you’re using a variable that wasn’t defined.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个组件函数不会工作。它有一个问题：`title`和`id`在该组件函数内部从未被定义。因此，这段代码会导致错误，因为你正在使用一个未定义的变量。
- en: Of course, these shouldn’t be defined inside the `GoalItem` component anyway,
    as the idea was to make the `GoalItem` component reusable and receive different
    `title` and `id` values *from outside the component* (i.e., from the component
    that renders the list of `<GoalItem>` components).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些属性不应该在`GoalItem`组件内部定义，因为初衷是使`GoalItem`组件可重用，并从组件外部（即渲染`<GoalItem>`组件列表的组件）接收不同的`title`和`id`值
    *（即未在组件内部定义的变量）*。
- en: 'React provides a solution for this problem: a special parameter value that
    is passed into every component function automatically by React. This is a special
    parameter that contains the extra configuration data that is set on the component
    in JSX code, called the `props` parameter.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: React为这个问题提供了一个解决方案：一个特殊的参数值，React自动将其传递给每个组件函数。这是一个特殊的参数，它包含在JSX代码中设置在组件上的额外配置数据，称为`props`参数。
- en: 'The preceding component function could (and should) be rewritten like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上述组件函数可以（并且应该）重写如下：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The name of the parameter ( `props` ) is up to you, but using `props` as a name
    is a convention because the overall concept is called **props** .
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 参数名称（`props`）由你决定，但使用`props`作为名称是一种约定，因为整体概念被称为**props**。
- en: To understand this concept, it is important to keep in mind that these component
    functions are not called by you somewhere else in your code and that, instead,
    React will call these functions on your behalf. And since React calls these functions,
    it can pass extra arguments into them when calling them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这个概念，重要的是要记住，这些组件函数不是你在代码的其他地方调用的，相反，React会代表你调用这些函数。由于React调用这些函数，它可以在调用它们时向它们传递额外的参数。
- en: This `props` argument is indeed such an extra argument. React will pass it into
    every component function, irrespective of whether you defined it as an extra parameter
    in the component function definition. However, if you didn’t define that `props`
    parameter in a component function, you, of course, won’t be able to work with
    the `props` data in that component.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`props`参数确实是一个额外的参数。React会将其传递到每个组件函数中，无论你是否在组件函数定义中将它定义为额外的参数。然而，如果你没有在组件函数中定义那个`props`参数，你当然无法在那个组件中处理`props`数据。
- en: This automatically provided `props` argument will always contain an object (because
    React passes an object as a value for this argument), and the properties of this
    object will be the “attributes” you added to your component (such as the `title`
    or `id` ) inside the JSX code where the component is used.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自动提供的`props`参数将始终包含一个对象（因为React将对象作为此参数的值传递），而这个对象的属性将是你在JSX代码中添加到组件的“属性”（例如`title`或`id`）。
- en: That’s why in this `GoalItem` component example, custom data can be passed via
    attributes ( `<GoalItem id="g1" … />` ) and consumed via the `props` object and
    its properties ( `<li>{props.title}</li>` ).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，在这个`GoalItem`组件示例中，可以通过属性（`<GoalItem id="g1" … />`）传递自定义数据，并通过`props`对象及其属性（`<li>{props.title}</li>`）来消费这些数据。
- en: Components, Props, and Reusability
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件、Props和可复用性
- en: Thanks to this props concept, components become *actually* reusable, instead
    of just being *theoretically* reusable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这个props概念，组件实际上变得可复用，而不仅仅是理论上可复用。
- en: Outputting three `<GoalItem>` components without any extra configuration could
    only render the same goal three times, since the goal text (and any other data
    you might need) would have to be hardcoded into the component function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不进行任何额外配置地输出三个`<GoalItem>`组件，只能渲染相同的目标三次，因为目标文本（以及你可能需要的任何其他数据）必须硬编码到组件函数中。
- en: By using props as described above, the same component can be used multiple times
    with different configurations. That allows you to define some general markup structure
    and logic once (in the component function) but then use it as often as needed
    with different configurations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过如上所述使用props，相同的组件可以多次使用，具有不同的配置。这允许你一次性（在组件函数中）定义一些通用的标记结构和逻辑，然后根据需要以不同的配置多次使用。
- en: And if that sounds familiar, that is indeed exactly the same idea that applies
    to regular JavaScript (or any other programming language) functions. You define
    logic once, and you can then call it multiple times with different inputs to receive
    different results. It’s the same for components—at least when embracing this props
    concept.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来很熟悉，那确实正是适用于常规JavaScript（或任何其他编程语言）函数的相同想法。你定义逻辑一次，然后可以多次调用它，以不同的输入接收不同的结果。对于组件来说也是如此——至少当你接受这个props概念时。
- en: The Special “children” Prop
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊的“子组件”属性
- en: It was mentioned before that React passes this `props` object automatically
    into component functions. That is indeed the case, and as described, this object
    contains all the attributes you set on the component (in JSX) as properties.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到过，React会自动将这个`props`对象传递到组件函数中。这确实是事实，正如描述的那样，这个对象包含你在组件（在JSX中）上设置的属性的所有属性。
- en: 'But React does not just package your attributes into this object; it also adds
    another extra property to the `props` object: the special `children` property
    (a built-in property whose name is fixed, meaning you can’t change it).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但React不仅将你的属性打包到这个对象中；它还向`props`对象添加了另一个额外的属性：特殊的`children`属性（一个名称固定的内置属性，这意味着你不能更改它）。
- en: 'The `children` property holds a very important piece of data: the content you
    might have provided between the component’s opening and closing tags.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`children`属性包含一个非常重要的数据片段：你可能在组件的起始和结束标签之间提供的内容。'
- en: Thus far, in the examples shown above, the components were mostly self-closing.
    `<GoalItem id="…" title="…" />` holds no content between the component tags. All
    the data is passed into the component via attributes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在上述示例中，组件大多是自闭合的。`<GoalItem id="…" title="…" />`在组件标签之间没有内容。所有数据都是通过属性传递到组件中的。
- en: There is nothing wrong with this approach. You can configure your components
    with attributes only. But for some pieces of data and some components, it might
    make more sense and be more logical to actually stick to regular HTML conventions,
    passing that data between the component tags instead. And the `GoalItem` component
    is actually a great example.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法没有问题。你可以仅使用属性来配置你的组件。但对于某些数据和某些组件，坚持使用常规HTML约定，在组件标签之间传递这些数据可能更有意义，也更符合逻辑。`GoalItem`组件实际上是一个很好的例子。
- en: Which approach looks more intuitive?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种方法看起来更直观？
- en: '`<GoalItem id="g1" title="Learn React" />`'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<GoalItem id="g1" title="Learn React" />`'
- en: '`<GoalItem id="g1">Learn React</GoalItem>`'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<GoalItem id="g1">Learn React</GoalItem>`'
- en: 'You might determine that the second option looks a bit more intuitive and in
    line with regular HTML because, there, you would also configure a normal list
    item like this: `<li id="li1">Some list item</li>` .'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得第二个选项看起来更直观，并且与常规HTML保持一致，因为在那里，你也会像这样配置一个普通的列表项：`<li id="li1">Some list
    item</li>`。
- en: While you have no choice when working with regular HTML elements (you can’t
    add a `goal` attribute to a `<li>` just because you want to), you do have a choice
    when working with React and your own components. It simply depends on how you
    consume props inside the component function. Both approaches can work, depending
    on the internal component code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理常规HTML元素时（你不能仅仅因为想要添加一个`goal`属性到`<li>`标签），你与React和自己的组件一起工作时确实有选择权。这完全取决于你在组件函数内部如何消费props。两种方法都可以工作，具体取决于组件的内部代码。
- en: Still, you might want to pass certain pieces of data between component tags,
    and the special `children` property allows you to do just that. It contains any
    content you define between the component opening and closing tags. Therefore,
    in the case of example 2 (in the list above), `children` would contain the string
    `"Learn React"` .
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能仍然想要在组件标签之间传递某些数据片段，而特殊的`children`属性允许你做到这一点。它包含你在组件开始和结束标签之间定义的任何内容。因此，在上述列表中的示例2中，`children`将包含字符串`"Learn
    React"`。
- en: 'In your component function, you can work with the `children` value just as
    you work with any other prop value:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的组件函数中，你可以像处理任何其他prop值一样处理`children`值：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Which Components Need Props?
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哪些组件需要Props？
- en: 'It was mentioned before, but it is extremely important: **props are optional!**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 之前已经提到过，但这一点非常重要：**props是可选的！**
- en: React will always pass **prop** data into your components, but you don’t have
    to work with that `prop` parameter. You don’t even have to define it in your component
    function if you don’t plan on working with it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: React总是会将**prop**数据传递到你的组件中，但你不必处理那个`prop`参数。如果你不打算使用它，甚至不需要在你的组件函数中定义它。
- en: There is no hard rule that would define which components need **props** and
    which don’t. It comes with experience and simply depends on the role of a component.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 没有硬性规则可以定义哪些组件需要**props**，哪些不需要。这取决于经验，并且简单地取决于组件的角色。
- en: You might have a general `Header` component that displays a static header (with
    a logo, title, and so on), and such a component probably needs no external configuration
    (in other words, no “attributes” or other kinds of data passed into it). It could
    be self-contained, with all the required values hardcoded into the component.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能有一个通用的`Header`组件，用于显示静态标题（带有标志、标题等），这样的组件可能不需要外部配置（换句话说，没有“属性”或其他类型的数据传递给它）。它可以自包含，所有必需的值都硬编码到组件中。
- en: But you will also often build and use components like the `GoalItem` component
    (in other words, components that do need external data to be useful). Whenever
    a component is used more than once in your React app, there is a high chance that
    it will utilize props. However, the opposite is not necessarily true. While you
    will have one-time components that don’t use props, you will absolutely also have
    components that are only used once in the entire app and still take advantage
    of props. As previously mentioned, it depends on the exact use case and component.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但你也会经常构建和使用像`GoalItem`组件这样的组件（换句话说，需要外部数据才能有用的组件）。每当一个组件在你的React应用中被多次使用时，它很可能将利用属性。然而，反过来不一定成立。虽然你会有一次性的组件不使用属性，但你绝对也会有一些在整个应用中只使用一次但仍利用属性的组件。正如之前提到的，这取决于具体的使用案例和组件。
- en: Throughout this book, you will see plenty of examples and exercises that will
    help you gain a deeper understanding of how to build components and use props.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的整个过程中，你将看到许多示例和练习，这些将帮助你更深入地理解如何构建组件和使用属性。
- en: How to Deal with Multiple Props
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何处理多个属性
- en: As shown in the preceding examples, you are not limited to only one prop per
    component. Indeed, you can pass and use as many props as your component needs—no
    matter if that’s 1 or 100 (or more) props.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，你不仅限于每个组件只有一个属性。实际上，你可以传递和使用组件需要的任何数量的属性——无论是一、一百（或更多）属性。
- en: 'Once you do create components with more than just two or three props, a new
    question might come up: do you have to add all those props individually (in other
    words, as separate attributes), or can you pass fewer attributes that contain
    grouped data, such as arrays or objects?'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了具有两个或三个以上属性的组件，可能会出现一个新的问题：你是否必须逐个添加所有这些属性（换句话说，作为单独的属性），或者你可以传递包含分组数据（如数组或对象）的更少的属性？
- en: And indeed, you can. React allows you to pass arrays and objects as prop values
    as well. In fact, any valid JavaScript value can be passed as a prop value!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 确实如此。React 允许你将数组和对象作为属性值传递。事实上，任何有效的JavaScript值都可以作为属性值传递！
- en: 'This allows you to decide whether you want to have a component with 20 individual
    props (“attributes”) or just one “big” prop. Here’s an example of where the same
    component is configured in two different ways:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这让你可以决定你是否想要一个包含20个单独属性（“属性”）的组件，或者只是一个“大”属性。以下是一个示例，展示了同一个组件以两种不同的方式配置：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Of course, the component must also be adapted internally (in other words, in
    the component function) to expect either individual or grouped props. But since
    you’re the developer, that is, of course, your choice.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，组件也必须在内部（换句话说，在组件函数中）进行调整，以期望单个或分组属性。但既然你是开发者，当然，这是你的选择。
- en: Inside the component function, you can also make your life easier.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件函数内部，你还可以使自己的生活变得更简单。
- en: There is nothing wrong with accessing prop values via `props.XYZ` , but if you
    have a component that receives multiple props, repeating `props.XYZ` over and
    over again could become cumbersome and make the code a bit harder to read.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`props.XYZ`访问属性值没有问题，但如果你的组件接收多个属性，反复重复`props.XYZ`可能会变得繁琐，并使代码难以阅读。
- en: 'You can use a default JavaScript feature to improve readability: **object destructuring**
    .'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用默认的JavaScript功能来提高可读性：**对象解构**。
- en: 'Object destructuring allows you to extract values from an object and assign
    those values to variables or constants in a single step:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对象解构允许你从对象中提取值，并将这些值一次性分配给变量或常量：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can, therefore, use this syntax to extract all prop values and assign them
    to equally named variables directly at the start of your component function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以使用这种语法在组件函数的开始处直接提取所有属性值并将它们分配给同名的变量：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You don’t have to use this syntax, but it can make your life easier.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必使用这种语法，但它可以使你的生活变得更简单。
- en: '**Note**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: For more information on object destructuring, MDN is a great place to dive deeper.
    You can access this at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)
    .
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 关于对象解构的更多信息，MDN是一个深入了解的好地方。你可以在这里访问[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)。
- en: Spreading Props
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性展开
- en: Imagine you’re building a custom component that should act as a “wrapper” around
    some other component—a built-in component, perhaps.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在构建一个自定义组件，该组件应作为其他组件的“包装器”——可能是内置组件。
- en: 'For instance, you could be building a custom `Link` component that should return
    a standard `<a>` element with some custom styling or logic added:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以构建一个自定义的`Link`组件，该组件应返回一个带有一些自定义样式或逻辑的标准`<a>`元素：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This very simple example component returns a pre-configured `<a>` element. This
    custom `Link` component configures the anchor element such that new pages are
    always opened in a new tab. In place of the standard `<a>` element, you could
    use this `Link` component in your React app to get that behavior out of the box
    for all your links.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常简单的示例组件返回一个预配置的`<a>`元素。这个自定义的`Link`组件配置了锚元素，使得新页面总是在新标签页中打开。你可以用这个`Link`组件替换标准`<a>`元素，在你的React应用中为所有链接提供开箱即用的行为。
- en: 'But this custom component suffers from a problem: it’s a wrapper around a core
    element, but by creating your own component, you remove the configurability of
    that core element. If you were to use this `Link` component in your app, how would
    you set the `href` prop to configure the link destination?'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个自定义组件存在一个问题：它是核心元素的包装器，但通过创建自己的组件，你移除了核心元素的配置性。如果你要在你的应用中使用这个`Link`组件，你将如何设置`href`属性来配置链接目标？
- en: 'You might try the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试以下方法：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: However, this example code wouldn’t work because `Link` doesn’t accept or use
    a `href` prop.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个示例代码不会工作，因为`Link`不接受或使用`href`属性。
- en: 'Of course, you could adjust the `Link` component function such that a `href`
    prop is used:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以调整`Link`组件函数，使其使用`href`属性：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: But what if you also wanted to ensure that the `download` prop could be added
    if needed?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你还想确保在需要时可以添加`download`属性呢？
- en: Well, it’s true that you can always accept more and more props (and pass them
    on to the `<a>` element inside your component), but this reduces the reusability
    and maintainability of your custom component.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，确实你可以接受越来越多的属性（并将它们传递到组件内的`<a>`元素），但这会降低自定义组件的可重用性和可维护性。
- en: A better solution is to use the standard JavaScript **spread operator** (i.e.,
    the `...` operator) and React’s support for that operator when working with components.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是使用标准的JavaScript**展开操作符**（即`...`操作符）以及React对该操作符的支持，当与组件一起工作时。
- en: 'For example, the following component code is valid:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下组件代码是有效的：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, `config` is expected to be a JavaScript object (i.e., a collection
    of key-value pairs). The spread operator ( `...` ), when used in JSX code on a
    JSX element, converts that object into multiple props.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`config`预期是一个JavaScript对象（即一组键值对）。当在JSX代码中的JSX元素上使用展开操作符（`...`）时，它会将该对象转换为多个属性。
- en: 'Consider this example `config` value:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个`config`值的例子：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this case, when spreading it on `<a>` , (i.e., `<a {…config}>` ), the result
    would be the same as if you had written this code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当在`<a>`上展开时（即`<a {...config}>`），结果将与以下代码相同：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'An alternative, more common pattern uses yet another JavaScript feature: the
    **rest property** . That’s a JavaScript pattern that allows you to group properties
    that have not been destructured into a new object (which then only contains those
    properties).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种更常见的模式使用了另一个JavaScript特性：**剩余属性**。这是一个JavaScript模式，允许你将未解构的属性组合到一个新对象中（该对象只包含那些属性）。
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this example, when destructuring props, only the `children` prop is destructured;
    the other ones are stored in a new object named `props` . The syntax is very similar
    to the spread operator syntax: you use three dots ( `...` ). But here, you use
    the operator in front of the property that should contain all remaining properties.
    Therefore, it’s the place where you use that operator that defines what it does.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当解构属性时，只有`children`属性被解构；其他属性存储在一个名为`props`的新对象中。语法与展开操作符语法非常相似：你使用三个点（`...`）。但在这里，你使用操作符在应包含所有剩余属性的前面。因此，这就是你使用该操作符的地方，它定义了它所做的事情。
- en: You can then use that rest property ( `props` in the example) like any other
    object. In the example above, it’s again used to spread its properties as props
    onto the `<a>` element.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用那个剩余属性（例如示例中的`props`）就像使用任何其他对象一样。在上面的例子中，它再次被用来将属性作为属性展开到`<a>`元素上。
- en: 'Using this pattern allows you to use the `Link` component in a more natural
    way, where you don’t have to create and use a separate configuration object:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式可以使您更自然地使用`Link`组件，您不需要创建和使用单独的配置对象：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These behaviors and patterns can be used to build reusable components that should
    still maintain the configurability of the core element they may be wrapping. This
    helps you avoid long lists of pre-defined, accepted props and improves the reusability
    of components.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行为和模式可以用来构建可重用的组件，同时仍然保持它们可能包装的核心元素的可配置性。这有助于您避免长列表的预定义、接受的props，并提高组件的可重用性。
- en: Prop Chains/Prop Drilling
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Prop Chains/Prop Drilling
- en: 'There is one last phenomenon that is worth noting when learning about props:
    **prop drilling** or **prop chains** .'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习关于props时，还有一个值得注意的最后现象：**prop drilling**或**prop chains**。
- en: It’s a problem every React developer will encounter at some point. It occurs
    when you build a slightly more complex React app that contains multiple layers
    of nested components that need to send data to each other.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是每个React开发者迟早会遇到的问题。当您构建一个稍微复杂一些的React应用程序，其中包含多层嵌套组件，这些组件需要相互发送数据时，就会发生这种情况。
- en: For example, assume that you have a `NavItem` component that should output a
    navigation link. Inside that component, you might have another nested component,
    `AnimatedLink` , that outputs the actual link (maybe with some nice animation
    styling).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您有一个`NavItem`组件，它应该输出一个导航链接。在这个组件内部，您可能还有一个嵌套组件`AnimatedLink`，它输出实际的链接（可能带有一些漂亮的动画样式）。
- en: 'The `NavItem` component could look like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavItem`组件可能看起来像这样：'
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And `AnimatedLink` could be defined like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnimatedLink`可以这样定义：'
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, the `target` prop is passed through the `NavItem` component
    to the `AnimatedLink` component. The `NavItem` component must accept the `target`
    prop because it must be passed on to `AnimatedLink` .
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`target` prop通过`NavItem`组件传递到`AnimatedLink`组件。`NavItem`组件必须接受`target`
    prop，因为它必须传递给`AnimatedLink`。
- en: 'That’s what prop drilling/prop chains is all about: you forward a prop from
    a component that doesn’t really need it to another component that *does* need
    it.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是prop drilling/prop chains的实质：您从一个实际上并不需要它的组件中转发一个prop到另一个确实需要它的组件。
- en: Having some prop drilling in your app isn’t necessarily bad, and you can definitely
    accept it. But, if you should end up with longer chains of props (in other words,
    multiple **pass-through components** ), you can use a solution that will be discussed
    in *Chapter 11* , *Working with Complex States* .
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中存在一些prop drilling并不一定不好，您当然可以接受它。但是，如果您最终得到更长的props链（换句话说，多个**传递组件**），您可以使用将在*第11章*，*处理复杂状态*中讨论的解决方案。
- en: Summary and Key Takeaways
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要和关键要点
- en: Props are a key React concept that make components configurable and, therefore,
    reusable.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Props是React的一个关键概念，它使组件可配置，因此可重用。
- en: Props are automatically collected and passed into component functions by React.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React会自动收集并传递props到组件函数中。
- en: You decide (on a per-component basis) whether you want to use the props data
    (an object) or not.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您决定（针对每个组件）是否想要使用props数据（一个对象）。
- en: Props are passed into components like attributes or, via the special `children`
    prop, between the opening and closing tags.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Props像属性一样传递到组件中，或者通过特殊的`children` prop在开标签和闭标签之间传递。
- en: You can use JavaScript features like destructuring, the rest property, or the
    spread operator to write concise, flexible code.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用JavaScript功能，如解构、剩余属性或扩展运算符来编写简洁、灵活的代码。
- en: Since you are writing the code, it’s up to you how you want to pass data via
    props. Between the tags or as attributes? A single grouped attribute or many single-value
    attributes? It’s up to you.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于您正在编写代码，所以您决定如何通过props传递数据。是在标签之间还是作为属性？是一个分组属性还是多个单值属性？这取决于您。
- en: What’s Next?
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: Props allow you to make components configurable and reusable. Still, they are
    rather static. Data and, therefore, the UI output doesn’t change. You can’t react
    to user events like button clicks.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Props允许您使组件可配置和可重用。尽管如此，它们相对静态。数据和因此UI输出不会改变。您无法对用户事件（如按钮点击）做出反应。
- en: But the true power of React only becomes visible once you do add events (and
    reactions to them).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 但React的真正力量只有在您添加事件（以及对其的反应）之后才会显现出来。
- en: In the next chapter, you will learn how you can add event listeners when working
    with React, and you will learn how you can react (no pun intended) to events and
    change the (invisible and visible) state of your application.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何在处理React时添加事件监听器，以及你将学习如何对事件做出反应（无意中开玩笑），并改变应用程序的（不可见和可见）状态。
- en: Test Your Knowledge!
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试你的知识！
- en: 'Test your knowledge regarding the concepts covered in this chapter by answering
    the following questions. You can then compare your answers to the example answers
    that can be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/03-components-props/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/03-components-props/exercises/questions-answers.md)
    :'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试你对本章涵盖的概念的了解。然后，你可以将你的答案与在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/03-components-props/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/03-components-props/exercises/questions-answers.md)上可以找到的示例答案进行比较：
- en: Which “problem” do props solve?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性解决了哪些“问题”？
- en: How are props passed into components?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性是如何传递到组件中的？
- en: How are props consumed inside of a component function?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性是如何在组件函数内部消费的？
- en: Which options exist for passing (multiple) props into components?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪些选项可以用于将（多个）属性传递到组件中？
- en: Apply What You Learned
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用你所学的知识
- en: With this and the previous chapters, you now have enough basic knowledge to
    build truly reusable components.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章和上一章，你现在已经有了足够的基础知识来构建真正可重用的组件。
- en: Below, you will find an activity that allows you to apply all the knowledge,
    including the new props knowledge, you have acquired so far.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下面，你将找到一个活动，它允许你应用到目前为止所获得的所有知识，包括新的属性知识。
- en: 'Activity 3.1: Creating an App to Output Your Goals for This Book'
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动三.1：创建一个应用来输出本书的目标
- en: 'This activity builds upon *Activity 2.2* , *Creating a React App to Log Your
    Goals for This Book* , from the previous chapter. If you followed along there,
    you can use your existing code and enhance it by adding props. Alternatively,
    you can also use the solution provided as a starting point that is accessible
    at the following link: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-2](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-2)
    .'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动基于上一章的*活动2.2*，*创建一个React应用来记录本书的目标*，并在此基础上进行。如果你跟随了那里的内容，你可以使用你现有的代码，并通过添加属性来增强它。或者，你也可以使用以下链接中可访问的解决方案作为起点：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-2](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/02-components-jsx/activities/practice-2)。
- en: The aim of this activity is to build reusable `GoalItem` components that can
    be configured via props. Every `GoalItem` component should receive and output
    a goal title and a short description text, with extra information about the goal.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的目的是构建可配置的`GoalItem`组件，这些组件可以通过属性进行配置。每个`GoalItem`组件都应该接收并输出一个目标标题和简短描述文本，以及关于目标的其他信息。
- en: 'The steps are as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: Complete the second activity from the previous chapter.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成上一章的第二项活动。
- en: Replace the hardcoded goal item components with a new configurable component.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用一个新的可配置组件替换硬编码的目标组件。
- en: Output multiple goal components with different titles (via props).
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过属性输出具有不同标题的多个目标组件。
- en: Set the detailed text description for every goal between the goal component’s
    opening and closing tags.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标组件的打开和关闭标签之间设置每个目标的详细文本描述。
- en: 'The final user interface might look like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的用户界面可能看起来像这样：
- en: '![img](img/B31339_03_01.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_03_01.png)'
- en: 'Figure 3.1: The final result: multiple goals output below each other'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：最终结果：每个目标输出在下方
- en: '**Note**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'You can find a full example solution here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/03-components-props/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/03-components-props/activities/practice-1)
    .'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中找到完整的示例解决方案：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/03-components-props/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/03-components-props/activities/practice-1)。
