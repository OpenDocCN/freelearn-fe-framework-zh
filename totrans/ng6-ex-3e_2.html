<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building Our First App – 7 Minute Workout</h1>
                
            
            <article>
                
<p class="calibre3">I hope that the first chapter was intriguing enough and that you want to learn more about Angular—believe me, we have just scratched the surface! The framework has a lot to offer, and together with TypeScript, it strives to make frontend development more organized and hence manageable.</p>
<p class="calibre3">Keeping up with the theme of this book, we will be building a new app in Angular, and in the process, become more familiar with the framework. This app will also help us explore some new capabilities of Angular.</p>
<p class="calibre3">The topics that we will cover in this chapter include the following:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">7 Minute Workout problem description</strong>: We detail the functionality of the app that we build in this chapter.</li>
<li class="calibre12"><strong class="calibre1">Code organization</strong>: For our first real app, we will try to explain how to organize code, specifically Angular code.</li>
<li class="calibre12"><strong class="calibre1">Designing the model</strong>: One of the building blocks of our app is its model. We design the app model based on the app's requirements.</li>
<li class="calibre12"><strong class="calibre1">Understanding the data binding infrastructure</strong>: While building the <em class="calibre2">7 Minute Workout</em> view, we will look at the data binding capabilities of the framework, which include <em class="calibre2">property</em>, <em class="calibre2">attribute</em>, <em class="calibre2">class</em>, <em class="calibre2">style</em>, and <em class="calibre2">event</em> bindings.</li>
<li class="calibre12"><strong class="calibre1">Exploring the Angular platform directives</strong>: Some of the directives that we will cover are <kbd class="calibre13">ngFor</kbd>, <kbd class="calibre13">ngIf</kbd>, <kbd class="calibre13">ngClass</kbd>, <kbd class="calibre13">ngStyle</kbd>, and <kbd class="calibre13">ngSwitch</kbd>.</li>
</ul>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Cross-component communication with input properties</strong>: As we build nested components, we learn how input properties can be used to pass data from the parent to its child components.</li>
<li class="calibre12"><strong class="calibre1">Cross-component communication with events</strong>: Angular components can subscribe to and raise events. We get introduced to event binding support in Angular.</li>
<li class="calibre12"><strong class="calibre1">Angular pipes</strong>: Angular pipes provide a mechanism to format view content. We explore some standard Angular pipes and build our own pipe to support conversions from seconds to hh:mm:ss.</li>
</ul>
<p class="calibre3">Let's get started! The first thing we will do is to define our <em class="calibre17">7 Minute Workout</em> app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What is 7 Minute Workout?</h1>
                
            
            <article>
                
<p class="calibre3">We want everyone reading this book to be physically fit. Therefore, this book should serve a dual purpose; it should not only stimulate your grey matter, but also urge you to look after your physical fitness. What better way to do it than to build an app that targets physical fitness!</p>
<p class="calibre3"><em class="calibre17">7 Minute Workout</em> is an exercise/workout app that requires us to perform a set of 12 exercises in quick succession within the seven-minute time span. <em class="calibre17">7 Minute Workout</em> has become quite popular due to its bite-sized length and great benefits. We cannot confirm or refute the claims, but doing any form of strenuous physical activity is better than doing nothing at all. If you are interested to know more about the workout, then check out <span class="calibre6"><a href="http://well.blogs.nytimes.com/2013/05/09/the-scientific-7-minute-workout/" class="calibre10">http://well.blogs.nytimes.com/2013/05/09/the-scientific-7-minute-workout/</a></span>.</p>
<p class="calibre3">The technicalities of the app include performing a set of 12 exercises, dedicating 30 seconds for each of the exercises. This is followed by a brief rest period before starting the next exercise. For the app that we are building, we will be taking rest periods of 10 seconds each. So, the total duration comes out at a little more than seven minutes.</p>
<p class="calibre3">At the end of the chapter, we will have the <em class="calibre17">7 Minute Workout</em> app ready, which will look something like the following:</p>
<div class="packt_figure"><img class="calibre28" src="../images/00011.jpeg"/></div>
<div class="packt_figref">The 7 Minute Workout app</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Downloading the code base</h1>
                
            
            <article>
                
<p class="calibre3">The code for this app can be downloaded from the GitHub site (<span class="calibre6"><a href="https://github.com/chandermani/angular6byexample" class="calibre10">https://github.com/chandermani/angular6byexample</a>)</span> dedicated to this book. Since we are building the app incrementally, we have created <strong class="calibre5">multiple checkpoints</strong> that map to <strong class="calibre5">GitHub branches</strong> such as <kbd class="calibre13">checkpoint2.1</kbd>, <kbd class="calibre13">checkpoint2.2</kbd>, and so on. During the narration, we will highlight the branch for reference. These branches will contain the work done on the app up until that point in time.</p>
<div class="packt_infobox"><br class="calibre27"/>
The <em class="calibre31">7 Minute Workout</em> code is available in the repository folder named <kbd class="calibre24">trainer</kbd>.</div>
<p class="calibre3">So, let's get started!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting up the build</h1>
                
            
            <article>
                
<p class="calibre3">Remember that we are building on a modern platform for which browsers still lack support. Therefore, directly referencing script files in HTML is out of the question (while common, it's a dated approach that we should avoid anyway). Browsers do not understand <strong class="calibre5">TypeScript</strong>; this implies that there has to be a process that converts code written in TypeScript into standard <strong class="calibre5">JavaScript (ES5)</strong>. Hence, having a build set up for any Angular app becomes imperative. And thanks to the growing popularity of Angular, we are never short of options.</p>
<p class="calibre3">If you are a frontend developer working on the web stack, you cannot avoid <strong class="calibre5">Node.js</strong>. This is the most widely used platform for web/JavaScript development. So, no prizes for guessing that most of the Angular build solutions out there are supported by Node. Packages such as <strong class="calibre5">Grunt</strong>, <strong class="calibre5">Gulp</strong>, <strong class="calibre5">JSPM</strong>, and <strong class="calibre5">webpack</strong> are the most common building blocks for any build system.</p>
<div class="packt_infobox"><br class="calibre27"/>
Since we too are building on the Node.js platform, install Node.js before starting.</div>
<p class="calibre3">For this book and this sample app, we endorse <strong class="calibre5">Angular CLI</strong> (<a href="http://bit.ly/ng6be-angular-cli" class="calibre10">http://bit.ly/ng6be-angular-cli</a>). A command line tool, it has a build system and a scaffolding tool that hugely simplifies Angular's development workflow. It is popular, easy to set up, easy to manage, and supports almost everything that a modern build system should have. More about it later.</p>
<p class="calibre3">As with any mature framework, Angular CLI is not the only option out there on the web. Some of the notable starter sites plus build setups created by the community are as follows:</p>
<table border="1" class="calibre32">
<tbody class="calibre33">
<tr class="calibre34">
<td class="calibre35"><strong class="calibre1">Start site</strong></td>
<td class="calibre35"><strong class="calibre1">Location</strong></td>
</tr>
<tr class="calibre34">
<td class="calibre35"><kbd class="calibre13">angular2-webpack-starter</kbd></td>
<td class="calibre35"><span><a href="http://bit.ly/ng2webpack" class="calibre10">http://bit.ly/ng2webpack</a></span></td>
</tr>
<tr class="calibre34">
<td class="calibre35"><kbd class="calibre13">angular-seed</kbd></td>
<td class="calibre35"><a href="https://github.com/mgechev/angular-seed" class="calibre10">https://github.com/mgechev/angular-seed</a></td>
</tr>
</tbody>
</table>
<p class="calibre3"> </p>
<p class="calibre3">Let's start with installing Angular CLI. On the command line, type the following:</p>
<pre class="calibre19"><strong class="calibre1">npm i -g @angular/cli</strong></pre>
<p class="calibre3">Once installed, Angular CLI adds a new command <kbd class="calibre13">ng</kbd> to our execution environment. To create a new Angular project from the command line, run the following command:</p>
<pre class="calibre19"><strong class="calibre1">ng new PROJECT-NAME</strong></pre>
<p class="calibre3">This generates a folder structure with a bunch of files, a boilerplate Angular application, and a preconfigured build system. To run the application from the command line, execute the following:</p>
<pre class="calibre19"><strong class="calibre1">ng serve --open</strong></pre>
<p class="calibre3">And you can see a basic Angular application in action!</p>
<p class="calibre3">For our <em class="calibre17">7 Minute Workout</em> app, instead of starting from scratch, we are going to start from a version that is based on the project structure generated by <kbd class="calibre13">ng new</kbd> with minor modification. Start with the following steps:</p>
<div class="packt_tip">Curious about what the default project includes? Go ahead and run <kbd class="calibre24">ng new PROJECT-NAME</kbd>. Look at the generated content structure and the Angular CLI documentation to get an idea of what's part of a default setup.</div>
<ol class="calibre14">
<li value="1" class="calibre12">Download the base version of this app from <a href="http://bit.ly/ngbe-base" class="calibre10"><span>http://bit.ly/ngbe-base</span></a> and unzip it to a location on your machine. If you are familiar with how Git works, you can just clone the repository and check out the<kbd class="calibre13">base</kbd> branch:</li>
</ol>
<pre class="calibre18"><strong class="calibre1">git checkout base</strong></pre>
<p class="calibre36">This code serves as the starting point for our app.</p>
<ol start="2" class="calibre14">
<li value="2" class="calibre12">Navigate to the <kbd class="calibre13">trainer</kbd> folder from the command line and execute the command <kbd class="calibre13">npm install</kbd> from the command line to install the <strong class="calibre1">package dependencies</strong> for our application.</li>
</ol>
<div class="packt_infobox1"><strong class="calibre26"><br class="calibre27"/>
Packages</strong> in the Node.js world are third-party libraries (such as Angular for our app) that are either used by the app or support the app's building process. <strong class="calibre26">npm</strong> is a command-line tool for pulling these packages from a remote repository.</div>
<ol start="3" class="calibre14">
<li value="3" class="calibre12">Once npm pulls the app dependencies from the npm store, we are ready to build and run the application. From the command line, enter the following command:</li>
</ol>
<pre class="calibre19">    <strong class="calibre1">ng serve --open</strong></pre>
<p class="calibre36">This compiles and runs the app. If the build process goes fine, the default browser window/tab will open with a rudimentary app page (<kbd class="calibre13">http://localhost:4200/</kbd>). We are all set to begin developing our app in Angular!</p>
<p class="calibre3">But before we do that, it would be interesting to know a bit more about Angular CLI and the customization that we have done on the default project template that Angular CLI generates.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Angular CLI</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Angular CLI</strong> was created with the aim of standardizing and simplifying the development and deployment workflow for Angular apps. As the documentation suggests:</p>
<div class="packt_quote">"The Angular CLI makes it easy to create an application that already works, right out of the box. It already follows our best practices!"</div>
<p class="calibre3">It incorporates:</p>
<ul class="calibre11">
<li class="calibre12">A build system based on <strong class="calibre1">webpack</strong></li>
<li class="calibre12">A <strong class="calibre1">scaffolding tool</strong> to generate all standard Angular artifacts including modules, directives, components, and pipes</li>
<li class="calibre12">Adherence to <strong class="calibre1">Angular style guide</strong> (<a href="http://bit.ly/ngbe-styleguide" class="calibre10">http://bit.ly/ngbe-styleguide</a>), making sure we use community-driven standards for projects of every shape and size</li>
</ul>
<div class="packt_infobox">You may have never heard the term style guide, or may not understand its significance. A style guide in any technology is a set of guidelines that help us organize and write code that is easy to develop, maintain, and extend. To understand and appreciate Angular's own style guide, some familiarity with the framework itself is desirable, and we have started that journey.</div>
<ul class="calibre11">
<li class="calibre12">A targeted <strong class="calibre1">linter;</strong> Angular CLI integrates with <strong class="calibre1">codelyzer</strong> (<a href="http://bit.ly/ngbe-codelyzer" class="calibre10">http://bit.ly/ngbe-codelyzer</a>), a <strong class="calibre1">static code analysis tool</strong> that validates our Angular code against a set of rules to make sure that the code we write adheres to standards laid down in the Angular style guide</li>
<li class="calibre12">Preconfigured <strong class="calibre1">unit</strong> and <strong class="calibre1">end-to-end</strong> (<strong class="calibre1">e2e</strong>) test framework</li>
</ul>
<p class="calibre3">And much more!</p>
<p class="calibre3">Imagine if we had to do all this manually! The steep learning curve would have quickly overwhelm us. Thankfully, we don't have to deal with it, Angular CLI does it for us.</p>
<div class="packt_infobox">The Angular CLI build setup is based on webpack, but it does not expose the underlying webpack configuration; this is intentional. The Angular team wanted to shield developers from the complexities and internal workings of webpack. The ultimate aim of Angular CLI is to eliminate any entry level barriers and make setting up and running Angular code simple.<br class="calibre27"/>
It doesn't mean Angular CLI is not configurable. There is a <em class="calibre31">config file</em> (<kbd class="calibre24">angular.json</kbd>) that we can use to alter the build setup. We will not cover that here. Check the configuration file for 7 Minute Workout and read the documentation here: <a href="http://bit.ly/ng6be-angular-cli-config" class="calibre21">http://bit.ly/ng6be-angular-cli-config</a>.</div>
<p class="calibre3">The tweaks that we have done to the default generated project template are:</p>
<ul class="calibre11">
<li class="calibre12">Referenced Bootstrap CSS in the <kbd class="calibre13">style.css</kbd> file.</li>
<li class="calibre12">Upgraded some npm library versions.</li>
<li class="calibre12">Changed the prefix configuration for generated code to use <kbd class="calibre13">abe</kbd> (short for Angular By Example) from <kbd class="calibre13">app</kbd>. With this change, all our components and directive selectors will be prefixed by <kbd class="calibre13">abe</kbd> instead of <kbd class="calibre13">app</kbd>. Check <kbd class="calibre13">app.component.ts</kbd>; the <kbd class="calibre13">selector</kbd> is <kbd class="calibre13">abe-root</kbd> instead of <kbd class="calibre13">app-root</kbd>.</li>
</ul>
<p class="calibre3">While on the topic of Angular CLI and builds, there is something that we should understand before proceeding.</p>
<p class="calibre3"><em class="calibre17">What happens to the TypeScript code we write?</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Code transpiling</h1>
                
            
            <article>
                
<p class="calibre3">Browsers, as we all know, only work with JavaScript, they don't understand TypeScript. We hence need a mechanism to convert our TypeScript code into plain JavaScript (<strong class="calibre5">ES5</strong> is our safest bet). The <strong class="calibre5">TypeScript compiler</strong> does this job. The compiler takes the TypeScript code and converts it into JavaScript. This process is commonly referred to as <strong class="calibre5">transpiling</strong>, and since the TypeScript compiler does it, it's called a <strong class="calibre5">transpiler</strong>.</p>
<div class="packt_infobox">JavaScript as a language has evolved over the years with every new version adding new features/capabilities to the language. The latest avatar, ES2015, succeeds ES5 and is a major update to the language. While released in June 2015, some of the older browsers still lack support for the ES2015 flavor, of JavaScript making its adoption a challenge.<br class="calibre27"/>
When transpiling code from TypeScript to JavaScript, we can specify the flavor of JavaScript to use. As mentioned earlier, ES5 is our safest bet, but if we plan to work with only the latest and greatest browsers, go for ES2015. For 7 Minute Workout, our code to transpile to is ES5 format. We set this TypeScript compiler configuration in <kbd class="calibre24">tsconfig.json</kbd> (see the <kbd class="calibre24">target</kbd> property).</div>
<p class="calibre3">Interestingly, transpilation can happen at both build/compile time and at runtime:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Build-time transpilation</strong>: Transpilation as part of the build process takes the script files (in our case, TypeScript <kbd class="calibre13">.ts</kbd> files) and compiles them into plain JavaScript. Angular CLI does build-time transpilation.</li>
<li class="calibre12"><strong class="calibre1">Runtime transpilation</strong>: This happens in the browser at runtime. We directly reference the TypeScript files (<kbd class="calibre13">.ts</kbd> in our case), and the TypeScript compiler, which is loaded in the browser beforehand, compiles these script files on the fly. This is a workable setup only for small examples/code snippets, as there is an additional performance overhead involved in loading the <span>transpiler</span> and <span>transpiling</span> the code on the fly.</li>
</ul>
<p class="calibre3">The process of transpiling is not limited to TypeScript. Every language targeted towards the web, such as <strong class="calibre5">CoffeeScript</strong>, <strong class="calibre5">ES2015</strong>, (yes JavaScript itself!) or any other language that is not inherently understood by a browser needs transpilation. There are transpilers for most languages, and the prominent ones (other than TypeScript) are <strong class="calibre5">tracuer</strong> and <strong class="calibre5">babel.</strong></p>
<p class="calibre3">The Angular CLI build system takes care of setting up the TypeScript compiler and sets up file watchers that recompile the code every time we make changes to our TypeScript file.</p>
<div class="packt_tip">If you are new to TypeScript, remember that TypeScript does not depend on Angular; in fact, Angular has been built on TypeScript. I highly recommend that you look at the official documentation on TypeScript (<a href="https://www.typescriptlang.org/" class="calibre21">https://www.typescriptlang.org/</a>) and learn the language outside the realms of Angular.</div>
<p class="calibre3">Let's get back to the app we are building and start exploring the code setup.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Organizing code</h1>
                
            
            <article>
                
<p class="calibre3">The advantage of Angular CLI is that is dictates a code organization structure that works for applications of all sizes. Here is how the current code organization looks:</p>
<div class="packt_figure"><img src="../images/00012.jpeg" class="calibre37"/></div>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">trainer</kbd> is the application root folder.</li>
<li class="calibre12">The files inside <kbd class="calibre13">trainer</kbd> are configuration files and some standard files that are part of every standard node application.</li>
<li class="calibre12">The <kbd class="calibre13">e2e</kbd> folder will contain end to end tests for the app.</li>
<li class="calibre12"><kbd class="calibre13">src</kbd> is the primary folder where all the development happens. All the application artifacts go into <kbd class="calibre13">src</kbd>.</li>
<li class="calibre12">The <kbd class="calibre13">assets</kbd> folder inside <kbd class="calibre13">src</kbd> hosts static content (such as images, CSS, audio files, and others).</li>
<li class="calibre12">The <kbd class="calibre13">app</kbd> <span>folder has the app's source code.</span></li>
<li class="calibre12">The <kbd class="calibre13">environments</kbd> folder is useful to set configurations for different deployment environments (such as <em class="calibre2">dev, qa, production</em>).</li>
</ul>
<p class="calibre3">To organize Angular code inside the <kbd class="calibre13">app</kbd> folder, we take a leaf from the Angular style guide (<a href="http://bit.ly/ng6be-style-guide" class="calibre10">http://bit.ly/ng6be-style-guide</a>) released by the Angular team.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Feature folders</h1>
                
            
            <article>
                
<p class="calibre3">The style guide recommends use of <strong class="calibre5">feature folders</strong> to organize code. With feature folders, files linked to a single feature are placed together. If a feature grows, we break it down further into sub features and tuck the code into sub folders. Consider the <kbd class="calibre13">app</kbd> folder to be our first feature folder! As the application grows, <kbd class="calibre13">app</kbd> will add sub features for better code organization.</p>
<p class="calibre3">Let's get straight into building the application. Our first focus area, the app's model!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The 7 Minute Workout model</h1>
                
            
            <article>
                
<p class="calibre3">Designing the model for this app requires us to first detail the functional aspects of the <em class="calibre17">7 Minute Workout</em> app, and then derive a model that satisfies those requirements. Based on the problem statement defined earlier, some of the obvious requirements are as follows:</p>
<ul class="calibre11">
<li class="calibre12">Being able to start the workout.</li>
<li class="calibre12">Providing a visual clue about the current exercise and its progress. This includes the following:
<ul class="calibre30">
<li class="calibre12">Providing a visual depiction of the current exercise</li>
<li class="calibre12">Providing step-by-step instructions on how to do a specific exercise</li>
<li class="calibre12">The time left for the current exercise</li>
</ul>
</li>
<li class="calibre12">Notifying the user when the workout ends.</li>
</ul>
<p class="calibre3">Some other valuable features that we will add to this app are as follows:</p>
<ul class="calibre11">
<li class="calibre12">The ability to pause the current workout.</li>
<li class="calibre12">Providing information about the next exercise to follow.</li>
<li class="calibre12">Providing audio clues so that the user can perform the workout without constantly looking at the screen. This includes:
<ul class="calibre30">
<li class="calibre12">A timer click sound</li>
<li class="calibre12">Details about the next exercise</li>
<li class="calibre12">Signaling that the exercise is about to start</li>
</ul>
</li>
<li class="calibre12">Showing related videos for the exercise in progress and the ability to play them.</li>
</ul>
<p class="calibre3">As we can see, the central themes for this app are <strong class="calibre5">workout</strong> and <strong class="calibre5">exercise</strong>. Here, a workout is a set of exercises performed in a specific order for a particular duration. So, let's go ahead and define the model for our workout and exercise.</p>
<p class="calibre3">Based on the requirements just mentioned, we will need the following details about an exercise:</p>
<ul class="calibre11">
<li class="calibre12">The name. This should be unique.</li>
<li class="calibre12">The title. This is shown to the user.</li>
<li class="calibre12">The description of the exercise.</li>
<li class="calibre12">Instructions on how to perform the exercise.</li>
<li class="calibre12">Images for the exercise.</li>
<li class="calibre12">The name of the audio clip for the exercise.</li>
<li class="calibre12">Related videos.</li>
</ul>
<p class="calibre3">With TypeScript, we can define the classes for our model.</p>
<p class="calibre3">The <kbd class="calibre13">Exercise</kbd> class looks as follows:</p>
<pre class="calibre19">export class Exercise { 
  constructor( 
    public name: string,
    public title: string,
    public description: string, 
    public image: string,
    public nameSound?: string,
    public procedure?: string,
    public videos?: Array&lt;string&gt;) { }
} </pre>
<div class="packt_tip"><span class="packt_screen">TypeScript tips</span><br class="calibre27"/>
Declaring constructor parameters with <kbd class="calibre24">public</kbd> or <kbd class="calibre24">private</kbd> is a shorthand for creating and initializing class members at one go. The <kbd class="calibre24">?</kbd> suffix after <kbd class="calibre24">nameSound</kbd>, <kbd class="calibre24">procedure</kbd>, and <kbd class="calibre24">videos</kbd> implies that these are optional parameters.</div>
<p class="calibre3">For the workout, we need to track the following properties:</p>
<ul class="calibre11">
<li class="calibre12">The name. This should be unique.</li>
<li class="calibre12">The title. This is shown to the user.</li>
<li class="calibre12">The exercises that are part of the workout.</li>
<li class="calibre12">The duration for each exercise.</li>
<li class="calibre12">The rest duration between two exercises.</li>
</ul>
<p class="calibre3">The model class to track workout progress (<kbd class="calibre13">WorkoutPlan</kbd>) looks as follows:</p>
<pre class="calibre19">export class WorkoutPlan { 
  constructor( 
    public name: string, 
    public title: string, 
    public restBetweenExercise: number, 
<strong class="calibre1">    public exercises: ExercisePlan[],</strong> 
    public description?: string) { } 
 
  totalWorkoutDuration(): number { ... } 
} </pre>
<p class="calibre3">The <kbd class="calibre13">totalWorkoutDuration</kbd> function returns the total duration of the workout in seconds.</p>
<p class="calibre3"><kbd class="calibre13">WorkoutPlan</kbd> has a reference to another class in the preceding definition, <kbd class="calibre13">ExercisePlan</kbd>. It tracks the exercise and the duration of the exercise in a workout, which is quite apparent once we look at the definition of <kbd class="calibre13">ExercisePlan</kbd>:</p>
<pre class="calibre19">export class ExercisePlan { 
  constructor( 
    public exercise: Exercise, 
    public duration: number) { } 
} </pre>
<p class="calibre3">Let me save you some typing and tell you where to get the model classes, but before that, we need to decide where to add them. We are ready for our first feature.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">First feature module</h1>
                
            
            <article>
                
<p class="calibre3">The primary feature of <em class="calibre17">7 Minute Workout</em> is to execute a predefined set of exercises. Hence we are going to create a feature module now and later add the feature implementation to this module. We call this module <kbd class="calibre13">workout-runner</kbd>. Let's initialize the feature with Angular CLI's scaffolding capabilities.</p>
<p class="calibre3">From the command line, navigate to the <kbd class="calibre13">trainer/src/app</kbd> folder and run the following:</p>
<pre class="calibre19"><strong class="calibre1">ng generate module workout-runner --module app.module.ts</strong></pre>
<p class="calibre3">Follow the console logs to know what files are generated. The command essentially:</p>
<ul class="calibre11">
<li class="calibre12">Creates a new Angular <kbd class="calibre13">WorkoutRunnerModule</kbd> module inside a new <kbd class="calibre13">workout-runner</kbd> folder</li>
<li class="calibre12">Imports the newly created module into the main application module app (<kbd class="calibre13">app.module.ts</kbd>)</li>
</ul>
<p class="calibre3">We now have a new <strong class="calibre5">feature module</strong>.</p>
<div class="packt_tip"><br class="calibre27"/>
Give every feature its own module.</div>
<div class="packt_infobox">Make special note of the conventions Angular CLI follows when scaffolding Angular artifacts. From the preceding example, the module name provided with the command line was <kbd class="calibre24">workout-runner</kbd>. While the generated folder and filenames use the same name, the class name for the generated module is <kbd class="calibre24">WorkoutRunnerModule</kbd> (pascal case with the <kbd class="calibre24">Module</kbd> suffix).</div>
<p class="calibre3">Open the newly generated module definition (<kbd class="calibre13">workout-runner.module.ts</kbd>) and look at the generated content. <kbd class="calibre13"><span>WorkoutRunnerModule</span></kbd> imports <kbd class="calibre13">CommonModule</kbd>, a module with common Angular directives such as <kbd class="calibre13">ngIf</kbd> and <kbd class="calibre13">ngFor</kbd>, allowing us to use these common directives across any component/directive defined in <kbd class="calibre13">WorkoutRunnerModule</kbd>.</p>
<div class="packt_infobox"><span class="packt_screen"><br class="calibre27"/>
Modules are Angular's way of organizing code. We will touch upon Angular modules shortly.</span></div>
<p class="calibre3">Copy the <kbd class="calibre13">model.ts</kbd> file from <a href="http://bit.ly/ng6be-2-1-model-ts" class="calibre10">http://bit.ly/ng6be-2-1-model-ts</a> into the <kbd class="calibre13">workout-runner</kbd> folder. Shortly, we will see how these model classes are utilized.</p>
<p class="calibre3">Since we have started with a preconfigured Angular app, we just need to understand how the app starts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">App bootstrapping</h1>
                
            
            <article>
                
<p class="calibre3"><a href="" class="calibre10">Chapter 1</a>, <em class="calibre17">Getting Started</em>, had a good introduction to the app bootstrapping process. The app bootstrapping process for <em class="calibre17">7 Minute Workout</em> remains the same; look at the <kbd class="calibre13">src</kbd> folder. There is a <kbd class="calibre13">main.ts</kbd> file that bootstraps the application by calling the following:</p>
<pre class="calibre19">platformBrowserDynamic().bootstrapModule(AppModule)<br class="title-page-name"/>    .catch(err =&gt; console.log(err));</pre>
<p class="calibre3">The heavy lifting is done by the Angular CLI, which compiles the application, includes the script and CSS reference into <kbd class="calibre13">index.html</kbd>, and runs the application. We don't need to configure anything. These configurations are part of the default Angular CLI configuration (<kbd class="calibre13">.angular-cli.json</kbd>).</p>
<p class="calibre3">We have created a new module and added some model classes to the <kbd class="calibre13">module</kbd> folder. Before we go any further and start implementing the feature, let's talk a bit about <strong class="calibre5">Angular modules</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Exploring Angular modules</h1>
                
            
            <article>
                
<p class="calibre3">As the <em class="calibre17">7 Minute Workout</em> app grows and we add new components/directives/pipes/other artifacts to it, a need arises to organize these items. Each of these items needs to be part of an Angular module.</p>
<p class="calibre3">A naïve approach would be to declare everything in our app's root module (<kbd class="calibre13">AppModule</kbd>), as we did with <kbd class="calibre13">WorkoutRunnerComponent</kbd>, but this defeats the whole purpose of Angular modules.</p>
<p class="calibre3">To understand why a single-module approach is never a good idea, let's explore Angular modules.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Comprehending Angular modules</h1>
                
            
            <article>
                
<p class="calibre3">In Angular, <strong class="calibre5">modules</strong> are a way to organize code into chunks that belong together and work as a cohesive unit. Modules are Angular's way of grouping and organizing code.</p>
<p class="calibre3">An Angular module primarily defines:</p>
<ul class="calibre11">
<li class="calibre12">The components/directives/pipes it owns</li>
<li class="calibre12">The components/directives/pipes it makes public for other modules to consume</li>
<li class="calibre12">Other modules that it depends on</li>
<li class="calibre12">Services that the module wants to make available application-wide</li>
</ul>
<p class="calibre3">Any decent-sized Angular app will have modules interlinked with each other: some modules consuming artifacts from other, some providing artifacts to others, and some modules doing both.</p>
<p class="calibre3">As a standard practice, module segregation is feature-based. One divides the app into features or subfeatures (for large features) and modules are created for each of the features. Even the framework adheres to this guideline as all of the framework constructs are divided across modules:</p>
<ul class="calibre11">
<li class="calibre12">There is <kbd class="calibre13">CommonModule</kbd> that aggregates the standard framework constructs used in every browser-based Angular app</li>
<li class="calibre12">There is <kbd class="calibre13">RouterModule</kbd> if we want to use the Angular routing framework</li>
<li class="calibre12">There is <kbd class="calibre13">HtppModule</kbd> if our app needs to communicate with the server over HTTP</li>
</ul>
<p class="calibre3">Angular modules are created by applying the <kbd class="calibre13">@NgModule</kbd> decorator to a TypeScript class, something we learned in <a href="" class="calibre10">Chapter 1</a>, <em class="calibre17">Getting Started</em>. The decorator definition exposes enough metadata, allowing Angular to load everything the module refers to.</p>
<p class="calibre3">The decorator has multiple attributes that allow us to define:</p>
<ul class="calibre11">
<li class="calibre12">External dependencies (using <kbd class="calibre13">imports</kbd>).</li>
<li class="calibre12">Module artifacts (using <kbd class="calibre13">declarations</kbd>).</li>
<li class="calibre12">Module exports (using <kbd class="calibre13">exports</kbd>).</li>
<li class="calibre12">The services defined inside the module that need to be registered globally (using <kbd class="calibre13">providers</kbd>).</li>
<li class="calibre12">The main application view, called the <strong class="calibre1">root component</strong>, which hosts all other app views. Only the root module should set this using the <kbd class="calibre13">bootstrap</kbd> property.</li>
</ul>
<p class="calibre3">This diagram highlights the internals of a module and how they link to each other:</p>
<div class="packt_figure"><img src="../images/00013.jpeg" class="calibre38"/></div>
<div class="packt_infobox">Modules defined in the context of Angular (using the <kbd class="calibre24">@NgModule</kbd> decorator) are different from modules we import using the <kbd class="calibre24">import</kbd> statement in our TypeScript file. Modules imported through the <kbd class="calibre24">import</kbd> statement are <strong class="calibre26">JavaScript modules</strong>, which can be in different formats adhering to <em class="calibre31">CommonJS</em>, <em class="calibre31">AMD</em>, or <em class="calibre31">ES2015</em> specifications, whereas Angular modules are constructs used by Angular to segregate and organize its artifacts. Unless the context of the discussion is specifically a JavaScript module, any reference to module implies an Angular module. We can learn more about this here: <a href="http://bit.ly/ng2be6-module-vs-ngmodule" class="calibre21">http://bit.ly/ng2be6-module-vs-ngmodule</a>.</div>
<p class="calibre3">We hope one thing is clear from all this discussion: creating a single application-wide module is not the right use of Angular modules unless you are building something rudimentary.</p>
<p class="calibre3">It's time to get into the thick of the action; let's build our first component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Our first component - WorkoutRunnerComponent</h1>
                
            
            <article>
                
<p class="calibre3"><kbd class="calibre13">WorkoutRunnerComponent</kbd>, is the central piece of our <em class="calibre17">7 Minute Workout</em> app and it will contain the logic to execute the workout.</p>
<p class="calibre3">What we are going to do in the <kbd class="calibre13">WorkoutRunnerComponent</kbd> implementation is as follows:</p>
<ol class="calibre14">
<li value="1" class="calibre12">Start the workout</li>
<li value="2" class="calibre12">Show the workout in progress and show the progress indicator</li>
<li value="3" class="calibre12">After the time elapses for an exercise, show the next exercise</li>
<li value="4" class="calibre12">Repeat this process until all the exercises are over</li>
</ol>
<p class="calibre3">We are ready to create (or scaffold) our component.</p>
<p class="calibre3">From the command line, navigate to the <kbd class="calibre13">src/app</kbd> folder and execute the following <kbd class="calibre13">ng</kbd> command:</p>
<pre class="calibre19"><strong class="calibre1">ng generate component workout-runner -is</strong></pre>
<p class="calibre3">The generator generates a bunch of files (three) in the <kbd class="calibre13">workout-runner</kbd> folder and updates the module declaration in <kbd class="calibre13">WorkoutRunnerModule</kbd> to include the newly created <kbd class="calibre13">WorkoutRunnerComponent</kbd>.</p>
<div class="packt_infobox">The <kbd class="calibre24">-is</kbd> flag is used to stop generation of a separate CSS file for the component. Since we are using global styles, we do not need component-specific styles.</div>
<div class="packt_tip">Remember to run this command from the <kbd class="calibre24">src/app</kbd> folder and not from the <kbd class="calibre24">src/app/workout-runner</kbd> folder. If we run the preceding command from <kbd class="calibre24">src/app/workout-runner</kbd>, Angular CLI will create a new subfolder with the <kbd class="calibre24">workout-runner</kbd> component definition.</div>
<p class="calibre3">The preceding <kbd class="calibre13">ng generate</kbd> command for component generates these three files:</p>
<ul class="calibre11">
<li class="calibre12"><span><kbd class="calibre13">&lt;component-name&gt;.component.html</kbd>: This is the component's view HTML.</span></li>
<li class="calibre12"><span><kbd class="calibre13">&lt;component-name&gt;.component.spec.ts</kbd>: Test specification file used in unit testing. We will dedicate a complete chapter to unit testing Angular applications.</span></li>
<li class="calibre12"><span><kbd class="calibre13">&lt;component-name&gt;.component.ts</kbd>: Main component file containing component implementation.</span></li>
</ul>
<p class="calibre3">Again, we will encourage you to have a look at the generated code to understand what gets generated. The Angular CLI component generator saves us some keystrokes and once generated, the boilerplate code can evolve as desired.</p>
<div class="packt_infobox">We touched upon the component decorator (<kbd class="calibre24">@Component</kbd>) in <a href="part0019.html#I3QM0-7edc9b1e1ea341adae33006323903887" class="calibre21">Chapter 1</a>, <em class="calibre31">Getting Started</em>, and the decorater applied here is no different. While we see only four decorator metadata properties (such as <kbd class="calibre24">templateUrl</kbd>), the component decorator supports some other useful properties too. Look at the Angular documentation for component to learn more about these properties and their application. In the coming chapters, we will utilize some metadata attributes other than the standard ones used on every component.</div>
<p class="calibre3">An observant reader might have noticed that the generated <kbd class="calibre13">selector</kbd> property value has a prefix <kbd class="calibre13">abe</kbd>; this is intentional. Since we are extending the HTML <strong class="calibre5">domain-specific language</strong> (<strong class="calibre5">DSL</strong>) to incorporate a new element, the prefix <kbd class="calibre13">abe</kbd> helps us demarcate HTML extensions that we have developed. So instead of using <kbd class="calibre13">&lt;workout-runner&gt;&lt;/workout-runner&gt;</kbd> in HTML we use <kbd class="calibre13">&lt;abe-workout-runner&gt;&lt;/abe-workout-runner&gt;</kbd>. The prefix value has been configured in <kbd class="calibre13">angular.json</kbd>, see the <kbd class="calibre13">prefix</kbd> property.</p>
<div class="packt_tip"><br class="calibre27"/>
Always add a prefix to your component selector.</div>
<p class="calibre3">We now have the <kbd class="calibre13">WorkoutRunnerComponent</kbd> boilerplate; let's start adding the implementation, starting with adding the model reference.</p>
<p class="calibre3">In <kbd class="calibre13">workout-runner.component.ts</kbd>, import all the workout models:</p>
<pre class="calibre19">import {WorkoutPlan, ExercisePlan, Exercise} from '../model';</pre>
<p class="calibre3">Next, we need to set up the workout data. Let's do that by adding some code in the generated <kbd class="calibre13">ngOnInit</kbd> function and related class properties to the <kbd class="calibre13">WorkoutRunnerComponent</kbd> class:</p>
<pre class="calibre19">workoutPlan: WorkoutPlan; 
restExercise: ExercisePlan; 
ngOnInit() { 
   this.workoutPlan = this.buildWorkout(); 
   this.restExercise = new ExercisePlan( 
     new Exercise('rest', 'Relax!', 'Relax a bit', 'rest.png'),  
     this.workoutPlan.restBetweenExercise);   
} </pre>
<p class="calibre3"><kbd class="calibre13">ngOnInit</kbd> is a special function that Angular calls when a component is initialized. We will talk about <kbd class="calibre13">ngOnInit</kbd> shortly.</p>
<p class="calibre3">The <kbd class="calibre13">buildWorkout</kbd> on <kbd class="calibre13">WorkoutRunnerComponent</kbd> sets up the complete workout, as we will define shortly. We also initialize a <kbd class="calibre13">restExercise</kbd> variable to track even the rest periods as exercise (note that <kbd class="calibre13">restExercise</kbd> is an object of type <kbd class="calibre13">ExercisePlan</kbd>).</p>
<p class="calibre3">The <kbd class="calibre13">buildWorkout</kbd> function is a lengthy function, so it's better to copy the implementation from the workout runner's implementation available in Git branch checkpoint2.1 (<a href="http://bit.ly/ng6be-2-1-workout-runner-component-ts" class="calibre10">http://bit.ly/ng6be-2-1-workout-runner-component-ts</a>). The <kbd class="calibre13">buildWorkout</kbd> code looks as follows:</p>
<pre class="calibre19">buildWorkout(): WorkoutPlan { 
let workout = new WorkoutPlan('7MinWorkout',  
"7 Minute Workout", 10, []); 
   workout.exercises.push( 
      new ExercisePlan( 
        new Exercise( 
          'jumpingJacks', 
          'Jumping Jacks', 
          'A jumping jack or star jump, also called side-straddle hop
           is a physical jumping exercise.', 
          'JumpingJacks.png', 
          'jumpingjacks.wav', 
          `Assume an erect position, with feet together and 
           arms at your side. ...`, 
          ['dmYwZH_BNd0', 'BABOdJ-2Z6o', 'c4DAnQ6DtF8']), 
        30)); 
   // (TRUNCATED) Other 11 workout exercise data. 
   return workout; 
} </pre>
<p class="calibre3">This code builds the <kbd class="calibre13">WorkoutPlan</kbd> object and pushes the exercise data into the <kbd class="calibre13">exercises</kbd> array (an array of <kbd class="calibre13">ExercisePlan</kbd> objects), returning the newly built workout.</p>
<p class="calibre3">The initialization is complete; now, it's time to actually implement the <em class="calibre17">start</em> workout. Add a <kbd class="calibre13">start</kbd> function to the <kbd class="calibre13">WorkoutRunnerComponent</kbd> implementation, as follows:</p>
<pre class="calibre19">start() { 
   this.workoutTimeRemaining =  
   this.workoutPlan.totalWorkoutDuration(); 
   this.currentExerciseIndex = 0;  
   this.startExercise(this.workoutPlan.exercises[this.currentExerciseIndex]); 
} </pre>
<p class="calibre3">Then declare the new variables used in the function at the top, with other variable declarations:</p>
<pre class="calibre19">workoutTimeRemaining: number; 
currentExerciseIndex: number; </pre>
<p class="calibre3">The <kbd class="calibre13">workoutTimeRemaining</kbd> variable tracks the total time remaining for the workout, and <kbd class="calibre13">currentExerciseIndex</kbd> tracks the currently executing exercise index. The call to <kbd class="calibre13">startExercise</kbd> actually starts an exercise. This is how the code for <kbd class="calibre13">startExercise</kbd> looks:</p>
<pre class="calibre19">startExercise(exercisePlan: ExercisePlan) { 
    this.currentExercise = exercisePlan; 
    this.exerciseRunningDuration = 0; 
    const intervalId = setInterval(() =&gt; { 
      if (this.exerciseRunningDuration &gt;=  this.currentExercise.duration) { 
          clearInterval(intervalId);  
      } 
      else { this.exerciseRunningDuration++; } 
    }, 1000); 
} </pre>
<p class="calibre3">We start by initializing <kbd class="calibre13">currentExercise</kbd> and <kbd class="calibre13">exerciseRunningDuration</kbd>. The <kbd class="calibre13">currentExercise</kbd> variable tracks the exercise in progress and <kbd class="calibre13">exerciseRunningDuration</kbd> tracks its duration. These two variables also need to be declared at the top:</p>
<pre class="calibre19">currentExercise: ExercisePlan; 
exerciseRunningDuration: number; </pre>
<p class="calibre3">We use the <kbd class="calibre13">setInterval</kbd> JavaScript function with a delay of one second (1,000 milliseconds) to make progress. Inside the <kbd class="calibre13">setInterval</kbd> callback, <kbd class="calibre13">exerciseRunningDuration</kbd> is incremented with each passing second. The nested <kbd class="calibre13">clearInterval</kbd> call stops the timer once the exercise duration lapses.</p>
<div class="packt_tip"><span class="packt_screen">TypeScript arrow functions</span><br class="calibre27"/>
The callback parameter passed to <kbd class="calibre24">setInterval</kbd> (<kbd class="calibre24">()=&gt;{...}</kbd>) is a lambda function (or an arrow function in ES 2015). Lambda functions are short-form representations of anonymous functions, with added benefits. You can learn more about them at <a href="http://bit.ly/ng2be-ts-arrow-functions" class="calibre21"><span class="packt_screen">http://bit.ly/ng2be-ts-arrow-functions</span></a>.</div>
<p class="calibre3">The first cut of the component is almost complete, except it currently has a static view (UI) and hence we cannot verify the implementation. We can quickly rectify this situation by adding a rudimentary view definition. Open <kbd class="calibre13">workout-runner.component.ts</kbd>, comment out the <kbd class="calibre13">templateUrl</kbd> property, and add an inline template property (<kbd class="calibre13">template</kbd>) and set it to the following:</p>
<pre class="calibre19">template: `&lt;pre&gt;Current Exercise: {{currentExercise | json}}&lt;/pre&gt;<br class="title-page-name"/>&lt;pre&gt;Time Left: {{currentExercise.duration - exerciseRunningDuration}}&lt;/pre&gt;`,</pre>
<div class="packt_infobox">Strings enclosed in backticks (<kbd class="calibre24">` `</kbd>) are a new addition to ES2015. Also called template literals, such string literals can be multiline and allow expressions to be embedded inside (not to be confused with Angular expressions). Look at the MDN article at <span class="packt_screen"><a href="http://bit.ly/template-literals" class="calibre21">http://bit.ly/template-literals</a></span> for more details.</div>
<div class="packt_infobox"><span class="packt_screen">Inline versus external view template</span><strong class="calibre26"><br class="calibre27"/></strong>The preceding <kbd class="calibre24">template</kbd> property is an example of <strong class="calibre26">inline component template</strong>. This allows the component developer to specify the component template inline instead of using a separate HTML file. The inline template approach generally works for components with a trivial view. Inline templates have a disadvantage: formatting HTML becomes difficult and IDE support is very limited as the content is treated as a string literal. When we externalize HTML, we can develop a template as a normal HTML document. We recommend you use an <strong class="calibre26">external template file</strong> (specified using <kbd class="calibre24">templateUrl</kbd>) for elaborate views. Angular CLI by default generates an external template reference, but we can affect this behavior by passing the <kbd class="calibre24">--inline-template</kbd> flag to the <kbd class="calibre24">ng</kbd> component generation command, such as <kbd class="calibre24">--inline-template true</kbd>.</div>
<p class="calibre3">The preceding template HTML will render the raw <kbd class="calibre13">ExercisePlan</kbd> object and the exercise time remaining. It has an interesting expression inside the first interpolation: <kbd class="calibre13">currentExercise | json</kbd>. The <kbd class="calibre13">currentExercise</kbd> property is defined in <kbd class="calibre13">WorkoutRunnerComponent</kbd>, but what about the <kbd class="calibre13">|</kbd> symbol and what follows it (<kbd class="calibre13">json</kbd>)? In the Angular world, it is called a <strong class="calibre5">pipe</strong>. The sole purpose of a pipe is to transform/format template data.</p>
<p class="calibre3">The <kbd class="calibre13">json</kbd> pipe here does JSON data formatting. You will learn more about pipes later in this chapter, but to get a general sense of what the <kbd class="calibre13">json</kbd> pipe does, we can remove the <kbd class="calibre13">json</kbd> pipe plus the <kbd class="calibre13">|</kbd> symbol and render the template; we are going to do this next.</p>
<p class="calibre3">To render the new <kbd class="calibre13">WorkoutRunnerComponent</kbd> implementation, it has to be added to the root component's view. Modify <kbd class="calibre13">src/components/app/app.component.html</kbd> and replace the <kbd class="calibre13">h3</kbd> tag with the following code:</p>
<pre class="calibre19">&lt;div class="container body-content app-container"&gt;<br class="title-page-name"/>      &lt;abe-workout-runner&gt;&lt;/abe-workout-runner&gt;<br class="title-page-name"/>&lt;/div&gt;</pre>
<p class="calibre3">While the implementation may look complete, there is a crucial piece missing. Nowhere in the code do we actually start the workout. The workout should start as soon as we load the page.</p>
<p class="calibre3">Component lifecycle hooks are going to rescue us!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Component lifecycle hooks</h1>
                
            
            <article>
                
<p class="calibre3">The life of an Angular component is eventful. Components get created, change state during their lifetime, and finally, they are destroyed. Angular provides some <strong class="calibre5">lifecycle hooks</strong>/<strong class="calibre5">functions</strong> that the framework invokes (on the component) when such an event occurs. Consider these examples:</p>
<ul class="calibre11">
<li class="calibre12">When a component is initialized, Angular invokes <kbd class="calibre13">ngOnInit</kbd></li>
<li class="calibre12">When a component's data-bound properties change, Angular invokes <kbd class="calibre13">ngOnChanges</kbd></li>
<li class="calibre12">When a component is destroyed, Angular invokes <kbd class="calibre13">ngOnDestroy</kbd></li>
</ul>
<p class="calibre3">As developers, we can tap into these key moments and perform some custom logic inside the respective component.</p>
<p class="calibre3">The hook we are going to utilize here is <kbd class="calibre13">ngOnInit</kbd>. The <kbd class="calibre13">ngOnInit</kbd> function gets fired the first time the component's data-bound properties are initialized, but before the view initialization starts.</p>
<div class="packt_infobox">While <kbd class="calibre24">ngOnInit</kbd> and the class constructor seem to look similar, they have a different purpose. <em class="calibre31">A constructor</em> is a language feature and it is used to initialize class members. <kbd class="calibre24">ngOnInit</kbd>, on the other hand, is used to do some initialization stuff once the component is ready. Avoid use of a constructor for anything other than member initialization.</div>
<p class="calibre3">Update the <kbd class="calibre13">ngOnInit</kbd> function to the <kbd class="calibre13">WorkoutRunnerComponent</kbd> class with a call to start the workout:</p>
<pre class="calibre19">ngOnInit() { <br class="title-page-name"/>    ...
    <strong class="calibre1">this.start();</strong> 
} </pre>
<p class="calibre3">Angular CLI as part of component scaffolding already generates the signature for <kbd class="calibre13">ngOnInit</kbd>. The <kbd class="calibre13">ngOnInit</kbd> function is declared on the <kbd class="calibre13">OnInit</kbd> interface, which is part of the core Angular framework. We can confirm this by looking at the import section of <kbd class="calibre13">WorkoutRunnerComponent</kbd>:</p>
<pre class="calibre19">import {Component,<strong class="calibre1">OnInit</strong>} from '@angular/core'; 
... 
export class WorkoutRunnerComponent <strong class="calibre1">implements OnInit</strong> {</pre>
<div class="packt_infobox">There are a number of other lifecycle hooks, including <kbd class="calibre24">ngOnDestroy</kbd>, <kbd class="calibre24">ngOnChanges</kbd>, and <kbd class="calibre24">ngAfterViewInit</kbd>, that components support, but we are not going to dwell on any of them here. Look at the developer guide (<a href="https://angular.io/guide/lifecycle-hooks" class="calibre21"><span class="packt_screen">https://angular.io/guide/lifecycle-hooks</span></a>) on lifecycle hooks to learn more about other such hooks.</div>
<div class="packt_tip">Implementing the interface (<kbd class="calibre24">OnInit</kbd> in the preceding example) is optional. These lifecycle hooks work as long as the function name matches. We still recommend you use interfaces to clearly communicate the intent.</div>
<p class="calibre3">Time to run our app! Open the command line, navigate to the <kbd class="calibre13">trainer</kbd> folder, and type this line:</p>
<pre class="calibre19"><strong class="calibre1">ng serve --open</strong></pre>
<p class="calibre3">The code compiles, but no UI is rendered. What is failing us? Let's look at the browser console for errors.</p>
<p class="calibre3">Open the browser's dev tools (common keyboard shortcut <kbd class="calibre13">F12</kbd>) and look at the <span class="calibre6">console</span> tab for errors. There is a template parsing error. Angular is not able to locate the <kbd class="calibre13">abe-workout-runner</kbd> component. Let's do some sanity checks to verify our setup:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">WorkoutRunnerComponent</kbd> implementation complete - <em class="calibre2">check</em></li>
<li class="calibre12">Component declared in <kbd class="calibre13">WorkoutRunnerModule</kbd>- <em class="calibre2">check</em></li>
<li class="calibre12"><kbd class="calibre13">WorkoutRunnerModule</kbd> imported into <kbd class="calibre13">AppModule</kbd> - <em class="calibre2">check</em></li>
</ul>
<p class="calibre3">Still, the <kbd class="calibre13">AppComponent</kbd> template cannot locate the <kbd class="calibre13">WorkoutRunnerComponent</kbd>. Is it because <kbd class="calibre13">WorkoutRunnerComponent</kbd> and <kbd class="calibre13">AppComponent</kbd> are in different modules? Indeed, that is the problem! While <kbd class="calibre13">WorkoutRunnerModule</kbd> has been imported into <kbd class="calibre13">AppModule</kbd>, <kbd class="calibre13">WorkoutRunnerModule</kbd> still does not export the new <kbd class="calibre13">WorkoutRunnerComponent</kbd> that will allow <kbd class="calibre13">AppComponent</kbd> to use it.</p>
<div class="packt_infobox">Remember, adding a component/directive/pipe to the <kbd class="calibre24">declaration</kbd> section of a module makes them available inside the module. It's only after we export the component/directive/pipe that it becomes available to be used across modules.</div>
<p class="calibre3">Let's export <kbd class="calibre13">WorkoutRunnerComponent</kbd> by updating the export array of the <kbd class="calibre13">WorkoutRunnerModule</kbd> declaration to the following:</p>
<pre class="calibre19">declarations: [WorkoutRunnerComponent]<strong class="calibre1">,</strong><br class="title-page-name"/><strong class="calibre1">exports:[WorkoutRunnerComponent]</strong></pre>
<p class="calibre3">This time, we should see the following output:</p>
<div class="packt_figure"><img src="../images/00014.jpeg" class="calibre39"/></div>
<div class="packt_tip"><br class="calibre27"/>
Always export artifacts defined inside an Angular module if you want them to be used across other modules.</div>
<p class="calibre3">The model data updates with every passing second! Now you'll understand why interpolations (<kbd class="calibre13">{{ }}</kbd>) are a great debugging tool.</p>
<div class="packt_infobox"><br class="calibre27"/>
This will also be a good time to try rendering <kbd class="calibre24">currentExercise</kbd> without the <kbd class="calibre24">json</kbd> pipe and see what gets rendered.</div>
<p class="calibre3">We are not done yet! Wait long enough on the page and we realize that the timer stops after 30 seconds. The app does not load the next exercise data. Time to fix it!</p>
<p class="calibre3">Update the code inside the <kbd class="calibre13">setInterval</kbd> function:</p>
<pre class="calibre19">if (this.exerciseRunningDuration &gt;=  this.currentExercise.duration) { 
   clearInterval(intervalId); 
<strong class="calibre1">   const next: ExercisePlan = this.getNextExercise();</strong><strong class="calibre1"> 
   if (next) {
</strong><strong class="calibre1">     if (next !== this.restExercise) {
</strong><strong class="calibre1">       this.currentExerciseIndex++;
</strong><strong class="calibre1">        }
</strong><strong class="calibre1">     this.startExercise(next);</strong><strong class="calibre1">}
</strong><strong class="calibre1">   else { console.log('Workout complete!'); }</strong> 
} </pre>
<p class="calibre3">The <kbd class="calibre13">if</kbd> condition <kbd class="calibre13">if (this.exerciseRunningDuration &gt;= this.currentExercise.duration)</kbd> is used to transition to the next exercise once the time duration of the current exercise lapses. We use <kbd class="calibre13">getNextExercise</kbd> to get the next exercise and call <kbd class="calibre13">startExercise</kbd> again to repeat the process. If no exercise is returned by the <kbd class="calibre13">getNextExercise</kbd> call, the workout is considered complete.</p>
<p class="calibre3">During exercise transitioning, we increment <kbd class="calibre13">currentExerciseIndex</kbd> only if the next exercise is not a rest exercise. Remember that the original workout plan does not have a rest exercise. For the sake of consistency, we have created a rest exercise and are now swapping between rest and the standard exercises that are part of the workout plan. Therefore, <kbd class="calibre13">currentExerciseIndex</kbd> does not change when the next exercise is rest.</p>
<p class="calibre3">Let's quickly add the <kbd class="calibre13">getNextExercise</kbd> function too. Add the function to the <kbd class="calibre13">WorkoutRunnerComponent</kbd> class:</p>
<pre class="calibre19">getNextExercise(): ExercisePlan { 
    let nextExercise: ExercisePlan = null; 
    if (this.currentExercise === this.restExercise) { 
      nextExercise = this.workoutPlan.exercises[this.currentExerciseIndex + 1]; 
    } 
    else if (this.currentExerciseIndex &lt; this.workoutPlan.exercises.length - 1) { 
      nextExercise = this.restExercise; 
    } 
    return nextExercise; 
} </pre>
<p class="calibre3">The <kbd class="calibre13">getNextExercise</kbd> function returns the next exercise that needs to be performed.</p>
<div class="packt_infobox">Note that the returned object for <kbd class="calibre24">getNextExercise</kbd> is an <kbd class="calibre24">ExercisePlan</kbd> object that internally contains the exercise details and the duration for which the exercise runs.</div>
<p class="calibre3">The implementation is quite self-explanatory. If the current exercise is rest, take the next exercise from the <kbd class="calibre13">workoutPlan.exercises</kbd> array (based on <kbd class="calibre13">currentExerciseIndex</kbd>); otherwise, the next exercise is rest, given that we are not on the last exercise (the <kbd class="calibre13">else if</kbd> condition check).</p>
<p class="calibre3">With this, we are ready to test our implementation. The exercises should flip after every 10 or 30 seconds. Great!</p>
<div class="packt_infobox">The current build setup automatically compiles any changes made to the script files when the files are saved; it also refreshes the browser after these changes. But just in case the UI does not update or things do not work as expected, refresh the browser window. If you are having a problem with running the code, look at the Git branch <kbd class="calibre24">checkpoint2.1</kbd> for a working version of what we have done thus far. Or if you are not using Git, download the snapshot of Checkpoint 2.1 (a ZIP file) from <a href="http://bit.ly/ng6be-checkpoint2-1" class="calibre21">http://bit.ly/ng6be-checkpoint2-1</a><span class="packt_screen"/>. Refer to the <kbd class="calibre24">README.md</kbd> file in the <kbd class="calibre24">trainer</kbd> folder when setting up the snapshot for the first time.</div>
<p class="calibre3">We have done enough work on the component for now, let's build the view.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building the 7 Minute Workout view</h1>
                
            
            <article>
                
<p class="calibre3">Most of the hard work has already been done while defining the model and implementing the component. Now, we just need to skin the HTML using the super-awesome data binding capabilities of Angular. It's going to be simple, sweet, and elegant!</p>
<p class="calibre3">For the <em class="calibre17">7 Minute Workout</em> view, we need to show the exercise name, the exercise image, a progress indicator, and the time remaining. Replace the local content of the <kbd class="calibre13">workout-runner.component.html</kbd> file with the content of the file from the Git branch <kbd class="calibre13">checkpoint2.2</kbd>, (or download it from <a href="http://bit.ly/ng6be-2-2-workout-runner-component-html" class="calibre10">http://bit.ly/ng6be-2-2-workout-runner-component-html</a>). The view HTML looks as follows:</p>
<pre class="calibre19">&lt;div class="row"&gt;<br class="title-page-name"/>  &lt;div id="exercise-pane" class="col-sm"&gt;<br class="title-page-name"/>    &lt;h1 class="text-center"&gt;{{currentExercise.exercise.title}}&lt;/h1&gt;<br class="title-page-name"/>    &lt;div class="image-container row"&gt;<br class="title-page-name"/>      &lt;img class="img-fluid col-sm" [src]="'/assets/images/' +  <br class="title-page-name"/>                                      currentExercise.exercise.image" /&gt;<br class="title-page-name"/>    &lt;/div&gt;<br class="title-page-name"/>    &lt;div class="progress time-progress row"&gt;<br class="title-page-name"/>      &lt;div class="progress-bar col-sm" <br class="title-page-name"/>            role="progressbar" <br class="title-page-name"/>            [attr.aria-valuenow]="exerciseRunningDuration" <br class="title-page-name"/>            aria-valuemin="0" <br class="title-page-name"/>            [attr.aria-valuemax]="currentExercise.duration"<br class="title-page-name"/>            [ngStyle]="{'width':(exerciseRunningDuration/currentExercise.duration) * <br class="title-page-name"/>                                                                100 + '%'}"&gt;<br class="title-page-name"/>      &lt;/div&gt;<br class="title-page-name"/>    &lt;/div&gt;<br class="title-page-name"/>    &lt;h1&gt;Time Remaining: {{currentExercise.duration-exerciseRunningDuration}}&lt;/h1&gt;<br class="title-page-name"/>  &lt;/div&gt;<br class="title-page-name"/>&lt;/div&gt;</pre>
<p class="calibre3"><kbd class="calibre13">WorkoutRunnerComponent</kbd> currently uses an inline template; instead, we need to revert back to using an external template. Update the <kbd class="calibre13">workout-runner.component.ts</kbd> file and get rid of the <kbd class="calibre13">template</kbd> property, then uncomment <kbd class="calibre13">templateUrl</kbd>, which we commented out earlier.</p>
<p class="calibre3">Before we understand the Angular pieces in the view, let's just run the app again. Save the changes in <kbd class="calibre13">workout-runner.component.html</kbd> and if everything went fine, we will see the workout app in its full glory:</p>
<div class="packt_figure"><img src="../images/00015.jpeg" class="calibre40"/></div>
<p class="calibre3">The basic app is now up and running. The exercise image and title show up, the progress indicator shows the progress, and exercise transitioning occurs when the exercise time lapses. This surely feels great!</p>
<div class="packt_infobox">If you are having a problem with running the code, look at the Git branch <kbd class="calibre24">checkpoint2.2</kbd> for a working version of what we have done thus far. You can also download the snapshot of <kbd class="calibre24">checkpoint2.2</kbd> (a ZIP file) from this GitHub location: <a href="http://bit.ly/ng6be-checkpoint-2-2" class="calibre21">http://bit.ly/ng6be-checkpoint-2-2</a> <span class="packt_screen"/>. Refer to the <kbd class="calibre24">README.md</kbd> file in the <kbd class="calibre24">trainer</kbd> folder when setting up the snapshot for the first time.</div>
<p class="calibre3">Looking at the view HTML, other than some Bootstrap styles, there are some interesting Angular pieces that need our attention. Before we dwell on these view constructs in detail, let's break down these elements and provide a quick summary:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">&lt;h1 ...&gt;{{currentExercise.exercise.title}}&lt;/h1&gt;</kbd>: Uses <strong class="calibre1">interpolation</strong></li>
<li class="calibre12"><kbd class="calibre13">&lt;img ... [src]="'/assets/images/' + currentExercise.exercise.image" .../&gt;</kbd>: Uses <strong class="calibre1">property binding</strong> to bind the <kbd class="calibre13">src</kbd> property of the image to the component model property <span><kbd class="calibre13">currentExercise.exercise.image</kbd></span></li>
<li class="calibre12"><kbd class="calibre13">&lt;div ... [attr.aria-valuenow]="exerciseRunningDuration" ... &gt;</kbd>: Uses <strong class="calibre1">attribute binding</strong> to bind the aria attribute on <em class="calibre2">div</em> to <kbd class="calibre13">exerciseRunningDuration</kbd></li>
<li class="calibre12"><kbd class="calibre13">&lt; div ... [ngStyle]="{'width':(exerciseRunningDuration/currentExercise.duration) * 100 + '%'}"&gt;</kbd>: Uses a <strong class="calibre1">directive</strong> <kbd class="calibre13">ngStyle</kbd> to bind the <kbd class="calibre13">style</kbd> property on the progress bar <kbd class="calibre13">div</kbd> to an expression that evaluates the exercise progress</li>
</ul>
<p class="calibre3">Phew! There is a lot of binding involved. Let's dig deeper into the binding infrastructure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Angular binding infrastructure</h1>
                
            
            <article>
                
<p class="calibre3">Most modern JavaScript frameworks today come with strong model-view binding support, and Angular is no different. The primary aim of any binding infrastructure is to reduce the boilerplate code that a developer needs to write to keep the model and view in sync. A robust binding infrastructure is always declarative and terse.</p>
<p class="calibre3">The Angular binding infrastructure allows us to transform template (raw) HTML into a live view that is bound to model data. Based on the binding constructs used, data can flow and be synced in both directions: from model to view and view to model.</p>
<p class="calibre3">The link between the component's model and its view is established using the <kbd class="calibre13">template</kbd> or <kbd class="calibre13">templateUrl</kbd> property of the <kbd class="calibre13">@Component</kbd> decorator. With the exception of the <kbd class="calibre13">script</kbd> tag, almost any piece of HTML can act as a template for the Angular binding infrastructure.</p>
<p class="calibre3">To make this binding magic work, Angular needs to take the view template, compile it, link it to the model data, and keep it in sync with model updates without the need for any custom boilerplate synchronization code.</p>
<p class="calibre3">Based on the data flow direction, these bindings can be of three types:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">One-way binding from model to view</strong>: In model-to-view binding, changes to the model are kept in sync with the view. Interpolations, property, attribute, class, and style bindings fall in this category.</li>
<li class="calibre12"><strong class="calibre1">One-way binding from view to model</strong>: In this category, view changes flow towards the model. Event bindings fall in this category.</li>
<li class="calibre12"><strong class="calibre1">Two-way/bidirectional binding</strong>: Two-way binding, as the name suggests, keeps the view and model in sync. There is a special binding construct used for two-way binding, <kbd class="calibre13">ngModel</kbd>, and some standard HTML data entry elements such as <kbd class="calibre13">input</kbd> and <kbd class="calibre13">select</kbd> support two-way binding.</li>
</ul>
<p class="calibre3">Let's understand how to utilize the binding capabilities of Angular to support view templatization. Angular provides these binding constructs:</p>
<ul class="calibre11">
<li class="calibre12">Interpolations</li>
<li class="calibre12">Property binding</li>
<li class="calibre12">Attribute binding</li>
<li class="calibre12">Class binding</li>
<li class="calibre12">Style binding</li>
<li class="calibre12">Event binding</li>
</ul>
<div class="packt_infobox"><br class="calibre27"/>
We have already touched upon a number of binding capabilities in <a href="part0019.html#I3QM0-7edc9b1e1ea341adae33006323903887" class="calibre21">Chapter 1</a>, <em class="calibre31">Getting Started</em>, so here we strive to reduce repetition and build upon the knowledge that we acquired in the last chapter.</div>
<p class="calibre3">This is a good time to learn about all these binding constructs. <strong class="calibre5">Interpolation</strong> is the first one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Interpolations</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Interpolations</strong> are quite simple. The expression (commonly know as a <strong class="calibre5">template expression</strong>) inside the interpolation symbols (<kbd class="calibre13">{{ }}</kbd>) is evaluated in the context of the model (or the component class members), and the outcome of the evaluation (string) is embedded in HTML. A handy framework construct to display a component's data/properties. We have seen these all along in <a href="" class="calibre10">Chapter 1</a>, <em class="calibre17">Getting Started</em>, and also in the view we just added. We render the exercise title and the exercise time remaining using interpolation:</p>
<pre class="calibre19">&lt;h1&gt;{{currentExercise.exercise.title}}&lt;/h1&gt;<br class="title-page-name"/>... 
&lt;h1&gt;Time Remaining: {{currentExercise.duration?-exerciseRunningDuration}}&lt;/h1&gt; </pre>
<p class="calibre3">Remember that interpolations synchronize model changes with the view. Interpolation is one way of binding from a model to a view.</p>
<div class="packt_tip"><br class="calibre27"/>
View bindings in Angular are always evaluated in the context of the component's scope.</div>
<p class="calibre3">Interpolations, in fact, are a special case of property binding, which allows us to bind any HTML element/component properties to a model. We will shortly discuss how an interpolation can be written using property binding syntax. Consider interpolation as syntactical sugar over property binding.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Property binding</h1>
                
            
            <article>
                
<p class="calibre3">As discussed in <a href="part0019.html#I3QM0-7edc9b1e1ea341adae33006323903887" class="calibre10">Chapter 1</a> <em class="calibre17">Getting Started</em>, property bindings allow us to bind native HTML/component properties to the component's model and keep them in sync (from model-&gt;view). Let's look at property binding from a different context.</p>
<p class="calibre3">Look at this view excerpt from the 7 Minute Workout's component view (<kbd class="calibre13">workout-runner.component.html</kbd>):</p>
<pre class="calibre19">&lt;img class="img-responsive" [src]="'/static/images/' + currentExercise.exercise.image" /&gt; </pre>
<p class="calibre3">It seems that we are setting the <kbd class="calibre13">src</kbd> attribute of <kbd class="calibre13">img</kbd> to an expression that gets evaluated at runtime. But are we really binding to an attribute? Or is this a property? Are properties and attributes different?</p>
<p class="calibre3">In Angular realms, while the preceding syntax looks like it is setting an HTML element's attribute, it is in fact doing <strong class="calibre5">property binding</strong>. Moreover, since many of us are not aware of the difference between an HTML element's properties and its attributes, this statement is very confusing. Therefore, before we look at how property bindings work, let's try to grasp the difference between an element's property and its attribute.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Property versus attribute</h1>
                
            
            <article>
                
<p class="calibre3">Take any DOM element API and you will find attributes, properties, functions, and events. While events and functions are self-explanatory, it is difficult to understand the difference between properties and attributes. In daily use, we use these words interchangeably, which does not help much either. Take, for example, this line of code:</p>
<pre class="calibre19">&lt;input type="text" value="Awesome Angular"&gt; </pre>
<p class="calibre3">When the browser creates a DOM element (<kbd class="calibre13">HTMLInputElement</kbd> to be precise) for this input textbox, it uses the <kbd class="calibre13">value</kbd> attribute on <kbd class="calibre13">input</kbd> to set the initial state of the  <kbd class="calibre13">value</kbd> property of <kbd class="calibre13">input</kbd> to <kbd class="calibre13">Awesome Angular</kbd>.</p>
<p class="calibre3">After this initialization, any changes to the <kbd class="calibre13">value</kbd> property of <kbd class="calibre13">input</kbd> do not reflect on the <kbd class="calibre13">value</kbd> attribute; the attribute always has <kbd class="calibre13">Awesome Angular</kbd> (unless set explicitly again). This can be confirmed by querying the <kbd class="calibre13">input</kbd> state.</p>
<p class="calibre3">Suppose we change the <kbd class="calibre13">input</kbd> data to <kbd class="calibre13">Angular rocks!</kbd> and query the <kbd class="calibre13">input</kbd> element state:</p>
<pre class="calibre19">input.value // value property </pre>
<p class="calibre3">The <kbd class="calibre13">value</kbd> property always returns the current input content, which is <kbd class="calibre13">Angular rocks!</kbd>. Whereas this DOM API function:</p>
<pre class="calibre19">input.getAttribute('value')  // value attribute </pre>
<p class="calibre3">Returns the <kbd class="calibre13">value</kbd> attribute, and is always the <kbd class="calibre13">Awesome Angular</kbd> that was set initially.</p>
<p class="calibre3">The primary role of an element attribute is to initialize the state of the element when the corresponding DOM object is created.</p>
<p class="calibre3">There are a number of other nuances that add to this confusion. These include the following:</p>
<ul class="calibre11">
<li class="calibre12">Attribute and property synchronization is not consistent across properties. As we saw in the preceding example, changes to the <kbd class="calibre13">value</kbd> property on <kbd class="calibre13">input</kbd> do not affect the <kbd class="calibre13">value</kbd> attribute, but this is not true for all property-value pairs. The <kbd class="calibre13">src</kbd> property of an image element is a prime example of this; changes to property or attribute values are always kept in sync.</li>
</ul>
<ul class="calibre11">
<li class="calibre12">It's surprising to learn that the mapping between attributes and properties is also not one-to-one. There are a number of properties that do not have any backing attribute (such as <kbd class="calibre13">innerHTML</kbd>), and there are also attributes that do not have a corresponding property defined on the DOM (such as <kbd class="calibre13">colspan</kbd>).</li>
<li class="calibre12">Attribute and property mapping adds to this confusion too, as they do not follow a consistent pattern. An excellent example of this is available in the Angular developer's guide, which we are going to reproduce here verbatim:</li>
</ul>
<div class="packt_infobox">The <kbd class="calibre24">disabled</kbd> attribute is another peculiar example. A button's <kbd class="calibre24">disabled</kbd> property is <kbd class="calibre24">false</kbd> by default so the button is enabled. When we add the disabled attribute, its presence alone initializes the button's <kbd class="calibre24">disabled</kbd> property to <kbd class="calibre24">true</kbd> so the button is disabled. Adding and removing the disabled attribute disables and enables the button. The value of the attribute is irrelevant, which is why we cannot enable a button by writing <kbd class="calibre24">&lt;button disabled="false"&gt;Still Disabled&lt;/button&gt;</kbd>.</div>
<p class="calibre3">The aim of this discussion is to make sure that we understand the difference between the properties and attributes of a DOM element. This new mental model will help us as we continue to explore the framework's property and attribute binding capabilities. Let's get back to our discussion on property binding.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Property binding continued...</h1>
                
            
            <article>
                
<p class="calibre3">Now that we understand the difference between a property and an attribute, let's look at the binding example again:</p>
<pre class="calibre19">&lt;img class="img-responsive" [src]="'/static/images/' + currentExercise.exercise.image" /&gt; </pre>
<p class="calibre3">The <kbd class="calibre13">[propertName]</kbd> square bracket syntax is used to bind the <kbd class="calibre13">img.src</kbd> property to an Angular expression.</p>
<p class="calibre3">The general syntax for property binding looks as follows:</p>
<pre class="calibre19">[target]="sourceExpression"; </pre>
<p class="calibre3">In the case of property binding, the <kbd class="calibre13">target</kbd> is a property on the DOM element or component. With property binding, we can literally bind to any property on the element's DOM. The <kbd class="calibre13">src</kbd> property on the <kbd class="calibre13">img</kbd> element is what we use; this binding works for any HTML element and every property on it.</p>
<div class="packt_infobox"><br class="calibre27"/>
Expression target can also be an event, as we will see shortly when we explore event binding.</div>
<div class="packt_infobox"><span class="packt_screen">Binding source and target</span><strong class="calibre26"><br class="calibre27"/></strong>It is important to understand the difference between source and target in an Angular binding. The property appearing inside <kbd class="calibre24">[]</kbd> is a target, sometimes called <strong class="calibre26">binding target</strong>. The target is the consumer of the data and always refers to a property on the component/element. The <strong class="calibre26">source</strong> expression constitutes the data source that provides data to the target.</div>
<p class="calibre3">At runtime, the expression is evaluated in the context of the component's/element's property (the <kbd class="calibre13">WorkoutRunnerComponent.currentExercise.exercise.image</kbd> property in the preceding case).</p>
<div class="packt_tip">Always remember to add square brackets <kbd class="calibre24">[]</kbd> around the target. If we don't, Angular treats the expression as a string constant and the target is simply assigned the string value.<br class="calibre27"/>
Property binding, event binding, and attribute binding do not use the interpolation symbol. The following is invalid: <kbd class="calibre24">[src]="{{'/static/images/' + currentExercise.exercise.image}}".</kbd></div>
<div class="packt_infobox">If you have worked on AngularJS, property binding together with event binding allows Angular to get rid of a number of directives, such as <kbd class="calibre24">ng-disable</kbd>, <kbd class="calibre24">ng-src</kbd>, <kbd class="calibre24">ng-key*</kbd>, <kbd class="calibre24">ng-mouse*</kbd>, and a few others.</div>
<p class="calibre3">From a data binding perspective, Angular treats components in the same way as it treats native elements. Hence, property binding works on component properties too! Components can define <strong class="calibre5">input</strong> and <strong class="calibre5">output properties</strong> that can be bound to the view, such as this:</p>
<pre class="calibre19">&lt;workout-runner [exerciseRestDuration]="restDuration"&gt;&lt;/workout-runner&gt; </pre>
<p class="calibre3">This hypothetical snippet binds the <kbd class="calibre13">exerciseRestDuration</kbd> property on the <kbd class="calibre13">WorkoutRunnerComponent</kbd> class to the <kbd class="calibre13">restDuration</kbd> property defined on the container component (parent), allowing us to pass the rest duration as a parameter to the <kbd class="calibre13">WorkoutRunnerComponent</kbd>. As we enhance our app and develop new components, you will learn how to define custom properties and events on a component.</p>
<div class="packt_infobox">We can enable property binding using the <kbd class="calibre24">bind-</kbd> syntax, which is a canonical form of property binding. This implies that <kbd class="calibre24">[src]="'/assets/images/' + currentExercise.exercise.image"</kbd> is equivalent to the following: <kbd class="calibre24">bind-src="'/static/images/' + currentExercise.exercise.image"</kbd>.</div>
<div class="packt_infobox"><br class="calibre27"/>
Property binding, like interpolation, is unidirectional, from the component/element source to the view. Changes to the model data are kept in sync with the view.</div>
<p class="calibre3">The template view that we just created has only one property binding (on <kbd class="calibre13">[src]</kbd>). The other bindings with square brackets aren't property bindings. We will cover them shortly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Interpolation syntactic sugar over property binding</h1>
                
            
            <article>
                
<p class="calibre3">We concluded the section on interpolations by describing interpolation as syntactical sugar over property binding. The intent was to highlight how both can be used interchangeably. The interpolation syntax is terser than property binding and hence is very useful. This is how Angular interprets an interpolation:</p>
<pre class="calibre19">&lt;h3&gt;Main heading - {{heading}}&lt;/h3&gt; <br class="title-page-name"/>&lt;h3 [text-content]="' Main heading - '+ heading"&gt;&lt;/h3&gt;</pre>
<p class="calibre3">Angular translates the interpolation in the first statement into the <kbd class="calibre13">textContent</kbd> property binding (second statement).</p>
<p class="calibre3">Interpolation can be used in more places than you can imagine. The following example contrasts the same binding using interpolation and property binding:</p>
<pre class="calibre19">&lt;img [src]="'/assets/images/' + currentExercise.exercise.image" /&gt;<br class="title-page-name"/>&lt;img src="/assets/images/{{currentExercise.exercise.image}}" /&gt;      // interpolation on attribute<br class="title-page-name"/><br class="title-page-name"/>&lt;span [text-content]="helpText"&gt;&lt;/span&gt;<br class="title-page-name"/>&lt;span&gt;{{helpText}}&lt;/span&gt;</pre>
<p class="calibre3">While property binding (and interpolations) makes it easy for us to bind any expression to the target property, we should be careful with the expression we use. Angular's change detection system will evaluate your expression binding multiple times during the life cycle of the application, as long as our component is alive. Therefore, while binding an expression to a property target, keep these two guidelines in mind.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Quick expression evaluation</h1>
                
            
            <article>
                
<p class="calibre3">A property binding expression should evaluate quickly. Slow expression evaluation can kill your app's performance. This happens when a function performing CPU intensive work is part of an expression. Consider this binding:</p>
<pre class="calibre19">&lt;div&gt;{{doLotsOfWork()}}&lt;/div&gt; </pre>
<p class="calibre3">Angular will evaluate the preceding <kbd class="calibre13">doLotsOfWork()</kbd> expression every time it performs a change detection run. These change detection runs happen more often than we imagine and are based on some internal heuristics, so it becomes imperative that the expressions we use evaluate quickly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Side effect-free binding expressions</h1>
                
            
            <article>
                
<p class="calibre3">If a function is used in a binding expression, it should be side effect-free. Consider yet another binding:</p>
<pre class="calibre19">&lt;div [innerHTML]="getContent()"&gt;&lt;/div&gt; </pre>
<p class="calibre3">And the underlying function, <kbd class="calibre13">getContent</kbd>:</p>
<pre class="calibre19">getContent() { 
  var content=buildContent(); 
  this.timesContentRequested +=1; 
  return content; 
} </pre>
<p class="calibre3">The <kbd class="calibre13">getContent</kbd> call changes the state of the component by updating the <kbd class="calibre13">timesContentRequested</kbd> property every time it is called. If this property is used in views such as:</p>
<pre class="calibre19">&lt;div&gt;{{timesContentRequested}}&lt;/div&gt; </pre>
<p class="calibre3">Angular throws errors such as:</p>
<pre class="calibre19">Expression '{{getContent()}}' in AppComponent@0:4' has changed after it was checked. Previous value: '1'. Current value: '2'</pre>
<div class="packt_infobox"><br class="calibre27"/>
The Angular framework works in two modes, dev and production. If we enable production mode in the application, the preceding error does not show up. Look at the framework documentation at <a href="http://bit.ly/enableProdMode" class="calibre21"><span class="packt_screen">http://bit.ly/enableProdMode</span></a> for more details.</div>
<p class="calibre3">The bottom line is that your expression used inside property binding should be side effect-free.</p>
<p class="calibre3">Let's now look at something interesting, <kbd class="calibre13">[ngStyle]</kbd>, which looks like a property binding, but it's not. The target specified in <kbd class="calibre13">[]</kbd> is not a component/element property (<kbd class="calibre13">div</kbd> does not have an <kbd class="calibre13">ngStyle</kbd> property), it's a directive.</p>
<p class="calibre3">Two new concepts need to be introduced, <strong class="calibre5">target selection</strong> and <strong class="calibre5">directives</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Angular directives</h1>
                
            
            <article>
                
<p class="calibre3">As a framework, Angular tries to enhance the HTML <strong class="calibre5">DSL</strong> (short for <strong class="calibre5">Domain-Specific Language</strong>):</p>
<ul class="calibre11">
<li class="calibre12">Components are referenced in HTML using custom tags such as <kbd class="calibre13">&lt;abe-workout-runner&gt;&lt;/abe-workout-runner&gt;</kbd> (not part of standard HTML constructs). This highlights the first extension point.</li>
<li class="calibre12">The use of <kbd class="calibre13">[]</kbd> and <kbd class="calibre13">()</kbd> for property and event binding defines the second.</li>
<li class="calibre12">And then there are <strong class="calibre1">directives</strong>, the third extension point which are further classified into <strong class="calibre1">attribute</strong> and <strong class="calibre1">structural directives</strong>, and <strong class="calibre1">components</strong> (components are directive too!).</li>
</ul>
<p class="calibre3">While components come with their own view, attribute directives are there to enhance the appearance and/or behavior of existing elements/components.</p>
<p class="calibre3">Structural directives do not have their own view too; they change the DOM layout of the elements on which they are applied. We will dedicate a complete section later in the chapter to understanding these structural directives.</p>
<p class="calibre3">The <kbd class="calibre13">ngStyle</kbd> directive used in the <kbd class="calibre13">workout-runner</kbd> view is, in fact, an attribute directive:</p>
<pre class="calibre19">&lt;div class="progress-bar" role="progressbar"  
 [ngStyle] = "{'width':(exerciseRunningDuration/currentExercise.duration) * 100 + '%'}"&gt;&lt;/div&gt;  </pre>
<p class="calibre3">The <kbd class="calibre13">ngStyle</kbd> directive does not have its own view; instead, it allows us to set multiple styles (<kbd class="calibre13">width</kbd> in this case) on an HTML element using binding expressions. We will be covering a number of framework attribute directives later in this book.</p>
<div class="packt_tip"><span class="packt_screen">Directive nomenclature</span><br class="calibre27"/>
Directives is an umbrella term used for component directives (also known as components), attribute directives, and structural directives. Throughout the book, when we use the term directive, we will be referring to either an attribute directive or a structural directive depending on the context. Component directives are always referred to as components.</div>
<p class="calibre3">With a basic understanding of the directive types that Angular has, we can comprehend the process of target selection for binding.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Target selection for binding</h1>
                
            
            <article>
                
<p class="calibre3">The target specified in <kbd class="calibre13">[]</kbd> is not limited to a component/element property. While the property name is a common target, the Angular templating engine actually does heuristics to decide the target type. Angular first searches the registered known directives (attribute or structural) that have matching selectors before looking for a property that matches the target expression. Consider this view fragment:</p>
<pre class="calibre19">&lt;div [ngStyle]='expression'&gt;&lt;/div&gt; </pre>
<p class="calibre3">The search for a target starts <span class="calibre6">with a framework looking at all internal and custom directives with a matching selector</span> (<kbd class="calibre13">ngStyle</kbd>). Since Angular already has an <kbd class="calibre13">NgStyle</kbd> directive, it becomes the target (the directive class name is <kbd class="calibre13">NgStyle</kbd>, whereas the selector is <kbd class="calibre13">ngStyle</kbd>). If Angular did not have a built-in <kbd class="calibre13">NgStyle</kbd> directive, the binding engine would have looked for a property called <kbd class="calibre13">ngStyle</kbd> on the underlying component.</p>
<p class="calibre3">If nothing matches the target expression, an unknown directive error is thrown<em class="calibre17">.</em></p>
<p class="calibre3">That completes our discussion on target selection. The next section is about attribute binding.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Attribute binding</h1>
                
            
            <article>
                
<p class="calibre3">The only reason attribute binding exists in Angular is that there are HTML attributes that do not have a backing DOM property. The <kbd class="calibre13">colspan</kbd> and <kbd class="calibre13">aria</kbd> attributes are some good examples of attributes without backing properties. The progress bar div in our view uses attribute binding.</p>
<div class="packt_infobox">If attribute directives are still playing your head, I cannot blame you, it can become a bit confusing. Fundamentally, they are different. Attribute directives (such as <kbd class="calibre24">[ngStyle]</kbd>) change the appearance or behavior of DOM elements and as the name suggests are directives. There is no attribute or property named <kbd class="calibre24">ngStyle</kbd> on any HTML element. Attribute binding, on the other hand, is all about binding to HTML attributes that do not have backing for a DOM property.</div>
<p class="calibre3">The <em class="calibre17">7 Minute Workout</em> uses attribute binding at two places, <kbd class="calibre13">[attr.aria-valuenow]</kbd> and <kbd class="calibre13">[attr.aria-valuemax]</kbd>. We may ask a question: can we use standard interpolation syntax to set an attribute? No, that does not work! Let's try it: open <kbd class="calibre13">workout-runner.component.html</kbd> and replace the two aria attributes <kbd class="calibre13">attr.aria-valuenow</kbd> and <kbd class="calibre13">attr.aria-valuemax</kbd> enclosed in <kbd class="calibre13">[]</kbd> with this highlighted code:</p>
<pre class="calibre19">&lt;div class="progress-bar" role="progressbar"  
    <strong class="calibre1">aria-valuenow = "{{exerciseRunningDuration}}" </strong> 
    aria-valuemin="0"  
    <strong class="calibre1">aria-valuemax= "{{currentExercise.duration}}" </strong> ...&gt; &lt;/div&gt; </pre>
<p class="calibre3">Save the view and if the app is not running, run it. This error will pop up in the browser console:</p>
<pre class="calibre19">Can't bind to 'ariaValuenow' since it isn't a known native property in WorkoutRunnerComponent ... </pre>
<p class="calibre3">Angular is trying to search for a property called <kbd class="calibre13">ariaValuenow</kbd> in the <kbd class="calibre13">div</kbd> that does not exist! Remember, interpolations are actually property bindings.</p>
<p class="calibre3">We hope that this gets the point across: to bind to an HTML attribute, use attribute binding.</p>
<div class="packt_tip"><br class="calibre27"/>
Angular binds to properties by default and not to attributes.</div>
<p class="calibre3">To support attribute binding, Angular uses a prefix notation, <kbd class="calibre13">attr</kbd>, within <kbd class="calibre13">[]</kbd>. An attribute binding looks as follows:</p>
<pre class="calibre19">[attr.attribute-name]="expression" </pre>
<p class="calibre3">Revert to the original aria setup to make attribute binding work:</p>
<pre class="calibre19">&lt;div ... [attr.aria-valuenow]="exerciseRunningDuration" <br class="title-page-name"/>    [attr.aria-valuemax]="currentExercise.duration" ...&gt; </pre>
<div class="packt_tip"><br class="calibre27"/>
Remember that unless an explicit <kbd class="calibre24">attr.</kbd> prefix is attached, attribute binding does not work.</div>
<p class="calibre3">While we have not used style and class-based binding in our workout view, these are some binding capabilities that can come in handy. Hence, they are worth exploring.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Style and class binding</h1>
                
            
            <article>
                
<p class="calibre3">We use <strong class="calibre5">class binding</strong> to set and remove a specific class based on the component state, as follows:</p>
<pre class="calibre19">[class.class-name]="expression" </pre>
<p class="calibre3">This adds <kbd class="calibre13">class-name</kbd> when <kbd class="calibre13">expression</kbd> is <kbd class="calibre13">true</kbd> and removes it when it is <kbd class="calibre13">false</kbd>. A simple example can look as follows:</p>
<pre class="calibre19">&lt;div [class.highlight]="isPreferred"&gt;Jim&lt;/div&gt; // Toggles the highlight class </pre>
<p class="calibre3">Use style bindings to set inline styles based on the component state:</p>
<pre class="calibre19">[style.style-name]="expression";</pre>
<p class="calibre3">While we have used the <kbd class="calibre13">ngStyle</kbd> directive for the workout view, we could have easily used style binding as well, as we are dealing with a single style. With style binding, the same <kbd class="calibre13">ngStyle</kbd> expression would become the following:</p>
<pre class="calibre19">[style.width.%]="(exerciseRunningDuration/currentExercise.duration) * 100" </pre>
<p class="calibre3"><kbd class="calibre13">width</kbd> is a style, and since it takes units too, we extend our target expression to include the <kbd class="calibre13">%</kbd> symbol.</p>
<div class="packt_tip">Remember that <kbd class="calibre24">style.</kbd> and <kbd class="calibre24">class.</kbd> are convenient bindings for setting a single class or style. For more flexibility, there are corresponding attribute directives: <kbd class="calibre24">ngClass</kbd> and <kbd class="calibre24">ngStyle</kbd>.</div>
<p class="calibre3">Earlier in the chapter, we formally introduced directives and their classifications. One of the directives types, attribute directives (again, don't confuse them with attribute binding, which we introduced in the preceding section) are the focus of our attention in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Attribute directives</h1>
                
            
            <article>
                
<p class="calibre3">Attribute directives are HTML extensions that change the look, feel, or behavior of a component/element. As described in the section on Angular directives, these directives do not define their own view.</p>
<p class="calibre3">Other than <kbd class="calibre13">ngStyle</kbd> and <kbd class="calibre13">ngClass</kbd> directives, there are a few more attribute directives that are part of the core framework. <kbd class="calibre13">ngValue</kbd>, <kbd class="calibre13">ngModel</kbd>, <kbd class="calibre13">ngSelectOptions</kbd>, <kbd class="calibre13">ngControl</kbd>, and <kbd class="calibre13">ngFormControl</kbd> are some of the attribute directives that Angular provides.</p>
<p class="calibre3">Since <em class="calibre17">7 Minute Workout</em> uses the <kbd class="calibre13">ngStyle</kbd> directive, it would be wise to dwell more on this directive and its close associate <kbd class="calibre13">ngClass</kbd>.</p>
<div class="packt_infobox">While the next section is dedicated to learning how to use the <kbd class="calibre24">ngClass</kbd> and <kbd class="calibre24">ngStyle</kbd> attribute directives, it is not until <a href="" class="calibre21">Chapter 6</a>, <em class="calibre31">Angular Directives in Depth</em>, that we learn how to create our own attribute directives.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Styling HTML with ngClass and ngStyle</h1>
                
            
            <article>
                
<p class="calibre3">Angular has two excellent directives that allow us to dynamically set styles on any element and toggle CSS classes. For the bootstrap progress bar, we use the <kbd class="calibre13">ngStyle</kbd> directive to dynamically set the element's style, <kbd class="calibre13">width</kbd>, as the exercise progresses:</p>
<pre class="calibre19">&lt;div class="progress-bar" role="progressbar" ... <br class="title-page-name"/>    [ngStyle]="{'width':(exerciseRunningDuration/currentExercise.duration) * 100 + '%'}"&gt; &lt;/div&gt; </pre>
<p class="calibre3"><kbd class="calibre13">ngStyle</kbd> allows us to bind one or more styles to a component's properties at once. It takes an object as a parameter. Each property name on the object is the style name, and the value is the Angular expression bound to that property, such as the following example:</p>
<pre class="calibre19">&lt;div [ngStyle]= "{ 
'width':componentWidth,  
'height':componentHeight,  
'font-size': 'larger',  
'font-weight': ifRequired ? 'bold': 'normal' }"&gt;&lt;/div&gt; </pre>
<p class="calibre3">The styles can not only bind to component properties (<kbd class="calibre13">componentWidth</kbd> and <kbd class="calibre13">componentHeight</kbd>), but also be set to a constant value (<kbd class="calibre13">'larger'</kbd>). The expression parser also allows the use of the ternary operator (<kbd class="calibre13">?:</kbd>); check out <kbd class="calibre13">isRequired</kbd>.</p>
<p class="calibre3">If styles become too unwieldy in HTML, we also have the option of writing in our component a function that returns the object hash, and setting that as an expression:</p>
<pre class="calibre19">&lt;div [ngStyle]= "getStyles()"&gt;&lt;/div&gt; </pre>
<p class="calibre3">Moreover, <kbd class="calibre13">getStyles</kbd> on the component looks as follows:</p>
<pre class="calibre19">getStyles () { 
    return { 
      'width':componentWidth, 
      ... 
    } 
} </pre>
<p class="calibre3"><kbd class="calibre13">ngClass</kbd> works on the same lines too, except that it is used to toggle one or multiple classes. For example, check out the following code:</p>
<pre class="calibre19">&lt;div [ngClass]= "{'required':inputRequired, 'email':whenEmail}"&gt;&lt;/div&gt; </pre>
<p class="calibre3">The <kbd class="calibre13">required</kbd> class is applied when <kbd class="calibre13">inputRequired</kbd> is <kbd class="calibre13">true</kbd> and is removed when it evaluates to <kbd class="calibre13">false</kbd>.</p>
<div class="packt_infobox">Directives (custom or platform) like any other Angular artifact, always belong to a module. To use them across modules, the module needs to be imported. Wondering where <kbd class="calibre24">ngStyle</kbd> is defined? <kbd class="calibre24">ngStyle</kbd> is part of the core framework module, <kbd class="calibre24">CommonModule,</kbd>, and has been imported in the workout runner module definition (<kbd class="calibre24">workout-runner.module.ts</kbd>). <kbd class="calibre24">CommonModule</kbd> defines a number of handy directives that are used across Angular.</div>
<p class="calibre3">Well! That covers everything we had to <span class="calibre6">learn</span> about our newly developed view.</p>
<div class="packt_infobox">And as described earlier, if you are having a problem with running the code, look at the Git branch <kbd class="calibre24">checkpoint2.2</kbd>. If not using Git, download the snapshot of <kbd class="calibre24">checkpoint2.2</kbd> (a ZIP file) from <span class="packt_screen"><a href="http://bit.ly/ng2be-checkpoint2-2" class="calibre21">http://bit.ly/ng2be-checkpoint2-2</a></span>. Refer to the <kbd class="calibre24">README.md</kbd> file in the <kbd class="calibre24">trainer</kbd> folder when setting up the snapshot for the first time.</div>
<p class="calibre3">Time to add some enhancements and learn a bit more about the framework!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Learning more about an exercise</h1>
                
            
            <article>
                
<p class="calibre3">For people who are doing this workout for the first time, it will be good to detail the steps involved in each exercise. We can also add references to some YouTube videos for each exercise to help the user understand the exercise better.</p>
<p class="calibre3">We are going to add the exercise description and instructions in the left panel and call it the <strong class="calibre5">description panel</strong>. We will also add references to YouTube videos in the right panel, which is the video player panel. To make things more modular and learn some new concepts, we are going to create independent components for each description panel and video panel.</p>
<p class="calibre3">The model data for this is already available. The <kbd class="calibre13">description</kbd> and <kbd class="calibre13">procedure</kbd> properties in the <kbd class="calibre13">Exercise</kbd> class (see <kbd class="calibre13">model.ts</kbd>) provide the necessary details about the exercise. The <kbd class="calibre13">videos</kbd> array contains some related YouTube video IDs, which will be used to fetch these videos.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding descriptions and video panels</h1>
                
            
            <article>
                
<p class="calibre3">An Angular app is nothing but a hierarchy of components, similar to a tree structure. As of now, <em class="calibre17">7 Minute Workout</em> has two components, the root component, <kbd class="calibre13">AppComponent</kbd>, and its child, <kbd class="calibre13">WorkoutRunnerComponent</kbd>, in line with the HTML component layout, which now looks as follows:</p>
<pre class="calibre19">&lt;abe-root&gt;<br class="title-page-name"/>    ...<br class="title-page-name"/>    &lt;abe-workout-runner&gt;...&lt;/abe-workout-runner&gt;<br class="title-page-name"/>&lt;/abe-root&gt;</pre>
<p class="calibre3">Run the app and do a view source to verify this hierarchy. As we all more components to implement new features in the application this component tree grows and branches out.</p>
<p class="calibre3">We are going to add two subcomponents to <kbd class="calibre13">WorkoutRunnerComponent</kbd>, one each to support the exercise description and exercise videos. While we could have added some HTML directly to the <kbd class="calibre13">WorkoutRunnerComponent</kbd> view, what we are hoping here is to learn a bit more about cross-component communication. Let's start with adding the description panel on the left and understand how a component can accept inputs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Component with inputs</h1>
                
            
            <article>
                
<p class="calibre3">Navigate to the <kbd class="calibre13">workour-runner</kbd> folder and generate a boilerplate exercise description component:</p>
<pre class="calibre19"><strong class="calibre1">ng generate component exercise-description -is</strong></pre>
<p class="calibre3">To the generated <kbd class="calibre13">exercise-description.component.ts</kbd> file, add the highlighted code:</p>
<pre class="calibre19">import { Component, OnInit, <strong class="calibre1">Input</strong> } from '@angular/core';<br class="title-page-name"/>...
export class ExerciseDescriptionComponent { 
<strong class="calibre1">  @Input() description: string; 
  @Input() steps: string; 
</strong>} </pre>
<p class="calibre3">The <kbd class="calibre13">@Input</kbd> decorator signifies that the component property is available for data binding. Before we dig into the <kbd class="calibre13">@Input</kbd> decorator, let's complete the view and integrate it with <kbd class="calibre13">WorkoutRunnerComponent</kbd>.</p>
<p class="calibre3">Copy the view definition for exercise description, <kbd class="calibre13">exercise-description.component.html</kbd>, from the Git branch <kbd class="calibre13">checkpoint2.3</kbd>, in the <kbd class="calibre13">workout-runner/exercise-description</kbd> folder (GitHub location: <a href="http://bit.ly/ng6be-2-3-exercise-description-component-html" class="calibre10">http://bit.ly/ng6be-2-3-exercise-description-component-html</a>). Look at the highlighted HTML for the exercise description:</p>
<pre class="calibre19">&lt;div class="card-body"&gt;<br class="title-page-name"/>    &lt;div class="card-text"&gt;<strong class="calibre1">{{description}}</strong>&lt;/div&gt;<br class="title-page-name"/>&lt;/div&gt; 
...  
&lt;div class="card-text"&gt;<br class="title-page-name"/>    <strong class="calibre1">{{steps}}</strong><br class="title-page-name"/>&lt;/div&gt; </pre>
<p class="calibre3">The preceding interpolation references the input properties of <kbd class="calibre13">ExerciseDescriptionComponent</kbd>: <kbd class="calibre13">description</kbd> and <kbd class="calibre13">steps</kbd>.</p>
<p class="calibre3">The component definition is complete. Now, we just need to reference <kbd class="calibre13">ExerciseDescriptionComponent</kbd> in <kbd class="calibre13">WorkoutRunnerComponent</kbd> and provide values for <kbd class="calibre13">description</kbd> and <kbd class="calibre13">steps</kbd> for the <kbd class="calibre13">ExerciseDescriptionComponent</kbd> view to render correctly.</p>
<p class="calibre3">Open <kbd class="calibre13">workout-runner.component.html</kbd> and update the HTML fragments as highlighted in the following code. Add a new div called <kbd class="calibre13">description-panel</kbd> before the <kbd class="calibre13">exercise-pane</kbd> div and adjust some styles on the <kbd class="calibre13">exercise-pane</kbd> div, as follows:</p>
<pre class="calibre19">&lt;div class="row"&gt;
    <strong class="calibre1">&lt;div id="description-panel" class="col-sm-3"&gt;</strong><br class="title-page-name"/><strong class="calibre1">        &lt;abe-exercise-description <br class="title-page-name"/>            [description]="currentExercise.exercise.description"</strong><br class="title-page-name"/><strong class="calibre1">            [steps]="currentExercise.exercise.procedure"&gt;&lt;/abe-exercise-description&gt;</strong><br class="title-page-name"/><strong class="calibre1">   &lt;/div&gt;</strong><br class="title-page-name"/>   &lt;div id="exercise-pane" <strong class="calibre1">class="col-sm-6"</strong>&gt;  
   ... </pre>
<p class="calibre3">If the app is running, the description panel should show up on the left with the relevant exercise details.</p>
<div class="packt_infobox"><kbd class="calibre24">WorkoutRunnerComponent</kbd> was able to use <kbd class="calibre24">ExerciseDescriptionComponent</kbd> because it has been declared on <kbd class="calibre24">WorkoutRunnerModule</kbd> (see the <kbd class="calibre24">workout-runner.module.ts</kbd> declaration property). The Angular CLI component generator does this work for us.</div>
<p class="calibre3">Look back at the <kbd class="calibre13">abe-exercise-description</kbd> declaration in the preceding view. We are referring to the <kbd class="calibre13">description</kbd> and <kbd class="calibre13">steps</kbd> properties in the same manner as we did with the HTML element properties earlier in the chapter (<kbd class="calibre13">&lt;img [src]='expression' ...</kbd>). Simple, intuitive, and very elegant!</p>
<p class="calibre3">The Angular data binding infrastructure makes sure that whenever the <kbd class="calibre13">currentExercise.exercise.description</kbd> and <kbd class="calibre13">currentExercise.exercise.procedure</kbd> properties on <kbd class="calibre13">WorkoutRunnerComponent</kbd> change, the bound properties on <kbd class="calibre13">ExerciseDescriptionComponent</kbd>, <kbd class="calibre13">description</kbd>, and <kbd class="calibre13">steps</kbd> are also updated.</p>
<div class="packt_infobox">The <kbd class="calibre24">@Input</kbd> decoration can take a property alias as a parameter, which means the following: consider a property declaration such as: <kbd class="calibre24">@Input("myAwesomeProperty") myProperty:string</kbd>. It can be referenced in the view as follows: <kbd class="calibre24">&lt;my-component [myAwesomeProperty]="expression"....</kbd></div>
<p class="calibre3">The power of the Angular binding infrastructure allows us to use any component property as a bindable property by attaching the <kbd class="calibre13">@Input</kbd> decorator (and <kbd class="calibre13">@Output</kbd> too) to it. We are not limited to basic data types such as <kbd class="calibre13">string</kbd>, <kbd class="calibre13">number</kbd>, and <kbd class="calibre13">boolean</kbd>; there can be complex objects too, which we will see next as we add the video player:</p>
<div class="packt_tip"><br class="calibre27"/>
The <kbd class="calibre24">@Input</kbd> decorator can be applied to complex objects too.</div>
<p class="calibre3">Generate a new component in the <kbd class="calibre13">workout-runner</kbd> directory for the video player:</p>
<pre class="calibre19"><strong class="calibre1">ng generate component video-player -is</strong></pre>
<p class="calibre3">Update the generated boilerplate code by copying implementation from <kbd class="calibre13">video-player.component.ts</kbd> and <kbd class="calibre13">video-player.component.html</kbd> available in the Git branch <kbd class="calibre13">checkpoint2.3</kbd> in the <kbd class="calibre13">trainer/src/components/workout-runner/video-player</kbd> folder (GitHub location: <a href="http://bit.ly/ng6be-2-3-video-player" class="calibre10">http://bit.ly/ng6be-2-3-video-player</a>).</p>
<p class="calibre3">Let's look at the implementation for the video player. Open <kbd class="calibre13">video-player.component.ts</kbd> and check out the <kbd class="calibre13">VideoPlayerComponent</kbd> class:</p>
<pre class="calibre19">export class VideoPlayerComponent implements OnInit, OnChanges { 
  private youtubeUrlPrefix = '//www.youtube.com/embed/'; 
 
  @Input() videos: Array&lt;string&gt;; 
  safeVideoUrls: Array&lt;SafeResourceUrl&gt;; 
 
  constructor(private sanitizer: DomSanitizationService) { } 
 
  ngOnChanges() { 
    this.safeVideoUrls = this.videos ? 
        this.videos 
            .map(v =&gt; this.sanitizer.bypassSecurityTrustResourceUrl(this.youtubeUrlPrefix + v)) 
    : this.videos; 
  } 
} </pre>
<p class="calibre3">The <kbd class="calibre13">videos</kbd> input property here takes an array of strings (YouTube video codes). While we take the <kbd class="calibre13">videos</kbd> array as input, we do not use this array directly in video player view; instead, we transform the input array into a new array of <kbd class="calibre13">safeVideoUrls</kbd> and bind it. This can be confirmed by looking at the view implementation:</p>
<pre class="calibre19">&lt;div *ngFor="let video of safeVideoUrls"&gt; 
   &lt;iframe width="198" height="132" [src]="video" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt; 
&lt;/div&gt; </pre>
<p class="calibre3">The view also uses a new Angular directive called <kbd class="calibre13">ngFor</kbd> to bind to the <kbd class="calibre13">safeVideoUrls</kbd> array. The <kbd class="calibre13">ngFor</kbd> directive belongs to a class of directives called <strong class="calibre5">structural directives</strong>. The directive's job is to take an HTML fragment and regenerate it based on the number of elements in the bound collection.</p>
<p class="calibre3">If you are confused about how the <kbd class="calibre13">ngFor</kbd> directive works with <kbd class="calibre13">safeVideoUrls</kbd>, and why we need to generate <kbd class="calibre13">safeVideoUrls</kbd> instead of using the <kbd class="calibre13">videos</kbd> input array, wait for a while as we are shortly going to address these queries. But, let's first complete the integration of <kbd class="calibre13">VideoPlayerComponent</kbd> with <kbd class="calibre13">WorkoutRunnerComponent</kbd> to see the final outcome.</p>
<p class="calibre3">Update the <kbd class="calibre13">WorkoutRunnerComponent</kbd> view by adding the component declaration after the <kbd class="calibre13">exercise-pane</kbd> div:</p>
<pre class="calibre19">&lt;div id="video-panel" class="col-sm-3"&gt;<br class="title-page-name"/>    &lt;abe-video-player [videos]="currentExercise.exercise.videos"&gt;&lt;/abe-video-player&gt;<br class="title-page-name"/>&lt;/div&gt; </pre>
<p class="calibre3">The <kbd class="calibre13">VideoPlayerComponent</kbd>'s <kbd class="calibre13">videos</kbd> property binds to the exercise's videos collection.</p>
<p class="calibre3">Start/refresh the app and the video thumbnails should show up on the right.</p>
<div class="packt_infobox">If you are having a problem with running the code, look at the Git branch <kbd class="calibre24">checkpoint2.3</kbd> for a working version of what we have done thus far. You can also download the snapshot of <kbd class="calibre24">checkpoint2.3</kbd> (a ZIP file) from <a href="http://bit.ly/ng6be-checkpoint-2-3" class="calibre21">http://bit.ly/ng6be-checkpoint-2-3</a>. Refer to the <kbd class="calibre24">README.md</kbd> file in the <kbd class="calibre24">trainer</kbd> folder when setting up the snapshot for the first time.</div>
<p class="calibre3">Now, it's time to go back and look at the parts of the <kbd class="calibre13">VideoPlayerComponent</kbd> implementation. We specifically need to understand:</p>
<ul class="calibre11">
<li class="calibre12">How the <kbd class="calibre13">ngFor</kbd> directive works</li>
<li class="calibre12">Why there is a need to transform the input <kbd class="calibre13">videos</kbd> array into <kbd class="calibre13">safeVideoUrls</kbd></li>
<li class="calibre12">The significance of the Angular component life cycle event <kbd class="calibre13">OnChanges</kbd> (used in the video player)</li>
</ul>
<p class="calibre3">To start with, it's time to formally introduce <kbd class="calibre13">ngFor</kbd> and the class of directives it belongs to: structural directives.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Structural directives</h1>
                
            
            <article>
                
<p class="calibre3">The third categorization of directives, structural directives, work on the components/elements to manipulate their layout.</p>
<p class="calibre3">The Angular documentation describes structural directives in a succinct manner:</p>
<div class="packt_quote">"Instead of defining and controlling a view like a Component Directive, or modifying the appearance and behavior of an element like an Attribute Directive, the Structural Directive manipulates the layout by adding and removing entire element sub-trees."</div>
<p class="calibre3">Since we have already touched upon component directives (such as <kbd class="calibre13">workout-runner</kbd> and <kbd class="calibre13">exercise-description</kbd>) and attribute directives (such as <kbd class="calibre13">ngClass</kbd> and <kbd class="calibre13">ngStyle</kbd>), we can very well contrast their behaviors with structural directives.</p>
<p class="calibre3">The <kbd class="calibre13">ngFor</kbd> directive belongs to this class. We can easily identify such directives by the <kbd class="calibre13">*</kbd> prefix. Other than <kbd class="calibre13">ngFor</kbd>, Angular comes with some other structural directives such as <kbd class="calibre13">ngIf</kbd> and <kbd class="calibre13">ngSwitch</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The ever-so-useful NgForOf</h1>
                
            
            <article>
                
<p class="calibre3">Every templating language has constructs that allow the templating engine to generate HTML (by repetition). Angular has <kbd class="calibre13">NgForOf</kbd>. The <kbd class="calibre13">NgForOf</kbd> directive is a super useful directive used to duplicate a piece of an HTML fragment n number of times. Let's again look at how we have used <kbd class="calibre13">NgForOf</kbd> in the video player:</p>
<pre class="calibre19">&lt;div *ngFor="let video of safeVideoUrls"&gt; 
   &lt;iframe width="198" height="132" [src]="video" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt; 
&lt;/div&gt;</pre>
<div class="packt_infobox">The directive selector for <kbd class="calibre24">NgForOf</kbd> is <kbd class="calibre24">{selector: '[ngFor][ngForOf]'}</kbd>, so we can use either <kbd class="calibre24">ngFor</kbd> or <kbd class="calibre24">ngForOf</kbd> in the view template. We also at times refer to this directive as <kbd class="calibre24">ngFor</kbd>.</div>
<p class="calibre3">The preceding code repeats the <kbd class="calibre13">div</kbd> fragment for each exercise video (using the <kbd class="calibre13">safeVideoUrls</kbd> array). The <kbd class="calibre13">let video of safeVideoUrls</kbd> string expression is interpreted as follows: take each video in the <kbd class="calibre13">safeVideoUrls</kbd> array and assign it to a template input variable, <kbd class="calibre13">video</kbd>.</p>
<p class="calibre3">This input variable can now be referenced inside the <kbd class="calibre13">ngFor</kbd> template HTML, as we do when we set the <kbd class="calibre13">src</kbd> property binding.</p>
<p class="calibre3">Interestingly, the string assigned to the <kbd class="calibre13">ngFor</kbd> directive is not a typical Angular expression. Instead, it's a <strong class="calibre5">microsyntax</strong>—a micro language, which the Angular engine can parse.</p>
<div class="packt_infobox"><br class="calibre27"/>
You can learn more about microsyntax in Angular's developer guide: <a href="http://bit.ly/ng6be-micro-syntax" class="calibre21">http://bit.ly/ng6be-micro-syntax</a>.</div>
<p class="calibre3">This microsyntax exposes a number of iteration context properties that we can assign to template input variables and use them inside the <kbd class="calibre13">ngFor</kbd> HTML block.</p>
<p class="calibre3">One such example is <kbd class="calibre13">index</kbd>. <kbd class="calibre13">index</kbd> increases from 0 to the length of the array for each iteration, something similar to a <kbd class="calibre13">for</kbd> loop, in any programming language. The following example shows how to capture it:</p>
<pre class="calibre19">&lt;div *ngFor="let video of videos; <strong class="calibre1">let i=index</strong>"&gt; 
     &lt;div&gt;This is video - <strong class="calibre1">{{i}}</strong>&lt;/div&gt; 
&lt;/div&gt; </pre>
<p class="calibre3">Other than <kbd class="calibre13">index</kbd>, there are some more iteration context variables; these include <kbd class="calibre13">first</kbd>, <kbd class="calibre13">last</kbd>, <kbd class="calibre13">even</kbd>, and <kbd class="calibre13">odd</kbd>. This context data allows us to do some nifty stuff. Consider this example:</p>
<pre class="calibre19">&lt;div *ngFor="let video of videos; let i=index; <strong class="calibre1">let f=first</strong>"&gt; 
     &lt;div <strong class="calibre1">[class.special]="f"</strong>&gt;This is video - {{i}}&lt;/div&gt; 
&lt;/div&gt; </pre>
<p class="calibre3">It applies a <kbd class="calibre13">special</kbd> class to the first video <kbd class="calibre13">div</kbd>.</p>
<p class="calibre3">The <kbd class="calibre13">NgForOf</kbd> directive can be applied to HTML elements as well as our custom components. This is a valid use of <kbd class="calibre13">NgForOf</kbd>:</p>
<pre class="calibre19">&lt;user-profile *ngFor="let userDetail of users" [user]= "userDetail"&gt;&lt;/user-profile&gt;</pre>
<p class="calibre3">Always remember to add an asterisk (<kbd class="calibre13">*</kbd>) before <kbd class="calibre13">ngFor</kbd> (and other structural directives). <kbd class="calibre13">*</kbd> has a significance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Asterisk (*) in structural directives</h1>
                
            
            <article>
                
<p class="calibre3">The <kbd class="calibre13">*</kbd> prefix is a terser format to represent a structural directive. Take, for example, the usage of <kbd class="calibre13">ngFor</kbd> by the video player. The <kbd class="calibre13">ngFor</kbd> template:</p>
<pre class="calibre19">&lt;div *ngFor="let video of safeVideoUrls"&gt; 
   &lt;iframe width="198" height="132" [src]="video" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt; 
&lt;/div&gt;</pre>
<p class="calibre3">Actually expands to the following:</p>
<pre class="calibre19">&lt;ng-template ngFor let-video [ngForOf]="safeVideoUrls"&gt;  <br class="title-page-name"/>    &lt;div&gt;<br class="title-page-name"/>        &lt;iframe width="198" height="132"  [src]="video" ...&gt;&lt;/iframe&gt;  <br class="title-page-name"/>    &lt;/div&gt; <br class="title-page-name"/>&lt;/ng-template&gt;  </pre>
<p class="calibre3">The <kbd class="calibre13">ng-template</kbd> tag is an Angular element that has a declaration for <kbd class="calibre13">ngFor</kbd>, a template input variable (<kbd class="calibre13">video</kbd>), and a property (<kbd class="calibre13">ngForOf</kbd>) that points to the <kbd class="calibre13">safeVideoUrls</kbd> array. Both the preceding declarations are a valid usage of <kbd class="calibre13">ngFor</kbd>.</p>
<p class="calibre3">Not sure about you, but I prefer the terser first format for <kbd class="calibre13">ngFor</kbd>!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">NgForOf performance</h1>
                
            
            <article>
                
<p class="calibre3">Since <kbd class="calibre13">NgForOf</kbd> generates HTML based on collection elements, it is notorious for causing performance issues. But we cannot blame the directive. It does what it is supposed to do: iterate and generate elements! If the underlying collection is huge, UI rendering can take a performance hit, especially if the collection changes too often. The cost of continuously destroying and creating elements in response to a changing collection can quickly become prohibitive.</p>
<p class="calibre3">One of the performance tweaks for <kbd class="calibre13">NgForOf</kbd> allows us to alter the behavior of <kbd class="calibre13">ngForOf</kbd> when it comes to creating and destroying DOM elements (when the underlying collection elements are added or removed).</p>
<p class="calibre3">Imagine a scenario where we frequently get an array of objects from the server and bind it to the view using <kbd class="calibre13">NgForOf</kbd>. The default behavior of <kbd class="calibre13">NgForOf</kbd> is to regenerate the DOM every time we refresh the list (since Angular does a standard object equality check). However, as developers, we may very well know not much has changed. Some new objects may have been added, some removed, and maybe some modified. But Angular just regenerates the complete DOM.</p>
<p class="calibre3">To alleviate this situation, Angular allows us to specify a custom <strong class="calibre5">tracking function</strong>, which lets Angular know when two objects being compared are equal. Have a look at the following function:</p>
<pre class="calibre19">trackByUserId(index: number, hero: User) { return user.id; } </pre>
<p class="calibre3">A function such as this can be used in the <kbd class="calibre13">NgForOf</kbd> template to tell Angular to compare the <em class="calibre17">user</em> object based on its <kbd class="calibre13">id</kbd> property instead of doing a reference equality check.</p>
<p class="calibre3">This is how we then use the preceding function in the <kbd class="calibre13">NgForOf</kbd> template:</p>
<pre class="calibre19">&lt;div *ngFor="let user of users; trackBy: trackByUserId"&gt;{{user.name}}&lt;/div&gt; </pre>
<p class="calibre3"><kbd class="calibre13">NgForOf</kbd> will now avoid recreating DOM for users with IDs already rendered.</p>
<p class="calibre3">Remember, Angular may still update the existing DOM elements if the bound properties of a user have changed.</p>
<p class="calibre3">That's enough on the <kbd class="calibre13">ngFor</kbd> directive; let's move ahead.</p>
<p class="calibre3">We still need to understand the role of the <kbd class="calibre13">safeVideoUrls</kbd> and the <kbd class="calibre13">OnChange</kbd> life cycle events in the <kbd class="calibre13">VideoPlayerComponent</kbd> implementation. Let's tackle the former first and understand the need for <kbd class="calibre13">safeVideoUrls</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Angular security</h1>
                
            
            <article>
                
<p class="calibre3">The easiest way to understand why we need to bind to <kbd class="calibre13">safeVideoUrls</kbd> instead of the <kbd class="calibre13">videos</kbd> input property is by trying the <kbd class="calibre13">videos</kbd> array out. Replace the existing <kbd class="calibre13">ngFor</kbd> fragment HTML with the following:</p>
<pre class="calibre19">&lt;div *ngFor="let video of <strong class="calibre1">videos</strong>"&gt; 
    &lt;iframe width="198" height="132"  <br class="title-page-name"/>        [src]="'//www.youtube.com/embed/' + video"  frameborder="0" allowfullscreen&gt;&lt;/iframe&gt; 
&lt;/div&gt;</pre>
<p class="calibre3">And look at the browser's console log (a page refresh may be required). There are a bunch of errors thrown by the framework, such as:</p>
<p class="calibre3"><kbd class="calibre13">Error: unsafe value used in a resource URL context (see http://g.co/ng/security#xss)</kbd></p>
<p class="calibre3">No prize for guessing what is happening! Angular is trying to safeguard our application against a <strong class="calibre5">Cross-Site Scripting</strong> (<strong class="calibre5">XSS</strong>) attack.</p>
<p class="calibre3">Such an attack enables the attacker to inject malicious code into our web pages. Once injected, the malicious code can read data from the current site context. This allows it to steal confidential data and also impersonate the logged-in user, hence gaining access to privileged resources.</p>
<p class="calibre3">Angular has been designed to block these attacks by sanitizing any external code/script that is injected into an Angular view. Remember, content can be injected into a view through a number of mechanisms, including property/attribute/style bindings or interpolation.</p>
<p class="calibre3">Consider an example of binding HTML markup through a component model to the <kbd class="calibre13">innerHTML</kbd> property of an HTML element (property binding):</p>
<pre class="calibre19">this.htmlContent = '&lt;span&gt;HTML content.&lt;/span&gt;'    // Component<br class="title-page-name"/><br class="title-page-name"/>&lt;div [innerHTML]="htmlContent"&gt; &lt;!-- View --&gt;</pre>
<p class="calibre3">While the HTML content is emitted, any unsafe content (such as a <em class="calibre17">script</em>) if present is stripped.</p>
<p class="calibre3">But what about Iframes? In our preceding example, Angular is blocking property binding to Iframe's <kbd class="calibre13">src</kbd> property too. This is a warning against third-party content being embedded in our own site using Iframe. Angular prevents this too.</p>
<p class="calibre3">All in all, the framework defines four security contexts around content sanitization. These include:</p>
<ol class="calibre14">
<li value="1" class="calibre12"><strong class="calibre1">HTML content sanitization</strong>, when HTML content is bound using the <kbd class="calibre13">innerHTML</kbd> property</li>
<li value="2" class="calibre12"><strong class="calibre1">Style sanitization</strong>, when binding CSS into the <kbd class="calibre13">style</kbd> property</li>
<li value="3" class="calibre12"><strong class="calibre1">URL sanitization</strong>, when URLs are used with tags such as <kbd class="calibre13">anchor</kbd> and <kbd class="calibre13">img</kbd></li>
<li value="4" class="calibre12"><strong class="calibre1">Resource sanitization</strong>, when using <kbd class="calibre13">Iframes</kbd> or <kbd class="calibre13">script</kbd> tags; in this case, content cannot be sanitized and hence it is blocked by default</li>
</ol>
<p class="calibre3">Angular is trying its best to keep us out of danger. But at times, we know that the content is safe to render and hence want to circumvent the default sanitization behavior.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Trusting safe content</h1>
                
            
            <article>
                
<p class="calibre3">To let Angular know that the content being bound is safe, we use <kbd class="calibre13">DomSanitizer</kbd> and call the appropriate method based on the security contexts just described. The available functions are as follows:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">bypassSecurityTrustHtml</kbd></li>
<li class="calibre12"><kbd class="calibre13">bypassSecurityTrustScript</kbd></li>
<li class="calibre12"><kbd class="calibre13">bypassSecurityTrustStyle</kbd></li>
<li class="calibre12"><kbd class="calibre13">bypassSecurityTrustUrl</kbd></li>
<li class="calibre12"><kbd class="calibre13">bypassSecurityTrustResourceUrl</kbd></li>
</ul>
<p class="calibre3">In our video player implementation, we use <kbd class="calibre13">bypassSecurityTrustResourceUrl</kbd>; it converts the video URL into a trusted <kbd class="calibre13">SafeResourceUrl</kbd> object:</p>
<pre class="calibre19">this.videos.map(v =&gt; this.sanitizer.bypassSecurityTrustResourceUrl(this.youtubeUrlPrefix + v)) </pre>
<p class="calibre3">The <kbd class="calibre13">map</kbd> method transforms the videos array into a collection of <kbd class="calibre13">SafeResourceUrl</kbd> objects and assigns it to <kbd class="calibre13">safeVideoUrls</kbd>.</p>
<p class="calibre3">Each of the methods listed previously takes a string parameter. This is the content we want Angular to know is safe. The return object, which could be any of <kbd class="calibre13">SafeStyle</kbd>, <kbd class="calibre13">SafeHtml</kbd>, <kbd class="calibre13">SafeScript</kbd>, <kbd class="calibre13">SafeUrl</kbd>, or <kbd class="calibre13">SafeResourceUrl</kbd>, can then be bound to the view.</p>
<div class="packt_infobox"><br class="calibre27"/>
A comprehensive treatment of this topic is available in the framework security guide available at <a href="http://bit.ly/ng6be-security" class="calibre21">http://bit.ly/ng6be-security</a>. A highly recommended read!</div>
<p class="calibre3">The last question to answer is why do this in the <kbd class="calibre13">OnChanges</kbd> Angular life cycle event?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">OnChange life cycle event</h1>
                
            
            <article>
                
<p class="calibre3">The <kbd class="calibre13">OnChanges</kbd> life cycle event is triggered whenever the component's input(s) change. In the case of <kbd class="calibre13">VideoPlayerComponent</kbd>, it is the <kbd class="calibre13">videos</kbd> array input property that changes whenever a new exercise is loaded. We use this life cycle event to recreate the <kbd class="calibre13">safeVideoUrls</kbd> array and re-bind it to the view. Simple!</p>
<p class="calibre3">Video panel implementation is now complete. Let's add a few more minor enhancements and explore it a bit more in Angular.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Formatting exercise steps with innerHTML binding</h1>
                
            
            <article>
                
<p class="calibre3">One of the sore points in the current app is the formatting of the exercise steps. It's a bit difficult to read these steps.</p>
<p class="calibre3">The steps should either have a line break (<kbd class="calibre13">&lt;br&gt;</kbd>) or be formatted as an HTML <kbd class="calibre13">list</kbd> for easy readability. This seems to be a straightforward task, and we can just go ahead and change the data that is bound to the step interpolation, or write a pipe that can add some HTML formatting using the line delimiting convention (<kbd class="calibre13">.</kbd>). For a quick verification, let's update the first exercise steps in <kbd class="calibre13">workout-runner.component.ts</kbd> by adding a break (<kbd class="calibre13">&lt;br&gt;</kbd>) after each line:</p>
<pre class="calibre19">`Assume an erect position, with feet together and arms at your side. &lt;br&gt; 
 Slightly bend your knees, and propel yourself a few inches into the air. &lt;br&gt; 
 While in air, bring your legs out to the side about shoulder width or slightly wider. &lt;br&gt; 
 ... </pre>
<p class="calibre3">As the workout restarts, look at the first exercise steps. The output does not match our expectations, as shown here:</p>
<div class="packt_figure"><img src="../images/00016.gif" class="calibre41"/></div>
<div class="packt_figure"/>
<p class="calibre3">The break tags were literally rendered in the browser. Angular did not render the interpolation as HTML; instead, it escaped the HTML characters, and we know why, security!</p>
<p class="calibre3">How to fix it? Easy! Replace the interpolation with the property binding to bind step data to the element's <kbd class="calibre13">innerHTML</kbd> property (in <kbd class="calibre13">exercise-description.html</kbd>), and you are done!</p>
<pre class="calibre19">&lt;div class="card-text" [innerHTML]="steps"&gt; </pre>
<p class="calibre3">Refresh the workout page to confirm.</p>
<div class="packt_tip"><span class="packt_screen">Preventing Cross-Site Scripting Security (XSS) issues</span><br class="calibre27"/>
By using <kbd class="calibre24">innerHTML</kbd>, we instruct Angular to not escape HTML, but Angular still sanitizes the input HTML as described in the security section earlier. It removes things such as <kbd class="calibre24">&lt;script&gt;</kbd> tags and other JavaScript to safeguard against XSS attacks. If you want to dynamically inject styles/scripts into HTML, use the <kbd class="calibre24">DomSanitizer</kbd> to bypass this sanitization check.</div>
<p class="calibre3">Time for another enhancement! It's time to learn about Angular pipes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Displaying the remaining workout duration using pipes</h1>
                
            
            <article>
                
<p class="calibre3">It will be nice if we can tell the user the time left to complete the workout and not just the duration of the exercise in progress. We can add a countdown timer somewhere in the exercise pane to show the overall time remaining.</p>
<p class="calibre3">The approach that we are going to take here is to define a component property called <kbd class="calibre13">workoutTimeRemaining</kbd>. This property will be initialized with the total time at the start of the workout and will reduce with every passing second until it reaches zero. Since <kbd class="calibre13">workoutTimeRemaining</kbd> is a numeric value, but we want to display a timer in the <kbd class="calibre13">hh:mm:ss</kbd> format, we need to make a conversion between the seconds data and the time format. <strong class="calibre5">Angular pipes</strong> are a great option for implementing such a feature.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Angular pipes</h1>
                
            
            <article>
                
<p class="calibre3">The primary aim of a pipe is to format the data displayed in the view. <strong class="calibre5">Pipes</strong> allow us to package this content transformation logic (formatting) as a reusable element. The framework itself comes with multiple predefined pipes, such as <kbd class="calibre13">date</kbd>, <kbd class="calibre13">currency</kbd>, <kbd class="calibre13">lowercase</kbd>, <kbd class="calibre13">uppercase</kbd>, <kbd class="calibre13">slice</kbd>, and others.</p>
<p class="calibre3">This is how we use a pipe with a view:</p>
<pre class="calibre19">{{expression | pipeName:inputParam1}} </pre>
<p class="calibre3">An expression is followed by the pipe symbol (<kbd class="calibre13">|</kbd>), which is followed by the pipe name and then an optional parameter (<kbd class="calibre13">inputParam1</kbd>) separated by a colon (<kbd class="calibre13">:</kbd>). If the pipe takes multiple inputs, they can be placed one after another separated by a colon, such as the inbuilt <kbd class="calibre13">slice</kbd> pipe, which can slice an array or string:</p>
<pre class="calibre19">{{fullName | slice:0:20}} //renders first 20 characters  </pre>
<p class="calibre3">The parameter passed to the pipe can be a constant or a component property, which implies we can use template expressions with pipe parameter. See the following example:</p>
<pre class="calibre19">{{fullName | slice:0:truncateAt}} //renders based on value truncateAt </pre>
<p class="calibre3">Here are some examples of the use of the <kbd class="calibre13">date</kbd> pipe, as described in the Angular <kbd class="calibre13">date</kbd> documentation. Assume that <kbd class="calibre13">dateObj</kbd> is initialized to <em class="calibre17">June 15,</em> 2015 <em class="calibre17">21:43:11</em> and locale is <em class="calibre17">en-US</em>:</p>
<pre class="calibre19">{{ dateObj | date }}               // output is 'Jun 15, 2015        ' 
{{ dateObj | date:'medium' }}      // output is 'Jun 15, 2015, 9:43:11 PM' 
{{ dateObj | date:'shortTime' }}   // output is '9:43 PM            ' 
{{ dateObj | date:'mmss' }}        // output is '43:11'     </pre>
<p class="calibre3">Some of the most commonly used pipes are the following:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">date</strong>: As we just saw, the date filter is used to format the date in a specific manner. This filter supports quite a number of formats and is locale-aware too. To know about the other formats supported by the date pipe, check out the framework documentation at <a href="http://bit.ly/ng2-date" class="calibre10">http://bit.ly/ng2-date</a>.</li>
<li class="calibre12"><strong class="calibre1">uppercase</strong> and <strong class="calibre1">lowercase</strong>: These two pipes, as the name suggests, change the case of the string input.</li>
<li class="calibre12"><strong class="calibre1">decimal</strong> and <strong class="calibre1">percent</strong>: <kbd class="calibre13">decimal</kbd> and <kbd class="calibre13">percent</kbd> pipes are there to format decimal and percentage values based on the current browser locale.</li>
<li class="calibre12"><strong class="calibre1">currency</strong>: This is used to format numeric values as a currency based on the current browser locale:</li>
</ul>
<pre class="calibre19"><strong class="calibre1">    {{14.22|currency:"USD" }} &lt;!-Renders USD 14.22 --&gt;</strong> 
    {{14.22|currency:"USD":'symbol'}}  &lt;!-Renders $14.22 --&gt;</pre>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">json</strong>: This is a handy pipe for debugging that can transform any input into a string using <kbd class="calibre13">JSON.stringify</kbd>. We made good use of it at the start of this chapter to render the <kbd class="calibre13">WorkoutPlan</kbd> object (see the Checkpoint 2.1 code).</li>
<li class="calibre12"><strong class="calibre1">slice:</strong> This pipe allows us to split a list or a string value to create a smaller trimmed down list/string. We saw an example in the preceding code.</li>
</ul>
<p class="calibre3">We are not going to cover the preceding pipes in detail. From a development perspective, as long as we know what pipes are there and what they are useful for, we can always refer to the platform documentation for exact usage instructions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pipe chaining</h1>
                
            
            <article>
                
<p class="calibre3">A really powerful feature of pipes is that they can be chained, where the output from one pipe can serve as the input to another pipe. Consider this example:</p>
<pre class="calibre19">{{fullName | slice:0:20 | uppercase}} </pre>
<p class="calibre3">The first pipe slices the first 20 characters of <kbd class="calibre13">fullName</kbd> and the second pipe transforms them to uppercase.</p>
<p class="calibre3">Now that we have seen what pipes are and how to use them, why not implement one for the <em class="calibre17">7 Minute Workout</em> app: a <strong class="calibre5">seconds to time</strong> pipe?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing a custom pipe - SecondsToTimePipe</h1>
                
            
            <article>
                
<p class="calibre3"><kbd class="calibre13">SecondsToTimePipe</kbd>, as the name suggests, should convert a numeric value into the <kbd class="calibre13">hh:mm:ss</kbd> format.</p>
<p class="calibre3">Create a folder <kbd class="calibre13">shared</kbd> in the <kbd class="calibre13">workout-runner</kbd> folder and from the shared folder invoke this CLI command to generate the pipe boilerplate:</p>
<pre class="calibre19"><strong class="calibre1">ng generate pipe seconds-to-time</strong></pre>
<div class="packt_infobox">The <kbd class="calibre24">shared</kbd> folder has been created to add common components/directives/pipes that can be used in the <kbd class="calibre24">workout-runner</kbd> module. It is a convention we follow to organize shared code at different levels. In the future, we can create a shared folder at the app module level, which has artifacts shared globally. In fact, if the second to time pipe needs to be used across other application modules, it can also be moved into the app module.</div>
<p class="calibre3">Copy the following <kbd class="calibre13">transform</kbd> function implementation into <kbd class="calibre13">seconds-to-time.pipe.ts</kbd>(the definition can also be downloaded from the Git branch <kbd class="calibre13">checkpoint.2.4</kbd> on the GitHub site at <a href="http://bit.ly/nng6be-2-4-seconds-to-time-pipe-ts" class="calibre10">http://bit.ly/nng6be-2-4-seconds-to-time-pipe-ts</a>):</p>
<pre class="calibre19">export class SecondsToTimePipe implements PipeTransform { 
  <strong class="calibre1">transform(value: number): any { 
    if (!isNaN(value)) { 
      const hours = Math.floor(value / 3600);<br class="title-page-name"/>      const minutes = Math.floor((value - (hours * 3600)) / 60);<br class="title-page-name"/>      const seconds = value - (hours * 3600) - (minutes * 60);<br class="title-page-name"/><br class="title-page-name"/>      return ('0' + hours).substr(-2) + ':'<br class="title-page-name"/>        + ('0' + minutes).substr(-2) + ':'<br class="title-page-name"/>        + ('0' + seconds).substr(-2);
    } 
    return; 
  }</strong> 
} </pre>
<p class="calibre3">In an Angular pipe, the implementation logic goes into the <kbd class="calibre13">transform</kbd> function. Defined as part of the <kbd class="calibre13">PipeTransform</kbd> interface, the preceding <kbd class="calibre13">transform</kbd> function transforms the input seconds value into an <em class="calibre17">hh:mm:ss</em> string. The first parameter to the <kbd class="calibre13">transform</kbd> function is the pipe input. The subsequent parameters, if provided, are the arguments to the pipe, passed using a colon separator (<kbd class="calibre13">pipe:argument1:arugment2..</kbd>) from the view.</p>
<p class="calibre3">For <kbd class="calibre13">SecondsToTimePipe</kbd>, while Angular CLI generates a boilerplate argument (<kbd class="calibre13">args?:any</kbd>), we do not make use of any pipe argument as the implementation does not require it.</p>
<p class="calibre3">The pipe implementation is quite straightforward, as we convert seconds into hours, minutes, and seconds. Then, we concatenate the result into a string value and return the value. The addition of 0 on the left for each of the <kbd class="calibre13">hours</kbd>, <kbd class="calibre13">minutes</kbd>, and <kbd class="calibre13">seconds</kbd> variables is done to format the value with a leading 0 in case the calculated value for hours, minutes, or seconds is less than 10.</p>
<p class="calibre3">The pipe that we just created is just a standard TypeScript class. It's the Pipe decorator (<kbd class="calibre13">@Pipe</kbd>) that instructs Angular to treat this class as a pipe:</p>
<pre class="calibre19">@Pipe({ 
  name: 'secondsToTime' 
}) </pre>
<p class="calibre3">The pipe definition is complete, but to use the pipe in <kbd class="calibre13">WorkoutRunnerComponent</kbd> the pipe has to be declared on <kbd class="calibre13">WorkoutRunnerModule.</kbd> Angular CLI has already done this for us as part of the boilerplate generation (see the <kbd class="calibre13">declaration</kbd> section in <kbd class="calibre13">workout-runner.module.ts</kbd>).</p>
<p class="calibre3">Now we just need to add the pipe in the view. Update <kbd class="calibre13">workout-runner.component.html</kbd> by adding the highlighted fragment:</p>
<pre class="calibre19">&lt;div class="exercise-pane" class="col-sm-6"&gt; 
    <strong class="calibre1">&lt;h4 class="text-center"&gt;Workout Remaining - {{workoutTimeRemaining | secondsToTime}}&lt;/h4&gt;</strong><br class="title-page-name"/>    &lt;h1 class="text-center"&gt;{{currentExercise.exercise.title}}&lt;/h1&gt; </pre>
<p class="calibre3">Surprisingly, the implementation is still not complete! There is one more step left. We have a pipe definition, and we have referenced it in the view, but <kbd class="calibre13">workoutTimeRemaining</kbd> needs to update with each passing second for <kbd class="calibre13">SecondsToTimePipe</kbd> to be effective.</p>
<p class="calibre3">We have already initialized <kbd class="calibre13">WorkoutRunnerComponent</kbd>'s <kbd class="calibre13">workoutTimeRemaining</kbd> property in the <kbd class="calibre13">start</kbd> function with the total workout time:</p>
<pre class="calibre19">start() { 
    this.workoutTimeRemaining = this.workoutPlan.totalWorkoutDuration(); 
    ... 
} </pre>
<p class="calibre3">Now the question is: how to update the <kbd class="calibre13">workoutTimeRemaining</kbd> variable with each passing second? Remember that we already have a <kbd class="calibre13">setInterval</kbd> set up that updates <kbd class="calibre13">exerciseRunningDuration</kbd>. While we can write another <kbd class="calibre13">setInterval</kbd> implementation for <kbd class="calibre13">workoutTimeRemaining</kbd>, it will be better if a single <kbd class="calibre13">setInterval</kbd> setup can take care of both the requirements.</p>
<p class="calibre3">Add a function called <kbd class="calibre13">startExerciseTimeTracking</kbd> to <kbd class="calibre13">WorkoutRunnerComponent</kbd>; it looks as follows:</p>
<pre class="calibre19">startExerciseTimeTracking() {<br class="title-page-name"/>    this.exerciseTrackingInterval = window.setInterval(() =&gt; {<br class="title-page-name"/>      if (this.exerciseRunningDuration &gt;= this.currentExercise.duration) {<br class="title-page-name"/>        clearInterval(this.exerciseTrackingInterval);<br class="title-page-name"/>        const next: ExercisePlan = this.getNextExercise();<br class="title-page-name"/>        if (next) {<br class="title-page-name"/>          if (next !== this.restExercise) {<br class="title-page-name"/>            this.currentExerciseIndex++;<br class="title-page-name"/>          }<br class="title-page-name"/>          this.startExercise(next);<br class="title-page-name"/>        }<br class="title-page-name"/>        else {<br class="title-page-name"/>          console.log('Workout complete!');<br class="title-page-name"/>        }<br class="title-page-name"/>        return;<br class="title-page-name"/>      }<br class="title-page-name"/>      ++this.exerciseRunningDuration;<br class="title-page-name"/>      --this.workoutTimeRemaining;<br class="title-page-name"/>    }, 1000);<br class="title-page-name"/>  }  </pre>
<p class="calibre3">As you can see, the primary purpose of the function is to track the exercise progress and flip the exercise once it is complete. However, it also tracks <kbd class="calibre13">workoutTimeRemaining</kbd> (it decrements this counter). The first <kbd class="calibre13">if</kbd> condition setup just makes sure that we clear the timer once all the exercises are done. The inner <kbd class="calibre13">if</kbd> conditions are used to keep <kbd class="calibre13">currentExerciseIndex</kbd> in sync with the running exercise.</p>
<p class="calibre3">This function uses a numeric instance variable called <kbd class="calibre13">exerciseTrackingInterval</kbd>. Add it to the class declaration section. We are going to use this variable later to implement an exercise pausing behavior.</p>
<p class="calibre3">Remove the complete <kbd class="calibre13">setInterval</kbd> setup from <kbd class="calibre13">startExercise</kbd> and replace it with a call to <kbd class="calibre13">this.startExerciseTimeTracking();</kbd>. We are all set to test our implementation. If required, refresh the browser and verify the implementation:</p>
<div class="packt_figure"><img class="image-border2" src="../images/00017.jpeg"/></div>
<p class="calibre3">The next section is about another inbuilt Angular directive, <kbd class="calibre13">ngIf</kbd>, and another small enhancement.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding the next exercise indicator using ngIf</h1>
                
            
            <article>
                
<p class="calibre3">It will be nice for the user to be told what the next exercise is during the short rest period between exercises. This will help them prepare for the next exercise. So let's add it.</p>
<p class="calibre3">To implement this feature, we can simply output the title of the next exercise from the <kbd class="calibre13">workoutPlan.exercises</kbd> array. We show the title next to the <kbd class="calibre13">Time Remaining</kbd> countdown section.</p>
<p class="calibre3">Change the workout div (<kbd class="calibre13">class="exercise-pane"</kbd>) to include the highlighted content, and remove existing <kbd class="calibre13">Time Remaining</kbd> <kbd class="calibre13">h1</kbd>:</p>
<pre class="calibre19">&lt;div class="exercise-pane"&gt; 
&lt;!-- Exiting html --&gt; 
   &lt;div class="progress time-progress"&gt; 
       &lt;!-- Exiting html --&gt; 
   &lt;/div&gt; 
<strong class="calibre1">   </strong> <strong class="calibre1">&lt;div class="row"&gt;</strong><br class="title-page-name"/><strong class="calibre1">      &lt;h4 class="col-sm-6 text-left"&gt;Time Remaining:</strong><br class="title-page-name"/><strong class="calibre1">        &lt;strong&gt;{{currentExercise.duration-exerciseRunningDuration}}&lt;/strong&gt;</strong><br class="title-page-name"/><strong class="calibre1">      &lt;/h4&gt;</strong><br class="title-page-name"/><strong class="calibre1">      &lt;h4 class="col-sm-6 text-right" *ngIf="currentExercise.exercise.name=='rest'"&gt;Next up:</strong><br class="title-page-name"/><strong class="calibre1">        &lt;strong&gt;{{workoutPlan.exercises[currentExerciseIndex + 1].exercise.title}}&lt;/strong&gt;</strong><br class="title-page-name"/><strong class="calibre1">      &lt;/h4&gt;</strong><br class="title-page-name"/><strong class="calibre1">    &lt;/div&gt;</strong>
&lt;/div&gt; </pre>
<p class="calibre3">We wrap the existing <kbd class="calibre13">Time Remaining h1</kbd> and add another <kbd class="calibre13">h3</kbd> tag to show the next exercise inside a new <kbd class="calibre13">div</kbd> with some style updates. Also, there is a new directive, <kbd class="calibre13">ngIf</kbd>, in the second <kbd class="calibre13">h3</kbd>. The <kbd class="calibre13">*</kbd> prefix implies that it belongs to the same set of directives that <kbd class="calibre13">ngFor</kbd> belongs: <strong class="calibre5">structural directives</strong>. Let's talk a bit about <kbd class="calibre13">ngIf</kbd>.</p>
<p class="calibre3">The <kbd class="calibre13">ngIf</kbd> directive is used to add or remove a specific section of the DOM based on whether the expression provided to it returns <kbd class="calibre13">true</kbd> or <kbd class="calibre13">false</kbd>. The DOM element is added when the expression evaluates to <kbd class="calibre13">true</kbd> and is destroyed otherwise. Isolate the <kbd class="calibre13">ngIf</kbd> declaration from the preceding view:</p>
<pre class="calibre19">ngIf="currentExercise.details.name=='rest'" </pre>
<p class="calibre3">The directive expression checks whether we are currently in the rest phase and accordingly shows or hides the linked <kbd class="calibre13">h3</kbd>.</p>
<p class="calibre3">Also in the same <kbd class="calibre13">h3</kbd>, we have an interpolation that shows the name of the exercise from the <kbd class="calibre13">workoutPlan.exercises</kbd> array.</p>
<p class="calibre3">A word of caution here: <kbd class="calibre13">ngIf</kbd> adds and destroys the DOM element, and hence it is not similar to the visibility constructs that we employed to show and hide elements. While the end result of <kbd class="calibre13">style</kbd>, <kbd class="calibre13">display:none</kbd> is the same as that of <kbd class="calibre13">ngIf</kbd>, the mechanism is entirely different:</p>
<pre class="calibre19">&lt;div [style.display]="isAdmin" ? 'block' : 'none'"&gt;Welcome Admin&lt;/div&gt; </pre>
<p class="calibre3">Versus this line:</p>
<pre class="calibre19">&lt;div *ngIf="isAdmin" ? 'block' : 'none'"&gt;Welcome Admin&lt;/div&gt; </pre>
<p class="calibre3">With <kbd class="calibre13">ngIf</kbd>, whenever the expression changes from <kbd class="calibre13">false</kbd> to <kbd class="calibre13">true</kbd>, a complete re-initialization of the content occurs. Recursively, new elements/components are created and data binding is set up, starting from the parent down to the children. The reverse happens when the expression changes from <kbd class="calibre13">true</kbd> to <kbd class="calibre13">false</kbd>: all of this is destroyed. Therefore, using <kbd class="calibre13">ngIf</kbd> can sometimes become an expensive operation if it wraps a large chunk of content and the expression attached to it changes very often. But otherwise, wrapping a view in <kbd class="calibre13">ngIf</kbd> is more performant than using CSS/style-based show or hide, as neither the DOM is created nor the data binding expressions are set up when the <kbd class="calibre13">ngIf</kbd> expression evaluates to <kbd class="calibre13">false</kbd>.</p>
<p class="calibre3">New version of Angular support branching constructs too. This allows us to implement the <strong class="calibre5">if then else</strong> flow in the view HTML. The following sample has been lifted directly from the platform documentation of <kbd class="calibre13">ngIf</kbd>:</p>
<pre class="calibre19">&lt;div *ngIf="show; else elseBlock"&gt;Text to show&lt;/div&gt;<br class="title-page-name"/>&lt;ng-template #elseBlock&gt;Alternate text while primary text is hidden&lt;/ng-template&gt;</pre>
<p class="calibre3">The <kbd class="calibre13">else</kbd> binding points to a <kbd class="calibre13">ng-template</kbd> with template variable <kbd class="calibre13">#elseBlock</kbd>.</p>
<p class="calibre3">There is another directive that belongs in this league: <kbd class="calibre13">ngSwitch</kbd>. When defined on the parent HTML, it can swap the child HTML elements based on the <kbd class="calibre13">ngSwitch</kbd> expression. Consider this example:</p>
<pre class="calibre19">&lt;div id="parent" [ngSwitch] ="userType"&gt; 
&lt;div *ngSwitchCase="'admin'"&gt;I am the Admin!&lt;/div&gt; 
&lt;div *ngSwitchCase="'powerUser'"&gt;I am the Power User!&lt;/div&gt; 
&lt;div *ngSwitchDefault&gt;I am a normal user!&lt;/div&gt; 
&lt;/div&gt; </pre>
<p class="calibre3">We bind the <kbd class="calibre13">userType</kbd> expression to <kbd class="calibre13">ngSwitch</kbd>. Based on the value of <kbd class="calibre13">userType</kbd> (<kbd class="calibre13">admin</kbd>, <kbd class="calibre13">powerUser</kbd>, or any other <kbd class="calibre13">userType</kbd>), one of the inner div elements will be rendered. The <kbd class="calibre13">ngSwitchDefault</kbd> directive is a wildcard match/fallback match, and it gets rendered when <kbd class="calibre13">userType</kbd> is neither <kbd class="calibre13">admin</kbd> nor <kbd class="calibre13">powerUser</kbd>.</p>
<p class="calibre3">If you have not realized it yet, note that there are three directives working together here to achieve switch-case-like behavior:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">ngSwitch</kbd></li>
<li class="calibre12"><kbd class="calibre13">ngSwitchCase</kbd></li>
<li class="calibre12"><kbd class="calibre13">ngSwitchDefault</kbd></li>
</ul>
<p class="calibre3">Coming back to our next exercise implementation, we are ready to verify the implementation, start the app, and wait for the rest period. There should be a mention of the next exercise during the rest phase, as shown here:</p>
<div class="packt_figure"><img class="image-border3" src="../images/00018.gif"/></div>
<p class="calibre3">The app is shaping up well. If you have used the app and done some physical workouts along with it, you will be missing the exercise pause functionality badly. The workout just does not stop until it reaches the end. We need to fix this behavior.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pausing an exercise</h1>
                
            
            <article>
                
<p class="calibre3">To pause an exercise, we need to stop the timer. We also need to add a button somewhere in the view that allows us to pause and resume the workout. We plan to do this by drawing a button overlay over the exercise area in the center of the page. When clicked on, it will toggle the exercise state between paused and running. We will also add keyboard support to pause and resume the workout using the key binding <kbd class="calibre13"><span>p</span></kbd> or <kbd class="calibre13"><span>P</span></kbd>. Let's update the component.</p>
<p class="calibre3">Update the <kbd class="calibre13">WorkoutRunnerComponent</kbd> class, add these three functions, and add a declaration for the <kbd class="calibre13">workoutPaused</kbd> variable:</p>
<pre class="calibre19">workoutPaused: boolean; <br class="title-page-name"/>...
pause() { 
    clearInterval(this.exerciseTrackingInterval); 
    this.workoutPaused = true; 
} 
 
resume() { 
    this.startExerciseTimeTracking(); 
    this.workoutPaused = false; 
} 
 
pauseResumeToggle() { 
    if (this.workoutPaused) { this.resume();    } 
    else {      this.pause();    } 
} </pre>
<p class="calibre3">The implementation for pausing is simple. The first thing we do is cancel the existing <kbd class="calibre13">setInterval</kbd> setup by calling <kbd class="calibre13">clearInterval(this.exerciseTrackingInterval);</kbd>. While resuming, we again call <kbd class="calibre13">startExerciseTimeTracking</kbd>, which again starts tracking the time from where we left off.</p>
<p class="calibre3">Now we just need to invoke the <kbd class="calibre13">pauseResumeToggle</kbd> function for the view. Add the following content to <kbd class="calibre13">workout-runner.html</kbd>:</p>
<pre class="calibre19">&lt;div id="exercise-pane" class="col-sm-6"&gt; 
<strong class="calibre1">    &lt;div id="pause-overlay" (click)="pauseResumeToggle()"&gt;</strong><strong class="calibre1"> 
        </strong><strong class="calibre1">&lt;span class="pause absolute-center" <br class="title-page-name"/>            [ngClass]="{'ion-md-pause' : !workoutPaused, 'ion-md-play' : workoutPaused}"&gt;<br class="title-page-name"/>        &lt;/span&gt;<br class="title-page-name"/>    </strong><strong class="calibre1">&lt;/div&gt;</strong> 
    &lt;div class="row workout-content"&gt; </pre>
<p class="calibre3">The <kbd class="calibre13">click</kbd> event handler on the div toggles the workout running state, and the <kbd class="calibre13">ngClass</kbd> directive is used to toggle the class between <kbd class="calibre13">ion-md-pause</kbd> and <kbd class="calibre13">ion-md-play</kbd>- standard Angular stuff. What is missing now is the ability to pause and resume on a <em class="calibre17"><span class="calibre6">P</span></em> key press.</p>
<p class="calibre3">One approach could be to apply a <kbd class="calibre13">keyup</kbd> event handler on the div:</p>
<pre class="calibre19"> &lt;div id="pause-overlay" (keyup)= "onKeyPressed($event)"&gt; </pre>
<p class="calibre3">But there are some shortcomings to this approach:</p>
<ul class="calibre11">
<li class="calibre12">The <kbd class="calibre13">div</kbd> element does not have a concept of focus, so we also need to add the <kbd class="calibre13">tabIndex</kbd> attribute on the div to make it work</li>
<li class="calibre12">Even then, it works only when we have clicked on the div at least once</li>
</ul>
<p class="calibre3">There is a better way to implement this; attach the event handler to the global <kbd class="calibre13">window</kbd> event <kbd class="calibre13">keyup</kbd>. This is how the event binding should be applied on the <kbd class="calibre13">div</kbd>:</p>
<pre class="calibre19">&lt;div id="pause-overlay" (window:keyup)= "onKeyPressed($event)"&gt;</pre>
<p class="calibre3">Make note of the special <kbd class="calibre13">window:</kbd> prefix before the <kbd class="calibre13">keyup</kbd> event. We can use this syntax to attach events to any global object, such as the <kbd class="calibre13">document</kbd>. A handy and very powerful feature of Angular binding infrastructure! The <kbd class="calibre13">onKeyPressed</kbd> event handler needs to be added to <kbd class="calibre13">WorkoutRunnerComponent</kbd>. Add this function to the class:</p>
<pre class="calibre19">onKeyPressed(event: KeyboardEvent) {<br class="title-page-name"/>    if (event.which === 80 || event.which === 112) {<br class="title-page-name"/>      this.pauseResumeToggle();<br class="title-page-name"/>    }<br class="title-page-name"/>  }</pre>
<p class="calibre3">The <kbd class="calibre13">$event</kbd> object is the standard <strong class="calibre5">DOM event object</strong> that Angular makes available for manipulation. Since this is a keyboard event, the specialized class is <kbd class="calibre13">KeyboardEvent</kbd>. The <kbd class="calibre13">which</kbd> property is matched to ASCII values of <kbd class="calibre13">p</kbd> or <kbd class="calibre13">P</kbd>. Refresh the page and you should see the play/pause icon when your mouse hovers over the exercise image, as follows:</p>
<div class="packt_figure"><img src="../images/00019.jpeg" class="calibre42"/></div>
<p class="calibre3">While we are on the topic of <strong class="calibre5">event binding</strong>, it would be a good opportunity to explore Angular's event binding infrastructure</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Angular event binding infrastructure</h1>
                
            
            <article>
                
<p class="calibre3">Angular event binding allows a component to communicate with its parent through events.</p>
<p class="calibre3">If we look back at the app implementation, what we have encountered thus far are the property/attribute bindings. Such bindings allow a component/element to take inputs from the outside world. The data flows into the component.</p>
<p class="calibre3">Event bindings are the reverse of property bindings. They allow a component/element to inform the outside world about any state change.</p>
<p class="calibre3">As we saw in the pause/resume implementation, event binding employs round brackets (<kbd class="calibre13">()</kbd>) to specify the target event:</p>
<pre class="calibre19">&lt;div id="pause-overlay" (click)="pauseResumeToggle()"&gt; </pre>
<p class="calibre3">This attaches a <kbd class="calibre13">click</kbd> event handler to the <kbd class="calibre13">div</kbd> that invokes the expression <kbd class="calibre13">pauseResumeToggle()</kbd> when the <kbd class="calibre13">div</kbd> is clicked.</p>
<div class="packt_infobox">Like properties, there is a canonical form for events too. Instead of using round brackets, the <kbd class="calibre24">on-</kbd> prefix can be used: <kbd class="calibre24">on-click="pauseResumeToggle()"</kbd></div>
<p class="calibre3">Angular supports all types of events. Events related to keyboard inputs, mouse movements, button clicks, and touches. The framework even allows us to define our own event for the components we create, such as:</p>
<pre class="calibre19">&lt;workout-runner (paused)= "stopAudio()"&gt;&lt;/workout-runner&gt; </pre>
<p class="calibre3">We will be covering custom component events in the next chapter, where we will add audio support to <em class="calibre17">7 Minute Workout</em>.</p>
<p class="calibre3">It is expected that events have side effects; in other words, an event handler may change the state of the component, which in turn may trigger a chain reaction in which multiple components react to the state change and change their own state. This is unlike a property binding expression, which should be side-effect-free. Even in our implementation, clicking on the <kbd class="calibre13">div</kbd> element toggles the exercise run state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Event bubbling</h1>
                
            
            <article>
                
<p class="calibre3">When Angular attaches event handlers to standard HTML element events, the event propagation works in the same way as standard DOM event propagation works. This is also called <strong class="calibre5">event bubbling</strong>. Events on child elements are propagated upwards, and hence event binding is also possible on a parent element, as follows:</p>
<pre class="calibre19">&lt;div id="parent " (click)="doWork($event)"&gt; Try 
  &lt;div id="child "&gt;me!&lt;/div&gt; 
&lt;/div&gt; </pre>
<p class="calibre3">Clicking on either of the divs results in the invocation of the <kbd class="calibre13">doWork</kbd> function on the parent <kbd class="calibre13">div</kbd>. Moreover, <kbd class="calibre13">$event.target</kbd> contains the reference to the <kbd class="calibre13">div</kbd> that dispatched the event.</p>
<div class="packt_infobox"><br class="calibre27"/>
Custom events created on Angular components do not support event bubbling.</div>
<p class="calibre3">Event bubbling stops if the expression assigned to the target evaluates to a <kbd class="calibre13">falsey</kbd> value (such as <kbd class="calibre13">void</kbd>, <kbd class="calibre13">false</kbd>). Therefore, to continue propagation, the expression should evaluate to <kbd class="calibre13">true</kbd>:</p>
<pre class="calibre19">&lt;div id="parent" (click)="doWork($event) || true"&gt; </pre>
<p class="calibre3">Here too, the <kbd class="calibre13">$event</kbd> object deserves some special attention.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Event binding an $event object</h1>
                
            
            <article>
                
<p class="calibre3">Angular makes an <kbd class="calibre13">$event</kbd> object available whenever the target event is triggered. This <kbd class="calibre13">$event</kbd> contains the details of the event that occurred.</p>
<p class="calibre3">The important thing to note here is that the shape of the <kbd class="calibre13">$event</kbd> object is decided based on the event type. For HTML elements, it is a DOM event object (<span class="calibre6"><a href="https://developer.mozilla.org/en-US/docs/Web/Events" class="calibre10">https://developer.mozilla.org/en-US/docs/Web/Events</a></span>), which may vary based on the actual event.</p>
<p class="calibre3">But if it is a custom component event, what is passed in the <kbd class="calibre13">$event</kbd> object is decided by the component implementation. We will return to this discussion again, in the next chapter.</p>
<p class="calibre3">We have now covered most of the data binding capabilities of Angular, with the exception of two-way binding. A quick introduction to the two-way binding constructs is warranted before we conclude the chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Two-way binding with ngModel</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Two-way binding</strong> helps us keep the model and view in sync. Changes to the model update the view and changes to the view update the model. The obvious area where two-way binding is applicable is form input. Let's look at a simple example:</p>
<pre class="calibre19">&lt;input [(ngModel)]="workout.name"&gt; </pre>
<p class="calibre3">The <kbd class="calibre13">ngModel</kbd> directive here sets a two-way binding between the <kbd class="calibre13">input</kbd>'s <kbd class="calibre13">value</kbd> property and the <kbd class="calibre13">workout.name</kbd> property on the underlying component. Anything that the user enters in the preceding  <kbd class="calibre13">input</kbd> is synced with <kbd class="calibre13">workout.name</kbd>, and any changes to <kbd class="calibre13">workout.name</kbd> are reflected back on the preceding <kbd class="calibre13">input</kbd>.</p>
<p class="calibre3">Interestingly, we can achieve the same result without using the <kbd class="calibre13">ngModel</kbd> directive too, by combining both property and event binding syntax. Consider the next example; it works in the same way as <kbd class="calibre13">input</kbd> before:</p>
<pre class="calibre19">&lt;input [value]="workout.name"  
    (input)="workout.name=$event.target.value" &gt; </pre>
<p class="calibre3">There is a property binding set up on the <kbd class="calibre13">value</kbd> property and an event binding set up on the <kbd class="calibre13">input</kbd> event that make the bidirectional sync work.</p>
<p class="calibre3">We will get into more details on two-way binding in <a href="" class="calibre10">Chapter 4</a>,<em class="calibre17"> Personal Trainer</em>, where we build our own custom workouts.</p>
<p class="calibre3">We have created a diagram that summarizes the data flow patterns for all the bindings that we have discussed thus far. Here is a handy diagram to help you memorize each of the binding constructs and how data flows:</p>
<div class="packt_figure"><img class="image-border4" src="../images/00020.jpeg"/></div>
<p class="calibre3">We now have a fully functional <em class="calibre17">7 Minute Workout</em>, with some bells and whistles too, and hopefully you had fun creating the app. It's time to conclude the chapter and summarize the lessons.</p>
<div class="packt_infobox">If you are having a problem with running the code, look at the Git branch <kbd class="calibre24">checkpoint2.4</kbd> for a working version of what we have done thus far. You can also download a snapshot of <kbd class="calibre24">checkpoint2.4</kbd> (a ZIP file) from this GitHub location: <a href="http://bit.ly/ng6be-checkpoint-2-4" class="calibre21">http://bit.ly/ng6be-checkpoint-2-4</a>. Refer to the <kbd class="calibre24">README.md</kbd> file in the <kbd class="calibre24">trainer</kbd> folder when setting up the snapshot for the first time.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre3">We started this chapter with the aim of creating an Angular app that is more complex than the sample we created in the first chapter. The <em class="calibre17">7 Minute Workout</em> app fitted the bill, and you learned a lot about the Angular framework while building this app.</p>
<p class="calibre3">We started by defining the functional specifications of the <em class="calibre17">7 Minute Workout</em> app. We then focused our efforts on defining the code structure for the app.</p>
<p class="calibre3">To build the app, we started off by defining the model of the app. Once the model was in place, we started the actual implementation by building an <strong class="calibre5">Angular component</strong>. Angular components are nothing but classes that are decorated with a framework-specific decorator, <kbd class="calibre13">@Component</kbd>.</p>
<p class="calibre3">We also learned about <strong class="calibre5">Angular modules</strong> and how Angular uses them to organize code artifacts.</p>
<p class="calibre3">Once we had a fully functional component, we created a supporting view for the app. We also explored the data binding capabilities of the framework, including <strong class="calibre5">property</strong>, <strong class="calibre5">attribute</strong>, <strong class="calibre5">class</strong>, <strong class="calibre5">style,</strong> and <strong class="calibre5">event binding</strong>. Plus, we highlighted how <strong class="calibre5">interpolations</strong> are a special case of property binding.</p>
<p class="calibre3">Components are a special class of directives that have an attached view. We touched upon what directives are and the special classes of directives, including <strong class="calibre5">attribute</strong> and <strong class="calibre5">structural directives</strong>.</p>
<p class="calibre3">We learned how to perform cross-component communication using <strong class="calibre5">input properties</strong>. The two child components that we put together (<kbd class="calibre13">ExerciseDescriptionComponent</kbd> and <kbd class="calibre13">VideoPlayerComponent</kbd>) derived their inputs from the parent <kbd class="calibre13">WorkoutRunnerComponent</kbd> using input properties.</p>
<p class="calibre3">We then covered another core construct in Angular, <strong class="calibre5">pipes</strong>. We saw how to use pipes such as the date pipe and how to create one of our own.</p>
<p class="calibre3">Throughout the chapter, we touched upon a number of Angular directives, including the following:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">ngClass/ngStyle</kbd>: For applying multiple styles and classes using Angular binding capabilities</li>
<li class="calibre12"><kbd class="calibre13">ngFor</kbd>: For generating dynamic HTML content using a looping construct</li>
<li class="calibre12"><kbd class="calibre13">ngIf</kbd>: For conditionally creating/destroying DOM elements</li>
<li class="calibre12"><kbd class="calibre13">ngSwitch</kbd>: For creating/destroying DOM elements using the switch-case construct</li>
</ul>
<p class="calibre3">We now have a basic <em class="calibre17">7 Minute Workout</em> app. For a better user experience, we have added a number of small enhancements to it too, but we are still missing some good-to-have features that would make our app more usable. From the framework perspective, we have purposefully ignored some core/advanced concepts such as <strong class="calibre5">change detection</strong>, <strong class="calibre5">dependency injection</strong>, <strong class="calibre5">component</strong> <strong class="calibre5">routing</strong>, and data flow patterns, which we plan to cover in the next chapter.</p>


            </article>

            
        </section>
    </body></html>