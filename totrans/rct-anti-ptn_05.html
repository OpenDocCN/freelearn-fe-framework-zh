<html><head></head><body>
<section epub:type="bodymatter chapter" id="_idLandmarksDest-1" role="doc-chapter">
<h1 class="chapter-number" id="_idParaDest-71"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-72"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.2.1">Testing in React</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Welcome to this immersive chapter on testing in React. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we will learn the importance of </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.4.1">software testing, understand the different types of testing – including unit, integration, and </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">end-to-end</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.7.1">E2E</span></strong><span class="koboSpan" id="kobo.8.1">) testing – and delve into the use of popular testing tools such as Cypress, Jest, and the React Testing Library. </span><span class="koboSpan" id="kobo.8.2">In addition, we will demystify concepts such as stubbing and mocking, ensuring you are well-equipped to handle complex testing scenarios.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Our overarching goal is to foster a solid understanding of testing strategies and their implementation in React. </span><span class="koboSpan" id="kobo.9.2">We aim to enhance your ability to write tests that make your application resilient to bugs and regressions and ensure the seamless addition of new features.</span></p>
<p><span class="koboSpan" id="kobo.10.1">By the end of this chapter, you’ll have a comprehensive understanding of React testing and be ready to implement efficient testing practices in your projects. </span><span class="koboSpan" id="kobo.10.2">So, let’s get started and step into the exciting world of React testing!</span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, we will cover the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.12.1">Understanding why we need tests</span></li>
<li><span class="koboSpan" id="kobo.13.1">Learning about different types of tests</span></li>
<li><span class="koboSpan" id="kobo.14.1">Testing individual units with Jest</span></li>
<li><span class="koboSpan" id="kobo.15.1">Learning about integration tests</span></li>
<li><span class="koboSpan" id="kobo.16.1">Learning about E2E tests using Cypress</span><a id="_idTextAnchor126"/></li>
</ul>
<h1 id="_idParaDest-73"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.17.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.18.1">A GitHub repository has been created to host all the code we’ll discuss in this book. </span><span class="koboSpan" id="kobo.18.2">For this chapter, you can find the recommended structure at </span><a href="https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch5"><span class="koboSpan" id="kobo.19.1">https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch5</span></a><span class="koboSpan" id="kobo.20.1">.</span><a id="_idTextAnchor128"/></p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.21.1">Understanding why we need tests</span></h1>
<p><span class="koboSpan" id="kobo.22.1">Testing is not just an optional best practice; it’s a critical part of building reliable and maintainable </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.23.1">software. </span><span class="koboSpan" id="kobo.23.2">Without tests, you’re essentially navigating the complex seas of software development without a compass. </span><span class="koboSpan" id="kobo.23.3">Let’s understand the multiple benefits that testing brings:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.24.1">Ensuring code correctness</span></strong><span class="koboSpan" id="kobo.25.1">: Tests serve as a seal of validation that your code performs </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.26.1">exactly the way it’s supposed to. </span><span class="koboSpan" id="kobo.26.2">A well-written test verifies that your functions return the expected output for a given input, your components render correctly, and your application behaves as anticipated.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.27.1">Preventing regression</span></strong><span class="koboSpan" id="kobo.28.1">: As applications grow and evolve, new code can sometimes unintentionally </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.29.1">break existing functionality. </span><span class="koboSpan" id="kobo.29.2">This is known as a </span><strong class="bold"><span class="koboSpan" id="kobo.30.1">regression</span></strong><span class="koboSpan" id="kobo.31.1">. </span><span class="koboSpan" id="kobo.31.2">Automated tests act as a safety net, catching these regressions before they reach production.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.32.1">Facilitating refactoring and maintenance</span></strong><span class="koboSpan" id="kobo.33.1">: Fear often surrounds the process of refactoring or updating legacy code. </span><span class="koboSpan" id="kobo.33.2">Tests alleviate this fear. </span><span class="koboSpan" id="kobo.33.3">They provide a comfort zone, assuring that if you accidentally break something during the update or refactoring process, your tests will catch it.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.34.1">Boosting confidence in code quality</span></strong><span class="koboSpan" id="kobo.35.1">: Tests elevate the confidence level of your team. </span><span class="koboSpan" id="kobo.35.2">When a suite of well-written tests backs your code, you have a quantifiable measure of your code’s quality. </span><span class="koboSpan" id="kobo.35.3">This assurance is especially beneficial when you’re adding new features or making changes to the system.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.36.1">Documentation</span></strong><span class="koboSpan" id="kobo.37.1">: Tests also serve as a form of documentation. </span><span class="koboSpan" id="kobo.37.2">They provide a clear understanding of what a function or component is supposed to do, helping new developers on the team understand the project’s functionality.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.38.1">In the </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.39.1">subsequent sections, we’ll delve deeper into the various types of testing you’ll commonly use in React applications and learn how to use testing tools effectively. </span><span class="koboSpan" id="kobo.39.2">Buckle up for an engaging ride into the realm of software test</span><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.40.1">ing.</span></p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.41.1">Learning about different types of tests</span></h1>
<p><span class="koboSpan" id="kobo.42.1">Testing, in the realm of software development, isn’t a one-size-fits-all approach. </span><span class="koboSpan" id="kobo.42.2">Rather, it is categorized </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.43.1">into different types, each serving a distinct purpose and offering unique insights into the functionality and reliability of the application. </span><span class="koboSpan" id="kobo.43.2">It is important to understand these categories to ensure the overall health and robustness of your application. </span><span class="koboSpan" id="kobo.43.3">Typically, you will have unit tests, integration tests, and E2E tests in one code base.</span></p>
<p><span class="koboSpan" id="kobo.44.1">We will define each type here briefly and discuss each type in detail in the following sections:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.45.1">Unit tests</span></strong><span class="koboSpan" id="kobo.46.1">: These tests </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.47.1">focus on testing individual </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.48.1">components or functions in isolation to ensure they work as expected</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.49.1">Integration tests</span></strong><span class="koboSpan" id="kobo.50.1">: These </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.51.1">tests examine the interactions </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.52.1">between different modules or services to verify they work together cohesively</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.53.1">E2E tests</span></strong><span class="koboSpan" id="kobo.54.1">: These tests </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.55.1">test the entire application flow from </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.56.1">start to finish, mimicking real-world user behavior to validate that the system works as a whole</span></li>
</ul>
<p><span class="koboSpan" id="kobo.57.1">How you structure your tests in a project also matters. </span><span class="koboSpan" id="kobo.57.2">For example, you should have a lot of unit tests that run fast and can provide detailed feedback, and you should have only a few E2E tests to ensure all the parts work together. </span><span class="koboSpan" id="kobo.57.3">This approach aligns with the principles of the test pyramid.</span></p>
<p><span class="koboSpan" id="kobo.58.1">Originally conceived by Mike Cohn, the </span><strong class="bold"><span class="koboSpan" id="kobo.59.1">test pyramid</span></strong><span class="koboSpan" id="kobo.60.1"> recommends having a larger number of unit tests </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.61.1">compared to integration or E2E tests. </span><span class="koboSpan" id="kobo.61.2">The reasoning is simple – unit tests are quicker, simpler, and more cost-effective to maintain:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.62.1"><img alt="Figure 5.1: The traditional test pyramid" src="image/B31103_05_01.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.63.1">Figure 5.1: The traditional test pyramid</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.64.1">However, in the modern </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.65.1">frontend world, this model is evolving. </span><span class="koboSpan" id="kobo.65.2">More value is being placed on integration and E2E tests due to the increasing complexity and interactivity of </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.66.1">frontend applications. </span><span class="koboSpan" id="kobo.66.2">Tools such as Cypress and Puppeteer </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.67.1">facilitate writing E2E tests that emulate user behavior on the browser, while libraries such as the React Testing Library encourage more integration tests by making it easier to test component interactions.</span></p>
<p><span class="koboSpan" id="kobo.68.1">New types </span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.69.1">of tests are also introduced in frontend applications. </span><span class="koboSpan" id="kobo.69.2">The visual regression tests is one of them. </span><strong class="bold"><span class="koboSpan" id="kobo.70.1">Visual regression testing</span></strong><span class="koboSpan" id="kobo.71.1"> is a method of testing in which the visual aspects of a web application are captured and compared to previous states or versions. </span><span class="koboSpan" id="kobo.71.2">This type of testing is particularly useful in catching unintended visual bugs and changes in a user interface that may be introduced during development.</span></p>
<p><span class="koboSpan" id="kobo.72.1">Visual regression tests work by taking screenshots (or snapshots) of web pages or components at different stages, and then comparing these screenshots pixel by pixel to identify any visual differences. </span><span class="koboSpan" id="kobo.72.2">When a difference is detected, it is flagged for review. </span><span class="koboSpan" id="kobo.72.3">The review can then determine if the change is expected (due to a new feature or design update) or if it’s an unintended regression that needs to be fixed.</span></p>
<p><span class="koboSpan" id="kobo.73.1">In frontend testing, </span><strong class="bold"><span class="koboSpan" id="kobo.74.1">static checks</span></strong><span class="koboSpan" id="kobo.75.1"> involve </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.76.1">analyzing code without executing it to identify errors </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.77.1">and ensure coding standards. </span><span class="koboSpan" id="kobo.77.2">This includes checking for syntax errors, enforcing coding style through linting, verifying correct data types with type checking, analyzing code complexity, examining dependencies, and identifying security vulnerabilities.</span></p>
<p><span class="koboSpan" id="kobo.78.1">The exact shape of your test pyramid might vary depending on your application’s needs, but the critical takeaway is to have a balanced testing strategy that provides quick and useful feedback at different levels of your application:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.79.1"><img alt="Figure 5.2: The enhanced test pyramid" src="image/B31103_05_02.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.80.1">Figure 5.2: The enhanced test pyramid</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.81.1">The next sections in this chapter will give you hands-on experience in writing these types of tests for a React application, ensuring that you are well-equipped to bring these concepts into your projects. </span><span class="koboSpan" id="kobo.81.2">Le</span><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.82.1">t’s forge ahead!</span></p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.83.1">Testing individual units with Jest</span></h1>
<p><span class="koboSpan" id="kobo.84.1">Unit tests are the smallest and most foundational part of the testing pyramid, verifying the behavior </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.85.1">of individual units of code in isolation, such as functions, methods, or components. </span><span class="koboSpan" id="kobo.85.2">These tests are quick to write and execute, offering immediate feedback to developers.</span></p>
<p><span class="koboSpan" id="kobo.86.1">We’ll use </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.87.1">Jest to write unit tests and integration tests in this book. </span><span class="koboSpan" id="kobo.87.2">Jest is a comprehensive JavaScript testing framework built by Facebook, with a strong focus on simplicity. </span><span class="koboSpan" id="kobo.87.3">It’s feature-rich and supports asynchronous testing, mocking, and snapshot testing, making it a great choice for R</span><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.88.1">eact applications.</span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.89.1">Writing your first test</span></h2>
<p><span class="koboSpan" id="kobo.90.1">Let’s write </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.91.1">a simple test. </span><span class="koboSpan" id="kobo.91.2">Say you have an </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">add</span></strong><span class="koboSpan" id="kobo.93.1"> function in a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">math.ts</span></strong><span class="koboSpan" id="kobo.95.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.96.1">
export function add(a: number, b: number) {
  return a + b;
}</span></pre> <p><span class="koboSpan" id="kobo.97.1">To test this function, you must create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">math.test.ts</span></strong><span class="koboSpan" id="kobo.99.1"> file in the same directory:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.100.1">
import { add } from './math';
test('add adds numbers correctly', () =&gt; {
  expect(add(1, 2)).toBe(3);
});</span></pre> <p><span class="koboSpan" id="kobo.101.1">You’ve now written your first test! </span><span class="koboSpan" id="kobo.101.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">test</span></strong><span class="koboSpan" id="kobo.103.1"> function takes two arguments: a string description of the test and a callback function that implements the test. </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">expect</span></strong><span class="koboSpan" id="kobo.105.1"> is a Jest function that takes the actual value, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">toBe</span></strong><span class="koboSpan" id="kobo.107.1"> is a matcher function that compares the actual value with the expected value.</span></p>
<p><span class="koboSpan" id="kobo.108.1">Another way of writing a test is to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">it</span></strong><span class="koboSpan" id="kobo.110.1"> function. </span><span class="koboSpan" id="kobo.110.2">In Jest, </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">test</span></strong><span class="koboSpan" id="kobo.112.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">it</span></strong><span class="koboSpan" id="kobo.114.1"> are actually the same function and can be used interchangeably; the names just come from different testing conventions:</span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">test</span></strong><span class="koboSpan" id="kobo.116.1">: This is a common name for a test function in many testing frameworks and languages. </span><span class="koboSpan" id="kobo.116.2">If you come from a background of using other testing libraries, you might find </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">test</span></strong><span class="koboSpan" id="kobo.118.1"> to be more intuitive or familiar.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">it</span></strong><span class="koboSpan" id="kobo.120.1">: This comes </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.121.1">from </span><strong class="bold"><span class="koboSpan" id="kobo.122.1">behavior-driven development</span></strong><span class="koboSpan" id="kobo.123.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.124.1">BDD</span></strong><span class="koboSpan" id="kobo.125.1">) style frameworks such as Jasmine or Mocha.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.126.1">The idea </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.127.1">of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">it</span></strong><span class="koboSpan" id="kobo.129.1"> is to make the tests read more like sentences. </span><span class="koboSpan" id="kobo.129.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">it("adds 1 + 2 to equal 3", () =&gt; expect(1 + 2).toBe(3))</span></strong><span class="koboSpan" id="kobo.131.1"> reads like “it ad</span><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.132.1">ds 1 + 2 to equal 3.”</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.133.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.134.1">BDD is a software development approach that emphasizes collaboration between developers, QA, and non-technical participants in a software project. </span><span class="koboSpan" id="kobo.134.2">It highlights the need to start with a clear understanding of desired behavior before development starts, thereby aligning development with business needs.</span></p>
<p class="callout"><span class="koboSpan" id="kobo.135.1">BDD encourages expressing software behaviors in plain, descriptive language that can be read and understood by all stakeholders. </span><span class="koboSpan" id="kobo.135.2">It leverages executable specifications, often written in a language such as Gherkin, that guide development and serve as acceptance criteria.</span></p>
<p class="callout"><span class="koboSpan" id="kobo.136.1">BDD aims to reduce misunderstandings by encouraging collaboration, making the behavior of a system explicit and understandable by all, and ensuring that the software developed truly meets the needs of the business.</span></p>
<p><span class="koboSpan" id="kobo.137.1">It’s a matter of team preference and what aligns best with your team’s testing philosophy – some teams prefer the sentence-like structure that it provides as it often makes it clearer what a test is trying to verify, especially to non-developers, while others might find </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">test</span></strong><span class="koboSpan" id="kobo.139.1"> to be more straightforward and less verbose. </span><span class="koboSpan" id="kobo.139.2">We’re going to write tests that follow the BD</span><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.140.1">D style in this book.</span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.141.1">Grouping tests</span></h2>
<p><span class="koboSpan" id="kobo.142.1">Grouping </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.143.1">related tests in one block significantly improves the readability of your test files. </span><span class="koboSpan" id="kobo.143.2">By clearly delineating different areas of functionality, a block allows anyone reading the tests to understand the context of the test suite at a glance. </span><span class="koboSpan" id="kobo.143.3">This enhanced understanding is crucial for comprehension of what functionality is being verified. </span><span class="koboSpan" id="kobo.143.4">In a large code base, with numerous tests, this organization can greatly decrease the cognitive load required to understand how different parts of the application are tested.</span></p>
<p><span class="koboSpan" id="kobo.144.1">In Jest, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">describe</span></strong><span class="koboSpan" id="kobo.146.1"> function to group related tests into one unit. </span><span class="koboSpan" id="kobo.146.2">For instance, consider a function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">add</span></strong><span class="koboSpan" id="kobo.148.1">, that includes multiple cases: the addition of negative numbers, the combination of one negative and one positive number, decimal sums, or even computations </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.149.1">involving imaginary numbers. </span><span class="koboSpan" id="kobo.149.2">It would be prudent to gather all these distinct cases under one </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">describe</span></strong><span class="koboSpan" id="kobo.151.1"> block, like so:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.152.1">
import { add } from './math';
describe('math functions', () =&gt; {
  it('adds positive numbers correctly', () =&gt; {
    expect(add(1, 2)).toBe(3);
  });
  it('adds negative numbers correctly', () =&gt; {
    expect(add(-1, -2)).toBe(-3);
  });
  // More tests...
</span><span class="koboSpan" id="kobo.152.2">});</span></pre> <p><span class="koboSpan" id="kobo.153.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">describe</span></strong><span class="koboSpan" id="kobo.155.1"> function is used </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.156.1">to group related tests – in this case, tests for some math functions. </span><span class="koboSpan" id="kobo.156.2">Within this group, there are two </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">it</span></strong><span class="koboSpan" id="kobo.158.1"> functions, each representing a single test. </span><span class="koboSpan" id="kobo.158.2">The first test checks if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">add</span></strong><span class="koboSpan" id="kobo.160.1"> function correctly adds two positive numbers, and the second test checks if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">add</span></strong><span class="koboSpan" id="kobo.162.1"> function correctly adds two negative numbers.</span></p>
<p><span class="koboSpan" id="kobo.163.1">With Jest, you can nest </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">describe</span></strong><span class="koboSpan" id="kobo.165.1"> blocks to organize your tests more systematically. </span><span class="koboSpan" id="kobo.165.2">For example, suppose we’re expanding our suite to include subtraction, multiplication, and division in </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.166.1">our calculator functionality. </span><span class="koboSpan" id="kobo.166.2">We can structure our test suite in the following manner:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.167.1">
describe('calculator', () =&gt; {
  describe('addition', () =&gt; {
    it('adds positive numbers correctly', () =&gt; {
        expect(add(1, 2)).toBe(3);
    });
    it('adds negative numbers correctly', () =&gt; {
        expect(add(-1, -2)).toBe(-3);
    });
    // More tests...
</span><span class="koboSpan" id="kobo.167.2">  })
  describe('subtraction', () =&gt; {
    it('subtracts positive numbers', () =&gt; {});
  })
  // Other describe blocks for multiplication and division
});</span></pre> <p><span class="koboSpan" id="kobo.168.1">In this code snippet, we have a top-level </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">describe</span></strong><span class="koboSpan" id="kobo.170.1"> block labeled </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">calculator</span></strong><span class="koboSpan" id="kobo.172.1">. </span><span class="koboSpan" id="kobo.172.2">Within this block, we have nested </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">describe</span></strong><span class="koboSpan" id="kobo.174.1"> blocks for each mathematical operation. </span><span class="koboSpan" id="kobo.174.2">For instance, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">addition</span></strong><span class="koboSpan" id="kobo.176.1"> block, we have individual </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">it</span></strong><span class="koboSpan" id="kobo.178.1"> tests for different scenarios of adding numbers. </span><span class="koboSpan" id="kobo.178.2">Similarly, we start a new describe block for </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">subtraction</span></strong><span class="koboSpan" id="kobo.180.1">. </span><span class="koboSpan" id="kobo.180.2">This nested structure makes our test suite more organized, readable, and easier to navigate, particularly when dealing with a large number of te</span><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.181.1">sts or complex scenarios.</span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.182.1">Testing React components</span></h2>
<p><span class="koboSpan" id="kobo.183.1">As we mentioned previously, Jest is a great tool for testing different types of applications, and it </span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.184.1">supports React applications out of the box. </span><span class="koboSpan" id="kobo.184.2">Although it’s possible to use Jest alone, it would be a bit more cumbersome and verbose than using a dedicated library such as the </span><strong class="bold"><span class="koboSpan" id="kobo.185.1">React </span></strong><strong class="bold"><span class="koboSpan" id="kobo.186.1">Testing Library</span></strong><span class="koboSpan" id="kobo.187.1">.</span></p>
<p><span class="koboSpan" id="kobo.188.1">The React Testing Library </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.189.1">is a lightweight yet powerful library for testing React components. </span><span class="koboSpan" id="kobo.189.2">It’s built on top of the popular JavaScript testing framework, Jest, and adds specific utilities for working with React components. </span><span class="koboSpan" id="kobo.189.3">The philosophy of the React Testing Library is to encourage writing tests that closely resemble how your software is used. </span><span class="koboSpan" id="kobo.189.4">It encourages you to interact with your app just like how users would, meaning you test the functionality and not the implementation details. </span><span class="koboSpan" id="kobo.189.5">This approach leads to more robust and maintainable tests that will give you confidence that your app will work in production.</span></p>
<p><span class="koboSpan" id="kobo.190.1">In the code provided in this book, the project has already been set up for you with the React Testing Library. </span><span class="koboSpan" id="kobo.190.2">Simply clone the code mentioned in the </span><i class="italic"><span class="koboSpan" id="kobo.191.1">Technical requirements</span></i><span class="koboSpan" id="kobo.192.1"> section into your local directory and you are good to go.</span></p>
<p><span class="koboSpan" id="kobo.193.1">All right – let’s start with a simple React component to see how we can test it with the React Testing Library. </span><span class="koboSpan" id="kobo.193.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">Section</span></strong><span class="koboSpan" id="kobo.195.1"> component is a presentational component that accepts two props, </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">heading</span></strong><span class="koboSpan" id="kobo.197.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">content</span></strong><span class="koboSpan" id="kobo.199.1">, and renders the props in an </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">article</span></strong><span class="koboSpan" id="kobo.201.1"> tag:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.202.1">
type SectionProps = {
  heading: string;
  content: string;
};
const Section = ({ heading, content }: SectionProps) =&gt; {
  return (
    &lt;article&gt;
      &lt;h1&gt;{heading}&lt;/h1&gt;
      &lt;p&gt;{content}&lt;/p&gt;
    &lt;/article&gt;
  );
};
export { Section };</span></pre> <p><span class="koboSpan" id="kobo.203.1">To test </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.204.1">the component, we can create a new file next to </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">Section.tsx</span></strong><span class="koboSpan" id="kobo.206.1">, which we will call </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">Section.test.tsx</span></strong><span class="koboSpan" id="kobo.208.1">. </span><span class="koboSpan" id="kobo.208.2">This is where our test code will live. </span><span class="koboSpan" id="kobo.208.3">Then, we’ll use the React Testing Library to check the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">Section</span></strong><span class="koboSpan" id="kobo.210.1"> component:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.211.1">
import React from "react";
import { render, screen } from "@testing-library/react";
import { Section } from "../component/Section";
describe("Section", () =&gt; {
  it("renders a section with heading and content", () =&gt; {
    render(&lt;Section heading="Basic" content="Hello world" /&gt;);
    expect(screen.getByText("Basic")).toBeInTheDocument();
    expect(screen.getByText("Hello world")).toBeInTheDocument();
  });
});</span></pre> <p><span class="koboSpan" id="kobo.212.1">This test code makes use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">@testing-library/react</span></strong><span class="koboSpan" id="kobo.214.1"> to verify that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">Section</span></strong><span class="koboSpan" id="kobo.216.1"> component behaves as expected – the text </span><strong class="bold"><span class="koboSpan" id="kobo.217.1">Basic</span></strong><span class="koboSpan" id="kobo.218.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.219.1">Hello world</span></strong><span class="koboSpan" id="kobo.220.1"> should be present in the HTML document. </span><span class="koboSpan" id="kobo.220.2">The render function provided by </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">@testing-library/react</span></strong><span class="koboSpan" id="kobo.222.1"> is used to render the </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">Section</span></strong><span class="koboSpan" id="kobo.224.1"> component with specific props: a heading of </span><strong class="bold"><span class="koboSpan" id="kobo.225.1">Basic</span></strong><span class="koboSpan" id="kobo.226.1"> and content of </span><strong class="bold"><span class="koboSpan" id="kobo.227.1">Hello world</span></strong><span class="koboSpan" id="kobo.228.1">.</span></p>
<p><span class="koboSpan" id="kobo.229.1">Following the </span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.230.1">rendering, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">screen.getByText</span></strong><span class="koboSpan" id="kobo.232.1"> function is used to query the DOM (which represents the rendered output of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">Section</span></strong><span class="koboSpan" id="kobo.234.1"> component) for elements containing specific text.</span></p>
<p><span class="koboSpan" id="kobo.235.1">Next, </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">expect</span></strong><span class="koboSpan" id="kobo.237.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">toBeInTheDocument</span></strong><span class="koboSpan" id="kobo.239.1"> are then used to make assertions about the state of these elements. </span><span class="koboSpan" id="kobo.239.2">Specifically, the test is asserting that there is an element with the </span><strong class="bold"><span class="koboSpan" id="kobo.240.1">Basic</span></strong><span class="koboSpan" id="kobo.241.1"> text and an element with the </span><strong class="bold"><span class="koboSpan" id="kobo.242.1">Hello world</span></strong><span class="koboSpan" id="kobo.243.1"> text present in the DOM, which would indicate that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">Section</span></strong><span class="koboSpan" id="kobo.245.1"> component has correctly rendered its heading and content props.</span></p>
<p><span class="koboSpan" id="kobo.246.1">This straightforward unit test for a React component serves as a useful starting point. </span><span class="koboSpan" id="kobo.246.2">However, in complex real-world projects, we often encounter scenarios where multiple components need to interact harmoniously. </span><span class="koboSpan" id="kobo.246.3">For instance, consider a checkout page that integrates an address collection component, a payment component, and a price calculation logic component.</span></p>
<p><span class="koboSpan" id="kobo.247.1">To confidently ensure the seamless interaction of these distinct components, we must employ a more comprehensive testing</span><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.248.1"> strategy: integration tests.</span></p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.249.1">Learning about integration tests</span></h1>
<p><span class="koboSpan" id="kobo.250.1">Integration tests are positioned above unit tests in the pyramid, validating the interactions </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.251.1">between multiple units of code. </span><span class="koboSpan" id="kobo.251.2">These could be component interactions or interactions between the client side and server side. </span><span class="koboSpan" id="kobo.251.3">Integration tests aim to identify issues that may arise when different parts of the system are combined.</span></p>
<p><span class="koboSpan" id="kobo.252.1">One such scenario involves testing the interaction between two separate components to verify that they function correctly together – this is integration testing at a UI component level. </span><span class="koboSpan" id="kobo.252.2">Additionally, if you’re looking to ensure smooth collaboration between your frontend code and backend services, the tests you write for this purpose would also be classified as integration tests, which verify that different layers of your application are working correctly together.</span></p>
<p><span class="koboSpan" id="kobo.253.1">Let’s have a look at an example of an integration test for a React component. </span><span class="koboSpan" id="kobo.253.2">In </span><i class="italic"><span class="koboSpan" id="kobo.254.1">Figure 5</span></i><i class="italic"><span class="koboSpan" id="kobo.255.1">.3</span></i><span class="koboSpan" id="kobo.256.1">, there is a </span><strong class="bold"><span class="koboSpan" id="kobo.257.1">Terms and Conditions</span></strong><span class="koboSpan" id="kobo.258.1"> section, which includes a long text about the legal information, and a checkbox for the user to consent. </span><span class="koboSpan" id="kobo.258.2">There is also a </span><strong class="bold"><span class="koboSpan" id="kobo.259.1">Next</span></strong><span class="koboSpan" id="kobo.260.1"> button, which is disabled </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.261.1">by default. </span><span class="koboSpan" id="kobo.261.2">However, once the user selects </span><strong class="bold"><span class="koboSpan" id="kobo.262.1">Accept the Terms and Conditions</span></strong><span class="koboSpan" id="kobo.263.1">, the button will be enabled, and the user can proceed:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.264.1"><img alt="Figure 5.3: The Terms and Conditions component" src="image/B31103_05_03.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.265.1">Figure 5.3: The Terms and Conditions component</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.266.1">This integration test can be described using the following code snippet – we are not testing the </span><strong class="bold"><span class="koboSpan" id="kobo.267.1">Checkbox</span></strong><span class="koboSpan" id="kobo.268.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.269.1">Next</span></strong><span class="koboSpan" id="kobo.270.1"> buttons separately, but verifying the interaction between them:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.271.1">
describe('Terms and Conditions', () =&gt; {
  it("renders learn react link", () =&gt; {
    render(&lt;TermsAndConditions /&gt;);
    const button = screen.getByText('Next');
    expect(button).toBeDisabled();
    const checkbox = screen.getByRole('checkbox');
    act(() =&gt; {
      userEvent.click(checkbox);
    })
    expect(button).toBeEnabled();
  });
})</span></pre> <p><span class="koboSpan" id="kobo.272.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">describe</span></strong><span class="koboSpan" id="kobo.274.1"> function is used to group all tests associated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">TermsAndConditions</span></strong><span class="koboSpan" id="kobo.276.1"> component, forming a so-called test suite. </span><span class="koboSpan" id="kobo.276.2">Within this suite, we have a single test case denoted by the it function. </span><span class="koboSpan" id="kobo.276.3">The description of this test is </span><strong class="bold"><span class="koboSpan" id="kobo.277.1">renders learn react link</span></strong><span class="koboSpan" id="kobo.278.1">, which appears to be a misnomer considering the operations carried out in this test. </span><span class="koboSpan" id="kobo.278.2">A more suitable description might be </span><strong class="bold"><span class="koboSpan" id="kobo.279.1">Enables the next button upon accepting terms </span></strong><strong class="bold"><span class="koboSpan" id="kobo.280.1">and conditions</span></strong><span class="koboSpan" id="kobo.281.1">.</span></p>
<p><span class="koboSpan" id="kobo.282.1">Initially, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">render</span></strong><span class="koboSpan" id="kobo.284.1"> function is invoked to display the </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">TermsAndConditions</span></strong><span class="koboSpan" id="kobo.286.1"> component. </span><span class="koboSpan" id="kobo.286.2">This function produces a series of output, or render results, that can be queried in various </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.287.1">ways to assess whether the component behaves as expected.</span></p>
<p><span class="koboSpan" id="kobo.288.1">We then try to find a button by its text, </span><strong class="bold"><span class="koboSpan" id="kobo.289.1">Next</span></strong><span class="koboSpan" id="kobo.290.1">, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">screen.getByText</span></strong><span class="koboSpan" id="kobo.292.1"> function – which returns the element found on the page. </span><span class="koboSpan" id="kobo.292.2">At this point, we expect this button to be disabled, so we confirm this expectation by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">expect(button).toBeDisabled()</span></strong><span class="koboSpan" id="kobo.294.1">.</span></p>
<p><span class="koboSpan" id="kobo.295.1">Next, we look for the checkbox using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">screen.getByRole</span></strong><span class="koboSpan" id="kobo.297.1"> function. </span><span class="koboSpan" id="kobo.297.2">This function allows us to find the checkbox based on its role, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">checkbox</span></strong><span class="koboSpan" id="kobo.299.1">.</span></p>
<p><span class="koboSpan" id="kobo.300.1">The user interaction of ticking the checkbox is simulated using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">userEvent.click</span></strong><span class="koboSpan" id="kobo.302.1"> function, which is wrapped in React’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">act</span></strong><span class="koboSpan" id="kobo.304.1"> function. </span><span class="koboSpan" id="kobo.304.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">act</span></strong><span class="koboSpan" id="kobo.306.1"> function ensures that all updates related to these actions are processed and applied before moving forward; this way, our assertions will examine the component in its updated state.</span></p>
<p><span class="koboSpan" id="kobo.307.1">Finally, we verify that the button is enabled after the checkbox has been clicked. </span><span class="koboSpan" id="kobo.307.2">This is done using </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">expect(button).toBeEnabled()</span></strong><span class="koboSpan" id="kobo.309.1">. </span><span class="koboSpan" id="kobo.309.2">If this statement holds true, we know that our component behaves as intended – that is, disabling the </span><strong class="bold"><span class="koboSpan" id="kobo.310.1">Next</span></strong><span class="koboSpan" id="kobo.311.1"> button until the user accepts the terms and conditions.</span></p>
<p><span class="koboSpan" id="kobo.312.1">Now, let’s look </span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.313.1">at how the code is written. </span><span class="koboSpan" id="kobo.313.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">TermsAndConditions</span></strong><span class="koboSpan" id="kobo.315.1"> component under test is composed of a few components – </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">heading</span></strong><span class="koboSpan" id="kobo.317.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">LegalContent</span></strong><span class="koboSpan" id="kobo.319.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">UserConsent</span></strong><span class="koboSpan" id="kobo.321.1">. </span><span class="koboSpan" id="kobo.321.2">Plus, </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">UserConsent</span></strong><span class="koboSpan" id="kobo.323.1"> itself is composed of </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">CheckBox</span></strong><span class="koboSpan" id="kobo.325.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">Button</span></strong><span class="koboSpan" id="kobo.327.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.328.1">
const TheLegalContent = () =&gt; {
  return (
    &lt;p&gt;
      {/*...*/}
    &lt;/p&gt;
  );
};
type CheckBoxProps = {
  label: string;
  isChecked: boolean;
  onCheck: (event: any) =&gt; void
}
const CheckBox = ({label, isChecked, onCheck}: CheckBoxProps) =&gt; {
  return (
    &lt;label&gt;
      &lt;input
        type="checkbox"
        checked={isChecked}
        onChange={onCheck}
      /&gt;
      {label}
    &lt;/label&gt;
  )
}
type ButtonProps = {
  type: 'standard' | 'primary' | 'secondary';
  label: string;
  disabled?: boolean;
}
const Button = ({label, disabled = true}: ButtonProps) =&gt; {
  return (
    &lt;div style={{margin: '0.5rem 0'}}&gt;
      &lt;button disabled={disabled}&gt;{label}&lt;/button&gt;
    &lt;/div&gt;
  )
}
const UserConsent = () =&gt; {
  const [isChecked, setIsChecked] = useState(false);
  const handleCheckboxChange = (event: React.
</span><span class="koboSpan" id="kobo.328.2">   ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    setIsChecked(event.target.checked);
  };
  return (
    &lt;&gt;
      &lt;CheckBox isChecked={isChecked} onCheck={handleCheckboxChange} 
       label="I accept the terms and conditions" /&gt;
      &lt;Button type="primary" label="Next" disabled={!isChecked} /&gt;
    &lt;/&gt;
  );
};
const TermsAndConditions = () =&gt; {
  return (
    &lt;div&gt;
      &lt;h2&gt;Terms and Conditions&lt;/h2&gt;
      &lt;TheLegalContent /&gt;
      &lt;UserConsent /&gt;
    &lt;/div&gt;
  );
};
export { TermsAndConditions };</span></pre> <p><span class="koboSpan" id="kobo.329.1">The sole component that gets exported in this code is </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">TermsAndConditions</span></strong><span class="koboSpan" id="kobo.331.1">, which is the primary subject of our testing strategy. </span><span class="koboSpan" id="kobo.331.2">In our tests, we employ </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">userEvent.click</span></strong><span class="koboSpan" id="kobo.333.1"> to initiate a click event within the realm of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">jsdom</span></strong><span class="koboSpan" id="kobo.335.1"> environment.</span></p>
<p><span class="koboSpan" id="kobo.336.1">Essentially, our focus is not on testing the isolated React components (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">CheckBox</span></strong><span class="koboSpan" id="kobo.338.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">Button</span></strong><span class="koboSpan" id="kobo.340.1">; they should have their own unit tests), but rather on the DOM elements and their interactions. </span><span class="koboSpan" id="kobo.340.2">It’s important to clarify that we’re not invoking a full-fledged browser here, but rather a headless </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">jsdom</span></strong><span class="koboSpan" id="kobo.342.1"> variant that exists in memory. </span><span class="koboSpan" id="kobo.342.2">Yet, despite the </span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.343.1">simulated environment of these integration tests, they still provide us with the confidence that the click event and button enable</span><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.344.1">ment are functioning as expected.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.345.1">Note</span></p>
<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.346.1">jsdom</span></strong><span class="koboSpan" id="kobo.347.1"> is a JavaScript-based </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.348.1">headless browser that can be used to create a realistic testing environment that simulates a web browser’s environment. </span><span class="koboSpan" id="kobo.348.2">It is an implementation of web standards such as HTML, DOM, CSS, and others, entirely in JavaScript.</span></p>
<p class="callout"><span class="koboSpan" id="kobo.349.1">When we run JavaScript that manipulates the DOM in a browser, the browser provides the DOM. </span><span class="koboSpan" id="kobo.349.2">However, when we are running tests using a testing framework such as Jest in a Node.js environment, there isn’t a DOM by default. </span><span class="koboSpan" id="kobo.349.3">This is where </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">jsdom</span></strong><span class="koboSpan" id="kobo.351.1"> comes into play. </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">jsdom</span></strong><span class="koboSpan" id="kobo.353.1"> provides a virtual DOM, thereby allowing our tests to run as though they were in a browser-like environment, even when they’re running in Node.js.</span></p>
<p class="callout"><span class="koboSpan" id="kobo.354.1">Why do we need </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">jsdom</span></strong><span class="koboSpan" id="kobo.356.1">? </span><span class="koboSpan" id="kobo.356.2">In modern frontend development, particularly with frameworks such as React, Angular, and Vue, our JavaScript code often interacts directly with the DOM. </span><span class="koboSpan" id="kobo.356.3">For our tests to be useful, they need to be able to simulate this interaction. </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">jsdom</span></strong><span class="koboSpan" id="kobo.358.1"> allows us to do this without needing to open a browser window.</span></p>
<p><span class="koboSpan" id="kobo.359.1">In integration tests, we concentrate on the interactions between various modules. </span><span class="koboSpan" id="kobo.359.2">However, even if these interactions function as expected, there’s still a possibility that the broader system may break. </span><span class="koboSpan" id="kobo.359.3">User journeys often involve multiple steps, so it’s essential to have a process that seamlessly connects these steps to ensure the so</span><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.360.1">ftware continues to work reliably.</span></p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.361.1">Learning about E2E tests using Cypress</span></h1>
<p><span class="koboSpan" id="kobo.362.1">E2E tests are at the top of the test pyramid. </span><span class="koboSpan" id="kobo.362.2">E2E tests simulate real user flows and interactions, testing the system as a whole. </span><span class="koboSpan" id="kobo.362.3">These tests help ensure that all parts of the application </span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.363.1">work together as expected, from the user interface to the backend systems.</span></p>
<p><span class="koboSpan" id="kobo.364.1">We’re going </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.365.1">to use Cypress as the E2E test framework in </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.366.1">this book. </span><strong class="bold"><span class="koboSpan" id="kobo.367.1">Cypress</span></strong><span class="koboSpan" id="kobo.368.1"> is a powerful tool for E2E testing of modern web applications. </span><span class="koboSpan" id="kobo.368.2">Its unique approach sets it apart from many other testing tools – instead of using Selenium, a common engine for many testing systems, Cypress operates directly on the actual browser, resulting in more reliable tests</span><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.369.1"> and a superior debugging experience.</span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.370.1">Installing Cypress</span></h2>
<p><span class="koboSpan" id="kobo.371.1">You can either install Cypress into an existing project (like what we’re doing in this book) or install it in </span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.372.1">another folder other than your project. </span><span class="koboSpan" id="kobo.372.2">Cypress has been added as a project dependency in the code base in GitHub (provided in the </span><i class="italic"><span class="koboSpan" id="kobo.373.1">Technical requirements</span></i><span class="koboSpan" id="kobo.374.1"> section), so you only need to run </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">npm install</span></strong><span class="koboSpan" id="kobo.376.1"> in the project root (refer to the official documentation for more information: </span><a href="https://docs.cypress.io/guides/getting-started/installing-cypress"><span class="koboSpan" id="kobo.377.1">https://docs.cypress.io/guides/getting-started/installing-cypress</span></a><span class="koboSpan" id="kobo.378.1">).</span></p>
<p><span class="koboSpan" id="kobo.379.1">Once you have installed the package, simply run </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">npx cypress open</span></strong><span class="koboSpan" id="kobo.381.1"> to launch the configuration wizard:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.382.1"><img alt="Figure 5.4: The Cypress wizard – choosing a test type" src="image/B31103_05_04.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.383.1">Figure 5.4: The Cypress wizard – choosing a test type</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.384.1">Follow the </span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.385.1">wizard to configure </span><strong class="bold"><span class="koboSpan" id="kobo.386.1">E2E Testing</span></strong><span class="koboSpan" id="kobo.387.1">, and choose </span><strong class="bold"><span class="koboSpan" id="kobo.388.1">Chrome</span></strong><span class="koboSpan" id="kobo.389.1"> as the browser for running all the tests. </span><span class="koboSpan" id="kobo.389.2">After that, choose </span><strong class="bold"><span class="koboSpan" id="kobo.390.1">Create </span></strong><strong class="bold"><span class="koboSpan" id="kobo.391.1">new spec</span></strong><span class="koboSpan" id="kobo.392.1">:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.393.1"><img alt="Figure 5.5: The Cypress wizard – creating a spec from a template" src="image/B31103_05_05.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.394.1">Figure 5.5: The Cypress wizard – creating a spec from a template</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.395.1">Cypress will </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.396.1">create a folder with all the necessary files for us:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.397.1">
cypress
├── downloads
├── e2e
│   └── quote-of-the-day.spec.cy.js
├── fixtures
│   └── example.json
└── support
    ├── commands.js
    └── e2e.js</span></pre> <p><span class="koboSpan" id="kobo.398.1">Let’s break his structure down:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.399.1">At the top level, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">cypress</span></strong><span class="koboSpan" id="kobo.401.1"> directory, which is the root directory for all the Cypress-related files.</span></li>
<li><span class="koboSpan" id="kobo.402.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">downloads</span></strong><span class="koboSpan" id="kobo.404.1"> directory is usually where files downloaded during Cypress tests would </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.405.1">be stored; we’re not going to use it here as we don’t have anything to save at this stage.</span></li>
<li><span class="koboSpan" id="kobo.406.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">e2e</span></strong><span class="koboSpan" id="kobo.408.1"> directory is where E2E test files are located. </span><span class="koboSpan" id="kobo.408.2">In this case, it contains </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">quote-of-the-day.spec.cy.js</span></strong><span class="koboSpan" id="kobo.410.1"> (generated from the Cypress wizard), a Cypress test file for testing the quote-of-the-day feature of an application.</span></li>
<li><span class="koboSpan" id="kobo.411.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">fixtures</span></strong><span class="koboSpan" id="kobo.413.1"> directory is a place to put external static data that your tests will use. </span><span class="koboSpan" id="kobo.413.2">We can put some static files that can be used in our tests (for example, if our tests need some JSON data for mocking the network’s response).</span></li>
<li><span class="koboSpan" id="kobo.414.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">support</span></strong><span class="koboSpan" id="kobo.416.1"> directory houses Cypress commands and support files, which we will not touch either.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.417.1">Once we have the folder structure set up, we can proceed and write our first test.</span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.418.1">Running our first E2E test</span></h2>
<p><span class="koboSpan" id="kobo.419.1">Let’s modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">quote-of-the-day.spec.cy.js</span></strong><span class="koboSpan" id="kobo.421.1"> file to make it access a remote website. </span><span class="koboSpan" id="kobo.421.2">Cypress </span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.422.1">will actively watch the files under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">cypress/e2e/</span></strong><span class="koboSpan" id="kobo.424.1"> folder, and whenever the content changes, it will rerun the test.</span></p>
<p><span class="koboSpan" id="kobo.425.1">Make sure you have launched cypress in a terminal window (either Terminal for MacOS/Linux or Windows Terminal) with </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">npx </span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">cypress open</span></strong><span class="koboSpan" id="kobo.428.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.429.1">
describe('quote of the day', () =&gt; {
  it('display the heading', () =&gt; {
    cy.visit('</span><a href="https://icodeit-juntao.github.io/quote-of-the-day/');"><span class="koboSpan" id="kobo.430.1">https://icodeit-juntao.github.io/quote-of-the-day/');</span></a><span class="koboSpan" id="kobo.431.1">
  })
});</span></pre> <p><span class="koboSpan" id="kobo.432.1">In this code snippet, </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">describe</span></strong><span class="koboSpan" id="kobo.434.1"> is used to declare a test suite – in this case, for the quote of the day feature. </span><span class="koboSpan" id="kobo.434.2">Within this suite, there’s a single test case defined by it, labeled </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">display the heading</span></strong><span class="koboSpan" id="kobo.436.1">. </span><span class="koboSpan" id="kobo.436.2">The purpose of this test case is to visit a web page – in this instance, </span><a href="https://icodeit-juntao.github.io/quote-of-the-day/"><span class="koboSpan" id="kobo.437.1">https://icodeit-juntao.github.io/quote-of-the-day/</span></a><span class="koboSpan" id="kobo.438.1"> – and this web page returns a random quote each time the user refreshes the page.</span></p>
<p><span class="koboSpan" id="kobo.439.1">However, it’s important to note that this test case doesn’t perform any actual tests or assertions yet. </span><span class="koboSpan" id="kobo.439.2">It merely navigates to the page. </span><span class="koboSpan" id="kobo.439.3">To make this a meaningful test, you would typically </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.440.1">add assertions to check the state of specific elements on the page, such as the heading or a quote displayed:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.441.1">
it('display the heading', () =&gt; {
  cy.visit('</span><a href="https://icodeit-juntao.github.io/quote-of-the-day/');"><span class="koboSpan" id="kobo.442.1">https://icodeit-juntao.github.io/quote-of-the-day/');</span></a><span class="koboSpan" id="kobo.443.1">
  cy.contains("Quote of the day");
})</span></pre> <p><span class="koboSpan" id="kobo.444.1">This code snippet is a meaningful test now. </span><span class="koboSpan" id="kobo.444.2">After visiting </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">https://icodeit-juntao.github.io/quote-of-the-day/</span></strong><span class="koboSpan" id="kobo.446.1">, this test now contains an additional check with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">cy.contains()</span></strong><span class="koboSpan" id="kobo.448.1"> method. </span><span class="koboSpan" id="kobo.448.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">cy.contains()</span></strong><span class="koboSpan" id="kobo.450.1"> method is used to search for and get a DOM element that contains the specified text – in this case, </span><strong class="bold"><span class="koboSpan" id="kobo.451.1">Quote of the day</span></strong><span class="koboSpan" id="kobo.452.1">. </span><span class="koboSpan" id="kobo.452.2">This method will get the first element it finds that contains the text, and it will fail the test if no such element is found.</span></p>
<p><span class="koboSpan" id="kobo.453.1">If the test can pass, we’re confident that the URL is accessible to the public, and the page doesn’t throw any exceptions:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.454.1"><img alt="Figure 5.6: Running E2E tests inside Cypress Test Runner" src="image/B31103_05_06.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.455.1">Figure 5.6: Running E2E tests inside Cypress Test Runner</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.456.1">Note that in </span><i class="italic"><span class="koboSpan" id="kobo.457.1">Figure 5</span></i><i class="italic"><span class="koboSpan" id="kobo.458.1">.6</span></i><span class="koboSpan" id="kobo.459.1">, on the right-hand side of the screen, you can see what is displayed on the real browser, while on the left-hand side, you can see the test cases and steps. </span><span class="koboSpan" id="kobo.459.2">You can even use the mouse to hover on a step to see the page snapshot at that point.</span></p>
<p><span class="koboSpan" id="kobo.460.1">In addition, we can </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.461.1">add another test case to verify that a quote container is present on the page; that is the most important part of the quote of the day application – to make sure a quote shows up:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.462.1">
it('display a quote', () =&gt; {
  cy.visit('https://icodeit-juntao.github.io/quote-of-the-day/');
  cy.get('[data-testid="quote-container"]').should('have.length', 1);
})</span></pre> <p><span class="koboSpan" id="kobo.463.1">In this test, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">cy.get()</span></strong><span class="koboSpan" id="kobo.465.1"> method is used to retrieve a DOM element by its </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">data-testid</span></strong><span class="koboSpan" id="kobo.467.1"> attribute. </span><span class="koboSpan" id="kobo.467.2">This attribute is typically used for testing, allowing you to select elements without the need to worry about their CSS selectors or contents, which might change over time.</span></p>
<p><span class="koboSpan" id="kobo.468.1">The element that’s being selected in this test has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">data-testid</span></strong><span class="koboSpan" id="kobo.470.1"> attribute of </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">quote-container</span></strong><span class="koboSpan" id="kobo.472.1">. </span><span class="koboSpan" id="kobo.472.2">Once the element is retrieved, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">should()</span></strong><span class="koboSpan" id="kobo.474.1"> method is invoked to assert </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.475.1">something about the state of that element. </span><span class="koboSpan" id="kobo.475.2">In this case, it checks that the length of the element (that is, the number of matching elements) is </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">1</span></strong><span class="koboSpan" id="kobo.477.1">.</span></p>
<p><span class="koboSpan" id="kobo.478.1">So, in this test, after navigating to the web page, it looks for an element with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">data-testid</span></strong><span class="koboSpan" id="kobo.480.1"> attribute of </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">quote-container</span></strong><span class="koboSpan" id="kobo.482.1">, and checks that exactly one such element exists. </span><span class="koboSpan" id="kobo.482.2">If it does, the test will pass; if not (either because there are no matching elements or more than one), the test will fail.</span></p>
<p><span class="koboSpan" id="kobo.483.1">That is awesome, but there is a problem here: what if the page isn’t blank and the heading is rendered correctly, but the actual content of a quote doesn’t show up for some reason? </span><span class="koboSpan" id="kobo.483.2">Alternatively, what if the quotes are visible but we’re uncertain about the expected quotes when we’re writing the tests? </span><span class="koboSpan" id="kobo.483.3">Consider, for instance, the </span><a href="https://icodeit-juntao.github.io/quote-of-the-day/"><span class="koboSpan" id="kobo.484.1">https://icodeit-juntao.github.io/quote-of-the-day/</span></a><span class="koboSpan" id="kobo.485.1"> website, which generates random quotes each time it’s accessed. </span><span class="koboSpan" id="kobo.485.2">Different users may encounter different quotes at various times. </span><span class="koboSpan" id="kobo.485.3">To address these variables, we need a structured method for testing appl</span><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.486.1">ications with such unpredictable behavior.</span></p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.487.1">Intercepting the network request</span></h2>
<p><span class="koboSpan" id="kobo.488.1">In some cases, we don’t want to send actual network requests for the UI to work, while in other </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.489.1">cases, it’s not practical to rely on the response directly. </span><span class="koboSpan" id="kobo.489.2">We want to verify whether the quote is rendered correctly by checking the content, but as the quoted content is generated randomly, we cannot predict it before we make the network request. </span><span class="koboSpan" id="kobo.489.3">This means we need a mechanism to pin down the response, but we would also like to send the request.</span></p>
<p><span class="koboSpan" id="kobo.490.1">One way to achieve that is to intercept the network request that’s sent to the endpoint and return some fixed data. </span><span class="koboSpan" id="kobo.490.2">In Cypress, we can do that through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">cy.intercept</span></strong><span class="koboSpan" id="kobo.492.1"> API.</span></p>
<p><span class="koboSpan" id="kobo.493.1">Firstly, we can define a data array in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">quote-of-the-day.spec.cy.js</span></strong><span class="koboSpan" id="kobo.495.1"> file. </span><span class="koboSpan" id="kobo.495.2">It’s a normal </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.496.1">JavaScript array that contains the data we expect to return from the server side:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.497.1">
const quotes = [
  {
    content:
      "Any fool can write code that a computer can understand. </span><span class="koboSpan" id="kobo.497.2">Good 
       programmers write code that humans can understand.",
    author: "Martin Fowler",
  },
  {
    content: "Truth can only be found in one place: the code.",
    author: "Robert C. </span><span class="koboSpan" id="kobo.497.3">Martin",
  },
  {
    content:
      "Optimism is an occupational hazard of programming: feedback is 
       the treatment.",
    author: "Kent Beck",
  },
];</span></pre> <p><span class="koboSpan" id="kobo.498.1">In the testing code, we aim to capture any network requests that are sent to URLs beginning with </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">https://api.quotable.io/quotes/random</span></strong><span class="koboSpan" id="kobo.500.1">. </span><span class="koboSpan" id="kobo.500.2">Whenever the request is sent from React, Cypress will cancel the request and return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">quotes</span></strong><span class="koboSpan" id="kobo.502.1"> array instead; this means </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.503.1">the test doesn’t depend on whether the remote service is working or not. </span><span class="koboSpan" id="kobo.503.2">That way, our test is more stable. </span><span class="koboSpan" id="kobo.503.3">We can see the code here:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.504.1">
it("display the quote content", () =&gt; {
  cy.intercept("GET", "https://api.quotable.io/quotes/random*", {
    statusCode: 200,
    body: quotes,
  });
  cy.visit("https://icodeit-juntao.github.io/quote-of-the-day/");
  cy.contains(
    "Any fool can write code that a computer can understand. </span><span class="koboSpan" id="kobo.504.2">Good 
     programmers write code that humans can understand."
</span><span class="koboSpan" id="kobo.504.3">  );
  cy.contains(
    "Martin Fowler"
  );
});</span></pre> <p><span class="koboSpan" id="kobo.505.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">cy.intercept</span></strong><span class="koboSpan" id="kobo.507.1"> function is being used to stub the HTTP GET request to the quote API. </span><span class="koboSpan" id="kobo.507.2">When such a request is detected, rather than letting the request go through to the actual API, Cypress will respond with a predefined HTTP response. </span><span class="koboSpan" id="kobo.507.3">This response has a status code of 200, indicating success, and the body of the response is set to be our predefined quotes data. </span><span class="koboSpan" id="kobo.507.4">This technique allows us to control the data being returned, making our test more deterministic and isolated from any potential instability or variation in the actual API.</span></p>
<p><span class="koboSpan" id="kobo.508.1">The test then navigates to the quote web page. </span><span class="koboSpan" id="kobo.508.2">After the page is loaded, it verifies if the page contains the expected quote text and the quote author. </span><span class="koboSpan" id="kobo.508.3">If these two checks pass, the test case succeeds.</span></p>
<p><span class="koboSpan" id="kobo.509.1">Something is interesting here that we need to highlight. </span><span class="koboSpan" id="kobo.509.2">An E2E test, by definition, tests the whole software stack from the frontend through to the backend, including all the intermediate layers, such as databases and network infrastructure. </span><span class="koboSpan" id="kobo.509.3">E2E testing aims to simulate real-world scenarios and confirm that the entire application is functioning correctly.</span></p>
<p><span class="koboSpan" id="kobo.510.1">However, when we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">cy.intercept</span></strong><span class="koboSpan" id="kobo.512.1"> function to stub HTTP requests, we are indeed modifying this behavior. </span><span class="koboSpan" id="kobo.512.2">We are no longer testing the complete E2E flow because </span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.513.1">we are controlling and replacing the actual backend response with a mock response. </span><span class="koboSpan" id="kobo.513.2">This technique transforms the test from an E2E test into something more akin to an integration test for the frontend as we are testing the integration of different components of the frontend while mocking the backend responses.</span></p>
<p><span class="koboSpan" id="kobo.514.1">This is not necessarily a bad thing, however. </span><span class="koboSpan" id="kobo.514.2">Often, in testing, especially in complex systems, it is beneficial to isolate different parts of the system to gain more control over what we are testing and to ensure we can test different scenarios more reliably and deterministically.</span></p>
<p><span class="koboSpan" id="kobo.515.1">With that, we’ve covered the basics of Cypress for E2E testing and you’re now equipped to wri</span><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.516.1">te robust E2E tests for your web applications.</span></p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.517.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.518.1">In this chapter, we embarked on an exploration of the world of testing in a React application. </span><span class="koboSpan" id="kobo.518.2">We understood that the necessity of testing goes beyond mere validation of code correctness; it paves the path toward maintainability, improves readability, and drives the evolution of our application, ultimately ensuring we build software that meets expectations consistently.</span></p>
<p><span class="koboSpan" id="kobo.519.1">Testing is a vital practice in software development – one that ensures our application not only works correctly but is also resilient to future changes. </span><span class="koboSpan" id="kobo.519.2">The React ecosystem, with tools such as Jest, the React Testing Library, and Cypress, provides us with a powerful arsenal to implement comprehensive testing strategies, thus bolstering the robustness and reliability of our applications.</span></p>
<p><span class="koboSpan" id="kobo.520.1">In the next chapter, we’ll look into the common refactoring techniques and see how tests can help us during the refactoring process.</span></p>
</section>
</body></html>