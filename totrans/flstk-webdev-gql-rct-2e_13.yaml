- en: '*Chapter 11*: Writing Tests for React and Node.js'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've written a lot of code and come across a variety of problems. We
    haven't yet implemented automated testing for our software; however, it's a common
    approach to make sure everything works after making changes to your application.
    Automated testing drastically improves the quality of your software and reduces
    errors in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we will cover the following main topics in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use Mocha for testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the GraphQL **application programming interface** (**API**) with Mocha
    and Chai
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing React with Enzyme and JSDOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available in the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter11)'
  prefs: []
  type: TYPE_NORMAL
- en: Testing with Mocha
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem we're facing is that we must ensure the quality of our software
    without increasing the amount of manual testing. It isn't possible to recheck
    every feature of our software when new updates are released. To solve this problem,
    we're going to use Mocha, which is a JavaScript testing framework that is used
    to run a series of asynchronous tests. If all the tests pass successfully, your
    application is OK and can get released to production.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers follow the **test-driven development** (**TDD**) approach. Often,
    when you implement tests for the first time, they fail because the business logic
    that's being tested is missing. After implementing all the tests, we have to write
    the actual application code to meet the requirements of the tests. In this book,
    we haven't followed this approach, but it isn't a problem as we can implement
    tests afterward too. Typically, I tend to write tests in parallel with the application
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, we have to install all the dependencies to test our application
    with `npm`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `mocha` package includes almost everything to run tests. Along with Mocha,
    we also install `chai`, which is an assertion library. It offers excellent ways
    to chain tests with many variables and types for use inside a Mocha test. We also
    install the `@babel/polyfill` package, which allows our test to support `request`
    package as a library to send all the queries or mutations within our test. I recommend
    you set the `NODE_ENV` environment variable to `production` to test every functionality,
    as in a live environment. Be sure that you set the environment variable correctly
    so that all production features are used.
  prefs: []
  type: TYPE_NORMAL
- en: Our first Mocha test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s add a new command to the `scripts` field of our `package.json`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you now execute `npm run test`, we'll run the `mocha` package in the `test`
    folder, which we'll create in a second. The preceding `--require` option loads
    the specified file or package. We'll also load a `babel-hook.js` file, which we'll
    create as well. The `--recursive` parameter tells Mocha to run through the complete
    file tree of the `test` folder, not just the first layer. This behavior is useful
    because it allows us to structure our tests in multiple files and folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with the `babel-hook.js` file by adding it to the root of our
    project, next to the `package.json` file. Insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this file is to give us an alternative Babel configuration file
    to our standard `.babelrc` file. If you compare both files, you should see that
    we use the `require-context-hook` plugin. We already use this plugin when starting
    the backend with `npm run server`. It allows us to import our Sequelize models
    using a **regular expression** (**regex**).
  prefs: []
  type: TYPE_NORMAL
- en: If we start our test with `npm run test`, we require this file at the beginning.
    Inside the `babel-hook.js` file, we load `@babel/register`, which compiles all
    the files that are imported afterward in our test according to the preceding configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when running a production build or environment, the production database
    is also used. All changes are made to this database. Verify that you have configured
    the database credentials correctly in the server's `configuration` folder. You
    have only to set the `host`, `username`, `password`, and `database` environment
    variables correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us the option to start our backend server from within our test file
    and render our application on the server. The preparation for our test is now
    finished. Create a folder named `test` inside the root of our project to hold
    all runnable tests. Mocha will scan all files or folders, and all tests will be
    executed. To get a basic test running, create an `app.test.js` file. This is the
    main file, which makes sure that our backend is running and in which we can subsequently
    define further tests. The first version of our test looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at what''s happening here, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We import the Node.js `assert` function. This gives us the ability to verify
    the value or type of a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We import the `request` package, which we use to send queries against our backend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We import two Chai functions, `expect` and `should`, from the `chai` package.
    Neither of these is included in Mocha, but they both improve the test's functionality
    significantly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The beginning of the test starts with the `describe` function. Because Mocha
    executes the `app.test.js` file, we're in the correct scope and can use all Mocha
    functions. The `describe` function is used to structure your test and its output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `it` function, which initiates the first test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `it` function can be understood as a feature of our application that we
    want to test inside the callback function. As the first parameter, you should
    enter a sentence, such as `'it does this and that'`, that's easily readable. The
    function itself waits for the complete execution of the `callback` function in
    the second parameter. The result of the callback will either be that all assertions
    were successful or that, for some reason, a test failed or the callback didn't
    complete in a reasonable amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: The `describe` function is the header of our test's output. Then, we have a
    new row for each `it` function we execute. Each row represents a single test step.
    The `it` function passes a `done` function to the callback. The `done` function
    has to be executed once all assertions are finished and there's nothing left to
    do. If it isn't executed in a certain amount of time, the current test is marked
    as failed. In the preceding code snippet, the first thing we did was send a `GET`
    request to `http://localhost:8000`, which is accepted by our backend server. The
    expected answer will be in the form of server-side rendered **HyperText Markup
    Language** (**HTML**) created through React.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prove that the response holds this information, we make some assertions
    in our preceding test, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `should` function from Chai. The great thing is that it's chainable
    and represents a sentence that directly explains the meaning of what we're doing.
    The `should.not.exist` function chain makes sure that the given value is empty.
    The result is `true` if the value is `undefined` or `null`, for example. The consequence
    is that when the `err` variable is filled, the assertion fails and so our test,
    `'renders and serves the index page'`, fails too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The same goes for the `should.exist` line. It makes sure that the `res` variable,
    which is the response given by the backend, is filled. Otherwise, there's a problem
    with the backend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `expect` function can also represent a sentence, as with both functions
    before. We expect `res.statusCode` to have a value of `200`. This assertion can
    be written as `expect(res.statusCode).to.be.equal(200)`. We can be sure that everything
    has gone well if the HTTP status is `200`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If nothing has failed so far, we check whether the returned `body` variable,
    which is the third callback parameter of the `request` function, is valid. For
    our test scenario, we only need to check whether it contains an `html` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We execute the `done` function. We pass the `err` object as a parameter. The
    result of this function is much like the `should.not.exist` function. If you pass
    a filled error object to the `done` function, the test fails. The tests become
    more readable when using the Chai syntax.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you execute `npm run test` now, you''ll receive the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Failed test because no server ran'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.01_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – Failed test because no server ran
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first `should.not.exist` assertion failed and threw an error. This is because
    we didn''t start the backend when we ran the test. Start the backend in a second
    terminal with the correct environment variables using `npm run server` and rerun
    the test. Now, the test is successful, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Test passes if the server runs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.02_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – Test passes if the server runs
  prefs: []
  type: TYPE_NORMAL
- en: The output is good, but the process isn't very intuitive. The current workflow
    is hard to implement when running the tests automatically while deploying your
    application or pushing new commits to your **version control system** (**VCS**).
    We'll change this behavior next.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the backend with Mocha
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we want to run a test, the server should start automatically. There are
    two options to implement this behavior, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: We add the `npm run server` command to the `test` script inside our `package.json`
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We import all the necessary files to launch the server within our `app.test.js`
    file. This allows us to run further assertions or commands against the backend.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The best option is to start the server within our test and not rely on a second
    command because we can run further tests on the backend. We need to import a further
    package to allow the server to start within our test, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We use and execute this package because we load the Sequelize models using the
    `require.context` function. By loading the package, the `require.context` function
    is executable for the server-side code. Before we started the server within the
    test, the plugin hadn't been used, although it was loaded in the `babel-hooks.js`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can load the server directly in the test. Add the following lines of
    code at the top of the `describe` function, just before the test we''ve just written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The idea is to load the server's `index.js` file inside of our test, which starts
    the backend automatically. To do this, we define an empty variable called `app`.
    Then, we use `this.timeout` to set the timeout for all tests inside Mocha to `50000`
    because starting our server, including Apollo Server, takes some time. Otherwise,
    the test will probably fail because the start time is too long for the standard
    Mocha timeout.
  prefs: []
  type: TYPE_NORMAL
- en: We must make sure that the server has been completely started before any of
    our tests are executed. This logic can be achieved with Mocha's `before` function.
    Using this function, you can set up and configure things such as starting a backend
    in our scenario. To continue and process all the tests, we need to execute the
    `done` function to complete the callback of the `before` function. To be sure
    that the server has started, we do not just run the `done` function after loading
    the `index.js` file. We bind the `listening` event of the server using the `app.on`
    function. If the server emits the `listening` event, we can securely run the `done`
    function, and all tests can send requests to the server. We could also save the
    return value of the `require` function directly into the `app` variable to hold
    the `server` object. The problem with this order, however, is that the server
    may start listening before we can bind the `listening` event. The way we are doing
    it now makes sure the server hasn't yet started.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test, however, still isn''t working. You''ll see an error message that
    says `''TypeError: app.on is not a function''`. Take a closer look at the server''s
    `index.js` file. At the end of the file, we aren''t exporting the `server` object
    because we only used it to start the backend. This means that the `app` variable
    in our test is empty and we can''t run the `app.on` function. The solution is
    to export the `server` object at the end of the server''s `index.js` file, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can now execute the test again. Everything should look fine, and all tests
    should pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, one last problem. If you compare the behavior from the test
    before importing the server directly in our test or starting it in a second terminal,
    you might notice that the test isn''t finished, or at least the process isn''t
    stopped. Previously, all steps were executed, we returned to the normal shell,
    and we could execute the next command. The reason for this is that the server
    is still running in our `app.test.js` file. Therefore, we must stop the backend
    after all tests have been executed. Insert the following code after the `before`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `after` function is run when all tests are finished. Our `app` object offers
    the `close` function, which terminates the server. As a callback, we hand over
    the `done` function, which is executed once the server has stopped. This means
    that our test has also finished.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the correct routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now want to check whether all the features of our application are working
    as expected. One major feature of our application is that React Router redirects
    the user in the following two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: The user visits a route that cannot be matched.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user visits a route that can be matched, but they aren't allowed to view
    the page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In both cases, the user should be redirected to the login form. In the first
    case, we can follow the same approach as for our first test. We send a request
    to a path that isn''t inside our router. Add the following code to the bottom
    of the `describe` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s quickly go through all the steps of the preceding test, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We add a new `describe` function to structure our test's output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We send a request inside another `it` function to an unmatched path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The checks are the same as the ones we used when starting the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We verify that the response's path is the `/` root. That happens when the redirect
    is executed. Therefore, we use the `res.req.path === '/'` condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We check whether the returned `body` variable includes an HTML tag with the
    `authModal` class. This should happen when the user isn't logged in, and the login
    or register form is rendered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the assertions are successful, we know that React Router works correctly
    in the first scenario. The second scenario relates to private routes that can
    only be accessed by authenticated users. We can copy the preceding check and replace
    the request. The assertions we are doing stay the same, but the **Uniform Resource
    Locator** (**URL**) of the request is different. Add the following test under
    the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If an unauthenticated user requests the `/app` route, they're redirected to
    the `/` root path. The assertions verify whether the login form is displayed as
    before. To differentiate the tests, we add a new `describe` function so that it
    has a better structure.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how use Mocha to assert that our application
    works correctly. We are now verifying whether our application starts and also
    whether the routing works as expected and returns the correct pages.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to test the GraphQL API that we built, not only the **server-side
    rendering** (**SSR**) functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the GraphQL API with Mocha
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We must verify that all the API functions we''re offering work correctly. I''m
    going to show you how to do this with two examples, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The user needs to sign up or log in. This is a critical feature where we should
    verify that the API works correctly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user queries or mutates data via the GraphQL API. For our test case, we
    will request all chats the logged-in user is related to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those two examples should explain all the essential techniques to test every
    part of your API. You can add more functions that you want to test at any point.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We extend the authentication tests of our test with the signup functionality.
    We're going to send a simple GraphQL request to our backend, including all the
    required data to sign up a new user. We've already sent requests, so there's nothing
    new here. In comparison to all the requests before, however, we have to send a
    `POST` request, not a `GET` request. Also, the endpoint for the signup is the
    `/graphql` path, where our Apollo Server listens for incoming mutations or queries.
    Normally, when a user signs up for Graphbook, the authentication token is returned
    directly, and the user is logged in. We must preserve this token to make future
    GraphQL requests. We don't use Apollo Client for our test as we don't need to
    test the GraphQL API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a global variable next to the `app` variable, where we can store the
    **JavaScript Object Notation (JSON) Web Token** (**JWT**) returned after signup,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the test, we can set the returned JWT. Add the following code to the
    `authentication` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We begin by creating a `json` variable. This object is sent as a JSON body to
    our GraphQL API. The content of it should be familiar to you—it's nearly the same
    format we used when testing the GraphQL API in Postman.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSON we send represents a manual way of sending GraphQL requests. There
    are libraries that you can easily use to save this and directly send the query
    without wrapping it inside an object, such as `graphql-request`: [https://github.com/prisma-labs/graphql-request](https://github.com/prisma-labs/graphql-request).'
  prefs: []
  type: TYPE_NORMAL
- en: The `json` object includes fake signup variables to create a user with the `mochatest`
    username. We'll send HTTP `POST` with the `request.post` function. To use the
    `json` variable, we pass it into the `json` field. The `request.post` function
    automatically adds the body as a JSON string and the correct `Content-Type` header
    for you. When the response arrives, we run the standard checks, such as checking
    for an error or checking an HTTP status code. We also check the format of the
    returned `body` variable because the response's `body` variable won't return HTML
    but will return JSON instead. We make sure that it's an object with the `should.be.an('object')`
    function. The `should` assertion can directly be used and chained to the `body`
    variable. If `body` is an object, we check whether there's a `data` property inside.
    That's enough security to read the token from the `body.data.signup.token` property.
  prefs: []
  type: TYPE_NORMAL
- en: The user is now created in our database. We can use this token for further requests.
    Be aware that running this test a second time on your local machine is likely
    to result in a failure because the user already exists. In this case, you can
    delete it manually from your database. This problem won't occur when running this
    test while using **continuous integration** (**CI**). We'll focus on this topic
    in the last chapter. Next, we'll make an authenticated query to our Apollo Server
    and test the result of it.
  prefs: []
  type: TYPE_NORMAL
- en: Testing authenticated requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We set the `authToken` variable after the signup request. You could also do
    this with a login request if a user already exists while testing. Only the query
    and the assertions we are using are going to change. Also, insert the following
    code into the `before` authentication function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code snippet, the `json` object doesn''t include
    any variables because we only query the chats of the logged-in user. We changed
    the `query` string accordingly. Compared to the login or signup request, the chat
    query requires the user to be authenticated. The `authToken` variable we saved
    is sent inside the `Authorization` header. We now verify again whether the request
    was successful and check for a `data` property in the `body` variable. Notice
    that, before running the `done` function, we verify that the `data` object has
    a field called `chats`. We also check the length of the `chats` field, which proves
    that it''s an array. The length can be statically set to `0` because the user
    who''s sending the query just signed up and doesn''t have any chats yet. The output
    from Mocha looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11\. 3 – Authentication test'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.03_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11\. 3 – Authentication test
  prefs: []
  type: TYPE_NORMAL
- en: This is all you need to know to test all the features of your API.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to have a look on Enzyme, which is a great testing tool that
    allows you to interact with the React components that we have written and ensure
    that they are working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Testing React with Enzyme
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve managed to test our server and all GraphQL API functions. Currently,
    however, we''re still missing the tests for our frontend code. While we render
    the React code when requesting any server route, such as the `/app` path, we only
    have access to the final result and not to each component. We should change this
    to execute the functions of certain components that aren''t testable through the
    backend. First, install some dependencies before using `npm`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The various packages are described in more detail here:'
  prefs: []
  type: TYPE_NORMAL
- en: The `enzyme` and `@wojtekmaj/enzyme-adapter-react-17` packages provide React
    with specific features to render and interact with the React tree. This can be
    through either a real **Document Object Model** (**DOM**) or shallow rendering.
    We are going to use a real DOM in this chapter because it allows us to test all
    features, while shallow rendering is limited to just the first layer of components.
    We need to rely on a third-party package for the React adapter because there is
    no official support at the moment for React 17 from Enzyme.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ignore-styles` package strips out all `import` statements for **Cascading
    Style Sheets** (**CSS**) files. This is very helpful since we don't need CSS for
    our tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `jsdom` package creates a DOM object for us, which is then used to render
    the React code into.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `isomorphic-fetch` package replaces the `fetch` function that all browsers
    provide by default. This isn't available in Node.js, so we need a polyfill.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We start by importing the new packages directly under the other `require` statements,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To use Enzyme, we import React. Then, we create an adapter for Enzyme that
    supports React 16\. We insert the adapter into Enzyme''s `configure` statement.
    Before starting with the frontend code, we import the `ignore-styles` package
    to ignore all CSS imports. I''ve also directly excluded **Syntactically Awesome
    Style Sheets** (**SASS**) and SCSS files. The next step is to initialize our DOM
    object, where all the React code is rendered. Here''s the code you''ll need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We require the `jsdom` package and initialize it with a small HTML string. We
    don't take the template file that we're using for the server or client because
    we just want to render our application to any HTML, so how it looks isn't important.
    The second parameter is an `options` object. We specify a `url` field, which is
    the host URL, under which we render the React code. Otherwise, we might get an
    error when accessing `localStorage`. After initialization, we extract the `window`
    object and define two global variables that are required to mount a React component
    to our fake DOM. These two properties behave like the `document` and `window`
    objects in the browser, but instead of the browser, they are global objects inside
    our Node.js server.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it isn't a good idea to mix up the Node.js `global` object with
    the DOM of a browser and render a React application in it. Still, we're merely
    testing our application and not running it in production in this environment,
    so while it might not be recommended, it helps our test to be more readable. We'll
    begin the first frontend test with our login form. The visitor to our page can
    either directly log in or switch to the signup form. Currently, we don't test
    this switch functionality in any way. This is a complex example, but you should
    be able to understand the techniques behind it quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To render our complete React code, we''re going to initialize an Apollo Client
    for our test. Import all the dependencies, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We also import the `index.js` component of the server-rendered React code.
    This component will receive our client, which we''ll initialize shortly. Add a
    new `describe` function for all frontend tests, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code creates a new Apollo Client. The client doesn''t implement
    any logic, such as authentication or WebSockets, because we don''t need this to
    test the switch from the login form to the signup form. It''s merely a required
    property to render our application completely. If you want to test components
    that are only rendered when being authenticated, you can, of course, implement
    it easily. Enzyme requires us to pass a real React component, which will be rendered
    to the DOM. Add the following code directly beneath the `client` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is a small wrapper around the `App` variable that we imported
    from the server''s `ssr` folder. The `client` property is filled with the new
    Apollo Client. Follow the given instructions to render and test your React frontend
    code. The following code goes directly under the `Graphbook` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `mount` function of Enzyme to render the `Graphbook` class to the
    DOM, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `wrapper` variable provides many functions to access or interact with the
    DOM and the components inside it. We use it to prove that the first render displays
    the login form. The code is illustrated here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `html` function of the `wrapper` variable returns the complete HTML string
    that has been rendered by the React code. We check this string with the `contain`
    function of Chai. If the check is successful, we can continue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Typically, the user clicks on the `wrapper` variable. The enzyme comes with
    that functionality innately, as illustrated here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `find` function gives us access to the `LoginRegisterForm` component. Inside
    the markup of the component, we search for an `a` tag, of which there can only
    be one. If the `find` method returns multiple results, we can't trigger things
    such as a click because the `simulate` function is fixed to only one possible
    target. After running both `find` functions, we execute Enzyme's `simulate` function.
    The only parameter needed is the event that we want to trigger. In our scenario,
    we trigger a `click` event on the `a` tag, which lets React handle all the rest.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We check whether the form was changed correctly by executing the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `html` and `contain` functions to verify that everything was rendered
    correctly. The `done` method of Mocha is used to finish the test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For a more detailed overview of the API and all the functions that Enzyme provides,
    have a look at the official documentation: [https://enzymejs.github.io/enzyme/docs/api/](https://enzymejs.github.io/enzyme/docs/api/).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This was the easy part. How does this work when we want to verify whether the
    client can send queries or mutations with authentication? It''s actually not that
    different. We already registered a new user and got a JWT in return. All we need
    to do is attach the JWT to our Apollo Client, and the router needs to receive
    the correct `loggedIn` property. The final code for this test looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the `AuthLink` function that we used in the original frontend
    code. We pass the `authToken` variable to every request that's made by the Apollo
    Client. In the `Apollo.from` method, we add it before `httpLink`. In the `Graphbook`
    class, we set `loggedIn` to `true` and `location` to `/app` to render the newsfeed.
    Because the requests are asynchronous by default and the `mount` method doesn't
    wait for the Apollo Client to fetch all queries, we couldn't directly check the
    DOM for the correct content. Instead, we wrapped the assertions and the `done`
    function in a `setTimeout` function. A timeout of 2,000 `currentUser` query has
    been run and the top bar has been rendered to show the logged-in user. With these
    two examples, you should now be able to run any test you want with your application's
    frontend code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned all the essential techniques to test your application
    automatically, including testing the server, the GraphQL API, and the user's frontend.
    You can apply the Mocha and Chai patterns you learned to other projects to reach
    a high software quality at any time. Your personal testing time will be greatly
    reduced.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll have a look at how to improve performance and error
    logging so that we're always providing a good **user experience** (**UX**).
  prefs: []
  type: TYPE_NORMAL
