["```js\n# Use the official Node.js 14 Alpine image from https://hub.docker.com/_/node.\n# Using an image with specific version tags allows deterministic builds.\nFROM node:16.17.0-alpine\n# Create and change to the app directory.\nWORKDIR /usr/src/frontend\n# Copy important root files to the builder image.\nCOPY package*.json ./\n# Install production dependencies.\nRUN npm install\n# Copy the Vue 3 source to the container image.\nCOPY . .\n# Expose container port\nEXPOSE 3000\n# Run the Vue service on container startup.\nCMD [\"npm\", \"run\", \"dev\"]\n```", "```js\n// build the image\ndocker build -t pinterest-vue-frontend .\n// check the images\ndocker images\n```", "```js\n\nIn summary, we have successfully dockerized our Vue.js 3 Pinterest application. In the next section, we will dockerize the Strapi backend application separately.\n\n### Dockerizing the Strapi backend app\n\nIn this section, we will follow the same approach used in dockerizing the Vue.js 3 frontend project to create a Docker instance for the Strapi backend.\n\nTherefore, create a Dockerfile inside the Strapi backend folder of your project and add the following configuration code:\n\n```", "```js\n\nWe copied the previous configuration and changed the building process for the backend app. The code snippet is self-explanatory with comments explaining every command we used in the Dockerfile. In the next section, we are going to run the applications on Docker and test them separately.\n\n### Running the images on Docker\n\nAfter building the Docker image, next, we need to run the image on Docker using the following command:\n\n```", "```jsbash\n// run the Frontend image\ndocker run -d -p  3000:3001 --name pinterest-frontend pinterest-vue-frontend\n// run the Strapi Backend Image\ndocker run -d -p  1337:3002 --name pinterest-backend pinterest-strapi-backend\n// check the container\ndocker ps\n```", "```js\n\nThe `ps` command checks the container for the list of images currently running in your Docker engine. You should see two images with the names specified in the preceding Docker `run` command.\n\nIf the `run` command is successful, you can access the frontend application on the web at the address `http://localhost:3001` and the backend instance at port `3002`. This port change is possible because the `-p` option exposes our internal frontend Vue.js 3 server port `3000` to the external port `3001`, which makes it possible to access our internal Docker application in our browser.\n\nAt this point, if everything is successful, you should be greeted with your demo Vue.js 3 application. However, following this approach poses a problem. Developers need to build, test, and deploy applications in isolation, which can be avoided with Docker Compose.\n\nIn this section, we explored how to dockerize the Pinterest clone application we have developed in this book. We learned how to create, build, and run the Dockerfile we used in dockerizing the project using different Docker commands. In the next section, we will explore how to use Docker Compose to build, test, and deploy multiple applications at once.\n\n# Dockerizing Vue.js and Node.js with Docker Compose\n\nIn the previous section, we explored how to dockerize Vue.js 3 applications and how to dockerize a Node.js application using Strapi, which was done separately. In this section, we are going to explore how to build, test, and deploy bundled applications. Furthermore, we are going to build and dockerize both applications as a single unit.\n\n## Overview of Docker Compose\n\nDocker Compose is a tool designed to enable users to easily define and share multi-container applications. By creating a YAML file, Compose allows us to quickly launch or shut down all services with a single command.\n\nWith Docker Compose, developers can build, test, and deploy multiple containers and images bundled together to form a single application.\n\nIn the next section, we are going to explore how to bundle the frontend and backend applications that we demonstrated in the previous section.\n\n### Dockerizing the Pinterest clone app\n\nTo bundle a deployable application, we are going to start by creating a central Dockerfile and Docker Compose YAML file inside the root directory that contains the different configurations to bundle our application with Docker Compose.\n\nBefore you start, rename your `strapi-pinterest-api` folder to `backend`. The following screenshot shows the current folder structure:\n\n![Figure 7.4 – A screenshot of the current folder structure with Docker and Docker Compose files](img/Figure_7.04_B17237.jpg)\n\nFigure 7.4 – A screenshot of the current folder structure with Docker and Docker Compose files\n\nNext, create a Dockerfile inside the root directory and add the following script:\n\n```", "```js\n\n#### Code walk-through\n\nLet’s walk through the code together and understand the nitty-gritty of it.\n\n**Step 1:** **Import Node.js**\n\nThe first step in every Dockerfile is to specify the build image. In this case, we specify Node.js as our image.\n\nThis will install Node.js with the specified version number and set up the environment to run Node.js properly.\n\n**Step 2: Create the** **required arguments**\n\nThe second step is to create the arguments required by Docker Compose when building individual images of our frontend and backend applications:\n\n```", "```js\n\nAdditionally, we create a working directory specifying the argument we created earlier. This will auto-inject the specified working directory in the Docker Compose YAML file.\n\n**Step 3: Copy, install, and** **run commands**\n\nLastly, we copy files from the specified working directory into the Docker virtual working directory. We start by copying `package*.json` files, running the `install` command, and copying the remaining files later. This approach utilizes the Docker caching system:\n\n```", "```js\n\nFurthermore, after mounting the `node_modules` folder of the specified working directory, Docker will execute the `npm start` command to start the application.\n\nNow that we have created a central Dockerfile for both the frontend and backend, let’s continue by creating a YAML Docker Compose file to bundle our separate applications together.\n\nCreate a `docker-compose.yaml` file inside the root directory and add the following script:\n\n```", "```js\n\n#### Code walk-through\n\nLet’s walk through the code together and understand the nitty-gritty of it.\n\n**Step 1: Versioning** **and services**\n\nEvery Docker Compose file always starts with a version number of the version of Docker Compose you intend to use when building and bundling the application. In this demo, we specify version 3.5.\n\nFurthermore, every Docker Compose YAML is always split into different services. You can add as many services as required that each application depends on. For instance, if the backend of your project depends on a database (PostgreSQL), you can specify that as a service.\n\nIn this demo, we have specified only two services, namely the following:\n\n*   Backend\n*   Frontend\n\nEach of the services contains configurations that enable them to run smoothly. Let’s explore the configurations we have added to the frontend service.\n\n**Step 2: The** **build section**\n\nThe `build` section includes configurations that help in building the application. It contains commands such as the context, working directory, and defined arguments:\n\n```", "```js\n\nThe `context` command specifies the part of the directory where the Dockerfile we created earlier is stored. In our case, it was stored in the root directory.\n\nNext, we call the Dockerfile with the `dockerfile` command and specify the required parameters with the `args` command. Lastly, we specify the `PACKAGE_PATH` and `WORKING_DIR` values.\n\n**Step 3: Exposing** **the port**\n\nIn this step, we exposed the internal Docker port used to run the application to the outside world:\n\n```", "```js\n\n**Step 4: Creating** **environment variables**\n\nIn this step, we use the `environment` command to add the required environment variables, such as `APP_BACKEND` and `APP_ENV`:\n\n```", "```js\n\nThen, we create an `env` file in the root directory using the `env_file` command to store the details we specified previously.\n\n**Step 5: Running** **the app**\n\nLastly, we mount the `frontend` directory and specify that the frontend project depends on our backend API service, which is our Strapi backend. This allows Docker to execute the project in sequence from the backend first before the frontend:\n\n```"]