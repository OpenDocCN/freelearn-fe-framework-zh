- en: Building a Media Streaming Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Media Streaming 应用程序
- en: Uploading and streaming media content, specifically video content, has been
    a growing part of the internet culture for some time now. From individuals sharing
    personal video content to the entertainment industry disseminating commercial
    content on online streaming services, we all rely on web applications that enable
    smooth uploading and streaming. Capabilities within the MERN stack technologies
    can be used to build and integrate these core streaming features into any MERN-based
    full-stack application. In this chapter, we will extend the MERN skeleton application
    to build a media streaming application, while demonstrating how to utilize MongoDB
    GridFS and add media streaming features to your web applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上传和流式传输媒体内容，特别是视频内容，已经是一段时间来互联网文化中增长的部分。从个人分享个人视频内容到娱乐行业在在线流媒体服务上传播商业内容，我们都依赖于能够实现顺畅上传和流式传输的
    Web 应用程序。MERN 技术栈中的功能可以用于构建和集成这些核心流媒体功能到任何基于 MERN 的全栈应用程序中。在本章中，我们将扩展 MERN 框架应用程序来构建一个媒体流媒体应用程序，同时展示如何利用
    MongoDB GridFS 并将媒体流式传输功能添加到您的 Web 应用程序中。
- en: 'In this chapter, we will cover the following topics to implement basic media
    uploading and streaming by extending the MERN skeleton application:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题，通过扩展 MERN 框架应用程序来实现基本的媒体上传和流式传输：
- en: Introducing MERN Mediastream
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 MERN Mediastream
- en: Uploading videos to MongoDB GridFS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将视频上传到 MongoDB GridFS
- en: Storing and retrieving media details
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储和检索媒体详情
- en: Streaming videos from GridFS to a basic media player
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 GridFS 流式传输视频到基本媒体播放器
- en: Listing, displaying, updating, and deleting media
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出、显示、更新和删除媒体
- en: Introducing MERN Mediastream
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 MERN Mediastream
- en: 'We will build the MERN Mediastream application by extending the skeleton application.
    This will be a simple video streaming application that allows registered users
    to upload videos that can be streamed by anyone browsing the application. The
    following screenshot shows the home page view on the MERN Mediastream application,
    along with a list of popular videos on the platform:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过扩展框架应用程序来构建 MERN Mediastream 应用程序。这将是一个简单的视频流媒体应用程序，允许注册用户上传任何浏览应用程序的人都可以流式传输的视频。以下截图显示了
    MERN Mediastream 应用程序的主页视图，以及平台上流行的视频列表：
- en: '![](img/a726f61d-5154-48bd-a13e-ae648367456b.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a726f61d-5154-48bd-a13e-ae648367456b.png)'
- en: The code for the complete MERN Mediastream application is available on GitHub
    at [https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter11%20and%2012/mern-mediastream](https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter11%20and%2012/mern-mediastream).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 MERN Mediastream 应用程序的代码可在 GitHub 上找到：[https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter11%20and%2012/mern-mediastream](https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter11%20and%2012/mern-mediastream)。
- en: You can clone this code and run the application as you go through the code explanations
    in the rest of this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以克隆此代码，并在阅读本章其余部分的代码解释时运行应用程序。
- en: 'The frontend user interface views that are needed for the features related
    to media uploading, editing, and streaming in a simple media player will be developed
    by extending and modifying existing React components in the MERN skeleton application. The
    component tree shown in the following diagram shows all the custom React components
    that make up the MERN Mediastream frontend that will be developed in this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 需要开发用于简单媒体播放器中媒体上传、编辑和流媒体功能的用户界面视图，这些视图将通过扩展和修改 MERN 框架应用程序中的现有 React 组件来实现。以下图表显示了将在本章中开发的
    MERN Mediastream 前端的所有自定义 React 组件：
- en: '![](img/80f78dff-f6a3-48b6-9244-f532cb0ffa45.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/80f78dff-f6a3-48b6-9244-f532cb0ffa45.png)'
- en: We will add new React components to implement views for uploading a new video,
    listing already posted media, modifying media post details, and displaying a video
    where users can interact with the video content to stream and watch it. We will also
    modify existing components such as the `Home` component so we can render a list
    of popular videos and the `Profile` component so we can list all the videos that
    are posted by a given user. These uploading and streaming capabilities in the
    application will rely on the user's ability to upload video content. In the next
    section, we will discuss how to allow signed-in users to add media to the application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Uploading and storing media
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Registered users on the MERN Mediastream application will be able to upload
    videos from their local files to store each video and related details directly
    on MongoDB using GridFS. To enable uploading media content to the application,
    we need to define how to store media details and the video content and implement
    a full-stack slice that will let users create a new media post and upload a video
    file. In the following sections, first we will define a media model for storing
    the details of each media post and configure GridFS to store the associated video
    content. Then, we will discuss implementations for the backend API, which will
    receive and store the video content with other media details, and the frontend
    form view, which will allow a user to create a new media post on the application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Media model
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will implement a Mongoose model to define a Media model for storing the
    details of each piece of media that''s posted to the application. This model will
    be defined in `server/models/media.model.js`, and the implementation will be similar
    to other Mongoose model implementations we covered in the previous chapters, such
    as the Course model we defined in [Chapter 6](c58ac055-5a1e-4bf4-b8a6-c9b311cf267a.xhtml), *Building
    a Web-Based Classroom Application*. The Media schema in this model will have fields
    to record the media title, description, genre, number of views, dates of when
    the media was posted and updated, and a reference to the user who posted the media. The
    code for defining the media fields is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '**Media title**: The `title` field is declared to be of the `String` type and
    will be a required field for introducing the media that are uploaded to the application:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Media description and genre**: The `description` and `genre` fields will
    be of type `String`, and these will store additional details about the media posted.
    The `genre` field will also allow us to group the different media uploaded to
    the application.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Number of views**: The `views` field is defined as a `Number` type and will
    keep track of how many times the uploaded media was viewed by users in the application:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Media posted by**: The `postedBy` field will reference the user who created
    the media post:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Created and updated at times**: The `created` and `updated` fields will be `Date` types,
    with `created` generated when a new media is added and `updated` changed when
    any media details are modified:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建和更新时间**：`created`和`updated`字段将是`Date`类型，`created`在添加新媒体时生成，`updated`在修改任何媒体详细信息时更改：'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The fields that were added to the schema definition will only store details
    about each video that's posted to the application. In order to store the video
    content itself, we will use MongoDB GridFS. Before getting into the implementation
    of uploading a video file, in the next section we will discuss how GridFS makes
    it possible to store large files in MongoDB, and then add initialization code
    to start using GridFS in this streaming application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到模式定义中的字段将只存储关于每个发布到应用程序的视频的详细信息。为了存储视频内容本身，我们将使用MongoDB GridFS。在下一节中，在讨论如何实现上传视频文件之前，我们将讨论GridFS如何使MongoDB中存储大文件成为可能，然后添加初始化代码以开始在这个流式应用中使用GridFS。
- en: Using MongoDB GridFS to store large files
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MongoDB GridFS存储大文件
- en: In previous chapters, we discussed how files uploaded by users could be stored
    directly in MongoDB as binary data; for example, when adding a profile photo in the
    *Upload profile photo* section in [Chapter 5](27d3dbdf-0617-4ad8-9dcc-27afa417c174.xhtml),
    *Growing the Skeleton into a Social Media Application*. But this only worked for
    files smaller than 16 MB. In order to store larger files in MongoDB, such as video
    files needed for this streaming application, we will need to use GridFS.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了用户上传的文件可以直接作为二进制数据存储在MongoDB中；例如，在[第5章](27d3dbdf-0617-4ad8-9dcc-27afa417c174.xhtml)的“上传个人照片”部分添加个人照片时。但这仅适用于小于16
    MB的文件。为了在MongoDB中存储更大的文件，例如本流式应用所需的视频文件，我们需要使用GridFS。
- en: GridFS is a specification in MongoDB that allows us to store large files in
    MongoDB by dividing a given file into several chunks. Each chunk can be a maximum
    of 255 KB in size, and is stored as a separate document. When the file has to
    be retrieved in response to a query to GridFS, the chunks are reassembled as needed.
    This opens up the option to fetch and load only parts of the file as required,
    rather than retrieving the whole file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: GridFS是MongoDB中的一个规范，允许我们将一个给定的文件分割成几个块来存储在MongoDB中。每个块的大小最大为255 KB，并作为单独的文档存储。当需要根据对GridFS的查询检索文件时，块会根据需要重新组装。这提供了只获取和加载文件所需部分而不是整个文件的功能。
- en: In the case of storing and retrieving video files for the MERN Mediastream application,
    we will utilize GridFS to store video files and stream parts of the video, depending
    on which part the user skips to and starts playing from.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储和检索MERN Mediastream应用程序的视频文件的情况下，我们将利用GridFS来存储视频文件，并根据用户跳转到的部分和开始播放的部分流式传输视频的相应部分。
- en: You can learn more about the GridFS specification and its features in the official
    MongoDB documentation at [https://docs.mongodb.com/manual/core/gridfs/](https://docs.mongodb.com/manual/core/gridfs/).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方MongoDB文档中了解更多关于GridFS规范及其功能的信息，请参阅[https://docs.mongodb.com/manual/core/gridfs/](https://docs.mongodb.com/manual/core/gridfs/)。
- en: To access and work with MongoDB GridFS from our backend code, we will use the Node.js
    MongoDB driver's streaming API by creating a `GridFSBucket` with the established
    database connection.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们的后端代码访问和使用MongoDB GridFS，我们将通过创建一个`GridFSBucket`并使用建立的数据库连接来使用Node.js MongoDB驱动程序的流式API。
- en: GridFSBucket is the GridFS streaming interface that gives us access to the streaming
    GridFS API. It can be used to interact with files in GridFS. You can learn more
    about GridFSBucket and the streaming API in the Node.js MongoDB Driver API documentation
    at [https://mongodb.github.io/node-mongodb-native/3.2/api/GridFSBucket.html](https://mongodb.github.io/node-mongodb-native/3.2/api/GridFSBucket.html).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: GridFSBucket是GridFS流式接口，它为我们提供了访问流式GridFS API的权限。它可以用来与GridFS中的文件进行交互。您可以在Node.js
    MongoDB驱动程序API文档中了解更多关于GridFSBucket和流式API的信息，请参阅[https://mongodb.github.io/node-mongodb-native/3.2/api/GridFSBucket.html](https://mongodb.github.io/node-mongodb-native/3.2/api/GridFSBucket.html)。
- en: Since we are using Mongoose to establish a connection with the MongoDB database
    for our application, we will add the following code to initialize a new `GridFSBucket`
    with this database connection after it has been established.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用Mongoose与MongoDB数据库建立应用程序的连接，因此将在连接建立后添加以下代码来初始化一个新的`GridFSBucket`。
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/controllers/media.controller.js`:'
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `gridfs` object we created here will give us access to the GridFS functionalities
    that are required to store the video file when new media is created and to fetch
    the file when the media is to be streamed back to the user. In the next section,
    we will add a create media form view and an API in the backend, which will use
    this `gridfs` object to save the video file that's uploaded with the request that's
    sent from the form view in the frontend.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在这里创建的`gridfs`对象将为我们提供访问GridFS功能，这些功能在创建新媒体时存储视频文件以及在媒体要流回用户时检索文件时是必需的。在下一节中，我们将添加创建媒体表单视图和后端API，这些API将使用此`gridfs`对象来保存与前端表单视图发送的请求一起上传的视频文件。 '
- en: Creating a new media post
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的媒体帖子
- en: For a user to be able to create a new media post on the application, we will
    need to integrate a full-stack slice that allows the user to fill out a form in
    the frontend and then save both the provided media details and the associated
    video file in the database in the backend. To implement this feature, in the following
    sections, we will add a create media API in the backend, along with a way to fetch
    this API in the frontend. Then, we will implement a create new media form view
    that allows the user to input media details and select a video file from their
    local filesystem.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户能够在应用程序中创建新的媒体帖子，我们需要集成一个全栈切片，允许用户在前端填写表单，然后在后端将提供的媒体细节和相关的视频文件保存到数据库中。为了实现这个功能，在接下来的章节中，我们将在后端添加一个创建媒体API，以及在前端获取此API的方法。然后，我们将实现一个创建新媒体表单视图，允许用户输入媒体细节并从他们的本地文件系统中选择视频文件。
- en: The create media API
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建媒体API
- en: We will implement a create media API in the backend to allow users to create
    new media posts on the application. This API will receive a POST request at `'/api/media/new/:userId'`
    with the multipart body content containing the media fields and the uploaded video
    file. First, we will declare the create media route and utilize the `userByID`
    method from the user controller, as shown in the following code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后端实现一个创建媒体API，允许用户在应用程序上创建新的媒体帖子。此API将在`'/api/media/new/:userId'`接收包含媒体字段和上传的视频文件的multipart请求体。首先，我们将声明创建媒体路由并利用用户控制器中的`userByID`方法，如下所示。
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/routes/media.routes.js`:'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `userByID` method processes the `:userId` parameter that's passed in the
    URL and retrieves the associated user from the database. The user object becomes
    available in the request object to be used in the next method that will be executed. Similar
    to the user and auth routes, we will have to mount the media routes on the Express
    app in `express.js` as follows.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`userByID`方法处理URL中传递的`:userId`参数，并从数据库中检索相关的用户。用户对象将在请求对象中可用，以便在将要执行的下一种方法中使用。类似于用户和认证路由，我们将在`express.js`中将媒体路由挂载到Express应用上，如下所示。'
- en: '`mern-mediastream/server/express.js`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/express.js`:'
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A POST request to the create route URL, `/api/media/new/:userId`, will make
    sure the user is signed in and then initiate the `create` method in the media
    controller. The `create` controller method will use the `formidable` node module
    to parse the multipart request body that will contain the media details and video
    file uploaded by the user. You can install the module by running the following
    command from the command line:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 向创建路由URL `/api/media/new/:userId` 发送POST请求，将确保用户已登录，然后初始化媒体控制器中的`create`方法。`create`控制器方法将使用`formidable`节点模块来解析包含用户上传的媒体细节和视频文件的multipart请求体。您可以从命令行运行以下命令来安装此模块：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the `create` method, we will use the media fields that have been received
    in the form data and parsed with `formidable` to generate a new Media object and
    then save it to the database. This `create` controller method is defined as follows.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`create`方法中，我们将使用在表单数据中接收并使用`formidable`解析的媒体字段来生成一个新的媒体对象，并将其保存到数据库中。这个`create`控制器方法定义如下。
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/controllers/media.controller.js`:'
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If there is a file in the request, `formidable` will store it temporarily in
    the filesystem. We will use this temporary file and the media object's ID to create
    a writable stream with `gridfs.openUploadStream`. Here, the temporary file will
    be read and then written into MongoDB GridFS, while setting the `filename` value
    to the media ID. This will generate the associated chunks and file information
    documents in MongoDB, and when it is time to retrieve this file, we will identify
    it with the media ID.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: To use this create media API in the frontend, we will add a corresponding `fetch`
    method in `api-media.js` to make a `POST` request to the API by passing the multipart
    form data from the view. This method will be defined as follows.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/api-media.js`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This `create` fetch method will take the current user's ID, user credentials,
    and the media form data to make a POST request to the create media API in the
    backend. We will use this method when the user submits the new media form to upload
    a new video and post it on the application. In the next section, we will look
    at the implementation of this form view in the frontend.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The NewMedia component
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Registered users on the MERN Mediastream application will interact with a form
    view to enter details of a new media post. This form view will be rendered in
    the `NewMedia` component, which will allow a signed-in user to create a media
    post by entering the title, description, and genre of the video and uploading
    a video file from their local filesystem.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'This form view will render as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/044f5619-fbaa-42bb-bcad-e5d2f97c93f6.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: We will implement this form in a React component named `NewMedia`. For the view,
    we will add the file upload elements using a Material-UI `Button` and an HTML5
    file `input` element, as shown in the following code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/NewMedia.js`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the file `input` element, we specify that it accepts video files, so when
    the user clicks on Upload and browses through their local folders, they only have
    the option to upload a video file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the view, we add the title, description, and genre form fields with
    the `TextField` components, as shown in the following code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/NewMedia.js`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These form field changes will be tracked with the `handleChange` method when
    a user interacts with the input fields to enter values. The `handleChange` function
    will be defined as follows.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/NewMedia.js`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `handleChange` method updates the state with the new values, including the
    name of the video file, if one is uploaded by the user.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can complete this form view by adding a Submit button, which, when
    clicked, should send the form data to the server. We will define a `clickSubmit` method
    here, which will be called when the Submit button is clicked by the user.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/NewMedia.js`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This `clickSubmit` function will take the input values and populate `mediaData`,
    which is a `FormData` object that ensures the data is stored in the correct format
    for the `multipart/form-data` encoding type. Then, the `create` fetch method is
    called to create the new media in the backend with this form data. On successful
    media creation, the user may be redirected to a different view as desired, for
    example, to a Media view with the new media details, as shown in the following
    code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此`clickSubmit`函数将获取输入值并填充`mediaData`，这是一个`FormData`对象，确保数据以正确的格式存储在`multipart/form-data`编码类型中。然后，调用`create`
    fetch方法使用此表单数据在后端创建新的媒体。在成功创建媒体后，用户可能会被重定向到不同的视图，例如，到一个包含新媒体详情的媒体视图，如下面的代码所示。
- en: '`mern-mediastream/client/media/NewMedia.js`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/NewMedia.js`:'
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `NewMedia` component can only be viewed by a signed-in user. Therefore,
    we will add a `PrivateRoute` in the `MainRouter` component, which will render
    this form only for authenticated users at `/media/new`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewMedia`组件只能由已登录用户查看。因此，我们将在`MainRouter`组件中添加一个`PrivateRoute`，这样它只会在`/media/new`为认证用户渲染此表单。'
- en: '`mern-mediastream/client/MainRouter.js`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/MainRouter.js`:'
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This link can be added to any view, such as in the Menu component, so that it's
    rendered conditionally when users are signed in. Now that it is possible to add
    new media posts in this media streaming application, in the next section we will
    discuss the implementation of retrieving and rendering the video content associated
    with each media post. This will allow users to stream and view video files stored
    in MongoDB GridFS from the frontend of the application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此链接可以添加到任何视图，例如在菜单组件中，以便在用户登录时条件性地渲染。现在，由于可以在本媒体流应用中添加新的媒体帖子，在下一节中，我们将讨论检索和渲染与每个媒体帖子关联的视频内容的实现。这将使用户能够从应用程序的前端流式传输和查看存储在MongoDB
    GridFS中的视频文件。
- en: Retrieving and streaming media
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索和流式传输媒体
- en: Any visitor browsing through the MERN Mediastream application will be able to
    view the media posted on the application by its users. Implementing this feature
    will require streaming the video files stored in MongoDB GridFS to the requesting
    client and rendering the stream in a media player. In the following sections,
    we will set up a backend API to retrieve a single video file, which we will then
    use as a source in a React-based media player to render the streaming video.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 任何浏览MERN Mediastream应用程序的访客都将能够查看用户在应用程序上发布的媒体。实现此功能需要将存储在MongoDB GridFS中的视频文件流式传输到请求客户端，并在媒体播放器中渲染流。在以下章节中，我们将设置一个后端API来检索单个视频文件，然后我们将将其用作基于React的媒体播放器的源来渲染流式视频。
- en: The video API
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视频API
- en: To retrieve the video file associated with a single media post, we will implement
    a get video API that will accept a GET request at `'/api/medias/video/:mediaId'` and
    query both the Media collection and GridFS files. We will start implementing this
    video API by declaring the route shown in the following code, along with a way
    to handle the `:mediaId` parameter in the URL.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索与单个媒体帖子关联的视频文件，我们将实现一个接受GET请求的get视频API，请求地址为`'/api/medias/video/:mediaId'`，并查询媒体集合和GridFS文件。我们将通过声明以下代码中的路由以及处理URL中的`:mediaId`参数的方式来实现此视频API。
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/routes/media.routes.js`:'
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `:mediaId` parameter in the route URL will be processed in the `mediaByID`
    controller to fetch the associated document from the Media collection and file
    details from GridFS. These retrieved results are then attached to the request
    object so that it can be used in the `video` controller method as required. This `mediaByID` controller
    method is defined as follows.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 路由URL中的`:mediaId`参数将在`mediaByID`控制器中处理，以从媒体集合和GridFS文件中检索相关文档和文件详情。然后，这些检索到的结果将附加到请求对象中，以便可以在`video`控制器方法中按需使用。此`mediaByID`控制器方法定义如下。
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/controllers/media.controller.js`:'
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To retrieve the relevant file details from GridFS, we use `find` from the MongoDB
    streaming API. We query the files stored in GridFS by the filename value, which
    should match the corresponding media ID in the Media collection. Then, we receive
    the resulting matching file records in an array and attach the first result to
    the request object so that it can be used in the next method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要从GridFS检索相关文件详情，我们使用MongoDB流式API中的`find`。我们通过文件名值查询存储在GridFS中的文件，该值应与媒体集合中相应的媒体ID相匹配。然后，我们以数组形式接收匹配的文件记录，并将第一个结果附加到请求对象中，以便在下一个方法中使用。
- en: The next method that's invoked when this API receives a request is the `video`
    controller method. In this method, depending on whether the request contains range
    headers, we send back the correct chunks of video with the related content information
    set as response headers. The `video` controller method is defined with the following
    structure, with the response composed depending on the existence of range headers
    in the request.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个API接收到请求时，调用的下一个方法是`video`控制器方法。在这个方法中，根据请求是否包含范围头，我们发送回正确的视频块，并将相关内容信息设置为响应头。`video`控制器方法定义如下结构，响应的组成取决于请求中是否存在范围头。
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/controllers/media.controller.js`:'
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, if the request does not contain range headers, we stream
    back the whole video file using `gridfs.openDownloadStream`, which gives us a
    readable stream of the corresponding file stored in GridFS. This is piped with
    the response sent back to the client. In the response header, we set the content
    type and total length of the file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果请求不包含范围头，我们使用`gridfs.openDownloadStream`流回整个视频文件，这为我们提供了存储在GridFS中的相应文件的可读流。这个流与发送回客户端的响应一起管道传输。在响应头中，我们设置了文件的内容类型和总长度。
- en: If the request contains range headers – for example, when the user drags to
    the middle of the video and starts playing from that point – we need to convert
    the received range headers to the start and end positions, which will correspond
    with the correct chunks stored in GridFS, as shown in the following code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求包含范围头——例如，当用户拖动到视频中间并从该点开始播放时——我们需要将接收到的范围头转换为起始和结束位置，这将与存储在GridFS中的正确块相对应，如下面的代码所示。
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/controllers/media.controller.js`:'
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We pass the start and end values that have been extracted from the header as
    a range to `gridfs.openDownloadStream`. These start and end values specify the
    0-based offset in bytes to start streaming from and stop streaming before. We
    also set the response headers with additional file details, including content
    length, range, and type. The content length will now be the total size of the
    content within the defined range. Therefore, the readable stream that's piped
    back to the response, in this case, will only contain the chunks of file data
    that fall within the start and end ranges.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将已从头部提取的起始和结束值作为范围传递给`gridfs.openDownloadStream`。这些起始和结束值指定了从0开始的字节数，以开始流式传输并在此之前停止流式传输。我们还设置了包含附加文件详情的响应头，包括内容长度、范围和类型。内容长度现在将是定义范围内的内容总大小。因此，返回给响应的可读流，在这种情况下，将只包含位于起始和结束范围内的文件数据块。
- en: The final readable stream that's piped to the response after a request is received at
    this get video API can be rendered directly in a basic HTML5 media player or a
    React-flavored media player in the frontend view. In the next section, we will
    look at how to render this video stream in a simple React media player.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收到此获取视频API请求后，最终的可读流被管道传输到响应，可以直接在前端视图的基本HTML5媒体播放器或React风格的媒体播放器中渲染。在下一节中，我们将探讨如何在简单的React媒体播放器中渲染此视频流。
- en: Using a React media player to render the video
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React媒体播放器渲染视频
- en: 'In the frontend of the application, we can render the video file being streamed
    from MongoDB GridFS in a media player. A good option for a React-flavored media
    player is the `ReactPlayer` component, available as a node module, which can be
    customized as required. Providing the video stream as a source to a default `ReactPlayer`
    component will render with basic player controls, as shown in the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的前端，我们可以在媒体播放器中渲染从MongoDB GridFS流出的视频文件。对于React风格的媒体播放器，一个好的选择是作为节点模块提供的`ReactPlayer`组件，可以根据需要自定义。将视频流作为源提供给默认的`ReactPlayer`组件将渲染带有基本播放控件，如下面的截图所示：
- en: '![](img/5426cde7-a7af-44d8-922e-a1b36c11aed7.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: 'To start using `ReactPlayer` in our frontend code, we need to install the corresponding
    node module by running the following Yarn command from the command line:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once installed, we can import it into any React component and add it to the
    view. For basic usage with the default controls provided by the browser, we can
    add it to any React view in any application that has access to the ID of the media
    to be rendered, as shown in the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will load the player with the video stream that was received from the get
    video API and provide the user with basic control options to interact with the
    stream being played. `ReactPlayer` can be customized so that more options are
    available. We will explore some of these advanced options for customizing this `ReactPlayer` with
    our own controls in the next chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about what is possible with `ReactPlayer`, visit [cookpete.com/react-player](https://cookpete.com/react-player).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's possible to retrieve a single video file stored in MongoDB GridFS
    and stream it to a media player in the frontend for the user to view and play
    the video as desired. In the next section, we will discuss how to fetch and display
    lists of multiple videos from the backend to the frontend of the streaming application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Listing media
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In MERN Mediastream, we will add list views of relevant media with a snapshot
    of each video to give visitors easier access and an overview of the videos on
    the application. For example, in the following screenshot, the `Profile` component
    displays a list of media posted by the corresponding user, showing the video preview
    and other details of each media:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d39a7f3f-6078-41a7-8bd5-442e6404057e.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: We will set up list APIs in the backend to retrieve different lists, such as
    videos uploaded by a single user and the most popular videos with the highest
    views in the application. Then, these retrieved lists can be rendered in a reusable `MediaList` component,
    which will receive a list of media objects as a prop from a parent component that
    fetches the specific API. In the following sections, we will implement the `MediaList`
    component and the backend APIs to retrieve the two different lists of media from
    the database.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: The MediaList component
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `MediaList` component is a reusable component that will take a list of media
    and iterate through it to render each media item in the view. In MERN Mediastream,
    we use it to render a list of the most popular media in the home view and a list
    of media uploaded by a specific user in their profile.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: In the view part of the `MediaList` component, we will iterate through the `media`
    array that's received in `props` using `map`, as shown in the following code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaList.js`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This `MediaList` component uses the Material-UI `GridList` components as it
    iterates through the array of objects sent in the props and renders media details
    for each item in the list. It also includes a `ReactPlayer` component, which renders
    the video URL without showing any controls. In the view, this gives the visitor
    a brief overview of each piece of media, as well as a glimpse of the video content.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'This component can be added to any view that can provide an array of media
    objects. In the MERN Mediastream application, we use it to render two different
    lists of media: a list of popular media and a list of media posted by a specific
    user. In the next section, we will look at how to retrieve a list of popular media
    from the database to render it in the frontend.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Listing popular media
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To retrieve specific lists of media from the database, we need to set up the
    relevant APIs on the server. For popular media, we will set up a route that receives
    a GET request at `/api/media/popular`. The route will be declared as follows.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A GET request to this URL will invoke the `listPopular` method. The `listPopular`
    controller method will query the Media collection and retrieve nine media documents
    that have the highest `views` in the whole collection. The `listPopular` method
    is defined as follows.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The result that's returned by the query to the Media collection is sorted by
    the number of views in descending order and limited to nine. Each media document
    in this list will also contain the name and ID of the user who posted it since
    we are calling `populate` to add these user attributes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: This API can be used in the frontend with a fetch request. You can define a
    corresponding fetch method in `api-media.js` to make the request, similarly to
    other API implementations. Then, the fetch method can be called in a React component,
    such as in the `Home` component for this application. In the `Home` component,
    we will fetch a list of popular videos in a `useEffect` hook, as shown in the
    following code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/core/Home.js`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The list that's fetched from the API in this hook is set in the state so that
    it can be passed to a `MediaList` component in the view. In the Home view, we
    can add the `MediaList` as follows, with the list provided as a prop.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/core/Home.js`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will render a list of up to nine of the most popular videos from the database
    on the home page of the MERN Mediastream application. In the next section, we
    will discuss a similar implementation to retrieve and render a list of media that's
    been posted by a specific user.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Listing media by users
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to retrieve a list of media that's been uploaded by a specific user
    from the database, we will set up an API with a route that accepts a `GET` request
    at `'/api/media/by/:userId'`. The route will be declared as follows.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A GET request to this route will invoke the `listByUser` method. The `listByUser`
    controller method will query the Media collection to find media documents that
    have `postedBy` values matching with the `userId` attached as a parameter in the
    URL. The `listByUser` controller method is defined as follows.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The result that's returned from the query to the Media collection is sorted
    by the date it was created on, with the latest post showing up first. Each media
    document in this list will also contain the name and ID of the user who posted
    it since we are calling `populate` to add these user attributes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: This API can be used in the frontend with a fetch request. You can define a
    corresponding `fetch` method in `api-media.js` to make the request, similar to
    other API implementations. Then, the fetch method can be called in a React component.
    In our application, we use the `fetch` method in the `Profile` component, similar
    to the `listPopular` fetch method we used in the home view, to retrieve the list
    data, set it to the state, and then pass it to a `MediaList` component. This will
    render a profile page with a list of media that was posted by the corresponding
    user.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: We are able to retrieve and display multiple videos on the application by utilizing
    APIs that have been implemented in the backend to fetch the list data. We can
    also utilize a ReactPlayer component without controls to give the user a glimpse
    of each video when we render the list in the frontend views. In the next section,
    we will discuss the full-stack slices that will display media posts and allow
    authorized users to update and delete individual media posts in the application.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Displaying, updating, and deleting media
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any visitor to MERN Mediastream will be able to view media details and stream
    videos, while only registered users will be able to edit the media's details and
    delete it any time after they post it on the application. In the following sections,
    we will implement full-stack slices, including backend APIs and frontend views,
    to display a single media post, update details of a media post, and delete a media
    post from the application.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Displaying media
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any visitor to MERN Mediastream will be able to browse to a single media view
    to play a video and read the details associated with it. Every time a specific
    video is loaded on the application, we will also increment the number of views
    associated with the media. In the following sections, we will implement the individual
    media view by adding a read media API to the backend, a way to call this API from
    the frontend, and the React component that will display the media details in the
    view.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The read media API
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To implement the read media API in the backend, we will start by adding a `GET` route
    that queries the `Media` collection with an ID and returns the media document
    in the response. The route is declared as follows.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `mediaId` in the request URL will cause the `mediaByID` controller method
    to execute and attach the retrieved media document to the request object so that
    it can be accessed in the next method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: A `GET` request to this API will execute the `incrementViews` controller method
    next, which will find the matching media record and increment the `views` value
    by `1`, before saving the updated record to the database. The `incrementViews`
    method is defined as follows.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This method will increment the number of views for a given media by 1 every
    time this read media API is called. After the media is updated from this `incrementViews`
    method, the `read` controller method is invoked. The `read` controller method
    will simply return the retrieved media document in response to the requesting
    client, as shown in the following code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To retrieve the media document that was sent in the response, we need to call
    this read media API in the frontend using a fetch method. We will set up a corresponding
    fetch method in `api-media.js`, as shown in the following code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/api-media.js`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This method takes the ID of the media to be retrieved and makes a `GET` request
    to the read API route using a `fetch`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The read media API can be used to render individual media details in a view
    or to pre-populate a media edit form. In the next section, we will use this fetch
    method to call the read media API in the React component to render the media details,
    as well as a `ReactPlayer` that will play the associated video.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The Media component
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Media` component will render details of an individual media record and
    stream the video in a basic `ReactPlayer` with default browser controls. The completed
    single Media view will look as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c171333d-9949-44de-8e54-08edce73050f.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: The `Media` component can call the read API to fetch the media data itself or
    receive the data as props from a parent component that makes the call to the read
    API. In the latter case, the parent component will fetch the media from the server
    in a `useEffect` hook, set it to state, and add it to the `Media` component, as
    follows.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/PlayMedia.js`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In MERN Mediastream, we will add the `Media` component in a `PlayMedia` component
    that fetches the media content from the server in a `useEffect` hook using the
    read API and passes it to `Media` as a prop. The composition of the `PlayMedia`
    component will be discussed in more detail in the next chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The `Media` component will take this data in the props and render it in the
    view to display the details and load the video in a `ReactPlayer` component. The
    title, genre, and view count details of the media can be rendered in a Material-UI
    `CardHeader` component in the `Media` component, as shown in the following code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/Media.js`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Besides rendering these media details, we will also load the video in the `Media`
    component. The video URL, which is basically the get video API route we set up
    in the backend, is loaded in a `ReactPlayer` with default browser controls, as
    shown in the following code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/Media.js`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will render a simple player that allows the user to play the video stream.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The `Media` component also renders additional details about the user who posted
    the video, a description of the video, and the date it was created, as shown in
    the following code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/Media.js`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the details being displayed in the Material-UI `ListItem` component, we will also
    conditionally show edit and delete options if the currently signed-in user is
    the one who posted the media being displayed. To render these elements conditionally
    in the view, we will add the following code after the `ListItemText` displaying
    the date.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/Media.js`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will ensure that the edit and delete options only render when the current
    user is signed in and is the uploader of the media being displayed. The edit option
    links to the media edit form, while the delete option opens a dialog box that
    can initiate the deletion of this particular media document from the database.
    In the next section, we will implement the functionality of this option to edit
    details of the uploaded media post.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Updating media details
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Registered users will have access to an edit form for each of their media uploads.
    Updating and submitting this form will save the changes to the given document
    in the Media collection. To implement this capability, we will have to create
    a backend API that allows the update operation on a given media after ensuring
    that the requesting user is authenticated and authorized. Then, this updated API
    needs to be called from the frontend with the changed details of the media. In
    the following sections, we will build this backend API and the React component
    to allow users to make changes to the media they already posted on the application.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The media update API
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the backend, we will need an API that allows us to update existing media
    in the database if the user making the request is the authorized creator of the
    given media post. First, we will declare the PUT route, which accepts the update
    request from the client.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When a PUT request is received at `'api/media/:mediaId'`, the server will ensure
    the signed-in user is the original poster of the media content by calling the
    `isPoster` controller method. The `isPoster` controller method is defined as follows.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js:`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This method ensures the ID of the authenticated user is the same as the user
    ID referenced in the `postedBy` field of the given media document. If the user
    is authorized, the `update` controller method will be called `next` in order to
    update the existing media document with the changes. The `update` controller method
    is defined as follows.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This method extends the existing media document with the changed details that
    were received in the request body and saves the updated media to the database.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: To access the update API in the frontend, we will add a corresponding fetch
    method in `api-media.js` that takes the necessary user auth credentials and media
    details as parameters before making the fetch call to this update media API, as
    shown in the following code.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/user/api-media.js`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This fetch method will be used in the media edit form when the user makes updates
    and submits the form. In the next section, we will discuss the implementation
    of this media edit form.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The media edit form
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The media edit form, which will allow an authorized user to make changes to
    the details of a media post, will be similar to the new media form. However, it
    will not have an upload option, and the fields will be pre-populated with the
    existing values, as shown in the following screenshot:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/180e69b1-8f55-46f0-b290-6304b551a616.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: The `EditMedia` component containing this form will fetch the existing values
    of the media by calling the read media API in a `useEffect` hook, as shown in
    the following code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/EditMedia.js`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The retrieved media details are set to state so that the values can be rendered
    in the text fields. The form field elements will be the same as in the `NewMedia`
    component. When a user updates any of the values in the form, the changes will
    be registered in the `media` object in state with a call to the `handleChange`
    method. The `handleChange` method is defined as follows.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '`mediastream/client/media/EditMedia.js`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this method, the specific field that's being updated in the form is reflected
    in the corresponding attribute in the media object in state. When the user is
    done editing and clicks submit, a call will be made to the update API with the
    required credentials and the changed media values. This is done by invoking the
    `clickSubmit` method, which is defined as follows.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '`mediastream/client/media/EditMedia.js`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The call to the update media API will update the media details in the corresponding
    media document in the Media collection, while the video file associated with the
    media remains as it is in the database.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: This `EditMedia` component can only be accessed by signed-in users and will
    be rendered at `'/media/edit/:mediaId'`. Due to this, we will add a `PrivateRoute` in
    the `MainRouter` component, like so.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/MainRouter.js`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This link is added with an edit icon in the `Media` component, allowing the
    user who posted the media to access the edit page. In the `Media` view, the user
    can also choose to delete their media post. We will implement this in the next
    section.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Deleting media
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An authorized user can completely delete the media they uploaded to the application,
    including the media document in the Media collection and the file chunks stored
    in MongoDB using GridFS. To allow a user to remove the media from the application,
    in the following sections, we will define a backend API for media deletion from
    the database and implement a React component that makes use of this API when the
    user interacts with the frontend to perform this deletion.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: The delete media API
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To delete media from the database, we will implement a delete media API in the
    backend, which will accept a DELETE request from a client at `/api/media/:mediaId`. We
    will add the `DELETE` route for this API as follows, which will allow an authorized
    user to delete their uploaded media records.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: When the server receives a DELETE request at `'/api/media/:mediaId'`, it will
    make sure the signed-in user is the original poster of the media by invoking the
    `isPoster` controller method. Then, the `remove` controller method will completely delete
    the specified media from the database. The `remove` method is defined as follows.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Besides deleting the media record from the Media collection, we are also using `gridfs`
    to remove the associated file details and chunks stored in the database.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: To access this backend API in the frontend, you will also need a fetch method
    with this route, similar to other API implementations. The fetch method will need
    to take the media ID and the current user's auth credentials in order to call
    the delete media API with these values.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The fetch method will be used when the user performs the delete operation by
    clicking a button in the frontend interface. In the next section, we will discuss
    a React component called `DeleteMedia`, where by this delete media action will
    be performed by the user.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: The DeleteMedia component
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `DeleteMedia` component is added to the `Media` component and is only visible
    to the signed-in user who added this specific media. This component is basically
    a button that, when clicked, opens a `Dialog` component asking the user to confirm
    the delete action, as shown in the following screenshot:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71d31ba9-fc95-4b16-a1aa-116fdc04ac03.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: This `DeleteMedia` component takes the media ID and title as props when it is
    added in the `Media` component. Its implementation will be similar to the `DeleteUser` component
    we discussed in [Chapter 4](6f2ca10a-8079-4e3a-9d42-a3db8e85b9d9.xhtml), *Adding
    a React Frontend to Complete MERN*. Once the `DeleteMedia` component has been
    added, the user will be able to remove the posted media completely from the application
    by confirming their action.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: The MERN Mediastream application that we've developed in this chapter is a complete
    media streaming application with the capability to upload video files to the database,
    stream stored videos back to the viewers, support CRUD operations such as media
    create, update, read, and delete, and support options for listing media by uploader
    or popularity.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we developed a media streaming application by extending the
    MERN skeleton application and leveraging MongoDB GridFS.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Besides adding basic add, update, delete, and listing features for media uploads,
    we looked into how MERN-based applications can allow users to upload video files,
    store these files into MongoDB GridFS as chunks, and stream the video back to
    the viewer partially or fully as required. We also covered using `ReactPlayer`
    with default browser controls to stream the video file. You can apply these streaming
    capabilities to any full-stack application that may require storing and retrieving
    large files from the database.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to customize `ReactPlayer` with our own
    controls and functionality so that users have more options, such as playing the
    next video in a list. In addition, we will discuss how to improve the SEO of the
    media details by implementing server-side rendering with data for the media view.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
