- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Common Refactoring Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the fascinating world of refactoring! In this chapter, we’re going
    to explore the basics of this fundamental practice, essential to every developer
    in maintaining and improving a code base. We aim to introduce you to the most
    common refactoring techniques, providing a solid foundation for understanding
    and employing these valuable tools. Remember, our objective is not to provide
    an exhaustive guide, but rather to familiarize you with the essentials that you’ll
    use time and time again in your programming journey.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring doesn’t discriminate among languages or frameworks – it’s a universal
    concept applicable anywhere you write code. The techniques we’ll discuss include
    renaming variables, changing function declarations, extracting functions, moving
    fields, and more. These techniques might appear simple at first glance, but they
    are incredibly powerful tools for crafting clean, understandable, and maintainable
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Also remember that refactoring is not a one-time task, but rather an ongoing
    process of small, iterative changes that gradually enhance the structure and quality
    of your code. It is these frequent, incremental improvements that keep a code
    base healthy, robust, and easier to work with. By introducing you to the basics,
    we hope to equip you with the essential tools and techniques that will be a stepping
    stone toward more advanced refactoring methods.
  prefs: []
  type: TYPE_NORMAL
- en: While we’ll delve into more complex refactoring techniques in later chapters,
    the practices you’ll learn here will serve as a valuable starting point. By the
    end of this chapter, you’ll have a toolkit of common refactoring practices and
    a newfound understanding of their importance in enhancing code quality. Ultimately,
    the refactoring skills you begin to develop here will empower you to write cleaner,
    more efficient code, and set you on the path to becoming a more proficient developer.
    Let’s dive in!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding refactoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding tests before refactoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Rename Variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Extract Variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Replace Loop with Pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Extract Function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Introduce Parameter Object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Decompose Conditional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Move Function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A GitHub repository has been created to host all the code we discuss in the
    book. For this chapter, you can find the recommended structure at [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch6](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch6).
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into the refactorings, let’s align with some tooling that would
    help us to make changes easily. When it comes to refactoring tools, there are
    many **integrated development environments** (**IDEs**) and source code editors
    available in the frontend world – WebStorm and Visual Studio Code (VS Code) are
    the most popular ones that offer an impressive range of features, including robust
    refactoring capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '**WebStorm**, developed by JetBrains, is a powerful and feature-rich IDE specifically
    designed for JavaScript and its related technologies such as TypeScript, HTML,
    and CSS. One of its most notable features is its advanced automated refactoring,
    but it also offers an extensive list of refactoring options such as rename, extract,
    inline, move, and copy, which can be applied to variables, classes, functions,
    and other elements. It also has a smart duplication detection feature, helping
    you to locate and resolve repetitive blocks of code.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: The WebStorm IDE](img/B31103_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: The WebStorm IDE'
  prefs: []
  type: TYPE_NORMAL
- en: WebStorm’s IntelliSense, auto-complete, and code navigation are quite robust,
    giving you a lot of help when writing and exploring the code. However, WebStorm
    is a commercial product, and while it does offer a trial period, you will need
    to purchase a license for continued use.
  prefs: []
  type: TYPE_NORMAL
- en: '**Visual Studio Code** (**VS Code**), on the other hand, is a free, open source
    IDE developed by Microsoft. It’s lightweight compared to WebStorm and is known
    for its speed and flexibility. VS Code also supports a wide range of languages
    beyond JavaScript, thanks to its extension marketplace. Refactoring capabilities
    in VS Code are strong as well, with support for common operations such as renaming,
    extracting functions or variables, and changing function signatures. VS Code’s
    refactoring capabilities can be further enhanced by installing extensions, and
    its customizability is one of its key strengths.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: VS Code](img/B31103_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: While VS Code may not have as many automated refactoring features as WebStorm
    out of the box, it can be tailored to match and sometimes exceed WebStorm’s capabilities
    through these extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between the two often boils down to personal preference and the specific
    needs of your project. If you value a highly automated, feature-rich environment
    and don’t mind paying for it, WebStorm might be your best bet. However, if you
    prioritize speed, flexibility, and customization and are comfortable setting up
    your environment through extensions, VS Code could be the better choice.
  prefs: []
  type: TYPE_NORMAL
- en: I prefer WebStorm as my IDE at work – part of the reason is I am already very
    familiar with the keymaps, and I love the built-in auto-refactoring capability.
    However, I still use VS Code for casual projects.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Refactoring** is a disciplined, systematic process of improving the design
    of an existing code base without changing its external behavior. It’s a fundamental
    aspect of everyday coding, a practice integral to the iterative and incremental
    nature of software development. The concept is universally applicable, and not
    bound to any specific programming language, framework, or paradigm. Whether you’re
    writing in JavaScript, Python, or any other language, and whether you’re using
    React, Angular, or a homegrown framework, refactoring is crucial to maintaining
    a healthy code base.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The term “refactoring” was first introduced by William Opdyke and Ralph Johnson
    in a 1990 paper titled *Refactoring: An Aid in Designing Application Frameworks
    and Evolving Object-Oriented Systems*; however, the concept and practice of refactoring
    have roots in earlier practices in software engineering. The art of refactoring
    gained significant prominence with Martin Fowler’s book *Refactoring: Improving
    the Design of Existing Code*, published in 1999\. In this book, Fowler describes
    refactoring as “a controlled technique for improving the design of an existing
    code base,” emphasizing its role in mitigating the buildup of technical debt,
    which makes the code easier to understand, maintain, and extend.'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring isn’t about making one grand, sweeping change to perfect the code
    base. Instead, it’s about making small, incremental improvements consistently
    over time. Each individual change might not dramatically alter the quality of
    the code, but collectively, over time, these small changes can significantly enhance
    the structure, readability, and maintainability of the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Although refactoring doesn’t add new functionality, it directly influences the
    team’s ability to deliver new features more quickly, with fewer bugs, and to respond
    more flexibly to changing requirements. By continuously refactoring, we keep our
    code clean and easy to work with and set the stage for long-term, sustainable
    development.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, refactoring is a critical tool in a developer’s toolkit, irrespective
    of the technology stack or the size and scope of the project. It’s a long-term
    investment in the code base and the team, and ultimately, it’s an investment in
    the quality of the software that is delivered.
  prefs: []
  type: TYPE_NORMAL
- en: The common mistakes of refactoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The biggest mistake people make in refactoring is that they restructure code
    rather than refactoring it. The terms “refactoring” and “restructuring” are often
    used interchangeably, but they have distinct meanings in software development.
  prefs: []
  type: TYPE_NORMAL
- en: '*Refactoring* is a disciplined technique for improving the design of an existing
    code base, making it cleaner and easier to understand and work with. It involves
    changing the internal structure of the software without modifying its external
    behavior. This is generally done in small steps, and each refactoring step is
    expected to maintain the software’s functionality. It doesn’t add new features;
    instead, it makes the code more readable, maintainable, and prepared for future
    changes.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, in a React application, refactoring could involve breaking down
    a large component into smaller, more manageable components, or replacing complex
    conditional logic with a strategy pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '*Restructuring*, on the other hand, can be seen as a broader and more drastic
    process. It often involves large-scale changes that not only impact the internal
    structure of the software but can also affect its external behavior. Restructuring
    can encompass changes to the software’s architecture, data models, interfaces,
    and more. It is often driven by the need to introduce major changes or additions
    to the software’s features or capabilities, to improve performance, or to address
    significant technical debt.'
  prefs: []
  type: TYPE_NORMAL
- en: In the context of a React application, restructuring might involve changing
    the state management solution (such as moving from Redux to the React Context
    API), updating the routing mechanism, or transitioning from a monolithic architecture
    to a microfrontend architecture.
  prefs: []
  type: TYPE_NORMAL
- en: While both refactoring and restructuring aim to improve the quality of the code
    base, refactoring is typically smaller in scope, involves no change in functionality,
    and is part of the regular development process. In contrast, restructuring is
    generally larger in scope, can change functionality, and is often part of a larger
    project or initiative to address more significant challenges or changes in requirements.
  prefs: []
  type: TYPE_NORMAL
- en: As well as a misunderstanding between refactoring and restructuring, another
    mistake people tend to make is that they don’t test as often – sometimes this
    is because they don’t have many tests, while at other times they think it’s safe
    to make these “small” changes without testing. Let’s look at testing in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding tests before refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because we don’t want to make any observable behavior changes during refactoring,
    we need to inspect the code to make sure we have enough tests to cover the current
    behavior. It’s easy to mess up without the right tests in place, and that’s not
    only risky but also less efficient, as we need to check the changed code manually
    and repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we have some TypeScript code from an online shopping application
    – the code works fine, but there aren’t any tests associated with it. To improve
    the code so that it’s easier to understand and extend, we need to refactor it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: So, this code defines a shopping cart model. Firstly, it defines an `Item` interface,
    which represents an item to be added to the cart. An `Item` component consists
    of an ID, a price, and a quantity. Then, it defines a `ShoppingCart` class with
    a `cartItems` property, which is an array of `Item` objects, initially empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ShoppingCart` class has two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The `addItemToCart` method accepts an ID, price, and quantity, and then creates
    an item using these parameters. This item is then added to the `cartItems` array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `calculateTotal` method calculates the total price of the items in the cart.
    For each item, it multiplies the item’s price by its quantity to get a subtotal.
    If the quantity of the item is more than 10, a 10% discount is applied to the
    subtotal. The subtotal of each item is then added together to get the total. The
    total is then returned by the method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two important calculations here: compute the total price (price by
    quantity) and apply the discount when eligible. We normally should pay more attention
    to the logic regarding these calculations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we need to verify both sides of an `if-else` statement. As we
    have `if-else` inside the `for` loop, we will at least need to add two test cases
    before making changes. Let’s add the following Jest tests to describe both calculations
    – with and without a discount:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first test, `calculates item prices`, is verifying that the `calculateTotal`
    method works as expected when no discounts are applied. Here, a `ShoppingCart`
    object is instantiated, and two items (`apple` and `orange`) are added to the
    cart. The total price of these items is calculated and expected to be 7.5, as
    there are two apples at $2 each and one orange at $3.5.
  prefs: []
  type: TYPE_NORMAL
- en: The second test, `applies discount when applicable`, is checking that the `calculateTotal`
    method correctly applies a 10% discount when the quantity of an item is more than
    10\. In this case, a `ShoppingCart` object is instantiated, and one type of item
    (`apple`) is added to the cart with quantity 11\. The total price of this item
    should be $19.8 after applying the 10% discount on the subtotal of $22 (11 apples
    at $2 each). The calculated total price is then checked against this expected
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have test cases to cover the important logic, we can safely make changes.
    During refactoring, we’ll need to run these tests regularly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refactorings are small steps that can improve the code. Let’s have a look at
    our very first and maybe the simplest refactoring technique: **Rename Variable**.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Rename Variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with a simple refactoring technique called Rename Variable. Rename
    Variable is a very straightforward yet effective method to improve the readability
    and maintainability of the code. It involves changing the name of a variable to
    better reflect its purpose and the data it holds, or to follow a certain naming
    convention or standard.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, during the initial phases of coding, developers might choose names
    for variables that make sense at that time, but as the code evolves, the purpose
    of the variable might change or become clearer. The variable name, however, often
    remains the same. This can cause confusion and make the code harder to understand
    and maintain. Renaming variables to describe their purposes more accurately can
    reduce the cognitive load for future readers of the code, including the future
    self of the current coder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s return to our `ShoppingCart` example. The variable name `cartItems` inside
    the `ShoppingCart` class is a little redundant; however, we can rename it to simply
    `items` to be more concise and clean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After the change, make sure to run the tests again to see whether we accidentally
    made any mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to establish a habit of running tests regularly after making
    some changes, and whenever the tests fail, we need to stop and examine what is
    wrong. Once all the tests are back to passing, we can then proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Using Extract Variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Extract Variable** is a common refactoring technique that is used to improve
    the readability and maintainability of code. The process involves taking a section
    of code that calculates a value, replacing it with a new variable, and assigning
    the result of the original expression to this new variable. There is a similar
    refactoring called **Extract Constant** that can be used to extract a value that
    doesn’t change at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: This refactoring technique is particularly useful when you have a complex expression
    or a duplicated calculation; by extracting parts of the expression to variables
    with meaningful names, the code becomes more understandable and easier to manage.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ShoppingCart` example, the `0.9` discount rate deserves its own name;
    we can extract a variable and reference it at the point where the function is
    called. As the value of the variable isn’t going to change at runtime, we can
    call it **Extract Constant** in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For the sake of clarity, portions of the code that aren’t relevant to this particular
    change have been left out of the discussion; however, the important thing to note
    is that in this instance, we’ve created a constant named `DISCOUNT_RATE` and used
    it in place of the previous hard-coded value of `0.9` where it’s utilized in the
    code. At times, we may wish to assign a name to an expression other than a hard-coded
    value, so we can create a variable to stand in for the expression and then refer
    to that variable.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a tiny step, but it improves the code slightly. If we need to change the
    discount rate in the future, the constant name is much easier to search and understand
    than the hard-coded value of `0.9`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can investigate another refactoring technique to make the `for` loop
    a bit simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Using Replace Loop with Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `map`, `filter`, and `reduce` in functional programming languages such as
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of JavaScript, the Array prototype has methods such as `map`, `filter`,
    and `reduce` that can be chained together to form a pipeline. Each of these methods
    receives a function as an argument and applies this function to each element in
    the array, effectively transforming the array in some manner.
  prefs: []
  type: TYPE_NORMAL
- en: However, keep in mind that while replacing loops with pipelines can make the
    code cleaner and more readable, it might not always be the most efficient option,
    especially when dealing with very large datasets. So, as with all refactorings,
    you need to balance readability and maintainability with performance requirements
    in cases when you need to iterate through a large dataset multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for` loop in the previous section can be replaced by the `reduce` function
    (and we don’t have to explicitly define an index variable or save the boilerplate
    code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `calculateTotal()` method is using the `reduce()` function to calculate
    the total price of the items in the shopping cart. The `reduce()` function is
    a higher-order function that applies a function against an accumulator and each
    element in the array (from left to right) to reduce it to a single output value.
  prefs: []
  type: TYPE_NORMAL
- en: The total starts at 0 and then for each item in the shopping cart, it adds the
    `subTotal` variable of that item to the total. The `subTotal` variable is calculated
    by multiplying the price and quantity of each item.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to re-run all the tests to check whether everything goes well.
    As our tests are still passing, let’s see how we can make the code even better
    by extracting lines into a smaller function.
  prefs: []
  type: TYPE_NORMAL
- en: Using Extract Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Extract Function** is a refactoring technique that helps to improve code
    readability and maintainability by breaking down a large or complex function into
    smaller, more manageable parts.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say you come across a function that’s performing multiple tasks. Maybe
    it’s doing some data validation, then some computations, and finally logging the
    result or updating some state. The function is long and complex, making it hard
    to understand at a glance what it’s doing. Extract Function refactoring is all
    about identifying those distinct pieces of functionality, pulling them out into
    their own separate functions, and then calling those new functions from the original
    one.
  prefs: []
  type: TYPE_NORMAL
- en: One key benefit is that it makes the code more self-documenting. If you extract
    a part of your function to a new function and give it a meaningful name, it can
    often make the code much easier to understand since the function name can describe
    what the code is doing. It also improves the reusability of the code, since these
    smaller functions can be reused elsewhere if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic of how to calculate the `subTotal` variable can be extracted from
    `calculateTotal` as a separate unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, we see the result of an Extract Function refactoring.
    The logic to apply a discount if the item quantity is greater than 10 has been
    extracted into its own function named `applyDiscountIfEligible`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `ShoppingCart` class, the `calculateTotal` method calculates the total
    price of the items in the cart using the `reduce` function. For each item, it
    computes the subtotal as the product of the item’s price and quantity, then adds
    this subtotal (after applying any eligible discount) to the total.
  prefs: []
  type: TYPE_NORMAL
- en: The `applyDiscountIfEligible` function takes an item and its quantity as arguments.
    If the quantity of the item is more than 10, it applies a discount rate (represented
    by `DISCOUNT_RATE`) to the argument `subTotal`; otherwise, it simply returns the
    argument `subTotal` as it is.
  prefs: []
  type: TYPE_NORMAL
- en: This refactoring makes the `calculateTotal` method more concise and easier to
    read, by abstracting away the details of how discounts are applied into a separate,
    appropriately named function.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at another refactoring method that could make the passed-in parameter
    easy to modify.
  prefs: []
  type: TYPE_NORMAL
- en: Using Introduce Parameter Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Introduce Parameter Object** is a refactoring technique used when a function
    has a large number of parameters, or when multiple functions share the same parameters.
    In this technique, you group related parameters into a single object and pass
    that object to the function instead.'
  prefs: []
  type: TYPE_NORMAL
- en: A large number of parameters in a function can be confusing and difficult to
    manage. Grouping related parameters together into an object can increase code
    readability and make it easier to understand what the function does. It also makes
    the function call simpler and cleaner. Furthermore, if the same group of parameters
    is used in multiple function calls, this technique reduces the chances of passing
    parameters in the wrong order.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider a `calculateTotalPrice(quantity, price, discount)` function.
    We could refactor this using the Introduce Parameter Object technique to become
    `calculateTotalPrice({ quantity, price, discount })`. Now, the `quantity`, `price`,
    and `discount` parameters are grouped together into an object (with type `Item`),
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: On top of these benefits, Introduce Parameter Object refactoring can often reveal
    or inspire domain concepts that were previously hidden and implicit in your code.
    The parameter object might become a class of its own, with its own behavior and
    data manipulation methods. This can lead to more object-oriented and encapsulated
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s explore another refactoring technique designed to streamline your
    `if-else` statements and enhance code readability.
  prefs: []
  type: TYPE_NORMAL
- en: Using Decompose Conditional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`if-else` or `switch`) is extracted into separate functions. This technique
    helps to improve the readability of the code, making it more understandable.'
  prefs: []
  type: TYPE_NORMAL
- en: The condition, `if` clause, and `else` clause (if it exists) all get their own
    function. These functions are then named according to what they do or what they
    are checking for. This refactoring is beneficial because it replaces code that
    might need comments to understand with well-named functions, making the code self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the logic in the `applyDiscountIfEligible` function can actually
    be simplified by this refactoring; we can extract a small function called `isDiscountEligible`
    to replace the `item.quantity > 10` check, like in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, the extraction of logic into a separate function might
    appear superfluous because it adds an additional function call. However, it enhances
    readability and reusability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, we’ve separated the logic that determines whether an item
    is eligible for a discount into a standalone `isDiscountEligible` function. This
    extraction makes our `applyDiscountIfEligible` function cleaner and its intention
    more evident. Additionally, it allows for the `isDiscountEligible` logic to be
    updated independently if needed in the future, improving maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: After extracting these smaller functions, they don’t have to reside in the current
    file. We can relocate them to a separate module and import them as needed; this
    not only shortens the length of the current module but also improves its readability.
    Let’s look at that next.
  prefs: []
  type: TYPE_NORMAL
- en: Using Move Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Move Function** is a refactoring method that involves changing the location
    of a function to a more suitable or appropriate place. This could be within the
    same class, to a different class, or even to a separate module. The objective
    of this method is to enhance the readability, maintainability, and structure of
    the code by ensuring that functions are placed where they logically fit best.'
  prefs: []
  type: TYPE_NORMAL
- en: This kind of refactoring becomes necessary when the responsibilities of your
    classes evolve over time. You might find that a function makes more sense in a
    different class, or perhaps you have a group of functions within a class that
    work together and would be better suited in their own class or module.
  prefs: []
  type: TYPE_NORMAL
- en: Move Function refactoring can help reduce the complexity of the class by moving
    functions to the places where their functionality is most relevant or required.
    This promotes the principle of cohesion where related code is kept together. It
    also aids in achieving loose coupling by minimizing unnecessary dependencies between
    different parts of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `ShoppingCart` component, we can move the type definition into a new
    file called `types.ts`. We can also move `DISCOUNT_RATE`, `isDiscountEligible`,
    and `applyDiscountIfEligible` into a separate file called `utils.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the code, only `applyDiscountIfEligible` is a public function and
    can be accessed outside of the file. This refactoring also improves the encapsulation
    of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'After Move Function is used, the `ShoppingCart` component is simplified significantly
    and only has the necessary parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As with all refactoring, care should be taken when moving functions to ensure
    that the overall behavior of the system is not altered. Tests should be in place
    to verify that the functionality remains the same after refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on a variety of code refactoring techniques that are essential
    to maintaining and improving the structure, readability, and maintainability of
    your code base.
  prefs: []
  type: TYPE_NORMAL
- en: The refactoring techniques introduced include Rename Variable, which enhances
    code clarity by using more descriptive variable names, Extract Variable, which
    simplifies complex expressions by breaking them into smaller, more manageable
    parts, and Replace Loop with Pipeline, which transforms traditional `for`/`while`
    loops into more concise, declarative higher-order functions such as `map`, `filter`,
    and `reduce`.
  prefs: []
  type: TYPE_NORMAL
- en: As well as this, Extract Function encourages code modularity and reusability
    by breaking down large functions into smaller ones, each with a single, well-defined
    responsibility, while Introduce Parameter Object groups related parameters into
    a single object, thereby reducing the complexity of function signatures. Plus,
    Decompose Conditional breaks down complex conditional logic into separate functions,
    enhancing readability, and Move Function ensures that functions are placed in
    the most logical and appropriate location in your code base, promoting high cohesion
    and loose coupling.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout all these techniques, we emphasized the importance of maintaining
    the same overall system behavior and relying on tests to ensure that functionality
    remains consistent despite refactoring. These methods, when properly applied,
    can lead to a more understandable, easier to maintain, and more robust code base.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore an exceptional approach to enhancing the
    quality of our code – the method known as test-driven development.
  prefs: []
  type: TYPE_NORMAL
