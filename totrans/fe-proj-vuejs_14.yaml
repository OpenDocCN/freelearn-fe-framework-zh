- en: 14\. Deploying Your Code to the Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to explain the benefits of a CI/CD
    workflow and how it ties into the release cycle, release cadence, and development
    workflows. To this end, you'll be able to articulate what the differences between
    Vue.js development and production builds are and what trade-offs are made. In
    order to test and deploy a Vue.js application, you'll configure GitLab CI/CD with
    pipelines, jobs, and steps. You'll become familiar with Netlify, AWS S3, and AWS
    CloudFront, and their key similarities and differences.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at how to deploy a Vue.js application to be consumed
    over the World Wide Web and how to automate this deployment process to release
    often with ease and confidence.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at how you might leverage CI/CD tools and techniques
    to deliver applications to production with high confidence and at high frequency.
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, we saw how to build and test complex Vue.js applications.
    This chapter is about leveraging all the techniques, including testing and automating
    them, in order to deliver software to production with minimal risk and time overhead.
  prefs: []
  type: TYPE_NORMAL
- en: The Benefits of CI/CD as Part of an Agile Software Development Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous integration** (**CI**) is the practice of integrating code multiple
    times a day. In order to support this, a modern **version control system** (**VCS**)
    such as Git that supports multiple working states (branches) in a single repository
    is necessary in order to allow developers to work on code independently, while
    still allowing them to collaborate and integrate their changes safely.'
  prefs: []
  type: TYPE_NORMAL
- en: To augment the abilities of the VCS, hosting and collaboration tools around
    repositories (such as GitLab or GitHub) have been created and allow developers
    to view and manage code changes more efficiently through a web **user interface**
    (**UI**).
  prefs: []
  type: TYPE_NORMAL
- en: As part of, or in addition to, these hosting platforms and the collaboration
    tools they provide, automated checks are crucial to maintaining high confidence
    in the quality of the code before, during, and after integration. Adopting a CI
    approach often entails including additional code quality steps, such as unit or
    integration tests, coverage checks, and building artifacts on the mainline branches
    (branches into which changes are integrated) every time any new code is integrated.
  prefs: []
  type: TYPE_NORMAL
- en: The conventions that a team follows for using Git for code collaboration and
    CI are called a **Git workflow**, which is often shortened to **Git flow**.
  prefs: []
  type: TYPE_NORMAL
- en: A Git flow will predicate branch naming conventions, as well as how and when
    changes are integrated. For example, a team might decide that branches should
    be prefixed with ticket numbers followed by a short dash-cased description such
    as `WRK-2334-fix-ie-11-scroll`.
  prefs: []
  type: TYPE_NORMAL
- en: Other examples of conventions that are decided on and adhered to as part of
    a Git flow are commit message lengths and titles, the automated checks that should
    pass or are allowed to fail, and the number of reviewers required to merge a change
    request, which is a pull request or merge request in GitHub and GitLab parlance, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Git flows fall under two rough categories: trunk-based development and (feature)
    branch-based development. We''ll cover branch-based development first since its
    limitations have become quite clear and the majority of projects tend to use trunk-based
    development.'
  prefs: []
  type: TYPE_NORMAL
- en: In a branch-based Git workflow, multiple working branches are kept in the repository.
    Branch-based flows can be used to keep branches that mirror the state of environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following diagram shows three branches – **production**, **staging**,
    and **develop**. **production** does not contain any changes from **staging**
    or **develop**. **staging** is ahead of **production** but has no changes in common
    with **develop** other than the changes that are on **production**. **develop**
    is ahead of both **staging** and **production**: it''s branched off of **production**
    at the same commit as **staging** is, but it doesn''t share any further commits
    with **staging**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1: An example of a branch-based Git commit/branch tree'
  prefs: []
  type: TYPE_NORMAL
- en: with three environment branches
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.1: An example of a branch-based Git commit/branch tree with three
    environment branches'
  prefs: []
  type: TYPE_NORMAL
- en: A branch-based workflow can also be used to keep track of changes going into
    release lines. This is useful in cases where a project has to maintain two versions
    of an application or library, but bug fixes or security patches need to be applied
    to both versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we have got a similar branching example as the environment
    branch one. Release 1.0.0 contains some changes that are not present in 1.0.1
    and 1.1.0 but does not share any of the newer code. Releases 1.0.1 and 1.1.0 are
    branched off of 1.0.0 at the same time, but they do not share further changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2: An example of a branch-based Git commit/branch tree'
  prefs: []
  type: TYPE_NORMAL
- en: with three release branches
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.2: An example of a branch-based Git commit/branch tree with three
    release branches'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a trunk-based Git flow, each member of the team will create new branches
    off of a single branch, usually the "master" branch. This process is often referred
    to as "branching off of":'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3: A sample trunk-based Git commit/branch tree with two feature
    branches branched off of the master'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.3: A sample trunk-based Git commit/branch tree with two feature branches
    branched off of the master'
  prefs: []
  type: TYPE_NORMAL
- en: An extreme case of a trunk-based workflow is to have a *single* branch that
    everyone commits on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In a trunk-based environment, an alternative to "release branches" is to use
    Git tags to keep track of release snapshots. This gives the same advantages as
    maintaining branches with reduced branch noise and the added benefit of immutability
    since tags cannot be changed once they're created.
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous delivery** (**CD**) is the ability of a team to deploy every good
    build to a production environment.'
  prefs: []
  type: TYPE_NORMAL
- en: A pre-requisite to CD is CI, since CI provides some initial confidence in the
    quality of a build. As part of CD, new systems, tools, and practices are required
    beyond CI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following diagram for a look at the tools and practices that relate
    more to CI and those that relate more to CD:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4: The relationship between CI and CD practices'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.4: The relationship between CI and CD practices'
  prefs: []
  type: TYPE_NORMAL
- en: The extra ingredient required to adopt CD is a high level of confidence that
    the application is going to keep working as expected (for the end user) and that
    new defects have not been unwittingly introduced. This means an additional end-to-end
    testing step is needed during or after the CI checks, to validate the build before
    being able to deploy it.
  prefs: []
  type: TYPE_NORMAL
- en: These end-to-end tests can be conducted manually, or they can be automated.
    In an ideal CD setup, the latter (automated end-to-end tests) is preferred since
    it means deployments do not include manual interaction. If the end-to-end tests
    pass, the build can automatically be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: In order to facilitate CD, systems used to deploy software have had to be rethought.
    As part of CD, deployment cannot be a long-winded manual process. This has led
    to companies adopting cloud-native technologies, such as Docker, and infrastructure
    as code tools, such as HashiCorp's **Terraform**.
  prefs: []
  type: TYPE_NORMAL
- en: The emphasis on moving toward CD practices has led to the inception of ideas
    such as **GitOps** and **ChatOps**.
  prefs: []
  type: TYPE_NORMAL
- en: In GitOps and ChatOps, deployments and operational tasks are driven by the tools
    that developers and stakeholders interact with daily.
  prefs: []
  type: TYPE_NORMAL
- en: In GitOps, deployments can be done through GitHub/GitLab (or another Git-hosting
    provider), directly with GitHub Actions or GitLab CI/CD, or through CI/CD software
    (such as CircleCI or Jenkins), which have tight integrations and reporting with
    GitHub/GitLab.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of ChatOps, conversational interfaces are used to deploy and operate
    software. Some flavors of ChatOps can be considered a subset of GitOps, for example,
    interacting with tools such as `deploy <service-name> <environment>`, which will
    deploy the service to the relevant environment. Note that chat interfaces are
    very reminiscent of command-line interfaces that developers might be used to but
    other stakeholders might take some time to adopt.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve now looked at approaches to CI and CD; what we''ll discuss next is the
    advantages of using CI and CD:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5: Advantages of CI and CD'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.5: Advantages of CI and CD'
  prefs: []
  type: TYPE_NORMAL
- en: Both practices also have an impact on the team's mindset and performance. Being
    able to see the changes you make integrated within a day and in production in
    less than a week means that contributors can see their work having an impact immediately.
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD also helps promote agile principles, where changes are applied and deployed
    iteratively. This is as opposed to long timelines for projects, for which inaccuracies
    in estimations compound and can cause major delays.
  prefs: []
  type: TYPE_NORMAL
- en: Building for Production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying applications to production starts with creating an artifact that can
    be deployed. In the case of Vue.js, we're building a client-side application,
    which means our build artifact will contain HTML, JavaScript, and CSS files.
  prefs: []
  type: TYPE_NORMAL
- en: The Vue CLI comes with a `build` command. This `build` command will take our
    Vue.js single-file components (`.vue` files) and compile them into render functions
    (JavaScript functions that the Vue runtime can use to render our application)
    that will be output to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: As part of the build process, the Vue CLI will take JavaScript, Vue single-file
    components, and modules that are imported into each other and *bundle* them. Bundling
    means that related chunks of code that depend on each other will be output as
    a single JavaScript file.
  prefs: []
  type: TYPE_NORMAL
- en: Due to our use of the Vue CLI, the Vue.js library itself can also be slimmed
    down. The Vue.js runtime bundle can include a **runtime compiler** that takes
    string templates and turns them into render functions on the client side. Since
    we are compiling to render functions with the Vue CLI at build time, this part
    of Vue.js doesn't need to be included in our JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The Vue CLI build step also includes a `dead code elimination` step. That means
    that it can analyze the code being generated and if any of it is obviously never
    used – for example, a statement such as `if (false) { /* do something */}` – then
    it will not be present in the build output.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the Vue CLI builds for production when we call `vue service build`,
    which in Vue CLI projects is aliased to the `build` script, which can be run with
    `npm run build` or `yarn build`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a sample Vue CLI project, we''ll see something along these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.6: Output of "npm run build" in a fresh Vue CLI project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.6: Output of "npm run build" in a fresh Vue CLI project'
  prefs: []
  type: TYPE_NORMAL
- en: The `dist` folder is now ready to deploy using a static hosting solution such
    as Netlify or AWS S3 and CloudFront.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how to build a Vue.js application for production using the
    Vue CLI with the `npm run build` command.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how to use GitLab CI/CD to test our code (before deploying
    it).
  prefs: []
  type: TYPE_NORMAL
- en: Using GitLab CI/CD to Test Your Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitLab has a built-in CI/CD tool called GitLab CI/CD.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use GitLab CI/CD, you'll need a GitLab account.
  prefs: []
  type: TYPE_NORMAL
- en: To interact with Git repositories hosted on GitLab, you'll also need to associate
    an SSH key from your machine and to your GitLab account.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Instructions to add an SSH key in the GitLab documentation can be found at [https://docs.gitlab.com/ee/gitlab-basics/create-your-ssh-keys.html](https://docs.gitlab.com/ee/gitlab-basics/create-your-ssh-keys.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve created an account, you can create a new repository using the
    `New Project` button at the top right of the `Projects` page, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.7: The GitLab "Projects" page with the New Project button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.7: The GitLab "Projects" page with the New Project button'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click the `New Project` button, you will be taken to the `New Project`
    page, where you can use the default `Blank Project` tab to create a project by
    giving it a name and a slug, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.8: The GitLab New Project page with Blank Project selected'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.8: The GitLab New Project page with Blank Project selected'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you click `Create Project`, the GitLab `Project` page will appear in an
    empty state that displays instructions on how to clone it. You should run the
    commands required to clone the repository, which probably boils down to an equivalent
    of the following (which you are expected to run on your machine):'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you did not associate an SSH key with your account, at this stage GitLab
    should be showing you a warning with a link you can follow to set up an SSH key.
  prefs: []
  type: TYPE_NORMAL
- en: '`git clone <repository-url>`'
  prefs: []
  type: TYPE_NORMAL
- en: On your machine, you should then open the directory into which the repository
    was cloned. To add GitLab CI/CD, we need to add a `.gitlab-ci.yml` file into the
    root of the project. A sample `.gitlab-ci.yml` file that adds a `build` job to
    the `build` stage of the pipeline that installs dependencies (using `npm ci`),
    runs the production build (`npm run build`), and caches the output artifact is
    defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: The job name is defined by setting a top-level key in the YAML file – in this
    case, `build:`.
  prefs: []
  type: TYPE_NORMAL
- en: In YAML syntax, we'll then increase the indent to denote that the `build` key
    points to an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `build job` object, we will define which Docker image is used to run
    the job, using `image: node:lts`. This means we want this job to run on a Node.js
    **Long Term Support** (**LTS**) image, which will be Node.js 12 until October
    20, 2020, at which point it will point to a Node.js 14 image.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can access the up-to-date Node.js LTS schedule at [https://nodejs.org/en/about/releases/](https://nodejs.org/en/about/releases/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The other property we can define in our job is the stage. GitLab CI/CD pipelines
    by default have three stages: **build**, **test**, and **deploy**. These stages
    can be replaced using custom stages when a team''s workflow doesn''t fit into
    these three categories (for example, if there is more than one environment to
    deploy to). See the documentation ([https://docs.gitlab.com/ee/ci/yaml/#stages](https://docs.gitlab.com/ee/ci/yaml/#stages)).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`stages` is used to define stages that can be used by jobs, and it is defined globally.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The specification of `stages` allows for flexible multistage pipelines. The
    ordering of elements in stages defines the ordering of jobs'' execution:'
  prefs: []
  type: TYPE_NORMAL
- en: a) Jobs of the same stage are run in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: b) Jobs of the next stage are run after the jobs from the previous stage complete
    successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Our pipeline only has one stage and one job at the moment, so most of the preceding
    doesn't apply to us.
  prefs: []
  type: TYPE_NORMAL
- en: The final properties we set are `script`, which defines steps that should be
    run when the job is running, and `artifacts`, which configures artifact storage.
    In our case, we'll run `npm ci` to install all dependencies followed by `npm run
    build`, which will run the production Vue.js CLI build. Our artifact is set up
    to be held for a week and to contain the `dist` folder (which is where the Vue
    CLI `build` output is stored).
  prefs: []
  type: TYPE_NORMAL
- en: 'In full, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we push this `.gitlab-ci.yml` file to a repository containing a Vue CLI
    project, we will see the following in the repository view, where a pipeline with
    one step is running on the latest commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.9: GitLab repository view with the build job running on the latest
    commit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.9: GitLab repository view with the build job running on the latest
    commit'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we click on the `Pipeline` icon (the blue in-progress indicator), we get
    the pipeline view. In the pipeline view, `Build` represents the `state` pipeline
    (which we set as `build`) and it represents the job name (which we defined as
    `build`). We see the same in-progress indicator until the job completes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.10: GitLab CI pipeline view with the build job running'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.10: GitLab CI pipeline view with the build job running'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the job completes, we see a `success` icon (green check-mark). We can
    click this icon or the job name to access the job view while the job is running
    or after it has completed (whether it has failed or succeeded). When a job has
    completed, we also see a `Retry` icon, which can be useful to retry a failed pipeline
    step. The following screenshot shows that the job ran successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.11: GitLab CI pipeline view with the build job passing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.11: GitLab CI pipeline view with the build job passing'
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking the job, we see the `Job` view, which shows us a detailed breakdown
    of all the steps in the job. Starting with the `Preparing the docker_machine executor`
    steps, which load up the Node.js Docker image, we see steps for running the script
    as well as cache and artifact restores, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.12: The GitLab CI job view with the successful build job'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.12: The GitLab CI job view with the successful build job'
  prefs: []
  type: TYPE_NORMAL
- en: If we want to add a `test` step to our GitLab CI/CD runs, we need to be in a
    project that supports unit testing. This can be achieved using the Vue CLI, which
    is installed using `vue add @vue/unit-jest`. Installing and adding unit tests
    is covered in depth in *Chapter 12*, *Unit Testing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to add a new job to the `.gitlab-ci.yml` file; we will call it
    `test`, use the `node:lts` image, and assign the job to the `test` state. In the
    job, we run `npm ci`, followed by `npm run test:unit` (which is the `npm` script
    added by the `unit-jest` CLI plugin):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we push this new `.gitlab-ci.yml` file up, we get the following view on
    the main repository page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.13: Repository view with GitLab CI/CD running the pipeline with
    the new test step'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.13: Repository view with GitLab CI/CD running the pipeline with the
    new test step'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can click through to the pipeline view. The reason GitLab CI/CD uses pipelines
    is that a failing step at a certain stage will mean steps in any subsequent stages
    will not run. For example, if we get a failing `build` job, the jobs that are
    part of the `test` stage will not run. The following screenshot explains this
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.14: GitLab CI/CD pipeline view with a failed build job that stops'
  prefs: []
  type: TYPE_NORMAL
- en: the test job/stage from running
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.14: GitLab CI/CD pipeline view with a failed build job that stops
    the test job/stage from running'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we push another commit or retry the build step (if the failure is not caused
    by changes) and navigate to the pipeline view again, we''ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.15: GitLab CI/CD pipeline view with the test job running'
  prefs: []
  type: TYPE_NORMAL
- en: after the build stage jobs have all succeeded
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.15: GitLab CI/CD pipeline view with the test job running after the
    build stage jobs have all succeeded'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `test` job has succeeded, we''ll see the following pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.16: GitLab CI/CD pipeline view with all jobs succeeding in the
    build and test stages'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.16: GitLab CI/CD pipeline view with all jobs succeeding in the build
    and test stages'
  prefs: []
  type: TYPE_NORMAL
- en: We've now added a GitLab CI/CD pipeline with the `build` and `test` stages that
    will validate that on every push to the GitLab repository, the code still integrates
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.01: Adding a Lint Step to Your GitLab CI/CD Pipeline'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linting is a way to get automated formatting and code style checks. Integrating
    it as part of CI makes sure that all code merged into the mainline branches adheres
    to a team's code style guide. It also reduces the number of code style review
    comments, which can be noisy and might detract from fundamental issues with the
    change request.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the code files for this exercise, refer to [https://packt.live/2IQDFW0](https://packt.live/2IQDFW0):'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add linting, we need to ensure that our `package.json` file includes
    the `lint` script. If it''s missing, we''ll need to add it and set it to `vue-cli-service
    lint`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to run the lint on GitLab CI/CD, we need to add a new `lint` job that
    will run in a Node.js LTS Docker image at the `test` stage of the GitLab CI/CD
    pipeline. We will do this in `.gitlab-ci.yml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the `lint` job to run the `lint` script as per `package.json`, we need
    to add a `script` section in the `.gitlab-ci.yml` file. It first needs to run
    `npm ci` to install the dependencies, and then `npm run lint` to run the linting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to commit and push the code to GitLab using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the code is pushed, we can see the pipeline run using the GitLab CI/CD
    UI, as follows. Note how all the jobs at the `test` stage are run in parallel:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.17: The GitLab CI/CD pipeline view with all the jobs succeeding,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: including "test" and "lint" running in parallel
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_17.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.17: The GitLab CI/CD pipeline view with all the jobs succeeding,
    including "test" and "lint" running in parallel'
  prefs: []
  type: TYPE_NORMAL
- en: We've now seen how to use GitLab CI/CD to run builds and tests on every commit.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll see how to deploy a Vue.js application to Netlify.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Netlify
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Netlify is a hosting provider that specializes in static hosting and relevant
    supporting services in order to have a fully interactive site that uses static
    hosting. This includes offerings such as Netlify Functions (serverless functions),
    Netlify Forms (a no-backend form submission system), and Netlify Identity (an
    identity/authentication provider).
  prefs: []
  type: TYPE_NORMAL
- en: The following sections require you to have a Netlify account, which is free.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to deploy a site to Netlify is to use the drag and drop interface.
    You''ll find this at the bottom of the home page in the logged-in view: [https://app.netlify.com](https://app.netlify.com).
    It looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.18: Netlify''s drag and drop deployment section at the'
  prefs: []
  type: TYPE_NORMAL
- en: bottom of the App home page
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.18: Netlify''s drag and drop deployment section at the bottom of
    the App home page'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, therefore, choose a project where we''ve run the `npm run build` command
    and deploy the `dist` folder by simply dragging it to the drag and drop deployment
    section, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.19: Dragging and dropping the dist folder onto the Netlify drag
    and drop deployment section'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.19: Dragging and dropping the dist folder onto the Netlify drag and
    drop deployment section'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the upload has succeeded, Netlify redirects you to your new website''s
    administration page. This will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.20: The Netlify new app page for the drag and drop site'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.20: The Netlify new app page for the drag and drop site'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can click on the link to the site and we''ll see the default Vue CLI home
    page template, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.21: Netlify new app displaying a greeting message'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.21: Netlify new app displaying a greeting message'
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how to manually deploy a site to Netlify using the drag and
    drop interface.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how to deploy our site from GitLab to Netlify.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Netlify app home page, we need to click the `New site from Git` button,
    as displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.22: Netlify home page with the New site from Git button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.22: Netlify home page with the New site from Git button'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll see a page asking us to choose a Git provider to connect to. For this
    example, we will use `GitLab`. The following screenshot represents how the screen
    will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.23: Netlify – Create a new site | Connect to Git provider'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.23: Netlify – Create a new site | Connect to Git provider'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon clicking `GitLab`, we will get an OAuth authorization challenge from GitLab,
    which we need to accept by clicking on the `Authorize` button as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.24: GitLab OAuth authorization modal'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.24: GitLab OAuth authorization modal'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will then be redirected to Netlify and asked to choose a repository to deploy,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.25: Select a GitLab repository to deploy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.25: Select a GitLab repository to deploy'
  prefs: []
  type: TYPE_NORMAL
- en: We select the repository we want to deploy and are met with a configuration
    page. Since we're now building on Netlify's build servers, we need to configure
    Netlify to build the application and deploy the correct folder.
  prefs: []
  type: TYPE_NORMAL
- en: We fill out the `build` command as `npm run build` since that's our build script.
    The publish directory is `dist`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then click the `Deploy site` button, which will start the deployment
    process, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.26: The Netlify build configuration tab, filled in with npm run
    build'
  prefs: []
  type: TYPE_NORMAL
- en: and dist for the build command and publish directory, respectively
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.26: The Netlify build configuration tab, filled in with npm run build
    and dist for the build command and publish directory, respectively'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will then be redirected to the newly created app''s page, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.27: New Netlify app'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.27: New Netlify app'
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how to deploy an application to Netlify using the manual upload
    method and using GitLab as the Git hosting provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.02: Deploying a Site to Netlify from GitHub'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen how to deploy a site to Netlify from GitLab, but how different
    is it from deploying it from GitHub? The answer is that they are very similar;
    the only notable difference is the first step in the `Connect to Git provider`
    tab:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin by clicking the `New site from Git` button on the home page, as follows:![Figure
    14.28: New site from Git on the Netlify dashboard'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_28.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.28: New site from Git on the Netlify dashboard'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will then choose `GitHub` as the Git hosting provider, as shown in the following
    screenshot:![Figure 14.29: Continuous Deployment'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_29.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.29: Continuous Deployment'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When we get the GitHub OAuth authorization challenge, as shown in the following
    screenshot, we authorize Netlify:![Figure 14.30: GitHub authorization challenge'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_30.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.30: GitHub authorization challenge'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We select the Vue CLI project we want to deploy from the repository list, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.31: Selecting the correct repository'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_31.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.31: Selecting the correct repository'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the deployment options tab, we select `master` as the branch to deploy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the build command as `npm run build`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the publish directory as `dist`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The completed deployment options look as follows:![Figure 14.32: The Netlify
    build configuration tab filled in with npm run'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: build and dist for the build command and publish directory, respectively
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_32.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.32: The Netlify build configuration tab filled in with npm run build
    and dist for the build command and publish directory, respectively'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We click `Deploy site` to start the deployment process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've now seen how to deploy an application to Netlify using the manual upload
    method and using GitLab or GitHub as the Git hosting provider.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how to use **Amazon Web Services Simple Storage Service**
    (**AWS S3**) and AWS CloudFront to deploy a Vue.js application.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to AWS Using S3 and CloudFront
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazon S3 is a static storage offering that can be used as a host for static
    files, such as what is generated by the Vue CLI's `build` script.
  prefs: []
  type: TYPE_NORMAL
- en: CloudFront is AWS' **content delivery network** (**CDN**) offering. A CDN can
    improve a web application's performance by serving static content from an **edge**
    location. These servers are positioned around the world and are more likely to
    be geographically located close to the end user than the **origin** servers (the
    ones that actually serve the content). Edge servers in a CDN request resources
    from the origin if they don't have them cached but will serve subsequent requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'A prerequisite for the following steps is an AWS account:'
  prefs: []
  type: TYPE_NORMAL
- en: We will start by creating and configuring an S3 bucket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We begin by heading to the S3 product page. It will look similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.33: Select S3 from the AWS service list'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_33.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.33: Select S3 from the AWS service list'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'On the S3 console home page, we can click the `Create bucket` button, which
    will take us to the bucket creation page, as seen here:![Figure 14.34: The Create
    bucket button on the AWS S3 console'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_34.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.34: The Create bucket button on the AWS S3 console'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To begin, we start by naming our bucket. For the purposes of this example,
    let''s call it `vue-workshop`, as follows:![Figure 14.35: Entering the bucket
    name on the bucket creation page'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_35.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.35: Entering the bucket name on the bucket creation page'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will also need to set the S3 bucket to be public. This is done by unselecting
    the `Block all public access` checkbox. Once this is done, we must check the acknowledgment
    checkbox, as seen here:![Figure 14.36: Set the S3 bucket to be public and acknowledge
    the warning'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_36.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.36: Set the S3 bucket to be public and acknowledge the warning'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once this is done, we are redirected to the bucket list page. We want to click
    into our new bucket. Then, we need to access the `Properties` tag in order to
    find the `Static website hosting` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.37: The Static website hosting option in the S3 bucket''s Properties
    tab'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_37.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.37: The Static website hosting option in the S3 bucket''s Properties
    tab'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can fill out the `Static website hosting` S3 property, selecting `Use this
    bucket to host a website` and setting the index document and error document to
    `index.html`. It is a good idea to take note of the `Endpoint` URL, which we''ll
    need to configure CloudFront, as follows:![Figure 14.38: Filling out the Static
    website hosting S3 property'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_38.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.38: Filling out the Static website hosting S3 property'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now go back to the `Overview` tab of the S3 bucket page, click `Upload`,
    and drag and drop the files from one of our `dist` folders, as seen in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.39: Adding files to the vue-workshop S3 bucket through drag and
    drop'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_39.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.39: Adding files to the vue-workshop S3 bucket through drag and drop'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once files are dropped on the overview page, we click `Next` and need to make
    sure file permissions are set to `public` by selecting `Grant public read access
    to this object(s)` in the `Manage public permissions` section of the page. Once
    that is completed, we can complete the upload without any changes from the default
    values by clicking `Next` and `Upload`, after having reviewed the files being
    uploaded, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.40: Setting file permissions to public on files being uploaded
    to the S3 bucket'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_40.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.40: Setting file permissions to public on files being uploaded to
    the S3 bucket'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our S3 bucket should now be configured to host static content, and by visiting
    the website endpoint (which is available in **Properties** | **Static website
    hosting**), we see the following Vue.js application (which is what we uploaded):![Figure
    14.41: The Vue.js application being served from our AWS S3 bucket'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_41.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.41: The Vue.js application being served from our AWS S3 bucket'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that S3 can only serve sites over HTTP, and domain names cannot be configured
    directly from S3 buckets. Beyond performance and robustness, being able to set
    custom domain names and HTTPS support are other reasons to set up AWS CloudFront
    as a CDN for our website.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will start by navigating to the CloudFront console and clicking the `Create
    Distribution` button as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.42: Select CloudFront from the AWS service list'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_42.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.42: Select CloudFront from the AWS service list'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When prompted for which type of distribution we want to create, we will select
    `Web` by clicking the relevant `Get Started` button, as seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.43: Choosing to create a Web CloudFront distribution'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_43.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.43: Choosing to create a Web CloudFront distribution'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Origin Domain Name` should be the S3 bucket website endpoint domain – in other
    words, the domain of the URL we used to access it earlier. It looks something
    like `example.s3-website.us-west-1.amazonaws.com` for the `example` bucket in
    the `us-east-1` region. The following screenshot displays this:![Figure 14.44:
    Enter the website endpoint domain in the CloudFront'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_44.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.44: Enter the website endpoint domain in the CloudFront distribution''s
    "Origin Domain Name" field'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'While we are setting up the distribution, it''s a good idea to select the `Redirect
    HTTP to HTTPS` option for the `Default Cache Behavior` section''s `Viewer Protocol
    Policy` field as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.45: Select Redirect HTTP to HTTPS for the Viewer Protocol Policy
    field'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_45.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.45: Select Redirect HTTP to HTTPS for the Viewer Protocol Policy
    field'
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to click the `Create Distribution` button and wait for the
    changes to propagate.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: CloudFront distribution changes take a while to propagate since they are being
    deployed to servers around the world.
  prefs: []
  type: TYPE_NORMAL
- en: We can open the domain name for the CloudFront distribution once the console
    shows its status as `Deployed`.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to set up S3 and CloudFront to serve a static website. We will
    now see how to use the AWS CLI to synchronize a local directory to the S3 bucket.
  prefs: []
  type: TYPE_NORMAL
- en: A prerequisite for the next section is a shell instance that has AWS credentials
    injected using the `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, and `AWS_DEFAULT_REGION`
    environment variables. The access key and secret key need to be generated from
    the `Account` dropdown | `My Security Credentials` | `Access Keys`. It also requires
    the AWS CLI version 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we''re in a Vue CLI project, we can deploy the `dist` folder (which can
    be built using `npm run build`) to our `vue-workshop` bucket using an AWS S3 CLI
    command. We want to update an `s3` resource so that our command will start with
    `aws s3`. The command we want to issue is to synchronize files, so we will use
    the `aws s3 sync` command. We will sync `./dist` to the `vue-workshop` S3 bucket,
    using the AWS URI syntax – that is, `s3://vue-workshop`. We also want to make
    sure that the files we upload, just like the bucket configuration, allow `public-read`.
    In full, the command looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 14.03: Deploying to S3 from GitLab CI/CD'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: S3 is a very cost-effective and performant solution for storing static files
    at scale. In this exercise, we'll look at how to integrate GitLab CI/CD and AWS
    S3 to deploy a Vue.js application. This automates the deployment of the Vue.js
    application. The deployment will run on every push to GitLab without any manual
    intervention.
  prefs: []
  type: TYPE_NORMAL
- en: To access the code files for this exercise, refer to [https://packt.live/3kJ1HPD](https://packt.live/3kJ1HPD).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to deploy to the S3 bucket from GitLab CI/CD, we will need to first
    set credential management:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the `CI/CD` settings section of GitLab as follows:![Figure 14.46:
    CI/CD in the Settings menu'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_46.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.46: CI/CD in the Settings menu'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will want to add variables, so let''s expand that section. You will see
    a message as shown in the following screenshot:![Figure 14.47: The Variables section
    of the GitLab CI/CD settings expanded'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_47.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.47: The Variables section of the GitLab CI/CD settings expanded'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we''ll add `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` using the
    UI (values not shown since they''re sensitive API keys), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.48: Entering the AWS_ACCESS_KEY_ID environment variable'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_48.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.48: Entering the AWS_ACCESS_KEY_ID environment variable'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can then add the default `AWS_REGION` variable using the UI. This isn''t
    so sensitive, so its value is shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.49: Entering the AWS_DEFAULT_REGION environment variable'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_49.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.49: Entering the AWS_DEFAULT_REGION environment variable'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have set up our environment variables on GitLab CI/CD, we can start
    updating our `.gitlab-ci.yml` file. First, we want to start caching the `dist`
    directory after our `build` step. In order to do this, we need to add a `cache`
    property to the `build` job:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now add our `deploy` job, which will be a part of the `deploy` stage.
    To access the AWS CLI, we will use a Python image (`python:latest`) and install
    the AWS CLI using `pip` (a Python package manager) in our `before_script` step.
    Once we''ve installed the AWS CLI, we will run the deployment in the `script`
    step using the `aws s3 sync` command we used to deploy from our local machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We don't need to invalidate caches since the Vue CLI `build` command has built-in
    cache-busting through fingerprinting the contents of a file in the filename. Fingerprinting
    means that if the contents of a file change, its name/URL will change accordingly.
    When this new file is requested, it will be loaded from an un-cached URL and will
    therefore get the latest version of the file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once this update to the configuration is pushed to the GitLab repository, we
    can see the pipeline running three stages that all pass, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.50: Passing build, test, and deploy jobs'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_50.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.50: Passing build, test, and deploy jobs'
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how to configure and deploy a Vue.js application to S3 and
    CloudFront using the AWS CLI and GitLab CI/CD.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 14.01: Adding CI/CD with GitLab to a Book Search App and Deploying
    to Amazon S3 and CloudFront'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's now take a fully built **book search** Vue.js application that loads data
    from the Google Books API and deploy it to S3/CloudFront using GitLab CI/CD. We
    will start by running the production build locally and checking the output. We
    will then switch to running the build and code quality steps (linting) on GitLab
    CI. Finally, we'll set up an S3 bucket and CloudFront distribution and integrate
    them with GitLab CI/CD to deploy on every push to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The start code for this activity can be found at `Chapter14/Activity14.01_initial`;
    we start with a `Chapter14/Activity14.01_solution`:'
  prefs: []
  type: TYPE_NORMAL
- en: To start, we will want to run a production build locally. We can use the regular
    command used to build all Vue CLI projects for production. We will also want to
    check that the relevant assets (JavaScript, CSS, and HTML) are generated correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We expect the `dist` folder to contain a similar structure, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.51: Sample contents of the dist folder (generated using the tree
    command)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: after a Vue CLI production build run
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_51.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.51: Sample contents of the dist folder (generated using the tree
    command) after a Vue CLI production build run'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In order to run GitLab CI/CD, we will need a `.gitlab-ci.yml` file. We will
    add a job to `.gitlab-ci.yml` in which we run an install of the packages followed
    by the production build in a Node.js LTS Docker container, at the `build` stage.
    We will also make sure to cache the output of the production build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we use `git add .gitlab-ci.yml` and commit and push the changes, we should
    see the following GitLab CI/CD pipeline run, which includes the `build` job while
    it is in the running state:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.52: The GitLab CI/CD pipeline with the build job running'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_52.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.52: The GitLab CI/CD pipeline with the build job running'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following screenshot, on the other hand, represents the GitLab CI/CD pipeline
    when the `build` job has completed and is in the `passed` state:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.53: GitLab CI/CD pipeline with the build job passed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_53.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.53: GitLab CI/CD pipeline with the build job passed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we will want to add a code quality job to the `test` stage on GitLab CI/CD
    (by updating `.gitlab-ci.yml`). We'll call the job `lint` and it will run an install
    of the dependencies as well as linting through the Vue CLI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we use `git add .gitlab-ci.yml` and commit and push the changes, we should
    see the following GitLab CI/CD pipeline run, which includes the `lint` job while
    it is in the running state:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.54: The GitLab CI/CD pipeline with the lint job running'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_54.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.54: The GitLab CI/CD pipeline with the lint job running'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following screenshot displays the GitLab CI/CD pipeline with the `lint`
    job successfully completed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.55: GitLab CI/CD pipeline with the lint job passed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_55.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.55: GitLab CI/CD pipeline with the lint job passed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In order to deploy our application, we'll need to create a `vue-workshop-book-search`
    S3 bucket with `public access` enabled using the S3 console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The S3 bucket creation page should look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.56: The S3 bucket creation page with vue-workshop-book-'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: search entered as the bucket name
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_56.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.56: The S3 bucket creation page with vue-workshop-book-search entered
    as the bucket name'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following screenshot displays the public access and disclaimer information
    on the S3 bucket creation page:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.57: The S3 bucket creation page with public access enabled'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and the relevant disclaimer accepted
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_57.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.57: The S3 bucket creation page with public access enabled and the
    relevant disclaimer accepted'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To access the S3 bucket contents over the web, we'll also need to configure
    it for web hosting. We can configure the web hosting property through the S3 console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It should be configured as follows, with the index and error page set to `index html`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.58: The S3 bucket properties page with web hosting enabled and
    configured with the index and error page set to index.html'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_58.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.58: The S3 bucket properties page with web hosting enabled and configured
    with the index and error page set to index.html'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For GitLab CI/CD to be able to create and update files on S3, we will need
    to add the relevant AWS secrets to our GitLab repo CI/CD settings. The secrets
    are found in the AWS management console at the `Username` dropdown | `My Security
    Credentials` | `Access keys` (access key ID and secret access key) | `Create New
    Access Key` (or pick a key to reuse). The following screenshot displays these
    details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.59: The GitLab CI/CD settings page with required the AWS environment'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: variables added (with values masked)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_59.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.59: The GitLab CI/CD settings page with required the AWS environment
    variables added (with values masked)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we will want to add a `deploy` job to the `deploy` stage on GitLab CI/CD
    (by updating `.gitlab-ci.yml`). We will call the job `deploy`; it will need to
    download the `awscli` `pip` package (Python package manager), which means the
    Docker image that makes the most sense is `python:latest`. The `deploy` job will
    load the built production build from cache, install `awscli` with `pip`, and run
    `aws s3 sync <build_directory> s3://<s3-bucket-name> --acl=public-read`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we use `git add .gitlab-ci.yml` and commit and push the changes, we should
    see the following GitLab CI/CD pipeline run, which includes the `deploy` job in
    the running state:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.60: The GitLab CI/CD pipeline with the deploy job running'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_60.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.60: The GitLab CI/CD pipeline with the deploy job running'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following screenshot displays the GitLab CI/CD pipeline with the `deploy`
    job completed successfully:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.61: The GitLab CI/CD pipeline with the deploy job passed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_61.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.61: The GitLab CI/CD pipeline with the deploy job passed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the pipeline completes, our application should be available through the
    `web` S3 endpoint as in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.62: Book search accessed through the S3 web endpoint URL'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_62.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.62: Book search accessed through the S3 web endpoint URL'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we''ll create a CloudFront distribution that acts as a CDN for the
    `web` S3 endpoint. We''ll want to set `origin` to the origin of our S3 bucket''s
    web endpoint and also make sure that we''ve enabled `Redirect HTTP to HTTPS`,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.63: The CloudFront distribution creation page, displaying the'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: origin and behavior settings
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_63.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.63: The CloudFront distribution creation page, displaying the origin
    and behavior settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the CloudFront distribution is deployed, our application should be accessible
    through the CloudFront distribution''s domain as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.64: Book search accessed through the CloudFront domain displaying'
  prefs: []
  type: TYPE_NORMAL
- en: results for a "harry potter" query
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_64.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.64: Book search accessed through the CloudFront domain displaying
    results for a "harry potter" query'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor412).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we've looked at how to introduce CI and CD practices
    to Vue.js projects in order to deploy to production safely and efficiently. We've
    seen how CI and CD are beneficial in the context of an agile delivery process.
    We used GitLab's CI/CD features to run tests, linting, and builds on every commit.
    We saw how to leverage Netlify to host a static website by connecting Netlify
    to our hosting provider. Finally, we looked at how to set up and deploy to AWS
    S3 and CloudFront.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, you have learned how to build, test, and deploy a Vue.js
    application that scales and performs for your team and your end users.
  prefs: []
  type: TYPE_NORMAL
