- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: MonoRepo Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单仓库架构
- en: When we think about building apps, we usually talk about an app, a `git` repository,
    and a build output. However, this configuration of an application and a repository
    does not always reflect the real-world experience of developers. Often organizations
    will use a single repository with all the applications, components, and libraries
    that could be used in common development. These are called a monorepository or
    single repository, and they are starting to become very popular.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们思考构建应用程序时，我们通常会谈论一个应用程序、一个`git`仓库和构建输出。然而，这种应用程序和仓库的配置并不总是反映开发者的实际体验。通常，组织会使用一个包含所有可能用于共同开发的程序、组件和库的单个仓库。这些被称为单仓库或单一仓库，并且它们正变得越来越受欢迎。
- en: So, what makes a monorepository interesting for organizations? Why put all the
    code in one place? Why not have a single `git` repository where you have many
    small and separate repositories? If we keep all our code in one project.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，是什么让单仓库对组织变得有趣？为什么要把所有代码放在一个地方？为什么不只有一个包含许多小型和独立仓库的单一`git`仓库？如果我们把所有代码都保存在一个项目中。
- en: By keeping all the code in one repository, you keep all dependencies up to date
    across the organization. This is probably the biggest benefit of a single repository.
    This way we will stop having to waste time updating all the dependencies of several
    different projects.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将所有代码保存在一个仓库中，你可以确保整个组织中的所有依赖项都保持最新。这可能是单仓库最大的好处。这样我们就可以停止浪费时间去更新几个不同项目的所有依赖项。
- en: In this chapter, we’ll be walking through how to create a monorepository with
    multiple packages using TypeScript, webpack, and NPM Workspaces.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过使用TypeScript、webpack和NPM Workspaces来创建包含多个包的单仓库进行讲解。
- en: 'We will look at the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨以下主题：
- en: Advantages of a monorepository and the problems it solves
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单仓库的优势及其解决的问题
- en: How to create a monorepository
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建单仓库
- en: Implementing TypeScript in the monorepository
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单仓库中实现TypeScript
- en: Creating a `devtools` package to compile other packages with Webpack
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`devtools`包以使用Webpack编译其他包
- en: Creating a `utils` package
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`utils`包
- en: How to create a multi-site system
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建多站系统
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will need the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，你需要以下内容：
- en: Node.js 19+
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 19+
- en: Visual Studio Code
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: 'You can find the code for this chapter in the book’s GitHub repository: [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter14](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter14).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的GitHub仓库中找到本章的代码：[https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter14](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter14)。
- en: Advantages of a monorepository and the problems it solves
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单仓库的优势及其解决的问题
- en: 'Some of the advantages of a **MonoRepo** (**monorepository**) are:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**MonoRepo**（单仓库）的一些优势包括：'
- en: '**Sharing is made easy**: With all the code in one place, it becomes easier
    to utilize the same code or tools across multiple projects, saving valuable time
    and effort.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享变得简单**：由于所有代码都在一个地方，利用相同的代码或工具跨多个项目变得更加容易，从而节省宝贵的时间和精力。'
- en: '**No mix-ups**: In a MonoRepo, every project utilizes the same version of shared
    components, eliminating concerns about compatibility issues between different
    versions.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免混淆**：在MonoRepo中，每个项目都使用共享组件的同一版本，消除了不同版本之间兼容性问题的担忧。'
- en: '**Change everything at once**: In a MonoRepo, making changes across all projects
    simultaneously becomes a straightforward task, as opposed to the complexity of
    managing individual projects in separate repositories.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一次性更改所有内容**：在单仓库（MonoRepo）中，同时跨所有项目进行更改变得简单直接，这与在单独的仓库中管理单个项目的复杂性形成对比。'
- en: '**Grouped changes**: Modifying multiple projects simultaneously within a MonoRepo
    ensures that all related components stay synchronized, allowing for efficient
    and cohesive updates.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分组更改**：在MonoRepo中同时修改多个项目确保所有相关组件保持同步，从而实现高效和连贯的更新。'
- en: '**Everyone can see everything**: With all the code centralized in one repository,
    all developers have access to it, fostering a better understanding of the entire
    system and facilitating effective collaboration.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**人人皆可看到一切**：由于所有代码都集中在一个仓库中，所有开发者都可以访问它，这有助于更好地理解整个系统，并促进有效的协作。'
- en: 'Now let’s explore some of the real-life problems that a MonoRepo solves:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来探讨一些MonoRepo解决的实际问题：
- en: '**Faster updates**: With a MonoRepo, you can update all projects at once. Without
    it, you’d have to update each project separately, which can take a lot of time.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新更快**：使用MonoRepo，你可以一次性更新所有项目。没有它，你将不得不单独更新每个项目，这可能会花费很多时间。'
- en: '**No more confusion**: Without a MonoRepo, different projects might use different
    versions of the same thing, which can cause problems. With a MonoRepo, everything
    uses the same version, so there’s no confusion.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不再混淆**：没有MonoRepo，不同的项目可能会使用相同事物的不同版本，这可能会引起问题。在MonoRepo中，所有东西都使用相同的版本，因此不会有混淆。'
- en: '**Better teamwork**: With all the code in one place, developers can easily
    see and understand what others have done. This can help them work together better.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的团队合作**：当所有代码都在一个地方时，开发者可以轻松地看到和理解其他人做了什么。这有助于他们更好地合作。'
- en: '**Easier start for newbies**: For new team members, it’s easier to get started
    when all the code is in one place. They can quickly understand the whole system,
    rather than having to search through different places.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新手更容易上手**：对于新团队成员来说，当所有代码都在一个地方时，开始工作会更容易。他们可以快速理解整个系统，而不是需要在不同地方搜索。'
- en: It is important to remember that MonoRepos may not always be the optimal choice.
    They can introduce their own challenges, such as potential performance issues
    and increased complexity when they become excessively large. Whether adopting
    a MonoRepo is a suitable approach depends on the specific needs of the team and
    the scale of their projects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，MonoRepos可能并不总是最佳选择。它们可能会引入自己的挑战，例如当它们变得过大时可能出现的性能问题和复杂性增加。是否采用MonoRepo取决于团队的具体需求和项目规模。
- en: 'In the following image you can see how the structure of a **MonoRepo** is different
    from that of a **Multi Repo**:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图像中，你可以看到**MonoRepo**的结构与**多仓库**的结构有何不同：
- en: '![A screenshot of a computer screen  Description automatically generated with
    low confidence](img/B18414_14_01.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述由低置信度自动生成](img/B18414_14_01.png)'
- en: 'Figure 14.1: MultiRepo vs MonoRepo'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1：多仓库与单仓库对比
- en: Now that we’ve shed light on the concept of a monorepository and explored why
    it is becoming increasingly popular for organizations, we will delve into the
    practical implementation of a monorepository using NPM Workspaces.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经阐明了单仓库的概念，并探讨了为什么它越来越受到组织的青睐，我们将深入探讨使用NPM Workspaces实现单仓库的实践方法。
- en: Creating a MonoRepo with NPM Workspaces
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NPM Workspaces创建MonoRepo
- en: '**NPM Workspaces** was introduced in NPM 7 and is a generic term that refers
    to the set of features in the npm CLI that provides support for managing multiple
    packages from your local filesystem, from within a singular top-level root package.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**NPM Workspaces**是在NPM 7中引入的，是一个通用术语，指的是npm CLI中提供支持管理本地文件系统中多个包的一组功能，这些包位于单个顶级根包内部。'
- en: 'The first thing you need to do in order to create a monorepository is to create
    a root `package.json` file, which should contain the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个单仓库，你需要首先创建一个根`package.json`文件，它应该包含以下代码：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will name our MonoRepo `web-creator`. We need to specify that `web-creator`
    will be private (only the root), and we need to specify the workspaces where our
    packages will live, which is on `"packages/*"`; the `*` means that we will include
    any directory that exists under the `packages` folder. After this, you need to
    create the packages directly.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将命名我们的MonoRepo为`web-creator`。我们需要指定`web-creator`将是私有的（只有根目录），并且我们需要指定我们的包将驻留的工作区，即`"packages/*"`；这里的`*`表示我们将包括`packages`文件夹下存在的任何目录。之后，你需要直接创建包。
- en: 'Let’s create two directories inside our new `packages` folder: `"packages/api"`
    and `"packages/frontend"`. Now go to your `api` project and run `npm init -y`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在新的`packages`文件夹内创建两个目录：`"packages/api"`和`"packages/frontend"`。现在转到你的`api`项目并运行`npm
    init -y`：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once you run that command it will create a `package.json` like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行该命令，它将创建一个`package.json`文件，如下所示：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, the name of that package by default will be `"api"`, but in
    order to connect that package to our main monorepository, we need to call it with
    a special format; in this case, you need to rename it `"@<name_of_root_package>/api"`,
    which in our example will be `"@web-creator/api"`. Your `package.json` should
    be like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，该包的默认名称将是`"api"`，但为了将此包连接到我们的主单一仓库，我们需要使用特殊格式调用它；在这种情况下，你需要将其重命名为`"@<name_of_root_package>/api"`，在我们的例子中将是`"@web-creator/api"`。你的`package.json`应该像这样：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now you need to create a file (`packages/api/index.js`) inside your `api` directory
    (later we will change this to TypeScript) with the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要在你的`api`目录（稍后我们将将其更改为TypeScript）中创建一个文件（`packages/api/index.js`），包含以下代码：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After this, you need to go to your `frontend` package (`packages/frontend`)
    and run the same `npm init -y` command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，你需要前往你的`frontend`包（`packages/frontend`）并运行相同的`npm init -y`命令：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Also, you will need to rename that package `@web-creator/frontend`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还需要重命名那个包`@web-creator/frontend`：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The monorepository now is ready to share packages. Let’s suppose you now want
    to consume your `api` package in your `frontend` package. To do this, you need
    to specify the `api` package as a dependency and put the same version we have
    in that `api` package; in this case, the version will be 1.0.0\. You need to be
    very careful and not change this version unless you really need to, and if you
    change it then you will need to update it on the `dependencies` node as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 单一仓库现在可以共享包了。假设你现在想在你的`frontend`包中消费你的`api`包。为此，你需要将`api`包指定为依赖项，并将该`api`包中的相同版本放入其中；在这种情况下，版本将是1.0.0。你需要非常小心，除非你真的需要，否则不要更改此版本，如果你更改了它，那么你还需要在`dependencies`节点上更新它。
- en: 'This will be your `package.json` from `packages/frontend`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是你的`packages/frontend`中的`package.json`：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After you’ve specified the `api` package as a dependency, you need to run `npm
    install` inside the frontend project. One very interesting thing you will notice
    is that even if you run the `npm install` command inside the `frontend` package
    (`packages/frontend`), your `node_modules` folder will be created at the root
    level, and it will look like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在你指定了`api`包作为依赖项之后，你需要在前端项目中运行`npm install`。你将注意到一个非常有趣的事情，即使你在`frontend`包（`packages/frontend`）内部运行`npm
    install`命令，你的`node_modules`文件夹也会在根级别创建，看起来像这样：
- en: '![](img/B18414_14_02.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18414_14_02.png)'
- en: 'Figure 14.2: Monorepo structure'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2：Monorepo结构
- en: 'If everything worked as expected, you can consume your `api` package in your
    `frontend` package. For this, you need to create an `index.js` file inside `packages/frontend/index.js`
    with the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按预期工作，你可以在你的`frontend`包中消费你的`api`包。为此，你需要在`packages/frontend/index.js`中创建一个`index.js`文件，包含以下代码：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now you can execute your index file with `node` and see the console message
    that comes from the `api` package:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用`node`执行你的索引文件，并看到来自`api`包的控制台消息：
- en: '![](img/B18414_14_03.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18414_14_03.png)'
- en: 'Figure 14.3: Running frontend'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3：运行前端
- en: 'One of the biggest advantages of a monorepository is that if you update your
    API `index.js`, the change will be reflected right away without you having to
    compile anything or publish any package to the NPM registry. This is very helpful
    and saves a lot of time for developers when coding large projects. Let’s change
    our message now to `I''m the API package UPDATED` in the `packages/api/index.js`
    and run the `index.js` again with `node`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 单一仓库最大的优点之一是，如果你更新了你的API `index.js`，变化将立即反映出来，无需你编译任何内容或发布任何包到NPM注册表。这对开发者在编码大型项目时非常有帮助。现在让我们将我们的消息更改为`I'm
    the API package UPDATED`在`packages/api/index.js`中，并再次使用`node`运行`index.js`：
- en: '![](img/B18414_14_04.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18414_14_04.png)'
- en: 'Figure 14.4: Updating the API'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4：更新API
- en: Congratulations, you have created your first MonoRepo successfully! In the next
    section, we will transform our MonoRepo to use TypeScript.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经成功创建了你的第一个MonoRepo！在下一节中，我们将把我们的MonoRepo转换为使用TypeScript。
- en: Implementing TypeScript in our MonoRepo
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的MonoRepo中实现TypeScript
- en: In the following sections, I will outline the steps to create a multi-site project.
    Due to the substantial amount of code involved, I’m unable to include it all in
    this book. However, I invite you to review the complete code in the repository
    available at [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter14/web-creator](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter14/web-creator).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将概述创建多站点的项目的步骤。由于涉及的代码量很大，我无法将所有内容都包含在这本书中。然而，我邀请您查看在 [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter14/web-creator](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter14/web-creator)
    可用的存储库中的完整代码。
- en: 'The first thing you need to do in order to add TypeScript to your project is
    to install the `typescript` package at the root level:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 TypeScript 添加到你的项目中，你需要将 `typescript` 包安装到根级别：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After this, you need to create the `tsconfig.json` file at the root level as
    well with the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你还需要在根级别创建 `tsconfig.json` 文件，代码如下：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, we extend the `tsconfig.json` file to `tsconfig.common.json`,
    and this is because we don’t want to to repeat each package that we want to transform
    to TypeScript. The only `compilerOptions` we want to specify is the `baseUrl`
    on our `packages` directory, and in the paths we will specify the name of our
    MonoRepo to be able to do imports in the code. This is the `tsconfig.common.json`
    file that you need to create:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将 `tsconfig.json` 文件扩展到 `tsconfig.common.json`，这是因为我们不希望重复每个我们想要转换为 TypeScript
    的包。我们想要指定的唯一的 `compilerOptions` 是 `packages` 目录上的 `baseUrl`，在路径中我们将指定我们的 MonoRepo
    的名称，以便能够在代码中进行导入。这是你需要创建的 `tsconfig.common.json` 文件：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The architecture of our project will look like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的架构将看起来像这样：
- en: '![Chart, bubble chart  Description automatically generated](img/B18414_14_05.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图表，气泡图  自动生成的描述](img/B18414_14_05.png)'
- en: 'Figure 14.5: Web creator architecture'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5：Web 创建器架构
- en: Now that we have explored the project’s architecture, let’s dive into the first
    package that will manage our Webpack configurations. This package will be referred
    to as `devtools`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了项目的架构，让我们深入了解第一个将管理我们的 Webpack 配置的包。这个包将被称为 `devtools`。
- en: Creating a devtools package to compile packages with Webpack
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个用于使用 Webpack 编译包的 devtools 包
- en: 'The first package we need to create to be able to compile other packages is
    called `devtools` and should be created in `packages/devtools`. Let’s see how
    it should look in its `package.json` file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的第一个包，以便能够编译其他包，称为 `devtools`，应该创建在 `packages/devtools` 中。让我们看看它在 `package.json`
    文件中应该是什么样子：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After you create the `package.json`, you need to create the `tsconfig.json`
    file for `devtools`. Each package will have its own `tsconfig.json` file. Basically
    we will extend our `tsconfig.common.json` from root and just specify the `outDir`
    and include the files inside the `src` folder:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `package.json` 之后，你需要为 `devtools` 创建 `tsconfig.json` 文件。每个包都将有自己的 `tsconfig.json`
    文件。基本上，我们将从根目录扩展我们的 `tsconfig.common.json`，并指定 `outDir` 并包含 `src` 文件夹内的文件：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Creating a colorful log
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个彩色的日志
- en: 'We need to create a log function that will help us highlight the Webpack configuration
    that we will implement, and for this we will use the `cli-color` package, which
    adds colors to the logs. You need to create the file under `packages/devtools/src/cli/log.ts`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个日志函数，这将帮助我们突出显示我们将要实现的 Webpack 配置，为此我们将使用 `cli-color` 包，该包为日志添加颜色。你需要创建位于
    `packages/devtools/src/cli/log.ts` 下的文件：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Webpack common configuration
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Webpack 通用配置
- en: 'Now that we have our log function ready, we will continue creating the Webpack
    configuration. We will break our Webpack configuration into three files: `webpack.common.ts`,
    `webpack.development.ts`, and `webpack.production.ts`. The common configuration
    will be merged with the development and production separately. However, before
    creating our common configuration, we need to create our Webpack types, and you
    need to add this file to `packages/devtools/src/webpack/webpack.types.ts`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了日志函数，我们将继续创建 Webpack 配置。我们将把 Webpack 配置分成三个文件：`webpack.common.ts`、`webpack.development.ts`
    和 `webpack.production.ts`。通用配置将与开发和生产分别合并。然而，在创建我们的通用配置之前，我们需要创建我们的 Webpack 类型，并且你需要将此文件添加到
    `packages/devtools/src/webpack/webpack.types.ts`：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now let’s create our `webpack.common.ts` file, starting with the packages we
    need to import:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建我们的 `webpack.common.ts` 文件，从我们需要导入的包开始：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next we need to create the `getWebpackCommonConfig` function, which will receive
    arguments from the terminal to compile each package via the NPM script:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建`getWebpackCommonConfig`函数，它将接收来自终端的参数来通过NPM脚本来编译每个包：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The blocks of code that you will see next from this chapter’s GitHub repository
    need to be added where the comment is located in the previous code: `// Here goes
    the next block of codes`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章的GitHub仓库中，您将看到的代码块需要添加到前一个代码中的注释位置：`// 这里是下一个代码块`。
- en: 'First let’s check if we are running a sandbox (this will be for our design-system
    package). If yes, we will use port `8080`, and if not, we will use the `port +
    1` (`3001`by default):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们检查我们是否正在运行沙盒（这将是我们的设计系统包）。如果是，我们将使用端口`8080`，如果不是，我们将使用`port + 1`（默认为`3001`）：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first configuration option we need to create is `entry`, which will define
    the index file that we will use to compile our project, based on the `packageName`
    we specify in our script. We can create `entry` by running the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的第一个配置选项是`entry`，它将定义我们将用于编译项目的索引文件，基于我们在脚本中指定的`packageName`。我们可以通过运行以下代码来创建`entry`：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When our `configType` is `"package"` (or different than `'web'`), we will specify
    the `index.ts` as `entry`, and for the web packages, we will use `index.tsx`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的`configType`是`"package"`（或不同于`'web'`）时，我们将指定`index.ts`作为入口，而对于网络包，我们将使用`index.tsx`。
- en: 'The second configuration option we need to create is going to be the `resolve`
    node, which will include the extensions we want to support and the alias for each
    package (`~`). In Webpack 5, we must turn off some fallback packages that are
    not enabled by default anymore:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的第二个配置选项将是`resolve`节点，它将包括我们想要支持的扩展和每个包的别名（`~`）。在Webpack 5中，我们必须关闭一些默认未启用的回退包：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The third configuration option is the `output`, which will specify where we
    will place the compiled project (the `dist` directory), which will be the dynamic
    filename (`[name].js`). If we want to compile a package, we will add the necessary
    options to be able to export that package (`libraryTarget`, `library`, `umdNamedDefine`,
    and `globalObject`):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个配置选项是`output`，它将指定我们将放置编译后的项目的地方（`dist`目录），这将是一个动态的文件名（`[name].js`）。如果我们想要编译一个包，我们将添加必要的选项来能够导出该包（`libraryTarget`、`library`、`umdNamedDefine`和`globalObject`）：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The fourth configuration option is the `plugins`, which will be applied based
    on some conditions, depending on if we want to analyze our bundle sizes (`BundleAnalyzerPlugin`)
    and add a template with `HtmlWebPackPlugin`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个配置选项是`plugins`，它将根据某些条件应用，取决于我们是否想要分析我们的包大小（`BundleAnalyzerPlugin`）并添加带有`HtmlWebPackPlugin`的模板：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The fifth configuration option is the `rules`, which we will define depending
    on the extension file we want to process. We will also use Webpack loaders like
    `ts-loader` to load TypeScript files or `svg-url-loader` and `@svgr/webpack` to
    load SVG files:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第五个配置选项是`rules`，我们将根据我们想要处理的扩展文件来定义。我们还将使用Webpack加载器，如`ts-loader`来加载TypeScript文件或`svg-url-loader`和`@svgr/webpack`来加载SVG文件：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we put all the options together in the `webpackConfig` object:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将所有选项一起放入`webpackConfig`对象中：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Webpack development configuration
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Webpack开发配置
- en: 'After creating our Webpack common configuration file, we now need to create
    our `webpack.development.ts` file, which is way smaller than the common one and
    will extend that configuration (on `webpack.config.ts`), specifying the development
    mode for Webpack, adding the source map, and passing the `HMR` plugin:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的Webpack通用配置文件后，我们现在需要创建我们的`webpack.development.ts`文件，这个文件比通用文件小得多，并将扩展该配置（在`webpack.config.ts`上），指定Webpack的开发模式，添加源映射，并传递`HMR`插件：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Webpack production configuration
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Webpack生产配置
- en: 'The last file we need to create is the `webpack.production.ts`, which will
    will use external libraries when we try to compile a package that uses shared
    libraries like **React**, **Apollo Server**, or **JSON Web Tokens**, put the `mode`
    as production, and disable the source map:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的最后一个文件是`webpack.production.ts`，当我们尝试编译使用共享库（如**React**、**Apollo Server**或**JSON
    Web Tokens**）的包时，将使用外部库，将`mode`设置为生产模式，并禁用源映射：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'That’s all for our `devtools` package. Now we only need to create the `index.ts`
    file in `packages/devtools/src/index.ts` to export all the Webpack configuration
    and be able to compile our `devtools` package:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的`devtools`包的全部内容。现在我们只需要在`packages/devtools/src/index.ts`中创建`index.ts`文件来导出所有Webpack配置，并能够编译我们的`devtools`包：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Since this will be the base package that will compile other packages, first
    we need to build it, and for this, we will just use the `tsc` command to transform
    TypeScript into JavaScript files. For this, you just need to run the `build` command
    inside `packages/devtools`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这将是一个将编译其他包的基础包，首先我们需要构建它，为此，我们只需在 `packages/devtools` 内运行 `build` 命令即可将 TypeScript
    转换为 JavaScript 文件。
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If everything is correct, you should see something like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正确，你应该会看到类似这样的内容：
- en: '![Text  Description automatically generated](img/B18414_14_06.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18414_14_06.png)'
- en: 'Figure 14.6: npm run build'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6：npm run build
- en: 'Finally, we need to create the `webpack.config.ts` file at the root level where
    we will consume our brand-new `devtools` package and merge the configurations
    (development + common or production + common) using `webpack-merge`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在根级别创建 `webpack.config.ts` 文件，在那里我们将使用我们的全新 `devtools` 包并使用 `webpack-merge`
    合并配置（开发 + 公共或生产 + 公共）：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Creating the utils package
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 utils 包
- en: After we’ve created the `devtools` package, it is time to add a basic `utils`
    package to test the Webpack compilation with `devtools`. For this, you will need
    to create a directory at `packages/utils`. For the example in the book, we will
    just add one `util` file to test our `devtools`, but in the actual repository
    you will find way more `util` files that have been added to the project.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建了 `devtools` 包之后，是时候添加一个基本的 `utils` 包来测试使用 `devtools` 的 Webpack 编译了。为此，你需要在
    `packages/utils` 创建一个目录。对于书中的示例，我们只需添加一个 `util` 文件来测试我们的 `devtools`，但在实际的仓库中，你会找到更多已经添加到项目中的
    `util` 文件。
- en: 'As always let’s start creating our `package.json` in the `utils` package:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，让我们从 `utils` 包中创建 `package.json` 开始：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There are some important elements in this `package.json` that I want to mention:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `package.json` 文件中，有一些重要的元素我想提一下：
- en: The first one is the name of the package, which is `@web-creator/utils`. As
    I mentioned before, this is the correct format to name packages inside our MonoRepo.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一项是包的名称，它是 `@web-creator/utils`。正如我之前提到的，这是在 MonoRepo 内部命名包的正确格式。
- en: The second node is `version`, which always will be `1.0.0` (unless you want
    to publish this package to the NPM registry; for now you don’t need to worry about
    that).
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个节点是 `version`，它始终将是 `1.0.0`（除非你想将这个包发布到 NPM 注册表；现在你不需要担心这个问题）。
- en: '`main` is to specify where our `utils` code will exist, which will always be
    in `dist/index.js`.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main` 是指定我们的 `utils` 代码将存在的地方，它将始终在 `dist/index.js`。'
- en: The `types` node is to be able to load our TypeScript types; if you don’t specify
    this, it won’t be possible to see the types you add to your `utils` package when
    you consume this package.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`types` 节是为了能够加载我们的 TypeScript 类型；如果你不指定这个，那么在消费这个包时，你将无法看到添加到你的 `utils` 包中的类型。'
- en: Finally the `files` node is an array that will contain the `dist` directory
    that will contain the compiled package.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`files` 节是一个数组，它将包含包含编译后包的 `dist` 目录。
- en: Additionally, the scripts have some interesting things that you should know.
    Our `build` command will run multiple scripts using `npm-run-all`, which is a
    library that helps us run multiple scripts one after the other. In this case,
    we always execute the script `clean` first to remove our `dist` folder and start
    fresh. Then we `compile` the code with TypeScript (`tsc`), then we execute `webpack:production`.
    This will execute `webpack`, specifying the configuration file that exists at
    the root (two levels behind). We also use the `--env` flag to pass values as variables.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，脚本还有一些有趣的事情你应该知道。我们的 `build` 命令将使用 `npm-run-all` 运行多个脚本，这是一个帮助我们依次运行多个脚本的库。在这种情况下，我们总是首先执行
    `clean` 脚本来删除我们的 `dist` 文件夹并从头开始。然后我们使用 TypeScript (`tsc`) 编译代码，然后执行 `webpack:production`。这将执行
    `webpack`，指定根目录中存在的配置文件（在两个级别之后）。我们还使用 `--env` 标志来传递变量。
- en: These variables are defined in our `webpack.config.ts` file. In this case, we’re
    passing `mode=production`, `type=package`, and `packageName=utils`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量定义在我们的 `webpack.config.ts` 文件中。在这种情况下，我们传递 `mode=production`、`type=package`
    和 `packageName=utils`。
- en: If you notice, some scripts contain `npm run --prefix ../../`, and I’m pretty
    sure you are wondering what exactly the `--prefix` flag is in this command. It
    is essentially a way to tell NPM that we want to run a script from a different
    `package.json`. In this specific example, we are going back two levels to run
    the script `lint` that exists in our root `package.json`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注意到，一些脚本包含`npm run --prefix ../../`，我非常确信您想知道这个命令中的`--prefix`标志究竟是什么。它本质上是一种告诉NPM我们想要从一个不同的`package.json`中运行脚本的方法。在这个特定的例子中，我们返回两级以运行存在于我们根`package.json`中的`lint`脚本。
- en: 'Now let’s create our first `util` file, which is going to be called `is.ts`,
    and you must save it in `packages/utils/src/utils/is.ts` with the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的第一个`util`文件，它将被命名为`is.ts`，并且您必须将其保存到`packages/utils/src/utils/is.ts`，以下代码如下：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After you create this `util`, you need to create the `index.ts` file in `packages/utils/src/index.ts`,
    where you will export all your `utils`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在您创建这个`util`之后，您需要在`packages/utils/src/index.ts`中创建一个`index.ts`文件，在那里您将导出所有的`utils`：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, you must add a script to your root `package.json` to be able to compile
    your brand-new `utils` package. Here is how your root `package.json` file should
    look:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您必须向根`package.json`添加一个脚本，以便能够编译您全新的`utils`包。以下是您的根`package.json`文件应该看起来像这样：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, we need to add a `build:package_name`(in this case,`build:utils`)
    script for each package that we want to build, and then our build script will
    execute all of them using `npm-run-all build:*`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们需要为每个我们想要构建的包添加一个`build:package_name`（在这个例子中，`build:utils`）脚本，然后我们的构建脚本将使用`npm-run-all
    build:*`执行所有这些脚本。
- en: 'Now you can build your `utils` package by running the `npm run build` script
    inside the `utils` directory; you should see something like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以通过在`utils`目录中运行`npm run build`脚本来构建您的`utils`包；您应该看到类似以下的内容：
- en: '![Text  Description automatically generated](img/B18414_14_07.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18414_14_07.png)'
- en: 'Figure 14.7: Building utils'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7：构建utils
- en: 'Following this, you should see the Webpack configuration log that we use to
    compile this package:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，您应该看到我们用于编译此包的Webpack配置日志：
- en: '![Text, timeline  Description automatically generated](img/B18414_14_08.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![文本，时间线描述自动生成](img/B18414_14_08.png)'
- en: 'Figure 14.8: Webpack configuration'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8：Webpack配置
- en: 'Then at the end, you will see the compiled files by Webpack:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在最后，您将看到Webpack编译的文件：
- en: '![Text  Description automatically generated](img/B18414_14_09.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18414_14_09.png)'
- en: 'Figure 14.9: Compiled files by Webpack'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9：Webpack编译的文件
- en: Now that we have created our first package, which is compiled with `devtools`,
    and understand the structure of a package, it’s time to start working on our API.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的第一个包，它是用`devtools`编译的，并且我们了解了包的结构，现在是时候开始处理我们的API了。
- en: Creating the API package
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建API包
- en: 'In this package, we will implement a multi-service system that will help us
    have more than one service to connect to multiple databases. Let’s see how our
    `package.json` file should look for the `api` package:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个包中，我们将实现一个多服务系统，这将帮助我们连接到多个数据库。让我们看看我们的`package.json`文件对于`api`包应该看起来像什么：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this case, we will use Sequelize (an ORM) and PostgreSQL for the database,
    but feel free to use MySQL or any other type of database supported by Sequelize.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用Sequelize（一个ORM）和PostgreSQL作为数据库，但请随意使用MySQL或其他Sequelize支持的数据库类型。
- en: In the following sections, we’ll guide you through each of these steps in detail.
    We’ll demonstrate how to integrate all the components and successfully operate
    your CRM service. If it appears complex, there’s no need to worry. We’ll proceed
    at a steady pace and provide explanations along the way.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将详细介绍每个步骤。我们将演示如何集成所有组件并成功运行您的CRM服务。如果它看起来很复杂，无需担心。我们将以稳定的速度进行，并在过程中提供解释。
- en: Creating a user-shared model
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户共享模型
- en: The first thing we need to create is our shared model, which for now will be
    only the `User` model, to be able to create a shared authentication system for
    all our sites.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先创建的是我们的共享模型，目前这将是唯一的`User`模型，以便能够为所有我们的网站创建一个共享的身份验证系统。
- en: 'You must create the `User` model file in `packages/models/User.ts`, which will
    create a table with the following fields: `id` (`UUID`), `username` (`STRING)`,
    `password` (`STRING`), `Email` (`STRING`), `Role` (`STRING`), and `active` (`BOOLEAN`):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须在`packages/models/User.ts`中创建`User`模型文件，这将创建一个包含以下字段的表：`id`（`UUID`），`username`（`STRING`），`password`（`STRING`），`Email`（`STRING`），`Role`（`STRING`），和`active`（`BOOLEAN`）：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Creating a user-shared GraphQL type and resolver
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个用户共享的GraphQL类型和解析器
- en: Besides the `User`-shared model, we need to create a shared GraphQL **type**
    and **resolver**, in order to handle the authentication using GraphQL on all our
    sites.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`User`共享模型外，我们还需要创建一个共享的GraphQL **类型**和**解析器**，以便在所有我们的网站上使用GraphQL处理认证。
- en: 'First we need to create another shared GraphQL type called `error`, which will
    help us handle errors on any of the queries or mutations we will create later.
    This file exists in `packages/api/src/graphql/types/Error.ts`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建另一个共享的GraphQL类型，称为`error`，它将帮助我们处理我们稍后创建的任何查询或突变中的错误。此文件位于`packages/api/src/graphql/types/Error.ts`中：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Another shared type that we need to create is the scalar one, which will define
    scalar types like `UUID`, `Datetime`, and `JSON`. This file exists in `packages/api/src/graphql/types/Scalar.ts`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的另一个共享类型是标量类型，它将定义标量类型如`UUID`、`Datetime`和`JSON`。此文件位于`packages/api/src/graphql/types/Scalar.ts`中：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, we need to create our `User` type, which will include some queries
    to get a specific user via an access token (`at`), get all users, and get some
    mutations to create a new user and also to log in. This file should be placed
    in `packages/api/src/graphql/types/User.ts`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建我们的`User`类型，它将包括一些查询，通过访问令牌（`at`）获取特定用户，获取所有用户，以及一些突变来创建新用户和登录。此文件应放置在`packages/api/src/graphql/types/User.ts`中：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After you create the preceding types, you need to create the user resolver.
    For this we will use the `authentication` package (please check the code at [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter14/web-creator/packages/authentication](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter14/web-creator/packages/authentication)).
    Do you remember the authentication system we created in *Chapter 13*? It is the
    same code, but now it will have its own package. This resolver should be created
    in `packages/api/src/graphql/resolvers/user.ts`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建前面的类型之后，您需要创建用户解析器。为此，我们将使用`authentication`包（请检查[https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter14/web-creator/packages/authentication](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter14/web-creator/packages/authentication)中的代码）。您还记得我们在*第13章*中创建的认证系统吗？这是相同的代码，但现在它将拥有自己的包。这个解析器应该在`packages/api/src/graphql/resolvers/user.ts`中创建：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Creating custom services
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义服务
- en: Now it is time to create our custom services; for this we will create one default
    service (just to have an empty service) and one for a **CRM** project (it will
    be called `crm`).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建我们的自定义服务了；为此，我们将创建一个默认服务（只是为了有一个空的服务）和一个用于**CRM**项目的服务（它将被命名为`crm`）。
- en: 'The first thing we need to do is to create our service configuration, and for
    this we will create some types that will help us to be very strict in the options
    that our configuration will receive. This file needs to be created in `packages/api/src/types/config.ts`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建我们的服务配置，为此我们将创建一些类型，这将帮助我们非常严格地限制我们的配置将接收的选项。此文件需要创建在`packages/api/src/types/config.ts`中：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Our default configuration should be like this (`packages/api/src/services/default/config.ts`):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们默认的配置应该是这样的（`packages/api/src/services/default/config.ts`）：
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After that let’s create our CRM configuration (custom service). This should
    be placed in `packages/api/src/services/crm/config.ts`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们创建我们的CRM配置（自定义服务）。这应该放置在`packages/api/src/services/crm/config.ts`中：
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'I’m pretty sure you’re wondering where the other options of the database node
    (`engine`, `port`, `host`, `username`, and `password`) are. Those will be overwritten
    in the main config file that we will create later, but those values will be grabbed
    from our `.env` file (you must rename the `.env.example` file). Hence, let’s create
    that file in `packages/api/.env`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我很确定您想知道数据库节点（`engine`、`port`、`host`、`username`和`password`）的其他选项在哪里。这些将在稍后创建的主要配置文件中被覆盖，但那些值将从我们的`.env`文件中获取（您必须重命名`.env.example`文件）。因此，让我们在`packages/api/.env`中创建该文件：
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Building our service configuration
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建我们的服务配置
- en: 'Now that we have our custom service (**CRM**) ready, let’s build our configuration.
    For this you need to create the config file in `packages/api/src/config.ts`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了自定义服务（**CRM**），让我们构建我们的配置。为此，您需要在`packages/api/src/config.ts`中创建配置文件：
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Creating our custom models
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的自定义模型
- en: 'Once we’ve created the configuration correctly, we need to create our custom
    models for our CRM service, which are created specifically for that service, and
    they will not be shared with other services. In this case, we will add just one
    and call it `Guest`. This model needs to be saved in `packages/api/src/services/crm/models/Guest.ts`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们正确创建了配置，我们需要创建我们的CRM服务的自定义模型，这些模型是专门为该服务创建的，并且它们将不会与其他服务共享。在这种情况下，我们将添加一个，并称之为`Guest`。这个模型需要保存在`packages/api/src/services/crm/models/Guest.ts`：
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After we create the `Guest` model, we need to connect to our database and join
    our global models (`User`) and our local models (`Guest`) in order to create our
    service tables. This file needs to be created in `packages/api/src/services/crm/models/index.ts`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建`Guest`模型后，我们需要连接到我们的数据库并将我们的全局模型（`User`）和本地模型（`Guest`）连接起来，以便创建我们的服务表。这个文件需要创建在`packages/api/src/services/crm/models/index.ts`：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Creating model seeds
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模型种子
- en: 'Seeds are the initial data for our models (tables). Most of the time we want
    to clear all the model values but keep some of them as default values, but in
    this case we will add some default data for our `User` model and our `Guest` model:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 种子是我们模型（表）的初始数据。大多数时候，我们希望清除所有模型值但保留一些默认值，但在这个例子中，我们将为我们的`User`模型和`Guest`模型添加一些默认数据：
- en: '[PRE47]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Creating our custom GraphQL types and resolvers
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的自定义GraphQL类型和解析器
- en: 'For our CRM, we will create a `Guest` type and resolver just to illustrate
    how we can use GraphQL in different services that we create; the first file you
    need to create is the `Guest` type, which must be saved in `packages/api/src/services/crm/graphql/types/Guest.ts`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的CRM，我们将创建一个`Guest`类型和解析器，只是为了说明我们如何在创建的不同服务中使用GraphQL；您需要创建的第一个文件是`Guest`类型，它必须保存在`packages/api/src/services/crm/graphql/types/Guest.ts`：
- en: '[PRE48]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, we define our `Guest` type with some personal fields such as
    `fullName`, `email`, `photo`, etc. Then we create a `GuestResponse` type that
    represents an array of guests `([Guest!]!`). The square brackets indicate that
    it’s an array, and the exclamation mark (`!`) denotes that it cannot contain `null`
    values. After that, we create a `union` type, which enables the `schema` field
    to return one of multiple object types. In this case, it can return `GuestResponse`
    when we have guests or the `Error` type if we don’t have guests or encounter any
    other issues. If something else occurs, we define the response of these types
    in our resolver.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用一些个人字段如`fullName`、`email`、`photo`等定义了我们的`Guest`类型。然后我们创建了一个`GuestResponse`类型，它代表一个客人数组`([Guest!]!)`。方括号表示这是一个数组，感叹号（`!`）表示它不能包含`null`值。之后，我们创建了一个`union`类型，这使得`schema`字段可以返回多个对象类型中的一个。在这种情况下，当有客人时，它可以返回`GuestResponse`类型，如果没有客人或遇到任何其他问题，则返回`Error`类型。如果发生其他情况，我们在解析器中定义这些类型的响应。
- en: 'After you create this type file (or more), it is time to merge all your **Type
    Definitions** (**TypeDefs**). For this, we will create an `index.ts` file inside
    our `types` directory and import our global types (`Error`, `Scalar`, and `User`).
    We will also include our local type (`Guest`) and merge it with a function provided
    by `@graphql-tools/merge`. This file is placed in `packages/api/src/services/crm/types/index.ts`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在您创建了这个类型文件（或更多）之后，是时候合并您所有的**类型定义**（**TypeDefs**）了。为此，我们将在`types`目录内创建一个`index.ts`文件，并导入我们的全局类型（`Error`、`Scalar`和`User`）。我们还将包括我们的本地类型（`Guest`），并使用`@graphql-tools/merge`提供的函数将其合并。这个文件放在`packages/api/src/services/crm/types/index.ts`：
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now once you have merged your types, you need to create the `Guest` resolver.
    This file should be placed in `packages/api/src/services/crm/graphql/resolvers/guest.ts`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一旦您合并了您的类型，您需要创建`Guest`解析器。这个文件应该放在`packages/api/src/services/crm/graphql/resolvers/guest.ts`：
- en: '[PRE50]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you can see, when we find guests (or data), we return them and add the `__typename`
    property (which is a GraphQL property) with a value of `GuestResponse`. This property
    is necessary to resolve the query with the correct type, since we are using a
    union. Here is where we define what we will return, whether it’s the `GuestResponse`
    type or the `Error` type. On the other hand, if we don’t find any guests, we return
    an error object with a code and message, and the `__typename` is set to `'Error'`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当我们找到客人（或数据）时，我们返回它们并添加一个`__typename`属性（这是一个GraphQL属性），其值为`GuestResponse`。由于我们使用的是`union`，这个属性对于正确解析查询是必要的。在这里，我们定义我们将返回的内容，无论是`GuestResponse`类型还是`Error`类型。另一方面，如果我们没有找到任何客人，我们返回一个包含代码和消息的错误对象，并将`__typename`设置为`'Error'`。
- en: 'Now, we need to do the same with the resolvers. We need to merge our resolvers,
    both the global ones and the local ones. To do this, create an `index.ts` file
    in the same `resolvers` directory and add the following code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要对解析器做同样的事情。我们需要合并我们的解析器，包括全局解析器和本地解析器。为此，在相同的`resolvers`目录中创建一个`index.ts`文件，并添加以下代码：
- en: '[PRE51]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We have done a similar thing with our resolvers as we did with the `TypeDef`.
    Now, we need to import the global user resolver and merge it with our guest resolver.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经像对`TypeDef`所做的那样对解析器做了类似的事情。现在，我们需要导入全局用户解析器并将其与我们的客人解析器合并。
- en: Synchronizing our models and starting Apollo Server
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步我们的模型并启动Apollo Server
- en: 'Now that we have created our custom `configs`, `models`, `seeds`, `types`,
    and `resolvers`, it’s time to put everything together, synchronize our models,
    and start our Apollo Server. This file should be placed in `packages/api/src/index.ts`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了自定义的`configs`、`models`、`seeds`、`types`和`resolvers`，是时候将所有这些放在一起，同步我们的模型，并启动我们的Apollo
    Server。此文件应放置在`packages/api/src/index.ts`：
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'After importing all the packages we need, first we need to check if we received
    the `SERVICE` variable from the terminal; otherwise, we will choose our default
    service. We will also check if our service is valid (exists in our `Service` type):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入所有需要的包之后，首先我们需要检查是否从终端收到了`SERVICE`变量；如果没有，我们将选择默认服务。我们还将检查我们的服务是否有效（存在于我们的`Service`类型中）：
- en: '[PRE53]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once we are sure that our service is valid, then we will dynamically import
    the `resolvers`, `types`, `models`, and `seeds`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确认我们的服务是有效的，然后我们将动态导入`resolvers`、`types`、`models`和`seeds`：
- en: '[PRE54]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then we create our Express app and configure `cors`, `cookieParser`, and `bodyParser`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建我们的Express应用并配置`cors`、`cookieParser`和`bodyParser`：
- en: '[PRE55]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We need to create our GraphQL schema with `makeExecutableSchema` and use the
    `applyMiddleware`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`makeExecutableSchema`创建我们的GraphQL模式，并使用`applyMiddleware`：
- en: '[PRE56]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Finally, we create our `ApolloServer` instance passing the schema and the plugins.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建我们的`ApolloServer`实例，传递模式和插件。
- en: '[PRE57]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now we need to sync our models. The `alter` option enables us to listen to
    changes in our models and modify them:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要同步我们的模型。`alter`选项使我们能够监听模型的变化并修改它们：
- en: If you change something, BE VERY CAREFUL with the `force` option. If it is `true`,
    it will truncate all your tables (meaning all your data will be deleted). Hence,
    only use it when totally necessary.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更改了某些内容，请务必小心使用`force`选项。如果它是`true`，它将截断所有您的表（这意味着所有数据都将被删除）。因此，只有在绝对必要时才使用它。
- en: '[PRE58]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Testing our CRM service
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们的CRM服务
- en: 'If you did everything correctly, you can run the command `SERVICE=crm npm run
    dev` inside your `api` package. and you should see something like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一切操作正确，您可以在`api`包内部运行命令`SERVICE=crm npm run dev`，您应该会看到类似以下的内容：
- en: '![Text  Description automatically generated](img/B18414_14_10.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B18414_14_10.png)'
- en: 'Figure 14.10: SERVICE=crm npm run dev'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10：SERVICE=crm npm run dev
- en: 'If you check your database, you will see the two tables created from your models
    (`Guests` and `Users`), and you should be able to see the seeds you added as well:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查您的数据库，您将看到从您的模型创建的两个表（`Guests`和`Users`），您应该能够看到您添加的种子：
- en: '![Graphical user interface, application, email  Description automatically generated](img/B18414_14_11.a.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，电子邮件描述自动生成](img/B18414_14_11.a.png)'
- en: '![Graphical user interface, application, email  Description automatically generated](img/B18414_14_11.b.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，电子邮件描述自动生成](img/B18414_14_11.b.png)'
- en: 'Figure 14.11: Database query'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11：数据库查询
- en: As you can see, the `createdAt` and `updatedAt` fields are automatically created
    by Sequelize. After this, you can try to hit [http://localhost:4000/graphql](http://localhost:4000/graphql)
    to see if your Apollo Server works fine.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`createdAt`和`updatedAt`字段是由Sequelize自动创建的。在此之后，您可以尝试访问[http://localhost:4000/graphql](http://localhost:4000/graphql)以查看您的Apollo
    Server是否运行正常。
- en: '![Graphical user interface, application, website  Description automatically
    generated](img/B18414_14_12.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，网站描述自动生成](img/B18414_14_12.png)'
- en: 'Figure 14.12: GraphQL Explorer'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.12：GraphQL探索器
- en: 'We can start testing our service queries like `getGuests`; let’s see what it
    returns:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以开始测试我们的服务查询，例如`getGuests`；让我们看看它返回什么：
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_14_13.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本描述自动生成](img/B18414_14_13.png)'
- en: 'Figure 14.13: getGuests query'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.13：getGuests查询
- en: 'Also, you can test the `getUsers` query:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以测试`getUsers`查询：
- en: '![Graphical user interface, application, Teams  Description automatically generated](img/B18414_14_14.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，团队描述自动生成](img/B18414_14_14.png)'
- en: 'Figure 14.14: getUsers query'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.14：获取用户查询
- en: 'Finally, you can also test the `login` mutation to make sure your global authentication
    system works fine:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您还可以测试 `登录` 突变，以确保您的全局认证系统运行良好：
- en: '![Graphical user interface, application, Teams  Description automatically generated](img/B18414_14_15.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，团队描述自动生成](img/B18414_14_15.png)'
- en: 'Figure 14.15: The login mutation'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.15：登录突变
- en: Creating the frontend package
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建前端包
- en: In this package, we will implement a multi-site system that will help us have
    more than one site with the same code base.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个包中，我们将实现一个多站点系统，这将帮助我们拥有多个具有相同代码库的站点。
- en: 'Let’s see how our `package.json` file should look for this package:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个包的 `package.json` 文件应该是什么样子：
- en: '[PRE59]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Our `frontend` package works a little bit differently from our other packages
    because we use **Next.js**, which takes care of its own Webpack configuration.
    We do not compile it using our `devtools` like the other packages, and the TypeScript
    configuration differs slightly.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `前端` 包与其他包的工作方式略有不同，因为我们使用 **Next.js**，它负责自己的 Webpack 配置。我们不使用我们的 `devtools`
    编译它，就像其他包一样，TypeScript 配置也有细微差别。
- en: 'This is the `tsconfig.json` file for our `frontend` package:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的 `前端` 包的 `tsconfig.json` 文件：
- en: '[PRE60]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As you can see, we define the `~` path. This is handled by `devtools` in other
    packages but in our case, we need to modify the next Webpack configuration directly.
    For this, you need to create the file `next.config.js` (yes, `.js`, not `.ts`),
    and the code should look like:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们定义了 `~` 路径。在其他包中，这由 `devtools` 处理，但在我们的情况下，我们需要直接修改下一个 Webpack 配置。为此，您需要创建文件
    `next.config.js`（是的，`.js`，而不是 `.ts`），代码应如下所示：
- en: '[PRE61]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Another configuration we need to set up is to add `styled-components` plugins
    to our `.babelrc` file. We will also use the `next/babel` preset. This file exists
    in `packages/frontend/.babelrc`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要设置的一个配置是向我们的 `.babelrc` 文件添加 `styled-components` 插件。我们还将使用 `next/babel`
    预设。此文件位于 `packages/frontend/.babelrc`：
- en: '[PRE62]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now that we have completed this portion of the chapter, we will proceed to create
    a universal `User` model. This model will serve as a template that can be utilized
    across all our websites for anyone who signs up.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这一章节的这一部分，我们将继续创建一个通用的 `用户` 模型。这个模型将作为一个模板，可以在所有我们的网站上为任何注册的用户使用。
- en: Next, our focus will shift toward developing a `Sites` system, which can be
    visualized as a master control room responsible for managing our websites. Just
    like changing TV channels, we will also build a **Page Switcher** that enables
    users to seamlessly switch between different pages on our websites.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的重点将转向开发一个 `站点` 系统，这可以想象为一个负责管理我们网站的主控制室。就像切换电视频道一样，我们还将构建一个 **页面切换器**，使用户能够无缝地在我们的网站上切换不同的页面。
- en: Subsequently, we will construct a common `Login` system that ensures a consistent
    login experience across all our websites. To enhance customization and functionality,
    we will set up a `Sites` configuration, which acts as a rulebook or settings panel
    for each individual site, dictating its behavior and features.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们将构建一个通用的 `登录` 系统，确保所有我们的网站上都有一致的登录体验。为了增强定制性和功能性，我们将设置一个 `站点` 配置，它作为每个独立站点的规则书或设置面板，规定其行为和功能。
- en: To consolidate all these components, we will bundle them together in a single
    file named `server.ts`, which will function as the command center for our system.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些组件统一起来，我们将它们捆绑在一个名为 `server.ts` 的单个文件中，这个文件将作为我们系统的指挥中心。
- en: Once the setup is complete, we will proceed to test our work by running the
    program and examining the outcomes using various examples. If any issues arise,
    our system will provide error messages to indicate and assist in troubleshooting.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置完成，我们将通过运行程序并使用各种示例检查结果来测试我们的工作。如果出现任何问题，我们的系统将提供错误消息以指示并协助故障排除。
- en: In the upcoming sections, you will witness all these steps in action, enabling
    you to comprehend how they integrate within our larger system. Rest assured, although
    it may sound intricate at the moment, we will break it down and guide you through
    each step, ensuring a clear understanding of the process.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将见证所有这些步骤的实际操作，使您能够理解它们如何集成到我们的更大系统中。请放心，尽管现在可能听起来很复杂，但我们将将其分解，并引导您通过每个步骤，确保对过程有清晰的理解。
- en: Creating our Sites system
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的站点系统
- en: The Sites system is pretty much the same as the services system we created in
    our API packages, but in this case instead of managing databases, we manage websites.
    So, like we did before, the first thing we need to do is create the configuration
    of each site. In this scenario, we will also have a **default** site, which is
    called `'blank-page'`, just to avoid the system breaking when no site has been
    provided.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 网站系统基本上与我们之前在API包中创建的服务系统相同，但在这个案例中，我们不是管理数据库，而是管理网站。因此，就像我们之前做的那样，我们首先需要做的是创建每个网站的配置。在这个场景中，我们还将有一个**默认**网站，称为`'blank-page'`，以避免在没有提供网站时系统崩溃。
- en: 'Let’s create the config file for this site in `packages/frontend/src/sites/blank-page/config.ts`,
    and this is the content of that file:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`packages/frontend/src/sites/blank-page/config.ts`中为这个网站创建配置文件，这是该文件的内容：
- en: '[PRE63]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: For this example, I’ll use two personal sites, `san-pancho` and `codejobs`,
    but feel free to add any site you want to the project.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我将使用两个个人网站，`san-pancho`和`codejobs`，但你可以自由地将任何网站添加到项目中。
- en: 'As part of the site, we need to create the `graphql` files, to consume our
    API queries and mutations, and the specific pages for this site. The only query
    we will add for now is the `getGuests` query that we previously created in the
    API package. This file should be in `packages/frontend/src/sites/san-pancho/graphql/guest/getGuests.query.ts`.
    If, at some point, you want to create a mutation, you may want to use the `myMutation.mutation.ts`
    format for the filename:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 作为网站的一部分，我们需要创建`graphql`文件，以消费我们的API查询和突变，以及这个网站的具体页面。我们现在将添加的唯一查询是我们之前在API包中创建的`getGuests`查询。这个文件应该在`packages/frontend/src/sites/san-pancho/graphql/guest/getGuests.query.ts`中。如果你在某个时候想创建一个突变，你可能想使用`myMutation.mutation.ts`格式作为文件名：
- en: '[PRE64]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Creating our Page Switcher
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的页面切换器
- en: If you have used Next.js in the past, you’ll know how the **Next** page system
    works. Essentially, you have your `pages` directory, and the files or directories
    you add to that will represent the route of a page. For our example, we will need
    to create some Next pages that will “switch” or render a custom page from each
    site. I know it sounds a little bit complicated, but let’s break this down into
    parts.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前使用过Next.js，你会知道**Next**页面系统是如何工作的。本质上，你有一个`pages`目录，你添加到该目录的文件或目录将代表页面的路由。在我们的例子中，我们需要创建一些Next页面，这些页面将“切换”或从每个网站渲染自定义页面。我知道这听起来有点复杂，但让我们将其分解成几个部分。
- en: 'The first thing to do is to create our `index.ts` page in `packages/frontend/src/pages/index.ts`
    (this is a Next page):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的事情是在`packages/frontend/src/pages/index.ts`中创建我们的`index.ts`页面（这是一个Next页面）：
- en: '[PRE65]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Another Next.js page that we must create is one that has a special name and
    needs to be created in `packages/frontend/src/pages/[page]/[…params].tsx`. The
    `[page]` will be a dynamic path. The `[...params].tsx` file will receive any additional
    parameters passed in the URL. If we have more than two nested routes, these additional
    routes will be added as an array to the `params` variable:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须创建的另一个Next.js页面是具有特殊名称的页面，需要创建在`packages/frontend/src/pages/[page]/[...params].tsx`中。`[page]`将是一个动态路径。`[...params].tsx`文件将接收URL中传递的任何附加参数。如果我们有超过两个嵌套路由，这些附加路由将作为数组添加到`params`变量中：
- en: '[PRE66]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: On each Next.js page, we will import a `SwitcherPage` component that exists
    on each site. We also import the `routerParams`, which will control the routing
    for each site as well, and we will receive the `siteTitle` via props. In other
    words, we just render the `SwitcherPage` component and pass the props.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个Next.js页面上，我们将导入存在于每个网站上的`SwitcherPage`组件。我们还会导入`routerParams`，它也将控制每个网站的路由，并且我们将通过props接收`siteTitle`。换句话说，我们只是渲染`SwitcherPage`组件并传递props。
- en: 'Let’s see how the `Switcher` component from our `san-pancho` site looks (`packages/frontend/src/sites/san-pancho/switcher.tsx`):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的`san-pancho`网站的`Switcher`组件是如何看的（`packages/frontend/src/sites/san-pancho/switcher.tsx`）：
- en: '[PRE67]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `next/dynamic` is a composite extension of `React.lazy` and `Suspense`.
    These components can delay hydration until the `Suspense` boundary is resolved.
    In our case, we are dynamically loading pages from this site, specifically the
    `index.index`, `login.index`, and `dashboard.index`. You’re probably wondering
    why we have a nested index page for each of them. This is because we can have
    nested pages; for example, `index.index` will refer to [http://localhost:3000/](http://localhost:3000/),
    `login.index` to [http://localhost:3000/login](http://localhost:3000/login), and
    `dashboard.index` to [http://localhost:3000/dashboard](http://localhost:3000/dashboard).
    However, suppose you want to add a page inside the dashboard like `guests`. You
    will then add `dashboard.guests`, which will point to [http://localhost:3000/dashboard/guests](http://localhost:3000/dashboard/guests).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`next/dynamic`是`React.lazy`和`Suspense`的复合扩展。这些组件可以延迟水合，直到`Suspense`边界解决。在我们的情况下，我们从这个网站动态加载页面，具体是`index.index`、`login.index`和`dashboard.index`。你可能想知道为什么我们为每个都设置了嵌套的索引页面。这是因为我们可以有嵌套的页面；例如，`index.index`将指向[http://localhost:3000/](http://localhost:3000/)，`login.index`指向[http://localhost:3000/login](http://localhost:3000/login)，而`dashboard.index`指向[http://localhost:3000/dashboard](http://localhost:3000/dashboard)。然而，如果你想在仪表板内部添加一个名为`guests`的页面，那么你需要添加`dashboard.guests`，它将指向[http://localhost:3000/dashboard/guests](http://localhost:3000/dashboard/guests)。'
- en: 'Each `switcher.ts` file from the `sites` directories uses the `Switcher` component.
    Hence, let’s create it. This file is located in `packages/frontend/src/components/Switcher.tsx`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`sites`目录中的每个`switcher.ts`文件都使用`Switcher`组件。因此，让我们创建它。此文件位于`packages/frontend/src/components/Switcher.tsx`：'
- en: '[PRE68]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Let’s now create the index page for our San Pancho site. This page serves a
    simple purpose: to display the site’s title, providing confirmation that we are
    currently on the San Pancho site. This file should exist in `packages/frontend/src/sites/san-pancho/pages/index.tsx`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的San Pancho网站创建索引页面。这个页面有一个简单的目的：显示网站的标题，确认我们目前位于San Pancho网站上。此文件应位于`packages/frontend/src/sites/san-pancho/pages/index.tsx`：
- en: '[PRE69]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'After this, we can create our index page for our dashboard (`packages/frontend/src/sites/san-pancho/pages/dashboard/index.tsx`):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们可以为我们的仪表板创建索引页面（`packages/frontend/src/sites/san-pancho/pages/dashboard/index.tsx`）：
- en: '[PRE70]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Finally, we need to create our login page for `san-pancho`, which will share
    the `Login` component for all the sites (`packages/frontend/src/sites/san-pancho/pages/login.tsx`):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要为`san-pancho`创建我们的登录页面，它将共享所有网站的`Login`组件（`packages/frontend/src/sites/san-pancho/pages/login.tsx`）：
- en: '[PRE71]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Creating our Login system
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的登录系统
- en: 'All our sites will use the same login page because we share the authentication
    system. Let’s create our `Login` component and see how we can perform the login:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的网站都将使用相同的登录页面，因为我们共享认证系统。让我们创建我们的`Login`组件，看看我们如何执行登录操作：
- en: '[PRE72]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'As you can see, the `login` function that is executed in the `handleSubmit`
    comes from our `UserContext`. This will execute the `login` mutation when the
    user needs to perform a login, and the `getUser` query to validate if a logged
    user is valid. Let’s create that `User Context` (Context API), which should be
    located in `packages/frontend/src/contexts/user.ts`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在`handleSubmit`中执行的`login`函数来自我们的`UserContext`。当用户需要执行登录操作时，它将执行`login`突变，并执行`getUser`查询以验证登录用户是否有效。让我们创建这个`User
    Context`（上下文API），它应位于`packages/frontend/src/contexts/user.ts`：
- en: '[PRE73]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now let’s create our `login` mutation, which will receive two parameters (`$emailOrUsername`
    and `$password`). This file should be located in `packages/frontend/src/graphql/user/login.mutation.ts`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的`login`突变，它将接收两个参数（`$emailOrUsername`和`$password`）。此文件应位于`packages/frontend/src/graphql/user/login.mutation.ts`：
- en: '[PRE74]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'After that, we need to create the `getUser` query, which will take the `accessToken`
    (`at`) as a parameter and validate if the connected user is valid. This file exists
    in `packages/frontend/src/graphql/user/getUser.query.ts`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要创建`getUser`查询，它将`accessToken`（`at`）作为参数，并验证连接的用户是否有效。此文件位于`packages/frontend/src/graphql/user/getUser.query.ts`：
- en: '[PRE75]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'There are two more things to do. The first thing is to add our `UserProvider`
    as a wrapper of our application; we need to do this on a special page called `"_app.tsx"`
    inside the `pages` directory:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两件事要做。第一件事是将我们的`UserProvider`作为应用程序的包装器添加；我们需要在`pages`目录中的特殊页面`"_app.tsx"`上执行此操作：
- en: '[PRE76]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Finally, we need to create another special file called `"_document.tsx"` inside
    the `pages` directory. In this file, we will render the `ServerStyleSheet` from
    `styled-components` to be able to use `styled-components` in the server (Next.js):'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要在`pages`目录内创建另一个特殊文件，名为`"_document.tsx"`。在这个文件中，我们将渲染来自`styled-components`的`ServerStyleSheet`，以便在服务器（Next.js）中使用`styled-components`：
- en: '[PRE77]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Creating our sites configuration
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的站点配置
- en: 'As we did in our API project, we need to create a configuration for our sites.
    Let’s start by creating our `SiteConfiguration` type, the file for which will
    be located in `packages/frontend/src/types/config.ts`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在我们的API项目中做的那样，我们需要为我们的站点创建一个配置。让我们首先创建我们的`SiteConfiguration`类型，该类型的文件将位于`packages/frontend/src/types/config.ts`：
- en: '[PRE78]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The configuration we will do is for the `san-pancho` site, and you should add
    this file to `packages/frontend/src/sites/san-pancho/config.ts`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要进行的配置是为`san-pancho`站点，你应该将此文件添加到`packages/frontend/src/sites/san-pancho/config.ts`：
- en: '[PRE79]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'After this, we must create our main `config.ts` file, which should be in `packages/frontend/src/config.ts`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们必须创建我们的主要`config.ts`文件，该文件应在`packages/frontend/src/config.ts`中：
- en: '[PRE80]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Putting everything together
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将一切整合在一起
- en: The last piece of the puzzle is our `server.ts` file, which will handle Next.js,
    our static directories, and routes. Let’s break down the file into parts and see
    each one in detail. This file should be in `packages/frontend/src/server.ts`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是`server.ts`文件，它将处理Next.js、我们的静态目录和路由。让我们将文件分解成几个部分，并详细查看每一个。此文件应在`packages/frontend/src/server.ts`中。
- en: 'The first thing we need to do is to import some dependencies and the site configuration:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是导入一些依赖项和站点配置：
- en: '[PRE81]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then we need to check that the `SITE` being passed in the terminal is actually
    valid:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要检查终端中传递的`SITE`是否实际上是有效的：
- en: '[PRE82]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'If the site is valid, then we prepare our `Next` and `Express` applications:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果站点有效，那么我们准备我们的`Next`和`Express`应用程序：
- en: '[PRE83]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We also need to configure our `cookieParser` to be able to use cookies and
    set up our site’s static directories, so we can have a shared `public` folder
    and then specific `static` directories inside each site:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要配置我们的`cookieParser`，以便能够使用cookie并设置我们站点的静态目录，这样我们就可以有一个共享的`public`文件夹，然后在每个站点内部有特定的`static`目录：
- en: '[PRE84]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Next, we’ll handle our custom routes next and add additional protection to
    specific routes, such as `/dashboard`. We want to ensure that only connected users
    can access this route. For this, we will use the `isConnected` middleware to validate
    whether a user is connected. If the user is not connected, we will redirect them
    to the login page:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将处理我们的自定义路由，并为特定路由，如`/dashboard`，添加额外的保护。我们希望确保只有已连接的用户才能访问此路由。为此，我们将使用`isConnected`中间件来验证用户是否已连接。如果用户未连接，我们将将他们重定向到登录页面：
- en: '[PRE85]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Finally, all other traffic is going to be handled by Next.js; then we listen
    to port `3000`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有其他流量都将由Next.js处理；然后我们监听端口`3000`：
- en: '[PRE86]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Demo time!
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示时间！
- en: 'After all of those configurations, we are ready to run our project and see
    if it works. We will need to run it in a similar way to how we did on the API,
    but instead of the `SERVICE` variable, we will use the `SITE` variable. We also
    need to specify which site we want to run (`san-pancho` or `codejobs`). If you
    try to run some other site that does not exist, you will get an error. Let’s try
    that to test the validation of the sites:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些配置之后，我们准备好运行我们的项目并查看它是否工作。我们需要以与我们在API中相同的方式运行它，但我们将使用`SITE`变量而不是`SERVICE`变量。我们还需要指定我们想要运行哪个站点（`san-pancho`或`codejobs`）。如果你尝试运行一个不存在的其他站点，你会得到一个错误。让我们尝试一下以测试站点的验证：
- en: '![Text  Description automatically generated](img/B18414_14_16.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![文本  自动生成的描述](img/B18414_14_16.png)'
- en: 'Figure 14.16: getGuests query'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.16：getGuests查询
- en: 'The validation works fine. Now, let’s run our `san-pancho` site with the `SITE=san-pancho
    npm run dev` command:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 验证工作正常。现在，让我们使用`SITE=san-pancho npm run dev`命令运行我们的`san-pancho`站点：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B18414_14_17.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，聊天或文本消息  自动生成的描述](img/B18414_14_17.png)'
- en: 'Figure 14.17: San Pancho Index Page'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.17：San Pancho首页
- en: 'If everything works fine, you should see the preceding. Next, let’s run our
    `codejobs` site with `SITE=codejobs npm run dev`:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该能看到前面的内容。接下来，让我们使用`SITE=codejobs npm run dev`命令运行我们的`codejobs`站点：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B18414_14_18.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，聊天或文本消息  自动生成的描述](img/B18414_14_18.png)'
- en: 'Figure 14.18: Codejobs Index Page'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.18：Codejobs索引页面
- en: Nice, so both our sites work as expected!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，所以我们的两个网站都按预期工作！
- en: 'Now it’s time to test our login page for each site. Let’s start with San Pancho:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候测试每个网站的登录页面了。让我们从San Pancho开始：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B18414_14_19.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，聊天或短信，自动生成的描述](img/B18414_14_19.png)'
- en: 'Figure 14.19: San Pancho Sign In page'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.19：San Pancho登录页面
- en: 'Then let’s test the Codejobs login page:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们测试Codejobs登录页面：
- en: '![Graphical user interface, application  Description automatically generated](img/B18414_14_20.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，自动生成的描述](img/B18414_14_20.png)'
- en: 'Figure 14.20: Codejobs Sign In page'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.20：Codejobs登录页面
- en: 'Everything seems good so far. Now let’s test the login with our default credentials,
    which are **username**: `admin` and **password**:`12345678`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切看起来都很正常。现在让我们用我们的默认凭证测试登录，这些凭证是**用户名**：`admin`和**密码**：`12345678`：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18414_14_21.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件，自动生成的描述](img/B18414_14_21.png)'
- en: 'Figure 14.21: Dashboard for San Pancho'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.21：San Pancho仪表板
- en: Nice! So now we are connected to San Pancho’s dashboard.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！所以现在我们已经连接到了San Pancho的仪表板。
- en: 'One thing I want to highlight here is the cookie name we used for the user
    session, which is `at-san-pancho`. However, even if you already performed a login
    in San Pancho, if you try to access the Codejobs dashboard, you will be required
    to log in again because each site session is independent of the other:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在这里强调的是我们用于用户会话的cookie名称，它是`at-san-pancho`。然而，即使你已经在San Pancho完成了登录，如果你尝试访问Codejobs仪表板，你将需要再次登录，因为每个网站会话都是独立的：
- en: '![](img/B18414_14_22.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18414_14_22.png)'
- en: 'Figure 14.22: Site cookies'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.22：网站cookie
- en: 'Finally, let’s test hitting a URL that does not exist on our sites:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们测试一下访问我们网站上不存在的URL：
- en: '![Graphical user interface, website  Description automatically generated](img/B18414_14_23.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，网站，自动生成的描述](img/B18414_14_23.png)'
- en: 'Figure 14.23: 404 error page'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.23：404错误页面
- en: You should see a `404` page that will be shared across both sites.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一个`404`页面，它将在两个网站上共享。
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations on making it this far! Without a doubt, this chapter has been
    complex, yet incredibly interesting. Now, you have the bare bones ready to begin
    working on your personal websites.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你走到了这一步！毫无疑问，这一章内容复杂，但非常有趣。现在，你已经准备好了个人网站的骨架，可以开始工作了。
- en: Throughout the course of this chapter, you acquired a comprehensive set of skills.
    You learned how to create `User` models and GraphQL types, understand error handling,
    and set up custom services like a CRM. You successfully navigated through the
    process of building a Sites system, enhanced user experience with a Page Switcher,
    and established a shared login system. Furthermore, you gained knowledge in managing
    configurations, working with “seeds” or default data for models, and consolidating
    components into a command file such as `server.ts`. As a result, you are now proficient
    in synchronizing models, starting up the Apollo Server, running tests, and effectively
    troubleshooting any issues that may arise. In essence, you have established a
    robust foundation in managing multi-site web systems, enhancing user experience,
    understanding GraphQL, and troubleshooting.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的学习过程中，你掌握了一套全面的技能。你学习了如何创建`User`模型和GraphQL类型，理解错误处理，并设置自定义服务，如CRM。你成功导航了构建站点系统的过程，通过页面切换器增强了用户体验，并建立了一个共享登录系统。此外，你获得了管理配置、使用模型的“种子”或默认数据以及将组件合并到命令文件（如`server.ts`）中的知识。因此，你现在精通同步模型、启动Apollo
    Server、运行测试以及有效地解决可能出现的任何问题。本质上，你在管理多站网站系统、增强用户体验、理解GraphQL和故障排除方面建立了坚实的基础。
- en: In the next chapter, you will have the opportunity to expand your skills further
    as you learn how to improve the performance of your React applications.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将有机会进一步扩展你的技能，学习如何提高你的React应用程序的性能。
