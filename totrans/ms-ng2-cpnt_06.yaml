- en: Chapter 6. Keeping Up with Activities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll build an activity log in our task management system using
    **Scalable Vector Graphics** (**SVG**) to build graphical components using Angular.
    SVG is the perfect candidate when it comes to complex graphical content, and using
    Angular components, we can build nicely encapsulated and reusable content.
  prefs: []
  type: TYPE_NORMAL
- en: Since we want to log all the activities within our application, such as adding
    comments or renaming tasks, we are going to create a central repository. We can
    then display these activities and render them as an activity timeline using SVG.
  prefs: []
  type: TYPE_NORMAL
- en: To add an overview of all the activities and to provide a user input to narrow
    the range of displayed activities, we're going to create an interactive slider
    component. This component will use a projection to render timestamps, in the form
    of ticks and activities, directly onto the slider's background. We'll also use
    SVG to render the elements within the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A basic introduction to SVG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making SVG composable with Angular components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using namespaces in component templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple pipe to format calendar times using Moment.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `@HostListener` annotations to handle user input events to create
    an interactive slider element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making use of Shadow DOM using `ViewEncapsulation.Native` in order to create
    native-style encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a service for logging activities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this chapter is to provide a way to keep track of all user activities
    within the task management application. For this purpose, we'll need a system
    that will allow us to log activities within components and to access already logged
    activities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activities, as entities, should be quite generic and should have the following
    fields with their respective purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subject**: This field should be used to reference the subject of the activity.
    This can be any identifier that identifies a foreign entity. In the context of
    projects, we''ll store the project ID in this field. Services and components that
    use the activity service should use this field to filter specific activities further.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Category**: This field provides an additional way of tagging the activity
    further. For projects, we will currently use two categories: *comments* and *tasks*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Title**: This refers to the title of the activity that will provide a very
    brief summary of what the activity is about. This could be something like *New
    task was added* or *Comment was deleted*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message**: This is the field where the real beef of the activity goes into.
    It should contain enough information to provide good traceability of what happened
    during the activity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to develop our system, we''ll create a new file named `activity-service.js`
    under the `activities/activity-service` path in our `lib` folder. In this file,
    we will create our activity service class, which we''re enabling for dependency
    injection, by using the `@Injectable` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor of our activity service, we've subscribed to changes to our
    data store and have filtered any incoming change by type so we will only receive
    activity updates.
  prefs: []
  type: TYPE_NORMAL
- en: Since activities can't be edited or deleted, we only need to be concerned about
    newly added activities. We update the internal array of activities with any added
    activity in the subscription. This way, we'll not only receive all the initial
    activities, but also the activities that are subsequently added directly from
    the data store. Other services and components can then directly access the activity
    list of the system.
  prefs: []
  type: TYPE_NORMAL
- en: In order for other application components to react to changes in the activity
    list, we've exposed a `ReplaySubject` observable on the `change` member field.
  prefs: []
  type: TYPE_NORMAL
- en: In the `logActivity` method, we've simply added a new activity to the data store.
    `UserService` will provide us with information on the currently logged-in user,
    and we can use `DataProvider` to write to the data store.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have created a simple platform that will help us keep track of activities
    within our application. Since we want only one instance of `ActivityService` within
    our application, let''s add it to the `providers` list on our root `App` component.
    You''ll find this component in the `app.js` file, located within our `lib` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Because all dependency injectors will inherit the dependencies from our `App`
    component, we can inject it in any component of our application going forward.
  prefs: []
  type: TYPE_NORMAL
- en: Logging activities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have created a nice system to log activities. Now let's go ahead and use
    it within our components to keep an audit of all the activities.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s use `ActivityService` to log activities within the `TaskList`
    component. The following code excerpt highlights the changes made to the `TaskList`
    component within the `task-list/task-list.js` file in our `lib` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using the `logActivity` method of `ActivityService`, we can easily log any number
    of activities within the already existing `TaskList` methods to modify tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the message body of our activities, we've used a new utility function, `limitWithEllipsis`,
    which we've imported from a new module, namely `string-utilities`. This function
    takes a string and a number as parameters. The returned string is a truncated
    version of the input string, which is cut off at the position specified with the
    second parameter. In addition, there's an ellipsis character (`...`) appended
    to the string. I won't bother you with the rather simple code within this helper.
    If you'd like to know how it's implemented, you can always check the implementation
    after downloading this chapter's code.
  prefs: []
  type: TYPE_NORMAL
- en: If you go back to the specification of our activity logs, you will see that
    we always need to specify a subject in order to log activities. We've implemented
    this on our `TaskList` component by introducing a new input parameter called `activitySubject`.
    The assumption here is that each activity subject contains `LiveDocument` stored
    under the document member. From there, we can obtain the ID in the data store
    and use it for our activity message.
  prefs: []
  type: TYPE_NORMAL
- en: If we revisit our `Project` component, you will see that we're already following
    the prerequisites of being an activity subject. We've stored a reference to the
    underlying `LiveDocument` instance under the `document` member field.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do now is change the template of our `ProjectTaskList` wrapper
    component to pass the `activitySubject` project input of the `TaskList` component.
    Let''s look at the changes in the `lib/project/project-task-list/project-task-list.html`
    file quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You might wonder why we care about this rather cumbersome way of dealing with
    our task list, if we could just pass in a hard reference to the project and use
    project tasks and the project ID directly. The beautiful aspect of our current
    solution is that we do not have any dependency on a project as such. We could
    also use our `TaskList` component without the context of a project. And we can
    still pass a list of tasks to the `tasks` input and use a different activity subject
    for the activity logs.
  prefs: []
  type: TYPE_NORMAL
- en: We're also going to use `ActivityService` within the `Comments` component to
    create logs for added, edited, and deleted comments. Since the steps involved
    are very similar to what we've just done for the `TaskList` component, we're going
    to skip this. You can always take a look at the final codebase for this chapter
    to add activity logs for the `Comments` component.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging the power of SVG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SVG has been a part of the Open Web Platform standards since 1999 and was first
    recommended in 2001 under the SVG 1.0 standard. SVG is a consolidation of two
    independent proposals for an XML-based vector image format. **Precision Graphics**
    **Markup Language** (**PGML**)—mainly developed by Adobe and Netscape—as well
    as **Vector Markup Language** (**VML**)—which was mainly represented by Microsoft
    and Macromedia—were both different XML formats that served the same purpose. The
    W3C consortium declined both the proposals in favor of the newly developed SVG
    standard that unified the best of both worlds into a single standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Leveraging the power of SVG](img/image00323.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Timeline showing the development of the SVG standard
  prefs: []
  type: TYPE_NORMAL
- en: All three standards had a common goal, which was to provide a format for the
    Web to display vector graphics in the browser. SVG is a declarative language that
    specifies graphical objects using XML elements and attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple example on how to create an SVG image with a black
    circle, using SVG:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This rather simple example represents an SVG image with a black circle, whose
    center is located at *x = 10 px* and *y = 10 px*. The radius of the circle is
    10 px, which makes this circle 20 px in width and height.
  prefs: []
  type: TYPE_NORMAL
- en: 'The origin of the coordinate system in SVG sits on the top-left corner, where
    the *y* axis faces the south direction and the *x* axis eastward:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Leveraging the power of SVG](img/image00324.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The coordinate system within SVG
  prefs: []
  type: TYPE_NORMAL
- en: Using not only primitive shapes, such as circles, lines, and rectangles, but
    also complex polygons, the possibilities for creating graphical content are nearly
    unlimited.
  prefs: []
  type: TYPE_NORMAL
- en: SVG is not only used within the Web, but has also become a very important intermediate
    format for exchanging vector graphics between different applications. Almost any
    application that supports vector graphics also supports the import of SVG files.
  prefs: []
  type: TYPE_NORMAL
- en: The real power of SVG comes to the surface when we do not include an SVG file
    as an HTML image, but rather include the SVG content directly within our DOM.
    Since HTML5 directly supports the SVG namespace within an HTML document and will
    render the graphics we define within our HTML, a whole bunch of new possibilities
    spring up. We can now style our SVG with CSS, manipulate the DOM with JavaScript,
    and easily make our SVG interactive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking the previous example of our circle image to the next level, we could
    make it interactive by changing the circle color by clicking it. First, let''s
    create a minimal HTML document and include our SVG elements directly within the
    DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can get rid of the version and the XML namespace declaration
    when we use SVG directly within the DOM of our HTML document. What's interesting
    here is that we can treat SVG very much like regular HTML. We can assign an ID
    and even classes to SVG elements and access them from JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `script` tag of our HTML document, we can directly access our `circle`
    element using the ID we've previously assigned to it. We can add event listeners,
    the way we already know, from regular HTML elements. In this example, we added
    a `click` event listener and changed the color of our circle to red.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, we used an inline `script` tag in this example.
    It would of course be much cleaner to have a separate JavaScript file to do the
    scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Styling SVG
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I'm a purist when it comes to the separation of concerns within the Web. I still
    strongly believe in the separation of structure (HTML), appearance (CSS), and
    behavior (JavaScript), as well as producing the most maintainable applications
    when following this practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it seems weird to have SVG in your HTML, and you might think that this
    breaks the contract of a clean separation. Why is this graphical content, consisting
    of only appearance-relevant data, sitting in my HTML that is supposed to only
    contain raw information? After dealing with a lot of SVGs within a DOM, I have
    come to the conclusion that we can establish a clean separation when using SVG
    by dividing our appearance responsibilities into the following two subgroups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Graphical structure**: This subgroup deals with the process of defining the
    basic structure of your graphical content. This is about shapes and layout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual appearance**: This subgroup deals with the process of defining the
    look and feel of our graphical structures, such as colors, line widths, line styles,
    and text alignment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we separate the concerns of SVG into these groups, we can actually gain great
    maintainability. Graphical structure is defined by the SVG shapes themselves.
    They are directly written within our HTML but don't have a particular look and
    feel. We only store the basic structural information within HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, all the properties of visual appearance, such as colors, cannot only
    be expressed through the attributes in our SVG elements; however, there's a corresponding
    CSS property that allows us to offload all the look-and-feel-relevant aspects
    of the structure to CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the example where we drew a black circle; we''ll tweak this a bit
    to fit our demands of separation of concerns so that we can distinguish graphical
    structure from graphical appearance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Styling our graphical structures can now be achieved using CSS by including
    a stylesheet with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is fantastic, as we can now not only reuse some graphical structures, but
    also apply different visual appearance parameters using CSS, similar to those
    enlightening moments when we managed to reuse some semantic HTML by only changing
    some CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the most important CSS properties we can use to style SVG shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fill`: While working with solid SVG shapes, there''s always a shape fill and
    stroke option available; the `fill` property specifies the color of the shape
    fill.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stroke`: This property specifies the color of the SVG shape''s outline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stroke-width`: This property specifies the width of the SVG shape''s outline
    on solid shapes. For nonsolid shapes, such as lines, this can be thought of as
    line width.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stroke-dasharray`: This specifies a dash pattern for strokes. Dash patterns
    are space-separated values that define a pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stroke-dashoffset`: This specifies an offset for the dash pattern, which is
    specified with the `stroke-dasharray` property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stroke-linecap`: This property defines how line caps should be rendered. They
    can be rendered as square, butt, or rounded caps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stroke-linejoin`: This property specifies how lines are joined together within
    a path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shape-rendering`: Using this property, you can override the shape-rendering
    algorithm that, as the name suggests, is used to render shapes. This is particularly
    useful if you need crispy edges on your shapes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a complete reference of the available appearance-relevant SVG attributes,
    visit the Mozilla Developer website at [https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute).
  prefs: []
  type: TYPE_NORMAL
- en: I hope this brief introduction gave you a better feeling about SVG and the great
    power it comes with. In this chapter, we're going to use some of that power to
    create nice, interactive graphical components. If you would like to learn more
    about SVG, I strongly recommend that you go through the great articles by *Sara
    Soueidan*.
  prefs: []
  type: TYPE_NORMAL
- en: Building SVG components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When building Angular components with SVG templates, there are a couple of things
    we need to be aware of. The first and most obvious one, is XML namespaces. Modern
    browsers are very intelligent when parsing HTML. Besides being probably the most
    fault-tolerant parser in the history of computer science, DOM parsers are very
    smart in recognizing markup and then deciding how to treat it. They will automatically
    decide the correct namespaces for us, based on element names, so we don't need
    to deal with them when writing HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve messed around with the DOM API a bit, you would''ve probably recognized
    that there are two methods for creating new elements. In the document object,
    for example, there''s a `createElement` function, but there''s also `createElementNS`
    that accepts an additional namespace URI parameter. Also, every created element
    has a `namespaceURI` property that tells you the namespace of the specific element.
    This is important since HTML5 is a standard that consists of at least three namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTML**: This is the standard HTML namespace with the [http://www.w3.org/1999/xhtml](http://www.w3.org/1999/xhtml)
    URI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SVG**: This embraces all SVG elements and attributes and uses the [http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)
    URI. You can sometimes see this namespace URI in an `xmlns` attribute of the `svg`
    elements. In fact, this is not really required, as the browser is smart enough
    to decide on the correct namespace itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MathML**: This is an XML-based format to describe mathematical formulas and
    is supported in most modern browsers. It uses the [http://www.w3.org/1998/Math/MathML](http://www.w3.org/1998/Math/MathML)
    namespace URI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can mix all these elements from different standards and namespaces within
    a single document, and our browser will figure out the correct namespace itself
    when it creates elements within the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want more information on namespaces, I recommend that you go through
    the *Namespaces* *Crash Course* article on the Mozilla Developer Network at [https://developer.mozilla.org/en/docs/Web/SVG/Namespaces_Crash_Course](https://developer.mozilla.org/en/docs/Web/SVG/Namespaces_Crash_Course).
  prefs: []
  type: TYPE_NORMAL
- en: As Angular will compile templates for us and render elements into the DOM using
    the DOM API, it needs to be aware of the namespaces when doing that. Similar to
    the browser, Angular provides some intelligence for deciding the correct namespace
    while creating elements. However, there are some situations where you need to
    help Angular recognize the correct namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate some of this behavior, let''s transform our circle example that
    we''ve been working on into an Angular component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We've wrapped our circle SVG graphics into a simple Angular component. The `size`
    input parameter determines the actual width and height of the circle by controlling
    the SVG's `width` and `height` attributes and the circle's `cx`, `cy`, and `r`
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use our `Circle` component, simply use the following template within another
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important to note that we need to use attribute bindings on SVG elements,
    and we can't set DOM element properties directly. This is due to the nature of
    SVG elements that have special property types—for example, `SVGAnimatedLength`—that
    can be animated with **Synchronized Multimedia Integration** **Language** (**SMIL**).
    Instead of interfering with these rather complex element properties, we can simply
    use attribute bindings to set the attribute values of the DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back to our namespace discussion. Angular would know that it needs
    to use the SVG namespace to create the elements within this template. It will
    function in this way simply because we're using the `svg` element as a root element
    within our component, and it could switch the namespace within the template parser
    for any child elements automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are certain situations where we need to help Angular determine
    the correct namespace for the elements we''d like to create. This strikes us if
    we''re creating nested SVG components that don''t contain a root `svg` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we're nesting SVG components, and our `AwesomeCircle` component
    does not have an `svg` root element to tell Angular to switch the namespace. This
    is why we've created the `svg` element within our `App` component and then included
    the `AwesomeCircle` component in an SVG group.
  prefs: []
  type: TYPE_NORMAL
- en: We need to explicitly tell Angular to switch to the SVG namespace within our
    `Circle` component, and we can do this by including the namespace name as a prefix
    separated by a colon, as you can see in the highlighted section of the preceding
    code excerpt.
  prefs: []
  type: TYPE_NORMAL
- en: If you have multiple elements that need to be created within the SVG namespace
    explicitly, you can rely on the fact that Angular does apply the namespace for
    child elements too and does group all your elements with an SVG group element.
    So, you only need to prefix the group element `<svg:g> ... </svg:g>`, but none
    of the contained SVG elements.
  prefs: []
  type: TYPE_NORMAL
- en: This is enough to know about Angular internals when dealing with SVG. Let's
    move on and create some real components!
  prefs: []
  type: TYPE_NORMAL
- en: Building an interactive activity slider component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous topics, we've covered the basics of working with SVG and dealing
    with SVG in Angular components. Now it's time to apply our knowledge to the task
    management application and create some components using SVG.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first component we''ll be creating in this context is an interactive slider
    that allows the user to select the time range of activities that he or she is
    interested to check out. Displaying a simple HTML5 range input could be a solution,
    but since we''ve gained some SVG superpower, we can do better! We''ll use SVG
    to render our own slider that will show existing activities as ticks on the slider.
    Let''s look at a mock-up of the slider component that we''re going to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an interactive activity slider component](img/image00325.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A mockup of the activity slider component
  prefs: []
  type: TYPE_NORMAL
- en: Our slider component will actually serve two purposes. It should be a user control
    and should provide a way to select a time range for filtering activities. However,
    it should also provide an overview of all the activities so that a user can filter
    the range more intuitively. By drawing vertical bars that represent activities,
    we can already give the user a feeling of the range he or she is interested in.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we''ll create a new file for our `ActivitySlider` component called
    `activity-slider.js` within the `activities/activity-slider` path and define our
    component class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we should mention, and which differs from all the other components
    we've written so far, is that we're using `ViewEncapsulation.Native` for this
    component. As we learned from the *Creating our application component* section
    in [Chapter 2](part0020.xhtml#aid-J2B81 "Chapter 2. Ready, Set, Go!"), *Ready,
    Set, Go!*, when we use `ViewEncapsulation.Native` for our component encapsulation,
    Angular actually uses Shadow DOM to create the component. We briefly looked at
    this in the *Shadow DOM* section in [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Component-Based
    User Interfaces"), *Component-Based User Interfaces* as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Shadow DOM for our component will give us this advantage: our component
    will be fully encapsulated from the CSS side of things. This not only means that
    none of the global CSSes will leak into our component, but it also means that
    we''ll need to create local styles in order to style our component.'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've used a CSS naming convention called BEM that provides us with
    some necessary prefixes to avoid name clashes within CSS and establish a clean
    and simple CSS specificity. However, when using Shadow DOM, we can forego prefixes
    to avoid name clashes, since we're only applying styles locally within the component.
  prefs: []
  type: TYPE_NORMAL
- en: Because we're using Shadow DOM for this component, we need to have a way to
    define local styles. Angular provides us with an option to pass styles into the
    component using the `styles` property of the component annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Chrome supports Shadow DOM natively since version 35\. Within Firefox, Shadow
    DOM can be enabled by visiting the `about:config` page and turning on the `dom.webcomponents.enabled`
    flag. IE, Edge, and Safari don't support this standard at all; however, we can
    set things up in a way that they could deal with Shadow DOM, by including a polyfill
    named `webcomponents.js`. You can find more information on this polyfill at [https://github.com/webcomponents/webcomponentsjs](https://github.com/webcomponents/webcomponentsjs).
  prefs: []
  type: TYPE_NORMAL
- en: Using the text plugin of SystemJS, we can import a stylesheet containing only
    the local styles of our component and then pass them to the `styles` property.
    By appending a `!text` postfix to the import of our CSS file, we tell SystemJS
    to load our CSS file as raw text. Note that the `styles` property is expecting
    an array, which is why we wrap our imported styles into an array literal.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take a look at the stylesheet for the `ActivitySlider` component, you
    can immediately see that we''re no longer prefixing the classes with the component
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Usually, such short class names would probably lead to name clashes within our
    project, but since the styles will be local to the Shadow DOM of our component,
    we don't need to worry about name clashes any more.
  prefs: []
  type: TYPE_NORMAL
- en: As an input parameter, we define the list of activities that will be used not
    only to determine the available range in the slider, but also to render activities
    on the background of the slider.
  prefs: []
  type: TYPE_NORMAL
- en: Once a selection is made by the user, our component will use the `selectionChange`
    event emitter to notify the outside world about the change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the constructor, we''re setting aside the component DOM element for
    some measurement we need to make in order to draw later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: By injecting the `ElementRef` instance to the constructor, we can easily access
    the native DOM element of our component.
  prefs: []
  type: TYPE_NORMAL
- en: Projection of time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our slider component needs to be able to project timestamps into the coordinate
    system of SVG. Also, when a user clicks on the timeline to select a range, we''ll
    need to be able to project coordinates back into timestamps. For this purpose,
    we need to create two projection functions within our component that will use
    a few helper functions and states to calculate the values, from coordinates to
    time and vice-verse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Projection of time](img/image00326.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Visualization of important variables and functions for our calculations
  prefs: []
  type: TYPE_NORMAL
- en: While we will use percentage to position our SVG elements on the slider component,
    the padding on the sides will need to be specified in pixels. The `totalWidth`
    function will return the total width of the area in pixels; this is where we'll
    draw the activity indicators. The `timeFirst`, `timeLast`, and `timeSpan` variables
    will also be used by the calculations and are specified in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some code to our slider to deal with the projection of our activities
    on the slider in the `activity-slider.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since we have put aside the reference to the root element as the `sliderElement`
    member variable, we can use its `clientWidth` property to get the full width of
    the component and subtract the padding. This will give us the full width of the
    area where we'd like to draw activity indicators, in pixels.
  prefs: []
  type: TYPE_NORMAL
- en: In the `projectTime` function, we will first transform the timestamp into a
    position by a simple rule of three. Because we have access to the timestamp of
    the first activity as well as the total time span, this will be quite a simple
    task. Once we do this, we can convert our position value, which is of unit pixels,
    into percentage, by dividing it by the total component width and then multiplying
    it by 100.
  prefs: []
  type: TYPE_NORMAL
- en: To project a pixel value back to a timestamp, we can do more or less the reverse
    of `projectTime`, except that we're not dealing with percentage here but assuming
    the length parameter of the `projectLength` function is in pixel unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve used some member variables—`timeFirst`, `timeLast`, and `timeSpan`—within
    our projection code, but how do we set these member variables? Since we have an
    `activities` component input, which is expected to be a list of relevant activities,
    we can observe the input for changes and set the values based on the input. To
    observe component input for changes, we can use the `ngOnChanges` life cycle hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to check whether the changes include changes to the `activities`
    input and that the current value of the input is valid. After checking for the
    input value, we can determine our member variables, namely `timeFirst`, `timeLast`,
    and `timeSpan`. We limit the `timeSpan` variable to `1` at least, as our projection
    calculations would be messed up otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code will ensure that we will always recalculate our member variables
    when the `activities` input changes and that we'd be using the most recent data-rendering
    activities.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering activity indicators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've already implemented the basics of the component and laid the groundwork
    for drawing time information into the coordinate system of our component. It's
    time to use our projection functions and draw our activities as indicators on
    the slider using SVG.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at the required template that we are going to create
    in a file called `activity-slider.html` within our `activity-slider` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Since we need to create an indicator for every activity within our activities
    list, we can simply use the `NgFor` directive to repeat the rectangle that represents
    our activity indicator.
  prefs: []
  type: TYPE_NORMAL
- en: As we know from building our `ActivityService` class in a previous topic, activities
    always contain a `time` field with the timestamp of the activity. Within our component,
    we have already created a projection function that converts time into percentage,
    relative to our component width. We can simply use the `projectTime` function
    within our attribute binding for the `x` attribute of the `rect` element to position
    our activity indicators at the correct positions.
  prefs: []
  type: TYPE_NORMAL
- en: By using only an SVG template and our backing function to project time, we have
    created a nice little chart that displays activity indicators on a timeline.
  prefs: []
  type: TYPE_NORMAL
- en: You can imagine that if we have a lot of activities, our slider will actually
    look pretty stuffed, and it will be hard to get a feeling for when those activities
    may have occurred. We need to have some sort of a grid that will help us associate
    the chart with a timeline.
  prefs: []
  type: TYPE_NORMAL
- en: As already shown in the mock-up of our slider component, we're now going to
    introduce some ticks on the slider background that will divide the slider into
    sections. We'll also label each tick with a calendar time. This will give our
    users a rough sense for time when looking at the activity indicators on the slider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the code changes within our `ActivitySlider` class that will
    enable the rendering of our ticks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we need to create a function that computes some ticks for us that
    we can place onto the timeline. For this purpose, we need to create the `computeTicks`
    method that will divide the whole timeline into five equal segments and generate
    timestamps that represent the position in time for individual ticks. We store
    these ticks in a new `ticks` member variable. With the help of these timestamps,
    we can render the ticks within our view easily.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use the `Array.from` ES6 function to create a new array with the desired
    length, and use the functional array extra function `map` to generate tick model
    objects from this array. Using `Array.from` is a nice trick to create an initial
    array of a given length that can be used to establish functional style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the template of our component and how we can use our array of
    timestamps to render ticks on our slider component. We''re going to modify our
    component template in `activity-slider.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To render our ticks, we've used an SVG group element to place our `NgFor` directive
    that repeats the tick timestamps we've stored in the `ticks` member variable.
  prefs: []
  type: TYPE_NORMAL
- en: For each tick, we need to place a label as well as a line that spans over the
    slider background. We can use the SVG text element to render our label with the
    timestamp on top of the slider. Within the attribute binding for the `x` attribute
    of our `text` element, we've used our `projectTime` projection function to receive
    the projected percentage value from our timestamp. The `y` coordinate of our `text`
    element is fixed at a position where the labels will just sit on top of our slider.
  prefs: []
  type: TYPE_NORMAL
- en: 'SVG lines consist of four coordinates: `x1`, `x2`, `y1`, and `y2`. Together
    they define two coordinate points where a line will be drawn from one point to
    the other.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we are getting closer to the final slider that we specified in the mock-up
    at the beginning of this topic. The last missing piece of the puzzle is to make
    our slider interactive so a user can select a range of activities.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing it to life
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we've covered the rendering of the slider background as well as the
    rendering of the activity indicators. We've also generated ticks and displayed
    them with a grid line and a label to display the calendar time of each tick.
  prefs: []
  type: TYPE_NORMAL
- en: Well, that does not really make a slider, does it? Of course, we also need to
    handle user input and make the slider interactive so users can select a time range
    they want to display the activities for.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, add the following changes to the component class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When we detect a change in the `activities` input property within the `ngOnChanges`
    life cycle hook, we initialize a model for the user selection in our slider component.
    It consists of a `start` and `end` property, both containing timestamps that represent
    the selected range on our activity slider.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've set our initial selection, we need to use the `selectionChange` output
    property to emit an event. This way, we can let our parent component know that
    the selection within the slider has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the selected range, we use an overlay rectangle within our template
    that will be placed above the slider background. If you look at the mock-up image
    of the slider again, you''ll notice that this overlay is painted in gray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This rectangle will be placed just above our slider background and will use
    our projection function to calculate the `x` and `width` attributes. As we need
    to wait for change detection to initialize our selection within the `ngOnChanges`
    life cycle hook, we'll just check for a valid selection object by making use of
    the `NgIf` directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to start tackling user input in our `ActivitySlider` component.
    The mechanics for storing the state and rendering our selection is already in
    place, so we can implement the required host listeners to handle user input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code excerpt, we handled a total of four events on the slider
    host element:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onMouseDown`: We set our selection model''s `start` and `end` properties with
    the same value. Since we''re using timestamps for these properties, we projected
    the mouse position into the timespace first. The mouse position comes in pixels
    relative to the slider component''s origin. Since we know the slider''s width
    and the total time duration displayed, we can convert this into timestamps easily.
    We''re using the `projectLength` method for this purpose. By passing a second
    argument to the `@HostListener` decorator, we specified that we''d like to pass
    the DOM event to our `onMouseDown` method. We also set a state flag, `modifySelection`,
    in our component to indicate that a selection is under progress.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onMouseMove`: If the component is in selection mode (the `modifySelection`
    flag is `true`), you can adjust the end property of the `selection` object. Here,
    we also made sure that we ruled out the possibility of creating a negative selection
    by using `Math.max` and limiting the end of the selection to not be smaller than
    the start.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onMouseUp`: When the user releases the mouse button, the component exits the
    selection mode. This can be done by setting the `modifySelection` flag to `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onMouseLeave`: This is the same as the `onMouseUp` event; the difference is
    that here the component will just exit the selection mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `@HostListener` decorator, we were able to handle all of the necessary
    user input to complete our component with the interactive elements that were still
    missing.
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this topic, we learned how to use SVG in order to create graphical and interactive
    components with Angular. By creating attribute bindings on our SVG elements and
    controlling the instantiation of graphical elements using the `NgFor` and `NgIf`
    directives, we built a custom slider component that provides a nice overview of
    our activities. At the same time, we also learned how to handle user input using
    the `@HostListener` decorator in order to make our component interactive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recap](img/image00327.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of the finished activity slider component
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum things up, we learned about the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating component views using `ViewEncapsulation.Native` and importing
    local styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Covering some basic projections of timestamps onto screen coordinates to be
    used with SVG elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling user input and creating a custom selection mechanism using the `@HostListener`
    decorator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the activity timeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've built a service to log activities and a slider component to select
    a time range and provide an overview using activity indicators. Since we needed
    to perform a lot of drawing tasks within the slider component, SVG was a perfect
    fit for this use case. To complete our `Activities` component tree, we still need
    to render the activities that were selected using the `ActivitySlider` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue to work on our activities component tree. Well create a new
    component that will be responsible for rendering an individual activity within
    an activity timeline. Let''s start with the template of the `Activity` component,
    which we will create in a new `activities/activity/activity.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Each activity will consist of a user image as well as an information box that
    will contain the activity title, message, and authoring details.
  prefs: []
  type: TYPE_NORMAL
- en: Our activity will use an input to determine its alignment. This allows us to
    align the activity from outside the component. The `isAlignedRight` method helps
    us set an additional CSS class, `activity__info--align-right`, on the activity
    information box.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to create a component class for our `Activity` component, which
    we will create under a new `activities/activity/activity.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Activity` component expects four inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`activity`: This property takes the data model of the activity that needs to
    be rendered with the component. This is the activity that we created using `ActivityService`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alignment`: This input property should be set to a string containing the word
    `left` or `right`. We used this to determine whether we needed to add an additional
    CSS class to our template in order to align the activity information box to the
    right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startMark`: This input property acts as an input and a host binding at the
    same time. If this input is set to `true`, the activity will get an additional
    CSS class, `activity--start-mark`, which will cause a small mark on top of the
    timeline to indicate the timeline termination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`endMark`: In the same way as `startMark`, this input uses a host binding to
    set an additional CSS class, `activity--end-mark`, which will cause a small mark
    on the bottom of the timeline to indicate the timeline termination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `isAlignedRight` method is used within the template to determine whether
    we need to add an additional CSS class to the information box in order to align
    it to the right.
  prefs: []
  type: TYPE_NORMAL
- en: We formatted the timestamp of the activity using the `FromNow` pipe, which we
    created in [Chapter 4](part0036.xhtml#aid-12AK82 "Chapter 4. No Comments, Please!"),
    *No Comments, Please!*. In order to use the pipe in the template, we need to import
    it and add it to the `pipes` property of our component annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have almost all the components to display our activities. But still,
    there''s something missing, which is the glue to combine `ActivitySlider` with
    our `Activity` components and also make our component subtree navigable. For this,
    we''ll create a new component called `Activities`. Let''s create an `activities/activities.js`
    file to write our component class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we need to know which activities we want to display within our
    component. For this, we need to provide a component input, namely `activitySubject`.
    Once this is done, we can pass an activity subject from the parent component and
    use it to filter activities we're interested in.
  prefs: []
  type: TYPE_NORMAL
- en: Since we've used activity subjects to log activities as well, we can use the
    same subjects to display activities. In the `ngOnChanges` life cycle hook, we
    set up a subscription on the `ActivityService` instance to react to newly created
    activities. Because the activity service will notify us with an updated list of
    activities, we can simply use the `Array.prototype.filter` function to filter
    only relevant items. We've made use of the `activitySubject` input to obtain the
    ID from the subject.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create a method to apply a date range filter to our activities.
    The `onSelectionChange` method will be called from our `activities` template,
    where we created a binding to our `ActivitySlider` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Whenever the time range is updated by the user within the slider, we'll override
    the `selectedActivities` member variable with a new filtered version of the activities,
    which we'd obtain from `ActivityService`. The filter will narrow down the activities
    by comparing the activity time against the selection range from the slider component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will set up some helper functions to be used within our template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The three methods, namely `getAlignment`, `isFirst`, and `isLast`, are used
    within the template as input for the `Activity` component. If you take a look
    at the code of `ActivityComponent` again, you will see that we need to provide
    some input in order to set some CSS classes for appearance. The three methods
    we created here will be used for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we added an `OnDestroy` life cycle hook that will unsubscribe us from
    the activity's change observable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template for this component is rather simple. The only thing we need to
    do is render the `ActivitySlider` component, as well as iterate over the selected
    activities and wire in the `Activity` component for each iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There's not much we need to explain here. We've bound `activities` and our `onSelectionChange`
    method to the slider component and iterated over all the selected activities to
    render our `Activity` components. We've created a local view variable, `index`,
    which we will use for the appearance input of the `Activity` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it for our activities page! We''ve created three components that are
    composed together and display an activity stream, which provides a slider to filter
    activities for dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the activity timeline](img/image00328.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of the finished activities view
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created an interactive slider component using SVG. While
    doing this, we learned about some SVG basics and the power of SVG within the DOM.
    Using Angular, we were able to make SVG composable, which it isn't by nature.
    We learned about namespaces, how Angular handles them, and how we can tell Angular
    that we'd like to use namespaces explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Besides using SVG for our slider component, we also learned how to use Shadow
    DOM to create native view encapsulation. As a result of this, we were able to
    use local styles for our component. We don't need to worry about CSS name clashes,
    specificity, and global CSS side effects any more when using local styles.
  prefs: []
  type: TYPE_NORMAL
- en: The whole code for this chapter can be found in the ZIP file of the book resources
    that you can download from the Packt Publishing website.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to enhance what we've built throughout the
    chapters so far. We will create some components to enrich the user experience
    within our application.
  prefs: []
  type: TYPE_NORMAL
