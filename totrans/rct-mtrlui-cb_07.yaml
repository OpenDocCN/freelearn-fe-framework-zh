- en: Tables - Display Complex Collection Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Stateful tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sortable columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering rows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting rows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Row actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your application needs to display tabular data, you can use the Material-UI `Table` component,
    along with all of its supporting components. Unlike grid components, which you
    might have seen or used in other React libraries, the Material-UI component is
    unopinionated. This means that you have to write your own code to control table
    data. On the plus side, the `Table` component stays out of your way and lets you
    implement things your own way.
  prefs: []
  type: TYPE_NORMAL
- en: Stateful tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With `Table` components, it's rare that you'll have static markup that defines
    the row data of the table. Instead, component state will map to the rows that
    make up your table data. For example, you might have a component that fetches
    API data that you want displayed in a table.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that you have a component that fetches data from an API endpoint.
    When the data loads, you want to display the tabular data in a Material-UI `Table`
    component. Here''s what the code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When you load the screen, you''ll see a table populated with data after one
    second:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2c62425-5743-4950-be34-ed1e5c408211.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by looking at the `fetchData()` function, which resolves the data
    that is eventually set as the component state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This function returns a `Promise` that resolves an array of objects after one
    second. The idea is to simulate a function that calls a real API using `fetch()`.
  prefs: []
  type: TYPE_NORMAL
- en: The objects shown in the array are truncated for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at the initial component state and what happens when your
    component is mounted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `items` state represents the table rows that are to be rendered within
    the `Table` component. When your component is mounted, the `fetchData()` call
    is made, and when the `Promise` resolves, the `items` state is set. Lastly, let''s
    look at the markup that''s responsible for rendering the table rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`Table` components typically have two children—a `TableHead` and a `TableBody`
    component. Inside `TableHead`, you''ll find a `TableRow` component with several
    `TableCell` components. These are the table column headings. Inside `TableBody`,
    you''ll see that the `items` state is mapped to `TableRow` and `TableCell` components.
    When the `items` state changes, the rows are changed too. You can already see
    this in action, because the `items` state defaults to an empty array. After the
    API data resolves, the `items` state changes and the rows are visible on the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One suboptimal aspect of this example is the user's experience while they wait
    for table data to load. Showing the column headers upfront is fine, since you
    know what they are ahead of time and the user might too. What's needed is some
    sort of indicator that the actual row data is, in fact, loading.
  prefs: []
  type: TYPE_NORMAL
- en: One way to fix this issue is to add a circular progress indicator underneath
    the column headers. This should help the user understand that not only are they
    waiting for data to load, but that it's the table row data specifically, thanks
    to the position of the progress indicator.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s introduce a new component for displaying a `CircularProgress`
    component along with some new styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There's a new `progress` style that's applied to the `CircularProgress` component.
    This adds `margin` to the progress indicator. The `textAlign` property has been
    added to the `root` style so that the progress indicator is horizontally centered
    within the `Paper` component. The `MaybeLoading` component renders the `CircularProgress`
    component if the `loading` property is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that you now have to keep track of the `loading` state of the API
    call. Here''s the new state, which defaults to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When the API call returns, you can set the `loading` state to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, you need to render the `MaybeLoading` component after the `Table` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what your users will see while waiting for the table data to load:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9ac9bca-e739-4648-a7f7-0d25e9151a05.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Table` API documentation: [https://material-ui.com/api/table/](https://material-ui.com/api/table/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sortable columns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Material-UI tables have tools that help you implement sortable columns. If you're
    rendering a `Table` component in your application, your users will likely expect
    to be able to sort the table data by column.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the users clicks on a column header, there should be a visual indication
    that table rows are now sorted by this column and the row order should change.
    When clicked on again, the column should appear in reverse order. Here''s the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you click on the Name column header, here''s what you''ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23804a51-b62d-4a73-a07c-5e549d9a7703.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The column changes to indicate the sort order. If you click on the name column
    again, the sort order will reverse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7bcc0a9-01fb-441b-acde-af3a58a60364.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s break down the code used to render this table, starting with the markup
    used to render the column headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Each column in the table is defined in the `columns` state. This array is mapped
    to `TableCell` components. Inside each `TableCell`, there''s a `TableSortLabel`
    component. This component makes the column header text bold when it''s the active
    column for sorting. It also adds the sort arrow to the right of the text. `TableSortLabel`
    takes `active`, `direction`, and `onClick` properties. The `active` property is
    based on the `active` state of the column, which changes when the column is clicked
    on. The `direction` property determines whether the rows are sorted in ascending
    or descending order for the given column. The `onClick` property takes an event
    handler that makes the necessary state changes when the column is clicked on.
    Here''s the `onSortClick()` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes an `index` argument—the column index—and returns a new
    function for the column. The returned function has two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: To update the column state so that the correct column is marked as active and
    that it has the correct sort direction
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To update the row state so that the table rows are in the correct order
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once these state changes have been made, the `active` column and the table
    rows will reflect them. The last piece of code to look at is the `comparator()`
    function. This is another higher-order function that takes the name of a column,
    and returns a new function that can be passed to `Array.sort()` to sort an array
    of objects by the given column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This function is generic enough that you can use it with any tables in your
    app. In this case, the column name and order are passed to `comparator()` from
    the component state. As the state of the component changes, so too does the sorting
    behavior in `comparator()`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if your data is already sorted by a particular column when it arrives from
    the API? If this is the case, you'll probably want to indicate which columns the
    rows are sorted by and in what direction, before the user starts interacting with
    the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, you just need to change the default column state. For example, let''s
    say that the Average column is sorted in descending order by default. Here''s
    what your initial `column` state would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The Average column is now active by default. You didn''t need to specify the
    order since the default is ascending. Here''s what the table looks like when the
    screen first loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be2b1f68-131e-4634-8711-ca17e96217cb.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Table` demos: [https://material-ui.com/demos/tables/](https://material-ui.com/demos/tables/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering rows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where there are tables, there's potential for too much information. This is
    why adding a search feature to your tables is a good idea. It allows the user
    to remove irrelevant rows from the table as they type.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that you have a table with lots of rows in it, meaning that the
    user is going to have a tough time scrolling through the entire table. To make
    things easier for them, you decide to add a search feature to your table that
    filters rows by checking whether the search text exists within the name column.
    Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the table and search input fields look like when the screen first
    loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12f6ec74-4c3e-4b8b-a651-3c6eb5fe6bb2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The search input is just above the table. Try typing in a filter string, such
    as Fourth—you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e635e51a-3080-441d-8d60-77bdb4aafb14.png)'
  prefs: []
  type: TYPE_IMG
- en: If you delete the filter text from the search input, all rows in the table data
    will be rendered again.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by looking at the state of the `FilteringRows` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The search string is the actual filter that changes the rows that are rendered
    within the `Table` element. Next, let''s look at the `TextField` component that
    renders the search input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `onSearchChange()` function is responsible for maintaining the search state
    as the user types. You should render the search input component close to the table
    that it filters. In this example, the position of the search input feels like
    it belongs to the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, let''s look at how the table rows are filtered and rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Instead of calling `map()` directly on the item's state, `filter()` is used
    to produce an array of items that match the search criteria. As the `search` state
    changes, the `filter()` call is repeated. The condition that checks whether the
    item matches what the user has typed checks to see whether the `name` property
    of the item contains the search string. But first, you have to make sure that
    the user is actually filtering. For example, if the search string is empty, every
    item should be returned. How the item is searched is specific to your application—you
    could search every item property if you wanted to.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Table` demos: [https://material-ui.com/demos/tables/](https://material-ui.com/demos/tables/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting rows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users often need to interact with specific rows in a table. For example, they
    might select a row and then perform an action that uses data from the selected
    row. Or, the user selects multiple rows, which produces new data related to their
    selection. With Material-UI tables, you can mark rows as selected using a single
    `TableRow` property.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, let''s assume that the user needs to be able to select multiple
    rows in your table. As rows are selected, another section on the screen is updated
    with data that reflects the selected rows. Let''s start by looking at the `Card`
    component, which displays data from the selected table rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the rest of the components now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the screen looks like when it first loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba4e04ff-17c3-4a51-9181-5e6890c3b8a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, you can try making some row selections. Here''s what you''ll see if you
    select the second and fourth rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa0fef0d-d84c-41b6-b2c3-0794937e2d56.png)'
  prefs: []
  type: TYPE_IMG
- en: When you click on a table row, it changes visually so that the user can see
    that it is selected. Also note that the `Card` component contents change to reflect
    the selected rows. It also tells you how many rows are selected.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Card` component relies on a few helper functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`selectedLow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selectedHigh`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selectedAverage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The return values of these functions change when the table row selection changes.
    Let''s take a closer look at how these values are computed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `selectedLow()` and `selectedHigh()` functions work the same way—they just
    operate on the `low` and `high` fields respectively. The `filter()` call is used
    to make sure that you're only working with selected rows. The `reduce()` call
    adds the values of the given field for the selected rows and returns the result
    as the property value. The `selectedAverage()` function uses the `selectedLow()`
    and `selectedHigh()` functions to compute a new average for the row selections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at the handler that''s called when a row is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onRowClick()` function finds the selected row in the `rows` state based
    on the `id` argument. Then, it toggles the selected state of the row. As a result,
    the computed properties that you just looked at are updated, and so is the appearance
    of the row itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `TableRow` component has a `selected` property, which changes the style
    of the row to mark it as selected.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Table` demos: [https://material-ui.com/demos/tables/](https://material-ui.com/demos/tables/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Row actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Table rows often represent an object that you can perform actions on. For example,
    you might have a table of servers where each row represents a server that can
    be turned on or off. Instead of making your users click a link that takes them
    away from the table to perform an action, you can include common actions directly
    in each table row.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say that you have a table with rows that have servers that can be turned
    on or off, depending on their current state. You want to include both of these
    actions as part of each table row, so that the user can more easily control their
    servers without spending lots of time navigating. The buttons also need to change
    their color and disabled state based on the state of the row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the screen looks like when it first loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35feccdc-ed17-4395-8cba-c7d2f7277c2c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Depending on the status of the row data, the action buttons will show differently.
    For example, in the first row, the start button is disabled because `status` is
    `running`. The second row has a disabled stop button because the `status` is `off`.
    Let''s try clicking on the stop button in the first row and the start button in
    the second row. Here''s how the UI changes once this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fa663ae-417c-4c41-8444-818dc9e94b9f.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by looking at the two components that are used as the row actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `StartButton` and `StopButton` components are very similar. Both of these
    components are rendered in every row of the table. There's the `onClick` property,
    a function that changes the state of the row data when clicked. The `color` of
    the icon changes based on the `status` of the row. Likewise, the `disabled` property
    changes based on the `status` of the row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at the `toggleStatus()` handler, which changes the status
    state of the row when an action button is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `StartButton` and `StopButton` components both use the same handler function—it
    toggles the `status` value between `running` and `off`. Finally, let''s look at
    the `TableCell` component where these `row` actions are rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The row data is passed as the `row` property. The `toggleStatus()` function
    takes a `row id` argument and returns a new handler function that acts on this
    row.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Table` demos: [https://material-ui.com/demos/tables/](https://material-ui.com/demos/tables/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
