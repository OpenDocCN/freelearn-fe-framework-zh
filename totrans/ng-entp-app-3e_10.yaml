- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Releasing to Production with CI/CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ship it or it never happened! If you don’t publish your code, you create zero
    value. This motivation to ship your work is prevalent in many industries. However,
    delivering a piece of work to someone else or opening it up to public scrutiny
    can be terrifying. In software engineering, delivering anything is difficult;
    delivering something to production is even more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out my 2018 talk, *Ship It or It Never Happened: The Power of Docker,
    Heroku, and CircleCI*, at [https://bit.ly/ship-it-or-it-never-happened](https://bit.ly/ship-it-or-it-never-happened).'
  prefs: []
  type: TYPE_NORMAL
- en: We live in an era of moving fast and breaking things. However, the latter part
    of that statement rarely works in an enterprise. You can live on the edge and
    adopt the YOLO lifestyle, but this doesn’t make good business sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_10_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: A creative CLI option for a tool'
  prefs: []
  type: TYPE_NORMAL
- en: In an enterprise project, code has to go through numerous quality gates before
    it can be merged. In this chapter, we will cover **Continuous Integration** (**CI**)
    pipelines leveraging GitHub flow and CircleCI, which help teams achieve frequent,
    reliable, high-quality, and flexible releases.
  prefs: []
  type: TYPE_NORMAL
- en: Frequent and reliable releases are only possible if we have a set of automated
    tests that can quickly verify the correctness of our code for us. Automated testing
    is critical to ensure your changes don’t introduce regressions. So, we will go
    over the importance of writing unit tests and **end-to-end** (**e2e**) tests with
    Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: To move fast without breaking things, we need to implement **Continuous Deployment**
    (**CD**) using DevOps best practices such as **Infrastructure as Code** (**IaC**),
    so we can verify the correctness of our running code more often.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover deploying Angular apps using CLI tools, then
    go over a Docker-based approach to implement IaC that can be run on most CI services
    and cloud providers, allowing you to achieve repeatable builds and deployments
    from any CI environment to any cloud provider. Working with flexible tools, you
    will avoid overspecializing in one service and keep your configuration management
    skills relevant across different CI services.
  prefs: []
  type: TYPE_NORMAL
- en: This book leverages CircleCI as the CI server. Other notable CI servers are
    Jenkins, Azure DevOps, and the built-in mechanisms within GitLab and GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers:'
  prefs: []
  type: TYPE_NORMAL
- en: Automated testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying to the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerizing web apps using Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with containers in the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code coverage reports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following software is required to follow along with this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Desktop Community version 4+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Engine CE version 24+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CircleCI account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vercel account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firebase account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coveralls account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the repositories linked in the following list. The repository contains the final
    and completed state of the code. Follow the instructions below to find out how
    to verify your progress as you go through the sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For *Chapter 10*:'
  prefs: []
  type: TYPE_NORMAL
- en: Clone the repositories [https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
    and [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm install` on the root folder to install dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`package.json` contains builds scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `.circleci` folder contains extra YAML files.
  prefs: []
  type: TYPE_NORMAL
- en: 'For **local-weather-app**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.circleci/config.stage4.yml` represents a simple CI pipeline.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.circleci/config.stage9.yml` adds CD with target deployment to Vercel.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.circleci/config.yml` shows an advanced pipeline with parallel builds and
    automated Cypress tests.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For **lemon-mart**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.circleci/config.stage9.yml` adds CD with target deployment to Vercel.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.circleci/config.docker-integration.yml` demonstrates a container within a
    container setup with multi-stage Dockerfiles and an AWS ECS Fargate deployment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.circleci/config.yml` shows an advanced pipeline with parallel builds and
    automated Cypress tests.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Beware that the source code provided in the book and the version on GitHub will
    likely differ. Cloud services are ever-evolving and changing. If you find errors
    or have questions, please create an issue or submit a pull request on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s understand why automated testing is critical to delivering quality
    solutions via CI/CD pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Automated testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As developers, we integrate code from various sources into our solutions. This
    can be from coffee-fueled, long, and tiring code sessions, a copy-pasted StackOverflow
    answer, a snippet from a blog post, an npm package, or a major library like Angular.
    We are expected to deliver quality results within the confines of an estimate
    we threw out there. In these conditions, bugs inevitably end up in our code. When
    deadlines, ambition, or ill-fated architectural decisions intersect with the regular
    cadence of coding, things only get worse.
  prefs: []
  type: TYPE_NORMAL
- en: Automated tests ensure that the code we write is correct and it stays correct.
    We rely on CI/CD pipelines for repeatable processes that are not prone to human
    error, but the pipeline is only as good as the quality of the automated tests
    we write.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular has two main categories of tests, unit and e2e tests. Unit tests are
    meant to be fast and easy to create and execute, and e2e tests are slower and
    more expensive. However, there’s a problem: Angular unit tests are not unit tests.'
  prefs: []
  type: TYPE_NORMAL
- en: To understand why, we need a deep dive into unit testing fundamentals to familiarize
    you with the benefits of test-driven development and cover principles like FIRST
    and SOLID.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit testing is crucial to ensure that the behavior of your application doesn’t
    unintentionally change over time. Unit tests will enable you and your team to
    continue making changes to your application without introducing changes to previously
    verified functionality. Developers write unit tests, where each test is scoped
    to test only the code in the **Function Under Test** (**FUT**) or **Class Under
    Test** (**CUT**). Unit tests should be plentiful, automated, and fast. You should
    write unit tests alongside the original code. If they are separated from the implementation,
    even by a day or two, you will start forgetting the details of your code. Because
    of that, you may forget to write tests for potential edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit tests should adhere to the FIRST principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '**F**ast'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**solated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**R**epeatable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**S**elf-verifying'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**T**imely'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unit test should be fast, taking only milliseconds to run, so we can have
    thousands of them running in just a few minutes. For fast tests to be possible,
    a unit test should be isolated. It shouldn’t talk to a database, make requests
    over the network, or interact with the DOM. Isolated tests are going to be repeatable
    so that every run of the test returns the same result. Predictability means we
    can assert the correctness of a test without relying on any outside environment,
    which makes our tests self-verifying. As mentioned earlier, you should write unit
    tests promptly; otherwise, you lose the benefits of writing unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to adhere to the FIRST principle if your tests focus only on
    a single FUT/CUT. But what about other classes, services, or parameters we must
    pass into the FUT/CUT? A unit test can isolate the behavior of the FUT/CUT by
    leveraging test doubles. A test double allows us to control outside dependencies,
    so instead of injecting an `HttpService` to your component, you may inject a fake
    or mocked `HttpService`. Using test doubles, we can control the effects of outside
    dependencies and create fast and repeatable tests.
  prefs: []
  type: TYPE_NORMAL
- en: How much testing is enough testing? You should have at least as much test code
    as production code. If you don’t, then you’re nowhere near writing enough tests.
  prefs: []
  type: TYPE_NORMAL
- en: See the *Further reading* section for literature going back 20+ years on this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit tests aren’t the only kind of tests you can create, but they are by far
    the kind you should create the most of. Consider the three kinds of tests you
    can create: unit, integration, and UI.'
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve said, unit tests only focus on one FUT/CUT at a time. Integration tests
    test the integration of various components so that they can include database calls,
    network requests, and interaction with the DOM. Due to their nature, integration
    tests are slow to run and must be frequently maintained. Increases in runtime
    and maintenance mean that integration tests are more expensive than unit tests
    over time. UI tests test the application as if a user were using it, filling in
    fields, clicking buttons, and observing the expected outcome.
  prefs: []
  type: TYPE_NORMAL
- en: You may imagine that these tests are the slowest and most fragile kind of tests.
    The UI of an application changes frequently, and it is very tough to create repeatable
    tests with UI testing.
  prefs: []
  type: TYPE_NORMAL
- en: We can leverage integration and UI testing to create acceptance tests. Acceptance
    tests are written to automate the business acceptance of our functionality. Angular’s
    e2e tests are a way to create acceptance tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can visualize the pros and cons of the three major classes of automated
    testing with Mike Cohn’s testing pyramid, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, screenshot, font, design  Description automatically
    generated](img/B20960_10_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Mike Cohn’s testing pyramid'
  prefs: []
  type: TYPE_NORMAL
- en: The testing pyramid effectively summarizes the relative amount of tests of each
    kind we should create for our applications while considering their speed and cost.
  prefs: []
  type: TYPE_NORMAL
- en: Given the description and expectations of unit tests, you can now begin understanding
    why **Angular unit tests are not really unit tests**. As I explained in the *Component
    architecture* section of *Chapter 1*, *Angular’s Architecture and Concepts*, an
    Angular component consists of a component class and a template. To truly test
    a component, we must interact with the DOM. This is why Angular tests must utilize
    `TestBed` to execute. Further, the dependency injection can be very cumbersome
    to configure and mock. Ultimately, `TestBed` is slow and fragile compared to true
    unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Consider using Spectator to simplify your Angular tests. Spectator aims to help
    you get rid of all the boilerplate grunt work, focusing on readable and streamlined
    unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: More info can be found at [https://github.com/ngneat/spectator](https://github.com/ngneat/spectator).
  prefs: []
  type: TYPE_NORMAL
- en: Standalone components are much easier to configure because they define their
    dependencies, and we no longer need to introduce modules to `TestBed`.
  prefs: []
  type: TYPE_NORMAL
- en: What does all this mean for Angular? Within this reality, unit testing a component
    is a waste of time. You should extract all business logic into services and functions
    and test those thoroughly. Hopefully, future updates to the Angular unit testing
    setup will change this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress component tests are a great way to integration test individual components’
    functionality. Follow the instructions in the next section to set Cypress up for
    your project.
  prefs: []
  type: TYPE_NORMAL
- en: More information about component testing is at [https://docs.cypress.io/guides/component-testing/angular/overview](https://docs.cypress.io/guides/component-testing/angular/overview).
  prefs: []
  type: TYPE_NORMAL
- en: 'Beginning with Angular 17.1, you can swap out the Karma test runner with the
    modern **Web Test Runner**. You can set it up with the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `angular.json` with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can read more at [https://modern-web.dev/docs/test-runner/overview](https://modern-web.dev/docs/test-runner/overview).
  prefs: []
  type: TYPE_NORMAL
- en: To test UI and template logic, Angular e2e tests will deliver the best bang
    for the buck, and now you can configure Cypress as the default e2e provider for
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress e2e tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While unit tests focus on isolating the CUT, e2e tests are about integration
    testing. I highly recommend that you configure Cypress as your e2e provider by
    executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can read more about the Cypress integration at [https://www.npmjs.com/package/@cypress/schematic](https://www.npmjs.com/package/@cypress/schematic).
  prefs: []
  type: TYPE_NORMAL
- en: Cypress allows you to easily create tests for your modern web applications,
    debug them visually, and automatically run them in your CI builds. You can read
    more about Cypress at [https://www.cypress.io/](https://www.cypress.io/).
  prefs: []
  type: TYPE_NORMAL
- en: e2e tests allow you to write **Automated Acceptance Tests** (**AATs**) from
    the perspective of a user interacting with your application in a browser. Cypress
    tests are easy to create and run. By using the `data-testid` attribute on HTML
    components, you can make them less fragile.
  prefs: []
  type: TYPE_NORMAL
- en: You can find sample Cypress tests for **local-weather-app** and **lemon-mart**
    under the `cypress` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can execute the tests in development by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For CI, you can use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In `local-weather-app`, check out the `cypress/e2e/app.cy.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `cypress/support/commands.ts` `file`, I implemented a helper function
    called `byTestId`, which finds an HTML element containing the `data-testid` attribute
    with the given name. In this case, `cy.byTestId("title")` will find the following
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The test will work even if the element moves around on the page. Using test
    IDs makes it easy and convenient to write more dependable tests.
  prefs: []
  type: TYPE_NORMAL
- en: Building robust and maintainable e2e code requires some additional concepts
    like Page Objects. You can learn more about Page Objects at [https://docs.cypress.io/guides/end-to-end-testing/protractor-to-cypress#Using-Page-Objects](https://docs.cypress.io/guides/end-to-end-testing/protractor-to-cypress#Using-Page-Objects)
    and other best practices at [https://docs.cypress.io/guides/references/best-practices](https://docs.cypress.io/guides/references/best-practices).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s set up CI to ensure that our tests always run before we deploy the
    app to production.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before pushing your code to production, you should enable CI. This simple tool
    helps ensure we don’t ship broken code to production by executing automated tasks,
    including the execution of tests, every time we make changes to our code.
  prefs: []
  type: TYPE_NORMAL
- en: CircleCI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CircleCI** makes it easy to get started, with a free tier and excellent documentation
    for beginners and pros alike. If you have unique enterprise needs, CircleCI can
    be brought on-premises, behind corporate firewalls, or as a private deployment
    in the cloud.'
  prefs: []
  type: TYPE_NORMAL
- en: 'CircleCI has pre-baked build environments for the virtual configuration of
    free setups, but it can also run builds using Docker containers, making it a solution
    that scales to the user’s skills and needs:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a CircleCI account at [https://circleci.com/](https://circleci.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Projects** to add a new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `local-weather-app` and click on **Set Up Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the on-screen prompts to create a sample `.yml` file. Hello World or
    Node.js works, but you will replace the content anyway.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This section uses the **local-weather-app** repo. The `config.yml` file for
    this section is named `.circleci/config.stage4.yml`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Copy the following `.yml` content into the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Select **Commit** and **Run**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CircleCI should run on a new branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If everything goes well, you should have a passing, *green* build. If not, you
    will see a failed, *red* build.
  prefs: []
  type: TYPE_NORMAL
- en: When you have a green build, you can leverage CircleCI to enforce the execution
    of your automated pipeline with every code push. GitHub flow allows us to control
    how code flows into our repositories.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main reason we’re developing software is to deliver value. In automating
    the way we deliver software, we are creating a value delivery stream. It is easy
    to deliver broken software; however, to reliably deliver value, each change to
    the code base should flow through a stream of checks and balances.
  prefs: []
  type: TYPE_NORMAL
- en: With control gates, we can enforce standards, make our quality control process
    repeatable for every team member, and have the ability to isolate changes. If
    something goes wrong or the work doesn’t live up to your standards, you can easily
    discard the proposed changes and restart.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub flow is an essential part of defining a value delivery stream and implementing
    control gates. As GitHub puts it, “*GitHub flow is a lightweight, branch-based
    workflow that supports teams and projects where deployments are made regularly*.”
  prefs: []
  type: TYPE_NORMAL
- en: 'GitHub flow consists of six steps, as shown in the following graphic from GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_10_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: GitHub flow diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '**Branch** – always add new code for a bug or a feature in a new branch'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Commit** – make multiple commits to your branch'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Create a pull request** – signal the readiness of your work to your team
    members and view CI results in a pull request'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Discuss and review** – request a review of your code changes, address general
    or line-level comments, and make necessary modifications'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Deploy** – optionally test your code on a test server or staging server with
    the ability to roll back to the main branch'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Merge** – apply your changes to the main branch'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use GitHub flow to ensure that only high-quality code ends up in the
    main branch. A solid foundation sets other team members up for success when making
    changes. You must restrict push access to the main branch to enforce GitHub flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s enable branch protection for the main branch:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the GitHub **Settings** tab for your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Branches** from the left navigation pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a rule exists for your main branch, click the **Edit** or **Add rule** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `main` as the branch name pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enable the following options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Require a pull request before merging.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Require approvals from at least one peer.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Dismiss stale pull request approvals.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Require status checks to pass before merging.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Require branches to be up to date before merging.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Require linear history.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Search for `CircleCI` and select the CI job that must succeed, in this case:
    `run_build_and_test`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you’ve saved your changes, you should see your new rule on the **Branches**
    page as shown:![A screenshot of a computer  Description automatically generated](img/B20960_10_04.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.4: GitHub Branches'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You are no longer able to commit code to your main branch directly. To commit
    code, you first need to create a branch from the main branch, commit your changes
    to the new branch, and create a pull request using the new branch when you’re
    ready. If you’re unfamiliar with `git` commands, you can use GitHub Desktop to
    assist you with these operations. See the handy **Branch** menu in GitHub Desktop
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_10_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: GitHub Desktop Branch menu'
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating a pull request, you can now observe checks running against your
    branch. Now that we have CircleCI configured, if everything went well, you should
    be able to merge a pull request, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_10_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: GitHub.com status checks passing'
  prefs: []
  type: TYPE_NORMAL
- en: When the checks fail, you are forced to fix any issues before you can merge
    the new code. Also, you may run into merge conflicts if a team member merged to
    the main branch while you were working on your branch. In this case, you may use
    GitHub Desktop’s **Update from master** feature for your branch to catch up with
    the latest main branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe the state of a failing pull request in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_10_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: GitHub.com status checks failing'
  prefs: []
  type: TYPE_NORMAL
- en: Note that I have an additional check, DeepScan, which runs additional tests
    against my code base. You can register your repository with DeepScan at [https://deepscan.io](https://deepscan.io).
    Later in the chapter, I demonstrate how you can enforce unit test code coverage
    using Coveralls.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, refer to [https://guides.github.com/introduction/flow](https://guides.github.com/introduction/flow).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have ensured that our automated checks are being enforced, we can
    be reasonably sure that we won’t push a broken app to production. Next, let’s
    learn how we can deploy our app to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to the cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If delivering something to production is difficult from a coding perspective,
    it is very complicated to do it right from an infrastructure perspective. Deploying
    solutions in the full-fledged versions of Azure, AWS, and Google Cloud is complicated.
    To deliver quick results, we can leverage cloud services that can serve the `dist`
    folder of our Angular app within minutes.
  prefs: []
  type: TYPE_NORMAL
- en: One such service is Vercel, and another is Firebase, which can leverage the
    `ng deploy` command.
  prefs: []
  type: TYPE_NORMAL
- en: Vercel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vercel, [https://vercel.com](https://vercel.com), is a multi-cloud service that
    enables real-time global deployments of applications directly from the CLI. Vercel
    works with static files, Node.js, PHP, Go applications, and any custom stack of
    software you’re willing to write a custom builder for, making it quite straightforward.
    Vercel has a free tier that you can use to deploy the `dist` folder of your Angular
    applications very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `vercel` package to your project and run the `login` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Follow the on-screen prompts to complete the login process. Now, let’s configure
    the `publish` script.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying static files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After you build an Angular project, the build output resides in the `dist` folder.
    The files in this folder are considered static files; all a web server needs to
    do is deliver these files to a client browser, unmodified, and then the browser
    executes your code dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: This means that any web server can serve up your Angular project. However, `vercel`
    makes it exceedingly easy and free to pull off.
  prefs: []
  type: TYPE_NORMAL
- en: This section uses the **local-weather-app** repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin deploying your Angular app using Vercel’s static file hosting capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add two new scripts to `package.json`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Execute `npm run vercel:publish`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the on-screen commands to accept first-use settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the terminal window, observe that the Angular project is built first and
    then uploaded to `vercel`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Follow the URL displayed on the screen to see that your app has been successfully
    deployed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And you’re done! Congratulations, your Angular app is live on the internet!
  prefs: []
  type: TYPE_NORMAL
- en: Firebase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firebase, [https://firebase.google.com/](https://firebase.google.com/), is an
    app development platform that helps you build and grow apps and games users love.
    It is backed by Google and trusted by millions of businesses around the world.
  prefs: []
  type: TYPE_NORMAL
- en: In the Firebase authentication recipe section of *Chapter 6*, *Implementing
    Role-Based Navigation*, you created a Firebase app for LemonMart and deployed
    your app using **firebase deploy**. We will leverage the account you created to
    deploy LemonMart to Firebase hosting using the new `ng` `deploy` command instead.
  prefs: []
  type: TYPE_NORMAL
- en: ng deploy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ng` `deploy` is a new CLI command that helps cloud services offer seamless
    integration with Angular, so you can easily deploy your app to the cloud.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s configure the LemonMart project using `@angular/fire`.
  prefs: []
  type: TYPE_NORMAL
- en: This section uses the **lemon-mart** repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command and make sure to select `ng` `deploy` -- `hosting`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will create a `deploy` configuration in `angular.json` and add or update
    existing Firebase configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: 'For LemonMart, I modified `angular.json` so it would automatically build using
    the Firebase authentication mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The Firebase configuration is defined under the **Configurations** options,
    and it uses `environment.firebase.ts` to build the app.
  prefs: []
  type: TYPE_NORMAL
- en: I also modified `firebase.json` to deploy `dist/lemon-mart`, because the repository
    is configured as a multi-project Angular app. However, you shouldn’t need to modify
    the auto-generated files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command to deploy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Follow the URL on the screen to see that your app has been successfully deployed.
  prefs: []
  type: TYPE_NORMAL
- en: '`ng` `deploy` offers a better integrated and simpler option compared to using
    platform-specific CLI commands. Working with CLI commands is great, but one command
    that works on one machine can easily fail on another. IaC is the only way high-performing
    enterprise teams can deliver high-quality code with speed. However, to get there,
    we first need to understand what DevOps is.'
  prefs: []
  type: TYPE_NORMAL
- en: DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DevOps is the marriage of development and operations. It is well established
    for development that code repositories like Git track every code change. In operations,
    there has long been a wide variety of techniques to track changes to environments,
    including scripts and various tools that aim to automate the provisioning of operating
    systems and servers.
  prefs: []
  type: TYPE_NORMAL
- en: How often have you heard the saying, “It works on my machine”? Developers often
    use that line as a joke. Still, it is often the case that software that works
    perfectly well on a test server ends up running into issues on a production server
    due to minor differences in configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, we discussed how GitHub flow can enable us to create a value delivery
    stream. We always branch from the main branch before making a change, enforce
    that change to go through our CI pipeline, and, once we’re reasonably sure that
    our code works, merge back to the main branch. See the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A line of dots and lines with a black background  Description automatically
    generated](img/B20960_10_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Branching and merging'
  prefs: []
  type: TYPE_NORMAL
- en: Remember, your main branch should always be deployable, and you should frequently
    merge your work with the main branch.
  prefs: []
  type: TYPE_NORMAL
- en: Docker allows us to define the software and the specific configuration parameters
    that our code depends on in a declarative manner using a special file named a
    Dockerfile. Similarly, CircleCI allows us to define the configuration of our CI
    environment in a `config.yml` file. By storing our configuration in files, we
    can check the files alongside our code. We can track changes using Git and enforce
    them to be verified by our CI pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: By storing the definition of our infrastructure in code, we achieve IaC, we
    also achieve repeatable integration, so no matter what environment we run our
    infrastructure in, we should be able to stand up our full-stack app with a one-line
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may remember that in *Chapter 1*, *Angular’s Architecture and Concepts*,
    we covered how TypeScript covers the JavaScript feature gap. Like TypeScript,
    Docker covers the configuration gap, as demonstrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a diagram  Description automatically generated](img/B20960_10_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Covering the configuration gap'
  prefs: []
  type: TYPE_NORMAL
- en: By using Docker, we can be reasonably sure that our code, which worked on our
    machine during testing, will work the same way when we ship it.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, DevOps brings operations closer to development, where it is cheaper
    to make changes and resolve issues. So, DevOps is primarily a developer’s responsibility,
    but it is also a way of thinking that the operations team must be willing to support.
    Let’s dive deeper into Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Containerizing web apps using Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker, which can be found at [https://docker.io](https://docker.io), is an
    open platform for developing, shipping, and running applications. Docker combines
    a lightweight container virtualization platform with workflows and tooling that
    help manage and deploy applications. The most obvious difference between **Virtual
    Machines** (**VMs**) and Docker containers is that VMs are usually dozens of gigabytes
    in size and require gigabytes of memory, whereas containers take up megabytes
    in terms of disk and memory size requirements. Furthermore, the Docker platform
    abstracts away host **Operating System** (**OS**)-level configuration settings,
    so every piece of configuration that is needed to successfully run an application
    is encoded within a human-readable format.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a Dockerfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Dockerfile consists of four main parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**FROM** – where we can inherit from Docker’s minimal “scratch” image or a
    pre-existing image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SETUP** – where we configure software dependencies to our requirements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**COPY** – where we copy our built code into the operating environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CMD** – where we specify the commands that will bootstrap the operating environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrap refers to a set of initial instructions that describe how a program
    loads or starts up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following visualization of the anatomy of a Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer program  Description automatically generated](img/B20960_10_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: Anatomy of a Dockerfile'
  prefs: []
  type: TYPE_NORMAL
- en: 'A concrete representation of a Dockerfile is demonstrated in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can map the `FROM`, `COPY`, and `CMD` parts of the script to the visualization.
    We inherit from the `duluca/minimal-nginx-web-server` image using the `FROM` command.
    Then, we copy the compiled result of our app from our development machine or build
    environment into the image using the `COPY` (or, alternatively, the `ADD`) command.
    Finally, we instruct the container to execute the nginx web server using the `CMD`
    (or, alternatively, the `ENTRYPOINT`) command.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the preceding `Dockerfile` doesn’t have a distinct `SETUP` part. `SETUP`
    doesn’t map to an actual `Dockerfile` command but represents a collection of commands
    you can execute to set up your container. In this case, all the necessary setup
    was done by the base image, so there are no additional commands to run.
  prefs: []
  type: TYPE_NORMAL
- en: Common `Dockerfile` commands are `FROM`, `COPY`, `ADD`, `RUN`, `CMD`, `ENTRYPOINT`,
    `ENV`, and `EXPOSE`. For the full `Dockerfile` reference, refer to [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Dockerfile` describes a new container that inherits from a container named
    `duluca/minimal-nginx-web-server`. This is a container that I published on Docker
    Hub, which inherits from the `nginx:alpine` image, which itself inherits from
    the `alpine` image. The `alpine` image is a minimal Linux operating environment
    that is only 5 MB in size. The `alpine` image itself inherits from `scratch`,
    which is an empty image. See the inheritance hierarchy demonstrated in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer screen  Description automatically generated](img/B20960_10_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.11: Docker inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Dockerfile` then copies the contents of the `dist` folder from your development
    environment into the container’s `www` folder, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_10_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.12: Copying code into a containerized web server'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the parent image is configured with an `nginx` server to act
    as a web server to serve the content inside the `www` folder. At this point, our
    source code is accessible from the internet but lives inside layers of secure
    environments. Even if our app has a vulnerability of some kind, it would be tough
    for an attacker to harm the systems we are operating on. The following diagram
    demonstrates the layers of security that Docker provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a software development  Description automatically generated
    with medium confidence](img/B20960_10_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.13: Docker security'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, at the base layer, our host OS, such as Windows or macOS, runs the
    Docker runtime, which will be installed in the next section. The Docker runtime
    can run self-contained Docker images, which the aforementioned Dockerfile defines.
    `duluca/minimal-nginx-web-server` is based on the lightweight Linux operating
    system, Alpine. Alpine is a completely pared-down version of Linux that doesn’t
    come with any GUI, drivers, or even most of the CLI tools you may expect from
    a Linux system. As a result, the OS is only ~5 MB in size. We then inherit from
    the `nginx` image, which installs the web server, which itself is around a few
    megabytes in size. Finally, our custom `nginx` configuration is layered over the
    default image, resulting in a tiny ~7 MB image. The `nginx` server is configured
    to serve the contents of the `/var/www` folder. In the `Dockerfile`, we merely
    copy the contents of the `/dist` folder in our development environment and place
    it into the `/var/www` folder. We will later build and execute this image, which
    will run our `nginx` web server containing the output of our `dist` folder. I
    have published a similar image named `duluca/minimal-node-web-server`, which clocks
    in at ~15 MB.
  prefs: []
  type: TYPE_NORMAL
- en: '`duluca/minimal-node-web-server` can be more straightforward to work with,
    especially if you’re not familiar with `nginx`. It relies on an `Express.js` server
    to serve static content. Most cloud providers provide concrete examples using
    Node and Express, which can help you narrow down any errors. In addition, `duluca/minimal-node-web-server`
    has HTTPS redirection support baked into it. You can spend a lot of time trying
    to set up an `nginx` proxy to do the same thing when all you need to do is set
    the `ENFORCE_HTTPS` environment variable in your `Dockerfile`. See the following
    sample Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can read more about the options `minimal-node-web-server` provides at `https://github.com/duluca/minimal-node-web-server`.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve now seen, the beauty of Docker is that you can navigate to [https://hub.docker.com](https://hub.docker.com),
    search for `duluca/minimal-nginx-web-server` or `duluca/minimal-node-web-server`,
    read its `Dockerfile`, and trace its origins all the way back to the original
    base image that is the foundation of the web server. I encourage you to vet every
    Docker image you use in this manner to understand what exactly it brings to the
    table for your needs.
  prefs: []
  type: TYPE_NORMAL
- en: You may either find it overkill or that it has features you never knew about
    that can make your life a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the parent images should pull a specific tag of `duluca/minimal-nginx-web-server`,
    which is `1-alpine`. Similarly, `duluca/minimal-node-web-server` pulls from `lts-alpine`.
    These evergreen base packages always contain the latest version 1 of `nginx` and
    Alpine or an LTS release of Node. In Docker Hub, I have pipelines to automatically
    update both images when a new base image is published. So, you will get the latest
    bug fixes and security patches whenever you pull these images.
  prefs: []
  type: TYPE_NORMAL
- en: Having an evergreen dependency tree removes the burden on you as the developer
    to hunt down the latest version of a Docker image. Alternatively, if you specify
    a version number, your images will not be subject to any potential breaking changes.
    However, it is better to remember to test your images after a new build than never
    update your image and, potentially, deploy compromised software. After all, the
    web is ever-changing and will not slow down for you to keep your images up to
    date.
  prefs: []
  type: TYPE_NORMAL
- en: Just like npm packages, Docker can bring great convenience and value, but you
    must take care to understand the tools you are working with.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to build and run containers, you must first install the Docker execution
    environment on your computer. You can download Docker Desktop at [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).
    Follow the instructions on the screen to complete the installation.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up npm scripts for Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s configure some Docker scripts for your Angular apps that you can
    use to automate your container’s building, testing, and publishing. I have developed
    a set of scripts called **npm scripts for Docker** that works on Windows 10 and
    macOS. You can get the latest version of these scripts and automatically configure
    them in your project by executing the following command.
  prefs: []
  type: TYPE_NORMAL
- en: Run the following command on both the **local-weather-app** and **lemon-mart**
    projects now!
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the npm scripts for Docker task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: After you execute the `mrm` scripts, we’re ready to take a deep dive into the
    configuration settings using the Local Weather app as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Building and publishing an image to Docker Hub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, let’s ensure that your project is configured correctly so we can containerize
    it, build an executable image, and publish it to Docker Hub, allowing us to access
    it from any build environment.
  prefs: []
  type: TYPE_NORMAL
- en: This section uses the **local-weather-app** repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign up for a Docker Hub account at [https://hub.docker.com/](https://hub.docker.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a public (free) repository for your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `package.json`, add or update the `config` property with the following configuration
    properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`namespace` will be your Docker Hub username. You will define what your repository
    will be called during creation. An example image `repository` variable should
    look like `duluca/localcast-weather`. The image name is for easy identification
    of your container while using Docker commands such as `docker ps`. I will just
    call mine `localcast-weather`. The `imagePort` property will define which port
    should be used to expose your application from inside the container. Since we
    use port `4200` for development, pick a different one, like `8080`. `internalContainerPort`
    defines the port that your web server is mapped to. This will mostly be port `3000`
    for Node servers and, for `nginx` servers, `80`. Refer to the documentation of
    the base container you’re using.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s review the Docker scripts added to `package.json` by the `mrm` task from
    earlier. The following section presents an annotated version of the scripts added,
    explaining each entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that with `npm` scripts, the `pre` and `post` keywords are used to execute
    helper scripts before or after executing a given script. Scripts are intentionally
    broken into smaller pieces to make them easier to read and maintain.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `build` script is as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note that the following `cross-conf-env` command ensures the script executes
    equally well in macOS, Linux, and Windows environments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`npm run docker:build` will build your Angular application in the `pre` script,
    then build the Docker image using the `docker image build` command, and tag the
    image with a version number in the `post` script.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In my project, the `pre` command builds my Angular application in `prod` mode
    and runs a test to ensure that I have an optimized build with no failing tests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'My `pre` command looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `tag` script is as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`npm run docker:tag` will tag an already built Docker image using the version
    number from the `version` property in `package.json` and the latest tag.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `stop` script is as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`npm run docker:stop` will stop the image if it’s currently running, so the
    `run` script can execute without errors.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `run` script is as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `run-s` and `run-p` commands ship with the `npm-run-all` package
    to synchronize or parallelize the execution of npm scripts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`npm run docker:run` will stop if the image is already running, and then run
    the newly built version of the image using the `docker run` command. Note that
    the `imagePort` property is used as the external port of the Docker image, which
    is mapped to the internal port of the image that the Node.js server listens to,
    port `3000`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `publish` script is as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note that `docker:tag` adds the latest version tag on the container. When we
    push the latest tags, both tags get pushed simultaneously.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`npm run docker:publish` will publish a built image to the configured repository,
    in this case, Docker Hub, using the `docker image push` command.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, the versioned image is published, followed by one tagged with `latest`
    in `post`. The `taillogs` script is as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`npm run docker:taillogs` will display the internal console logs of a running
    Docker instance using the `docker log -f` command, a useful tool for debugging
    your Docker instance.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `open` script is as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`npm run docker:open` will wait for 2 seconds, accounting for latency, and
    then launch the browser with the correct URL for your application using the `imagePort`
    property.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `debug` script is as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`npm run docker:debug` will build your image and run an instance of it in `pre`,
    open the browser, and then start displaying the internal logs of the container.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Customize the pre-build script to build your angular app in production mode
    and execute unit tests before building the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that `ng build` is provided with the `--prod` argument, which achieves
    two things: the size of the app is optimized to be significantly smaller with
    **Ahead-of-Time** (**AOT**) compilation to increase runtime performance, and the
    configuration items defined in `src/environments/environment.prod.ts` are used.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update `src/environments/environment.prod.ts` to look like you’re using your
    own `appId` from `OpenWeather`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are modifying how `npm test` is executed, so the tests are run only once
    and the tool stops executing. The `--watch=false` option is provided to achieve
    this behavior, as opposed to the development-friendly default continuous execution
    behavior.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new file named `Dockerfile` with no file extensions in the project
    root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement or replace the contents of the `Dockerfile`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Be sure to inspect the contents of your `dist` folder to ensure you’re copying
    the correct folder, which contains the `index.html` file at its root.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Execute `npm run predocker:build` and see that it runs without errors in the
    Terminal to ensure that your application changes have been successful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm run docker:build` and see that it runs without errors in the Terminal
    to ensure that your image builds successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While you can run any of the provided scripts individually, you really only
    need to remember two of them going forward:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm run docker:debug` will test, build, tag, run, tail, and launch your containerized
    app in a new browser window for testing.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm run docker:publish` will publish the image you just built and test to
    the online Docker repository.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Execute `docker:debug` in your Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A successful `docker:debug` run should result in a new in-focus browser window
    with your application and the server logs being tailed in the Terminal, as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: You should always run `docker ps` to check whether your image is running, when
    it was last updated, and whether it clashes with any existing images claiming
    the same port.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute `docker:publish` in your Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should observe a successful run in the Terminal window like this:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Over time, your local Docker cache may grow significantly; for example, it’s
    reached roughly 40 GB on my laptop over two years. You can use the `docker image
    prune` and `docker container prune` commands to reduce your cache size. For more
    detailed information, refer to the documentation at [https://docs.docker.com/config/pruning](https://docs.docker.com/config/pruning).
  prefs: []
  type: TYPE_NORMAL
- en: By defining a `Dockerfile` and scripting our use of it, we created living documentation
    in our code base. We have achieved DevOps and closed the configuration gap.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to containerize **lemon-mart** like you’ve done with **local-weather-app**
    and verify your work by executing `npm run docker:debug`.
  prefs: []
  type: TYPE_NORMAL
- en: VS Code offers a visual way to interact with npm scripts. Let’s take a look
    at VS Code’s npm script support next.
  prefs: []
  type: TYPE_NORMAL
- en: npm scripts in VS Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'VS Code provides support for npm scripts out of the box. In order to enable
    npm Script Explorer, open the VS Code settings and ensure that the `"npm.enableScriptExplorer":
    true` property is present. Once you do, you will see an expandable title named
    **NPM SCRIPTS** in the **Explorer** pane, as highlighted with an arrow in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_10_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.14: NPM SCRIPTS in VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: You can click on any script to launch the line that contains the script in `package.json`
    or right-click and select **Run** to execute the script.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an easier way to interact with Docker next.
  prefs: []
  type: TYPE_NORMAL
- en: Docker extensions in VS Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to interact with Docker images and containers is through VS Code.
    If you have installed the `ms-azuretools.vscode-docker` Docker extension from
    Microsoft, as suggested in *Chapter 2*, *Forms, Observables, Signals, and Subjects*,
    you can identify the extension by the Docker logo on the left-hand navigation
    menu in VS Code, as circled in white in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_10_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.15: Docker extension in VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go through some of the functionality provided by the extension. Refer
    to the preceding screenshot and the numbered steps in the following list for a
    quick explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Images** contain a list of all the container snapshots on your system.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-clicking on a Docker image creates a context menu to run various operations
    like **Run**, **Push**, and **Tag**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Containers** list all executable Docker containers on your system, which
    you can start, stop, or attach to.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Registries** display the registries that you’re configured to connect to,
    such as Docker Hub or **AWS Elastic Container Registry** (**AWS ECR**).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While the extension makes it easier to interact with Docker, the **npm scripts
    for Docker** (which you configured using the `mrm` task) automate many of the
    chores related to building, tagging, and testing an image. They are both cross-platform
    and will work equally well in a CI environment.
  prefs: []
  type: TYPE_NORMAL
- en: The `npm` `run` `docker:debug` script automates a lot of chores to verify that
    you have a good image build!
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s learn about deploying our containers to the cloud and later achieve
    CD.
  prefs: []
  type: TYPE_NORMAL
- en: Working with containers in the cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the advantages of using Docker is that we can deploy it on any number
    of operating environments, from personal PCs to servers and cloud providers. In
    any case, we expect our container to function the same across the board.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in the chapter, I mentioned that working with full-fledged cloud providers
    like Azure, AWS, and Google Cloud is complicated. To deploy your containers in
    the cloud you will likely need to use one of these providers. Now and then, a
    provider that offers easy and seamless container hosting pops up, but over the
    years, these options have disappeared.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud services offer a wide variety of methods for running containers ranging
    from managed to unmanaged solutions. The key difference between managed and unmanaged
    is the level of control and responsibility shared between the user and the cloud
    provider. This is referred to as the Shared Responsibility Model. In a managed
    configuration, you concede more control and responsibility of the underlying infrastructure
    to the cloud provider. This consequently results in increased security and usually
    a cheaper cloud bill.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_10_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.16: Shared Responsibility Model'
  prefs: []
  type: TYPE_NORMAL
- en: The figure above demonstrates the shared responsibility model for running containers
    in the cloud. In the unmanaged model, the cloud provider gives you access to a
    virtual machine. The cloud provider manages and maintains the physical machine,
    which is totally abstracted away fro user. Now it’s up to you to configure the
    **Operating System** (**OS**) and secure it. On top of the OS, you can set up
    a container runtime or a cluster that involves many virtual machines.
  prefs: []
  type: TYPE_NORMAL
- en: Read the excellent article by Kaizhe Huang on ECS Fargate Threat Modeling at
    [https://sysdig.com/blog/ecs-fargate-threat-modeling](https://sysdig.com/blog/ecs-fargate-threat-modeling).
  prefs: []
  type: TYPE_NORMAL
- en: A container cluster is a group of hosts set up to run containerized workloads.
    Container orchestration software like Kubernetes automates and manages the containers
    across the cluster infrastructure. This allows you to scale container instances
    to respond to changes in load. Clusters also provide rich features like service
    discovery. You can learn more about Kubernetes at [https://kubernetes.io](https://kubernetes.io).
  prefs: []
  type: TYPE_NORMAL
- en: In the managed model, the cloud provider gives you access to a container runtime
    environment with cluster-like features, including Kubernetes support. The cloud
    provider secures the runtime, and the user is only responsible for the container.
    These offerings are **serverless**. In this space, each cloud provider offers
    a variety of services that significantly differ in capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of some popular options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS Fargate** is a serverless compute engine that runs containers without
    managing servers or clusters. Integrates with **Elastic Container Service** (**ECS**)
    and **Elastic Kubernetes Service** (**EKS**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Cloud Run** is a fully managed serverless platform for stateless containerized
    applications. Auto-scales and bills per request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Container Instances** can run individual containers without adopting
    higher-level orchestration services. Per-second billing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon ECS** offers highly scalable Docker container management across a
    cluster of **Elastic Compute Cloud** (**EC2**) instances. Tight integration with
    other AWS services. AWS EKS is the Kubernetes-flavored version of AWS ECS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Kubernetes Engine** (**GKE**) is a managed Kubernetes environment
    running on Google Cloud. Easily deploy containers with native Google Cloud integrations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Kubernetes Service** (**AKS**) is a fully managed Kubernetes cluster
    service hosted on Azure. Streamlined deployments to containers with auto-scaling
    capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main advantages of the serverless options (AWS Fargate, Google Cloud Run,
    Azure Container Instances) are that they are fully managed, automatically scale,
    and have payas-you-go pricing models. However, they offer limited customization
    compared to provisioned Kubernetes. The provisioned Kubernetes options (Amazon
    ECS, Google GKE, Azure AKS) offer more control, customization, and the ability
    to run stateful applications. However, they require manual scaling and managing
    of the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, serverless options are easier to use but less flexible, while provisioned
    Kubernetes offers more customization but requires DevOps know-how to manage the
    infrastructure. Your choice depends on whether the workload fits the serverless
    constraints and how much control vs simplicity is preferred.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you’ve deployed your code to the cloud, mastered the fundamentals of
    working with Docker containers, and understood the nuances of deploying containers
    in the cloud. **Continuous Deployment** (**CD**) is the manifestation of my motto,
    ship it, or it never happened. Next, we’ll go over how you can integrate deployments
    as part of your CI pipeline to achieve CD.
  prefs: []
  type: TYPE_NORMAL
- en: The `npm run docker:debug` script automates a lot of chores to verify that you
    have a good image build!
  prefs: []
  type: TYPE_NORMAL
- en: Continuous deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CD is the idea that code changes that successfully pass through your pipeline
    can be automatically deployed to a target environment. Although examples of continuously
    deploying to production exist, most enterprises prefer to target a development
    environment. A gated approach is adopted to move the changes through the various
    stages of development environment, test, staging, and, ultimately, production.
    CircleCI can facilitate gated deployment with approval workflows, which is covered
    later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In CircleCI, you need to implement a deploy job to deploy your image. You can
    deploy to many targets in this job, such as Google Cloud Run, Docker Hub, Heroku,
    Azure, or AWS ECS. Integration with these targets will involve multiple steps.
    At a high level, these steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure an orb for your target environment, which provides the CLI tools required
    to deploy your software.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store login credentials or access keys specific to the target environment as
    CircleCI environment variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a container in the CI pipeline if not using a platform-specific `build`
    command. Then use `docker push` to submit the resulting Docker image to the target
    platform’s registry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute a platform-specific `deploy` command to instruct the target to run the
    Docker image that was just pushed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By using a Docker-based workflow, we achieve great amounts of flexibility in
    terms of systems and target environments we can use. The following diagram illustrates
    this point by highlighting the possible permutation of choices that are available
    to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a structure  Description automatically generated](img/B20960_10_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.17: n-to-n deployment'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, in a containerized world, the possibilities are limitless. We
    will use the deployment related npm scripts we added later in this chapter to
    implement the deploy job in our CI pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Outside of Docker-based workflows, you can use purpose-built CLI tools to quickly
    deploy your app. Next, let’s see how you can deploy your app to Vercel using CircleCI.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Vercel using CircleCI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, we configured the LocalCast Weather app to be built using CircleCI.
    We can enhance our CI pipeline to take the build output and optionally deploy
    it to Vercel.
  prefs: []
  type: TYPE_NORMAL
- en: This section uses the **local-weather-app** repository. The `config.yml` file
    for this section is named `.circleci/config.stage9.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update the `config.yml` file to add a new job named `deploy`. In the
    upcoming *Workflows* section, we will use this job to deploy a pipeline when approved:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a token from your Vercel account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an environment variable to your CircleCI project named `VERCEL_TOKEN` and
    store your Vercel token as the value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `config.yml`, update the `build` job with the new steps and add a new job
    named `deploy`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `build` job, after the build is complete, we add two new steps. First,
    we move the compiled app in the `dist` folder to a workspace and persist that
    workspace so we can use it later in another job. In a new job named `deploy`,
    we attach the workspace and use `npx` to run the `vercel` command to deploy the
    `dist` folder. This is a straightforward process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that `$VERCEL_TOKEN` is the environment variable we stored in the CircleCI
    project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement a simple CircleCI workflow to deploy the outcome of your `build`
    job continuously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `deploy` job waits for the `build` job to complete before it can
    execute.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ensure that your CI pipeline executed successfully by inspecting the test results:![A
    screenshot of a computer  Description automatically generated](img/B20960_10_18.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.18: Successful Vercel deployment of local-weather-app'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Most CLI commands for cloud providers need to be installed in your pipeline
    to function. Since Vercel has an npm package, this is easy to do. CLI tools for
    AWS, Google Cloud, or Microsoft Azure need to be installed using tools such as
    `brew` or `choco`. CircleCI offers orbs, reusable snippets of code that help automate
    repeated processes, speed up project setup, and make it easy to integrate with
    third-party tools.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about orbs at [https://circleci.com/orbs](https://circleci.com/orbs).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the Orb registry for more information on how to use these orbs at
    [https://circleci.com/orbs/registry](https://circleci.com/orbs/registry).
  prefs: []
  type: TYPE_NORMAL
- en: CD works great for development and testing environments. However, it is usually
    desirable to have gated deployments, where a person must approve a deployment
    before it reaches a production environment. Next, let’s see how you can implement
    this with CircleCI.
  prefs: []
  type: TYPE_NORMAL
- en: Gated CI workflows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In CircleCI, you can define a workflow to control how and when your jobs are
    executed. Consider the following configuration, given the jobs `build` and `deploy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'First, the `build` job gets executed. Then, we introduce a special job named
    `hold` with type `approval`, which requires the `build` job to be successfully
    completed. Once this happens, the pipeline is put on hold. If or when a decision-maker
    approves `hold`, then the `deploy` step can execute. Refer to the following screenshot
    to see what a **hold** looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_10_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.19: A hold in the pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `build` and `test` jobs are executed in parallel. If we’re
    on a branch, this is where the pipeline stops. Once the branch is merged with
    `main`, the pipeline is put on hold, and a decision-maker has the option to deploy
    the build or not. This type of branch filtering ensures that only code that’s
    been merged to `main` can be deployed, which is in line with GitHub flow.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will go over how we can integrate code coverage reports with our CI
    runs to get better insight into our test coverage and optionally fail builds that
    don’t meet a certain threshold.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage reports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A code coverage report is a good way to understand the amount and trends of
    unit test coverage for your Angular project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the report for your app, execute the following command from your
    `project` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting report will be created as an HTML file under a folder named `coverage`;
    execute the following command to view it in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You may need to specify `--project` for the `ng` `test` command. Similarly,
    the coverage report may be generated in a sub-folder under **coverage**. You can
    select the folder to view it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the folder-level sample coverage report generated by `istanbul` for
    LemonMart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a spreadsheet  Description automatically generated](img/B20960_10_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.20: Istanbul code coverage report for LemonMart'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can drill down on a particular folder, such as `src/app/auth`, and get
    a file-level report, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a data  Description automatically generated](img/B20960_10_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.21: Istanbul code coverage report for src/app/auth'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can drill down further to get line-level coverage for a given file, such
    as `cache.service.ts`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_10_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.22: Istanbul code coverage report for cache.service.ts'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see lines **5**, **12**, **17**–**18**,
    and **21**–**22** are not covered by any test. The **I** icon denotes that the
    `if` path was not taken. We can increase our code coverage by implementing unit
    tests that exercise the functions that are contained within `CacheService`. As
    an exercise, you should attempt to at least cover one of these functions with
    a new unit test and observe the code coverage report change.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage in CI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ideally, your CI server configuration should generate and host the code coverage
    report with every test run. You can then use code coverage as another code quality
    gate to prevent pull requests from being merged if the new code reduces the overall
    code coverage percentage. This is a great way to reinforce the **Test-Driven Development**
    (**TDD**) mindset.
  prefs: []
  type: TYPE_NORMAL
- en: You can use a service such as Coveralls, found at [https://coveralls.io](https://coveralls.io),
    to implement your code coverage checks, which can embed your code coverage levels
    directly on a GitHub pull request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s configure Coveralls for LemonMart:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **lemon-mart** repo, the `config.yml` file for this section is named
    `.circleci/config.stage9.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: In your CircleCI account settings, under the **Security** section, ensure that
    you allow the execution of uncertified/unsigned orbs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register your GitHub project at [https://coveralls.io/](https://coveralls.io/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the repository token and store it as an environment variable in CircleCI
    named `COVERALLS_REPO_TOKEN`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new branch before making any code changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `.circleci/config.yml` file with the Coveralls orb as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `build` job to store code coverage results and upload them to Coveralls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`store_test_results` and `store_artifacts` will store test results and code
    coverage data to be analyzed in other jobs or orbs. CircleCI can display XML formatted
    coverage reports in its web UI. `The` `coveralls/upload` `command` uploads the
    code coverage data we just stored for analysis.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the orb automatically configures Coveralls for your account, so the
    `coveralls`/`upload` command can upload your code coverage results.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Commit your changes to the branch and publish it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a pull request on GitHub using the branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the pull request, verify that you can see that Coveralls is reporting your
    project’s code coverage, as shown:![A screenshot of a computer error  Description
    automatically generated](img/B20960_10_23.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.23: Coveralls reporting code coverage'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Merge the pull request to your main branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations! Now, you can modify your branch protection rules to require
    that code coverage levels be above a certain percentage before a pull request
    can be merged into the main branch.
  prefs: []
  type: TYPE_NORMAL
- en: You can set coverage thresholds at [https://coveralls.io](https://coveralls.io).
  prefs: []
  type: TYPE_NORMAL
- en: The LemonMart project at [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
    implements a full-featured `config.yml` file. This file also implements [Cypress.io](http://Cypress.io),
    overriding Angular’s default e2e tooling. The Cypress orb can record test results
    and allow you to view them from your CircleCI pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging what you have learned in this chapter, you can incorporate the `deploy`
    scripts from LocalCast Weather for LemonMart and implement a gated deployment
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Good engineering practices and DevOps practices are key to delivering successful
    projects and building a satisfying career. Thanks for reading this book!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about creating a value delivery stream using CI/CD
    pipelines. We covered the importance of automated unit testing to enable the delivery
    of quality code at speed in an enterprise context. You configured a CI pipeline
    using CircleCI. You learned about trunk-based development using GitHub flow and
    enforcing quality gates. You deployed a web application to Vercel and leveraged
    `ng` `deploy` for Firebase.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we covered DevOps and IaC techniques using Docker and npm scripts. You
    containerized your web app, learned about working with containers in the cloud,
    and learned how to implement gated CI workflows. Also, you became familiar with
    orbs, workflows, and code coverage tools.
  prefs: []
  type: TYPE_NORMAL
- en: We leveraged CircleCI as a cloud-based CI service and highlighted that you can
    deploy the outcome of your builds to all major cloud hosting providers. You have
    seen how you can achieve CD. We covered an example deployment to Vercel via CircleCI
    demonstrating how you can implement continuous deployments.
  prefs: []
  type: TYPE_NORMAL
- en: With a robust CI/CD pipeline, you can share every app build with clients and
    team members and quickly deliver bug fixes or new features to your end users.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have completed your *Angular for Enterprise Applications*
    journey. I hope you learned something new. The best way to learn and grow is by
    teaching and sharing, so I hope you keep this book around as a reference and share
    it with friends, family, and colleagues.
  prefs: []
  type: TYPE_NORMAL
- en: If you got this far, send me a picture of yourself with the (e-)book or a note
    on how the content impacted you, and I’ll share an exclusive digital badge with
    you for your achievement.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Continue your journey at [https://AngularForEnterprise.com](https://AngularForEnterprise.com).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add CircleCI and Coveralls badges to the `README.md` file on your code repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement Cypress for e2e testing and run it in your CircleCI pipeline using
    the `Cypress orb`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a Vercel deployment and a conditional workflow for the LemonMart app.
    The resulting `config.yml` file is in the `lemon-mart` repo, named `.circleci/config.stage9.yml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Working Effectively with Legacy Code*, Michael Feathers, 2004'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Three Laws of TDD*, Robert “Uncle Bob” Martin, 2005, [http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd](http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Succeeding with Agile: Software Development Using Scrum*, Mike Cohn, 2009'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TestPyramid*, Martin Fowler, 2012, [https://martinfowler.com/bliki/TestPyramid.html](https://martinfowler.com/bliki/TestPyramid.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Jasmine 2 Spy Cheat Sheet*, Dave Ceddia, 2015, [https://daveceddia.com/jasmine-2-spy-cheat-sheet](https://daveceddia.com/jasmine-2-spy-cheat-sheet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Practical Test Pyramid*, Ham Vocke, 2018, [https://martinfowler.com/articles/practical-test-pyramid.html](https://martinfowler.com/articles/practical-test-pyramid.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*SOLID Principles*, Wikipedia, 2019, [https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dockerfile reference*, 2020, [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CircleCI orbs*, 2020, [https://circleci.com/orbs/](https://circleci.com/orbs/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deploying container images*, 2020, [https://cloud.google.com/run/docs/deploying](https://cloud.google.com/run/docs/deploying
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ECS Fargate Threat Modeling*, Kaizhe Huang, 2019, [https://sysdig.com/blog/ecs-fargate-threat-modeling/](https://sysdig.com/blog/ecs-fargate-threat-modeling/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions as best as possible to ensure you’ve understood
    the key concepts from this chapter without googling anything. Do you know if you
    got all the answers right? Visit [https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)
    for more:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the testing pyramid?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are fixtures and matchers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the differences between a mock, a spy, and a stub?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of building Angular in prod mode?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does GitHub flow work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should we protect the main branch?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain the difference between a Docker image and a Docker container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do you prefer a managed container runtime over an unmanaged one in the cloud?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of a CD pipeline?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of CD?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we cover the configuration gap?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does a CircleCI orb do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of using a multi-stage Dockerfile?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a code coverage report help maintain the quality of your app?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
