<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer082">
			<h1 id="_idParaDest-84"><em class="italic"><a id="_idTextAnchor083"/>Chapter 5</em>: Refactoring Legacy Applications with React Testing Library</h1>
			<p>In the previous chapter, we learned how to test components in isolation separate from dependencies. We learned how the benefits of testing components can be integrated with other components. We also learned how to test components that use popular third-party <strong class="bold">User Interface</strong> (<strong class="bold">UI</strong>) and state management tools. By the end of this chapter, you will learn strategies for dealing with breaking changes while refactoring legacy React applications. You will learn how to update production packages while using React Testing Library tests to guide you in resolving breaking changes. You will also learn how to convert tests written in Enzyme or ReactTestUtils to React Testing Library.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Using tests to catch regressions when updating dependencies</li>
				<li>Refactoring tests written with Enzyme</li>
				<li>Refactoring tests written with ReactTestUtils</li>
				<li>Refactoring tests to comply with common testing best practices</li>
			</ul>
			<p>The skills acquired in this chapter will enable you to reduce the burden of refactoring legacy applications.</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor084"/>Technical requirements</h1>
			<p>For the examples in this chapter, you will need to have Node.js installed on your machine. We will be using the <strong class="source-inline">create-react-app</strong> CLI tool for all code examples. Please familiarize yourself with the tool if required before starting the chapter. Also, a basic understanding of the Material UI library will be helpful.</p>
			<p>Code snippets will be provided throughout the chapter to help you understand the code under test, but the objective is understanding how to test the code. You can find the code examples for this chapter here: <a href="https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter05">https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter05</a>.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/>Using tests to catch regressions when updating dependencies</h1>
			<p>In this section, we will <a id="_idIndexMarker238"/>learn how to use tests to drive the updating of application dependencies. The tests will help verify <a id="_idIndexMarker239"/>that the application code continues to work as expected and allow us to quickly catch regressions if they occur after updating dependencies. The budgeting application renders the following when the application is running:</p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="Images/Figure_5.1_B16887.jpg" alt="Figure 5.1 – Budget application" width="545" height="382"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – Budget application</p>
			<p>The preceding screenshot shows a summary section that includes <strong class="bold">Income</strong>, <strong class="bold">Spending</strong>, and <strong class="bold">Left over</strong> amounts based on user input. A user can click the <strong class="bold">SET INCOME</strong> button to update the value for <strong class="bold">Income</strong>:</p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="Images/Figure_5.2_B16887.jpg" alt="Figure 5.2 – Setting the budget income" width="383" height="179"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Setting the budget income</p>
			<p>The preceding <a id="_idIndexMarker240"/>screenshot shows a model that <a id="_idIndexMarker241"/>allows the user to enter and submit a number to update the value for <strong class="bold">Income</strong>. A user can also create budgets for various categories:</p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="Images/Figure_5.3_B16887.jpg" alt="Figure 5.3 – Adding a budget category" width="464" height="293"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Adding a budget category</p>
			<p>The <a id="_idIndexMarker242"/>preceding screenshot shows a <a id="_idIndexMarker243"/>model that allows the user to select <strong class="bold">Category</strong> and <strong class="bold">Amount</strong> and add the new budget. The model also displays a message informing the user of acceptable values for the budget. Once the user creates a new budget, the budget is added to the screen:</p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="Images/Figure_5.4_B16887.jpg" alt="Figure 5.4 – Budget category details&#13;&#10;" width="541" height="435"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – Budget category details</p>
			<p>The preceding <a id="_idIndexMarker244"/>screenshot shows a <strong class="bold">Shopping</strong> budget of <strong class="bold">$200</strong> added to the screen. An associated bar graph and a spending <a id="_idIndexMarker245"/>progress bar are added to the budget. A user can click the triangle buttons to add amounts to the budget or click the trashcan icon to delete the budget.</p>
			<p>The budgeting application has the following production dependencies:</p>
			<p class="source-code">  "dependencies": {</p>
			<p class="source-code">    "@material-ui/core": "^1.4.2",</p>
			<p class="source-code">    "@material-ui/icons": "^2.0.1",</p>
			<p class="source-code">    "react": "^16.4.2",</p>
			<p class="source-code">    "react-dom": "^16.4.2",</p>
			<p class="source-code">    "recharts": "^1.1.0",</p>
			<p class="source-code">    "uuid": "^3.3.2"</p>
			<p class="source-code">  },</p>
			<p>The preceding code shows the current versions of all project dependencies. We will update <strong class="source-inline">"@material-ui/core"</strong> to version <strong class="source-inline">"4.11.3"</strong>, <strong class="source-inline">"@material-ui/icons"</strong> to version <strong class="source-inline">"4.11.2"</strong>, and <strong class="source-inline">"recharts"</strong> to version <strong class="source-inline">"2.0.4"</strong>, so the application has up-to-date dependency code. The approach we will use to update the dependencies will involve having a suite of automated tests running to help catch any regressions after each dependency is updated. The budgeting application does not have any existing tests.</p>
			<p>In situations where a legacy application has no existing tests, a great way to get started is by writing automated UI end-to-end tests for critical workflows before adding tests at other test levels. Please refer to <a href="B16887_07_Final_PG_ePub.xhtml#_idTextAnchor109"><em class="italic">Chapter 7</em></a>, <em class="italic">End-to-End UI Testing with Cypress</em>, for related content.</p>
			<p>This chapter will teach <a id="_idIndexMarker246"/>you how to write automated <a id="_idIndexMarker247"/>component tests with React Testing Library before starting the dependency refactor task. Please see <a href="B16887_02_Final_PG_ePub.xhtml#_idTextAnchor029"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with React Testing Library</em>, for installation instructions. Now that you have learned about the application and the approach to updating dependencies, we will get down to writing regression tests in the next section.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>Creating the regression test suite</h2>
			<p>In this section, we will <a id="_idIndexMarker248"/>write several integration tests with React Testing Library to add confidence that we can catch regressions while updating application dependencies. Please refer to <a href="B16887_04_Final_PG_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 4</em></a>, <em class="italic">Integration Testing and Third-Party Libraries in Your Application</em>, for content related to writing integration testing. We will write tests for the following major functionalities: setting the income, deleting a budget, creating a budget, and budget details. For the first test, we will target the <em class="italic">setting the income</em> functionality by verifying that a user can enter an amount for <strong class="source-inline">income</strong>:</p>
			<p class="source-code">  function setOneDollarIncome() {</p>
			<p class="source-code">    user.click(screen.getByText(/set income/i));</p>
			<p class="source-code">    user.type(screen.getByRole('spinbutton'), '1');</p>
			<p class="source-code">    user.click(screen.getByText(/submit/i));</p>
			<p class="source-code">  }</p>
			<p>In the previous code, we create a function, <strong class="source-inline">setOneDollarIncome</strong>, to set an <strong class="source-inline">income</strong> amount of <em class="italic">$1</em>. The <strong class="source-inline">setOneDollarIncome</strong> function will reduce repetitive code in successive tests. Next, we will write the main test code:</p>
			<p class="source-code">  test('SetIncome, given income amount, sets income', () =&gt; {</p>
			<p class="source-code">    render(&lt;App /&gt;);</p>
			<p class="source-code">    setOneDollarIncome();</p>
			<p class="source-code">    const leftOverBudget = screen.getByText(/left over:/i);</p>
			<p class="source-code">    const leftOverBudgetAmount = within(leftOverBudget).       getByText(/\$1/i);</p>
			<p class="source-code">    expect(leftOverBudgetAmount).toBeInTheDocument();</p>
			<p class="source-code">    expect(</p>
			<p class="source-code">      screen.getByRole('heading', { name: /income: \$1/i })</p>
			<p class="source-code">    ).toBeInTheDocument();</p>
			<p class="source-code">  });</p>
			<p>In the preceding <a id="_idIndexMarker249"/>code, first, we render the <strong class="source-inline">App</strong> component in the DOM. Next, we set an <strong class="source-inline">income</strong> amount of <em class="italic">$1</em> via the <strong class="source-inline">setOneDollarIncome</strong> function. Next, we grab the <strong class="source-inline">left over</strong> text and use the <strong class="source-inline">within</strong> method from React Testing Library to access the dollar amount text. The <strong class="source-inline">within</strong> method can be used in situations where we want to access the child elements of a parent element. When we run the application, the resulting HTML element output for the <strong class="bold">Left Over</strong> section on the screen is as follows:</p>
			<p class="source-code">&lt;p class="MuiTypography-root BudgetSummary-leftoverText-4   MuiTypography-body1"&gt;</p>
			<p class="source-code">  Left over: &lt;span class="BudgetSummary-profit-6"&gt;$1&lt;/span&gt;</p>
			<p class="source-code">&lt;/p&gt;</p>
			<p>In the preceding code, a <strong class="source-inline">p</strong> element has the text <strong class="source-inline">Left over</strong> as child content. In the test code, we grab the <strong class="source-inline">p</strong> element via the <strong class="source-inline">Left Over</strong> text and store it in the <strong class="source-inline">leftOverBudget</strong> variable. Then, we use <strong class="source-inline">within</strong> to grab the <strong class="source-inline">span</strong> element with the text <strong class="source-inline">$1</strong> and store it in the <strong class="source-inline">leftOverBudgetAmount</strong> variable.</p>
			<p>Finally, we assert that <strong class="source-inline">leftOverBudgetAmount</strong> is in the DOM. For the next test, we will target the <em class="italic">creating a budget</em> functionality by verifying the resulting amount in the <em class="italic">Budget Summary</em> section once a user sets a budget:</p>
			<p class="source-code">  function createCarBudget(amount = '5') {</p>
			<p class="source-code">    user.click(screen.getByText(/create new budget/i));</p>
			<p class="source-code">    user.selectOptions(screen.getByRole('combobox', { name: /       category/i }), [</p>
			<p class="source-code">      screen.getByText('Auto'),</p>
			<p class="source-code">    ]);</p>
			<p class="source-code">    user.type(screen.getByRole('spinbutton'), amount);</p>
			<p class="source-code">    user.click(screen.getByText(/add budget/i));</p>
			<p class="source-code">  }</p>
			<p>In the previous code, we <a id="_idIndexMarker250"/>create a function, <strong class="source-inline">createCarBudget</strong>, to reduce the repetitive steps of creating a budget that will be used in multiple test cases. A default value of <strong class="source-inline">5</strong> will be used if no value for the <strong class="source-inline">amount</strong> parameter is passed as an argument to the function. Next, we will write the main test code:</p>
			<p class="source-code">    test.each`</p>
			<p class="source-code">      budgetAmount | spending           | leftOver</p>
			<p class="source-code">      ${'4'}       | ${'Spending: $5'}  | ${'$-4'}</p>
			<p class="source-code">      ${'5'}       | ${'Spending: $5'}  | ${'$-4'}</p>
			<p class="source-code">      ${'6'}       | ${'Spending: $10'} | ${'$-9'}</p>
			<p class="source-code">    `(</p>
			<p class="source-code">      'given budget, updates budget summary',</p>
			<p class="source-code">      ({ budgetAmount, spending, leftOver }) =&gt; {</p>
			<p>In the preceding code, we use the <strong class="source-inline">each</strong> method from Jest to allow the same test to be run multiple times with different values. The <strong class="source-inline">budgetAmount</strong>, <strong class="source-inline">spending</strong>, and <strong class="source-inline">leftOver</strong> variables represent the test's values for each test iteration. We have three rows of data under the variables to pass into the variables for each of the three test runs. Next, we arrange and perform actions in the test:</p>
			<p class="source-code">        render(&lt;App /&gt;);</p>
			<p class="source-code">        setOneDollarIncome();</p>
			<p class="source-code">        createCarBudget(budgetAmount);</p>
			<p class="source-code">        const leftOverBudget = screen.getByText(/left over:/i);</p>
			<p class="source-code">        const leftOverBudgetAmount = within(leftOverBudget).           getByText(leftOver);</p>
			<p>In the preceding code, first we <a id="_idIndexMarker251"/>render the app in the DOM and invoke the <strong class="source-inline">setOneDollarIncome</strong> function. Next, we invoke the <strong class="source-inline">createCarBudget</strong> function and pass in the value of <strong class="source-inline">budgetAmount</strong> for the current test iteration. Next, we grab the element associated with the <strong class="bold">Left Over Budget</strong> section and assign it to the <strong class="source-inline">leftOverBudget</strong> variable, similar to what we did in the previous test. Finally, we make the following assertions:</p>
			<p class="source-code">        expect(leftOverBudgetAmount).toBeInTheDocument();</p>
			<p class="source-code">        expect(</p>
			<p class="source-code">          screen.getByRole('heading', { name: spending })</p>
			<p class="source-code">        ).toBeInTheDocument();</p>
			<p class="source-code">      }</p>
			<p class="source-code">    );</p>
			<p>In the previous code, first, we assert that <strong class="source-inline">leftOverBudgetAmount</strong> is in the DOM. Finally, we assert that the heading element for the current value of <strong class="source-inline">name</strong> is in the DOM. By way of a challenge, write a test that verifies that a budget chart is displayed for a created budget.</p>
			<p>The solution for the previous scenario can be found in the code samples for <a href="B16887_05_Final_PG_ePub.xhtml#_idTextAnchor083"><em class="italic">Chapter 5</em></a>, <em class="italic">Refactoring Legacy Applications with React Testing Library</em>.</p>
			<p>For the next test, we will target the <em class="italic">deleting a budget</em> functionality by verifying that a deleted budget has been removed from the screen:</p>
			<p class="source-code">  test('DeleteBudget, given deleted budget, budget removed from      DOM', () =&gt; {</p>
			<p class="source-code">    render(&lt;App /&gt;);</p>
			<p class="source-code">    setOneDollarIncome();</p>
			<p class="source-code">    createCarBudget();</p>
			<p class="source-code">    user.click(screen.getByLabelText(/trash can/i));</p>
			<p class="source-code">    expect(screen.queryByRole('listitem')).not.       toBeInTheDocument();</p>
			<p class="source-code">  });</p>
			<p>In the preceding <a id="_idIndexMarker252"/>code, first, we arrange our test by rendering the <strong class="source-inline">App</strong> component in the DOM and invoking the <strong class="source-inline">setOneDollarIncome</strong> and <strong class="source-inline">createCarBudget</strong> functions. Next, we click the trash can icon. Finally, we assert that no <strong class="source-inline">listitem</strong> elements are in the DOM.</p>
			<p>Since the <strong class="source-inline">listitem</strong> elements render the budgets on the screen, we can be confident that the functionality works as expected if none are found in the DOM. For the last test, we will target the <em class="italic">budget details</em> functionality by verifying that adding expenses updates the budget's progress:</p>
			<p class="source-code">    test('given budget expense, updates budget progress', async        () =&gt; {</p>
			<p class="source-code">      render(&lt;App /&gt;);</p>
			<p class="source-code">      setOneDollarIncome();</p>
			<p class="source-code">      createCarBudget();</p>
			<p class="source-code">      user.click(screen.getByRole('button', { name: /         arrowright/i }));</p>
			<p class="source-code">      expect(</p>
			<p class="source-code">        screen.getByRole('heading', { name: /\$5 of \$5/i })</p>
			<p class="source-code">      ).toBeInTheDocument();</p>
			<p class="source-code">    });</p>
			<p>In the <a id="_idIndexMarker253"/>preceding code, first, we arrange our test by rendering the <strong class="source-inline">App</strong> component in the DOM and invoking the <strong class="source-inline">setOneDollarIncome</strong> and <strong class="source-inline">createCarBudget</strong> functions similar to the previous test. Next, we click the right arrow icon. Finally, we assert that the text, <strong class="source-inline">$5 of $5</strong>, is present on the screen.</p>
			<p>As a challenge, try to write the code for the following test scenario: <strong class="source-inline">Budget, given budget, displays details</strong>. The solutions for this test scenario can be found in the code samples for <a href="B16887_05_Final_PG_ePub.xhtml#_idTextAnchor083"><em class="italic">Chapter 5</em></a>, <em class="italic">Refactoring Legacy Applications with React Testing Library</em>.</p>
			<p>When we run our tests, we receive the following output:</p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="Images/Figure_5.5_B16887.jpg" alt="Figure 5.5 – Budget app test results" width="1013" height="480"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – Budget app test results</p>
			<p>The preceding screenshot shows that all the tests pass. Now that we have a passing regression test suite, we will upgrade the production dependencies for the application in the next section. It should <a id="_idIndexMarker254"/>be noted that our tests are automatically set up to run in <strong class="bold">watch mode</strong>, a Jest feature that automatically re-runs tests any time an associated component file is changed.</p>
			<p>The watch mode feature provides <a id="_idIndexMarker255"/>you with confidence that we can quickly discover regressions as code changes are implemented. For projects not automatically set up to run Jest in watch mode, simply pass the <strong class="source-inline">--watch</strong> flag when you execute Jest from the command line.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>Upgrading the Material UI dependencies</h2>
			<p>In the previous <a id="_idIndexMarker256"/>section, we created a regression test suite. In this section, we will delete all highlighted text and get the latest dependency code by upgrading the <strong class="source-inline">@material-ui/icons</strong> and <strong class="source-inline">@material-ui/core</strong> dependencies. The <strong class="source-inline">@material-ui/icons</strong> package depends on <strong class="source-inline">@material-ui/core</strong>, so we will update both dependencies simultaneously.</p>
			<p>Inside the <strong class="source-inline">package.json</strong> file, replace the current version of <strong class="source-inline">@material-ui/icons</strong> <strong class="source-inline">2.0.1</strong> with <strong class="source-inline">4.11.2</strong>, <strong class="source-inline">@material-ui/core</strong> with <strong class="source-inline">4.11.3</strong>, and reinstall all dependencies. Now, when we run our tests, we receive the following output:</p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="Images/Figure_5.6_B16887.jpg" alt="Figure 5.6 – Budget app failed test results" width="750" height="193"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – Budget app failed test results</p>
			<p>In the previous screenshot, the test results indicate that the dependency updates broke our tests. The results <a id="_idIndexMarker257"/>provide detailed information related to why each test failed. The following is a high-level version of the test results information displayed in the console:</p>
			<p class="source-code">Integration: Budget App › SetIncome, given income amount, sets income</p>
			<p class="source-code">    TestingLibraryElementError: Unable to find an accessible       element with the role "heading" and name `/income: \$1/i`</p>
			<p class="source-code">Integration: Budget App › Budget › given budget, displays details</p>
			<p class="source-code">    TestingLibraryElementError: Unable to find an accessible       element with the role "heading" and name `/\$0 of \$5/i`</p>
			<p class="source-code">Integration: Budget App › Budget › given budget expense, updates budget progress</p>
			<p class="source-code">    TestingLibraryElementError: Unable to find an accessible       element with the role "heading" and name `/\$5 of \$5/i`</p>
			<p class="source-code">Integration: Budget App › CreateNewBudget › given budget, updates budget summary</p>
			<p class="source-code">    TestingLibraryElementError: Unable to find an accessible       element with the role "heading" and name "Spending: $10"</p>
			<p class="source-code">    TestingLibraryElementError: Unable to find an accessible       element with the role "heading" and name "Spending: $5"</p>
			<p>In the previous console output, the test results inform us of specific tests that failed due to not being able to find targeted <strong class="source-inline">heading</strong> elements in the DOM. When we updated the dependencies, a regression occurred in our source code. Error messages are also displayed in the console, providing <a id="_idIndexMarker258"/>information to pinpoint the problems in the source code. The following is a high-level version of the error messages displayed in the console:</p>
			<p class="source-code">Warning: Failed prop type: Invalid prop `spacing` of value `24` supplied to `ForwardRef(Grid)`, expected one of [0,1,2,3,4,5,6,7,8,9,10].</p>
			<p class="source-code">Warning: Failed prop type: Invalid prop `variant` of value `title` supplied to `ForwardRef(Typography)`, expected one of ["h1","h2","h3","h4","h5","h6","subtitle1","subtitle2","body1","body2","caption","button","overline","srOnly","inherit"].</p>
			<p class="source-code">Warning: Failed prop type: Invalid prop `variant` of value `subheading` supplied to `ForwardRef(Typography)`, expected one of ["h1","h2","h3","h4","h5","h6","subtitle1","subtitle2","body1","body2","caption","button","overline","srOnly","inherit"].</p>
			<p class="source-code">Material-UI: theme.spacing.unit usage has been deprecated.</p>
			<p class="source-code">It will be removed in v5.</p>
			<p class="source-code">You can replace `theme.spacing.unit * y` with `theme.spacing(y)`.</p>
			<p>The error messages inform us that our source code is now using outdated property values from the material UI dependencies in the previous console output, which resulted in our tests not finding specific <strong class="source-inline">heading</strong> elements and failing. The error message output also tells us in which individual component file the error occurred under each error message. For example, the source of the error, <strong class="source-inline">Material-UI: theme.spacing.unit usage has been deprecated.</strong>, can be found here:</p>
			<p class="source-code">(src/components/SetIncome.js:27:26)</p>
			<p>The preceding console output informs us that the error source is on space <strong class="source-inline">26</strong> of line <strong class="source-inline">27</strong> of the <strong class="source-inline">SetIncome</strong> component file. Now that we know the specifics of why each test failed, we can update the source code appropriately.</p>
			<p>We will keep our tests running in watch mode while updating the source code to add confidence we will catch any <a id="_idIndexMarker259"/>new regressions that may occur due to updating the code. Once we update the code in our component files based on the error messages, we receive the following output when we run our tests:</p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="Images/Figure_5.7_B16887.jpg" alt="Figure 5.7 – Budget app updated dependency test results" width="1018" height="500"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7 – Budget app updated dependency test results</p>
			<p>The preceding screenshot shows that all tests are now passing after updating the source code based on the error messages. Now you know how to update production dependencies and add tests to legacy applications. The great thing about using React Testing Library during this task is knowing that we never need to update our test code while we update the source code.</p>
			<p>Our test code does not <a id="_idIndexMarker260"/>depend on the components' implementation details, we are free to change the source code however necessary as long as the resulting DOM output and behavior do not change. In the next section, we will learn how to refactor tests for legacy code that uses Enzyme.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor088"/>Refactoring tests written with Enzyme</h1>
			<p>In the <a id="_idIndexMarker261"/>previous section, we learned how to update production dependencies and add component tests to legacy applications. In this section, we will learn how to <a id="_idIndexMarker262"/>replace existing legacy tests written in <strong class="bold">Enzyme</strong> with React Testing Library. Before React Testing Library was created, Enzyme was a popular library to test the UI of React components. Enzyme is a great tool, but the design of the API allows the implementation details of components to be tested, resulting in developers having to update test code frequently as they update their source code. We will replace legacy Enzyme tests with React Testing Library to resolve the problem of having to update tests that focus on implementation details continually.</p>
			<p>We will use this approach to refactor legacy Enzyme tests to keep the current tests while installing and incrementally refactoring them with React Testing Library. Please refer to <a href="B16887_02_Final_PG_ePub.xhtml#_idTextAnchor029"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with React Testing Library</em>, for installation instructions. Once we are finished refactoring the legacy code and all tests are passing, we will remove Enzyme from the application. The tests will be refactored to tests created in the <em class="italic">Creating the regression test suite</em> section of this chapter. The first test we will refactor verifies that a user can set an income amount:</p>
			<p class="source-code">  test('SetIncome, given income amount, sets income', () =&gt; {</p>
			<p class="source-code">    const wrapper = mount(&lt;App /&gt;);</p>
			<p class="source-code">    wrapper.find('SetIncome').props().setIncome(1);</p>
			<p class="source-code">    expect(wrapper.find('h3#income').text()).toEqual('Income:       $1');</p>
			<p class="source-code">  });</p>
			<p>In the preceding code, the <strong class="source-inline">mount</strong> method from Enzyme is used to render the <strong class="source-inline">App</strong> component in the DOM. Next, the <strong class="source-inline">find</strong> method is used to locate the <strong class="source-inline">SetIncome</strong> component and invoke the <strong class="source-inline">setIncome</strong> method with the value <strong class="source-inline">1</strong>. Finally, an assertion is made to verify that the text value of the <strong class="source-inline">h3</strong> element with the <strong class="source-inline">id</strong> of <strong class="source-inline">income</strong> equals <strong class="source-inline">Income: $1</strong>.</p>
			<p>There are many implementation details that would break the test if changed. For example, if the <a id="_idIndexMarker263"/>names of the <strong class="source-inline">SetIncome</strong> component or the <strong class="source-inline">setIncome</strong> method are changed, the test would <a id="_idIndexMarker264"/>break. A change to <strong class="source-inline">income id</strong> would also break the test. We can refactor the test to focus on the user's perspective like so:</p>
			<p class="source-code">test('SetIncome, given income amount, sets income', () =&gt; {</p>
			<p class="source-code">    render(&lt;App /&gt;);</p>
			<p class="source-code">    setOneDollarIncome();</p>
			<p class="source-code">    const leftOverBudget = screen.getByText(/left over:/i);</p>
			<p class="source-code">    const leftOverBudgetAmount = within(leftOverBudget).      getByText(/\$1/i);</p>
			<p class="source-code">    expect(leftOverBudgetAmount).toBeInTheDocument();</p>
			<p>In the preceding code, we refactored the Enzyme test code that verifies that a user can set an income amount with React Testing Library. The next test that we will refactor verifies that the <em class="italic">Budget summary</em> section is updated when a user creates a budget:</p>
			<p class="source-code">      test('given budget, updates budget summary', () =&gt; {</p>
			<p class="source-code">        const wrapper = mount(&lt;App /&gt;);</p>
			<p class="source-code">        const budgetAmount = Math.ceil(parseInt(5, 10) / 5) * 5;</p>
			<p class="source-code">        wrapper.find('CreateNewBudget').props().addNewBudget({</p>
			<p class="source-code">          id: '1',</p>
			<p class="source-code">          category: 'Auto',</p>
			<p class="source-code">          amount: budgetAmount,</p>
			<p class="source-code">          amtSpent: 0,</p>
			<p class="source-code">        });</p>
			<p class="source-code">  wrapper.find('CreateNewBudget').props().     setTotalSpending(budgetAmount);</p>
			<p>In the preceding code, first we render the <strong class="source-inline">App</strong> component in the DOM. Next, we use the <strong class="source-inline">ceil</strong> method from the <strong class="source-inline">Math</strong> object and the <strong class="source-inline">parseInt</strong> method to <a id="_idIndexMarker265"/>round the passed-in budget amount of <strong class="source-inline">5</strong> to the nearest multiple of <strong class="source-inline">5</strong>. Next, we use the <strong class="source-inline">find</strong> method to <a id="_idIndexMarker266"/>call the <strong class="source-inline">addNewBudget</strong> method inside the <strong class="source-inline">CreateNewBudget</strong> component with an object representing the budget.</p>
			<p>Then, we call the <strong class="source-inline">setTotalSpending</strong> method in the same component with the result of the <strong class="source-inline">budgetAmount</strong> variable. Next, we will make assertions:</p>
			<p class="source-code">expect(wrapper.find('h3#spending').text()).toEqual('Spending:   $5');</p>
			<p class="source-code">expect(wrapper.find('span#leftover').text()).toEqual("$-5");</p>
			<p>In the previous code, we assert that the text value of the <strong class="source-inline">h3</strong> element with the <strong class="source-inline">id</strong> of <strong class="source-inline">spending</strong> is equal to <strong class="source-inline">Spending: $5</strong>. Finally, we assert that the text value of the <strong class="source-inline">span</strong> element with the <strong class="source-inline">id</strong> of <strong class="source-inline">leftover</strong> is equal to <strong class="source-inline">$-5</strong>. We can refactor the previous code with React Testing Library like so:</p>
			<p class="source-code">test('given budget, updates budget summary', () =&gt; {</p>
			<p class="source-code">  render(&lt;App /&gt;);</p>
			<p class="source-code">  setOneDollarIncome();</p>
			<p class="source-code">  createCarBudget(5);</p>
			<p class="source-code">  const leftOverBudget = screen.getByText(/left over:/i);</p>
			<p class="source-code">  const leftOverBudgetAmount = within(leftOverBudget).     getByText('df');</p>
			<p class="source-code">  expect(leftOverBudgetAmount).toBeInTheDocument();</p>
			<p class="source-code">  expect(screen.getByRole('heading', { name: 'Spending: $5'</p>
			<p class="source-code">})).toBeInTheDocument();</p>
			<p class="source-code">});</p>
			<p>In the preceding code, we <a id="_idIndexMarker267"/>refactored the Enzyme test code <a id="_idIndexMarker268"/>that verifies that the <em class="italic">Budget summary</em> section is <a id="_idIndexMarker269"/>updated when a user creates a budget with React Testing Library. The next test that we will refactor verifies that a chart is displayed when a user creates a budget:</p>
			<p class="source-code">    test('given budget, displays budget chart', () =&gt; {</p>
			<p class="source-code">      const wrapper = mount(&lt;App /&gt;);</p>
			<p class="source-code">      const budgetAmount = Math.ceil(parseInt(5, 10) / 5) * 5;</p>
			<p class="source-code">      wrapper.find('CreateNewBudget').props().addNewBudget({</p>
			<p class="source-code">        id: '1',</p>
			<p class="source-code">        category: 'Auto',</p>
			<p class="source-code">        amount: budgetAmount,</p>
			<p class="source-code">        amtSpent: 0,</p>
			<p class="source-code">      });</p>
			<p class="source-code">      wrapper.find('CreateNewBudget').props().         setTotalSpending(budgetAmount);</p>
			<p class="source-code">      wrapper.update();</p>
			<p>In the preceding code, we render the <strong class="source-inline">App</strong> component in the DOM using the <strong class="source-inline">mount</strong> method and create a <strong class="source-inline">budgetAmount</strong> variable to convert the budget into a multiple of five similar to the previous test. Next. We use the <strong class="source-inline">find</strong> method to call the <strong class="source-inline">addNewBudget</strong> method inside the <strong class="source-inline">CreateNewBudget</strong> component and pass in a <strong class="source-inline">budget</strong> object.</p>
			<p>Then, we call the <strong class="source-inline">setTotalSpending</strong> method inside <strong class="source-inline">CreateNewBudget</strong> and pass in the <a id="_idIndexMarker270"/>budget amount. Next, we <a id="_idIndexMarker271"/>call the <strong class="source-inline">update</strong> method to sync our test with the code created by the <strong class="source-inline">Chart</strong> component. Next, we can make assertions:</p>
			<p class="source-code">      expect(wrapper.find('div#chart')).toBeTruthy();</p>
			<p class="source-code">    });</p>
			<p>In the preceding code, we assert that the <strong class="source-inline">div</strong> element with the <strong class="source-inline">id</strong> of <strong class="source-inline">chart</strong> is <strong class="source-inline">truthy</strong>, meaning it was found in the DOM. As we saw in the <em class="italic">Creating the regression test suite</em> section of this chapter, all the test cases for the budget application written in React Testing Library will pass as expected when run.</p>
			<p>Now that all the Enzyme tests have been refactored to React Testing Library, we can remove the <strong class="source-inline">enzyme</strong> and <strong class="source-inline">enzyme-adapter-react-16</strong> dependencies from the <strong class="source-inline">package.json</strong> file. We can also remove the following code from the <strong class="source-inline">setupTests.js</strong> file:</p>
			<p class="source-code">import Enzyme from 'enzyme';</p>
			<p class="source-code">import Adapter from 'enzyme-adapter-react-16';</p>
			<p class="source-code">Enzyme.configure({ adapter: new Adapter() });</p>
			<p>The preceding code is used to configure Enzyme to work in the test files. The code is no longer needed after removing Enzyme from the application. Now you know how to refactor legacy tests created <a id="_idIndexMarker272"/>with Enzyme to React Testing <a id="_idIndexMarker273"/>Library. The React Testing Library tests provide greater confidence and reduce the chances of tests breaking when we refactor the source code.</p>
			<p>In the next section, we will learn how to refactor tests created with <strong class="source-inline">ReactTestUtils</strong>.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/>Refactoring tests written with ReactTestUtils</h1>
			<p>In the <a id="_idIndexMarker274"/>previous section, we learned how to convert tests written in Enzyme to React Testing Library. The process involved refactoring <a id="_idIndexMarker275"/>existing tests and then uninstalling the Enzyme library. In this section, we will use a similar process, only we will not have to uninstall an existing testing library. The <strong class="source-inline">ReactTestUtils</strong> module is included with React, so we can simply not import the module in our test file when we don't want to use it. Since the refactoring process is similar to the previous section, we will only look at one example in this section. The test we will refactor verifies that a user can set an income amount:</p>
			<p class="source-code">import React from 'react';</p>
			<p class="source-code">import ReactDOM from 'react-dom';</p>
			<p class="source-code">import { act } from 'react-dom/test-utils';</p>
			<p class="source-code">import App from './App';</p>
			<p>In the preceding code, we import <strong class="source-inline">React</strong>, <strong class="source-inline">ReactDOM</strong>, and the <strong class="source-inline">act</strong> method. The <strong class="source-inline">act</strong> method imported from the <strong class="source-inline">test-utils</strong> module is used to sync component updates and ensure that our tests behave in ways similar to how React does in the browser. Next, we will arrange the code needed for the test:</p>
			<p class="source-code">  it('SetIncome, given initial render, displays budget summary       values', () =&gt; {</p>
			<p class="source-code">    let container = document.createElement('div');</p>
			<p class="source-code">    document.body.appendChild(container);</p>
			<p class="source-code">    act(() =&gt; {</p>
			<p class="source-code">      ReactDOM.render(&lt;App /&gt;, container);</p>
			<p class="source-code">    });</p>
			<p>In the preceding code, we create a <strong class="source-inline">div</strong> element to render in the DOM and assign it to the <strong class="source-inline">container</strong> variable. Next, we attach the <strong class="source-inline">container</strong> variable to the <strong class="source-inline">body</strong> element of the DOM. Then, we <a id="_idIndexMarker276"/>render the <strong class="source-inline">App</strong> component in <strong class="source-inline">container</strong>, wrapped <a id="_idIndexMarker277"/>in the <strong class="source-inline">act</strong> method. Next, we will grab DOM elements and assert on their text values:</p>
			<p class="source-code">    const income = container.querySelector('h3#income');</p>
			<p class="source-code">    const spending = container.querySelector('#spending');</p>
			<p class="source-code">    const leftover = container.querySelector('#leftover');</p>
			<p class="source-code">    expect(income.textContent).toBe('Income: $0');</p>
			<p class="source-code">    expect(spending.textContent).toBe('Spending: $0');</p>
			<p class="source-code">    expect(leftover.textContent).toBe('$0');</p>
			<p>In the preceding code, we use the <strong class="source-inline">querySelector</strong> method to access the <strong class="source-inline">income</strong>, <strong class="source-inline">spending</strong>, and <strong class="source-inline">leftover</strong> elements in the DOM. Then, we assert the values of the previous three elements using the <strong class="source-inline">textContent</strong> property. Finally, we will add code to clean up the test:</p>
			<p class="source-code">    document.body.removeChild(container);</p>
			<p>In the preceding code, we remove the container element from the DOM. Removing the container will ensure that we can start successive tests from a clean slate. We can refactor the previous test using React Testing Library:</p>
			<p class="source-code">it('SetIncome, given initial render, displays budget summary   values', () =&gt; {</p>
			<p class="source-code">  render(&lt;App /&gt;);</p>
			<p class="source-code">  const income = screen.getByRole('heading', { name: /income:     \$0/i });</p>
			<p class="source-code">  const spending = screen.getByRole('heading', { name: /    spending: \$0/i });</p>
			<p class="source-code">  const leftover = screen.getByText(/left over:/i);</p>
			<p class="source-code">  expect(income).toHaveTextContent('Income: $0');</p>
			<p class="source-code">  expect(spending).toHaveTextContent('Spending: $0');</p>
			<p class="source-code">  expect(leftover).toHaveTextContent('$0');</p>
			<p class="source-code">});</p>
			<p>In the preceding code, we <a id="_idIndexMarker278"/>refactored the <strong class="source-inline">SetIncome, given initial render, displays budget summary values</strong> test using React <a id="_idIndexMarker279"/>Testing Library. The React Testing Library version of the test is cleaner and is more resilient to source code changes because it does not select DOM elements using implementation details. When we run the test, we get the following output:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="Images/Figure_5.8_B16887.jpg" alt="Figure 5.8 – Passing the set income test&#13;&#10;" width="1010" height="214"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8 – Passing the set income test</p>
			<p>The results show that the <strong class="source-inline">SetIncome, given initial render, displays budget summary values</strong> test passes as expected in the previous code. Now you know how to refactor tests created with the <strong class="source-inline">ReactTestUtils</strong> module. The skills learned in this section will arm you with the knowledge to refactor legacy test code to use modern testing tools.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor090"/>Refactoring tests to comply with common testing best practices</h1>
			<p>In the previous section, we <a id="_idIndexMarker280"/>learned how to refactor tests created with ReactTestUtils. In this section, we will cover a few scenarios where we can refactor existing test code to be more robust and maintainable. We will use the following feedback form application to illustrate examples:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="Images/Figure_5.9_B16887.jpg" alt="Figure 5.9 – Feedback form" width="315" height="373"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 5.9 – Feedback form</p>
			<p>In the preceding screenshot, we have a form for users to complete the <strong class="bold">Name</strong> and <strong class="bold">Email</strong> fields, as well as select a rating, enter comments, and finally, submit their information. If a user tries to submit the form with blank values for the required fields, an error message is displayed:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="Images/Figure_5.10_B16887.jpg" alt="Figure 5.10 – Feedback form error validation&#13;&#10;" width="296" height="573"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10 – Feedback form error validation</p>
			<p>In the preceding screenshot, form <a id="_idIndexMarker281"/>validation errors are displayed under each input with blank values. Finally, when a user submits the form with valid input data, a <strong class="bold">Thank you</strong> message is displayed:</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="Images/Figure_5.11_B16887.jpg" alt="Figure 5.11 – Submitted feedback form" width="930" height="60"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11 – Submitted feedback form</p>
			<p>In the preceding screenshot, the message <strong class="bold">We appreciate your responses John Doe!</strong> is displayed. The <strong class="bold">John Doe</strong> part of the message is the value entered for the <strong class="bold">Name</strong> input element in the form. The first test we will refactor verifies that an error message is displayed when invalid emails are entered:</p>
			<p class="source-code">test.each`</p>
			<p class="source-code">  value</p>
			<p class="source-code">  ${'a'}</p>
			<p class="source-code">  ${'a@b'}</p>
			<p class="source-code">  ${'a@b.c'}</p>
			<p class="source-code">`('displays error message', async ({ value }) =&gt; {</p>
			<p>In the preceding code, first, the <strong class="source-inline">each</strong> method from Jest was used to run the same test with different values: <strong class="source-inline">a</strong>, <strong class="source-inline">a@b</strong>, and <strong class="source-inline">a@b.c</strong>. Next, we see the test name, <strong class="source-inline">displays error message</strong>. The test name is vague because it does not provide enough details regarding the context of the test. It is common to use test naming conventions to eliminate issues with vague test names. There are many popular naming conventions, such as <strong class="source-inline">when_stateUnderTest_expect_expectedBehavior</strong> and <strong class="source-inline">given_preconditions_when_stateUnderTest_then_expectedBehavior</strong>, that describe the code under test, the actions performed on the code, and finally, the expected result. The important thing to remember is to use a naming convention in agreement with your project team.</p>
			<p>We will use the following convention, <strong class="source-inline">component under test, given preconditions, expected results</strong>, in our refactoring <a id="_idIndexMarker282"/>efforts. We can refactor the current test name like so:</p>
			<p class="source-code">  'Form, given invalid email value "$value", displays error       message',</p>
			<p>In the preceding code, we refactor the current test name to <strong class="source-inline">Form, given invalid email value "$value", displays error message</strong>. When reading the test name, it is clear now that we are testing a <strong class="source-inline">Form</strong> component, the given preconditions are invalid values, and the expected result is to see an error message on the screen. Notice the <strong class="source-inline">$value</strong> variable in the test name. The variable will be replaced with the name of the current value for each test iteration, further providing context to understand the specific test code. </p>
			<p>Next, we will analyze and refactor the main test code:</p>
			<p class="source-code">  async ({ value }) =&gt; {</p>
			<p class="source-code">    const { getByRole, getByText } = render(&lt;App /&gt;)</p>
			<p class="source-code">    const emailInput = getByRole('textbox', { name: /email/i })</p>
			<p class="source-code">    user.click(emailInput)</p>
			<p class="source-code">    user.tab()</p>
			<p class="source-code">    user.type(emailInput, value)</p>
			<p class="source-code">    await waitFor(() =&gt; {</p>
			<p class="source-code">      const errorMessage = getByText(/invalid email address/i)</p>
			<p class="source-code">      expect(errorMessage).toBeInTheDocument()</p>
			<p class="source-code">    })</p>
			<p class="source-code">  }</p>
			<p class="source-code">)</p>
			<p>In the preceding code, the object destructuring approach was used to access the <strong class="source-inline">getByRole</strong> and <strong class="source-inline">getByText</strong> query methods. However, the destructing approach requires you to manually keep track of which queries to add or remove as you build out the test code. As mentioned in <a href="B16887_01_Final_PG_ePub.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Exploring React Testing Library</em>, we can use the <strong class="source-inline">screen</strong> object to access query methods starting in version <strong class="bold">9</strong> of React Testing Library.</p>
			<p>Using the <strong class="source-inline">screen</strong> object to access query methods is easier to maintain and results in cleaner code than the destructuring <a id="_idIndexMarker283"/>approach. The <strong class="source-inline">waitFor</strong> method is also used to grab and verify that the error message is displayed asynchronously in the DOM. However, the <strong class="source-inline">findBy*</strong> queries of the <strong class="source-inline">screen</strong> object are also asynchronous and are easier-to-use options than <strong class="source-inline">waitFor</strong> when you need to query elements that take time to appear on the screen. We can refactor the current test code like so:</p>
			<p class="source-code">  async ({ value }) =&gt; {</p>
			<p class="source-code">    render(&lt;App /&gt;)</p>
			<p class="source-code">    const emailInput = screen.getByRole('textbox', { name: /      email/i })</p>
			<p class="source-code">    user.click(emailInput)</p>
			<p class="source-code">    user.tab()</p>
			<p class="source-code">    user.type(emailInput, value)</p>
			<p class="source-code">    const errorMessage = await screen.findByText(/invalid email       address/i)</p>
			<p class="source-code">    expect(errorMessage).toBeInTheDocument()</p>
			<p class="source-code">  }</p>
			<p class="source-code">)</p>
			<p>In the preceding code, we replaced the destructured queries to access via the screen object. We also replaced the <strong class="source-inline">waitFor</strong> method with an asynchronous <strong class="source-inline">findByText</strong> query. Now the test code is cleaner and easier to maintain.</p>
			<p>The next test we will refactor verifies that an <a id="_idIndexMarker284"/>error message is displayed when a user doesn't enter a value for any required form input:</p>
			<p class="source-code">test('Form, given blank input value, displays error message',   async () =&gt; {</p>
			<p class="source-code">  render(&lt;App /&gt;)</p>
			<p class="source-code">  const nameInput = screen.getByRole('textbox', { name: /name/i })</p>
			<p class="source-code">  const emailInput = screen.getByRole('textbox', { name: /    email/i })</p>
			<p class="source-code">  const ratingSelect = screen.getByRole('combobox', { name: /    rating/i })</p>
			<p class="source-code">  const commentsInput = screen.getByRole('textbox', { name: /    comments/i })</p>
			<p>In the preceding code, first, the application is rendered in the DOM. Next, the test is arranged by grabbing all the form <strong class="source-inline">input</strong> elements and storing them in respective values. Next, actions are performed on the form elements:</p>
			<p class="source-code">  user.click(nameInput)</p>
			<p class="source-code">  user.click(emailInput)</p>
			<p class="source-code">  user.click(ratingSelect)</p>
			<p class="source-code">  user.click(commentsInput)</p>
			<p class="source-code">  user.tab()</p>
			<p>In the preceding code, each <strong class="source-inline">input</strong> element is clicked. Then, pressing the <em class="italic">Tab</em> key on the keyboard simulates to move the focus away from the actively selected <strong class="source-inline">ratingSelect</strong> element. Finally, four assertions are made:</p>
			<p class="source-code">  expect(await screen.findByText(/name required/i)).    toBeInTheDocument()</p>
			<p class="source-code">  expect(await screen.findByText(/email required/i)).    toBeInTheDocument()</p>
			<p class="source-code">  expect(await screen.findByText(/rating required/i)).    toBeInTheDocument()</p>
			<p class="source-code">  expect(await screen.findByText(/comments required/i)).    toBeInTheDocument()</p>
			<p>In the preceding code, an assertion is made <a id="_idIndexMarker285"/>to verify that specific error messages are displayed for empty form values. However, if, for example, the first assertion for the <strong class="bold">name required</strong> error message fails, the test fails and none of the other assertions will be made. This approach of multiple assertions in the same test is not a good practice because we will not know whether the code for the remaining assertions works as expected.</p>
			<p>Each assertion in the test is independent of other assertions, and therefore, should live inside their own individual test. We can refactor the test like so:</p>
			<p class="source-code">  test.each`</p>
			<p class="source-code">  inputLabel</p>
			<p class="source-code">  ${'Name'}</p>
			<p class="source-code">  ${'Email'}</p>
			<p class="source-code">  ${'Rating'}</p>
			<p class="source-code">  ${'Comments'}</p>
			<p class="source-code">`(</p>
			<p class="source-code">  'Form, given blank $inputLabel input value, displays error message',</p>
			<p>In the preceding code, first, we use the <strong class="source-inline">each</strong> method to create individual tests for the <strong class="bold">Name</strong>, <strong class="bold">Email</strong>, <strong class="bold">Rating</strong>, and <strong class="bold">Comments</strong> <strong class="source-inline">input</strong> element names. The input names will be passed to the <strong class="source-inline">inputLabel</strong> variable for each test run. Next, we will write the main test code:</p>
			<p class="source-code">  async ({ inputLabel }) =&gt; {</p>
			<p class="source-code">    render(&lt;App /&gt;)</p>
			<p class="source-code">    user.click(screen.getByText(`${inputLabel} *`))</p>
			<p class="source-code">    user.tab()</p>
			<p class="source-code">    const errorMessage = await screen.findByText(`${inputLabel}         Required`)</p>
			<p class="source-code">    expect(errorMessage).toBeInTheDocument()</p>
			<p class="source-code">  }</p>
			<p class="source-code">)</p>
			<p>In the preceding code, first, we <a id="_idIndexMarker286"/>render the <strong class="source-inline">App</strong> component in the DOM. Next, we click the input label using <strong class="source-inline">getByText</strong>. Then, we simulate pressing the <em class="italic">Tab</em> key to move the focus away from the <strong class="source-inline">input</strong> element. Finally, we grab the element with the error message, store it in the <strong class="source-inline">errorMessage</strong> variable, and verify that it is in the DOM. We get the following output when we run the refactored tests:</p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="Images/Figure_5.12_B16887.jpg" alt="Figure 5.12 – Feedback form test results&#13;&#10;" width="1010" height="343"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.12 – Feedback form test results</p>
			<p>In the preceding screensho<a id="_idTextAnchor091"/>t, all <a id="_idIndexMarker287"/>refactored test cases pass as expected. Now you know how to refactor tests to use testing best practices of naming conventions and splitting multiple assertions from one test into individual tests. You also learned how to refactor legacy tests written in React Testing Library to modern approaches.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor092"/>Summary</h1>
			<p>In this chapter, you have learned how to reduce the burden of updating production dependencies of legacy applications. You learned how to refactor legacy tests using the modern React Testing Library tool. You also learned a few testing best practices. The skills acquired in this chapter should give you the confidence that you can successfully refactor outdated code to current versions without significant issues. You should also be able to refactor test code to be more maintainable.</p>
			<p>In the next chapter, we will learn about additional tools and plugins for testing.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor093"/>Questions</h1>
			<ol>
				<li>Explain the benefits of using React Testing Library compared to tools such as Enzyme or <strong class="source-inline">ReactTestUtils</strong>.</li>
				<li>Explain the benefits of running tests in Jest's watch mode.</li>
				<li>When should you use the <strong class="source-inline">each</strong> method from Jest when writing tests?</li>
			</ol>
		</div>
	</div></body></html>