- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing RxJS Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Observables play a central role in managing asynchronous data streams and event-driven
    interactions. By thoroughly testing Observables, developers can verify the correctness
    of their asynchronous code, anticipate and handle various edge cases, and ensure
    consistent behavior across different environments and use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The comprehensive testing of Observables not only enhances the robustness of
    applications but also improves code quality, reduces the likelihood of bugs and
    regressions, and ultimately enhances the overall user experience. With rigorous
    testing practices in place, developers can confidently deploy reactive applications
    that meet high standards of reliability, performance, and usability.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers consider testing Observables a challenging task. This is true.
    However, if you learn the right techniques, you can implement maintainable and
    readable tests in a very effective manner.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will walk you through three commonly used patterns for testing
    streams. We will start by explaining the subscribe and assert pattern, after which
    we will discuss the marble testing pattern. Finally, we will highlight a suitable
    pattern for testing streams that are returned from `HTTPClient` by focusing on
    a concrete example in our recipe app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the subscribe and assert pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about the marble testing pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlighting testing streams using `HTTPClientTestingModule`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter assumes that you have a basic understanding of RxJS and unit testing
    in Angular using Jasmine. Follow this link for more information: [https://angular.dev/guide/testing#set-up-testing](https://angular.dev/guide/testing#set-up-testing).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '[angular.dev](http://angular.dev) will be the new documentation site for Angular
    developers; it offers updated features and documentation. [angular.io](http://angular.io)
    will be deprecated in future releases.'
  prefs: []
  type: TYPE_NORMAL
- en: We will be testing Observables in an Angular context. The source code for this
    chapter is available at [https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-for-Angular-16-2nd-Edition/tree/main/Chap13](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-for-Angular-16-2nd-Edition/tree/main/Chap13).
  prefs: []
  type: TYPE_NORMAL
- en: We will be completing a unit test for the `saveRecipe` method, which is available
    under the `RecipesService` class. You can find the complete code in the `recipes.service.spec`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the subscribe and assert pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you will already know, Observables are lazy, and we don’t obtain any value
    until we subscribe to them. In tests, it is the same thing; Observables will not
    emit any value until we subscribe to them. To solve this, programmers always tend
    to subscribe to the Observables manually inside the tests and then perform assertions
    on the emitted values. This is what we call the **subscribe and** **assert** pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s delve into testing using the subscribe and assert pattern across three
    distinct scenarios. We will demonstrate testing for methods returning a single
    value, methods returning multiple values, and methods returning timed values (values
    returned after a specified time duration).
  prefs: []
  type: TYPE_NORMAL
- en: Testing single-value output methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s suppose we have to test a method that returns a single value. The method
    is called `getValue(value: boolean)` and is available in an Angular service called
    `SampleService`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The method itself is very simple, returning an Observable that will emit the
    Boolean input value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The test of this method will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we start by defining our test suite using the Jasmine `describe()` function.
    The function is used to define a test suite, which is a logical grouping of test
    cases to execute a single task with different test scenarios. It serves as a way
    to organize and structure your tests, making them more readable and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `describe()` function takes two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: A string description of the test suite (in the previous code snippet, `SampleService`,
    which is the name of the service that we are going to test and refers to the description
    of our test suite).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A function that contains the test cases for that suite (in testing frameworks,
    “test case” and “spec” typically refer to a single unit of testing within a test
    suite). Inside this function, we inject `SampleService` into the `beforeEach`
    statement to provide a shared instance of the service that we will be using in
    all the test cases. Finally, we define the test case of our `getValue(value: boolean)`
    method by using the Jasmine function `it()`. The `it()` function takes two parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string description of the test case (in the previous code snippet, `should
    return true as a value` refers to the description of our test case).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that contains the test logic. In this function, we subscribe to the
    `getValue(true)` method and expect the result to be equal to `true` since we passed
    the `true` value as input. Expectations are built using the `expect()` Jasmine
    function and are used to assert or verify that certain conditions are met during
    the execution of a test.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s run `ng test`; the test passes, and everything is fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – ng test output](img/B21180_13_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – ng test output
  prefs: []
  type: TYPE_NORMAL
- en: Quite simple, right? This is the expected behavior when running a positive scenario.
    A positive scenario typically involves providing input or conditions that align
    with the expected behavior of the code being tested, resulting in successful execution
    without errors or failures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s handle a negative scenario by providing input or conditions that
    are intended to trigger failures in the code being tested. To do so, we will replace
    `true` with `false` in the following assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When you run `ng test` again, our test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: However, in some cases, the test will still pass. How is this possible?
  prefs: []
  type: TYPE_NORMAL
- en: The thing with expectations in testing is that if you have an unmet assertion,
    it throws an error. Plus, if you have an unhandled error inside an RxJS subscription,
    it will be thrown on a separate call stack, meaning that it is asynchronously
    thrown. Therefore, tests that use the subscribe and assert pattern can sometimes
    be green even though, in reality, they are failing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this, we should pass a `done` callback to the test function and
    call it manually after our expectations for when the test has been completed,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `done` callback is a mechanism used in asynchronous testing to signal the
    completion of a test case to the testing framework. It is supported by many testing
    frameworks, such as Jasmine, Jest, and Mocha. Calling the `done` callback ensures
    that the test doesn’t finish prematurely before all asynchronous tasks have been
    executed and assertions have been verified. Therefore, we prevent false positives
    and ensure that our tests accurately reflect the behavior of the code being tested,
    particularly in asynchronous scenarios. So, don’t forget to call the `done` callback
    in asynchronous scenarios!
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s consider a more complicated method that will return multiple values
    instead of one value.
  prefs: []
  type: TYPE_NORMAL
- en: Testing multiple-value output methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s consider a method called `getValues`, which will return multiple values
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The values will be emitted one by one in the aforementioned order.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the assert and subscribe pattern, the test will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created an array that represents the expected values
    in order; then, we subscribed to the `getValues` method and compared the emitted
    values with the expected value using a counter (`expectedValues[index]`). After
    finishing, we called the `done()` callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, instead of the counter, we can use the `toArray` operator of RxJS,
    which will put the values that have been emitted in an array and then compare
    the resulting array with the expected array we defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Well, this is working fine, and `ng test` will pass. However, in both cases,
    even though we are dealing with a simple stream, we were forced to add some logic;
    in the first example, we added a counter, while in the second example, we used
    the `toArray` operator. This boils down the tests and adds some unnecessary testing
    logic; these are the most significant drawbacks of the subscribe and assert pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to a different example and explore testing methods that output
    timed values.
  prefs: []
  type: TYPE_NORMAL
- en: Testing timed-value output methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s update the method `getValues()` and add a timer to return the values
    after a specific duration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used the RxJS `timer` in this method to emit a value every 5 seconds.
    Since `timer` produces an endless stream, we call the `take` operator to return
    the first three emissions and complete them. Then, for every emission, we use
    the `switchMap` operator to return an Observable that emits three values consecutively.
  prefs: []
  type: TYPE_NORMAL
- en: This is tricky, right? If we use the subscribe and assert pattern here, the
    tests would be very complicated and may take a lot of time, depending on the value
    that’s passed to `timer`. However, the unit tests should be fast and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, having a virtual timer can be beneficial. A virtual timer refers
    to a simulated passage of time controlled by the testing framework. Instead of
    waiting for actual time to pass, which could lead to slow and unreliable tests,
    the virtual timer allows testers to control time programmatically. This means
    they can advance time forward or backward as needed to trigger certain events
    or test scenarios, making it easier to write reliable and deterministic tests
    for code that depends on time-based behavior. This approach ensures that tests
    are fast, predictable, and independent of real-time conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in a nutshell, the subscribe and assert pattern is a valid and easy technique
    that most developers adopt. However, it has some drawbacks that I pointed out
    throughout this section:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to remember to call the `done` callback in asynchronous tests; otherwise,
    the tests will return invalid results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some scenarios, we end up with boiled tests and unwanted testing logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timed Observables are very complicated to test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s explore another approach for testing Observables: marble testing
    with RxJS testing utilities.'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the marble testing pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Marble diagrams are very useful for visualizing Observable execution. You will
    already know this, as we introduced marble diagrams back in [*Chapter 1*](B21180_01.xhtml#_idTextAnchor016),
    *Diving into the Reactive Paradigm*, and we’ve used them in almost all the reactive
    patterns we’ve implemented in this book. They are simple to understand and delightful
    to read. So, why not also use them in code? What you will be surprised to know
    is that RxJS introduced marble testing as an intuitive and clean way to test Observables.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discover what marble testing is about. We will start by explaining the
    syntax in the next section and then learn how we can write marble tests in our
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the syntax, we should know about the following semantics:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Character** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `'' ''` | This represents a special character that will not be interpreted.
    It can be used to align your marble string. |'
  prefs: []
  type: TYPE_TB
- en: '| `''-''` | This represents a frame of virtual time passing. |'
  prefs: []
  type: TYPE_TB
- en: '| `''&#124;''` | This represents the completion of an Observable. |'
  prefs: []
  type: TYPE_TB
- en: '| `[``a-z]` | This represents a value that is emitted by an Observable. It
    is an alphanumeric character. |'
  prefs: []
  type: TYPE_TB
- en: '| `''#''` | This represents an error. |'
  prefs: []
  type: TYPE_TB
- en: '| `''()''` | This represents a group of events that occur in the same frame.
    It can be used to group any values emitted, errors, and completion. |'
  prefs: []
  type: TYPE_TB
- en: '| `''^''` | This represents the subscription point and will only be used when
    you’re dealing with hot Observables. |'
  prefs: []
  type: TYPE_TB
- en: '| `[``0-9]+[ms&#124;s&#124;m]` | This represents time progression and allows
    you to progress virtual time by a specific amount. It’s a number, followed by
    a time unit in **milliseconds** (**ms**), **seconds** (**s**), or **minutes**
    (**m**) without any space between them. |'
  prefs: []
  type: TYPE_TB
- en: Figure 13.2 – Marble testing syntax
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the basic syntax. Let’s look at some examples to practice the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`---`: This represents an Observable that never emits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-x--y--z|`: This represents an Observable that emits `x` on the first frame,
    `y` on the fourth, and `z` on the seventh. After emitting `z`, the Observable
    completes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--xy--#`: This represents an Observable that emits `x` on frame two, `y` on
    frame three, and an error on frame six.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-x^(yz)--|`: This is a hot Observable that emits `x` before the subscription.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ve got the idea, right? Now, let’s learn how to implement marble tests in
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing TestScheduler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are different packages out there that can help you write marble tests,
    including `jasmine-marbles`, `jest-marbles`, and `rxjs-marbles`. However, RxJS
    provides testing utilities out of the box, and all the libraries are just wrappers
    around the RxJS testing utilities. I recommend working with the RxJS utilities
    for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: You don’t have to include a third-party dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You stay up to date with the core implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You stay up to date with the latest features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The RxJS API that’s provided for testing is based on `TestScheduler`. This API
    allows you to test time-dependent RxJS code in a controlled and deterministic
    manner, which is crucial for writing reliable and predictable tests for Observables
    with time-based operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define our test logic, the `TestScheduler` API provides a `run` method that
    has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `run` method takes a `callback` function as an argument. This `callback`
    function is where you define your test logic, including setting up Observables,
    defining expectations, and making assertions. The `callback` function takes one
    argument named `helpers` of type `RunHelpers`, which provides various utility
    functions and properties to assist you in writing marble tests for Observables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RunHelpers` interface contains the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at these properties one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cold`: This produces a cold Observable based on a given marble diagram. Here
    is the signature of the method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`hot`: This produces a hot Observable based on a given marble diagram. Here
    is the signature of the method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you’re creating a hot Observable, you can use `^` to point out the first
    frame:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`flush`: This starts virtual time. It’s only needed if you use helpers outside
    the `run` callback or if you want to use `flush` more than once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expectObservable`: This asserts that an Observable matches a marble diagram.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expectSubscriptions`: This asserts that an Observable matches the expected
    subscriptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s learn how we can implement marble testing using `TestScheduler` in
    the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing marble tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will consider implementing marble tests for the `getValues`
    method previously mentioned in the subscribe and assert pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The steps for writing the marble testing implementation pattern are simple:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `TestScheduler` from `rxjs/testing`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `beforeEach` statement, inject `SampleService`. Then, instantiate `TestScheduler`
    and pass an input function that compares the actual output with the expected output
    of the Observable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the expected output and actual output are not equal, it throws an error,
    failing the test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `TestScheduler` to test your stream by calling the `run` method and passing
    a callback to it (remember that the callback needs to accept `RunHelpers` as the
    first parameter):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is also useful to destruct the helpers into variables and use them directly
    to implement the marble tests. We will be destructuring the `expectObservable`
    variable, as we will use it to assert that the Observable matches the marble diagram,
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, declare the expected marble and values and perform the expectation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `expectedMarble` constant represents the marble diagram. Since the `getValues`
    method returns three values consecutively, we used parentheses to group the `a`,
    `b`, and `c` emissions. The stream then completes, so we use the `|` character.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `expectedValues` constant represents the values of the `a`, `b`, and `c`
    characters that we put in `expectedMarble`. It represents `'Hello'`, `'Packt'`,
    and `'Readers'`, consecutively, which are nothing but the values that are emitted
    by the Observable that we want to test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The last instruction is the expectation; we should provide the expected result
    that our methods should return. Here, we must use `expectObservable`, which takes
    the Observable we want to test as a parameter and matches it with `expectedMarble`
    and `expectedValues`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'That’s it. Let’s have a look at the complete test setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run `ng test`, this test will pass. If you enter wrong values in `expectedValues`,
    the test will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – ng test failing](img/B21180_13_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – ng test failing
  prefs: []
  type: TYPE_NORMAL
- en: Well, this is cleaner than the subscribe and assert pattern implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at a more difficult example and see how we can implement it
    using marble testing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing timed-value output methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will consider the testing of a timed Observable that was complicated to
    implement using the subscribe and assert pattern. Let’s revisit the timer example
    that we explained earlier in the subscribe and assert pattern section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The cool `TestScheduler` feature that can help us here is **virtual time**;
    this allows us to test asynchronous streams synchronously by virtualizing time
    and ensuring that the correct items are emitted at the correct time. Thanks to
    the time progression syntax, we can advance virtual time by milliseconds (ms),
    seconds (s), or even minutes (m). This is extremely useful in the case of timed
    Observables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the following marble diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, the diagram indicates that `e` is emitted immediately. Then, after 1 second,
    `f` and `g` are emitted. Then, 1 second later, `h` is emitted, after which `I`
    is emitted, and the stream finally completes.
  prefs: []
  type: TYPE_NORMAL
- en: Why use `999` and `996`? Well, we’re using `999` because `e` takes 1 ms to emit
    and `996` because the characters in the `(fg)` group take 1 ms each.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all this in mind, the marble tests of `getValues` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The group of values `(abc)` is emitted every 5 seconds or 5000 ms, and since
    the characters are counted inside the group, we put `4995ms`. So, the whole test
    case will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That’s how we resolved the test of a timed Observable using marble tests.
  prefs: []
  type: TYPE_NORMAL
- en: Marble testing is extremely powerful and helpful. It allows you to test a very
    high level of detail and complicated things such as concurrency and timed Observables.
    It also makes your tests cleaner. However, it requires you to learn a new syntax,
    and it is not recommended for testing business logic. Marble testing was designed
    for testing operators with arbitrary time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more details about marble testing, you can check out the official docs at
    [https://rxjs.dev/guide/testing/marble-testing](https://rxjs.dev/guide/testing/marble-testing).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s highlight a very common pattern for testing business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting testing streams using HttpClientTestingModule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Observables that are returned from the HTTP client are frequently used in our
    Angular code, but how can we test those streams? Let’s look at the pattern we
    can use to test those Observables. We will be shifting our focus away from general
    testing practices and narrowing our attention specifically to testing our recipe
    app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following method inside `RecipeService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `saveRecipe` method issues an HTTP request and returns an Observable of
    recipe. In order to test the output Observable, there is a very useful API that
    can be used: `HttpClientTestingModule`. This API allows us to test HTTP methods
    that use the HTTP client. It also allows us to easily mock HTTP requests by providing
    the `HttpTestingController` service. In short, it enables us to mock requests
    instead of making real API requests to our API backend when testing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see the steps required to test the `saveRecipe` method using the `HttpClientTestingModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can use `HttpClientTestingModule`, import and inject it in your
    `TestBed` in the `beforeEach` statement, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, import and inject `HttpTestingController` and `RecipesService` and provide
    a shared instance of each to use in our tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, implement the test case of saving the recipe. We’ll mock `saveRecipe`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we created a constant called `recipeToSave`, which represents a mocked
    recipe that we will post to the server to be saved. Then, we subscribed to the
    `saveRecipe` method and passed `recipeToSave` to it as a parameter. Inside the
    subscription, we defined our expectations. Then, we called the `expectOne` method,
    which expects a single request that’s been made to match a given URL (in our case,
    `/api/recipes`) and returns mock data using the `flush` method, which resolves
    the request by returning a mocked body. Finally, we released the subscription.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last step is to add an `afterEach()` block, in which we run the `verify`
    method of our controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `verify()` method ensures that there are no outstanding HTTP requests that
    have not been handled or flushed. When you make HTTP requests in your tests using
    `HttpClientTestingModule`, they are intercepted by `httpTestingController` instead
    of being sent over the network. The `verify()` method ensures that all requests
    have been properly handled and allows your tests to pass only if there are no
    pending requests remaining.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In summary, the `afterEach()` block with `httpTestingController.verify()` is
    used in Angular tests to clean up and verify that there are no unhandled HTTP
    requests left over after each test case. This helps ensure that your tests are
    isolated and reliable, without unexpected network interactions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And that’s it; the pattern for testing methods that issue HTTP requests is complete.
    Just run the `ng test` command and ensure everything works fine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpClientTestingModule` is very useful in this use case. For more details,
    please refer to [https://angular.dev/guide/testing/services#httpclienttestingmodule](https://angular.dev/guide/testing/services#httpclienttestingmodule).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I’ve elucidated three common approaches for testing Observables
    in RxJS and Angular. Each solution has its strengths and weaknesses, and there
    is no one-size-fits-all answer.
  prefs: []
  type: TYPE_NORMAL
- en: First, we learned about the subscribe and assert pattern, as well as its advantages
    and drawbacks. This pattern is straightforward to understand but may not cover
    all edge cases, especially when dealing with complex asynchronous behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we learned about the marble testing pattern and its syntax, features,
    advantages, and drawbacks. We studied a basic example and an example that uses
    virtual time to test timed Observables. Marble testing provides a visual representation
    of Observable behavior; it is suitable for testing complex asynchronous scenarios.
    However, it requires special syntax, meaning it may have a steep learning curve
    for beginners.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned about a pattern that we can use to test streams that are
    returned from the HTTP client. This pattern provides control over responses and
    doesn’t rely on external APIs. However, it can be tedious to set up and maintain
    and may not accurately simulate real-world network behavior in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, each testing approach offers its advantages and trade-offs. Depending
    on your project requirements, you can choose the solution that aligns best with
    your testing needs and project constraints.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, our journey into reactive patterns is coming to an end. In this
    book, I tried to highlight the most used reactive patterns that solve a lot of
    recurrent use cases in web applications. You can use them immediately in your
    current projects, adapt them to your needs, or get inspired to create your own
    reactive pattern.
  prefs: []
  type: TYPE_NORMAL
- en: This book is not just about patterns, though; it is also about the reactive
    approach and how to switch your mindset from imperative to reactive thinking;
    in most chapters, this is why I’ve highlighted the classic pattern before the
    reactive one to provide you with a smooth transition between the two.
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we reach the end of our journey together. Thank you for reading
    and embarking on this reactive adventure with me!
  prefs: []
  type: TYPE_NORMAL
