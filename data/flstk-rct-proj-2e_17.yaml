- en: Developing a Web-Based VR Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发基于Web的VR游戏
- en: The advent of **virtual reality** (**VR**) and **augmented reality** (**AR**)
    technologies is transforming how users interact with software and, in turn, the
    world around them. The possible applications of VR and AR are innumerable, and
    though the gaming industry has been an early adopter, these rapidly developing
    technologies have the potential to shift paradigms across multiple disciplines
    and industries.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟现实**（VR）和**增强现实**（AR）技术的出现正在改变用户与软件以及他们周围世界的互动方式。VR和AR的可能应用数不胜数，尽管游戏行业是早期采用者，但这些快速发展的技术有潜力在多个学科和行业中改变范式。'
- en: In order to demonstrate how the MERN stack paired with React 360 can easily
    add VR capabilities to any web application, we will discuss and develop a dynamic,
    web-based VR game in this and the next chapter. In this chapter, we will focus
    on defining the features of the VR game. Additionally, we will go over the key
    3D VR concepts that are relevant to implementing this VR game, before developing
    the game view using React 360.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示MERN堆栈与React 360相结合如何轻松地为任何Web应用程序添加VR功能，我们将在本章和下一章中讨论和开发一个动态的、基于Web的VR游戏。在本章中，我们将专注于定义VR游戏的特点。此外，在开发使用React
    360的游戏视图之前，我们将回顾与实现此VR游戏相关的关键3D VR概念。
- en: 'In this chapter, we will build the VR game using React 360 by covering the
    following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过以下主题构建VR游戏，使用React 360：
- en: Introducing the MERN VR Game
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍MERN VR游戏
- en: Getting started with React 360
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用React 360
- en: Key concepts for developing 3D VR applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发3D VR应用程序的关键概念
- en: Defining game details
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义游戏详情
- en: Building the game view in React 360
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React 360中构建游戏视图
- en: Bundling the React 360 code to integrate with the MERN skeleton
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将React 360代码打包以集成到MERN框架中
- en: After going over these topics, you will be able to apply 3D VR concepts and
    use React 360 to start building your own VR-based applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解这些主题之后，您将能够应用3D VR概念并使用React 360开始构建自己的基于VR的应用程序。
- en: Introducing the MERN VR Game
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍MERN VR游戏
- en: 'The MERN VR Game web application will be developed by extending the MERN skeleton
    and integrating VR capabilities using React 360\. It will be a dynamic, web-based
    VR game application, in which registered users can make their own games, and any
    visitor to the application can play these games. The home page of this application
    will list the games on the platform, as shown in the following screenshot:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: MERN VR游戏Web应用程序将通过扩展MERN框架并使用React 360集成VR功能来开发。它将是一个动态的、基于Web的VR游戏应用程序，其中注册用户可以创建自己的游戏，任何访问该应用程序的访客都可以玩这些游戏。该应用程序的主页将列出平台上的游戏，如下面的截图所示：
- en: '![](img/a3d1a186-03b5-4201-82d2-0dccbfa3446f.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a3d1a186-03b5-4201-82d2-0dccbfa3446f.png)'
- en: The code to implement features of the VR game using React 360 is available on
    GitHub at [https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter13/MERNVR](https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter13/MERNVR). You
    can clone this code and run the application as you go through the code explanations
    in the rest of this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React 360实现VR游戏功能的代码可在GitHub上找到：[https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter13/MERNVR](https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter13/MERNVR)。您可以在阅读本章剩余部分的代码解释时克隆此代码并运行应用程序。
- en: The features of the game will be simple enough to reveal the capabilities of
    introducing VR into a MERN-based application, without delving too deeply into
    the advanced concepts of React 360 that may be used to implement more complex
    VR features. In the next section, we will briefly define the features of a game
    in this application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的特点将足够简单，足以展示将VR引入基于MERN的应用程序的能力，而不会深入探讨可能用于实现更复杂VR功能的React 360的高级概念。在下一节中，我们将简要定义该应用程序中游戏的特点。
- en: Game features
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏特点
- en: Each game in the MERN VR Game application will essentially be a different VR
    world, where users can interact with 3D objects placed at different locations
    in a 360-degree panoramic world.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: MERN VR游戏应用程序中的每个游戏本质上都是一个不同的VR世界，用户可以与放置在360度全景世界中不同位置的3D对象进行交互。
- en: The gameplay will be similar to that of a scavenger hunt, and to complete each
    game, users will have to find and collect the 3D objects that are relevant to
    the clue or description for each game. This means the game world will contain
    some VR objects that can be collected by the player and some VR objects that cannot
    be collected, but that may be placed by makers of the game as props or hints.
    Finally, the game will be won when all of the relevant 3D objects have been collected
    by the user.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏玩法将与寻宝游戏相似，为了完成每个游戏，用户必须找到并收集与每个游戏提示或描述相关的 3D 对象。这意味着游戏世界将包含一些可以被玩家收集的 VR
    对象，以及一些不能被收集但可能被游戏制作者作为道具或提示放置的 VR 对象。最后，当所有相关的 3D 对象都被用户收集后，游戏即告胜利。
- en: In this chapter, we will build these game features using React 360, focusing
    primarily on VR and React 360 concepts that will be relevant to implementing the
    features defined here. Once the game features are ready, we will discuss how the
    React 360 code can be bundled and prepared for integration with the MERN application
    code developed in [Chapter 14](17bbfed7-9867-4c8b-99fd-42581044a906.xhtml), *Making
    the VR Game Dynamic Using MERN*. Before diving into the implementation of the
    game features with React 360, we will first look at setting up and getting started
    with React 360 in the next section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 React 360 构建这些游戏功能，主要关注与实现这里定义的功能相关的 VR 和 React 360 概念。一旦游戏功能准备就绪，我们将讨论如何将
    React 360 代码打包并准备与第 14 章（17bbfed7-9867-4c8b-99fd-42581044a906.xhtml）中开发的 MERN
    应用程序代码集成。在深入实现游戏功能之前，我们首先将在下一节中查看设置和开始使用 React 360。
- en: Getting started with React 360
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 React 360
- en: React 360 makes it possible to build VR experiences using the same declarative
    and component-based approach as in React. The underlying technology of React 360
    makes use of the Three.js JavaScript 3D engine to render 3D graphics with WebGL
    within any compatible web browser and also provides us with access to VR headsets
    with the Web VR API.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: React 360 使得使用与 React 中相同的声明式和组件化方法来构建 VR 体验成为可能。React 360 的底层技术利用了 Three.js
    JavaScript 3D 引擎，在任意兼容的 Web 浏览器中使用 WebGL 渲染 3D 图形，并且通过 Web VR API 提供了对 VR 头显的访问。
- en: Though React 360 builds on top of React and the apps run in the browser, React
    360 has a lot in common with React Native, thus making React 360 apps cross-platform.
    This also means that some concepts of React Native are also applicable to React
    360\. Covering all of the React 360 concepts is outside the scope of this book;
    therefore, we will focus on the concepts that are required to build the game and
    integrate them with the MERN stack web application. In the following section,
    we will begin by setting up a React 360 project, which will be extended on later
    in the chapter in order to build the game features.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然React 360 是基于 React 构建的，并且应用在浏览器中运行，但 React 360 与 React Native 有很多共同之处，这使得
    React 360 应用成为跨平台应用。这也意味着 React Native 的一些概念也适用于 React 360。涵盖所有 React 360 概念超出了本书的范围；因此，我们将专注于构建游戏和与
    MERN 栈 Web 应用程序集成的所需概念。在下一节中，我们将首先设置一个 React 360 项目，然后在章节的后续部分扩展以构建游戏功能。
- en: Setting up a React 360 project
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 React 360 项目
- en: React 360 provides developer tools that make it easy to start developing a new
    React 360 project. The steps to get started are detailed in the official React
    360 documentation, so we will only summarize the steps here and point out the
    files that are relevant to developing the game.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: React 360 提供了开发者工具，使得开始开发新的 React 360 项目变得简单。启动步骤在官方 React 360 文档中有详细说明，因此我们在这里只总结步骤，并指出与游戏开发相关的文件。
- en: 'Since we already have Node and Yarn installed for the MERN applications, we
    can start by installing the React 360 CLI tool by running the following command
    in the command line:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已为 MERN 应用程序安装了 Node 和 Yarn，我们可以通过在命令行中运行以下命令来开始安装 React 360 CLI 工具：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, use this React 360 CLI tool to create a new application, and install
    the required dependencies by running the following command from the command line:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用这个 React 360 CLI 工具创建一个新的应用程序，并从命令行运行以下命令来安装所需的依赖项：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will add the new React 360 application with all of the necessary files
    into a folder, named `MERNVR`, in the current directory. Finally, we can go into
    this folder in the command line, and run the application using the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在当前目录中创建一个名为 `MERNVR` 的文件夹，并将所有必要的文件添加到该文件夹中。最后，我们可以在命令行中进入这个文件夹，并使用以下命令运行应用程序：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This `start` command will initialize the local development server, and the default
    React 360 application can be viewed in the browser at `http://localhost:8081/index.html`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此`start`命令将初始化本地开发服务器，默认的React 360应用程序可以在浏览器中的`http://localhost:8081/index.html`查看。
- en: To update this starter application and implement our game features, we will
    modify code mainly in the `index.js` file with some minor updates in the `client.js`
    file, which can be found in the `MERNVR` project folder.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新这个启动应用程序并实现我们的游戏功能，我们将主要修改`index.js`文件中的代码，并在`client.js`文件中进行一些小的更新，这些文件可以在`MERNVR`项目文件夹中找到。
- en: 'The default code in `index.js` for the starter application generated by React
    360 should be as follows. Note that it renders a Welcome to React 360 text in
    a 360-degree world in the browser:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由React 360生成的启动应用程序的默认`index.js`代码如下。请注意，它在一个360度的世界中渲染了“欢迎使用React 360”文本：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This `index.js` file contains the application''s content and the main code,
    including the view and style code. The code in `client.js` contains the boilerplate
    that connects the browser to the React application in `index.js`. The default
    `client.js` file in the starter project folder should look like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`index.js`文件包含了应用程序的内容和主要代码，包括视图和样式代码。`client.js`中的代码包含了将浏览器连接到`index.js`中React应用程序的样板代码。启动项目文件夹中的默认`client.js`文件应该看起来像这样：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code executes the React code defined in `index.js`, essentially creating
    a new instance of React 360 and loading the React code by attaching it to the
    DOM.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码执行`index.js`中定义的React代码，本质上创建了一个新的React 360实例，并通过将其附加到DOM来加载React代码。
- en: With this, the default React 360 starter project is set up and ready for extension.
    Before modifying this code to implement the game, in the next section, we will
    first look at some of the key concepts related to developing 3D VR experiences,
    in the context of how these concepts are applied with React 360.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，默认的React 360启动项目就设置好了，并准备好扩展。在修改此代码以实现游戏之前，在下一节中，我们将首先查看一些与开发3D VR体验相关的关键概念，以及这些概念如何与React
    360结合应用。
- en: Key concepts for developing the VR game
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发VR游戏的关键概念
- en: Before creating VR content and an interactive 360-degree experience for the
    game, we will highlight some of the relevant aspects of the virtual world, and
    how React 360 can be used to work with these VR concepts. Given the wide range
    of possibilities in the VR space and the various options available with React
    360, we need to identify and explore the specific concepts that will enable us
    to implement the interactive VR features we defined for the game. In the following
    sections, we will discuss the images that will make up the 360-degree world of
    the game, the 3D positioning system, along with the React 360 components, APIs,
    and input events that will be utilized to implement the game.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建游戏中的VR内容和交互式360度体验之前，我们将突出显示虚拟世界的相关方面，以及如何使用React 360与这些VR概念协同工作。鉴于VR空间中的广泛可能性以及React
    360提供的各种选项，我们需要确定并探索特定的概念，这些概念将使我们能够实现为游戏定义的交互式VR功能。在接下来的章节中，我们将讨论构成游戏360度世界的图像，3D定位系统，以及将用于实现游戏的React
    360组件、API和输入事件。
- en: Equirectangular panoramic images
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等经纬全景图像
- en: The VR world for the game will be composed of a panoramic image that is added
    to the React 360 environment as a background image.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的VR世界将由一个全景图像组成，该图像作为背景图像添加到React 360环境中。
- en: Panorama images are generally 360-degree images or spherical panoramas projected
    onto a sphere that completely surrounds the viewer. A common and popular format
    for 360-degree panorama images is the equirectangular format. React 360 currently
    supports mono and stereo formats for equirectangular images.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 全景图像通常是360度图像或球形全景，这些图像被投影到一个完全围绕观众的球体上。360度全景图像的一种常见且流行的格式是等经纬格式。React 360目前支持等经纬图像的单色和立体格式。
- en: To learn more about the 360 images and video support in React 360, refer to
    the React 360 documentation at [facebook.github.io/react-360/docs/setup.html](https://facebook.github.io/react-360/docs/setup.html).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于React 360中360度图像和视频支持的信息，请参阅React 360文档[facebook.github.io/react-360/docs/setup.html](https://facebook.github.io/react-360/docs/setup.html)。
- en: 'The photograph shown here is an example of an equirectangular, 360-degree panoramic
    image. To set the world background for a game in MERN VR Game, we will use this
    kind of image:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的照片是一个等经纬，360度全景图像的例子。在MERN VR游戏中设置世界背景时，我们将使用这种图像：
- en: '![](img/c413a1ae-2ec4-4546-9026-1b8a8dd83eae.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c413a1ae-2ec4-4546-9026-1b8a8dd83eae.jpg)'
- en: An equirectangular panoramic image consists of a single image with an aspect
    ratio of 2:1, where the width is twice the height. These images are created with
    a special 360-degree camera. An excellent source of equirectangular images is
    Flickr; you just need to search for the `equirectangular` tag.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 等经线全景图像由一个宽高比为 2:1 的单一图像组成，其中宽度是高度的两倍。这些图像使用特殊的 360 度相机创建。Flickr 是等经线图像的一个优秀来源；你只需搜索
    `equirectangular` 标签。
- en: Creating the game world by setting the background scene using an equirectangular
    image in a React 360 environment will make the VR experience immersive and transport
    the user to a virtual location. To enhance this experience and add 3D objects
    in this VR world effectively, we need to learn more about the layout and coordinate
    system relevant to the 3D space, which is discussed next.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 React 360 环境中使用等经线图像设置背景场景来创建游戏世界，将使 VR 体验更加沉浸式，并将用户带到虚拟位置。为了有效地在这个 VR 世界中添加
    3D 对象并增强这种体验，我们需要了解与 3D 空间相关的布局和坐标系，这将在下文中讨论。
- en: 3D position – coordinates and transforms
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D 位置 - 坐标和变换
- en: We need to understand positioning and orientation in the VR world space, in
    order to place 3D objects at the desired locations and to make the VR experience
    feel more real. In the following sections, we will review the 3D coordinate system
    to help us to determine the location of a virtual object in the 3D space, and
    the transform capabilities in React 360, which will allow us to position, orient,
    and scale objects as required.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 VR 世界空间中放置 3D 对象并使 VR 体验更加真实，我们需要了解定位和方向。在接下来的章节中，我们将回顾 3D 坐标系，以帮助我们确定虚拟对象在
    3D 空间中的位置，以及 React 360 中的变换功能，这将允许我们按要求定位、定向和缩放对象。
- en: 3D coordinate system
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D 坐标系
- en: For mapping in a 3D space, React 360 uses a three-dimensional meter-based coordinate
    system that is similar to the OpenGL® 3D coordinate system. This allows individual
    components to be transformed, moved, or rotated in 3D in relation to the layout
    in their parent component.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 3D 空间的映射，React 360 使用一个类似于 OpenGL® 3D 坐标系的基于米的三维坐标系统。这允许单个组件相对于其父组件的布局在 3D
    中进行变换、移动或旋转。
- en: The 3D coordinate system used in React 360 is a right-handed system. This means
    the positive *x* axis is to the right, the positive *y* axis points upward, and
    the positive *z* axis is backward. This provides a better mapping with common
    coordinate systems of the world space in assets and 3D world modeling.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: React 360 中使用的 3D 坐标系是一个右手坐标系。这意味着正 *x* 轴在右侧，正 *y* 轴向上，正 *z* 轴向后。这提供了与世界空间中资产和
    3D 世界建模的常见坐标系统更好的映射。
- en: 'If we try to visualize the 3D space, the user starts out at the center of the
    **x-y-z** axes pictured in the following diagram:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试可视化 3D 空间，用户将开始于以下图中 **x-y-z** 轴的中心：
- en: '![](img/ba726573-d550-4e4b-9d27-8df91a3868d6.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba726573-d550-4e4b-9d27-8df91a3868d6.png)'
- en: The ***z ***axis points forward toward the user and the user looks out at the **-z **axis
    direction. The **y **axis runs up and down, whereas the **x **axis runs from side
    to side. The curved arrow in the diagram shows the direction of the positive rotation
    values.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**z** 轴指向用户前方，用户朝向 **-z** 轴方向望去。**y** 轴垂直上下，而 **x** 轴则从一侧到另一侧。图中弯曲的箭头显示了正旋转值的方向。'
- en: While deciding where and how to place 3D objects in the 360-degree world, we
    will have to set values according to this 3D coordinate system. In the next section,
    we will demonstrate how to place 3D objects using React 360 by setting values
    in transform properties.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定在 360 度世界中放置 3D 对象的位置和方式时，我们必须根据这个 3D 坐标系设置值。在下一节中，我们将通过设置变换属性来演示如何使用 React
    360 放置 3D 对象。
- en: Transforming 3D objects
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换 3D 对象
- en: 'The position and orientation of a 3D object will be determined by its transform
    properties, which will have values corresponding to the 3D coordinate system.
    In the following screenshot, the same 3D book object is placed in two different
    positions and orientations by changing the `transform` properties in the style
    attribute of a React 360 `Entity` component that is rendering the 3D object:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 对象的位置和方向将由其变换属性确定，这些属性将具有与 3D 坐标系相对应的值。在以下屏幕截图中，通过更改渲染 3D 对象的 React 360 `Entity`
    组件样式属性中的 `transform` 属性，将相同的 3D 书籍对象放置在两个不同的位置和方向：
- en: '![](img/228b2a5e-9d0e-48c0-a64f-693a2961e5eb.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/228b2a5e-9d0e-48c0-a64f-693a2961e5eb.png)'
- en: 'This transform feature is based on the transform style used in React, which
    React 360 extends to be fully 3D, considering the **x-y-z** axes. The `transform`
    properties are added to the `Entity` components in the `style` attribute as an
    array of keys and values in the following form:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此变换功能基于React中使用的变换样式，React 360将其扩展为完全3D，考虑到**x-y-z**轴。`transform`属性以键值对数组的形式添加到`Entity`组件的`style`属性中：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The transform commands and values that are relevant to the 3D objects to be
    placed in our games are `translate [x, y, z]`, with values in meters; `rotate
    [x, y, z]`, with values in degrees; and `scale`, to determine the size of the
    object across all axes. We can also utilize the `matrix` command instead, which
    accepts an array of 16 numbers representing the translation, rotation, and scale
    values.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们要放置在游戏中的3D对象相关的变换命令和值是`translate [x, y, z]`，单位为米；`rotate [x, y, z]`，单位为度；以及`scale`，用于确定对象在所有轴上的大小。我们还可以利用`matrix`命令，它接受一个包含16个数字的数组，代表平移、旋转和缩放值。
- en: To learn more about the React 360 3D coordinates and transforms, refer to the
    React 360 documentation at [facebook.github.io/react-360/docs/setup.html](https://facebook.github.io/react-360/docs/setup.html).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于React 360 3D坐标和变换的信息，请参阅React 360文档，网址为[facebook.github.io/react-360/docs/setup.html](https://facebook.github.io/react-360/docs/setup.html)。
- en: We will utilize these transform properties to position and orient 3D objects
    according to the 3D coordinate system while placing objects in the game world
    built using React 360\. In the next section, we will go over the React 360 components
    that will allow us to build the game world.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用这些变换属性来根据3D坐标系定位和定向3D对象，同时在用React 360构建的游戏世界中放置对象。在下一节中，我们将介绍React 360组件，这些组件将允许我们构建游戏世界。
- en: React 360 components
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 360组件
- en: React 360 provides a range of components that can be used out of the box to
    create the VR user interface for the game. This range consists of basic components
    available from React Native and also VR-specific components that will allow you
    to incorporate the interactive 3D objects in the VR game. In the following sections,
    we will summarize the specific components that will be used to build the game
    view and features, including core components, such as `View` and `Text`, and VR-specific
    components, such as `Entity` and `VrButton`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: React 360提供了一系列可以直接用于创建游戏VR用户界面的组件。这个范围包括从React Native可用的基本组件，以及允许你在VR游戏中集成交互式3D对象的VR特定组件。在接下来的几节中，我们将总结用于构建游戏视图和功能的特定组件，包括核心组件，如`View`和`Text`，以及VR特定组件，如`Entity`和`VrButton`。
- en: Core components
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心组件
- en: The core components in React 360 include two of React Native's built-in components
    – the `Text` and `View` components. In the game, we will use these two components to
    add content to the game world. In the following sections, we will discuss these
    two core components.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: React 360的核心组件包括React Native的两个内置组件——`Text`和`View`组件。在游戏中，我们将使用这两个组件向游戏世界添加内容。在接下来的几节中，我们将讨论这两个核心组件。
- en: View
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: View
- en: 'The `View` component is the most fundamental component for building a user
    interface in React Native, and it maps directly to the native view equivalent
    on whatever platform React Native is running on. In our case, since the application
    will render in the browser, it will map to a `<div>` element in the browser. The
    `View` component can be added as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`View`组件是构建React Native用户界面的最基本组件，它直接映射到React Native在运行的平台上的原生视图等效物。在我们的案例中，由于应用程序将在浏览器中渲染，它将映射到浏览器的`<div>`元素。`View`组件可以添加如下：'
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `View` component is typically used as a container for other components;
    it can be nested inside other views and can have zero-to-many children of any
    type.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`View`组件通常用作其他组件的容器；它可以嵌套在其他视图中，并且可以有零到多个任何类型的子组件。'
- en: We will use `View` components to hold the game world view and add 3D object
    entities and text to the game. Next, we will look at the `Text` component, which
    will allow us to add text to the view.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`View`组件来包含游戏世界视图，并添加3D对象实体和文本到游戏中。接下来，我们将查看`Text`组件，它将允许我们在视图中添加文本。
- en: Text
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本
- en: 'The `Text` component is a React Native component for displaying text, and we
    will use it to render strings in a 3D space by placing `Text` components inside `View`
    components, as shown in the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Text`组件是一个用于显示文本的React Native组件，我们将通过将`Text`组件放置在`View`组件内部来在3D空间中渲染字符串，如下面的代码所示：'
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will compose the game world using these two React Native components, along
    with other React 360 components to integrate VR features into the game. In the
    next section, we will go over the React 360 components that will let us add interactive
    VR objects in the game world.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这两个React Native组件以及其他React 360组件来组合游戏世界，并将VR功能集成到游戏中。在下一节中，我们将介绍React 360组件，这些组件将允许我们在游戏世界中添加交互式VR对象。
- en: Components for the 3D VR experience
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D VR体验组件
- en: React 360 provides a set of its own components to create the VR experience.
    Specifically, we will use the `Entity` component to add 3D objects and a `VrButton`
    component to capture clicks from the user. We will discuss the `Entity` and `VrButton`
    components in the following sections.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: React 360提供了一套自己的组件来创建VR体验。具体来说，我们将使用`Entity`组件添加3D对象，并使用`VrButton`组件来捕获用户的点击。我们将在以下章节中讨论`Entity`和`VrButton`组件。
- en: Entity
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体
- en: 'In order to add 3D objects to the game world, we will use the `Entity` component,
    which allows us to render 3D objects in React 360\. The `Entity` component can
    be added in the view as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将3D对象添加到游戏世界，我们将使用`Entity`组件，它允许我们在React 360中渲染3D对象。以下是在视图中添加`Entity`组件的方法：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Files containing the specific 3D object''s information are added to the `Entity`
    component using a `source` attribute. The `source` attribute takes an object of
    key-value pairs to map resource file types to their locations. React 360 supports
    the Wavefront OBJ file format, which is a common representation for 3D models.
    So, in the `source` attribute, the `Entity` component supports the following keys:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 包含特定3D对象信息的文件通过`source`属性添加到`Entity`组件中。`source`属性接受一个键值对对象，将资源文件类型映射到其位置。React
    360支持Wavefront OBJ文件格式，这是3D模型的常见表示。因此，在`source`属性中，`Entity`组件支持以下键：
- en: '`obj`: The location of an OBJ-formatted model'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`obj`：OBJ格式模型的存储位置'
- en: '`mtl`: The location of an MTL-formatted material (the companion to OBJ)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mtl`：MTL格式材料（OBJ的配套文件）的位置'
- en: The values for the `obj` and `mtl` properties point to the location of these
    files and can be static strings, `asset()` calls, `require()` statements, or URI
    strings.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj`和`mtl`属性的值指向这些文件的位置，可以是静态字符串、`asset()`调用、`require()`语句或URI字符串。'
- en: OBJ (or .OBJ) is a geometry definition file format that was first developed
    by Wavefront Technologies. It is a simple data format that represents 3D geometry
    as a list of vertices and texture vertices. OBJ coordinates have no units, but
    OBJ files can contain scale information in a human-readable comment line. You
    can learn more about this format at [paulbourke.net/dataformats/obj/](http://paulbourke.net/dataformats/obj/).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: OBJ（或 .OBJ）是一种几何定义文件格式，最初由Wavefront Technologies开发。它是一种简单的数据格式，将3D几何形状表示为顶点和纹理顶点的列表。OBJ坐标没有单位，但OBJ文件可以在可读的注释行中包含缩放信息。您可以在[paulbourke.net/dataformats/obj/](http://paulbourke.net/dataformats/obj/)了解更多关于此格式的信息。
- en: MTL (or .MTL) are material library files that contains one or more material
    definitions, each of which includes the color, texture, and reflection map of
    individual materials. These are applied to the surfaces and vertices of objects.
    You can learn more about this format at [paulbourke.net/dataformats/mtl/](http://paulbourke.net/dataformats/mtl/).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: MTL（或 .MTL）是包含一个或多个材料定义的材料库文件，每个定义都包括单个材料的颜色、纹理和反射图。这些应用于对象的表面和顶点。您可以在[paulbourke.net/dataformats/mtl/](http://paulbourke.net/dataformats/mtl/)了解更多关于此格式的信息。
- en: The `Entity` component also takes `transform` property values in the `style`
    attribute, so the objects can be placed at the desired positions and orientations
    in the 3D world space.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entity`组件还接受`style`属性中的`transform`属性值，因此可以将对象放置在3D世界空间中期望的位置和方向。'
- en: In our MERN VR Game application, makers will add URLs pointing to the VR object
    files (both `.obj` and `.mtl`) for each of their `Entity` objects in a game, and
    also specify the `transform` property values to indicate where and how the 3D
    objects should be placed in the game world.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的MERN VR游戏应用中，制作者将为每个游戏中的`Entity`对象添加指向VR对象文件（`.obj`和`.mtl`）的URL，并指定`transform`属性值，以指示3D对象在游戏世界中的放置位置和方式。
- en: A good source of 3D objects is [https://clara.io/](https://clara.io/), with
    multiple file formats available for download and use.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的3D对象来源是[https://clara.io/](https://clara.io/)，提供多种文件格式可供下载和使用。
- en: The `Entity` component will render 3D objects in the 3D world space. In order
    to make these objects interactive, we need to use the `VrButton` component, which
    is discussed in the next section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entity` 组件将在 3D 世界空间中渲染 3D 对象。为了使这些对象具有交互性，我们需要使用 `VrButton` 组件，这在下一节中将会讨论。'
- en: VrButton
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VrButton
- en: 'The `VrButton` component in React 360 will help us to implement a simple, button-style `onClick`
    behavior for the objects and `Text` buttons that will be added to the game. A
    `VrButton` component is not visible in the view by default and will only act as
    a wrapper to capture events, but it can be styled in the same way as a `View`
    component, as shown in the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: React 360 中的 `VrButton` 组件将帮助我们为要添加到游戏中的对象和 `Text` 按钮实现简单的、按钮风格的 `onClick` 行为。默认情况下，`VrButton`
    组件在视图中是不可见的，它仅作为事件捕获的包装器，但可以像 `View` 组件一样进行样式化，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This component is a helper for managing click-type interactions from the user
    across different input devices. Input events that will trigger the click event
    include a spacebar press on the keyboard, a left-click on the mouse, and a touch
    on the screen.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件是管理用户在不同输入设备上进行的点击类型交互的辅助工具。将触发点击事件的输入事件包括键盘上的空格键按下、鼠标的左键点击以及屏幕上的触摸。
- en: The `Entity` and `VrButton` components from React 360 will allow us to render
    interactive 3D objects in the game world. To integrate other VR functionalities
    such as setting the background scene and playing audio in the game world, we will
    explore relevant options from the React 360 API in the next section.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: React 360 的 `Entity` 和 `VrButton` 组件将使我们能够在游戏世界中渲染交互式 3D 对象。为了在游戏世界中集成其他 VR
    功能，如设置背景场景和播放音频，我们将在下一节中探索 React 360 API 中的相关选项。
- en: The React 360 API
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 360 API
- en: Besides the React 360 components discussed in the previous section, we will
    utilize the APIs provided by React 360 to implement functionality such as setting
    the background scene, playing audio, dealing with external links, adding styles,
    capturing the current orientation of the user's view, and using static asset files.
    In the following sections, we will explore the `Environment` API, the `Audio`
    and `Location` native modules, the `StyleSheet` API, the `VrHeadModel` module,
    and the asset specification options.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上一节中讨论的 React 360 组件外，我们还将利用 React 360 提供的 API 实现设置背景场景、播放音频、处理外部链接、添加样式、捕获用户当前视图方向以及使用静态资产文件等功能。在接下来的章节中，我们将探讨
    `Environment` API、`Audio` 和 `Location` 原生模块、`StyleSheet` API、`VrHeadModel` 模块以及资产指定选项。
- en: Environment
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境
- en: 'In the game, we will set the world or background scene with equirectangular
    panoramic images. We will use the `Environment` API from React 360 to change this
    background scene dynamically from the React code using its `setBackgroundImage`
    method. This method can be used as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，我们将使用等角全景图像设置世界或背景场景。我们将使用 React 360 的 `Environment` API，通过其 `setBackgroundImage`
    方法，在 React 代码中动态地更改此背景场景。此方法可以使用如下方式：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This method sets the current background image with the resource at the specified
    URL. When we integrate the React 360 game code with the MERN stack containing
    the game application backend, we can use this to set the game world image dynamically
    using image links provided by the user. In the next section, we will explore native
    modules that will allow us to play audio in this rendered scene in the browser,
    and provide access to the browser location.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用指定 URL 的资源设置当前背景图像。当我们将 React 360 游戏代码与包含游戏应用后端的 MERN 栈集成时，我们可以使用此方法通过用户提供的图像链接动态设置游戏世界图像。在下一节中，我们将探讨允许我们在浏览器中播放此渲染场景中的音频以及提供浏览器位置访问权限的原生模块。
- en: Native modules
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原生模块
- en: 'Native modules in React 360 provide us with the ability to access functionality
    that is only available in the main browser environment. In the game, we will use
    `AudioModule` in `NativeModules`, to play sounds in response to user activity,
    and the `Location` module, to give us access to `window.location` in the browser
    to handle external links. These modules can be accessed in `index.js`, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: React 360 中的原生模块为我们提供了访问仅在主浏览器环境中可用的功能的能力。在游戏中，我们将使用 `NativeModules` 中的 `AudioModule`
    来响应用户活动播放声音，以及 `Location` 模块，以在浏览器中访问 `window.location` 来处理外部链接。这些模块可以在 `index.js`
    中按如下方式访问：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can use these imported modules in the code to manipulate the audio and location
    URL in the browser. In the following sections, we will explore how these modules
    can be used to implement the features of the game.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在代码中使用这些导入的模块来操作浏览器中的音频和位置URL。在接下来的章节中，我们将探讨这些模块如何被用来实现游戏的功能。
- en: AudioModule
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频模块
- en: 'When the user interacts with the 3D objects in the game, we will play sounds
    based on whether the object can be collected or not, and also whether the game
    has been completed. The `AudioModule` in `NativeModules` allows us to add sound
    to the VR world as background environmental audio, one-off sound effects, and
    spatial audio. In our game, we will use environmental audio and one-off sound
    effects:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户与游戏中的3D对象交互时，我们将根据对象是否可收集以及游戏是否已完成来播放声音。`NativeModules`中的`AudioModule`允许我们在VR世界中添加声音，作为背景环境音频、一次性音效和空间音频。在我们的游戏中，我们将使用环境音频和一次性音效：
- en: '**Environmental audio**: To play audio on loop and set the mood when the game
    is successfully completed, we will use the `playEnvironmental` method, which takes
    an audio file path as the `source` attribute, and the `loop` option as a `playback`
    parameter, as shown in the following code:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境音频**：为了在游戏成功完成后循环播放音频并设置氛围，我们将使用`playEnvironmental`方法，该方法将音频文件路径作为`source`属性，并将`loop`选项作为`playback`参数，如下面的代码所示：'
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Sound effects**: To play a single sound once when the user clicks on 3D objects,
    we will use the `playOneShot` method that takes an audio file path as the `source` attribute,
    as shown in the following code:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音效**：当用户点击3D对象时，我们将使用`playOneShot`方法播放单个声音，该方法将音频文件路径作为`source`属性，如下面的代码所示：'
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `source` attribute in the options passed to `playEnvironmental` and `playOneShot`
    takes a resource file location to load the audio. It can be an `asset()` statement
    or a resource URL declaration in the form of `{uri: ''PATH''}`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '传递给`playEnvironmental`和`playOneShot`的选项中的`source`属性接受一个资源文件位置来加载音频。它可以是`asset()`语句或形式为`{uri:
    ''PATH''}`的资源URL声明。'
- en: We will call these `AudioModule` methods to play specified audio files as needed
    from the game implementation code. In the next section, we will look at how we
    can use the `Location` module, which is another native module in React 360.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在游戏实现代码中调用这些`AudioModule`方法，根据需要播放指定的音频文件。在下一节中，我们将探讨如何使用`Location`模块，这是React
    360中的另一个原生模块。
- en: Location
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位置
- en: After we integrate the React 360 code containing the game with the MERN stack
    containing the game application backend, the VR game will be launched from the
    MERN server at a declared route containing the specific game's ID. Then, once
    a user completes a game, they will also have the option to leave the VR space
    and go to a URL containing a list of other games. To handle these incoming and
    outgoing app links in the React 360 code, we will utilize the `Location` module
    in `NativeModules`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将包含游戏的React 360代码与包含游戏应用程序后端的MERN堆栈集成后，VR游戏将从声明路由中的MERN服务器启动，该路由包含特定游戏的ID。然后，一旦用户完成游戏，他们也将有选择离开VR空间并前往包含其他游戏列表的URL。为了在React
    360代码中处理这些传入和传出的应用链接，我们将利用`NativeModules`中的`Location`模块。
- en: 'The `Location` module is essentially the `Location` object returned by the
    read-only `window.location` property in the browser. We will use the `replace` method
    and the `search` property in the `Location` object to implement features related
    to external links. We will handle outgoing and incoming links as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Location`模块实际上是浏览器中只读`window.location`属性返回的`Location`对象。我们将使用`Location`对象中的`replace`方法和`search`属性来实现与外部链接相关的功能。我们将如下处理传入和传出链接：'
- en: '**Handling outgoing links**: When we want to direct the user out of the VR
    application to another link, we can use the `replace` method in `Location`, as
    shown in the following code:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理传出链接**：当我们想要将用户从VR应用程序导向另一个链接时，我们可以使用`Location`中的`replace`方法，如下面的代码所示：'
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Handling incoming links**: When the React 360 app is launched from an external
    URL and after the registered component mounts, we can access the URL and retrieve
    its query string part using the `search` property in `Location`, as shown in the
    following code.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理传入链接**：当React 360应用从外部URL启动并在已注册的组件挂载后，我们可以通过`Location`中的`search`属性访问URL并检索其查询字符串部分，如下面的代码所示。'
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For the purpose of integrating this React 360 component with MERN VR Game, and
    dynamically loading game details, we will capture this initial URL to parse the
    game ID from a query parameter and then use it to make a read API call to the
    MERN application server. This implementation is elaborated further in [Chapter
    11](17bbfed7-9867-4c8b-99fd-42581044a906.xhtml), *Making the VR Game Dynamic Using
    MERN*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此 React 360 组件与 MERN VR 游戏（MERN VR Game）集成，并动态加载游戏详情，我们将捕获此初始 URL，从查询参数中解析游戏
    ID，然后使用它向 MERN 应用程序服务器发起读取 API 调用。这种实现方式在 [第 11 章](17bbfed7-9867-4c8b-99fd-42581044a906.xhtml)，*使用
    MERN 使 VR 游戏动态化* 中有进一步的阐述。
- en: Besides using these native modules from the React 360 API, we will also use
    the StyleSheet API to add styling to the components rendered to make the game
    view. We will demonstrate how to use the StyleSheet API in the next section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 React 360 API 中的这些原生模块外，我们还将使用 StyleSheet API 为渲染的游戏视图添加样式。我们将在下一节中演示如何使用
    StyleSheet API。
- en: StyleSheet
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: StyleSheet
- en: 'The StyleSheet API from React Native can also be used in React 360 to define
    several styles in one place rather than adding styles to individual components.
    The styles can be defined using StyleSheet, as shown in the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 的 StyleSheet API 也可以在 React 360 中使用，以便在单个位置定义多个样式，而不是向单个组件添加样式。样式可以使用
    StyleSheet 定义，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'These style objects defined using `StyleSheet.create` can be added to components
    as required, as shown in the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `StyleSheet.create` 定义的这些样式对象可以根据需要添加到组件中，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will apply the CSS styles to the `View` and `Text` components accordingly.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将根据需要将 CSS 样式应用于 `View` 和 `Text` 组件。
- en: The default distance units for CSS properties, such as width and height, are
    in meters when mapping to 3D space in React 360, whereas the default distance
    units are in pixels for 2D interfaces in React Native.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 360 中将 CSS 属性（如宽度、高度）映射到 3D 空间时，默认的距离单位是米，而 React Native 中的 2D 接口的默认距离单位是像素。
- en: We will use StyleSheet in this way to define styles for the components that
    will make up the game view. In the next section, we will discuss the `VrHeadModel`
    module in React 360, which will allow us to figure out where the user is currently
    looking.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 StyleSheet 以这种方式为将构成游戏视图的组件定义样式。在下一节中，我们将讨论 React 360 中的 `VrHeadModel`
    模块，它将使我们能够确定用户当前正在看哪里。
- en: VrHeadModel
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VrHeadModel
- en: '`VrHeadModel` is a utility module in React 360 that simplifies the process
    of obtaining the current orientation of the headset. Since the user is moving
    around in a VR space, when the desired feature requires that an object or piece
    of text should be placed in front of or with respect to the user''s current orientation,
    it becomes necessary to know exactly where the user is currently gazing.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`VrHeadModel` 是 React 360 中的一个实用模块，它简化了获取头戴式设备当前方向的过程。由于用户在 VR 空间中移动，当需要将对象或文本放置在用户当前方向之前或相对于用户当前方向时，了解用户当前注视的确切位置变得至关重要。'
- en: In MERN VR Game, we will use this to show the game completed message to the
    user in front of their view, no matter where they end up turning to from their
    initial position. For example, the user may be looking up or down when collecting
    the final object, and the completed message should pop up wherever the user is
    gazing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MERN VR 游戏（MERN VR Game）中，我们将使用此功能向用户展示游戏完成的消息，无论他们从初始位置转向何处。例如，当用户在收集最终对象时可能向上或向下看，完成消息应出现在用户注视的任何位置。
- en: To implement this, we will retrieve the current head matrix as an array of numbers
    using `getHeadMatrix()` from `VrHeadModel`, and set it as a value for the `transform`
    property in the style attribute of the `View` component containing the game completed
    message.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用 `VrHeadModel` 中的 `getHeadMatrix()` 从数组中检索当前头矩阵，并将其设置为包含游戏完成消息的
    `View` 组件样式属性中的 `transform` 属性的值。
- en: This will render the message at the location where the user is currently gazing.
    We will see the usage of this `getHeadMatrix()` function later in the chapter, in
    the *Building the game view in React 360 *section. In the next section, we will
    discuss how static assets can be loaded in React 360.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在用户当前注视的位置渲染消息。我们将在本章的 *在 React 360 中构建游戏视图* 部分中看到 `getHeadMatrix()` 函数的使用。在下一节中，我们将讨论如何在
    React 360 中加载静态资源。
- en: Loading assets
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载资源
- en: In order to load any static asset files such as image or audio files in the
    code, we can utilize the `asset` method in React 360\. This `asset()` functionality
    in React 360 allows us to retrieve external resource files, including audio and
    image files.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在代码中加载任何静态资产文件，例如图像或音频文件，我们可以利用 React 360 中的 `asset` 方法。React 360 中的 `asset()`
    功能使我们能够检索外部资源文件，包括音频和图像文件。
- en: 'For example, we will place the sound audio files for the game in the `static_assets`
    folder, to be retrieved using `asset()` for each audio added to the game, as shown
    in the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将游戏的声音音频文件放置在 `static_assets` 文件夹中，使用 `asset()` 来检索添加到游戏中的每个音频，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will load the audio file to be played in the call to `playOneShot`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在调用 `playOneShot` 时加载要播放的音频文件。
- en: With these different APIs and modules available in React 360, we will integrate
    different features for the VR game such as setting the background scene, playing
    audio, adding styles, loading static files, and retrieving the user orientation.
    In the next section, we will look at some of the input events available in React
    360 that will allow us to make the game interactive.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 360 中，我们有这些不同的 API 和模块可用，我们将集成不同的功能以用于 VR 游戏，例如设置背景场景、播放音频、添加样式、加载静态文件和检索用户方向。在下一节中，我们将查看
    React 360 中的一些可用输入事件，这将使我们能够使游戏具有交互性。
- en: React 360 input events
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 360 输入事件
- en: In order to make the game interface interactive, we will utilize some of the
    input event handlers exposed in React 360\. Input events are collected from mouse,
    keyboard, touch, and gamepad interactions, and also with the `gaze` button click
    on a VR headset.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使游戏界面具有交互性，我们将利用 React 360 中公开的一些输入事件处理器。输入事件来自鼠标、键盘、触摸和游戏手柄交互，以及 VR 头盔上的
    `gaze` 按钮点击。
- en: 'The specific input events we will work with are the `onEnter`, `onExit`, and
    `onClick` events, as discussed in the following list:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将工作的特定输入事件是 `onEnter`、`onExit` 和 `onClick` 事件，如下表所述：
- en: '`onEnter`: This event is fired whenever the platform cursor begins intersecting
    with a component. We will capture this event for the VR objects in the game, so
    the objects can start rotating around the *y* axis when the platform cursor enters
    the specific object.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onEnter`：每当平台光标开始与组件相交时，都会触发此事件。我们将捕获这个事件用于游戏中的 VR 对象，以便当平台光标进入特定对象时，对象可以开始围绕
    *y* 轴旋转。'
- en: '`onExit`: This event is fired whenever the platform cursor stops intersecting
    with a component. It has the same properties as the `onEnter` event and we will
    use it to stop rotating the VR object just exited.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onExit`：每当平台光标停止与组件相交时，都会触发此事件。它具有与 `onEnter` 事件相同的属性，我们将使用它来停止旋转刚刚退出的 VR
    对象。'
- en: '`onClick`: The `onClick` event is used with the `VrButton` component, and is
    fired when there is click interaction with `VrButton`. We will use this to set
    click event handlers on the VR objects, and also on the game complete message
    to redirect the user out of the VR application to a link containing a list of
    games.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onClick`：`onClick` 事件与 `VrButton` 组件一起使用，当与 `VrButton` 进行点击交互时触发。我们将使用它来设置
    VR 对象上的点击事件处理器，以及游戏完成消息，以便将用户从 VR 应用程序重定向到包含游戏列表的链接。'
- en: These events will allow us to add actions to the game, which happens when the
    user does something.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件将允许我们在游戏中添加动作，即当用户进行某些操作时发生的动作。
- en: While implementing the VR game, we will apply 3D world concepts to determine
    how to set the game world with equirectangular panoramic images, and position
    VR objects in this world based on the 3D coordinate system. We will use React
    360 components such as `View`, `Text`, `Entity`, and `VrButton` to render the
    VR game view. We can also use available React 360 APIs to load audio and external
    URLs for the VR game in the browser environment. Finally, we can utilize available
    React 360 events that capture user interactions to make the VR game interactive.
    With the VR-related concepts, React 360 components, APIs, modules, and events
    discussed in this section, we are ready to define the specific game data details
    before we start implementing the complete VR game using these concepts. In the
    next section, we will go over the game data structure and details.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 VR 游戏时，我们将应用 3D 世界概念来确定如何使用等距圆盘全景图像设置游戏世界，并根据 3D 坐标系在这个世界中定位 VR 物体。我们将使用
    React 360 组件，如 `View`、`Text`、`Entity` 和 `VrButton` 来渲染 VR 游戏视图。我们还可以使用可用的 React
    360 API 在浏览器环境中加载音频和外部 URL，用于 VR 游戏。最后，我们可以利用可用的 React 360 事件来捕获用户交互，使 VR 游戏具有交互性。在本节中，我们讨论了与
    VR 相关的概念、React 360 组件、API、模块和事件，我们准备在开始使用这些概念实现完整的 VR 游戏之前定义具体的游戏数据详情。在下一节中，我们将介绍游戏数据结构和详情。
- en: Defining game details
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义游戏详情
- en: Each game in MERN VR Game will be defined in a common data structure that the
    React 360 application will also adhere to when rendering the individual game details.
    In the following sections, we will discuss the data structure for capturing a
    game's details, and then highlight the difference between using static game data
    and dynamically loaded game data.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MERN VR 游戏中，每一款游戏都将定义在一个通用的数据结构中，React 360 应用在渲染单个游戏详情时也将遵循此数据结构。在接下来的章节中，我们将讨论捕获游戏详情的数据结构，并突出使用静态游戏数据和动态加载游戏数据之间的区别。
- en: Game data structure
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏数据结构
- en: 'The game data will consist of details such as the game''s name, a URL pointing
    to the location of the equirectangular image for the game world, and two arrays
    containing details for each VR object to be added to the game world. The following
    list indicates the fields corresponding to the game data attributes:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏数据将包括游戏名称、指向游戏世界等距圆盘图像位置的 URL，以及包含要添加到游戏世界中的每个 VR 物体详情的两个数组。以下列表指出了对应游戏数据属性的字段：
- en: '`name`: A string representing the name of the game'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 一个表示游戏名称的字符串'
- en: '`world`: A string with the URL pointing to the equirectangular image either
    hosted on cloud storage, CDNs, or stored on MongoDB'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`world`: 一个字符串，包含指向等距圆盘图像的 URL，这些图像可以托管在云存储、CDNs 上，或者存储在 MongoDB 中'
- en: '`answerObjects`: An array of JavaScript objects containing details of the VR
    objects that can be collected by the player'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`answerObjects`: 一个包含玩家可收集的 VR 物体详情的 JavaScript 对象数组'
- en: '`wrongObjects`: An array of JavaScript objects containing details of the other
    VR objects to be placed in the VR world that cannot be collected by the player'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wrongObjects`: 一个包含其他 VR 物体详情的 JavaScript 对象数组，这些物体将被放置在 VR 世界中，但玩家无法收集'
- en: These details will define each game in the MERN VR Game application. The arrays
    containing the VR object details will store properties of each object to be added
    to the 3D world in the game. In the following section, we will go over the details
    representing a VR object in these arrays.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '这些详情将定义 MERN VR 游戏应用程序中的每个游戏。包含 VR 物体详情的数组将存储要添加到游戏 3D 世界中的每个对象的属性。在以下章节中，我们将介绍表示这些数组中
    VR 物体的详情。 '
- en: Details of VR objects
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VR 物体的详情
- en: 'The two arrays in the game data structure will store details of the VR objects
    to be added in the game world. The `answerObjects` array will contain details
    of the 3D objects that can be collected, and the `wrongObjects` array will contain
    details of 3D objects that cannot be collected. Each object will contain links
    to the 3D data resource files and `transform` style property values. In the following
    list, we will go over these specific details to be stored for each object:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏数据结构中的两个数组将存储要添加到游戏世界中的 VR 物体的详情。`answerObjects` 数组将包含可收集的 3D 物体的详情，而 `wrongObjects`
    数组将包含无法收集的 3D 物体的详情。每个对象将包含指向 3D 数据资源文件的链接和 `transform` 样式属性值。在以下列表中，我们将介绍每个对象需要存储的这些具体详情：
- en: '**OBJ and MTL links**: The 3D data information resources for the VR objects
    will be added to the `objUrl` and `mtlUrl` attributes. These attributes will contain
    the following values:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OBJ 和 MTL 链接**: VR 物体的 3D 数据信息资源将被添加到 `objUrl` 和 `mtlUrl` 属性中。这些属性将包含以下值：'
- en: '`objUrl`: The link to the `.obj` file for the 3D object'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`objUrl`: 3D对象的`.obj`文件的链接'
- en: '`mtlUrl`: The link to the accompanying `.mtl` file'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mtlUrl`: 到配套`.mtl`文件的链接'
- en: The `objUrl` and `mtlUrl` links may point to files either hosted on cloud storage,
    CDNs, or stored on MongoDB. For MERN VR Game, we will assume that makers will
    add URLs to their own hosted OBJ, MTL, and equirectangular image files.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`objUrl`和`mtlUrl`链接可能指向存储在云存储、CDNs或MongoDB上的文件。对于MERN VR游戏，我们将假设制作者将添加他们自己托管OBJ、MTL和等角图像文件的URL。'
- en: '**Translation values**: The position of the VR object in the 3D space will
    be defined with the `translate` values in the following attributes:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Translation values**: VR对象在3D空间中的位置将通过以下属性中的`translate`值来定义：'
- en: '`translateX`: The translation value of the object along the *x* axis'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translateX`: 沿着*x*轴的对象平移值'
- en: '`translateY`: The translation value of the object along the *y* axis'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translateY`: 沿着*y*轴的对象平移值'
- en: '`translateZ`: The translation value of the object along the *z* axis'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translateZ`: 沿着*z*轴的对象平移值'
- en: All translation values are numbers in meters.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所有平移值都是米为单位的数字。
- en: '**Rotation values**: The orientation of the 3D object will be defined with
    the `rotate` values in the following keys:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rotation values**: 3D对象的方向将通过以下键中的`rotate`值来定义：'
- en: '`rotateX`: The rotation value of the object around the *x* axis; in other words,
    turning the object up or down'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotateX`: 围绕*x*轴旋转对象的值；换句话说，向上或向下转动对象'
- en: '`rotateY`: The rotation value of the object around the *y* axis that would
    turn the object left or right'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotateY`: 围绕*y*轴旋转对象的值，这将使对象向左或向右转动'
- en: '`rotateZ`: The rotation value of the object around the *z* axis, making the
    object tilt forward or backward'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotateZ`: 围绕*z*轴旋转对象的值，使对象向前或向后倾斜'
- en: All rotation values are in numbers or string representations of a number in
    degrees.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 所有旋转值都是数字或数字的字符串表示形式。
- en: '**Scale value**: The `scale` value will define the relative size and appearance
    of the 3D object in the 3D environment:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Scale value**: `scale`值将定义3D对象在3D环境中的相对大小和外观：'
- en: '`scale`: A number value that defines uniform scale across all axes'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale`: 一个数值，用于定义所有轴上的统一缩放比例'
- en: '**Color**: If the 3D object''s material texture is not provided in an MTL file,
    a color value can be defined to set the default color of the object in the `color`
    attribute:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色**: 如果3D对象的材质纹理在MTL文件中没有提供，可以在`color`属性中定义一个颜色值来设置对象的默认颜色：'
- en: '`color`: A string value representing color values allowed in CSS'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color`: 表示CSS中允许的颜色值的字符串'
- en: These attributes will define the details of each VR object to be added to the
    game.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性将定义要添加到游戏中的每个VR对象的详细信息。
- en: With this game data structure capable of holding the details of the game and
    its VR objects, we can implement the game in React 360 accordingly with sample
    data values. In the next section, we will look at sample game data and distinguish
    between setting game data statically in contrast to loading it dynamically for
    different games.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种能够存储游戏及其VR对象详细信息的游戏数据结构，我们可以根据示例数据值相应地在React 360中实现游戏。在下一节中，我们将查看示例游戏数据，并区分静态设置游戏数据与为不同游戏动态加载数据。
- en: Static data versus dynamic data
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态数据与动态数据
- en: 'While integrating the game developed using React 360 with the MERN-based application
    in the next chapter, we will update the React 360 code to fetch game data dynamically
    from the backend database. This will render the React 360 game view with different
    games stored in the database. For now, we will start developing the game features
    here with dummy game data that is set in component state. The sample game data
    will be set as follows, using the defined game data structure:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，当将使用React 360开发的游戏与基于MERN的应用程序集成时，我们将更新React 360代码以从后端数据库动态获取游戏数据。这将渲染存储在数据库中的不同游戏的React
    360游戏视图。目前，我们将在这里使用设置在组件状态中的虚拟游戏数据来开发游戏功能。示例游戏数据将按以下方式设置，使用定义的游戏数据结构：
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This game object holds the details of a sample game including the name, a link
    to the 360 world image, and two object arrays with one 3D object detailed in each
    array. For initial development purposes, this sample game data can be set in state
    to be rendered in the game view. Using this game structure and data, in the next
    section, we will implement the game features in React 360.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此游戏对象包含一个示例游戏的详细信息，包括名称、到360世界图像的链接以及包含每个数组中一个详细3D对象的两个对象数组。出于初始开发目的，此示例游戏数据可以设置在状态中，以便在游戏视图中渲染。使用此游戏结构和数据，在下一节中，我们将实现React
    360中的游戏功能。
- en: Building the game view in React 360
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React 360中构建游戏视图
- en: We will apply the React 360 concepts and use the game data structure to implement
    the game features for each game in the MERN VR Game application. For these implementations,
    we will update the default starter code generated in the `index.js` and `client.js` files
    within the initiated React 360 project.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用React 360的概念，并使用游戏数据结构来实现MERN VR游戏应用中每个游戏的特性。对于这些实现，我们将更新在初始化的React 360项目中生成的`index.js`和`client.js`文件中的默认启动代码。
- en: For a working version of the game, we will start with the `MERNVR` component's
    state that was initialized using the sample game data from the previous section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个可工作的游戏版本，我们将从使用上一节中的示例游戏数据初始化的`MERNVR`组件的状态开始。
- en: 'The `MERNVR` component is defined in `index.js`, and the code will be updated
    with the game data in state, as shown in the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`MERNVR`组件在`index.js`中定义，代码将使用上一节中的示例游戏数据初始化的状态进行更新，如下面的代码所示：'
- en: '`/MERNVR/index.js`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`/MERNVR/index.js`'
- en: '[PRE20]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will make the sample game's details available for building the rest of
    the game features. In the following sections, we will update the code in the `index.js`
    and `client.js` files to first mount the game world, define the CSS styles, and
    load the 360-degree environment for the game. Then, we will add the 3D VR objects
    to the game, make these objects interactive, and implement behavior that indicates
    the game is completed.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使示例游戏的详细信息可用于构建其余的游戏功能。在接下来的几节中，我们将更新`index.js`和`client.js`文件中的代码，首先挂载游戏世界，定义CSS样式，并为游戏加载360度环境。然后，我们将向游戏中添加3D
    VR对象，使这些对象具有交互性，并实现表示游戏完成的操作。
- en: Updating client.js and mounting to Location
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新client.js并将其挂载到位置
- en: 'The default code in `client.js` attaches the mount point declared in `index.js`
    to the default `Surface` in the React 360 app, where `Surface` is a cylindrical
    layer that is used for placing a 2D user interface. In order to use the 3D meter-based
    coordinate system for a layout in 3D space, we need to mount to a `Location` object
    instead of a `Surface`. So, we will update `client.js` to replace the `renderToSurface`
    with a `renderToLocation`, as highlighted in the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`client.js`中的默认代码将挂载在`index.js`中声明的挂载点到React 360应用中的默认`Surface`上，其中`Surface`是一个用于放置2D用户界面的圆柱层。为了在3D空间中进行布局，我们需要挂载到一个`Location`对象上而不是`Surface`。因此，我们将更新`client.js`以将`renderToSurface`替换为`renderToLocation`，如下面的代码所示：'
- en: '`/MERNVR/client.js`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`/MERNVR/client.js`'
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will mount our game view to a React 360 `Location`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们的游戏视图挂载到React 360的`Location`上。
- en: You can also customize the initial background scene by updating the `r360.compositor.setBackground(**r360.getAssetURL('360_world.jpg')**)` code
    in `client.js` to use your desired image.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过更新`client.js`中的`r360.compositor.setBackground(**r360.getAssetURL('360_world.jpg')**)`代码来自定义初始背景场景，以使用您希望使用的图像。
- en: With this update added in `client.js`, we can move on to updating the code in
    `index.js`, which will contain our game functionalities. In the next section,
    we will start by defining CSS styles for the elements to be rendered in the game
    view.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在`client.js`中添加此更新后，我们可以继续更新`index.js`中的代码，其中将包含我们的游戏功能。在下一节中，我们将首先定义游戏视图中要渲染的元素的CSS样式。
- en: Defining styles with StyleSheet
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用StyleSheet定义样式
- en: 'In `index.js`, we will update the default styles generated in the initial React
    360 project to add our own CSS rules. In the `StyleSheet.create` call, we will
    define style objects to be used with the components in the game, as shown in the
    following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.js`中，我们将更新初始React 360项目中生成的默认样式，以添加我们自己的CSS规则。在`StyleSheet.create`调用中，我们将定义用于游戏组件的样式对象，如下面的代码所示：
- en: '`/MERNVR/index.js`'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`/MERNVR/index.js`'
- en: '[PRE22]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For the game features implemented in this book, we are keeping the styling simple
    with CSS declared for only the text and button to be displayed when the game is
    completed. In the next section, we will look at how to load the 360 panoramic
    image that will represent the 3D world for each game.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中实现的游戏功能，我们使用CSS仅对显示在游戏完成时的文本和按钮进行简单样式化。在下一节中，我们将探讨如何加载代表每个游戏3D世界的360度全景图像。
- en: World background
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 世界背景
- en: 'In order to set the game''s 360-degree world background, we will update the
    current background scene using the `setBackgroundImage` method from the `Environment`
    API. We will call this inside the `componentDidMount` of the `MERNVR` component
    defined in `index.js`, as shown in the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置游戏的360度世界背景，我们将使用`Environment` API中的`setBackgroundImage`方法更新当前的背景场景。我们将在`index.js`中定义的`MERNVR`组件的`componentDidMount`内部调用此方法，如下面的代码所示：
- en: '`/MERNVR/index.js`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`/MERNVR/index.js`'
- en: '[PRE23]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will replace the default 360-degree background in the starter React 360
    project with our sample game''s world image fetched from cloud storage. If you
    are editing the default React 360 application and have it running, refreshing
    the `http://localhost:8081/index.html` link in the browser should show an outer
    space background, which you can pan across using the mouse:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这将用我们从云存储中获取的示例游戏世界图像替换入门级React 360项目中的默认360度背景。如果你正在编辑默认的React 360应用程序并且正在运行它，在浏览器中刷新`http://localhost:8081/index.html`链接应该会显示外太空背景，你可以使用鼠标进行平移：
- en: '![](img/ee255992-346f-4421-97dd-0faf23675ac0.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee255992-346f-4421-97dd-0faf23675ac0.png)'
- en: To generate the preceding screenshot, the `View` and `Text` components in the
    default code were also updated with custom CSS rules to show this hello text on
    the screen.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成前面的截图，默认代码中的`View`和`Text`组件也被更新为自定义CSS规则，以在屏幕上显示此文本。
- en: With this, we will have a 360-degree game world that can be explored by the
    user. In the next section, we will explore how to place 3D objects in this world.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们将拥有一个用户可以探索的360度游戏世界。在下一节中，我们将探讨如何在这个世界中放置3D对象。
- en: Adding 3D VR objects
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加3D VR对象
- en: We will add 3D objects to the game world using `Entity` components from React
    360, along with the sample object details in the `answerObjects` and `wrongObjects`
    arrays that were defined for the game.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用React 360的`Entity`组件将3D对象添加到游戏世界中，以及为游戏定义的`answerObjects`和`wrongObjects`数组中的示例对象详情。
- en: 'First, we will concatenate the `answerObjects` and `wrongObjects` arrays in
    `componentDidMount` to form a single array containing all of the VR objects, as
    shown in the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在`componentDidMount`中将`answerObjects`和`wrongObjects`数组连接起来，形成一个包含所有VR对象的单一数组，如下面的代码所示：
- en: '`/MERNVR/index.js`'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`/MERNVR/index.js`'
- en: '[PRE24]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will give us a single array containing all of the VR objects for the game.
    Then, in the main view, we will iterate over this merged `vrObjects` array to
    render the `Entity` components with details of each object. The iteration code
    will be added using `map`, as shown in the following code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们一个包含游戏所有VR对象的单一数组。然后，在主视图中，我们将遍历这个合并的`vrObjects`数组来渲染具有每个对象详情的`Entity`组件。迭代代码将通过`map`添加，如下面的代码所示：
- en: '`/MERNVR/index.js`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`/MERNVR/index.js`'
- en: '[PRE25]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `obj` and `mtl` file links are added to the `source` prop in `Entity`, and
    the `transform` style details are applied in the `Entity` component's styles with
    the call to `setModelStyles`. The `setModelStyles` method constructs the styles
    for the specific VR object to be rendered, using values defined in the VR object's
    details.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj`和`mtl`文件链接被添加到`Entity`的`source`属性中，`transform`样式的详细信息通过调用`setModelStyles`应用于`Entity`组件的样式。`setModelStyles`方法使用在VR对象详情中定义的值构建要渲染的特定VR对象的样式。'
- en: 'The `setModelStyles` method is implemented as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`setModelStyles`方法实现如下：'
- en: '`/MERNVR/index.js`'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`/MERNVR/index.js`'
- en: '[PRE26]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `display` property will allow us to show or hide an object based on whether
    it has already been collected by the player or not. The `translate` and `rotate`
    values will render the 3D objects in the desired positions and orientations across
    the VR world. Next, we will update the `Entity` code further to enable user interactions
    with these 3D objects.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`display`属性将允许我们根据对象是否已经被玩家收集来显示或隐藏对象。`translate`和`rotate`值将在VR世界中渲染3D对象到期望的位置和方向。接下来，我们将进一步更新`Entity`代码以启用用户与这些3D对象的交互。'
- en: Interacting with VR objects
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与VR对象交互
- en: In order to make the VR game objects interactive, we will use the React 360
    event handlers, such as `onEnter` and `onExit` with `Entity`, and `onClick` with
    `VrButton`, to add rotation animation and gameplay behavior. In the following
    sections, we will add the implementations for rotating a VR object when a user
    focuses on it, and for adding click behavior on the objects to allow a user to
    collect the correct objects in the game.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使VR游戏对象具有交互性，我们将使用React 360事件处理程序，如与`Entity`一起使用的`onEnter`和`onExit`，以及与`VrButton`一起使用的`onClick`，以添加旋转动画和游戏行为。在接下来的章节中，我们将添加在用户聚焦于VR对象时旋转VR对象的实现，以及为对象添加点击行为，以便用户在游戏中收集正确的对象。
- en: Rotating a VR object
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转VR对象
- en: We want to add a feature that starts rotating a 3D object around its *y* axis
    whenever a player focuses on the 3D object, that is, when the platform cursor
    begins intersecting with the `Entity` component rendering the specific 3D object.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望添加一个功能，即当玩家聚焦于3D对象时，开始围绕其*y*轴旋转3D对象，即当平台光标开始与渲染特定3D对象的`Entity`组件相交时。
- en: 'We will update the `Entity` component from the previous section to add the
    `onEnter` and `onExit` handlers, as shown in the following code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新上一节中的`Entity`组件，添加`onEnter`和`onExit`处理程序，如下面的代码所示：
- en: '`/MERNVR/index.js`'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`/MERNVR/index.js`'
- en: '[PRE27]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The object rendered with this `Entity` component will start rotating on a cursor
    entry or focus on the object, and it will stop when the platform cursor exits
    the object and is no longer in the player's focus. In the following section, we
    will discuss the implementation of this rotation animation.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此`Entity`组件渲染的对象将在光标进入或聚焦于对象时开始旋转，并在平台光标退出对象且不再在玩家焦点中时停止。在下一节中，我们将讨论此旋转动画的实现。
- en: Animation with requestAnimationFrame
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`requestAnimationFrame`进行动画
- en: The rotation behavior for each 3D object is implemented in the event handlers
    added to the `Entity` component, which is rendering the 3D object. Specifically,
    in the `rotate(index)` and `stopRotate()` handler methods that are called when
    the `onEnter` and `onExit` events occur, we will implement rotation animation
    behavior using `requestAnimationFrame` for smooth animations in the browser.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 每个3D对象的旋转行为是在添加到渲染3D对象的`Entity`组件的事件处理程序中实现的。具体来说，在`onEnter`和`onExit`事件发生时调用的`rotate(index)`和`stopRotate()`处理方法中，我们将使用`requestAnimationFrame`实现旋转动画行为，以在浏览器中实现平滑动画。
- en: The `window.requestAnimationFrame()` method asks the browser to call a specified
    callback function to update an animation before the next repaint. With `requestAnimationFrame`,
    the browser optimizes the animations to make them smoother and more resource-efficient.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.requestAnimationFrame()`方法要求浏览器在下次重绘之前调用指定的回调函数来更新动画。使用`requestAnimationFrame`，浏览器优化动画以使其更平滑且更高效。'
- en: 'Using the `rotate` method, we will update the `rotateY` transform value of
    the given object at a steady rate on a set time interval with `requestionAnimationFrame`,
    as shown in the following code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`rotate`方法，我们将使用`requestAnimationFrame`在设定的时间间隔内以恒定速率更新给定对象的`rotateY`变换值，如下面的代码所示：
- en: '`/MERNVR/index.js`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`/MERNVR/index.js`'
- en: '[PRE28]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `requestAnimationFrame` method will take the `rotate` method as a recursive
    callback function, then execute it to redraw each frame of the rotation animation
    with the new values, and, in turn, update the animation on the screen.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`requestAnimationFrame`方法将`rotate`方法作为递归回调函数，然后执行它以使用新值重绘旋转动画的每一帧，并相应地更新屏幕上的动画。'
- en: 'The `requestAnimateFrame` method returns a `requestID`, which we will use in
    the call to `stopRotate`, so the animation gets canceled in the `stopRotate` method.
    This `stopRotate` method is defined as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`requestAnimationFrame`方法返回一个`requestID`，我们将使用它在`stopRotate`调用中，以便在`stopRotate`方法中取消动画。此`stopRotate`方法定义如下：'
- en: '`/MERNVR/index.js`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`/MERNVR/index.js`'
- en: '[PRE29]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will implement the functionality of animating the 3D object only when
    it is in the viewer''s focus. As shown in the following screenshot, the 3D Rubik''s
    cube rotates clockwise around its *y* axis while it is in focus:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这将实现仅在3D对象处于观看者焦点时才对其动画化的功能。如图所示，当3D魔方处于焦点时，它围绕其*y*轴顺时针旋转：
- en: '![](img/d4e0594f-f0cf-4b75-a370-17cb575b375d.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4e0594f-f0cf-4b75-a370-17cb575b375d.png)'
- en: Though not covered here, it is also worth exploring the React 360 Animated library,
    which can be used to compose different types of animations. Core components can
    be animated natively with this library, and it is possible to animate other components
    using `createAnimatedComponent()`. This library was originally implemented from
    React Native; to learn more, you can refer to the React Native documentation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里没有涉及，但探索React 360 Animated库也是值得的，它可以用来组合不同类型的动画。核心组件可以使用这个库进行原生动画，并且可以使用`createAnimatedComponent()`方法来动画化其他组件。这个库最初是从React
    Native实现的；要了解更多信息，您可以参考React Native文档。
- en: Now the users playing the game will observe motion when they focus on any of
    the VR objects placed in the game world. In the next section, we will add the
    functionality for capturing user clicks on these objects.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩游戏的用户将观察到，当他们聚焦于游戏世界中放置的任何VR对象时，会有运动效果。在下一节中，我们将添加捕捉用户点击这些对象的功能。
- en: Clicking on the 3D objects
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击3D对象
- en: In order to register the click behavior on each 3D object added to the game,
    we need to wrap the `Entity` component with a `VrButton` component that can call
    the `onClick` handler.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在游戏中添加的每个3D对象上注册点击行为，我们需要将`Entity`组件包裹在一个可以调用`onClick`处理器的`VrButton`组件中。
- en: 'We will update the `Entity` component added inside the `vrObjects` array iteration
    code, to wrap it with the `VrButton` component, as shown in the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新`vrObjects`数组迭代代码中添加的`Entity`组件，将其包裹在`VrButton`组件中，如下面的代码所示：
- en: '`/MERNVR/index.js`'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`/MERNVR/index.js`'
- en: '[PRE30]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `VrButton` component will call the `collectItem` method when clicked on,
    and pass it the current object's details.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击`VrButton`组件时，它将调用`collectItem`方法，并传递当前对象的详细信息。
- en: 'When a 3D object is clicked on by a user, we need the `collectItem` method
    to perform the following actions with respect to the game features:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击一个3D对象时，我们需要`collectItem`方法根据游戏功能执行以下操作：
- en: Check whether the clicked object is an `answerObject` or a `wrongObject`.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查点击的对象是`answerObject`还是`wrongObject`。
- en: Based on the object type, play the associated sound.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据对象类型，播放相关的声音。
- en: If the object is an `answerObject`, it should be collected and removed from
    view, then added to a list of collected objects.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象是`answerObject`，则应将其收集并从视图中移除，然后添加到收集对象列表中。
- en: 'Check whether all instances of `answerObject` were successfully collected with
    this click:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查是否通过这次点击成功收集了所有`answerObject`实例：
- en: If yes, show the game completed message to the player and play the sound for game
    completed.
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是，向玩家显示游戏完成消息并播放游戏完成的声音。
- en: 'We will implement these actions in the `collectItem` method with the following
    structure and steps:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`collectItem`方法中使用以下结构和步骤来实现这些动作：
- en: '[PRE31]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Any time a VR object is clicked on by the user, in this method, we will first
    check the type of the object before taking the related actions. We will discuss
    the implementation of these steps and actions in detail in the following section.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时间用户点击VR对象，在这个方法中，我们首先检查对象的类型，然后再采取相关的行动。我们将在下一节详细讨论这些步骤和动作的实现。
- en: Collecting the correct object on click
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在点击时收集正确的对象
- en: When a user clicks on a 3D object, we need to first check whether the clicked
    object is an answer object. If it is, this object will be *collected* and hidden
    from view, and a list of collected objects will be updated along with the total
    number to keep track of the user's progress in the game.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击一个3D对象时，我们首先需要检查点击的对象是否是答案对象。如果是，这个对象将被*收集*并从视图中隐藏，同时更新收集对象列表以及总数以跟踪用户在游戏中的进度。
- en: 'To check whether the clicked VR object is an `answerObject`, we will use the
    `indexOf` method to find a match in the `answerObjects` array, as shown in the
    following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查点击的VR对象是否是`answerObject`，我们将使用`indexOf`方法在`answerObjects`数组中找到一个匹配项，如下面的代码所示：
- en: '[PRE32]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If the `vrObject` is an `answerObject`, `indexOf` will return the array index
    of the matched object; otherwise, it will return `-1` if no match is found.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`vrObject`是`answerObject`，`indexOf`将返回匹配对象的数组索引；如果没有找到匹配项，它将返回`-1`。
- en: 'To keep track of collected objects in the game, we will also maintain an array
    of Boolean values in `collectedList` at corresponding indices, and the total number
    of objects collected so far in `collectedNum`, as shown in the following code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪游戏中的收集对象，我们还将维护一个布尔值数组`collectedList`在相应的索引处，以及到目前为止收集的对象总数`collectedNum`，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Using the `collectedList` array, we will also determine which `Entity` component
    should be hidden from the view because the associated object was collected. The
    `display` style property of the relevant `Entity` component will be set based
    on the Boolean value of the corresponding index in the `collectedList` array.
    We set this in the style for the `Entity` component using the `setModelStyles`
    method, as shown earlier in the *Adding 3D VR objects* section. This display style
    value is set conditionally with the following line of code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `collectedList` 数组，我们还将确定哪个 `Entity` 组件应该从视图中隐藏，因为相关的对象已被收集。相关的 `Entity`
    组件的 `display` 样式属性将根据 `collectedList` 数组中相应索引的布尔值设置。我们使用前面在 *添加 3D VR 对象* 部分中提到的
    `setModelStyles` 方法设置此样式。此显示样式值使用以下代码条件性地设置：
- en: '[PRE34]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Depending on whether the array index of the rendered VR object is set to true
    in the collected list of objects, we hide or show the `Entity` component in the
    view.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 根据渲染的 VR 对象的数组索引是否在对象的收集列表中设置为 true，我们将隐藏或显示视图中的 `Entity` 组件。
- en: 'For example, in the following screenshot, the treasure chest can be clicked
    on to be collected as it is an `answerObject`, whereas the flower pot cannot be
    collected because it is a `wrongObject`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的屏幕截图中，宝箱可以被点击并收集，因为它是一个 `answerObject`，而花盆不能被收集，因为它是一个 `wrongObject`：
- en: '![](img/a6f20097-fa73-4e6d-bc13-42e071be5f90.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6f20097-fa73-4e6d-bc13-42e071be5f90.png)'
- en: 'When the treasure chest is clicked on, it disappears from the view as the `collectedList`
    is updated, and we also play the sound effect for collection using `AudioModule.playOneShot` with
    the following code:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击宝箱时，由于 `collectedList` 被更新，它将从视图中消失，并且我们还会使用 `AudioModule.playOneShot` 以以下代码播放收集音效：
- en: '[PRE35]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'However, when the flower pot is clicked on, and it is identified as a wrong
    object, we play another sound effect indicating it cannot be collected, as shown
    in the following code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当点击花盆并且它被识别为错误对象时，我们将播放另一个音效，表明它不能被收集，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As the flower pot was identified to be a wrong object, the `collectedList`
    was not updated and it remains on the screen, whereas the treasure chest is gone, as
    shown in the following screenshot:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 由于花盆被识别为错误对象，`collectedList` 没有被更新，它仍然在屏幕上，而宝箱已经消失，如下面的屏幕截图所示：
- en: '![](img/d1a2710e-819b-48d2-84d6-57e71f478797.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1a2710e-819b-48d2-84d6-57e71f478797.png)'
- en: The complete code in the `collectItem` method that executes all of these steps
    when an object is clicked on will be as follows.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象被点击时，执行所有这些步骤的 `collectItem` 方法中的完整代码如下。
- en: '`/MERNVR/index.js`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`/MERNVR/index.js`:'
- en: '[PRE37]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: After a clicked object is collected using this method, we will also check whether
    all of the `answerObjects` have been collected and whether the game is complete
    with a call to the `checkGameCompleteStatus` method. We will take a look at the
    implementation of this method and the game completed functionality in the next
    section.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法收集到点击的对象后，我们还将通过调用 `checkGameCompleteStatus` 方法来检查是否所有 `answerObjects`
    都已被收集，以及游戏是否完成。我们将在下一节中查看此方法的实现和游戏完成功能。
- en: Game completed state
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏完成状态
- en: 'Every time an `answerObject` is collected, we will check whether the total
    number of collected items is equal to the total number of objects in the `answerObjects`
    array to determine whether the game is complete. We will achieve this by calling
    the `checkGameCompleteStatus` method, which will perform this check, as shown
    in the following code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 每次收集到 `answerObject` 时，我们将检查收集到的项目总数是否等于 `answerObjects` 数组中的对象总数，以确定游戏是否完成。我们将通过调用
    `checkGameCompleteStatus` 方法来实现这一点，如下面的代码所示：
- en: '`/MERNVR/index.js`'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`/MERNVR/index.js`'
- en: '[PRE38]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this method, we first confirm that the game is indeed complete, and then
    we perform the following actions:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，我们首先确认游戏确实已完成，然后执行以下操作：
- en: Play the audio for game completed, using `AudioModule.playEnvironmental`.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `AudioModule.playEnvironmental` 播放游戏完成的音频。
- en: Fetch the current `headMatrix` value using `VrHeadModel` so that it can be set
    as the transform matrix value for the `View` component containing the game completion
    message.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `VrHeadModel` 获取当前的 `headMatrix` 值，以便将其设置为包含游戏完成信息的 `View` 组件的变换矩阵值。
- en: Set the `display` style property of the `View` message to `flex`, so the message
    renders to the viewer.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `View` 消息的 `display` 样式属性设置为 `flex`，以便消息渲染给观众。
- en: 'The `View` component containing the message congratulating the player for completing
    the game will be added to the parent `View` component as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 将包含向玩家表示祝贺完成游戏的`View`组件添加到父`View`组件中，如下所示：
- en: '`/MERNVR/index.js`'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`/MERNVR/index.js`'
- en: '[PRE39]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The call to the `setGameCompletedStyle()` method will set the styles for the
    `View` message with the updated `display` value and the `transform` matrix value. The `setGameCompletedStyle` method
    is defined as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 对`setGameCompletedStyle()`方法的调用将设置`View`消息的样式，包括更新的`display`值和`transform`矩阵值。`setGameCompletedStyle`方法定义如下：
- en: '`/MERNVR/index.js`'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`/MERNVR/index.js`'
- en: '[PRE40]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'These style values will render the `View` component with the completion message
    at the center of the user''s current view, regardless of whether they are looking
    up, down, behind, or forward in the 360-degree VR world, as shown in the following
    screenshot:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这些样式值将使`View`组件在用户当前视图的中心显示完成消息，无论他们是在360度VR世界的向上、向下、向后还是向前看，如下面的截图所示：
- en: '![](img/7c0f6b18-b1d5-42f9-8366-626522807d36.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c0f6b18-b1d5-42f9-8366-626522807d36.png)'
- en: 'The final text in the `View` message will act as a button, as we wrapped this
    `View` in a `VrButton` component that calls the `exitGame` method when clicked.
    The `exitGame` method is defined as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`View`消息中的最终文本将充当按钮，因为我们把这个`View`包裹在一个调用`exitGame`方法的`VrButton`组件中。`exitGame`方法定义如下：'
- en: '`/MERNVR/index.js`'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`/MERNVR/index.js`'
- en: '[PRE41]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `exitGame` method will use the `Location.replace` method to redirect the
    user to an external URL that may contain a list of games.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`exitGame`方法将使用`Location.replace`方法将用户重定向到可能包含游戏列表的外部URL。'
- en: The `replace` method can be passed any valid URL, and once this React 360 game
    code is integrated with the MERN VR Game application in [Chapter 14](17bbfed7-9867-4c8b-99fd-42581044a906.xhtml),
    *Making the VR Game Dynamic Using MERN*, `replace('/')` will take the user to
    the home page of the whole application.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace`方法可以传递任何有效的URL，一旦这个React 360游戏代码与第14章中基于MERN的VR游戏应用程序集成，`replace(''/'')`将用户带到整个应用程序的主页。'
- en: The VR game functionalities are complete with these updates to the React 360
    project. It is now possible to set a 360-degree panoramic background as the game
    world and add interactive VR objects to this world. These 3D objects will rotate
    in place and can be collected based on user interaction if the game rules allow
    it. In the next section, we will demonstrate how to bundle this React 360 code
    so that the game can be integrated with a MERN-based web application.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: VR游戏功能已经通过这些对React 360项目的更新而完整。现在可以设置360度全景背景作为游戏世界，并向这个世界添加交互式VR对象。如果游戏规则允许，这些3D对象将原地旋转，并且可以根据用户交互进行收集。在下一节中，我们将演示如何打包这个React
    360代码，以便游戏可以与基于MERN的Web应用程序集成。
- en: Bundling for production and integration with MERN
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产打包和与MERN集成
- en: Now that we have features of the VR game implemented and are functional with
    the sample game data, we can prepare it for production and add it to our MERN-based
    application to see how VR can be added to an existing web application. In the
    following sections, we will look at how to bundle the React 360 code, integrate
    it with a MERN application, and test the integration by running the game from
    the application.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了VR游戏的功能，并且与示例游戏数据一起是功能性的，我们可以为生产做准备，并将其添加到我们的MERN应用程序中，以查看如何将VR添加到现有的Web应用程序中。在接下来的几节中，我们将探讨如何打包React
    360代码，将其与MERN应用程序集成，并通过从应用程序中运行游戏来测试集成。
- en: Bundling React 360 files
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包React 360文件
- en: 'React 360 tools provide a script to bundle all of the React 360 application
    code into a few files that we can just place on the MERN web server and serve
    as content at a specified route. To create the bundled files, we can run the following
    command in the React 360 project directory:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: React 360工具提供了一个脚本来将所有React 360应用程序代码打包成几个文件，我们可以将这些文件直接放置在MERN Web服务器上，并在指定的路由上作为内容提供。要创建打包文件，我们可以在React
    360项目目录中运行以下命令：
- en: '[PRE42]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This generates compiled versions of the React 360 application files in a folder
    called `build`. The compiled bundle files are `client.bundle.js` and `index.bundle.js`.
    These two files, in addition to the `index.html` file and the `static-assets/`
    folder, make up the production version of the whole React 360 application that
    was developed. The final production code will be in the following folder and files:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在名为 `build` 的文件夹中生成 React 360 应用程序文件的编译版本。编译后的打包文件是 `client.bundle.js` 和 `index.bundle.js`。这两个文件，加上
    `index.html` 文件和 `static-assets/` 文件夹，构成了开发的整个 React 360 应用程序的生产版本。最终的生产代码将在以下文件夹和文件中：
- en: '[PRE43]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We will have to take these folders and files over to a MERN project directory
    to integrate the game with the MERN application, as discussed in the next section.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将这些文件夹和文件移动到 MERN 项目目录中，以便将游戏与 MERN 应用程序集成，如下一节所述。
- en: Integrating with a MERN application
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 MERN 应用程序集成
- en: In order to integrate the game developed in React 360 with a MERN-based web
    application, we will first bring the React 360 production files discussed in the
    previous section to our MERN application project. Then, we will update the bundle
    file references in the generated `index.html` code to point to the new location
    of the bundle files, before loading the `index.html` code at a specified route
    in the Express app.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将用 React 360 开发的游戏与基于 MERN 的 Web 应用程序集成，我们首先将上一节中讨论的 React 360 生产文件引入我们的 MERN
    应用程序项目中。然后，我们将更新生成的 `index.html` 代码中的打包文件引用，使其指向打包文件的新位置，在 Express 应用程序中指定路由加载
    `index.html` 代码之前。
- en: Adding the React 360 production files
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 React 360 生产文件
- en: 'With consideration to the folder structure in the existing MERN skeleton application,
    we will add the `static_assets` folder and the bundle files from the React 360
    production files to the `dist/` folder. This will keep our MERN code organized
    with all the bundles in the same location. The `index.html` file will be placed
    in a new folder, named `vr` in the `server` folder, as highlighted in the following
    folder structure:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到现有 MERN 骨架应用程序的文件夹结构，我们将添加 `static_assets` 文件夹并将 React 360 生产文件中的打包文件添加到
    `dist/` 文件夹中。这将使我们的 MERN 代码保持有序，所有打包文件都在同一位置。`index.html` 文件将被放置在 `server` 文件夹下的一个新文件夹中，命名为
    `vr`，如下面的文件夹结构所示：
- en: '[PRE44]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will bring the React 360 code over to the MERN application. However, to
    make it functional, we need to update the file references in the `index.html`
    code, as discussed in the next section.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把 React 360 代码带到 MERN 应用程序中。然而，为了使其功能正常，我们需要更新 `index.html` 代码中的文件引用，如下一节所述。
- en: Updating references in index.html
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新 index.html 中的引用
- en: 'The `index.html` file, which was generated after bundling the React 360 project,
    references the bundle files expecting these files to be in the same folder, as
    shown in the following code:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在打包 React 360 项目后生成的 `index.html` 文件引用了打包文件，期望这些文件在同一个文件夹中，如下面的代码所示：
- en: '[PRE45]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We need to update this `index.html` code to refer to the correct location of
    the `client.bundle.js`, `index.bundle.js`, and `static_assets` folders.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新这个 `index.html` 代码，使其引用 `client.bundle.js`、`index.bundle.js` 和 `static_assets`
    文件夹的正确位置。
- en: 'First, update the reference to `client.bundle.js` as follows, to point to the
    file we placed in the `dist` folder:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照以下方式更新对 `client.bundle.js` 的引用，以指向我们放置在 `dist` 文件夹中的文件：
- en: '[PRE46]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, update the `React360.init` call with the correct reference to `index.bundle.js`,
    and `assetRoot` set to the correct location of the `static_assets` folder, as
    shown in the following code:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，更新 `React360.init` 调用，使用正确的引用 `index.bundle.js`，并将 `assetRoot` 设置为 `static_assets`
    文件夹的正确位置，如下面的代码所示：
- en: '[PRE47]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `assetRoot` specifies where to look for asset files when we use `asset()`
    to set resources in the React 360 components.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`assetRoot` 指定了在用 `asset()` 在 React 360 组件中设置资源时查找资源文件的位置。'
- en: The game view implemented with React 360 is now available in the MERN application.
    In the next section, we will try out this integration by setting up a route to
    load the game from the web application.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 React 360 实现的游戏视图现在可在 MERN 应用程序中使用。在下一节中，我们将通过设置一个路由从 Web 应用程序加载游戏来尝试这种集成。
- en: Trying out the integration
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试集成
- en: 'If we set up an Express route in the MERN application to return the `index.html` file
    in the response, then visiting the route in the browser will render the React
    360 game. To test out this integration, we can set up an example route, as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 MERN 应用程序中设置一个 Express 路由以在响应中返回 `index.html` 文件，那么在浏览器中访问该路由将渲染 React
    360 游戏。为了测试这种集成，我们可以设置一个示例路由，如下所示：
- en: '[PRE48]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This declares a `GET` route in the `'/game/play'` path, which will simply return
    the `index.html` file that we placed in the `vr` folder with the server code,
    in response to the requesting client.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这在`'/game/play'`路径中声明了一个`GET`路由，它将简单地返回我们放置在`vr`文件夹中的与服务器代码一起的`index.html`文件，作为对请求客户端的响应。
- en: Then, we can run the MERN server and open this route in the browser at `localhost:3000/game/play`.
    This should render the complete React 360 game implemented in this chapter from
    within the MERN-based web application.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以运行MERN服务器，并在浏览器中的`localhost:3000/game/play`打开此路由。这应该会在基于MERN的Web应用内部渲染本章实现的完整的React
    360游戏。
- en: Summary
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we used React 360 to develop a web-based VR game that can be
    easily integrated into MERN applications.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用React 360开发了一个可以轻松集成到MERN应用的基于Web的VR游戏。
- en: We began by defining simple VR features for the gameplay. Then, we set up React
    360 for development and looked at key VR concepts, such as equirectangular panoramic
    images, 3D positions, and coordinate systems in the 360-degree VR world. We explored
    the React 360 components and APIs required to implement the game features, including
    components such as `View`, `Text`, `Entity`, and `VrButton`, along with the `Environment`, `VrHeadModel`, and
    `NativeModules` APIs.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为游戏玩法定义了简单的VR功能。然后，我们为开发设置了React 360，并研究了关键的VR概念，例如等角全景图像、3D位置和360度VR世界的坐标系。我们探索了实现游戏功能所需的React
    360组件和API，包括`View`、`Text`、`Entity`和`VrButton`组件，以及`Environment`、`VrHeadModel`和`NativeModules`
    API。
- en: Finally, we updated the code in the starter React 360 project to implement the
    game with sample game data, then we bundled the code files and discussed how to
    add these compiled files to an existing MERN application.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们更新了入门级React 360项目的代码，以使用示例游戏数据实现游戏，然后打包了代码文件，并讨论了如何将这些编译后的文件添加到现有的MERN应用中。
- en: With these steps covered, you will now be able to build your own VR interfaces
    with React 360, which can be easily integrated with any MERN-based web application.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，你现在将能够使用React 360构建自己的VR界面，这些界面可以轻松地集成到任何基于MERN的Web应用中。
- en: In the next chapter, we will develop the MERN VR Game application, complete
    with a game database and backend APIs. This is so that we can make the game developed
    in this chapter dynamic by fetching data from a game collection stored in MongoDB.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开发一个MERN VR游戏应用，包括游戏数据库和后端API。这样我们就可以通过从存储在MongoDB中的游戏收藏中获取数据，使本章开发的游戏变得动态。
