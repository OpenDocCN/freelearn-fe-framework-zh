- en: Some Practical Scenarios
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些实际场景
- en: 'With seven chapters under our belt, you should feel pretty good. What you have
    learned thus far is a direct consequence of the apps we have built in the last
    few chapters. We believe you should now have an adequate understanding of the
    framework, how it works, and what it supports. Armed with this knowledge, as soon
    as we start to build some decent-sized apps, there are some common problems/patterns
    that invariably surface, such as these:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握七个章节之后，你应该感觉相当不错。到目前为止你所学的都是直接来源于我们在前几章中构建的应用。我们相信你现在应该对框架、其工作原理以及它支持的内容有了足够的了解。有了这些知识，当我们开始构建一些规模较大的应用时，一些常见的问题/模式不可避免地会出现，例如这些：
- en: How do we authenticate the user and control his/her access (authorize)?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何验证用户并控制其访问权限（授权）？
- en: How do we make sure that the app is performing well enough?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何确保应用性能足够好？
- en: My app requires localized content. What do I do?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的应用需要本地化内容。我该怎么办？
- en: What tools can I use to expedite app development?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我可以使用哪些工具来加速应用开发？
- en: I have an AngularJS app. How do I migrate it?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我有一个AngularJS应用。我该如何迁移它？
- en: And some more!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以及更多！
- en: In this chapter, we will try to address such common scenarios and provide some
    working solutions and/or prescriptive guidance to handle such use cases.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将尝试解决这些常见场景，并提供一些可行的解决方案和/或指导性建议来处理这些用例。
- en: 'The topics we will cover in this chapter include:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主题包括：
- en: '**Angular seed projects**: You will learn how some seed projects in Angular
    can help us when starting a new engagement.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular种子项目**：你将学习到一些Angular种子项目如何在开始新的项目时帮助我们。'
- en: '**Authenticating Angular applications**: This is a common requirement. We look
    at how to support cookie- and token-based authentication in Angular.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证Angular应用**：这是一个常见需求。我们来看如何在Angular中支持基于cookie和token的认证。'
- en: '**Angular performance**: A customary performance section is a must as we try
    to detail what makes Angular performant and things you can do to make your apps
    faster.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular性能**：在尝试详细说明是什么使Angular性能良好以及你可以做些什么来使你的应用更快时，一个常规的性能部分是必须的。'
- en: '**Migrating AngularJS apps to Angular**: AngularJS and Angular are altogether
    different beasts. In this chapter, you will learn how to gradually migrate an
    AngularJS app to Angular.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将AngularJS应用迁移到Angular**：AngularJS和Angular是完全不同的东西。在本章中，你将学习如何逐步将AngularJS应用迁移到Angular。'
- en: Let's start at the beginning!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一开始吧！
- en: Building a new app
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建新的应用
- en: 'Imagine a scenario here: we are building a new application and given the super
    awesomeness of the Angular framework, we have unanimously decided to use Angular.
    Great! What next? Next is the mundane process of setting up the project.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景：我们正在构建一个新的应用，鉴于Angular框架的超级强大，我们一致决定使用Angular。太好了！接下来是什么？接下来是设置项目的平凡过程。
- en: 'Although a mundane activity, it''s still a critical part of any engagement.
    Setting up a new project typically involves:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个平凡的活动，但它仍然是任何合作的关键部分。设置新项目通常涉及：
- en: Creating a standard folder structure. This is at times influenced by the server
    framework (such as *RoR*, *ASP.Net*, *Node.js*, and others).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建标准文件夹结构。有时这会受到服务器框架（如*ROR*、*ASP.Net*、*Node.js*等）的影响。
- en: Adding standard assets to specific folders.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将标准资产添加到特定文件夹中。
- en: 'Setting up the build, which in the case that, we are developing an Angular-based
    web application, includes:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置构建，如果我们正在开发基于Angular的Web应用，这包括：
- en: Compiling/transpiling content if using TypeScript
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用TypeScript，则编译/转换内容
- en: Configuring the Module loader
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置模块加载器
- en: Dependency management in terms of framework and third-party components
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在框架和第三方组件方面的依赖管理
- en: Setting up unit/E2E testing
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置单元/E2E测试
- en: Configuring builds for different environments such as dev, test, and production.
    Again, this is influenced by the server technology involved.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置不同环境（如开发、测试和生产）的构建。这再次受到所涉及的服务器技术的影响。
- en: Code bundling and minification.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码打包和压缩。
- en: There is a lot of stuff to do.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多工作要做。
- en: What if we can short-circuit the overall setup process? This is indeed possible;
    we just need a **seed project** or a **starter site**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以缩短整体设置过程会怎样？这确实可能；我们只需要一个**种子项目**或**启动站点**。
- en: Seed projects
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 种子项目
- en: Angular CLI as a built and scaffolding tool is awesome! But, it is not the only
    option out there. There are a number of *seed projects/starter sites* that can
    get us up and running in no time. Some seed projects integrate the framework with
    a specific backend and some only dictate/provide Angular-specific content. Some
    come preconfigured with vendor-specific libraries/frameworks (such as *LESS*,
    *SASS*, *Bootstrap*, and others), whereas others just provide a plain vanilla
    setup.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI 作为构建和脚手架工具非常棒！但是，它并不是唯一的选择。有许多*种子项目/入门网站*可以在短时间内帮助我们开始。一些种子项目将框架与特定的后端集成，而另一些则仅规定/提供Angular特定的内容。一些预先配置了供应商特定的库/框架（如*LESS*、*SASS*、*Bootstrap*等），而另一些则只提供纯
    vanilla 设置。
- en: 'Some of the notable seed projects worth exploring are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一些值得探索的知名种子项目如下：
- en: '**Angular Starter** ([http://bit.ly/ng-starter](http://bit.ly/ng-starter)):
    This seed repo serves as an Angular starter for anyone looking to get up and running
    with Angular and TypeScript fast. It uses Webpack (module bundler) to build our
    files and assist with boilerplate. It''s a complete build system with a substantial
    number of integrations.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular Starter** ([http://bit.ly/ng-starter](http://bit.ly/ng-starter))：这个种子仓库为那些希望快速开始使用
    Angular 和 TypeScript 的人提供了一个 Angular 入门。它使用 Webpack（模块打包器）来构建我们的文件并帮助处理样板代码。它是一个完整的构建系统，具有大量的集成。'
- en: '**Angular Seed** ([http://bit.ly/ng-starter-seed](http://bit.ly/ng-starter-seed)):
    Another seed project similar to Angular Starter. This seed project uses gulp for
    build automation, and the module bundler system is not as advanced as Webpack.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular Seed** ([http://bit.ly/ng-starter-seed](http://bit.ly/ng-starter-seed))：与
    Angular Starter 类似的另一个种子项目。这个种子项目使用 gulp 进行构建自动化，其模块打包系统不如 Webpack 先进。'
- en: These projects along with Angular CLI provide a head start when building with
    Angular.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些项目以及 Angular CLI 为使用 Angular 进行构建提供了良好的起点。
- en: 'If the app is tied to a specific backend stack, we have two choices, which
    are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序与特定的后端堆栈相关联，我们有两种选择，如下所示：
- en: Use one of these seed projects and integrate it with the backend manually.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这些种子项目之一，并手动将其与后端集成。
- en: Find a seed project/implementation that does it for us. There is a good chance
    you will find such seed projects.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到一个为我们完成这项工作的种子项目/实现。有很大机会你会找到这样的种子项目。
- en: Angular performance
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 性能
- en: Angular has been designed with performance in mind. Every part of the framework,
    starting from the framework footprint, initial load time, memory utilization,
    change detection plus data binding, and DOM rendering, has been tweaked or is
    being tweaked for better performance.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 是以性能为设计理念的。框架的每个部分，从框架占用空间、初始加载时间、内存使用、变更检测加上数据绑定，到DOM渲染，都经过了调整或正在调整以实现更好的性能。
- en: The next few sections are dedicated to understanding how performant Angular
    is and the tricks it uses to achieve some impressive performance gains.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几节将致力于了解 Angular 的性能以及它用来实现一些令人印象深刻的性能提升的技巧。
- en: Byte size
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字节大小
- en: '*The Byte size* of the framework is a good starting point for performance optimization.
    While the world is moving towards high-speed internet, a sizable population among
    us is on a slow connection and are using their mobile to connect to the web. We
    may not think too much about a few KB here or there, but it does matter!'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的*字节大小*是性能优化的良好起点。虽然世界正在向高速互联网发展，但我们中相当一部分人仍然在使用慢速连接，并通过手机连接到网络。我们可能不会太在意这里或那里的几KB，但这确实很重要！
- en: While the byte size of Angular out of the box is bigger than AngularJS, there
    are techniques that can drastically reduce the size of an Angular bundle.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Angular的默认字节大小比AngularJS大，但有一些技术可以大幅减少Angular打包的大小。
- en: To start with, the standard techniques of *minification* and *gzipping* can
    reduce this gap substantially. And with Angular, we can do some nifty tricks with
    *module bundler/loaders* to reduce the Angular bundle size even more.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，标准的压缩和gzip压缩技术可以显著减少这个差距。并且，在 Angular 中，我们可以通过使用*模块打包器/加载器*来执行一些巧妙的技巧，进一步减少
    Angular 打包的大小。
- en: '**Tree shaking** may be a quirky name for a process, but it literally does
    what it says! As we build apps using TypeScript (or ES2015), containing *modules*
    and *exports*, a module bundler such as *Rollup* ([http://rollupjs.org](http://rollupjs.org))
    can perform static code analysis on such code, determine what parts of the code
    are never used, and remove them before bundling the release bits. Such module
    bundlers, when added to the app''s build process, can analyze the framework bit,
    any third-party library, and the app code to remove any dead code before creating
    bundles. *Tree shaking can result in enormous size reduction as you don''t bundle
    framework bits that you don''t use.*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**摇树**可能是一个古怪的过程名称，但它确实做到了它所说的！当我们使用 TypeScript（或 ES2015）构建应用程序，包含 *模块* 和 *导出*
    时，模块打包器（如 *Rollup* ([http://rollupjs.org](http://rollupjs.org)））可以对这样的代码进行静态代码分析，确定代码中哪些部分从未使用过，并在打包发布前将其删除。这样的模块打包器，当添加到应用程序的构建过程中时，可以分析框架代码、任何第三方库和应用程序代码，在创建包之前删除任何死代码。*摇树可以导致巨大的尺寸缩减，因为你不会打包你不使用的框架代码。*'
- en: One of the biggest framework pieces that can be removed from the framework bundle
    is the *compiler*. Yes, you read right, it's the compiler!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从框架包中移除的最大框架组件之一是 *编译器*。是的，你没听错，就是编译器！
- en: For curious readers, the compiler is the single biggest framework piece, contributing
    roughly 50% in size to the Angular bundle (In Angular *v2.0.0*).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于好奇的读者，编译器是最大的框架组件，大约占 Angular 包大小的 50%（在 Angular *v2.0.0* 中）。
- en: Using tree shaking together with **Ahead-of-Time** (**AoT**) compilation, we
    can just get rid of the Angular compiler (in the browser) altogether.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 结合使用摇树和 **提前编译**（**AoT**），我们可以完全去除浏览器中的 Angular 编译器。
- en: With AoT compilation, the view templates (HTML) are compiled beforehand on the
    server side. This compilation again is done as part of the app's build process
    where a server version of the Angular compiler (a node package) compiles every
    view in the application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AoT 编译，视图模板（HTML）在服务器端预先编译。这次编译作为应用程序构建过程的一部分进行，其中服务器版本的 Angular 编译器（一个节点包）编译应用程序中的每个视图。
- en: With all the templates compiled, there is no need to send the Angular compiler
    bits to the client side at all. Tree shaking can now just get rid of the compiler
    and create a far slimmer framework package. Angular CLI supports AoT compilation
    and can be used for production builds.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有模板编译完成后，就无需将 Angular 编译器代码发送到客户端。现在，摇树可以去除编译器，创建一个更精简的框架包。Angular CLI 支持
    AoT 编译，可用于生产构建。
- en: Read more about AoT in the framework documentation available at [http://bit.ly/ngx-aot](http://bit.ly/ngx-aot).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 AoT 的信息，请参阅框架文档，可在 [http://bit.ly/ngx-aot](http://bit.ly/ngx-aot) 找到。
- en: Initial load time and memory utilization
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始加载时间和内存使用
- en: The initial load time for any web app with a full-fledged JavaScript framework
    is typically slow. This effect is more pronounced on mobile devices, where the
    JavaScript engine may not be as powerful as a desktop client. For a better user
    experience, it becomes imperative that the framework initial load time is optimized,
    especially for mobile devices.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有完整 JavaScript 框架的 Web 应用程序的初始加载时间通常较慢。在移动设备上，这种影响更为明显，因为 JavaScript 引擎可能没有桌面客户端强大。为了提供更好的用户体验，优化框架的初始加载时间变得至关重要，尤其是在移动设备上。
- en: Out of the box, **Angular 2 was five times faster than AngularJS** when it came
    to initial load time and re-rendering the view. These numbers are getting better
    as the Angular team evolves the framework.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，**Angular 2 在初始加载时间和视图重渲染方面比 AngularJS 快五倍**。随着 Angular 团队对框架的改进，这些数字正在变得更好。
- en: Further, AoT compilation too can improve the initial load time of the application
    as a time-consuming activity (view compilation) is not required.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，AoT 编译也可以提高应用程序的初始加载时间，因为不需要进行耗时活动（视图编译）。
- en: The same holds true for memory utilization. Angular fares better here too, and
    things will get even better with future releases.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内存使用，这也同样适用。Angular 在这里表现也更好，未来的版本将使事情变得更好。
- en: 'If you are planning to switch to Angular, this is something that you should
    look forward to: a performant framework built for the future.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划切换到 Angular，这是你应该期待的事情：一个为未来构建的高性能框架。
- en: 'The next three performance improvements that we are going to talk about have
    been made possible because of a single architectural decision: *the creation of
    a separate renderer layer*.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的下一个性能改进是由于一个单一架构决策而成为可能的：*创建一个单独的渲染层*。
- en: The Angular rendering engine
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular渲染引擎
- en: The biggest disadvantage of AngularJS was that the framework was tied to the
    browser DOM. The directives, the binding, and the interpolations all worked against
    the DOM.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS最大的缺点是框架绑定到浏览器DOM上。指令、绑定和插值都是针对DOM工作的。
- en: 'With Angular, the biggest architectural change that came in was a separate
    rendering layer. Now, an Angular app has two layers:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Angular，最大的架构变化是引入了一个独立的渲染层。现在，一个Angular应用有两个层：
- en: '**Application layer**: This is the layer our code resides in. It uses an abstraction
    build over the renderer layer to interact with it. The Renderer class we saw in
    Chapter 6, *Angular Directives in Depth*, is the interface that we use to interact
    with the rendering layer.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**：这是我们的代码所在的一层。它通过在渲染层之上构建的抽象来与它交互。我们在第6章“深入理解Angular指令”中看到的Renderer类是我们用来与渲染层交互的接口。'
- en: '**Rendering layer**: This layer is responsible for translating requests from
    the application layer into rendered components, and reacting to user input and
    view updates.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染层**：这一层负责将应用层的请求转换为渲染组件，并对用户输入和视图更新做出反应。'
- en: The default renderer implementation for the renderer is `DomRenderer`, which
    runs inside the browser. But there are other rendering abstractions too and we
    will discuss them in the following section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的渲染器实现是`DomRenderer`，它在浏览器内部运行。但还有其他渲染抽象，我们将在下一节中讨论。
- en: Server-side rendering
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: '**Pre-rendering** on the server side is yet another technique for improving
    the initial load time of an Angular app. This technique is really helpful on mobile
    devices, as it improves the perceived load time considerably.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器端预渲染**是提高Angular应用初始加载时间的另一种技术。这项技术在移动设备上特别有帮助，因为它显著提高了感知的加载时间。'
- en: Server-side rendering takes care of the initial page load before client-side
    rendering kicks in (and handles view rendering henceforth).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染负责在客户端渲染启动之前处理初始页面加载（并从此处理视图渲染）。
- en: In such a scenario, when the user requests for a view/page, a piece of software
    on the server generates a fully materialized HTML page with data pre-bound to
    the view and sends it to the client along with a small script. The app view is
    therefore immediately rendered, ready for interaction. While the framework loads
    in the background, the small script that was sent along the first time captures
    all user inputs and makes them available to the framework, allowing it to replay
    the interactions once it is loaded.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当用户请求一个视图/页面时，服务器上的一块软件生成一个完全实例化的HTML页面，其中数据预先绑定到视图，并将其与一小段脚本一起发送到客户端。因此，应用视图可以立即渲染，准备交互。当框架在后台加载时，第一次发送的小脚本捕获所有用户输入，并使它们对框架可用，允许它在加载后重放这些交互。
- en: '**Angular Universal**, as it is touted, allows rendering and sharing of the
    view both on the server and the client side.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**Angular Universal**，正如其名，允许在服务器和客户端上渲染和共享视图。'
- en: Server-side rendering is only made possible because of separation of the rendering
    layer described previously. The initial view is generated by a renderer implementation
    on the server, named `ServerDomRenderer`. There is a Node.js plugin ([http://bit.ly/ng-universal-node](http://bit.ly/ng-universal-node))
    that can be used in a number of node web frameworks such as *Express*, *Hapi*,
    *Sail*, and others.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染之所以成为可能，是因为之前描述的渲染层的分离。初始视图由服务器上的渲染器实现生成，名为`ServerDomRenderer`。有一个Node.js插件（[http://bit.ly/ng-universal-node](http://bit.ly/ng-universal-node)），可以在多个Node.js
    Web框架中使用，如*Express*、*Hapi*、*Sail*等。
- en: Look at the Angular design docs for Angular Universal ([http://bit.ly/ng-universal-design](http://bit.ly/ng-universal-design))
    and the embedded YouTube videos at the top of the design doc to learn more about
    server-side rendering.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Angular Universal的设计文档（[http://bit.ly/ng-universal-design](http://bit.ly/ng-universal-design)）和设计文档顶部的嵌入YouTube视频，以了解更多关于服务器端渲染的信息。
- en: Performance is not the only benefit with server-side rendering. As it turns
    out, search indexers too like pre-rendered HTML content. Server-side rendering
    is really useful in areas such as **search engine optimization (SEO)** and deep
    linking, which allows easy content sharing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染不仅带来了性能上的好处。实际上，搜索引擎索引器也喜欢预渲染的HTML内容。服务器端渲染在搜索引擎优化（SEO）和深度链接等领域非常有用，这允许轻松的内容共享。
- en: Offloading work to a web worker
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将工作卸载到Web Worker
- en: Offloading work to a **web worker** is a neat idea, again made possible due
    to the separation of the rendering layer from the application layer.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将工作委托给**web worker**是一个很好的想法，这再次得益于渲染层与应用层之间的分离。
- en: '*Web workers* provide a mechanism for running scripts in background threads.
    These threads can execute work that does not involve the browser DOM. Be it a
    CPU-intensive task or a remote XHR invocation, all can be delegated to web workers.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*Web workers*提供了一种在后台线程中运行脚本的方法。这些线程可以执行不涉及浏览器DOM的工作。无论是CPU密集型任务还是远程XHR调用，都可以委托给web
    workers。'
- en: In today's world, CPUs with multiple cores are the norm, but JavaScript execution
    is still single-threaded. There is a need for a standard/mechanism to utilize
    these idle cores for our apps. Web workers fit the bill perfectly, and since most
    modern browsers support them, we all should be writing code that utilizes web
    workers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今世界，多核CPU已成为常态，但JavaScript执行仍然是单线程的。我们需要一个标准/机制来利用这些空闲核心为我们的应用程序服务。Web workers完美地满足了这一需求，并且由于大多数现代浏览器都支持它们，我们都应该编写利用web
    workers的代码。
- en: 'Sadly, that''s not happening. Web workers are still not mainstream, and there
    are good reasons for that. Web workers impose a good number of restrictions on
    what is allowed and what is not. These limitations include:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，这种情况并没有发生。Web workers仍然不是主流，这有很好的原因。Web workers对允许和不允许的内容施加了许多限制。这些限制包括：
- en: '**No direct access to DOM**: Web workers cannot directly manipulate the DOM.
    In fact, web workers do not have access to multiple globals such as *window* and
    *document*, and others are not available on the web worker thread. This severely
    limits the number of use cases where a web worker can be utilized.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无法直接访问DOM**：Web workers不能直接操作DOM。实际上，web workers无法访问多个全局变量，如*window*和*document*，以及其他在web
    worker线程上不可用。这严重限制了web worker可以使用的用例数量。'
- en: '**Browser support**: Web workers are only available for modern/evergreen browsers
    (IE 10+).'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览器支持**：Web workers仅适用于现代/持续更新的浏览器（IE 10+）。'
- en: '**Inter-process communication**: Web workers do not share the memory with your
    main browser process, and hence need to communicate with the main thread (UI thread)
    only through *message passing* (serialized data). Adding to that, the message
    passing mechanism is asynchronous in nature, adding another layer of complexity
    to the communication model.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程间通信**：Web workers不与你的主浏览器进程共享内存，因此只能通过*消息传递*（序列化数据）与主线程（UI线程）通信。此外，消息传递机制本质上是异步的，这给通信模型增加了另一层复杂性。'
- en: Clearly, web workers are hard to use.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，web workers难以使用。
- en: Angular tries to alleviate these limitations by integrating the web worker usage
    into the framework itself. It does that by running the complete application in
    the web worker thread, except the rendering part.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Angular试图通过将web worker的使用集成到框架本身中来减轻这些限制。它是通过在web worker线程中运行整个应用程序来实现的，除了渲染部分。
- en: The framework takes care of the communication between the application code running
    inside the web worker and the renderer running inside the main UI thread. From
    a developer's perspective, there are no visible differences.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 框架负责在web worker内部运行的应用代码与主UI线程内运行的渲染器之间的通信。从开发者的角度来看，没有明显的区别。
- en: 'This is again made possible due to the separation of the renderer layer in
    Angular. The following diagram shows the layers that run on the app main thread
    and what runs inside the web worker:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样得益于Angular中渲染层的分离。以下图表显示了在应用主线程上运行的层以及在内置web worker中运行的层：
- en: '![](img/00078.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00078.jpeg)'
- en: Go through this talk ([http://bit.ly/yt-ng-web-worker](http://bit.ly/yt-ng-web-worker))
    from Jason Teplitz to learn about what web workers have to offer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观看Jason Teplitz的这次演讲([http://bit.ly/yt-ng-web-worker](http://bit.ly/yt-ng-web-worker))来了解web
    workers能提供什么。
- en: Performant mobile experience
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效的移动体验
- en: Angular's rendering abstraction again opens up a host of integration avenues,
    especially on the mobile platform. Rather than running an app on a mobile browser,
    Angular renderers can be created that can tap the device's native UI capabilities.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的渲染抽象再次开辟了许多集成途径，尤其是在移动平台上。而不是在移动浏览器上运行应用程序，Angular渲染器可以被创建出来，可以调用设备的原生UI功能。
- en: 'Two notable projects in this domain are renderers for platforms:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个领域有两个值得注意的项目：平台渲染器：
- en: '**ReactNative** ([http://bit.ly/rnative](http://bit.ly/rnative)): A renderer
    for ReactNative ([http://bit.ly/ng-rnative](http://bit.ly/ng-rnative)). It allows
    the writing of Angular apps using ReactNative''s rendering capabilities.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ReactNative** ([http://bit.ly/rnative](http://bit.ly/rnative))：一个ReactNative的渲染器([http://bit.ly/ng-rnative](http://bit.ly/ng-rnative))。它允许使用ReactNative的渲染能力编写Angular应用。'
- en: '**NativeScript** ([https://www.nativescript.org/](https://www.nativescript.org/)):
    Angular and NativeScript teams have collaborated to create a renderer for NativeScript
    ([http://bit.ly/ng-native-script](http://bit.ly/ng-native-script)).'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NativeScript** ([https://www.nativescript.org/](https://www.nativescript.org/))：Angular和NativeScript团队合作创建了一个NativeScript的渲染器([http://bit.ly/ng-native-script](http://bit.ly/ng-native-script))。'
- en: App platforms such as *ReactNative* and *NativeScript* already do a superb job
    of providing JavaScript-based APIs for the native mobile platforms (iOS and Android),
    allowing us to utilize a single code base with a familiar language. Angular renderers
    take things a step further. With Angular integration, a good amount of code can
    be shared across browsers and mobile devices. Things may only differ in terms
    of view templates and view-related services such as dialogs, popups, and others.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如*ReactNative*和*NativeScript*这样的应用平台已经出色地提供了针对原生移动平台（iOS和Android）的基于JavaScript的API，使我们能够使用熟悉的语言利用单一代码库。Angular渲染器更进一步。通过Angular集成，大量代码可以在浏览器和移动设备之间共享。可能只有视图模板和与视图相关的服务（如对话框、弹出窗口等）有所不同。
- en: Look at the documentation for the respective renderers to understand how they
    work and the features they support.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看相应渲染器的文档，以了解它们的工作原理和支持的功能。
- en: Next up on the line, we have framework improvements in terms of *change detection*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论框架在*变更检测*方面的改进。
- en: Change detection improvements
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变更检测改进
- en: One of the major performance improvements in Angular over AngularJS is in how
    *change detection* works in Angular. Out of the box, Angular change detection
    is insanely fast, and it can be tweaked even further for better results.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular相对于AngularJS的几个主要性能改进中，Angular中*变更检测*的工作方式是一个亮点。Angular的变更检测默认情况下非常快，并且可以进一步调整以获得更好的结果。
- en: The next few sections talk about Angular change detection in depth. It's an
    important topic to understand when building anything at scale. It also helps us
    debug scenarios where it may seem that change detection is not working as advertised.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几节将深入讨论Angular的变更检测。在构建任何大规模应用时，这是一个重要的理解主题。它还有助于我们调试那些看起来变更检测没有按预期工作的场景。
- en: Let's start the discussion by understanding what change detection is and why
    it is important.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从了解什么是变更检测以及为什么它很重要开始讨论。
- en: Change detection
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变更检测
- en: Angular's *data binding engine* does a great job of binding the view with the
    model data (component data). These are live bindings where Angular keeps the view
    in sync with model changes. Any time the model changes, the binding engine re-renders
    parts of the view that are dependent on the model. To manage this view-model synchronization,
    Angular needs to know when the model changed and what changed exactly. This is
    what **change detection** is all about. During app execution, Angular frequently
    does what we call **change detection runs** to determine what changed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的*数据绑定引擎*在将视图与模型数据（组件数据）绑定方面做得很好。这些是实时绑定，Angular会保持视图与模型变化同步。每当模型发生变化时，绑定引擎都会重新渲染依赖于模型的视图部分。为了管理这种视图-模型同步，Angular需要知道模型何时发生变化以及具体发生了什么变化。这就是*变更检测*的全部内容。在应用执行期间，Angular会频繁地进行我们所说的*变更检测运行*，以确定发生了什么变化。
- en: If you are from AngularJS, a *change detection run* is roughly equivalent to
    **digest cycles**, except that in Angular there are **no cycles**.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自AngularJS，一个*变更检测运行*大致相当于**消化周期**，只不过在Angular中**没有循环**。
- en: While this problem of keeping the model and view in sync may sound simple, it's
    a tough nut to crack. Unlike the component tree, the interconnection between multiple
    models can be complex. Changes in one component model can trigger changes in multiple
    component models. Furthermore, these interconnections may have cycles. A single
    model property could be bound to multiple views. All these complex scenarios need
    to be managed using a robust change detection infrastructure.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然保持模型和视图同步的问题听起来很简单，但实际上是一个难题。与组件树不同，多个模型之间的相互连接可能很复杂。一个组件模型的变化可能会触发多个组件模型的变化。此外，这些相互连接可能存在循环。单个模型属性可能绑定到多个视图。所有这些复杂场景都需要使用强大的变更检测基础设施来管理。
- en: In the next few sections, we explore how the Angular change detection infrastructure
    works, when change detection triggers, and how can we influence change detection
    behavior in Angular.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将探讨Angular变更检测基础设施的工作原理、变更检测何时触发，以及我们如何影响Angular中的变更检测行为。
- en: Change detection setup
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变更检测设置
- en: 'It all starts with Angular setting up change detectors for every component
    rendered on the view. Since every Angular app is a hierarchy of components, these
    change detectors are also set up in the same hierarchy. The following diagram
    highlights the **change detector hierarchy** of the *Workout Builder* app at a
    point in time:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切都始于Angular为视图上渲染的每个组件设置变更检测器。由于每个Angular应用都是组件的层次结构，这些变更检测器也在相同的层次结构中设置。以下图表突出显示了在某个时间点*Workout
    Builder*应用的**变更检测器层次结构**：
- en: '![](img/00079.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00079.jpeg)'
- en: A *change detector* attached to a component has the responsibility of detecting
    changes in the component. It does that by parsing the binding on the component's
    template HTML and setting up the necessary change detection watches.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 附属于组件的*变更检测器*负责检测组件中的变更。它是通过解析组件模板HTML中的绑定并设置必要的变更检测监视来做到这一点的。
- en: Remember, the detector only sets up watches on model properties used in the
    template, not on all component properties.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，检测器只为模板中使用的模型属性设置监视，而不是所有组件属性。
- en: Another important point worth highlighting here is that *change detection is
    set up one way, from model to view*. Angular does not have the concept of two-way
    data binding and hence the preceding figure is a directed tree without cycles.
    This also makes change detection more predictable. Interleaving model and view
    updates are disallowed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得强调的重要观点是，*变更检测是从模型到视图单向设置的*。Angular没有双向数据绑定的概念，因此前面的图是一个没有环的有向树。这也使得变更检测更加可预测。不允许模型和视图更新交织。
- en: When does change detection kick in?
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变更检测何时启动？
- en: Does Angular constantly check for changes in the model data? Considering the
    fact that the component properties we bind the view to do not inherit from any
    special class, Angular has no way of knowing which property changed. The only
    way out for Angular is to constantly query each data-bound property to know its
    current value and compare it against its old value for changes. Highly inefficient
    to say the least!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是否始终检查模型数据中的变更？考虑到我们绑定的视图组件属性不继承任何特殊类，Angular无法知道哪个属性发生了变化。Angular的唯一出路是不断查询每个数据绑定属性以了解其当前值，并将其与旧值进行比较以检测变更。至少可以说，这是非常低效的！
- en: Angular does better than that, as change detection runs get executed only at
    specific times during app execution. Think carefully about any web application;
    what causes a view to update?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的表现优于这一点，因为变更检测只在应用执行过程中的特定时间执行。仔细思考任何Web应用；是什么原因导致视图更新？
- en: 'A view can get updated due to:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 视图可以因为以下原因而更新：
- en: '**User input/browser events**: We click on a button, enter some text, or scroll
    the content. Each of these actions can update the view (and the underlying model).'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户输入/浏览器事件**：我们点击按钮、输入一些文本或滚动内容。这些操作中的每一个都可以更新视图（以及底层的模型）。'
- en: '**Remote XHR requests**: This is another common reason for view updates. Getting
    data from a remote server to show on the grid and getting user data to render
    a view are examples of this.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程XHR请求**：这是视图更新的另一个常见原因。从远程服务器获取数据以显示在网格上，以及获取用户数据以渲染视图都是这种情况的例子。'
- en: '**setTimeout and setInterval timers**: As it turns out, we can use `setTimeout`
    and `setInterval` to execute some code asynchronously and at specific intervals.
    Such code can also update the model. For example, a `setInterval` timer may check
    for stock quotes at regular intervals and update the stock price on the UI.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**setTimeout和setInterval计时器**：实际上，我们可以使用`setTimeout`和`setInterval`来异步执行某些代码并在特定间隔执行。这样的代码也可以更新模型。例如，一个`setInterval`计时器可能会定期检查股票报价，并在UI上更新股票价格。'
- en: For obvious reasons, Angular change detection too kicks in only when any of
    these conditions occur.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于显而易见的原因，Angular的变更检测也只有在以下任何条件发生时才会启动。
- en: The interesting part here is not when Angular's change detection kicks in but
    how Angular is able to intercept all *browser events*, *XHR requests*, and `setTimeout`
    and `setInterval` functions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的部分不是Angular的变更检测何时启动，而是Angular如何能够拦截所有*浏览器事件*、*XHR请求*以及`setTimeout`和`setInterval`函数。
- en: 'This feat in Angular is performed by a library called `zone.js`. As the documentation
    describes:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中完成这一壮举的是一个名为`zone.js`的库。正如文档所描述的：
- en: '"A Zone is an execution context that persists across async tasks."'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '"区域是一个在异步任务中持续存在的执行上下文。"'
- en: 'One of the basic abilities of this library is that it can hook into a piece
    of code and trigger callbacks when code execution starts and when it ends. The
    code being monitored could be a sequence of calls that are both synchronous and
    asynchronous in nature. Consider this example, which highlights the usage:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库的一项基本能力是它可以钩入一段代码，并在代码执行开始和结束时触发回调。被监控的代码可能是一系列既同步又异步的调用。考虑以下示例，它突出了使用情况：
- en: '[PRE0]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We wrap a piece of code inside a call to the `zone.run` call. This code calls
    the `doWork` function synchronously twice, interleaved with a `setTimeout` call
    that invokes the same function after a lapse of 200 milliseconds.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一段代码包裹在`zone.run`调用中。这段代码同步地调用`doWork`函数两次，并在两次调用之间插入一个`setTimeout`调用，该调用在200毫秒后再次调用相同的函数。
- en: 'By wrapping this sequence inside `zone.run`, we can know when the call execution
    is complete. In zone terminology, these are **turns**. The code before `zone.run`
    sets up a subscriber that gets called when execution is complete, using the `zone.onMicrotaskEmpty`
    function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这个序列包裹在`zone.run`中，我们可以知道调用执行何时完成。在区域术语中，这些是**轮次**。`zone.run`之前的代码设置了一个订阅者，当执行完成时会被调用，使用`zone.onMicrotaskEmpty`函数：
- en: 'If we execute the preceding code, the logs look as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行前面的代码，日志看起来如下：
- en: '[PRE1]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `onMicrotaskEmpty` subscription is executed twice, once after the sequential
    execution completes (defined inside `run` callback) and one after the asynchronous
    `setTimeout` execution is complete.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`onMicrotaskEmpty`订阅执行了两次，一次是在顺序执行完成后（定义在`run`回调中），另一次是在异步`setTimeout`执行完成后。'
- en: Angular change detection uses the same technique to execute our code within
    zones. This code could be an *event handler*, which internally makes more synchronous
    and asynchronous calls before completing, or it could be a `setTimeout`/`setInterval`
    operation that may again require a UI update.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的变更检测使用相同的技巧在区域中执行我们的代码。这段代码可能是一个*事件处理器*，它在完成之前内部进行更多的同步和异步调用，或者它可能是一个`setTimeout`/`setInterval`操作，可能还需要更新UI。
- en: 'The Angular change detection framework subscribes to the `onMicrotaskEmpty`
    observable for the executing zone, and kicks in change detection whenever a turn
    is complete. The following diagram highlights what happens when code similar to
    the one just described is run on a button click:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Angular变更检测框架订阅执行区域的`onMicrotaskEmpty`可观察对象，并在每次轮次完成后启动变更检测。以下图示突出了当运行类似前面描述的代码在按钮点击时发生的情况：
- en: '![](img/00080.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00080.jpeg)'
- en: During the execution of the code block, if the zone library determines that
    the call is asynchronous in nature, it spawns a new micro task that has its own
    life cycle. It is the completion of these micro tasks that also triggers `onMicrotaskEmpty`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码块执行过程中，如果区域库确定该调用是异步的，它将产生一个新的微任务，该任务有自己的生命周期。这些微任务的完成也会触发`onMicrotaskEmpty`。
- en: 'If you want to know how the change detection trigger looks inside Angular,
    here is an excerpt from the Angular source code (simplified further):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道Angular内部变更检测触发器是如何工作的，以下是Angular源代码的摘录（进一步简化）：
- en: '[PRE2]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `ApplicationRef` class tracks all the change detectors attached throughout
    the app and triggers a change detection cycle when the application-level zone
    object fires the `onMicrotaskEmpty` event. We will shortly touch upon what happens
    during this change detection.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicationRef`类跟踪整个应用程序中附加的所有变更检测器，并在应用程序级别的区域对象触发`onMicrotaskEmpty`事件时触发变更检测周期。我们很快就会涉及到这个变更检测期间发生的事情。'
- en: '*Zone.js* gets the ability to track execution context across any asynchronous
    call because it overrides the default browser API. The override, also termed **monkey
    patching**, overrides the *event subscription*, *XHR requests*, and `setTimeout`/`setInterval`
    API. In the example highlighted previously, the `setTimeout` we invoke is a monkey-patched
    version of the original browser API.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*Zone.js* 通过覆盖默认浏览器API获得了跟踪任何异步调用执行上下文的能力。这种覆盖，也称为**猴子补丁**，覆盖了*事件订阅*、*XHR请求*以及`setTimeout`/`setInterval`
    API。在前面突出显示的例子中，我们调用的`setTimeout`是原始浏览器API的猴子补丁版本。'
- en: Now that we know how change detectors are set up and when this activity kicks
    in, we can look at how it works.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了变更检测器的设置方式和何时启动这项活动，我们可以看看它是如何工作的。
- en: How does change detection work?
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何进行变更检测？
- en: Once the change detectors are set up and the browser API is monkey-patched to
    trigger change detection, the real change detection kicks in. This is quite a
    simple process.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦变化检测器设置完成并且浏览器 API 被猴子补丁以触发变化检测，真正的变化检测就开始了。这是一个相当简单的过程。
- en: As soon as any of the asynchronous event callbacks are triggered (the execution
    of an event handler is also an async activity), Angular first executes the application
    code we attached to the callback. This code execution may result in some model
    updates. After the execution of the callback, Angular needs to respond to the
    changes by triggering a *change detection run*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦任何异步事件回调被触发（事件处理器的执行也是一种异步活动），Angular 首先执行我们附加到回调的应用程序代码。这段代码的执行可能会导致一些模型更新。在回调执行之后，Angular
    需要通过触发一个 *变化检测运行* 来响应这些变化。
- en: In a change detection run, starting from the top of the component tree, every
    change detector evaluates its respective component's template bindings to see
    if the value of the binding expression has changed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在变化检测运行中，从组件树的顶部开始，每个变化检测器都会评估其相应组件的模板绑定，以查看绑定表达式的值是否已更改。
- en: 'There are some things that we need to highlight regarding this execution:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个执行，我们需要强调以下几点：
- en: Angular does a strict equality check (using `===`) to detect changes. Since
    it's not a deep comparison, for a binding that refers to an object, Angular will
    only update the view when the object reference changes.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 使用严格的相等性检查（使用 `===`）来检测变化。由于它不是深度比较，对于引用对象的绑定，Angular 只在对象引用发生变化时更新视图。
- en: The change detection flow is unidirectional (starting from root), from parent
    to child in a top-down fashion. The detectors on the parent component run before
    the child detectors.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变化检测流程是单向的（从根开始），以自顶向下的方式从父到子。父组件上的检测器在子组件检测器之前运行。
- en: 'By default, the change detection algorithm navigates the complete tree, irrespective
    of where the change was triggered in the tree. This implies all binding is evaluated
    on every change detection run:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，变化检测算法遍历整个树，而不管变化是在树的哪个位置触发的。这意味着每次变化检测运行时都会评估所有的绑定：
- en: '![](img/00081.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00081.jpeg)'
- en: A binding evaluation on every run may seem inefficient, but it is not. Angular
    employs some advance optimizations to make this check super fast. Still, if we
    want to tweak this behavior, we do have some switches that can reduce the number
    of checks performed. We will touch upon this topic soon.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行都进行绑定评估可能看起来效率不高，但实际上并非如此。Angular 采用一些高级优化来使这个检查非常快。尽管如此，如果我们想调整这种行为，我们确实有一些开关可以减少执行的检查次数。我们很快就会涉及到这个话题。
- en: Change detectors only track properties that are part of template bindings, not
    the complete object/component properties.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变化检测器只跟踪模板绑定中的属性，而不是完整的对象/组件属性。
- en: To detect changes in the bound value, the change detectors need to track the
    previous value of the expression evaluated during the last change detection run.
    Clearly, some amount of bookkeeping is required for every template binding we
    use.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了检测绑定值的更改，变化检测器需要跟踪在上次变化检测运行期间评估的表达式的上一个值。显然，对于每个我们使用的模板绑定，都需要进行一些记录。
- en: The obvious next question would be what happens when a change is detected (by
    a change detector)?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，接下来的问题会是当检测到变化（由变化检测器检测）时会发生什么？
- en: Since all the hard work of setting up change detection and identifying changes
    has already been done, this step just involves updating the component state and
    synchronizing the component DOM.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设置变化检测和识别更改的所有艰苦工作已经完成，这一步只是涉及更新组件状态和同步组件 DOM。
- en: 'There are a few more observations worth highlighting here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一些值得强调的观察结果：
- en: 'First and foremost, Angular separates the model update step from the DOM update.
    Consider this code snippet, which is invoked when someone clicks on a button:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首要的是，Angular 将模型更新步骤与 DOM 更新步骤分离。考虑以下代码片段，它在有人点击按钮时被调用：
- en: '[PRE3]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Assuming that both `firstName` and `lastName` are bound to the component view,
    a change to `firstName` does not update the DOM binding immediately. Instead,
    Angular waits for the `doWork` function to complete before triggering a change
    detection run and DOM update.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `firstName` 和 `lastName` 都绑定到组件视图，对 `firstName` 的更改不会立即更新 DOM 绑定。相反，Angular
    会等待 `doWork` 函数完成，然后触发变化检测运行和 DOM 更新。
- en: Secondly, a change detection run does not (and should not) update the model
    state. This avoids any cycles and cascading updates. A change detection run is
    only responsible for evaluating the bindings and updating the view. This also
    means that we should not update the model state during change detection. If we
    update the model during change detection, Angular throws an error.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，一个变更检测运行不会（也不应该）更新模型状态。这避免了任何循环和级联更新。变更检测运行只负责评估绑定和更新视图。这也意味着我们不应该在变更检测期间更新模型状态。如果我们更新模型，Angular
    会抛出一个错误。
- en: 'Let''s see an example of this behavior:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个行为的例子：
- en: 'Open `start.component.html` from the 7 Minute Workout app and update the last
    `div` to:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 7 分钟健身应用中的 `start.component.html`，并将最后一个 `div` 更新为：
- en: '[PRE4]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And, add a `changeDetectionDone` function to the component implementation (`start.component.ts`),
    which looks like:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在组件实现（`start.component.ts`）中添加一个 `changeDetectionDone` 函数，其看起来如下：
- en: '[PRE5]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the app, load the start page, and then look at the browser console. Angular
    has logged a number of errors that look like the following:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用，加载起始页面，然后查看浏览器控制台。Angular 记录了许多看起来如下所示的错误：
- en: '[PRE6]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We are changing the state of the component when calling the `changeDetectionDone`
    function (inside an interpolation), and Angular throws an error because it does
    not expect the component state to update.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `changeDetectionDone` 函数（在一个插值内）时，我们正在改变组件的状态，Angular 会抛出一个错误，因为它没有预料到组件状态会更新。
- en: 'This change detection behavior is enabled only when **production mode** in
    Angular is disabled. *Production mode* can be enabled by calling the `enableProdMode()`
     function before bootstrapping the application (in `bootstrap.ts`). When enabled,
    Angular behaves a bit differently. It turns off assertions and other checks within
    the framework. Production mode also affects the change detection behavior. In
    non-production mode, Angular traverses the component tree twice to detect changes.
    If on the second pass any binding expression has changed, it throws an error.
    In contrast, when in production mode, change detection tree traversal is done
    only once. The change detection error that we saw on the console will not show
    up if we enable production mode. This can lead to an inconsistency between the
    model and view state. Something we should be aware of! The bottom line is that
    we cannot alter the state of a component when change detection is in progress.
    A direct corollary: if we are using a function inside the binding expression,
    function executions should be stateless, without any side effects.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变更检测行为仅在 Angular 的**生产模式**被禁用时启用。*生产模式*可以通过在启动应用之前调用 `enableProdMode()` 函数来启用（在
    `bootstrap.ts` 中）。启用后，Angular 的行为会有所不同。它会关闭框架内的断言和其他检查。生产模式也会影响变更检测行为。在非生产模式下，Angular
    会遍历组件树两次以检测变更。如果在第二次遍历中任何绑定表达式已更改，它会抛出一个错误。相比之下，在生产模式下，变更检测树遍历只执行一次。我们在控制台上看到的变更检测错误如果启用生产模式将不会显示。这可能导致模型和视图状态之间不一致。这是我们应意识到的事情！底线是，我们不能在变更检测进行时改变组件的状态。一个直接的推论是：如果我们在一个绑定表达式中使用函数，函数执行应该是无状态的，没有副作用。
- en: Lastly, this change detection traversal from root to leaf node executes only
    once during the change detection run.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，这个从根节点到叶节点的变更检测遍历在变更检测运行期间只执行一次。
- en: A pleasant surprise for folks with an AngularJS background! *The digest cycle
    count in Angular is 1*. Angular developers will never face "the digest iterations
    exceeded exception!" A far more performant change detection system!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有 AngularJS 背景的人来说，这是一个令人愉快的惊喜！*Angular 中的消化周期计数为 1*。Angular 开发者永远不会遇到“消化迭代超出异常”！一个性能更优的变更检测系统！
- en: Change detection performance
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变更检测性能
- en: Let's talk about change detection performance. If you think checking the complete
    component tree every time for change is inefficient, you will be surprised to
    know how fast it is. Due to some optimization around how expressions are evaluated
    and compared, Angular can perform thousands of checks in a couple of milliseconds.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈变更检测性能。如果你认为每次检查整个组件树以查找变更是不高效的，你将会惊讶地知道它是多么快。由于一些关于表达式评估和比较的优化，Angular
    可以在几毫秒内执行数千次检查。
- en: Under the hood, for every expression involved in the view binding, Angular generates
    a change detection function that specifically targets a particular binding. While
    it may seem counter intuitive at first, Angular does not have a common function
    for determining whether an expression has changed. Instead, it's like writing
    our own change detection function for every property that we bind to. This allows
    the JavaScript VM to optimize the code, resulting in improved performance.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，对于每个涉及视图绑定的表达式，Angular 都会生成一个专门针对特定绑定的变更检测函数。虽然一开始可能看起来有些反直觉，但 Angular 并没有用于确定表达式是否已更改的通用函数。相反，它就像为每个我们绑定的属性编写我们自己的变更检测函数。这允许
    JavaScript VM 优化代码，从而提高性能。
- en: 'Want to learn more about it? Check out this video by Victor Savkin: [https://youtu.be/jvKGQSFQf10](https://youtu.be/jvKGQSFQf10).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于它的信息？查看维克多·萨金（Victor Savkin）的这段视频：[https://youtu.be/jvKGQSFQf10](https://youtu.be/jvKGQSFQf10)。
- en: In spite of all this optimization, there may still be cases where traversing
    the complete component tree may not be performant enough. This is especially true
    when we have to render a large dataset on the view, keeping the bindings intact.
    The good news is that the Angular change detection mechanism can be tweaked.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管进行了所有这些优化，但仍可能存在一些情况，遍历完整的组件树可能不足以高效。这尤其在我们需要在视图中渲染大量数据集并保持绑定完整时更为明显。好消息是，Angular
    的变更检测机制可以进行微调。
- en: The reason Angular needs to do the complete tree walk is that model changes
    in one place may trigger model changes at other places. In other words, a model
    change may have a cascading effect, where interconnected model objects are also
    updated. Since Angular has no way to know what exactly changed, it checks the
    complete component tree and associated model.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 需要遍历整个树的原因是，一个地方的模式变化可能会在其他地方触发模式变化。换句话说，模式变化可能产生级联效应，相互连接的模式对象也会被更新。由于
    Angular 无法知道确切发生了什么变化，它检查完整的组件树和相关模式。
- en: If we can help Angular determine what parts of the application state are updated,
    Angular can be pretty smart about what part of the component tree it traverses
    to detect changes. We do this by storing the app data in some special data structures
    that help Angular decide what components need to be checked for changes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以帮助 Angular 确定应用程序状态中哪些部分被更新，Angular 就可以非常智能地决定遍历组件树以检测更改的部分。我们通过将应用程序数据存储在某些特殊的数据结构中来实现这一点，这些数据结构帮助
    Angular 决定哪些组件需要检查更改。
- en: There are three ways in which we can make Angular change detection smarter.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种方法可以使 Angular 的变更检测更智能。
- en: Using immutable data structures
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不可变数据结构
- en: '**Immutable objects/collections** are objects that cannot be changed once created.
    Any property change results in a new object being created. This is what `immutable.js`,
    a popular library for immutable data structures, has to say:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可变对象/集合**是创建后不能更改的对象。任何属性更改都会导致创建一个新的对象。这是 `immutable.js`，一个流行的不可变数据结构库，对此所说的话：'
- en: Immutable data cannot be changed once created, leading to much simpler application
    development, no defensive copying, and enabling advanced memoization and change
    detection techniques with simple logic.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数据一旦创建就不能更改，这导致应用程序开发更加简单，无需进行防御性复制，并允许使用简单的逻辑实现高级记忆化和变更检测技术。
- en: Let's try to understand how immutable data structures help in the Angular context
    with an example.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来尝试理解不可变数据结构如何在 Angular 上下文中提供帮助。
- en: 'Imagine we are building a set of components to collect employee information
    for a **Human Resource** (**HR**) software. The employee component view looks
    something like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在构建一组组件来收集人力资源（**HR**）软件的员工信息。员工组件视图看起来可能像这样：
- en: '[PRE7]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It has sections for taking personal, professional, and address information.
    The `summary` components provide a read-only view of the employee data being entered.
    Each of the components has a property called `model`, highlighting what part of
    employee data these components manipulate. Each of these components'' summary,
    professional, personal, and address internally may have other child components.
    This is how the component tree looks:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 它有用于收集个人、专业和地址信息的部分。`summary` 组件提供了正在输入的员工数据的只读视图。每个组件都有一个名为 `model` 的属性，突出显示这些组件操作员工数据的哪些部分。这些组件的摘要、专业、个人和地址内部可能还有其他子组件。这就是组件树的外观：
- en: '![](img/00082.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00082.jpeg)'
- en: What happens when we update an employee's personal information? With standard
    objects (mutable), Angular cannot make any assumption about the shape of data
    and what has changed; hence, it does the complete tree walk.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更新员工的个人信息时会发生什么？使用标准对象（可变）时，Angular无法对数据的形状和变化做出任何假设；因此，它执行完整的树遍历。
- en: 'How does immutability help here? When using an immutable data structure, any
    change to an object''s properties results in a new object being created. For example,
    if we create an immutable object using a popular library, `Immutable.js`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性在这里是如何帮助的？当使用不可变数据结构时，对对象属性任何的更改都会导致创建一个新的对象。例如，如果我们使用流行的库`Immutable.js`创建不可变对象：
- en: '[PRE8]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Changes to either the `name` or `age` property of `personalInfo` create a new
    object:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`personalInfo`的`name`或`age`属性的变化会创建一个新的对象：'
- en: '[PRE9]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This immutability comes in handy if each of the employee model properties (`personal`,
    `professional`, `home`, and `work`) is immutable.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个员工模型属性（`personal`、`professional`、`home`和`work`）都是不可变的，这种不可变性将非常有用。
- en: 'Take, for instance, the `PersonalInfo` component definition that binds to personal
    info data:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以`PersonalInfo`组件定义为例，它绑定到个人信息数据：
- en: '[PRE10]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since the only thing `PersonalInfo` depends upon is the `model` property, and
    the `model` property binds to an immutable object, Angular only needs to do a
    check for changes if the `model` reference changes. Otherwise, the complete `PersonalInfo`
    component subtree can be skipped.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`PersonalInfo`仅依赖于`model`属性，且`model`属性绑定到一个不可变对象，因此Angular只有在`model`引用发生变化时才需要进行变更检查。否则，可以跳过完整的`PersonalInfo`组件子树。
- en: By setting the `PersonalInfo` component property `changeDetection` to `ChangeDetectionStrategy.OnPush`,
    we instruct Angular to trigger change detection only when the component's inputs
    change.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`PersonalInfo`组件的`changeDetection`属性设置为`ChangeDetectionStrategy.OnPush`，我们指示Angular仅在组件的输入属性发生变化时触发变更检测。
- en: 'If we change the change detection strategy to `OnPush` for each of the Employee
    component children and update the employee''s personal info, only the `PersonalInfo`
    component subtree is checked for changes:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将Employee组件子代中的每个组件的变更检测策略更改为`OnPush`并更新员工的个人信息，则只有`PersonalInfo`组件子树会检查变更：
- en: '![](img/00083.jpeg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00083.jpeg)'
- en: For a large component tree, such an optimization will improve the app/view performance
    many times over.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型组件树，这种优化将大大提高应用/视图性能。
- en: When set to `OnPush`, Angular triggers change detection only when the component's
    input property changes or there is an event raised inside the component or its
    children.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置为`OnPush`时，Angular仅在组件的输入属性发生变化或组件内部或其子代中引发事件时触发变更检测。
- en: Developing applications using immutable data structures departs from the standard
    development paradigm where the application state is totally mutable. What we have
    highlighted in this section is how Angular takes advantage of immutable data structures
    to optimize the change detection process.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不可变数据结构开发应用程序与完全可变的传统应用程序状态开发范式不同。本节中我们强调的是Angular如何利用不可变数据结构来优化变更检测过程。
- en: '*Observables* are another kind of data structure that can help us optimize
    Angular change detection.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**可观察对象**是另一种可以帮助我们优化Angular变更检测的数据结构。'
- en: Using Observables
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可观察对象
- en: '**Observables** are data structures that trigger events when their internal
    state changes. The Angular *eventing infrastructure* extensively uses *Observables*
    to communicate the components'' internal state to the outside world.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**可观察对象**是当其内部状态发生变化时触发事件的 数据结构。Angular广泛使用**可观察对象**来将组件的内部状态与外部世界进行通信。'
- en: While we have used Observable output properties (the `EventEmitter` class) to
    raise events, *input **properties* too can take Observables. Such observable inputs
    can help Angular optimize change detection.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们使用了可观察的输出属性（`EventEmitter`类）来触发事件，但输入**属性**也可以接受可观察对象。这种可观察的输入可以帮助Angular优化变更检测。
- en: When using observables, the change detection switch still remains `ChangeDetectionStrategy.OnPush`.
    But this time, only if a component input triggers an event (as they are observables)
    will Angular perform the dirty check. When the input triggers an event, the complete
    component tree path, starting from the affected component to the root, is marked
    for verification.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用可观察对象时，变更检测开关仍然保持为`ChangeDetectionStrategy.OnPush`。但这次，只有当组件输入触发事件（因为它们是可观察的）时，Angular才会执行脏检查。当输入触发事件时，从受影响的组件到根组件的完整组件树路径将被标记为待验证。
- en: When performing the view update, Angular will only sync the affected path and
    ignore the rest of the tree.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行视图更新时，Angular只会同步受影响的路径，并忽略树中的其余部分。
- en: Manual change detection
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动更改检测
- en: 'We can actually disable change detection on a component completely and trigger
    manual change detection when required. To disable change detection, we just need
    to inject the component-specific change detector (the `ChangeDetectorRef` class
    instance) into the component and call the `detach` function:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以完全禁用组件上的更改检测，并在需要时手动触发更改检测。要禁用更改检测，我们只需将特定于组件的更改检测器（`ChangeDetectorRef`类实例）注入到组件中，并调用`detach`函数：
- en: '[PRE11]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, the onus is on us to inform Angular when the component should be checked
    for changes.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，责任在我们身上，我们需要通知Angular何时应该检查组件的更改。
- en: We can reattach the component to the change detection tree by using the `reattach`
    function on `ChangeDetectorRef.`
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`ChangeDetectorRef`上使用`reattach`函数将组件重新附加到更改检测树。
- en: We seldom need to disable the standard change detector setup, unless there are
    situations where standard change detection becomes an expensive affair.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很少需要禁用标准更改检测设置，除非有情况使得标准更改检测变得代价高昂。
- en: Take, for example, a public chatroom app, which is receiving messages from thousands
    of people connected to it. If we constantly keep pulling the messages and refreshing
    the DOM, the app may become unresponsive. In such a scenario, we can disable change
    detection on parts of the chat app component tree and manually trigger change
    detection to update the UI at specific intervals.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个公共聊天室应用程序为例，它正在接收来自连接到它的数千人的消息。如果我们不断拉取消息并刷新DOM，应用程序可能会变得无响应。在这种情况下，我们可以禁用聊天应用程序组件树的部分更改检测，并手动在特定间隔触发更改检测以更新UI。
- en: While we have seen three ways to tweak change detection behavior, the good thing
    is that these are not exclusive. Parts of the component tree can use immutable
    data structures, parts can use Observables, parts can employ manual change detection,
    and the rest can still use the default change detection. And Angular will happily
    oblige!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经看到了三种调整更改检测行为的方法，但好事是这些方法并不是互斥的。组件树的部分可以使用不可变数据结构，部分可以使用Observables，部分可以采用手动更改检测，其余部分仍然可以使用默认的更改检测。Angular会欣然从命！
- en: Enough on change detection for now. We may never need it unless we are building
    some large views with a chatty UI. Such scenarios require us to squeeze every
    bit of performance out of the change detection system, and the system is ready
    for it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 关于更改检测就先说这么多。除非我们正在构建一些具有嘈杂UI的大型视图，否则我们可能永远不需要它。这些场景要求我们从更改检测系统中挤出每一分性能，系统已经为此做好了准备。
- en: 'Next, we will have a look at another common requirement that most apps invariably
    have: authenticating their users.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨大多数应用程序不可避免地具有的另一个常见要求：认证用户。
- en: Handling authentication and authorization
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理认证和授权
- en: Most, if not all, apps have a requirement to authenticate/authorize their users.
    We may argue that authentication and authorization are more of a server concern
    than a client one, and that is correct. Still, the client side needs to adapt
    and integrate with the authentication and authorization requirement imposed by
    the server.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数，如果不是所有应用程序，都有对用户进行认证/授权的要求。我们可能会认为认证和授权更多地是服务器的问题，而不是客户端的问题，这是正确的。尽管如此，客户端仍需要适应并与服务器强加的认证和授权要求集成。
- en: In a typical app execution workflow, the app first loads some partial views
    then makes calls to pull data from the server, and finally binds data to its view.
    Clearly, *the views* and *the remote data API* are two assets that need to be
    secured.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的应用程序执行工作流程中，应用程序首先加载一些部分视图，然后调用服务器以获取数据，最后将数据绑定到其视图上。显然，*视图*和*远程数据API*是两种需要被保护的资源。
- en: 'To guard these resources, we need to understand how a typical application is
    secured on the server. There are primarily two broad approaches to securing any
    web applications: *cookie-based authentication* and *token-based authentication*.
    Each of them requires different handling on the client part. The next two sections
    describe how we can integrate with either of these approaches.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护这些资源，我们需要了解典型应用程序在服务器上的安全保护方式。主要有两种广泛的方法来保护任何Web应用程序：*基于cookie的认证*和*基于令牌的认证*。每种方法在客户端部分都需要不同的处理。接下来的两个部分将描述我们如何集成这两种方法之一。
- en: Cookie-based authentication
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于cookie的认证
- en: 'This authentication mechanism is the easiest to implement if the server stack
    supports it. It''s non-intrusive and may require bare minimum changes to the Angular
    application. **Cookie-based authentication** involves setting the browser cookie
    to track the user authentication session. The following sequence diagram explains
    a typical cookie-based authentication workflow:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器堆栈支持它，这种身份验证机制是最容易实现的。它不会干扰应用，并且可能只需要对 Angular 应用进行最小程度的修改。**基于 Cookie
    的身份验证**涉及设置浏览器 Cookie 以跟踪用户身份验证会话。以下序列图解释了一个典型的基于 Cookie 的身份验证工作流程：
- en: '![](img/00084.jpeg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00084.jpeg)'
- en: 'Here is how a typical authentication workflow works:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个典型的身份验证工作流程是如何工作的：
- en: When trying to access a secured resource from the browser, if the user is not
    authenticated, the server sends an HTTP 401 Unauthorized status code. A user request
    is an unauthorized request if there is no cookie attached to the request or the
    cookie is expired/invalid.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当尝试从浏览器访问受保护资源时，如果用户未认证，服务器会发送 HTTP 401 未授权状态码。如果请求中没有附加 Cookie 或 Cookie 已过期/无效，则用户请求是一个未经授权的请求。
- en: This unauthorized response is intercepted by the server or, at times, by the
    client framework (Angular in our case) and it typically results in a 302 redirect
    (if intercepted by the server). The redirect location is the URL to the login
    page (the login page allows anonymous access).
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种未经授权的响应被服务器拦截，有时甚至被客户端框架（在我们的案例中是 Angular）拦截，通常会导致 302 重定向（如果由服务器拦截）。重定向位置是登录页面的
    URL（登录页面允许匿名访问）。
- en: The user then enters the username and password on the login page and does a
    POST to the login endpoint.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，用户在登录页面上输入用户名和密码，并对登录端点进行 POST 请求。
- en: The server validates the credentials, sets a browser cookie, and redirects the
    user to the originally requested resource.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器验证凭据，设置浏览器 Cookie，并将用户重定向到最初请求的资源。
- en: Henceforth, the authentication cookie is a part of every request (added by the
    browser automatically), and the server uses this cookie to confirm his identity
    and whether the user is authenticated.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从此以后，身份验证 Cookie 成为每个请求的一部分（由浏览器自动添加），服务器使用此 Cookie 来确认其身份以及用户是否已认证。
- en: As we can see, with this approach, the Angular infrastructure is not involved,
    or the involvement is minimal. Even the login page can be a standard HTML page
    that just sends data to the login endpoint for authentication. If the user lands
    on the Angular app, it implicitly means that the user has been authenticated.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，使用这种方法，Angular 基础设施不参与，或者参与度很小。甚至登录页面也可以是一个标准的 HTML 页面，它只是将数据发送到登录端点进行身份验证。如果用户进入
    Angular 应用，这隐含地意味着用户已经通过认证。
- en: The cookie-based authentication flow may vary depending on the server framework,
    but the general pattern of setting a cookie and attaching a cookie with every
    subsequent request remains the same.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Cookie 的身份验证流程可能因服务器框架而异，但设置 Cookie 并在随后的每个请求中附加 Cookie 的一般模式保持不变。
- en: In a cookie-based application authentication, if the application wants to get
    the user context, a server endpoint (such as `/user/details`) is exposed that
    returns the logged in user's specific data. The client application can then implement
    a service such as `UserService` that loads and caches the user profile data.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Cookie 的应用程序身份验证中，如果应用程序想要获取用户上下文，则会暴露一个服务器端点（例如 `/user/details`），该端点返回已登录用户的特定数据。然后客户端应用程序可以实现一个服务，如
    `UserService`，用于加载和缓存用户配置文件数据。
- en: The scenario described here assumes that the API server (the server that returns
    data) and the site where the application is hosted are in a single domain. That
    may not always be the case. Even for *Personal Trainer*, the data resides on the
    *MongoLab* servers and the application resides on a different server (even if
    it is local). And we already know that this is a cross-domain access and it comes
    with its own set of challenges.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的场景假设 API 服务器（返回数据的服务器）和应用程序托管网站位于单个域中。这并不总是情况。即使是 *Personal Trainer*，数据也驻留在
    *MongoLab* 服务器上，而应用程序驻留在不同的服务器上（即使它是本地的）。我们已经知道这是一个跨域访问，并且它带来了一组自己的挑战。
- en: In such a setup, even if the API server is able to authenticate the request
    and send a cookie back to the client, the client application still does not send
    the authentication cookie on a subsequent request.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种设置中，即使 API 服务器能够认证请求并将 Cookie 发送回客户端，客户端应用程序在随后的请求中仍然不会发送身份验证 Cookie。
- en: To fix this, we need to set a variable, `withCredentials`, to `true` on each
    XHR request. This can be enabled at the global level by overriding `BaseRequestOptions`
    (the `withCredentials` property). The framework uses the `BaseRequestOptions`
    class to set the default values for every HTTP request.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要在每个XHR请求中将变量`withCredentials`设置为`true`。这可以通过覆盖`BaseRequestOptions`（`withCredentials`属性）在全局级别启用。框架使用`BaseRequestOptions`类为每个HTTP请求设置默认值。
- en: 'This can also be enabled on a per-request level by passing in the `withCredentials:true`
    flag in each HTTP request method as the last parameter:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以通过在每个HTTP请求方法中将`withCredentials:true`标志作为最后一个参数传递到每个请求级别来启用：
- en: '[PRE12]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The last parameter to every HTTP function, including `get`, `post`, and `put`,
    is an options object. This allows us to override the options for the request being
    made.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HTTP函数的最后一个参数，包括`get`、`post`和`put`，都是一个选项对象。这允许我们覆盖正在进行的请求的选项。
- en: Once this flag is enabled, the client browser will start attaching the authentication
    cookie for the cross-domain requests.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用此标志，客户端浏览器将开始为跨域请求附加认证Cookie。
- en: The server too needs to have **cross-origin resource sharing** (**CORS**) enabled
    and needs to respond in a specific manner for the request to succeed. It should
    set the **access-control-allow-credentials** header to true and the **access-control-allow-origin**
    header to the host site making the request.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器也需要启用**跨源资源共享**（**CORS**），并且需要以特定的方式响应才能使请求成功。它应该将**access-control-allow-credentials**头部设置为true，并将**access-control-allow-origin**头部设置为发出请求的主机站点。
- en: Check out the MDN documentation ([http://bit.ly/http-cors](http://bit.ly/http-cors))
    to learn about this scenario in detail.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 查看MDN文档（[http://bit.ly/http-cors](http://bit.ly/http-cors)）以详细了解此场景。
- en: 'Cookie-based authentication is definitely less work on the client side, but
    there are times when you have to revert to token-based access. This could be because:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Cookie的认证在客户端确实减少了工作量，但有时您不得不回退到基于令牌的访问。这可能是因为：
- en: Cookies and cross-domain requests do not play nicely across browsers. Specifically,
    IE8 and IE9 do not support them.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cookie和跨域请求在浏览器中表现不佳。特别是，IE8和IE9不支持它们。
- en: The server may not support generating cookies, or the server only exposes token-based
    authentication.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器可能不支持生成Cookie，或者服务器只公开基于令牌的认证。
- en: Token-based solutions are easy to integrate with a native mobile application
    and desktop clients.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于令牌的解决方案很容易与原生移动应用程序和桌面客户端集成。
- en: Tokens are not susceptible to cross-site request forgery (CSRF) attacks.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令牌不易受到跨站请求伪造（CSRF）攻击。
- en: To know more about CSRF, look at the CRSF Prevention cheat sheet at [http://bit.ly/csrf-cs](http://bit.ly/csrf-cs).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于CSRF的信息，请查看[http://bit.ly/csrf-cs](http://bit.ly/csrf-cs)的CRSF预防cheat
    sheet。
- en: The next section talks about supporting token-based authentication.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论支持基于令牌的认证。
- en: Token-based authentication
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于令牌的认证
- en: '**Token-based access** is all about sending a token (typically in HTTP headers)
    with each request instead of a cookie. A simplified token-based workflow looks
    something like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于令牌的访问**完全是关于在每个请求中发送一个令牌（通常在HTTP头部），而不是一个Cookie。简化的基于令牌的工作流程看起来大致如下：'
- en: '![](img/00085.jpeg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00085.jpeg)'
- en: Many public APIs (such as *Facebook* and *Twitter*) use token-based authentication.
    The format of the token, where it goes, and how it is generated depends on the
    protocol used and the server implementation. Popular services that use token-based
    authentication implement the **OAuth 2.0** protocol for token generation and exchange.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 许多公共API（如*Facebook*和*Twitter*）使用基于令牌的认证。令牌的格式、位置以及如何生成取决于所使用的协议和服务器实现。使用基于令牌的认证的流行服务实现了用于令牌生成和交换的**OAuth
    2.0**协议。
- en: In a typical token-based authentication setup, the views are available publicly
    but the API is secured. If the application tries to pull data through API calls
    without attaching the appropriate token to the outgoing request, the server returns
    an *HTTP 401 Unauthorized* status code.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的基于令牌的认证设置中，视图是公开的，但API是受保护的。如果应用程序尝试通过不将适当的令牌附加到发出的请求的API调用来获取数据，服务器将返回一个*HTTP
    401未授权*状态码。
- en: Enabling token authentication is a good amount of work in Angular. It involves
    setting up a login page/component, guard conditions, authentication service, and
    authentication context shared across the application.  If you embark on this journey,
    make sure to look for Angular libraries/module that makes this integration easier.
    The `ngx-auth` library ([http://bit.ly/ngx-auth](http://bit.ly/ngx-auth)) can
    be a good starting point.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中启用token认证是一项相当多的工作。它包括设置登录页面/组件、守卫条件、认证服务和跨应用共享的认证上下文。如果你开始这段旅程，确保寻找使这种集成更简单的Angular库/模块。`ngx-auth`库（[http://bit.ly/ngx-auth](http://bit.ly/ngx-auth)）可以是一个好的起点。
- en: That's all about authentication, but what about authorization? Once the user
    context is established, we still need to make sure that the user is only able
    to access parts that he/she is allowed to. *Authorization* is still missing.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于认证的所有内容，但关于授权呢？一旦建立了用户上下文，我们仍然需要确保用户只能访问他/她被允许访问的部分。*授权*仍然缺失。
- en: Handling authorization
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理授权
- en: Like authentication, authorization support too needs to be implemented on both
    the server and client side, more so on the server than the client. Remember, anyone
    can hack into the JavaScript code and circumvent the complete authentication/authorization
    setup. So, always tighten your server infrastructure irrespective of whether the
    client has the necessary checks in place or not.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 与认证一样，授权支持也需要在服务器和客户端上实现，尤其是在服务器端。记住，任何人都可以破解JavaScript代码并绕过完整的认证/授权设置。所以，无论客户端是否设置了必要的检查，都要始终加强你的服务器基础设施。
- en: This still does not mean that we do not do any authorization checks on the client.
    For standard users, this is the first line of defense against unwarranted access.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着我们在客户端不做任何授权检查。对于标准用户来说，这是防止未经授权访问的第一道防线。
- en: 'When working on an authorization requirement for any application, there are
    three essential elements that are part of the setup:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在为任何应用程序设置授权需求时，有三个基本元素是设置的一部分：
- en: The resources that need to be secured/authorized
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要受到保护/授权的资源
- en: A list of roles and users that are part of these roles
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属于这些角色的角色和用户列表
- en: A mapping between the resources and the roles that define who can access what
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源与定义谁可以访问什么的角色之间的映射
- en: From an Angular app perspective, the resources are the pages and, sometimes,
    sections of pages that need to be restricted to specific roles. If the user is
    in a specific role, depending upon the role-resource mapping, they get access
    to some pages; otherwise, they are denied access.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 从Angular应用程序的角度来看，资源是需要限制到特定角色的页面和，有时，页面的部分。如果用户属于特定角色，根据角色-资源映射，他们可以访问某些页面；否则，他们将无法访问。
- en: While authorization in an Angular application can be implemented in a number
    of ways, we will outline a generic implementation that can be further customized
    to suit your needs in the future.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在Angular应用程序中授权可以通过多种方式实现，但我们将概述一个通用的实现，该实现可以进一步定制以满足未来的需求。
- en: Adding authorization support
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加授权支持
- en: To enable authorization, the first thing that we need to do is expose the logged
    in user data, including his/her roles, throughout the application.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用授权，我们首先需要做的是在整个应用程序中公开登录用户数据，包括他的/她的角色。
- en: Sharing user authentication context
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享用户认证上下文
- en: 'User context can be shared using an Angular service, which can then be injected
    into components that require the authorization context. Look at this service interface:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Angular服务共享用户上下文，然后可以将该服务注入到需要授权上下文的组件中。看看这个服务接口：
- en: '[PRE13]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `SessionContext` service tracks the user login session and provides details
    such as:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`SessionContext`服务跟踪用户登录会话并提供如下详细信息：'
- en: The logged in user (`currentUser`)
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录用户（`currentUser`）
- en: Whether the user is authenticated (`isAuthenticated`)
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户是否已认证（`isAuthenticated`）
- en: The `isUserInRole` function, which returns `true` or `false` based on whether
    the user is part of any of the roles passed into the `roles` parameter
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isUserInRole`函数，根据用户是否是传递给`roles`参数的任何角色的成员，返回`true`或`false`'
- en: With such a service in place, we can add authorization for routes, thereby restricting
    access to some routes to specific roles only.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的服务到位后，我们可以为路由添加授权，从而仅将某些路由的访问限制到特定角色。
- en: Restricting routes
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制路由
- en: 'Like authentication, the `canActivate` guard check can also be used for authorization.
    Implement a class with the `CanActivate` interface and inject the `SessionContext`
    service into the constructor; then, check whether the user belongs to a specific
    role in the `canActivate` function using the `SessionContext` service. Check out
    the following code snippet:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 就像认证一样，`canActivate`守卫检查也可以用于授权。实现一个具有`CanActivate`接口的类，并在构造函数中注入`SessionContext`服务；然后，使用`SessionContext`服务在`canActivate`函数中检查用户是否属于特定角色。查看以下代码片段：
- en: '[PRE14]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Only users with roles of *Contributor* and *Admin* now have access to routes
    that have this guard condition.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只有具有*贡献者*和*管理员*角色的用户才能访问具有此守卫条件的路由。
- en: But what happens when a page has view elements that are rendered based on the
    user's role?
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 但当页面有基于用户角色的渲染视图元素时会发生什么？
- en: Conditionally rendering content based on roles
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据角色条件渲染内容
- en: 'Conditionally rendering content is easy to implement. We just need to show/hide
    HTML elements based on the user role. We can build a *structural directive* such
    as `ng-if` that can verify that the user belongs to a role before rendering the
    content. The directive''s usage looks like:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 条件渲染内容易于实现。我们只需根据用户角色显示/隐藏HTML元素。我们可以构建一个如`ng-if`这样的*结构指令*，在渲染内容之前验证用户是否属于该角色。指令的使用方式如下：
- en: '[PRE15]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code checks whether the user is in an admin role before rendering
    a Site Setting hyperlink.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在渲染网站设置超链接之前检查用户是否处于管理员角色。
- en: 'The directive implementation mimics how `ng-if` works, except that our show/hide
    logic depends upon the `SessionContext` service. Here is a sample implementation
    for the `a2beRolesAllowed` directive:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 指令实现模仿了`ng-if`的工作方式，但我们的显示/隐藏逻辑依赖于`SessionContext`服务。以下是`a2beRolesAllowed`指令的一个示例实现：
- en: '[PRE16]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is a trivial implementation that uses `SessionContext` and the roles passed
    as input (`a2beRolesAllowed`) to show/hide a fragment.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`SessionContext`和作为输入传递的角色（`a2beRolesAllowed`）来显示/隐藏片段的简单实现。
- en: This brings us to the end of authentication and authorization implementation.
    The reference implementation walkthrough should help us build authentication and
    authorization into our apps. With this basic understanding in place, any setup
    can be tweaked to handle other custom authentication/authorization scenarios.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们来到了认证和授权实现的终点。参考实现指南应该能帮助我们将认证和授权集成到我们的应用中。有了这个基本理解，任何设置都可以进行调整以处理其他自定义认证/授权场景。
- en: 'It''s now time to address the elephant in the room: migrating from *AngularJS*
    to *Angular*. If you are starting afresh on Angular, you can very well skip the
    next section.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候解决房间里的大象了：从*AngularJS*迁移到*Angular*。如果你是全新开始使用Angular，你可以很好地跳过下一节。
- en: From the Angular's migration guide *"Angular is the name for the Angular of
    today and tomorrow. AngularJS is the name for all v1.x versions of Angular.*"
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 从Angular的迁移指南中可以看出："Angular是今天和明天的Angular。AngularJS是所有v1.x版本的Angular的名称。"
- en: Migrating AngularJS apps
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移AngularJS应用
- en: 'If you have been working extensively on AngularJS, Angular poses some pertinent
    questions:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在大量使用AngularJS，Angular会提出一些相关的问题：
- en: Should I migrate my old AngularJS apps to the latest Angular version?
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该将我的旧AngularJS应用迁移到最新的Angular版本吗？
- en: When should the migration happen?
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移应该在什么时候进行？
- en: Is the migration one-shot or can it be done in an incremental fashion?
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移是一次性的还是可以分步骤进行？
- en: What is the effort involved?
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要付出的努力有哪些？
- en: Can I do something today that helps with the migration in the future?
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我今天能做些什么来帮助未来的迁移？
- en: I am starting a new AngularJS app today. What should I do to make the migration
    seamless in the future?
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我今天开始一个新的AngularJS应用。为了将来迁移顺利，我应该做什么？
- en: Every such query needs to be addressed to make sure the transition is as smooth
    as possible. No one likes surprises later in the game! In the coming sections,
    we will try to answer a number of such questions. As part of the learning, we
    will also walk you through migrating the AngularJS version of the *Trainer* app
    (developed for the first version of this book) to Angular. This will help everyone
    make some informed decisions on when and how to migrate to Angular.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这样的查询都需要得到解决，以确保过渡尽可能平滑。没有人喜欢在游戏中出现意外！在接下来的章节中，我们将尝试回答许多此类问题。作为学习的一部分，我们还将向您展示如何将（为本书的第一版开发的）*Trainer*应用的AngularJS版本迁移到Angular。这将帮助每个人在何时以及如何迁移到Angular方面做出一些明智的决定。
- en: '"Should I migrate or not" is something that we will address first.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: “我应该迁移还是不迁移”是我们首先需要解决的问题。
- en: Should I migrate?
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我应该迁移吗？
- en: Just because Angular is here doesn't mean AngularJS is gone. AngularJS is still
    being developed, albeit not at the same pace as Angular. Google is still committed
    to supporting AngularJS for a good amount of time. The AngularJS team is working
    on version 1.7 currently and plan to release it before June 2018\. After that,
    1.7 will enter the **Long Term Support** (**LTS**) period, where the focus will
    only be on bug fixes.  We can learn more about it from their blog post at [http://bit.ly/ng1-lte-support](http://bit.ly/ng1-lte-support).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 只因 Angular 存在并不意味着 AngularJS 已经消失。AngularJS 仍在开发中，尽管其速度不如 Angular。Google 仍然承诺在相当长的时间内支持
    AngularJS。AngularJS 团队目前正在开发 1.7 版本，并计划在 2018 年 6 月之前发布。之后，1.7 将进入 **长期支持**（**LTS**）期，届时重点将仅限于修复错误。我们可以从他们的博客文章中了解更多信息，请参阅[http://bit.ly/ng1-lte-support](http://bit.ly/ng1-lte-support)。
- en: Clearly, AngularJS will continue to be supported and hence should not be a major
    concern for migration. The move to Angular can be decided based on what Angular
    has to offer over its predecessor.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，AngularJS 将继续得到支持，因此迁移不应成为主要担忧。迁移到 Angular 的决定可以根据 Angular 相比前辈所提供的优势来做出。
- en: Advantages of Angular
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 的优势
- en: Angular is designed for the future and overcomes a number of shortcomings in
    its predecessor. In this section, we emphasize what makes Angular a better framework
    than AngularJS.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 是面向未来的，并克服了其前辈的许多缺点。在本节中，我们强调是什么让 Angular 比 AngularJS 成为一个更好的框架。
- en: 'Things you should be aware of while making a decision to move to Angular:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定迁移到 Angular 时，您应该注意的事项：
- en: '**Better behavioral encapsulation**: Admittedly, while AngularJS *scopes* seem
    to be god sent when we started learning AngularJS, we have now realized how difficult
    it is to manage the hierarchical nature of scopes. Component-based development
    in Angular provides a better encapsulation in terms of the state of the application.
    A component manages its own state, takes input, and raises events; a clear demarcation
    of responsibilities that are easy to reason with!'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的行为封装**：诚然，当我们刚开始学习 AngularJS 时，AngularJS 的 *scopes* 似乎是从天而降的神物，但我们现在已经意识到管理
    scopes 层级性质是多么困难。基于组件的开发在 Angular 中提供了更好的应用状态封装。组件管理自己的状态，接收输入，并触发事件；这是一个责任划分清晰、易于推理的明确界限！'
- en: '**Less of the framework in app code**: You don''t need special objects such
    as a *scope.* DI works with annotation (in TypeScript). You don''t set up watches.
    All in all, when reading a component code, you will not find framework-level constructs
    in it.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用代码中框架的减少**：您不需要像 *scope* 这样的特殊对象。依赖注入（DI）与注解（在 TypeScript 中）一起工作。您不需要设置观察者。总的来说，当阅读组件代码时，您不会在其中找到框架级别的结构。'
- en: '**Smaller framework API to explore**: AngularJS had a host of directives that
    one had to be aware of. With Angular template syntax, directives related to browser
    events are gone. This reduces the number of directives that one needs to be aware
    of.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更小的框架 API 需要探索**：AngularJS 有许多指令需要了解。随着 Angular 模板语法的引入，与浏览器事件相关的指令已经消失。这减少了需要了解的指令数量。'
- en: '**Performance**: Angular is faster compared to its predecessor. A complete
    section of this book was dedicated to understanding what makes Angular a high-performance
    framework.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：与前辈相比，Angular 的性能更快。本书的一个完整章节都致力于理解是什么让 Angular 成为一个高性能框架。'
- en: '**Mobile-friendly**: Angular tries to optimize the user''s mobile experience
    by utilizing technologies such as server-side rendering and web workers. Angular
    applications on mobile are more performant that those of its predecessor.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动友好**：Angular 通过利用服务器端渲染和 Web Workers 等技术来优化用户的移动体验。Angular 在移动设备上的应用程序性能优于其前辈。'
- en: '**Cross-platform**: Angular targets running on most devices and across platforms.
    You can use Angular to build applications for web and mobile. As we learned earlier,
    the separation of the rendering layer has open up a great number of possibilities
    in terms of where Angular can be utilized.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台**：Angular 面向在大多数设备和平台上运行。您可以使用 Angular 来构建 Web 和移动应用程序。正如我们之前所学的，渲染层的分离为
    Angular 可以被利用的地方开辟了大量的可能性。'
- en: In a true sense, Angular supersedes its predecessor, and in a perfect world,
    everyone should be working on a better framework/technology. But migration is
    never easy, especially in this case, where the two frameworks differ a lot.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在真正意义上，Angular 取代了其前辈，在理想的世界里，每个人都应该致力于更好的框架/技术。但迁移从来都不容易，尤其是在这种两个框架差异很大的情况下。
- en: What we recommend is even if you do not plan to migrate to Angular today, build
    your AngularJS apps in ways that allow easy migration to Angular in future.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推荐的是，即使你今天不打算迁移到Angular，也要以允许将来易于迁移到Angular的方式构建你的AngularJS应用。
- en: The next section talks about the principles and practices to follow for AngularJS
    today, allowing easy migration in the future.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论今天应遵循的原则和实践，以便将来易于迁移。
- en: Developing AngularJS apps today for easy migration
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为了便于迁移而开发AngularJS应用
- en: The new Angular is a paradigm shift and the way we develop components in Angular
    is quite different from AngularJS. For easy migration, Angular too should embrace
    component-based development. This can be achieved if we follow some guidelines/principles
    while building AngularJS apps. The next few sections detail these guidelines.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 新的Angular是一个范式转变，我们在Angular中开发组件的方式与AngularJS大不相同。为了便于迁移，Angular也应该采用基于组件的开发方式。如果我们遵循一些在构建AngularJS应用时的指南/原则，就可以实现这一点。接下来的几节将详细说明这些指南。
- en: The advice listed here is highly recommended even if you do not plan to migrate
    to Angular. These recommendation bits will make AngularJS code more modular, organized,
    and testable.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你计划不迁移到Angular，这里列出的建议也非常推荐。这些推荐将使AngularJS代码更加模块化、组织化，并且易于测试。
- en: One component per file
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个文件一个组件
- en: 'This can be anything: an AngularJS *controller*, *directive*, *filter*, or
    *service*. One component per file allows better organization of code and easy
    migration, allowing us to clearly identify how much progress has been made.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是任何东西：AngularJS的*控制器*、*指令*、*过滤器*或*服务*。每个文件一个组件允许更好的代码组织，并便于迁移，使我们能够清楚地识别已经取得了多少进展。
- en: Avoiding inline anonymous functions
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用内联匿名函数
- en: 'Use named functions instead to declare controllers, directives, filters, and
    services. A declaration such as this:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名函数来声明控制器、指令、过滤器和服务。如下所示的一个声明：
- en: '[PRE17]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Should be converted to this:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 应该转换为以下形式：
- en: '[PRE18]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The advantages of using named functions are ease of debugging and ease of migration
    to TypeScript. Using named functions also requires that the dependencies be registered
    using the `$inject` function property.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名函数的优点是易于调试和易于迁移到TypeScript。使用命名函数还要求使用`$inject`函数属性注册依赖。
- en: '`$inject`-based dependency declaration safeguards against minification and
    adds to the readability of the functions.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 基于`$inject`的依赖声明可以防止压缩并增加函数的可读性。
- en: 'To avoid exposing global name functions with this approach, it is advisable
    to wrap the function in an **Immediately Invoked Function Expression** (**IIFE**):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免使用这种方法暴露全局命名函数，建议将函数包裹在一个**立即调用的函数表达式**（**IIFE**）中：
- en: '[PRE19]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Avoiding $scope!
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用`$scope`！
- en: Yes, you read it right; avoid the `$scope`/`$rootScope` object or using scopes
    directly!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你没看错；避免使用`$scope`/`$rootScope`对象或直接使用作用域！
- en: The biggest problem with AngularJS scopes is their hierarchical nature. Accessing
    the parent scope from the child scope gives us tremendous flexibility, but it
    comes at a cost. This can unknowingly create unwarranted dependencies that make
    the app really hard to debug and, of course, migrate. In contrast, in Angular,
    a view is bound to its component implementation and cannot access data outside
    its boundary implicitly. Therefore, if you plan to migrate to Angular, *avoid
    scopes at all costs*.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS作用域的最大问题是它们的层次结构。从子作用域访问父作用域为我们提供了巨大的灵活性，但这也带来了代价。这可能会无意中创建不必要的依赖，使得应用难以调试和迁移。相比之下，在Angular中，视图绑定到其组件实现，并且不能隐式地访问其边界之外的数据。因此，如果你计划迁移到Angular，请务必*避免使用作用域*。
- en: There are a number of techniques that can be used to remove the `$scope` object
    dependency. The next few subsections elaborate on some techniques that can help
    us avoid AngularJS scopes.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多技术可以用来移除对`$scope`对象的依赖。接下来的几小节将详细阐述一些可以帮助我们避免AngularJS作用域的技术。
- en: Using controller as (controller aliasing) syntax everywhere
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在所有地方使用控制器作为（控制器别名）语法
- en: AngularJS 1.3+ has the *controller as* syntax for *controllers*, *directives*,
    and *routes*. *controller as* syntax allows AngularJS data binding expressions
    to work against a controller's instance properties instead of the current *scope*'s
    object properties. With the controller as paradigm in place, we never need to
    interact with the scope directly, and hence future migration becomes easy.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 1.3+提供了*控制器as*语法，用于*控制器*、*指令*和*路由*。*控制器as*语法允许AngularJS数据绑定表达式针对控制器实例属性而不是当前*作用域*的对象属性进行操作。在控制器as范式下，我们无需直接与作用域交互，因此未来的迁移变得容易。
- en: While controller aliasing gets rid of scope access, scopes are still there in
    AngularJS. The complete AngularJS data binding infrastructure depends upon scopes.
    Controller aliasing just puts an indirection between our code and scope access.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然控制器别名消除了作用域访问，但在AngularJS中作用域仍然存在。完整的AngularJS数据绑定基础设施依赖于作用域。控制器别名只是在我们的代码和作用域访问之间添加了一个间接层。
- en: 'Consider the following syntax for *controller as* in views:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下语法在视图中使用*控制器as*：
- en: '[PRE20]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And the corresponding controller implementation:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 以及相应的控制器实现：
- en: '[PRE21]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`WorkoutListController` as `workoutList` creates an alias `workoutList` for
    `WorkoutListController` on the current scope, hence allowing us to bind to the
    `workouts` property defined on the controller.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutListController`作为`workoutList`在当前作用域上为`WorkoutListController`创建了一个别名`workoutList`，因此允许我们绑定到控制器上定义的`workouts`属性。'
- en: 'Route definition too allows controller aliasing using the `controllerAs` property
    in a *route definition object*:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 路由定义同样允许使用*路由定义对象*中的`controllerAs`属性进行控制器别名设置：
- en: '[PRE22]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Finally, directives too can use `controllerAs`, and together with the `bindToController`
    property on the *directive definition object*, we can get rid of any direct scope
    access.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，指令也可以使用`controllerAs`，结合*指令定义对象*上的`bindToController`属性，我们可以消除任何直接的作用域访问。
- en: 'Look at the Angular documentation on controllers, routes, and directives to
    get a basic understanding of the controller as syntax. Also, look at the following
    posts for some more detailed samples on this topic: [http://bit.ly/ng1-controller-as](http://bit.ly/ng1-controller-as) and [http://bit.ly/ng1-bind-to](http://bit.ly/ng1-bind-to).'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Angular文档中的控制器、路由和指令部分，以获得对控制器as语法的初步理解。同时，查看以下帖子以获取更多关于此主题的详细示例：[http://bit.ly/ng1-controller-as](http://bit.ly/ng1-controller-as)
    和 [http://bit.ly/ng1-bind-to](http://bit.ly/ng1-bind-to)。
- en: Avoiding ng-controller
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用ng-controller
- en: If scopes can be avoided, so can controllers!
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以避免作用域，那么也可以避免控制器！
- en: This may again seem counterintuitive, but the approach has real benefits. What
    we ideally want to do is emulate component behavior in AngularJS. Since the closest
    thing to components in AngularJS is *element directives* (with `restrict='E'`),
    we should utilize *element directives* everywhere.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有些反直觉，但这种方法确实有实际的好处。我们理想的做法是在AngularJS中模拟组件行为。由于AngularJS中最接近组件的是*元素指令*（具有`restrict='E'`），我们应该在所有地方使用*元素指令*。
- en: An AngularJS element directive with its own template and isolated scope can
    very well behave like an Angular component and only be dependent on its internal
    state for its view binding. We just don't need `ng-controller`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有自己的模板和独立作用域的AngularJS元素指令可以很好地表现得像一个Angular组件，并且只依赖于其内部状态进行视图绑定。我们只需要`ng-controller`。
- en: 'Consider the use of `ng-controller` for audio tracking from the AngularJS version
    of the *Personal Trainer* app:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在*个人教练*应用的AngularJS版本中使用`ng-controller`进行音频跟踪：
- en: '[PRE23]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Instead of using `WorkoutAudioController`, an element directive can encapsulate
    the workout audio''s view and behavior. Such a directive can then replace the
    complete `ng-controller` declaration and its view:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用`WorkoutAudioController`，一个元素指令可以封装锻炼音频的视图和行为。这样的指令可以替换完整的`ng-controller`声明及其视图：
- en: '[PRE24]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When replacing `ng-controller` with an element directive, the scope variables
    that the controller depends upon should be passed to the directive using the `bindToController`
    property on the *directive definition object—*something like this:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当用元素指令替换`ng-controller`时，控制器所依赖的作用域变量应通过*指令定义对象*上的`bindToController`属性传递给指令——类似于以下这样：
- en: '[PRE25]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This topic has been extensively covered in these two blogs posts by Tero: [http://bit.ly/ng2-no-controllers](http://bit.ly/ng2-no-controllers)
    and [http://bit.ly/ng2-refactor-to-component](http://bit.ly/ng2-refactor-to-component).
    Must-read posts with a wealth of information!'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题在Tero的以下两篇博客文章中得到了广泛讨论：[http://bit.ly/ng2-no-controllers](http://bit.ly/ng2-no-controllers)
    和 [http://bit.ly/ng2-refactor-to-component](http://bit.ly/ng2-refactor-to-component)。必读的帖子，信息量丰富！
- en: Building using the AngularJS 1.5+ component API
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AngularJS 1.5+ 组件 API 构建
- en: AngularJS 1.5+ has a **component API** that allows us to create directives that
    can be easily migrated to Angular. The component API is preconfigured with sensible
    defaults, hence incorporating the best practices when it comes to building truly
    isolated and reusable directives.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 1.5+ 有一个 **组件 API**，允许我们创建可以轻松迁移到 Angular 的指令。组件 API 预配置了合理的默认值，因此在构建真正隔离和可重用的指令时，它包含了最佳实践。
- en: Look at the component API at [http://bit.ly/ng1-dev-guide-components](http://bit.ly/ng1-dev-guide-components) and
    this informative post by Tod Motto at [http://bit.ly/1MahwNs](http://bit.ly/1MahwNs) to
    learn about the component API.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 查看组件 API 在 [http://bit.ly/ng1-dev-guide-components](http://bit.ly/ng1-dev-guide-components)，以及
    Tod Motto 在 [http://bit.ly/1MahwNs](http://bit.ly/1MahwNs) 发表的这篇信息丰富的帖子，以了解组件
    API。
- en: To reiterate what has been emphasized earlier, these steps are not just targeted
    towards easy Angular migration but also towards making AngularJS code better.
    Component-based UI development is a better paradigm than what we are used to with
    AngularJS.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调之前已经强调过的，这些步骤不仅针对简单的 Angular 迁移，而且也针对使 AngularJS 代码更加优秀。基于组件的 UI 开发比我们习惯的
    AngularJS 更好的范式。
- en: We highly recommend that you go through the AngularJS style guide ([http://bit.ly/ng1-style-guide](http://bit.ly/ng1-style-guide)).
    This guide contains a wealth of tips/patterns that allow us to build better AngularJS
    apps, and is in sync with the guidelines provided previously for easy Angular
    migration.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议您阅读 AngularJS 风格指南（[http://bit.ly/ng1-style-guide](http://bit.ly/ng1-style-guide)）。这份指南包含了许多技巧/模式，使我们能够构建更好的
    AngularJS 应用程序，并且与之前提供的易于 Angular 迁移的指南保持一致。
- en: Finally, if we have decided to migrate, it's time to decide what to migrate.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们已经决定迁移，那么是时候决定要迁移什么了。
- en: What to migrate?
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要迁移什么？
- en: For an app in maintenance mode, where most of the development activity revolves
    around bug fixes and some enhancements, it would be prudent to stick to AngularJS.
    Remember the old saying *if it ain't broke, don't fix it*.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处于维护模式的应用程序，其中大部分开发活动都围绕着错误修复和一些增强，坚持使用 AngularJS 是明智的。记住那句老话：*如果它没有坏，就不要修理它*。
- en: If the app is being actively developed and has a clear long-term roadmap, migrating
    to Angular is worth considering. As we dig deeper into the intricacies of migration,
    we will realize the time and effort involved in the process. While the Angular
    team has worked really hard to make this migration smooth, by no stretch of the
    imagination is this a trivial job. It is going to take a good amount of time and
    effort to perform the actual migration.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序正在积极开发，并且有一个明确的长期路线图，那么考虑迁移到 Angular 是值得的。随着我们深入了解迁移的复杂性，我们将意识到这个过程所涉及的时间和精力。虽然
    Angular 团队已经非常努力地使这次迁移变得顺利，但无论如何想象，这都不是一个简单的工作。实际的迁移将需要相当多的时间和精力。
- en: The silver lining here is that we do not need to migrate everything at once.
    We can work slowly towards migrating parts of the AngularJS code base to Angular.
    Both the frameworks can coexist and can depend on each other too. This also allows
    us to develop new parts of applications in Angular. How cool is that?
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的亮点是我们不需要一次性迁移所有内容。我们可以慢慢地将 AngularJS 代码库的部分迁移到 Angular。这两个框架可以共存，并且可以相互依赖。这也允许我们在
    Angular 中开发应用程序的新部分。这有多酷？
- en: But again, this flexibility comes at a cost—the cost of bytes. As both frameworks
    are downloaded, the page bytes do increase, something that we should be aware
    of.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 但再次强调，这种灵活性是有代价的——字节代价。由于两个框架都会被下载，页面字节会增加，这是我们应当注意的。
- en: Also, while the coexistence of both the frameworks allows us to migrate without
    much disruption, we cannot make it a perpetual activity. Eventually, AngularJS
    has to go, and the sooner it does the better.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尽管这两个框架共存使我们能够在很大程度上避免中断进行迁移，但我们不能让它成为一种永久的活动。最终，AngularJS 必须退出，越早越好。
- en: During migration, the best thing that can be done is to carve out new SPAs within
    the existing application. For example, we can build the Admin area of an app entirely
    using Angular, with a separate host page, but still share the common infrastructure
    of style sheets, images, and even AngularJS services if we refactor the code a
    bit. As we will learn later, migrating services to Angular is the easiest.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在迁移过程中，能做的事情最好的是，在现有应用程序中划分出新的单页应用（SPA）。例如，我们可以完全使用 Angular 构建应用程序的 Admin 区域，有一个独立的主页，但如果我们稍微重构代码，仍然可以共享样式表、图像甚至
    AngularJS 服务的基础设施。正如我们稍后将学习的，将服务迁移到 Angular 是最简单的。
- en: Breaking an application into multiple smaller ones introduces full-page refreshes,
    but this is a cleaner approach when it comes to migration.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序分解成多个较小的应用程序会引入全页刷新，但在迁移方面这是一个更干净的方法。
- en: Taking all of this into consideration, if we have decided to migrate and identified
    areas of migration, you need to do the prep work for migration.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，如果我们已经决定迁移并确定了迁移区域，你需要为迁移做准备工作。
- en: Preparing for Angular migration
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备迁移到Angular
- en: Welcome to the big brave world of Angular migration! A successful migration
    strategy involves making sure that we do the groundwork beforehand, avoiding any
    late surprises.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到Angular迁移的广阔勇敢的世界！一个成功的迁移策略涉及确保我们在事先做好基础工作，避免任何意外的惊喜。
- en: As prep work, the first step is to analyze the application from a third-party
    library dependency perspective.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 作为准备工作，第一步是从第三方库依赖的角度分析应用程序。
- en: Identifying third-party dependencies
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别第三方依赖
- en: Any third-party library that an AngularJS app uses needs a migration strategy
    too. These could be either jQuery-based libraries or AngularJS libraries.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 任何AngularJS应用程序使用的第三方库都需要一个迁移策略。这些库可能是基于jQuery的库或者AngularJS库。
- en: jQuery libraries
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jQuery库
- en: jQuery libraries in AngularJS were consumed by creating a directive wrapper
    over them. We will have to migrate such directives to Angular.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularJS中，jQuery库是通过在其上创建指令包装器来使用的。我们将不得不将这些指令迁移到Angular。
- en: AngularJS libraries
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AngularJS库
- en: Migrating AngularJS libraries is a bit of a tricky affair. AngularJS has a massive
    ecosystem, and Angular too has been around for some time and now has a healthy
    community. When migrating, each AngularJS library needs to be substituted with
    an Angular alternative.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移AngularJS库是一件有点棘手的事情。AngularJS有一个庞大的生态系统，Angular也已经存在一段时间，现在有一个健康的社区。在迁移时，每个AngularJS库都需要用Angular的替代品来替换。
- en: 'If we do not find a perfect upgrade path for a specific library, we can either:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有找到特定库的完美升级路径，我们可以选择以下之一：
- en: Customize a similar component/library available out there
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制现有的类似组件/库
- en: Take the more radical approach of building our own library from the ground up
    in Angular
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采取更激进的从零开始构建自己的Angular库的方法
- en: Each of these choices has trade-offs in terms of time and complexity.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间和复杂性方面，每个选择都有其权衡。
- en: Another choice that needs to be made is the development language. Should we
    use TypeScript, ES2015, or plain old JavaScript (ES5)?
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要做出的选择是开发语言。我们应该使用TypeScript、ES2015还是传统的JavaScript（ES5）？
- en: Choice of language
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言选择
- en: We would definitely recommend TypeScript. It's a super awesome language that
    integrates very well with Angular and vastly reduces the verbosity of Angular
    declarations. Also, given that it can coexist with JavaScript, it makes our lives
    easier. Even without Angular, TypeScript is one language that we should embrace
    for the web platform.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定会推荐TypeScript。这是一种非常棒的语言，它与Angular集成得非常好，大大减少了Angular声明的冗长性。此外，由于它可以与JavaScript共存，这使我们的工作变得更简单。即使没有Angular，TypeScript也是我们应该拥抱的Web平台的一种语言。
- en: In the coming sections, we will migrate the AngularJS *Personal Trainer* app
    to Angular. The app is currently available on *GitHub* at [http://bit.ly/a1begit](http://bit.ly/a1begit).
    This app was part of the first version of this book, *AngularJS by Example*, and
    was built using JavaScript.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将把AngularJS *个人教练*应用程序迁移到Angular。该应用程序目前在*GitHub*上可用，地址为[http://bit.ly/a1begit](http://bit.ly/a1begit)。这个应用程序是本书第一版
    *AngularJS by Example* 的一部分，并使用JavaScript构建。
- en: We are again going to follow the checkpoint-based approach for this migration.
    The checkpoints that we highlight during the migration have been implemented as
    GitHub branches. Since we will be interacting with a *Git* repository for v1 code
    and using *Node.js* tools for the build, please set up Git and Node.js on your
    development box before proceeding further.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次采用基于检查点的迁移方法。在迁移过程中，我们强调的检查点已经实现为GitHub分支。由于我们将与v1代码的Git仓库交互，并使用Node.js工具进行构建，请在继续之前在您的开发机器上设置Git和Node.js。
- en: Migrating AngularJS's Personal Trainer
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移AngularJS的Personal Trainer
- en: Before we even begin the migration process, we need to set up the v1 *Personal
    Trainer* locally.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始迁移过程之前，我们需要在本地设置v1 *个人教练*。
- en: The code for the migrated app can be downloaded from the GitHub site at [https://github.com/chandermani/angularjsbyexample](https://github.com/chandermani/angularjsbyexample).
    Since we migrate in chunks, we have created multiple checkpoints that map to **GitHub
    branches** dedicated to migration. Branches such as `ng6-checkpoint8.1`, `ng6-checkpoint8.2`,
    and so on highlight this progression. During the narration, we will highlight
    the branch for reference. These branches will contain the work done on the app
    up to that point in time.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 已迁移应用程序的代码可以从 GitHub 网站下载，网址为 [https://github.com/chandermani/angularjsbyexample](https://github.com/chandermani/angularjsbyexample)。由于我们是分块迁移的，因此我们创建了多个检查点，这些检查点映射到专门用于迁移的
    **GitHub 分支**。例如 `ng6-checkpoint8.1`、`ng6-checkpoint8.2` 等分支突出了这一进展。在叙述过程中，我们将突出显示这些分支以供参考。这些分支将包含到那时为止在应用程序上所做的所有工作。
- en: The *7 Minute Workout* code is available inside the repository folder named
    `trainer`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '*7 分钟锻炼* 代码位于名为 `trainer` 的仓库文件夹内。'
- en: So, let's get started!
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Setting up AngularJS's Personal Trainer locally
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地设置 AngularJS 的 Personal Trainer
- en: 'Follow these steps and you will be up and running in no time:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作，您将很快就能启动并运行：
- en: 'From the command line, clone the v1 GitHub repository:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行，克隆 v1 GitHub 仓库：
- en: '[PRE26]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Navigate to the new Git repo and check out the `ng6-base` branch to get started:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到新的 Git 仓库并检出 `ng6-base` 分支以开始：
- en: '[PRE27]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Since the app loads its workout data from **MongoDB** hosted in **mLab **([https://mlab.com/](https://mlab.com/)),
    you need an mLab account to host workout-related data. Set up an mLab account
    by signing up with them. Once you have an mLab account, you need to retrieve your
    API key from mLab's management portal. Follow the instructions provided in the
    API documentation ([http://bit.ly/mlab-docs](http://bit.ly/mlab-docs)) to get
    your API key.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于应用程序从托管在 **mLab** ([https://mlab.com/](https://mlab.com/)) 上的 **MongoDB**
    加载锻炼数据，因此您需要一个 mLab 账户来托管与锻炼相关的数据。通过注册他们来设置 mLab 账户。一旦您有了 mLab 账户，您需要从 mLab 的管理门户中检索您的
    API 密钥。按照 API 文档中提供的说明 ([http://bit.ly/mlab-docs](http://bit.ly/mlab-docs)) 获取您的
    API 密钥。
- en: 'Once you have the API key, update this line in `app/js/config.js` with your
    API key:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您有了 API 密钥，请更新 `app/js/config.js` 中的这一行，使用您的 API 密钥：
- en: '[PRE28]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And add some seed workout data into your mLab instance. The instructions to
    add the seed data into mLab are available in the source code file, `app/js/seed.js`.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一些种子锻炼数据添加到您的 mLab 实例中。将种子数据添加到 mLab 的说明可在源代码文件 `app/js/seed.js` 中找到。
- en: 'Next, install the necessary *npm packages* required for v1 *Personal Trainer*:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，安装 v1 *个人教练* 所需的必要 *npm 包*：
- en: '[PRE29]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Install `http-server`; it will act as a development server for our v1 app:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `http-server`；它将作为我们的 v1 应用程序的开发服务器：
- en: '[PRE30]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Verify that the setup is complete by starting the `http-server` from the `app`
    folder:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从 `app` 文件夹启动 `http-server` 来验证设置是否完成：
- en: '[PRE31]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: And open the browser location `http://localhost:8080`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 并打开浏览器位置 `http://localhost:8080`。
- en: The v1 *Personal Trainer* start page should show up. Play around with the app
    to verify that the app is working fine. Now, the migration can begin.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: v1 *个人教练* 的起始页面应该会出现。玩一下这个应用程序以验证应用程序运行正常。现在，迁移可以开始了。
- en: Identifying dependencies
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别依赖项
- en: The first step before we begin migrating v1 *Personal Trainer* is to identify
    the external libraries that we are using in the AngularJS version of Personal
    Trainer.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始迁移 v1 *个人教练* 之前的第一步是确定我们在 AngularJS 版本的 Personal Trainer 中使用的外部库。
- en: 'The external libraries that we are using in v1 are:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 v1 中使用的库有：
- en: '`angular-media-player`'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`angular-media-player`'
- en: '`angular-local-storage`'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`angular-local-storage`'
- en: '`angular-translate`'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`angular-translate`'
- en: '`angular-ui-bootstrap`'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`angular-ui-bootstrap`'
- en: '`owl. carousel`'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`owl. carousel`'
- en: Libraries such as `angular-media-player` and `angular-local-storage` are easy
    to migrate/replace. We have already done this in earlier chapters of this book.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的库 `angular-media-player` 和 `angular-local-storage` 容易迁移/替换。我们已经在本书的早期章节中完成了这项工作。
- en: The `angular-translate` library can be replaced with `ngx-translate`, and as
    we will see in the coming sections, it is not a very challenging task.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`angular-translate` 库可以被 `ngx-translate` 替换，正如我们将在接下来的章节中看到的，这不是一个很有挑战性的任务。'
- en: We use `angular-ui-bootstrap` for **modal dialogs** in *Personal Trainer v1*.
    We replace it with `ngx-modialog` ([http://bit.ly/ngx-modialog](http://bit.ly/ngx-modialog))
    as the only control we were using from `angular-ui-bootstrap` was the dialog control.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *Personal Trainer v1* 中使用 `angular-ui-bootstrap` 进行 **模态对话框**。我们用 `ngx-modialog`
    ([http://bit.ly/ngx-modialog](http://bit.ly/ngx-modialog)) 替换它，因为我们只使用了 `angular-ui-bootstrap`
    中的对话框控件。
- en: Now that we have sorted out the external dependencies, let's decide the language
    to use.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经整理好了外部依赖，让我们决定要使用的语言。
- en: While the existing code base is JavaScript, we love TypeScript. Its type safety,
    its terse syntax, and how well it plays with Angular makes it our language of
    choice. Hence, it's going to be TypeScript all the way.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然现有的代码库是 JavaScript，但我们更喜欢 TypeScript。它的类型安全、简洁的语法以及与 Angular 的良好兼容性使其成为我们的首选语言。因此，我们将全程使用
    TypeScript。
- en: Another thing that tilts the decision in favor of TypeScript is that we do not
    need to migrate the existing code base to TypeScript. Anything we migrate/build
    new, we build it in TypeScript. Legacy code still remains in JavaScript.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使决策倾向于 TypeScript 的因素是，我们不需要将现有代码库迁移到 TypeScript。我们迁移/构建的任何新内容都将使用 TypeScript
    构建。遗留代码仍然保持在 JavaScript 中。
- en: Let's start. As a first migration task, we need to set up a module loader for
    our v1 Personal Trainer.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。作为一个迁移任务的第一步，我们需要为我们的 v1 个人教练设置一个模块加载器。
- en: Setting up the module loader
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置模块加载器
- en: Since we are going to create a number of new Angular components spread across
    numerous small files, adding direct script reference is going to be tedious and
    error-prone. Angular CLI also is not of much help here as it cannot manage the
    existing codebase implemented in JavaScript.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将创建许多新的 Angular 组件，分布在众多小文件中，直接添加脚本引用将会很繁琐且容易出错。Angular CLI 在这里也不是很有帮助，因为它无法管理用
    JavaScript 实现的现有代码库。
- en: 'We need a **module loader**. A module loader (*ES6 modules* and not Angular)
    can help us with:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个 **模块加载器**。一个模块加载器（*ES6 模块*，而不是 Angular）可以帮助我们：
- en: Creating isolated/reusable modules based on some common module formats
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于某些常见的模块格式创建隔离/可重用模块
- en: Managing the script loading order based on dependencies
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据依赖关系管理脚本加载顺序
- en: Allowing bundling/packaging of a module and on-demand loading for dev/production
    deployments
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许模块的捆绑/打包以及开发/生产部署时的按需加载
- en: We use the **SystemJS** module loader for this migration.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 **SystemJS** 模块加载器进行这次迁移。
- en: 'Install SystemJS from the command line using:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令从命令行安装 SystemJS：
- en: '[PRE32]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: All the commands need to be executed from the `trainer/app` folder.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 所有命令都需要从 `trainer/app` 文件夹中执行。
- en: We open `index.html` and remove all the script references of our app scripts.
    All script references with the source as `src='js/*.*'` should be removed, except
    `angular-media-player.js` and `angular-local-storage.js`, as they are external
    libraries.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开 `index.html` 并移除我们应用脚本的全部脚本引用。所有以 `src='js/*.*'` 为源的脚本引用都应该被移除，除了 `angular-media-player.js`
    和 `angular-local-storage.js`，因为它们是外部库。
- en: 'Note: We are not removing script references for third-party libraries, but
    only app files.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们不会移除第三方库的脚本引用，但只会移除应用文件。
- en: 'Add SystemJS configurations after all third-party script references:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有第三方脚本引用之后添加 SystemJS 配置：
- en: '[PRE33]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Remove the `ng-app` attribute on the `body` tag, keeping the `ng-controller`
    declaration intact:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `body` 标签上移除 `ng-app` 属性，保持 `ng-controller` 声明不变：
- en: '[PRE34]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `ng-app` way of bootstrapping has to go as we switch to the `angular.bootstrap`
    function for manual bootstrapping. Manual bootstrapping helps when we bring Angular
    into the mix.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们切换到 `angular.bootstrap` 函数进行手动引导时，`ng-app` 的引导方式必须放弃。手动引导在将 Angular 引入其中时非常有帮助。
- en: The preceding `SystemJS.import` call loads the application by loading the first
    app module (JavaScript) defined in `js/app.js`. We are going to define this JavaScript
    module shortly.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `SystemJS.import` 调用通过加载 `js/app.js` 中定义的第一个应用模块（JavaScript）来加载应用程序。我们很快就会定义这个
    JavaScript 模块。
- en: Create a new file called `app.module.js` in the same folder as `app.js` and
    copy the complete contents of `app.js` into `app.module.js`.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在与 `app.js` 相同的文件夹中创建一个名为 `app.module.js` 的新文件，并将 `app.js` 的全部内容复制到 `app.module.js`
    中。
- en: Remember to get rid of the `use strict` statement. The TypeScript compiler does
    not like it.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 记得移除 `use strict` 语句。TypeScript 编译器不喜欢它。
- en: All the app module definitions are now in `app.module.js`.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 所有应用模块定义现在都在 `app.module.js` 中。
- en: 'Next, clear `app.js` and add the following imports and bootstrap code:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，清空 `app.js` 并添加以下导入和引导代码：
- en: '[PRE35]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We have added *ES6 import statements* to `app.js`. These are the same scripts
    that were earlier referenced in `index.html`. SystemJS now loads these script
    files when loading `app.js`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 `app.js` 中添加了 *ES6 导入语句*。这些脚本与之前在 `index.html` 中引用的脚本相同。SystemJS 现在在加载
    `app.js` 时会加载这些脚本文件。
- en: Moving all of the AngularJS module declarations into a new file, `app.module.js`,
    and importing it first into `app.js` makes sure that the AngularJS modules are
    defined before any of the `import` statements are executed.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有的AngularJS模块声明移动到一个新的文件`app.module.js`中，并首先将其导入到`app.js`中，确保在执行任何`import`语句之前定义了AngularJS模块。
- en: Do not confuse *ES6 modules* and *AngularJS modules* defined/accessed using
    `angular.module('name')`. These two are altogether different concepts.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆使用`angular.module('name')`定义/访问的**ES6模块**和**AngularJS模块**。这两个概念完全不同。
- en: The last few lines bootstrap the AngularJS application using the `angular.bootstrap`
    function.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 最后几行使用`angular.bootstrap`函数引导AngularJS应用程序。
- en: Module loading is enabled now; let's enable TypeScript too.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 模块加载现在已启用；让我们也启用TypeScript。
- en: Enabling TypeScript
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用TypeScript
- en: 'To enable TypeScript, install the TypeScript compiler using *npm*:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用TypeScript，使用*npm*安装TypeScript编译器：
- en: '[PRE36]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, open `package.json` and add these lines inside the script configuration:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开`package.json`并在脚本配置中添加以下行：
- en: '[PRE37]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The new script's properties that we just added provide a shortcut for commonly
    executed commands.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的新脚本属性为常用命令提供了快捷方式。
- en: To enable IDE IntelliSense for JavaScript libraries, we need to install their
    type definitions. **Type definitions** or **typings** are files that define the
    public interface for a TypeScript/JavaScript library. These type definitions help
    IDEs provide IntelliSense around the library functions. Typings are available
    for most of the popular JavaScript libraries and for frameworks/libraries written
    in TypeScript.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用JavaScript库的IDE IntelliSense，我们需要安装它们的类型定义。**类型定义**或**typings**是定义TypeScript/JavaScript库公共接口的文件。这些类型定义帮助IDE为库函数提供IntelliSense。大多数流行的JavaScript库和用TypeScript编写的框架/库都有类型定义。
- en: 'Let''s install typings for the libraries we use. From the command line, execute:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装我们使用的库的类型定义。从命令行执行：
- en: '[PRE38]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Next, copy `overrides.d.ts` from `checkpoint8.1` to the local `app` folder.
    This helps TypeScript compiler to handle the global `angular` object used in `app.js` and
    other places.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`overrides.d.ts`从`checkpoint8.1`复制到本地的`app`文件夹。这有助于TypeScript编译器处理在`app.js`和其他地方使用的全局`angular`对象。
- en: 'We now need to set up some configurations for the TypeScript compiler. Create
    a file called `tsconfig.json` (in the `trainer/app` folder) and copy the configuration
    from the `ng6-checkpoint8.1` repo branch (also available remotely at [http://bit.ly/ng6be-8-1-tsconfig](http://bit.ly/ng2be-8-1-tsconfig)).
    Run the compiler using:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要为TypeScript编译器设置一些配置。在`trainer/app`文件夹中创建一个名为`tsconfig.json`的文件，并从`ng6-checkpoint8.1`仓库分支复制配置（也远程可用于[http://bit.ly/ng6be-8-1-tsconfig](http://bit.ly/ng2be-8-1-tsconfig)）。使用以下命令运行编译器：
- en: '[PRE39]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This should start the TypeScript compiler, and there should be no errors reported.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会启动TypeScript编译器，并且不应该报告任何错误。
- en: Keep this command running in a separate console window at all times during development.
    The compiler will continuously watch for changes to the TypeScript file and rebuild
    the code if changes are detected.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发期间，始终在单独的控制台窗口中运行此命令。编译器将连续监视TypeScript文件的变化，并在检测到变化时重新构建代码。
- en: Change the extension of the `app.js` and `app.module.js` files to `app.ts` and
    `app.module.ts`. The TypeScript compiler detects these changes and compiles the
    TypeScript files. After compilation, the compiler produces two files for each
    TypeScript file. One is the compiled JavaScript file (such as `app.js`) and the
    other is a map file (`app.js.map`) for debugging purposes.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 将`app.js`和`app.module.js`文件的扩展名更改为`app.ts`和`app.module.ts`。TypeScript编译器会检测这些更改并编译TypeScript文件。编译后，编译器为每个TypeScript文件生成两个文件。一个是编译后的JavaScript文件（如`app.js`），另一个是用于调试的映射文件（`app.js.map`）。
- en: We have not set up an elaborate build for this exercise as our primary focus
    is on migration. For your own apps, the initial setup steps may vary depending
    upon how the build is already set up.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有为这个练习设置复杂的构建，因为我们的主要重点是迁移。对于您自己的应用程序，初始设置步骤可能因构建的设置方式而异。
- en: 'Before we test our new changes, `config.js` needs to be fixed because we have
    enabled strict DI check-in AngularJS through:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们测试新的更改之前，`config.js`需要修复，因为我们已经通过以下方式在AngularJS中启用了严格的DI检查：
- en: '[PRE40]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Replace the `config.js` content with updated content available in `ng6-checkpoint8.1`
    or at [http://bit.ly/ng6be-8-1-configjs](http://bit.ly/ng2be-8-1-configjs) (and
    remember to set the API key again). The update fixes the `config` function and
    makes it minification-friendly. Time to test the app!
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `config.js` 的内容替换为在 `ng6-checkpoint8.1` 或 [http://bit.ly/ng6be-8-1-configjs](http://bit.ly/ng2be-8-1-configjs)
    中可用的更新内容（并记得再次设置 API 密钥）。这次更新修复了 `config` 函数，使其更适合压缩。是时候测试应用了！
- en: Make sure the TypeScript compiler is running in one console; run `http-server
    -c-1` in a new console window.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 确保 TypeScript 编译器在一个控制台中运行；在新控制台窗口中运行 `http-server -c-1`。
- en: Navigate to `http://localhost:8080` the app start page should load.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到 `http://localhost:8080` 应用启动页面应该加载。
- en: Commit/save your local changes.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 提交/保存你的本地更改。
- en: 'If things work fine, you can even commit your local changes to your git repo.
    This will help you track what has changed over time as we migrate the app piece
    by piece. The implementation till this point is available in the `ng6-checkpoint8.1`
    GitHub branch. If you are facing problems, compare the `ng6-base` and `ng6-checkpoint8.1`
    branches to understand the changes made. Since the code is hosted in GitHub, we
    can use the *GitHub compare* interface to compare commits in a single branch.
    See the documentation on how to do it here: [http://bit.ly/github-compare](http://bit.ly/github-compare).
    The link at [http://bit.ly/ng6be-compare-base-8-1](http://bit.ly/ng6be-compare-base-8-1) shows
    a comparison between `ng6-base` and `ng6-checkpoint8.1`. You can ignore the diff
    view for `app.js` and `app.module.js`, generated as part of the TypeScript compilation.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你甚至可以将你的本地更改提交到你的 git 仓库。这将帮助我们跟踪随着时间的推移应用迁移过程中发生了哪些变化。到这一点的实现可以在 `ng6-checkpoint8.1`
    GitHub 分支中找到。如果你遇到问题，比较 `ng6-base` 和 `ng6-checkpoint8.1` 分支以了解所做的更改。由于代码托管在 GitHub
    上，我们可以使用 *GitHub compare* 接口来比较单个分支的提交。请参阅如何操作的文档：[http://bit.ly/github-compare](http://bit.ly/github-compare)。[http://bit.ly/ng6be-compare-base-8-1](http://bit.ly/ng6be-compare-base-8-1)
    中的链接显示了 `ng6-base` 和 `ng6-checkpoint8.1` 之间的比较。你可以忽略作为 TypeScript 编译部分生成的 `app.js`
    和 `app.module.js` 的 diff 视图。
- en: Time to introduce Angular!
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候介绍 Angular 了！
- en: Adding Angular
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 Angular
- en: We start by installing Angular and dependent *npm modules* for our app. We will
    update the `package.json` file with the necessary packages first.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先安装 Angular 和应用依赖的 *npm 模块*。首先，我们将更新 `package.json` 文件中的必要包。
- en: Copy the updated package file from [http://bit.ly/ng6be-8-2-package-json](http://bit.ly/ng6be-8-2-package-json)
    into your local installation.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [http://bit.ly/ng6be-8-2-package-json](http://bit.ly/ng6be-8-2-package-json)
    复制更新的包文件到你的本地安装。
- en: '`package.json` now references some new packages related to Angular. Install
    the referenced packages by calling:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json` 现在引用了一些与 Angular 相关的新包。通过调用以下命令安装引用的包：'
- en: '[PRE41]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you are having trouble with installing packages with `npm install`, delete
    the `node_modules` folder and run `npm install` again.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `npm install` 安装包时遇到问题，删除 `node_modules` 文件夹并再次运行 `npm install`。
- en: 'Then, add a few library references that Angular is dependent upon (and are
    not loaded using SystemJS) in `index.html` before the `system.src.js` script reference
    (two in total):'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `index.html` 中 `system.src.js` 脚本引用之前添加一些 Angular 依赖的库引用（不使用 SystemJS 加载），总共两个：
- en: '[PRE42]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As it stands now, the SystemJS configuration has been set up in the `index.html`
    file itself. Since Angular requires some decent amount of configuration, we are
    going to create a separate *SystemJS configuration file* instead, and reference
    that in `index.html`.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，SystemJS 配置已经在 `index.html` 文件中设置。由于 Angular 需要相当数量的配置，我们将创建一个单独的 *SystemJS
    配置文件*，并在 `index.html` 中引用它。
- en: 'Add this script reference after the `system.src.js` reference:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `system.src.js` 引用之后添加此脚本引用：
- en: '[PRE43]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, clear the `script` section containing the call to the `System.config`
    function and replace it with the following:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，清除包含调用 `System.config` 函数的 `script` 部分，并用以下内容替换：
- en: '[PRE44]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Copy the `systemjs.config.js` from [http://bit.ly/ng6be-8-2-system-js-config](http://bit.ly/ng6be-8-2-system-js-config) and
    place it in the same folder as `package.json`.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [http://bit.ly/ng6be-8-2-system-js-config](http://bit.ly/ng6be-8-2-system-js-config)
    复制 `systemjs.config.js` 并将其放置在 `package.json` 相同的文件夹中。
- en: 'Also, update `tsconfig.json` and add a new property called `moduleResolution`
    to `compilerOptions`:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，更新 `tsconfig.json` 并在 `compilerOptions` 中添加一个名为 `moduleResolution` 的新属性：
- en: '[PRE45]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This instructs TypeScript to look for type definitions in the `node_modules`
    folder. Remember, Angular typings are bundled as part of the Angular library itself,
    and hence a separate type definition import is not required.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示TypeScript在`node_modules`文件夹中查找类型定义。记住，Angular类型定义捆绑在Angular库本身中，因此不需要单独的类型定义导入。
- en: Now that the Angular-specific references have been added, we need to modify
    the existing bootstrap process to also load Angular.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经添加了Angular特定的引用，我们需要修改现有的引导过程，以便也加载Angular。
- en: The ngUpgrade Library
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The ngUpgrade Library
- en: 'To support gradual migration from AngularJS to Angular, the Angular team has
    released a library, `ngUpgrade`. The library contains a set of services that allow
    AngularJS and Angular to be loaded in tandem and play well together. This library
    has services that can help:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持从AngularJS到Angular的逐步迁移，Angular团队发布了一个库，`ngUpgrade`。该库包含一组服务，允许AngularJS和Angular同时加载并良好协作。此库包含以下服务可以帮助：
- en: Bootstrap an app with both the AngularJS and Angular frameworks loaded. This
    is the first thing we are going to do.
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导同时加载AngularJS和Angular框架的应用程序。这是我们即将要做的事情。
- en: Incorporate an Angular component in an AngularJS view.
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在AngularJS视图中包含一个Angular组件。
- en: Incorporate an AngularJS component in an Angular view, albeit with some limitations.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular视图中包含一个AngularJS组件，尽管有一些限制。
- en: Share dependencies across the frameworks.
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在框架之间共享依赖项。
- en: '*The primary tool in this library is* `UpgradeModule`. As the platform documentation
    summarizes:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '*该库中的主要工具是* `UpgradeModule`。正如平台文档总结的那样：'
- en: '"This is a module that contains utilities for bootstrapping and managing hybrid
    applications that support both Angular and AngularJS code."'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '"这是一个包含用于引导和管理支持Angular和AngularJS代码的混合应用程序的实用工具的模块。"'
- en: As we make progress with our migration efforts, the role of `UpgradeModule`
    becomes clearer.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们迁移工作的进展，`UpgradeModule`的作用变得更加清晰。
- en: Let's learn how to bootstrap the hybrid AngularJS and Angular app using `UpgradeModule`.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何使用`UpgradeModule`引导混合的AngularJS和Angular应用程序。
- en: Bootstrapping the hybrid app
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引导混合应用程序
- en: 'To bootstrap a hybrid application, we must bootstrap both the Angular and AngularJS
    parts of the application. The sequence involves the process is as follows:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 要引导混合应用程序，我们必须引导应用程序的Angular和AngularJS部分。这个过程涉及以下步骤：
- en: Bootstrap the Angular app
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引导Angular应用程序
- en: Then, using`UpgradeModule`, bootstrap the AngularJS app
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`UpgradeModule`引导AngularJS应用程序
- en: Since Angular has just been added, we need to define the root app module for
    Angular.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 由于刚刚添加了Angular，我们需要定义Angular的根应用程序模块。
- en: Create a new file, `app-ng1.module.js`, and copy the complete content of `app.module.ts`
    to the new file. We will use the `app.module.ts` file to define an Angular module
    and hence the existing AngularJS module has been shifted to a new file.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，`app-ng1.module.js`，并将`app.module.ts`的完整内容复制到新文件中。我们将使用`app.module.ts`文件来定义Angular模块，因此现有的AngularJS模块已被转移到新文件中。
- en: 'Also, remember to update the `import` statement in `app.ts` in line with the
    changes:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记得根据更改更新`app.ts`中的`import`语句：
- en: '[PRE46]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Let's now add the Angular root module definition to `app.module.ts`.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将Angular根模块定义添加到`app.module.ts`中。
- en: Replace the content of `app.module.ts` with the Angular module definition. Copy
    the new definition from `ng6-checkpoint8.2` (GitHub location: [http://bit.ly/ng6be-8-2-app-module-ts](http://bit.ly/ng6be-8-2-app-module-ts)).
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 将`app.module.ts`的内容替换为Angular模块定义。从`ng6-checkpoint8.2`（GitHub位置：[http://bit.ly/ng6be-8-2-app-module-ts](http://bit.ly/ng6be-8-2-app-module-ts)）复制新的定义。
- en: 'The `AppModule` implementation defines a function, `ngDoBootstrap`:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppModule`实现定义了一个函数，`ngDoBootstrap`：'
- en: '[PRE47]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The Angular framework invokes this function as part of the application bootstrap.
    This function internally uses the `bootstrap` function of `UpgradeModule` to bootstrap
    the AngularJS app. This function takes the same argument as the `angular.bootstrap`
    function takes.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: Angular框架在应用程序引导过程中调用此函数。此函数内部使用`UpgradeModule`的`bootstrap`函数来引导AngularJS应用程序。此函数接受与`angular.bootstrap`函数相同的参数。
- en: 'While we have defined the root module for Angular, we still have not defined
    the entry point for the Angular application. Create a new file, `main.ts`, in
    the app folder and add the following code:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经定义了Angular的根模块，但我们还没有定义Angular应用程序的入口点。在app文件夹中创建一个新的文件，名为`main.ts`，并添加以下代码：
- en: '[PRE48]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This code, when executed, instructs the Angular framework to bootstrap the application
    with `AppModule`. The statement `import './app'` helps in loading all the script
    references in `app.ts`. Before proceeding, do remember to remove the AngularJS
    application bootstrapping code from `app.ts` (the complete `angular.element` block).
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 当这段代码执行时，它指示 Angular 框架使用 `AppModule` 启动应用。语句 `import './app'` 有助于加载 `app.ts`
    中的所有脚本引用。在继续之前，请记住从 `app.ts`（完整的 `angular.element` 块）中删除 AngularJS 应用启动代码。
- en: Refresh your app and make sure it works as before. Do watch out for errors in
    the TypeScript compiler console window or browser console log.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新你的应用并确保它像以前一样工作。同时请注意 TypeScript 编译器控制台窗口或浏览器控制台日志中的错误。
- en: Congratulations! We now have a hybrid app up and running. Both frameworks are
    now working in tandem.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们现在有一个混合应用正在运行。两个框架现在协同工作。
- en: Look at the `ng6-checkpoint8.2` branch if you are facing issues upgrading to
    Angular. Again, you can also compare the git branches `ng6-checkpoint8.1` and
    `ng6- checkpoint8.2` to understand what has changed ([http://bit.ly/ng6be-compare-8-1-8-2](http://bit.ly/ng6be-compare-8-1-8-2)).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在升级到 Angular 时遇到问题，请查看 `ng6-checkpoint8.2` 分支。再次提醒，你也可以比较 git 分支 `ng6-checkpoint8.1`
    和 `ng6-checkpoint8.2` 来了解发生了哪些变化 ([http://bit.ly/ng6be-compare-8-1-8-2](http://bit.ly/ng6be-compare-8-1-8-2))。
- en: The migration process can start now. We can start by migrating a part of an
    AngularJS view/directive to Angular.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移过程现在可以开始了。我们可以从将 AngularJS 视图/指令的一部分迁移到 Angular 开始。
- en: Injecting Angular components into AngularJS views
  id: totrans-524
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Angular 组件注入到 AngularJS 视图中
- en: The most common migration pattern involves migrating lower-level AngularJS directives/views
    to Angular components. If we visualize the AngularJS HTML view structure as a
    tree of directives, we start at the leaf. We migrate parts of a directive/view
    to an Angular component and then embed the component inside the AngularJS view
    template. This Angular component is injected into the AngularJS view as an *element
    directive*.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的迁移模式是将低级别的 AngularJS 指令/视图迁移到 Angular 组件。如果我们将 AngularJS HTML 视图结构可视化为指令树，我们则从叶子开始。我们将指令/视图的一部分迁移到
    Angular 组件，然后将组件嵌入到 AngularJS 视图模板中。这个 Angular 组件作为 *元素指令* 注入到 AngularJS 视图中。
- en: The closest thing to **Angular components** that AngularJS has is **element
    directives**. During migration, we are either migrating element directives or
    controller-view pairs.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 中最接近 *Angular 组件* 的是 **element directives**。在迁移过程中，我们要么迁移元素指令，要么迁移控制器-视图对。
- en: 'This is a bottom-up approach to migrating view/directives to Angular components.
    The following diagram highlights how the AngularJS view hierarchy gradually transforms
    into an Angular component tree:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种自下而上的方法，将视图/指令迁移到 Angular 组件。以下图表突出了 AngularJS 视图层次结构如何逐渐转换为 Angular 组件树：
- en: '![](img/00086.jpeg)'
  id: totrans-528
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00086.jpeg)'
- en: Let's migrate something small and get a feel for how things work. `ExerciseNavController`
    and its corresponding view fit the bill.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们迁移一些小东西，感受一下事情是如何工作的。`ExerciseNavController` 及其相应的视图符合要求。
- en: Migrating our first view to Angular component
  id: totrans-530
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将第一个视图迁移到 Angular 组件
- en: '`ExerciseNavController` is part of *Workout Builder* and is located inside
    `trainer/app/js/WorkoutBuilder/exercise.js`. The corresponding view is served
    from `trainer/app/partials/workoutbuilder/left-nav-exercises.html`.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExerciseNavController` 是 *Workout Builder* 的一部分，位于 `trainer/app/js/WorkoutBuilder/exercise.js`
    内。相应的视图由 `trainer/app/partials/workoutbuilder/left-nav-exercises.html` 提供。'
- en: 'The primary purpose of this controller-view pair is to show the list of available
    exercises when building a workout (available user path `http://localhost:8080/#/builder/workouts/new`):'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 这对控制器-视图的主要目的是在构建锻炼时显示可用的练习列表（可用用户路径 `http://localhost:8080/#/builder/workouts/new`）：
- en: '![](img/00087.jpeg)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00087.jpeg)'
- en: Clicking on any of these exercise names adds the exercise to the workout being
    constructed.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 点击任何这些练习名称都会将其添加到正在构建的锻炼中。
- en: Let's start with creating a component for the preceding view.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建前一个视图的组件开始。
- en: 'Before starting on the new component, add a new *Workout Builder* module (`WorkoutBuilderModule`)
    to the application. Copy the module definition from `ng6-checkpoint8.3` in the
    `WorkoutBuilder` folder (GitHub location: [http://bit.ly/ng6be-8-3-workout-builder-module-ts](http://bit.ly/ng6be-8-3-workout-builder-module-ts)).
    Also, import the newly created module in `app.module.ts`.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始新的组件之前，向应用中添加一个新的 *Workout Builder* 模块（`WorkoutBuilderModule`）。从 `WorkoutBuilder`
    文件夹中的 `ng6-checkpoint8.3` 复制模块定义（GitHub 位置：[http://bit.ly/ng6be-8-3-workout-builder-module-ts](http://bit.ly/ng6be-8-3-workout-builder-module-ts)）。此外，在
    `app.module.ts` 中导入新创建的模块。
- en: Instead of inlining the complete code here, we suggest copying the `exercise-nav.component.ts`
    file from GitHub branch `ng6-checkpoint8.3` ([http://bit.ly/ng6be-8-3-exercise-nav-component-ts](http://bit.ly/ng6be-8-3-exercise-nav-component-ts))
    and adding it to the `WorkoutBuilder` folder locally. The file has already been
    referenced in `WorkoutBuilderModule`. We also add `ExerciseNavComponent` to `entryComponents`
    array as the component will be used from AngularJS module directly.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议不要在这里内联完整的代码，而是从 GitHub 分支 `ng6-checkpoint8.3`（[http://bit.ly/ng6be-8-3-exercise-nav-component-ts](http://bit.ly/ng6be-8-3-exercise-nav-component-ts)）复制
    `exercise-nav.component.ts` 文件，并将其添加到本地的 `WorkoutBuilder` 文件夹中。该文件已在 `WorkoutBuilderModule`
    中被引用。我们还把 `ExerciseNavComponent` 添加到 `entryComponents` 数组中，因为该组件将从 AngularJS 模块直接使用。
- en: From an implementation standpoint, let's look at some relevant parts.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 从实现的角度来看，让我们看看一些相关的部分。
- en: Contrasting template syntaxThe Angular team has published an excellent reference
    ([http://bit.ly/ng2-a1-a2-quickref](http://bit.ly/ng2-a1-a2-quickref)) that details
    the common view syntaxes in AngularJS and their equivalents in Angular. Highly
    recommended when migrating an AngularJS app!
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 对比模板语法Angular 团队发布了一份优秀的参考文档（[http://bit.ly/ng2-a1-a2-quickref](http://bit.ly/ng2-a1-a2-quickref)），详细介绍了
    AngularJS 中的常见视图语法及其在 Angular 中的等效语法。在迁移 AngularJS 应用时强烈推荐！
- en: 'To start with, if you look at the `exercise-nav.component.ts` file, the component
    template is similar to `left-nav-exercises.html` used in AngularJS, except there
    is no `ng-controller` and the template bindings are Angular-based:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你查看 `exercise-nav.component.ts` 文件，组件模板与 AngularJS 中使用的 `left-nav-exercises.html`
    类似，只是没有 `ng-controller`，并且模板绑定是基于 Angular 的：
- en: '[PRE49]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If we focus on the component implementation (`ExercisesNavComponent`), the
    first striking thing is the component''s dependencies:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们关注组件实现（`ExercisesNavComponent`），第一眼令人印象深刻的是组件的依赖项：
- en: '[PRE50]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`WorkoutService` and `WorkoutBuilderService` are AngularJS services injected
    into Angular components.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutService` 和 `WorkoutBuilderService` 是注入到 Angular 组件中的 AngularJS 服务。'
- en: Nice! If that is your initial reaction, we can't blame you. The ease with which
    we can inject AngularJS service into Angular is pretty cool! But the story is
    still incomplete. There is no magic happening here. Angular cannot access AngularJS
    services unless it is told where to look. To help Angular, we need to create *factory
    provider* wrappers for the AngularJS service.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！如果你有这样的初始反应，我们不会责怪你。我们能够轻松地将 AngularJS 服务注入到 Angular 中的便利性真的很酷！但故事还没有结束。这里并没有发生魔法。除非告诉
    Angular 去哪里寻找，否则 Angular 无法访问 AngularJS 服务。为了帮助 Angular，我们需要为 AngularJS 服务创建 *工厂提供者*
    包装器。
- en: Injecting AngularJS dependencies into Angular
  id: totrans-546
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 AngularJS 依赖注入到 Angular 中
- en: When we allow an AngularJS service to be used in Angular, we are *upgrading*
    the service. The way it is done is by creating a **factory provider wrapper**
    over the existing AngularJS service and registering the wrapper with an Angular
    module or component.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们允许 AngularJS 服务在 Angular 中使用时，我们是在 *升级* 该服务。这样做的方式是通过在现有的 AngularJS 服务上创建一个
    **工厂提供者包装器**，并将其注册到一个 Angular 模块或组件中。
- en: Let's create wrappers for the two AngularJS services, `WorkoutService` and `WorkoutBuilderService`,
    that we have used in the last section.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为上一节中使用的两个 AngularJS 服务，`WorkoutService` 和 `WorkoutBuilderService`，创建包装器。
- en: 'A factory provider for an AngularJS service can be created using Angular''s
    dependency injection API. Here is an example of a factory provider for `WorkoutService`:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 Angular 的依赖注入 API 创建 AngularJS 服务的工厂提供者。以下是一个 `WorkoutService` 的工厂提供者示例：
- en: '[PRE51]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this code, `$injector` is the AngularJS *injector service* and we are referencing
    the injector in the Angular execution context. The call to  `injector.get('WorkoutService');`
    in the previous factory function retrieves the service from AngularJS realm.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`$injector` 是 AngularJS 的 *注入服务*，我们在 Angular 执行上下文中引用了这个注入器。在前一个工厂函数中对
    `injector.get('WorkoutService');` 的调用从 AngularJS 领域检索了该服务。
- en: 'The provider created can then be registered with the app module:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的提供者可以随后注册到应用模块中：
- en: '[PRE52]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The shortcoming of this approach is that we have to define the factory function
    (`workoutServiceFactory`) and provider (`workoutServiceProvider`) for each service.
    That is too much code!
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是我们必须为每个服务定义工厂函数（`workoutServiceFactory`）和提供者（`workoutServiceProvider`）。这太多了！
- en: Instead, we can create a generic factory provider and factory function implementation,
    which can take any AngularJS service and register it with the same name (*string
    token*) in Angular. We have already done the hard work and created a new class, `UpgradeHelperService.`
    Download it from the codebase for `ng6-checkpoint8.3` ([http://bit.ly/ng6be-upgrade-helper-service-ts](http://bit.ly/ng6be-upgrade-helper-service-ts)).
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以创建一个通用的工厂提供者和工厂函数实现，它可以接受任何AngularJS服务，并在Angular中以相同的名称（*字符串标记*）注册它。我们已经完成了艰苦的工作，并创建了一个新的类，`UpgradeHelperService`。从`ng6-checkpoint8.3`的代码库中下载它（[http://bit.ly/ng6be-upgrade-helper-service-ts](http://bit.ly/ng6be-upgrade-helper-service-ts)）。
- en: 'The implementation exposes a function, `upgradeService`, which takes one argument,
    the name of the AngularJS service, and returns a factory provider instance. The
    factory provider implementation internally uses a *string token* to register the
    dependency. To create a factory provider for an AngularJS service, we just need
    to call:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 实现提供了一个函数，`upgradeService`，它接受一个参数，即AngularJS服务的名称，并返回一个工厂提供者实例。工厂提供者实现内部使用一个*字符串标记*来注册依赖项。要为AngularJS服务创建一个工厂提供者，我们只需调用：
- en: '[PRE53]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Service dependencies at times have other dependencies, and hence it''s better
    if we bring in all the service dependencies from AngularJS in one go. Register
    all the existing AngularJS dependencies as factory providers in `app.module.ts`:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 服务依赖项有时还有其他依赖项，因此最好一次性将所有AngularJS服务依赖项引入。在`app.module.ts`中将所有现有的AngularJS依赖项注册为工厂提供者：
- en: '[PRE54]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Back to component integration! As the new  `ExercisesNavComponent` is rendered
    inside an AngularJS view, it needs to be registered as an *AngularJS directive*.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 回到组件集成！由于新的`ExercisesNavComponent`是在AngularJS视图中渲染的，因此它需要注册为*AngularJS指令*。
- en: Registering Angular components as directives
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册Angular组件为指令
- en: '`ExercisesNavComponent` can be converted into an AngularJS directive using
    `ngUpgrade` library function `downgradeComponent.` As the function name suggests,
    we are downgrading an Angular component into an AngularJS element directive.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ngUpgrade`库函数`downgradeComponent`可以将`ExercisesNavComponent`转换为AngularJS指令。正如函数名所暗示的，我们正在将Angular组件降级为AngularJS元素指令。
- en: 'Open `app.ts` and add the highlighted lines:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`app.ts`并添加高亮行：
- en: '[PRE55]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `downgradeComponent` function returns a *factory function* containing the
    *directive definition object*. We register the component as an AngularJS directive,
    `exerciseNav`.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '`downgradeComponent`函数返回一个包含*指令定义对象*的*工厂函数*。我们将组件注册为AngularJS指令，`exerciseNav`。'
- en: Every Angular component is registered as an *element directive* when used in
    AngularJS.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Angular组件在AngularJS中使用时都会注册为*元素指令*。
- en: The component implementation is complete. We now need to clean up the old code
    and inject the new directive into the view.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 组件实现已完成。我们现在需要清理旧代码并将新指令注入到视图中。
- en: Delete the definition of `ExercisesNavController` from `exercise.js`.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 从`exercise.js`中删除`ExercisesNavController`的定义。
- en: 'Replace the content of `left-nav-exercises.html` (located in the `partials`
    folder) with:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 将`left-nav-exercises.html`（位于`partials`文件夹中）的内容替换为：
- en: '[PRE56]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: And we are good to go.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们就可以开始了。
- en: Note that we do not get rid of `left-nav-exercises.html` as AngularJS still
    loads `left-nav-exercises.html` as part of the route transition, but the view
    inside is an Angular component.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有删除`left-nav-exercises.html`，因为AngularJS仍然将`left-nav-exercises.html`作为路由转换的一部分加载，但其中的视图是一个Angular组件。
- en: Go ahead and try out the new implementation. Create a new workout and try to
    add exercises from the left nav. The functionality should work as before.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，尝试一下新的实现。创建一个新的锻炼，并尝试从左侧导航中添加练习。功能应该和以前一样。
- en: Look at `ng6-checkpoint8.3` in case you are facing issues upgrading to Angular.
    You can compare the git branches `ng6-checkpoint8.2` and `ng6-checkpoint8.3` to
    understand what has changed ([http://bit.ly/ng6be-compare-8-2-8-3](http://bit.ly/ng6be-compare-8-2-8-3)).
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在升级到Angular时遇到问题，请查看`ng6-checkpoint8.3`。你可以比较git分支`ng6-checkpoint8.2`和`ng6-checkpoint8.3`来了解发生了什么变化（[http://bit.ly/ng6be-compare-8-2-8-3](http://bit.ly/ng6be-compare-8-2-8-3)）。
- en: While we have only migrated a trivial component, this exercise highlights how
    easy it is to convert/downgrade an Angular component to the AngularJS directive
    and use it in an AngularJS view. The overall encapsulation of an Angular component
    makes this chore easy.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们只迁移了一个微不足道的组件，但这个练习突出了将Angular组件转换为AngularJS指令并用于AngularJS视图是多么容易。Angular组件的整体封装使得这项工作变得容易。
- en: 'This downgraded component can even take an input from the parent scope using
    the familiar Angular property binding syntax:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 这个降级组件甚至可以使用熟悉的Angular属性绑定语法从父作用域获取输入：
- en: '[PRE57]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Add to that, the event raised by the component can be subscribed by the AngularJS
    container scope too:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，组件引发的事件也可以由AngularJS容器作用域订阅：
- en: '[PRE58]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We now have an Angular component running inside AngularJS using services initially
    designed for AngularJS. A promising start to our migration journey!
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个Angular组件在AngularJS中运行，使用的是最初为AngularJS设计的服务。这是我们迁移之旅的一个有希望的起点！
- en: Before we move any further, it's time to highlight how this collaboration works
    and the rules of engagement.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，是时候强调这种协作是如何工作的以及参与规则了。
- en: Rules of engagement
  id: totrans-582
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参与规则
- en: The migration story from AngularJS to Angular is only possible because these
    frameworks can coexist, and possibly share data. There are some touch points where
    the boundaries can be crossed. To have a better sense of how a hybrid application
    works and what is achievable in such a setup, we need to understand the areas
    of collaboration between the two frameworks.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 从AngularJS迁移到Angular的迁移故事之所以可能，仅仅是因为这些框架可以共存，并且可能共享数据。有一些接触点，边界可以跨越。为了更好地理解混合应用程序的工作原理以及在这种设置中可以实现什么，我们需要了解两个框架之间的协作区域。
- en: 'There are three areas that need discussion:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个方面需要讨论：
- en: Template interleaving in the DOM
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOM中的模板交错
- en: Dependency injection
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Change detection
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更检测
- en: Since Angular components and AngularJS directives can coexist in a DOM, the
    question we need to answer is who owns what parts of the DOM?
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Angular组件和AngularJS指令可以在DOM中共存，我们需要回答的问题是DOM的哪些部分属于谁？
- en: AngularJS directives and Angular components
  id: totrans-589
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AngularJS指令和Angular组件
- en: 'When it comes to ownership of a DOM element, the golden rule is:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到DOM元素的拥有权时，黄金规则是：
- en: Every DOM element is owned/managed by exactly one of the Angular frameworks.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 每个DOM元素恰好由Angular框架中的一个拥有/管理。
- en: Take our previous migration example. The view that is part of `ExercisesNavComponent`
    is managed by Angular, whereas the container view (`left-nav-exercises.html`)
    is managed by AngularJS.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们之前的迁移示例为例。`ExercisesNavComponent`的一部分视图由Angular管理，而容器视图（`left-nav-exercises.html`）则由AngularJS管理。
- en: 'Things get a bit tricky at the boundaries of these directives and components.
    Consider the declaration inside `left-nav-exercises.html`:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些指令和组件的边界处，事情会变得有些棘手。考虑`left-nav-exercises.html`内部的声明：
- en: '[PRE59]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Who owns this? The short answer is AngularJS.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 这属于谁？简短的答案是AngularJS。
- en: 'While this is an Angular component, the host element is owned by AngularJS.
    This means all AngularJS template syntax works:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个Angular组件，但宿主元素属于AngularJS。这意味着所有AngularJS模板语法都适用：
- en: '[PRE60]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As these components and directives coexist in the same view, they often need
    to communicate. There are two ways to manage this communication:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些组件和指令在同一个视图中共存，它们通常需要通信。有两种方式来管理这种通信：
- en: 'Using the templating capabilities of AngularJS and Angular:'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AngularJS和Angular的模板功能：
- en: An Angular component embedded inside an AngularJS view can take inputs from
    the parent scope using event and property binding
  id: totrans-600
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个嵌入在AngularJS视图中的Angular组件可以使用事件和属性绑定从父作用域获取输入
- en: In a similar fashion, if a directive is injected into an Angular component view,
    it too can get inputs from the parent component and call the parent component
    function (through its isolated scope)
  id: totrans-601
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以类似的方式，如果指令被注入到Angular组件视图中，它也可以从父组件获取输入并调用父组件函数（通过其隔离作用域）
- en: Using shared services; we saw an example of this previously as we injected the
    `WorkoutService` and `WorkoutBuilderService` AngularJS services into `ExercisesNavComponent`
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用共享服务；我们之前已经看到了一个例子，我们将`WorkoutService`和`WorkoutBuilderService` AngularJS服务注入到`ExercisesNavComponent`
- en: Injecting AngularJS directives into Angular is a bit tricky. To be able to inject
    an AngularJS directive into an Angular template, the directive needs to abide
    by some rules. We will talk about these rules in the coming sections.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 将AngularJS指令注入到Angular中有些棘手。为了能够将AngularJS指令注入到Angular模板中，该指令需要遵守一些规则。我们将在接下来的章节中讨论这些规则。
- en: Sharing functionality using services is far more flexible compared to sharing
    through view templates. Injecting services across framework boundaries requires
    us to register the service across both frameworks and let Angular take care of
    the rest. Let's learn how dependency injection works across boundaries.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务共享功能比通过视图模板共享要灵活得多。在框架边界之间注入服务需要我们在两个框架中注册该服务，并让Angular处理其余部分。让我们学习如何跨边界进行依赖注入。
- en: Resource sharing and dependency injection
  id: totrans-605
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源共享和依赖注入
- en: How dependencies are registered in a hybrid app is driven by how DI works in
    these two frameworks. For AngularJS, there is only one global injector, whereas
    Angular has a concept of hierarchical injectors. In a hybrid environment, the
    least common denominator is the global injector that both the frameworks support.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在混合应用中，依赖是如何注册的由这两个框架中的DI（依赖注入）工作方式驱动。对于AngularJS，只有一个全局注入器，而Angular有一个分层注入器的概念。在混合环境中，两个框架都支持的最低共同点是全局注入器。
- en: Sharing an AngularJS service
  id: totrans-607
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享AngularJS服务
- en: As we saw in the factory provider example earlier, AngularJS services can be
    registered with Angular by creating a wrapper factory provider.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在之前的工厂提供者示例中看到的那样，AngularJS服务可以通过创建包装工厂提供者来注册到Angular中。
- en: Since dependency injection in AngularJS is string token-based, the corresponding
    providers too use string tokens to locate dependencies in Angular.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 由于AngularJS中的依赖注入基于字符串标记，相应的提供者也使用字符串标记在Angular中定位依赖项。
- en: 'Looking back at the example of dependency registration share earlier, the dependency
    was registered with a help of a helper class:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下之前提到的依赖注册共享示例，依赖是通过一个辅助类来注册的：
- en: '[PRE61]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And it was injected using the `Inject` decorator (with a string token):'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 它是通过`Inject`装饰器（带字符串标记）注入的：
- en: '[PRE62]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Sharing an Angular service
  id: totrans-614
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享Angular服务
- en: 'Services from Angular too can be injected into AngularJS. Since AngularJS only
    has a global injector, the dependency is registered at the global level. The `ngUpgrade`
    library has a `downgradeInjectable` function for this. The `downgradeInjectable` function
    creates a factory function than can be consumed by the AngularJS module''s `factory`
    API:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Angular的服务也可以注入到AngularJS中。由于AngularJS只有一个全局注入器，依赖在全局级别注册。`ngUpgrade`库有一个`downgradeInjectable`函数用于此。`downgradeInjectable`函数创建一个可以被AngularJS模块的`factory`
    API消费的工厂函数：
- en: '[PRE63]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`MyService` can now be injected across the AngularJS app, like any other service.'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyService`现在可以像任何其他服务一样注入到AngularJS应用中。'
- en: 'Look at the following diagram; it summarizes what we have discussed:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的图表；它总结了我们所讨论的内容：
- en: '![](img/00088.jpeg)'
  id: totrans-619
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00088.jpeg)'
- en: One last topic of this discussion is change detection.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 本讨论的最后一个主题是变更检测。
- en: Change detection
  id: totrans-621
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变更检测
- en: In a hybrid application, change detection is managed by Angular. If we are used
    to calling `$scope.$apply()` in our code, we don't need to do it in a hybrid application.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 在混合应用中，变更检测由Angular管理。如果我们习惯在代码中调用`$scope.$apply()`，那么在混合应用中我们就不需要这样做。
- en: We have already discussed how Angular change detection works. The Angular framework
    takes care of triggering AngularJS change detection by internally calling `$rootScope.$apply()`
    on standard triggering points.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了Angular的变更检测是如何工作的。Angular框架通过在标准触发点上内部调用`$rootScope.$apply()`来处理AngularJS的变更检测。
- en: Now that we understand the rules of engagement, it is easier to comprehend how
    things work, what's feasible, and what's not.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了参与规则，理解事物是如何运作的、什么是可行的以及什么不可行就变得容易多了。
- en: Let's set some bigger/meatier targets and migrate the start and finish pages
    of the v1 app.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设定一些更大/更有实质性的目标，并迁移v1应用的起始和结束页面。
- en: Migrating the start and finish pages
  id: totrans-626
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移起始和结束页面
- en: The finish page migration is easy to do, and I suggest you do it yourself. Create
    a folder called `finish` inside the `js` folder, and create two files, `finish.component.ts`
    and  `finish.component.html`. Implement the component by looking at the existing
    implementation (or copy it from `ng6-checkpoint8.4`).
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 结束页面的迁移很容易做，我建议你自己来做。在`js`文件夹内创建一个名为`finish`的文件夹，并创建两个文件，`finish.component.ts`和`finish.component.html`。通过查看现有实现（或从`ng6-checkpoint8.4`复制）来实现组件。
- en: Add the component to the `declarations` and `entryComponents` array on  `AppModule`
    (`app.module.ts`). And then, fix the route for the finish to load the finish component.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 将组件添加到`AppModule`（`app.module.ts`）的`declarations`和`entryComponents`数组中。然后，修复路由以加载结束组件。
- en: 'Remember to also downgrade `FinishComponent` using the `downgradeComponent`
    function (check `app.ts`) and to fix the AngularJS *finish route* to use the new
    directive:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 记得使用`downgradeComponent`函数（检查`app.ts`）降级`FinishComponent`，并修复AngularJS的*finish路由*以使用新的指令：
- en: '[PRE64]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Lastly, remember to delete the finish HTML template from the `partials/workout`
    folder.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，记得从`partials/workout`文件夹中删除完成HTML模板。
- en: If you are stuck in migrating the finish page, compare the `ng6-checkpoint8.3`
    and `ng6-checkpoint8.4` git branches to understand what has changed in the `8.4`
    branch ([http://bit.ly/ng6be-compare-8-3-8-4](http://bit.ly/ng2be-compare-8-3-8-4)).
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你卡在迁移完成页面上，比较`ng6-checkpoint8.3`和`ng6-checkpoint8.4`的git分支，以了解`8.4`分支中发生了什么变化（[http://bit.ly/ng6be-compare-8-3-8-4](http://bit.ly/ng2be-compare-8-3-8-4)）。
- en: The finish page was easy, the start page is not! While the start page seems
    to be an easy target, there are some challenges that require some head-scratching.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 完成页面很容易，起始页面则不然！虽然起始页面看起来是一个容易的目标，但有一些挑战需要一些思考。
- en: Look at the start page template (`partials/workout/start.html`); the biggest
    issue with the start page is that it uses a third-party library, *angular-translate*,
    to localize the content of the page. Since we are migrating the complete page/view
    to Angular, we need a mechanism to handle these AngularJS library dependencies.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 查看起始页面模板（`partials/workout/start.html`）；起始页面的最大问题是它使用第三方库*angular-translate*来本地化页面内容。由于我们将整个页面/视图迁移到Angular，我们需要一种机制来处理这些AngularJS库依赖。
- en: '*angular-translate* comes with a *filter* (*pipe* in the Angular world) and
    a directive, both named `translate`. Their job is to translate string tokens into
    localized string literals.'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '*angular-translate*包含一个*过滤器*（在Angular世界中称为*pipe*）和一个指令，两者都命名为`translate`。它们的工作是将字符串标记转换为本地化的字符串字面量。'
- en: If the *start* page becomes an Angular component, we need to convert the filter
    into an Angular pipe and, in some way, make the `translate` directive work in
    Angular.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*start*页面成为Angular组件，我们需要将过滤器转换为Angular管道，并以某种方式使`translate`指令在Angular中工作。
- en: 'We have at least these two choices to handle this migration scenario:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 我们至少有这两种选择来处理这种迁移场景：
- en: Create a new filter, also upgrade the v1 `translate` directive using `UpgradeModule`
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的过滤器，同时使用`UpgradeModule`升级v1版本的`translate`指令
- en: Find a suitable replacement for *angular-translate* in the Angular world
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular世界中找到一个合适的*angular-translate*替代品
- en: Although the first choice seems to be the easiest, it has some serious limitations.
    Angular imposes some stringent requirements around how a directive can be upgraded
    to Angular.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然第一个选择看起来似乎是最简单的，但它有一些严重的限制。Angular对指令如何升级到Angular有一些严格的要求。
- en: Upgrading an AngularJS directive does not mean the directive has been migrated.
    Angular instead allows us to use an AngularJS element directive as is inside Angular
    component views.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 升级AngularJS指令并不意味着指令已经迁移。Angular允许我们在Angular组件视图中直接使用AngularJS元素指令。
- en: AngularJS directive upgrade
  id: totrans-642
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AngularJS指令升级
- en: 'At times, the parts of an application may be migrated in a top-down fashion;
    a higher-order view is converted into a component. In such a case, instead of
    migrating all the custom directives that are part of the AngularJS view, we just
    upgrade them to Angular components using some interfaces and functions defined
    in the  `UpgradeModule`. The following diagram illustrates this migration path:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，应用程序的某些部分可能以自顶向下的方式迁移；一个高阶视图被转换成组件。在这种情况下，我们不需要迁移AngularJS视图中所有自定义指令，而是使用在`UpgradeModule`中定义的一些接口和函数将它们升级为Angular组件。以下图表展示了这个迁移路径：
- en: '![](img/00089.jpeg)'
  id: totrans-644
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00089.jpeg)'
- en: The Angular framework puts some restrictions on what can be upgraded to an Angular
    component. Here is an excerpt from the Angular migration guide.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: Angular框架对可以升级为Angular组件的内容有一些限制。以下是Angular迁移指南的摘录。
- en: 'To be Angular compatible, an AngularJS component directive should configure
    these attributes:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与Angular兼容，AngularJS组件指令应该配置以下属性：
- en: '`restrict: ''E''`. Components are usually used as elements.'
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restrict: ''E''`。组件通常用作元素。'
- en: '`scope: {}` - an isolate scope. In Angular, components are always isolated
    from their surroundings, and you should do this in AngularJS too.'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scope: {}` - 一个隔离作用域。在Angular中，组件总是与其周围环境隔离，你应在AngularJS中也这样做。'
- en: '`bindToController: {}`. Component inputs and outputs should be bound to the
    controller instead of using the `$scope`.'
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bindToController: {}`。组件输入和输出应该绑定到控制器而不是使用`$scope`。'
- en: '`controller and controllerAs`. Components have their own controllers.'
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controller and controllerAs`。组件有自己的控制器。'
- en: '`template or templateUrl`. Components have their own templates.'
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Component directives may also use the following attributes:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '`transclude: true/{}`, if the component needs to transclude content from elsewhere'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`require`, if the component needs to communicate with some parent component''s
    controller'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Component directives should not use the following attributes:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: '`compile`. This will not be supported in Angular.'
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace`: True. Angular never replaces a component element with the component
    template. This attribute is also deprecated in AngularJS.'
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`priority` and `terminal`. While AngularJS components may use these, they are
    not used in Angular and it is better not to write code that relies on them.'
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only AngularJS directives that can be upgraded to Angular are element directives,
    given that all other conditions are met.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: With this sizeable laundry list, upgrading an AngularJS directive to Angular
    is difficult when compared to an Angular component downgrade. More often than
    not, we have to do an actual code migration of an AngularJS directive if the parent
    view has been migrated to Angular.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the `angular-translate` source code, we realize it uses the `$compile`
    service; therefore, the upgrade option is ruled out. We need to find an alternative
    library.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: We do have an internationalization library for Angular, `ngx-translate` ([http://www.ngx-translate.com/](http://www.ngx-translate.com/)).
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: Replacing angular-translate with ngx-translate
  id: totrans-663
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*ngx-translate* is an internationalization library that targets Angular. This
    library can replace v1 *angular-translate*.'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the npm package for `ngx-translate` and `ngx-translate/http-loader`:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The *http-loader* loads the localization files from the server.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `systemjs.config.js` to include the `*ngx-translate*` library. Add entries
    to the `map` property:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'As described in the `ngx-translate` documentation, we need to configure the
    translate module and HTTP loader. Open `app.module.ts` and add the highlighted
    code:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The preceding provider declaration sets up a loader that loads the translation
    files (`.json`) from the `i18n` folder. The `HttpClientModule` import is required
    for the translate library to load translations from the server. Remember to copy
    the translation files (`*.json`) from git branch `ng6-checkpoint8.4` ([http://bit.ly/ng6be-8-4-i18n](http://bit.ly/ng6be-8-4-i18n)).
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these import statements to `app.module.ts` to keep the TypeScript compiler
    happy:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `ngx-translate` library is now ready to be used. The first thing that we
    are going to do is set the default translation language as soon as the application
    bootstraps.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: Using ngDoBootstrap for initialization
  id: totrans-676
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Angular, luckily the `AppModule` already defines a function, `ngDoBootstrap`,
    that the framework calls when bootstrapping an AngularJS application—a perfect
    place to do `ngx-translate` initialization. Update the `ngDoBootstrap` function
    in `app.module.ts` with the following code snippet:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The code tries to determine the current browser language and sets the current
    language for translations accordingly. Make note of how we get hold of `TranslateService`.
    The `UpgradeModule` object holds the reference to Angular's *root injector*, which
    in turn loads `TranslateService` from `ngx-translate`.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 代码尝试确定当前浏览器的语言，并根据此设置当前翻译语言。注意我们是如何获取`TranslateService`的。`UpgradeModule`对象持有Angular的*root
    injector*的引用，它反过来从`ngx-translate`加载`TranslateService`。
- en: With the background work done for the start component, copy the start page implementation
    from the `ng6-checkpoint8.4` branch ([http://bit.ly/ng6be-8-4-start](http://bit.ly/ng6be-8-4-start))
    into a new folder `app/js/start`.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成起始组件的背景工作后，将`ng6-checkpoint8.4`分支中的起始页实现复制到新的文件夹`app/js/start`中。
- en: Then, add the start component declaration to `app.module.ts`.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将起始组件声明添加到`app.module.ts`中。
- en: 'Like other components registered as an AngularJS directive before use, add
    this statement to `app.ts`:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 如同之前注册为AngularJS指令的其他组件一样，将此语句添加到`app.ts`中：
- en: '[PRE70]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The start template file now uses the `translate` pipe (the name of the pipe
    is the same as the AngularJS filter `translate`).
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 起始模板文件现在使用`translate`管道（管道的名称与AngularJS过滤器`translate`的名称相同）。
- en: 'The start page also has three pipes, `search`, `orderBy`, and `secondsToTime`:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 起始页也有三个管道，`search`、`orderBy`和`secondsToTime`：
- en: '[PRE71]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Copy the implementation for these pipes together with the definition of the
    shared module (`shared.module.ts`) from `ng6-checkpoint8.4` ([http://bit.ly/ng6be-8-4-shared](http://bit.ly/ng6be-8-4-shared))
    and add it to the `js/shared` folder locally. Also, remember to import the shared
    module (`shared.module.ts`) into the app module (`app.module.ts`). We will not
    dwell on any of the pipe implementation here, as we have done that already in
    earlier chapters.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些管道的实现以及共享模块的定义（`shared.module.ts`）从`ng6-checkpoint8.4`（[http://bit.ly/ng6be-8-4-shared](http://bit.ly/ng6be-8-4-shared)）复制到本地`js/shared`文件夹中。同时，记得将共享模块（`shared.module.ts`）导入到应用模块（`app.module.ts`）。在这里，我们不会详细讨论管道的实现，因为我们已经在前面的章节中讨论过了。
- en: Start and finish component implementation is complete. Let's integrate them
    into the app.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 起始和结束组件实现已完成。让我们将它们集成到应用中。
- en: Integrating the start and finish pages
  id: totrans-689
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整合起始页和结束页
- en: 'Start/finish views are loaded as part of route change, so we need to fix the
    route definition in `config.js`. Update the start and finish route definitions
    to:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 起始/结束视图作为路由更改的一部分加载，因此我们需要修复`config.js`中的路由定义。更新起始和结束路由定义如下：
- en: '[PRE72]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The route template HTML is a part of the AngularJS view. Since we have registered
    both `StartComponent` and `FinishComponent` as AngularJS directives, the route
    loads the correct components.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 路由模板HTML是AngularJS视图的一部分。由于我们已经将`StartComponent`和`FinishComponent`注册为AngularJS指令，所以路由会加载正确的组件。
- en: If you have already migrated the finish page, you do not need to redo the route
    setup for finish as described.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经迁移了结束页，你不需要重新执行结束页的路由设置，如描述的那样。
- en: A few more fixes are pending before we can test the implementation.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以测试实现之前，还有一些修复工作要做。
- en: Remember to copy the translation files `de.json` and `en.json` from the `ng6-checkpoint8.4`
    folder `i18n` ([http://bit.ly/ng6-8-4-i18n](http://bit.ly/ng6be-8-4-i18n)). Now,
    we are ready to test what we have developed.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将翻译文件`de.json`和`en.json`从`ng6-checkpoint8.4`文件夹的`i18n`（[http://bit.ly/ng6-8-4-i18n](http://bit.ly/ng6be-8-4-i18n)）复制过来。现在，我们准备好测试我们所开发的内容了。
- en: If not started, start the TypeScript compiler and HTTP-server, and then launch
    the browser. The start and finish pages should load just fine. But the translations
    do not work! Clicking on the language translation links on the top nav has no
    effect. Content always renders in English.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未启动，启动TypeScript编译器和HTTP服务器，然后打开浏览器。起始页和结束页应该可以正常加载。但是翻译没有工作！点击顶部导航的语言翻译链接没有任何效果。内容始终以英语渲染。
- en: We now are at checkpoint `ng6-checkpoint8.4`. If you are stuck, compare the
    git branches `ng6-checkpoint8.3` and `ng6-checkpoint8.4` to understand what changed
    ([http://bit.ly/ng6be-compare-8-3-8-4](http://bit.ly/ng6be-compare-8-3-8-4)).
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在处于`ng6-checkpoint8.4`检查点。如果你遇到了困难，比较git分支`ng6-checkpoint8.3`和`ng6-checkpoint8.4`来了解发生了什么变化（[http://bit.ly/ng6be-compare-8-3-8-4](http://bit.ly/ng6be-compare-8-3-8-4)）。
- en: The translations still do not work because the top nav code (`root.js`) that
    enables translation is still using the older library. We need to get rid of angular-translate
    (the v1 library) altogether. Having two libraries doing the same work is not something
    we want, but removing it is also not that simple.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译仍然不起作用，因为启用翻译的顶部导航代码（`root.js`）仍在使用较旧的库。我们需要完全去除 angular-translate（v1 库）。有两个库做相同的工作不是我们想要的，但移除它也不是那么简单。
- en: Getting rid of angular-translate
  id: totrans-699
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去除 angular-translate
- en: 'To get rid of the angular-translate (v1) library, we need to:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 要去除 angular-translate（v1）库，我们需要：
- en: Remove the angular-translate's directive/filter references from all AngularJS
    views
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从所有 AngularJS 视图中移除 angular-translate 的指令/过滤器引用
- en: Get rid of any code that uses this library
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去除任何使用此库的代码
- en: Getting rid of the v1 directive/filter altogether is a difficult task. No can
    we use the v2 `ngx-translate` pipe in the AngularJS view. Also, migrating every
    view using the v1 translate directive/filter to Angular at one shot is feasible.
    There has to be a better solution out there? And there is!
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 完全去除 v1 指令/过滤器的任务很困难。我们也不能在 AngularJS 视图中使用 v2 `ngx-translate` 管道。此外，一次性将所有使用
    v1 翻译指令/过滤器的视图迁移到 Angular 也是可行的。肯定有更好的解决方案！而且确实有！
- en: Why not write a new AngularJS filter that uses ngx-translate's translation service
    (`TranslateService`) for translations and then use the new filter everywhere?
    Problems solved!
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不编写一个新的 AngularJS 过滤器，该过滤器使用 ngx-translate 的翻译服务（`TranslateService`）进行翻译，然后在整个地方使用新的过滤器？问题解决了！
- en: Let's call this filter `ngxTranslate`. We replace all references to the `translate`
    filter in the v1 view with `ngxTranslate`. All v1 `translate` directive references
    too are replaced with an `ngxTranslate` filter.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 我们把这个过滤器称为 `ngxTranslate`。我们将 v1 视图中所有对 `translate` 过滤器的引用替换为 `ngxTranslate`。所有
    v1 `translate` 指令的引用也替换为 `ngxTranslate` 过滤器。
- en: 'Here is how the filter implementation looks:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器的实现如下：
- en: '[PRE73]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Create a file called `ngx-translate.filter.ts` in the `shared` folder and add
    the preceding implementation. The filter uses `TranslateService` to localized
    content. To make the service discoverable in AngularJS, it needs to be downgraded
    using the `ngUpgrade` module method `downgradeInjectable`. Open  `app.ts` and
    add the following lines:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `shared` 文件夹中创建一个名为 `ngx-translate.filter.ts` 的文件，并添加前面的实现。过滤器使用 `TranslateService`
    来本地化内容。为了使服务在 AngularJS 中可发现，需要使用 `ngUpgrade` 模块的 `downgradeInjectable` 方法降级。打开
    `app.ts` 并添加以下行：
- en: '[PRE74]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This code registers `TranslateService` using a string token, `'TranslateService'`,
    in AngularJS. The first import statement also loads the new filter at runtime.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用 AngularJS 中的字符串标记 `'TranslateService'` 注册 `TranslateService`。第一个导入语句也在运行时加载了新的过滤器。
- en: To test this implementation, there are a few more steps needed.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个实现，还需要进行几个额外的步骤。
- en: 'To start with, replace all references to `translate` (directive and filter)
    across the AngularJS view with `ngxTranslate`. There are references in these files:
    `description-panel.html`, `video-panel.html`, `workout.html` (in the folder `partials/workout`),
    and `index.html`. Replacing the filter in the interpolation is a simple exercise.
    For the `translate` directive, replace it with interpolation. For example, in
    `partials/workout/description-panel.html`, the line of code is as follows:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 AngularJS 视图中所有对 `translate`（指令和过滤器）的引用替换为 `ngxTranslate`。这些文件中有引用：`description-panel.html`、`video-panel.html`、`workout.html`（在
    `partials/workout` 文件夹中），以及 `index.html`。在插值中替换过滤器是一个简单的练习。对于 `translate` 指令，用插值替换它。例如，在
    `partials/workout/description-panel.html` 中，代码行如下：
- en: '[PRE75]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'It then becomes the following:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它变成以下形式：
- en: '[PRE76]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Remember to quote the string token (`'RUNNER.STEPS'`) inside the interpolation.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在插值中引用字符串标记（`'RUNNER.STEPS'`）时加上引号。
- en: Finally, copy the updated `root.js` from [http://bit.ly/ng6be-8-5-root-js](http://bit.ly/ng6be-8-5-root-js).
    We have replaced all references to the `$translate` service with `TranslateService` and
    refactored the code to use the new service. `root.js` contains the implementation
    for the v1 `RootController`.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从 [http://bit.ly/ng6be-8-5-root-js](http://bit.ly/ng6be-8-5-root-js) 复制更新的
    `root.js`。我们已经将所有对 `$translate` 服务的引用替换为 `TranslateService`，并将代码重构为使用新的服务。`root.js`
    包含 v1 `RootController` 的实现。
- en: We are good to go now. Try out the new implementation; the app should load translation
    using the *ngx-translate* library.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了。尝试新的实现；应用应该会使用 *ngx-translate* 库加载翻译。
- en: We can now delete all references to *angular-translate*. There are references
    in `index.html`, `app-ng1.module.ts`, and `config.js`.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以删除所有对 *angular-translate* 的引用。在 `index.html`、`app-ng1.module.ts` 和 `config.js`
    中都有引用。
- en: The migration of the start and finish pages is complete.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 起始和结束页面的迁移已完成。
- en: Compare the branches `ng6-checkpoint8.4` and `ng6-checkpoint8.5` to understand
    the new changes in `ng6-checkpoint8.5` ([http://bit.ly/ng6be-compare-8-4-8-5](http://bit.ly/ng2be-compare-8-4-8-5)).
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 比较分支`ng6-checkpoint8.4`和`ng6-checkpoint8.5`，以了解`ng6-checkpoint8.5`中的新更改（[http://bit.ly/ng6be-compare-8-4-8-5](http://bit.ly/ng2be-compare-8-4-8-5)）。
- en: We will stop here and direct you to the other GitHub branches pertaining to
    migration. All branches starting with `ng6-checkpoint*` are the migration branches.
    Try to migrate the pending views and compare them with the GitHub branch changes.
    Remember, a working version of the app has already been developed in Angular,
    and hence there is a good reference point. Look at the `README.md` file for each
    branch to know what part of the application was migrated to Angular.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里停止，并将您引导到其他与迁移相关的GitHub分支。所有以`ng6-checkpoint*`开头的分支都是迁移分支。尝试迁移挂起的视图，并将它们与GitHub分支的更改进行比较。记住，已经在Angular中开发了一个应用程序的工作版本，因此有一个很好的参考点。查看每个分支的`README.md`文件，以了解应用程序的哪个部分被迁移到了Angular。
- en: Meanwhile, let's summarize our learnings from the migration that we did.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，让我们总结我们从迁移中学到的经验。
- en: Learning
  id: totrans-724
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习
- en: 'We hope this migration exercise has provided enough insight into the process.
    You can now gauge the complexity, the time, and the effort required to migrate
    elements from AngularJS to Angular. Let''s highlight what we have learned as part
    of this process:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这次迁移练习已经提供了足够的过程洞察。你现在可以评估从AngularJS迁移到Angular所需复杂性、时间和努力。让我们强调在这个过程中我们学到了什么：
- en: '**Migration is time-consuming**: Migration is by no stretch of the imagination
    a trivial exercise. Each page/view presents its own challenges that we need to
    overcome. Some elements are easy to migrate and some are not. The best thing you
    can do today if you are developing in AngularJS would be to follow the advice
    from the *Developing AngularJS apps today for easy migration* section.'
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迁移耗时**：从想象中，迁移绝对不是一项微不足道的练习。每个页面/视图都提出了我们需要克服的挑战。一些元素容易迁移，而一些则不然。如果你正在开发AngularJS，今天你能做的最好的事情就是遵循*今天开发AngularJS应用程序以方便迁移*部分的建议。'
- en: '**Migrate third-party libraries first**: Migrating third-party libraries can
    be quite challenging. The reasons are manifold:'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**首先迁移第三方库**：迁移第三方库可能相当具有挑战性。原因有很多：'
- en: Such libraries are used across pages
  id: totrans-728
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这样的库被跨页面使用
- en: They may not be upgradable to Angular (using `UpgradeAdapter`)
  id: totrans-729
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能无法升级到Angular（使用`UpgradeAdapter`）
- en: Migrating each view that uses such a library may not be feasible when the library
    is extensively used
  id: totrans-730
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当库被广泛使用时，迁移使用此类库的每个视图可能不可行
- en: It's better to identify all third-party dependencies in your app and find a
    suitable alternative for them in the Angular world. If possible, develop some
    **proof of concept** (**POC**) with the new library to understand how different
    the new library is from the existing implementation.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 最好识别您应用程序中的所有第三方依赖项，并在Angular世界中找到它们的合适替代品。如果可能，使用新库开发一些**概念验证**（**POC**），以了解新库与现有实现的不同之处。
- en: '**Libraries with overlap may exist**: While migrating, there could be scenarios
    where both AngularJS and Angular versions of a library coexist. Minimize this
    time period and migrate to the newer version as soon as possible.'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存在重叠的库**：在迁移过程中，可能会出现AngularJS和Angular版本的库共存的情况。尽量缩短这个时间段，并尽快迁移到新版本。'
- en: '**It is easier to integrate Angular components into AngularJS than the other
    way round**: While migrating, migrate the complete view to Angular. Due to the
    restriction imposed by Angular, it becomes very difficult to have a parent Angular
    component with embedded AngularJS element directives. With such limitations, a
    bottom-up approach to migrating works better than a top-down approach.'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将Angular组件集成到AngularJS中比反过来更容易**：在迁移过程中，将完整视图迁移到Angular。由于Angular的限制，拥有一个包含AngularJS元素指令的父Angular组件变得非常困难。在这种限制下，自下而上的迁移方法比自上而下的方法更有效。'
- en: '**Anything non-UI-related is easy to migrate**: For *Personal Trainer*, we
    migrate the services last as they can be easily migrated.'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与UI无关的内容迁移起来很容易**：对于*Personal Trainer*，我们最后迁移服务，因为它们可以很容易地迁移。'
- en: '**Feature parity better AngularJS and Angular**: Angular may not have every
    feature that AngularJS supports. In such a case, we need workarounds to achieve
    the desired behavior.'
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持AngularJS和Angular的功能一致性**：Angular可能没有AngularJS支持的所有功能。在这种情况下，我们需要找到解决方案来实现所需的行为。'
- en: That completes our migration story. With this, it's time to conclude the chapter
    and summarize our lessons from it.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的迁移故事。有了这个，是时候结束这一章节并总结我们从中学到的经验教训。
- en: Summary
  id: totrans-737
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we gained some useful insight into a number of practical issues
    surrounding Angular development. These tips/guidelines can be extremely handy
    when building real-life applications using the framework.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们对围绕Angular开发的一些实际问题获得了有用的见解。这些提示/指南在构建使用该框架的实际应用程序时非常有用。
- en: We started the chapter by exploring the concept of *seed projects* and how these
    projects can get us up and running in no time. We looked at some popular seed
    projects that can serve as a base for any new Angular app development.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从探索*种子项目*的概念开始这一章节，并了解了这些项目如何让我们迅速启动。我们查看了一些可以作为任何新Angular应用程序开发基础的流行种子项目。
- en: In spite of being a server-side concern, authentication and authorization do
    affect the client implementation. The section on authentication/authorization
    covered how to handle authentication in both cookie- and token-based setups.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管认证和授权是服务器端的问题，但它们确实会影响客户端实现。关于认证/授权的部分涵盖了如何在基于cookie和基于token的设置中处理认证。
- en: We looked at the ever-so-important topic of performance, where you learned ways
    to optimize an Angular app's performance.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了至关重要的性能主题，你学习了优化Angular应用程序性能的方法。
- en: Finally, we migrated the v1 *Personal Trainer* to Angular. The gradual migration
    process taught us the intricacies of migration, the challenges faced, and the
    workaround done.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将v1版本的*个人教练*迁移到了Angular。逐步迁移的过程教会了我们迁移的复杂性、面临的挑战以及采取的解决方案。
- en: The book is coming to a close, but for everyone reading it, the journey has
    just begun. It's time to put theories into practice, hone our newly acquired skills,
    build something useful with Angular, and share it with the world. The more you
    invest in Angular, the more rewarding the framework is. Let's get started!
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍即将结束，但对于每一位阅读它的人来说，旅程才刚刚开始。现在是时候将理论付诸实践，磨练我们新获得的技术，用Angular构建一些有用的东西，并与世界分享。你投入Angular越多，这个框架就越有回报。让我们开始吧！
