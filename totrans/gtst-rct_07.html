<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;7.&#xA0;Making Your Component Reusable"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. Making Your Component Reusable</h1></div></div></div><p class="calibre7">Until now, we have dug into React's components' lifecycle, properties, state, and ECMAScript with respect to React 0.1.13 and future versions. In this chapter, we will also see how we can write reusable components/code in React applications. Such reusable components in React are named Mixins. Furthermore, we will explore how the React component's properties can be validated.</p><p class="calibre7">The following topics to be covered in this chapter:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Understanding mixins</li><li class="listitem">A higher order component in ECMA6 (as Mixin is not supported in ECMA6)</li><li class="listitem">Different types of validations in a React application</li><li class="listitem">The structure of a React component and application's architecture</li></ul></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Making Your Component Reusable">
<div class="book" title="Understanding Mixins"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec37" class="calibre1"/>Understanding Mixins</h1></div></div></div><p class="calibre7">The Mixins (reusable components) are typically those React components that are<a id="id226" class="calibre1"/> used in multiple places and thus can be reused. Typically, the design elements, such as buttons, layout components, form fields, or any code logic/computation, that are used more than once are extracted in code named Mixin. Thus, Mixins help us incorporate some additional functionalities to existing React components by acting as helpers.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note27" class="calibre1"/>Note</h3><p class="calibre7">Like in the previous chapters , the index.html content remains the same. Only the contents of the corresponding js (having the React components) changes.</p></div></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Making Your Component Reusable">
<div class="book" title="Understanding Mixins">
<div class="book" title="Exploring Mixins by example"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec48" class="calibre1"/>Exploring Mixins by example</h2></div></div></div><p class="calibre7">In this <a id="id227" class="calibre1"/>example we are setting the interval of the window global objects for every 100 ms:</p><p class="calibre7">Content of index.html:</p><div class="informaltable"><pre class="programlisting">&lt;!DOCTYPE html&gt;
            &lt;html&gt;
&lt;head&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0-rc1/react.min.js"&gt;&lt;/script&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/JSXTransformer.js"&gt;&lt;/script&gt;
  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0-rc1/react-dom.js"&gt;&lt;/script&gt;
  
&lt;meta charset="utf-8"&gt;
  &lt;title&gt;JS Bin&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="myReactContainer"&gt;
        &lt;script type="text/jsx", src="index.js"&gt;&lt;/script&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">Content of index.js:</p><div class="informaltable"><pre class="programlisting">//Defining the Mixin
 . var ReactMixin = {
 . getInitialState:function(){
 .    return {count:0};
 .  },

// componentWillMount, a  lifecycle method, is added as a part of the Mixin.
 . componentWillMount:function(){
    console.log('Component will mount!');
  },
  increaseCountBy10: function(){
    this.setState({count: this.state.count+10})
 }
  }


//This method displays text to display
     var App = React.createClass({
  render:function(){
   return (
     &lt;div&gt;
     &lt;Label txt="SetInterval increase by 10 in every 100ms" /&gt;
        &lt;/div&gt;
     )
  }
  });

// React component (&lt;Label /&gt;), called from the &lt;App /&gt; component.
  var Label = React.createClass({

// Mixins are called using the keyword Mixin, followed by the Mixin name within an array.
  mixins:[ReactMixin],
  componentWillMount:function(){

    //setting the interval to 100ms
       interval = setInterval(this.increaseCountBy10,100);
  },

//The function is called for the second time to update the interval every 100ms
  componentWillUnMount:function(){
  clearInterval(this.interval);
  },
  render:function(){
   return &lt;label&gt;{this.props.txt} : {this.state.count}&lt;/label&gt;
  }
 });

ReactDOM.render(&lt;App /&gt;, document.getElementById('myReactContainer'));</pre></div><div class="informaltable" title="Note"><h3 class="title2"><a id="note28" class="calibre1"/>Note</h3><p class="calibre7">Run the httpserver from the application's root dir:</p><div class="informaltable"><pre class="programlisting">
<span class="strong"><strong class="calibre8">doel@doel-Vostro-3500:~/reactjs/ch7_mixins_validationProps/app1_mixin$ httpster</strong></span>
<span class="strong"><strong class="calibre8">Starting HTTPster v1.0.1 on port 3333 from /home/doel/reactjs/ch7_mixins_validationProps/app1_mixin</strong></span>
</pre></div></div><p class="calibre7">The <a id="id228" class="calibre1"/>following is the output for this code on opening <code class="literal">localhost:3333</code>:</p><div class="mediaobject"><img src="../images/00039.jpeg" alt="Exploring Mixins by example" class="calibre9"/><div class="caption"><p class="calibre25">The app screenshot using Mixin with a lifecycle method</p></div></div><p class="calibre10"> </p><p class="calibre7">The explanation of the executed code:</p><p class="calibre7">A mixin is nothing but a JavaScript object, which can be reused within the React component later. We begin with defining the Mixin.</p><p class="calibre7">The <code class="literal">componentWillMount</code> is a lifecycle method, which is added as a part of the Mixin. Later, when the Mixin is called from the react component, the log from <code class="literal">console.log</code> can be seen in the bottom part of the developer tool portion of the webpage to present <span class="strong"><strong class="calibre8">Component Will Mount</strong></span>.</p><p class="calibre7">We add a typical react component (<code class="literal">&lt;App /&gt;</code>), which calls the <code class="literal">&lt;Label /&gt;</code> component. It's a render function, which displays the text presented on the label. The App component can have multiple react components, which will internally call different react components.</p><p class="calibre7">In the next example, we will see such an example.</p><p class="calibre7">React component <code class="literal">(&lt;Label /&gt;</code>) is called from the <code class="literal">&lt;App /&gt;</code> component. It's using the React Mixin (ReactMixin).</p><p class="calibre7">In line mixins:[ReactMixin], Mixins in React, are called using the keyword Mixin, followed by the Mixin name (ReactMixin in this case), within an array. We can define multiple Mixins, as JavaScript objects. All these separate Mixins can then be called from a single React component (each Mixin representing a separate element in an array).</p><p class="calibre7">We will<a id="id229" class="calibre1"/> explore such an example, with multiple Mixins, later in the chapter.</p><p class="calibre7">We then add the <code class="literal">setInterval()</code> function</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">The setInterval</code>() method is a window function in JavaScript.</li><li class="listitem">It's declared as <code class="literal">window.setInterval(function, milliseconds)</code>.</li><li class="listitem">Although it's a method based on window object, but it's not necessary to call the <code class="literal">setInterval()</code> method on the window object, such as in the previously mentioned code. It can be called without the window prefix.</li><li class="listitem">The first parameter is the function that gets executed (<code class="literal">this.increaseCountBy10</code>).</li><li class="listitem">The second parameter is the interval of time between executions of each of the function, <code class="literal">this.increaseCountBy10</code>. The interval is set to <code class="literal">100ms</code> in this case.</li></ul></div><p class="calibre7">The lifecycle method (<code class="literal">componentWillMount</code>) is then called for the second time in the previously mentioned code. For the first time, it is called within the Mixin body, which logs the <code class="literal">Component Will Mount</code> on the log.</p><p class="calibre7">For the second time, it is called within the React component (<code class="literal">&lt;Label /&gt;</code>). Due to the second call, the <code class="literal">setInterval()</code> method is incrementing the value from <code class="literal">0</code> (count set to <code class="literal">0</code> initially) to <code class="literal">10</code>, in each <code class="literal">100</code> ms.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note29" class="calibre1"/>Note</h3><p class="calibre7">Take a <a id="id230" class="calibre1"/>look at the Facebook documentation <a class="calibre1" href="https://facebook.github.io/react/docs/reusable-components.html">https://facebook.github.io/react/docs/reusable-components.html</a>:</p><p class="calibre7">"A nice feature of Mixins is that if a component is using multiple Mixins and several Mixins define the same lifecycle method (i.e. several Mixins want to do some clean up when the component is destroyed), all of the lifecycle methods are guaranteed to be called. Methods defined on Mixins run in the order Mixins were listed, followed by a method call on the component."</p></div><p class="calibre7">We will see another example of Mixins in the next section:</p><div class="informaltable"><pre class="programlisting">Calling Multiple Mixins from a single React Component</pre></div><p class="calibre7">We shall now see another example where multiple Mixin will be called from a single React component. The following code is declared:</p><p class="calibre7">First, we <a id="id231" class="calibre1"/>shall declare two react Mixins:</p><div class="informaltable"><pre class="programlisting">var ReactMixin1= {

     getDefaultProps: function () {

        return {text1: "I am from first Mixin"};

    }

};

var ReactMixin2 = {

      getDefaultProps: function () {

        return {text2: "I am from second Mixin"};

    }

};</pre></div><p class="calibre7">In the Second part of the code, we will call both the React Mixins, from the react component <code class="literal">&lt;App /&gt;</code>:</p><div class="informaltable"><pre class="programlisting">var App = React.createClass({

  Mixins:[ReactMixin, ReactMixin2],

  render: function () {

    return (

    &lt;div&gt;

        &lt;p&gt;Mixin1: {this.props.text1} &lt;/p&gt;

        &lt;p&gt;Mixin2: {this.props.text2}&lt;/p&gt;

    &lt;/div&gt;

    );

  }

});



ReactDOM.render(&lt;App /&gt;, document.getElementById('myReactContainer'));
\\</pre></div><p class="calibre7">Execute <a id="id232" class="calibre1"/>the command httpster from application root directly like before to see the output from two Mixins:</p><div class="mediaobject"><img src="../images/00040.jpeg" alt="Exploring Mixins by example" class="calibre9"/><div class="caption"><p class="calibre25">The app screenshot using multiple Mixins</p></div></div><p class="calibre10"> </p><p class="calibre7">Note the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The same property name in both the Mixins, for example, <span class="strong"><strong class="calibre8">text</strong></span>, in this case, will throw an error</li><li class="listitem">The same method name within the different Mixins will throw an error</li><li class="listitem">The same lifecycle methods can be called both within Mixin and within a React component. The order of execution of these lifecycle methods is Mixin, followed by a React component.</li><li class="listitem">In case the same lifecycle method is called within different Mixins, then the order of <a id="id233" class="calibre1"/>execution is in the order in which the Mixins are called within the array [lower to higher index].</li></ul></div></div></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Making Your Component Reusable">
<div class="book" title="Understanding Mixins">
<div class="book" title="Higher-order components in Mixins"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec49" class="calibre1"/>Higher-order components in Mixins</h2></div></div></div><p class="calibre7">In ReactJS using ES6, Mixins are no longer supported. Instead of this, they have introduced higher order components.</p><p class="calibre7">These <a id="id234" class="calibre1"/>higher order components are widely used in the Relay framework, which is a complete React-based framework released by Facebook. The higher order component wraps up child UI components. Thus, these components when called will first execute its queries and thereby render the child UI component(s). When the query is passed, data is passed from the child component to the higher order component in as props.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Validations"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec38" class="calibre1"/>Validations</h1></div></div></div><p class="calibre7"><span class="strong"><strong class="calibre8">Validations</strong></span> are<a id="id235" class="calibre1"/> an integral part of any application dealing with user input. In ReactJS, there are some validations provided by the library that enables the developer to validate the data received.</p><p class="calibre7">Data are received mostly as properties (props) in react application. The various validators are exported from <code class="literal">React.PropTypes</code>. Any validation error, if occurs, will appear in the JavaScript console. Any such error occurring due to validation check will only occur in the development mode due to performance reasons.</p><p class="calibre7">Take<a id="id236" class="calibre1"/> a look at the Facebook ReactJS development team documentation <a class="calibre1" href="https://facebook.github.io/react/docs/reusable-components.html#prop-validation">https://facebook.github.io/react/docs/reusable-components.html#prop-validation</a>. The following is an example of the various validators:</p><div class="informaltable"><pre class="programlisting">React.createClass({
  propTypes: {
    // You can declare that a prop is a specific JS primitive. By default, these
    // are all optional.
    optionalArray: React.PropTypes.array,
    optionalBool: React.PropTypes.bool,
    optionalFunc: React.PropTypes.func,
    optionalNumber: React.PropTypes.number,
    optionalObject: React.PropTypes.object,
    optionalString: React.PropTypes.string,

    // Anything that can be rendered: numbers, strings, elements or an array
    // (or fragment) containing these types.
    optionalNode: React.PropTypes.node,

    // A React element.
    optionalElement: React.PropTypes.element,

    // You can also declare that a prop is an instance of a class. This uses
    // JS's instanceof operator.
    optionalMessage: React.PropTypes.instanceOf(Message),

    // You can ensure that your prop is limited to specific values by treating
    // it as an enum.
    optionalEnum: React.PropTypes.oneOf(['News', 'Photos']),

    // An object that could be one of many types
    optionalUnion: React.PropTypes.oneOfType([
      React.PropTypes.string,
      React.PropTypes.number,
      React.PropTypes.instanceOf(Message)
    ]),

    // An array of a certain type
    optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),

    // An object with property values of a certain type
    optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),

    // An object taking on a particular shape
    optionalObjectWithShape: React.PropTypes.shape({
      color: React.PropTypes.string,
      fontSize: React.PropTypes.number
    }),

    // You can chain any of the above with `isRequired` to make sure a warning
    // is shown if the prop isn't provided.
    requiredFunc: React.PropTypes.func.isRequired,

    // A value of any data type
    requiredAny: React.PropTypes.any.isRequired,

    // You can also specify a custom validator. It should return an Error
    // object if the validation fails. Don't `console.warn` or throw, as this
    // won't work inside `oneOfType`.
    customProp: function(props, propName, componentName) {
      if (!/matchme/.test(props[propName])) {
        return new Error('Validation failed!');
      }
    }
  },
  /* ... */
});</pre></div></div>

<div class="book" title="Validations">
<div class="book" title="An example using the isRequired validator"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec50" class="calibre1"/>An example using the isRequired validator</h2></div></div></div><p class="calibre7">The <code class="literal">index.html</code> page. Use<a id="id237" class="calibre1"/> different JS pages in order to check the different versions of the validations used:</p><div class="informaltable"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0-rc1/react.js"&gt;&lt;/script&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/JSXTransformer.js"&gt;&lt;/script&gt;
  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0-rc1/react-dom.js"&gt;&lt;/script&gt;
  &lt;script type="text/jsx", src="index4.js"&gt;&lt;/script&gt;

&lt;meta charset="utf-8"&gt;
  &lt;title&gt;JS Bin&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="myReactContainer"&gt;
        &lt;script type="text/jsx", src="index.js"&gt;&lt;/script&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">As the name of the validation suggests, the <code class="literal">isRequired</code> validator ensures that the property of the React component remains present. Otherwise, it will throw an error in the JS console. The <code class="literal">React.PropTypes.{foo}</code> properties are the JavaScript functions, which internally check whether a prop is valid or not. When the prop is valid, it will return <code class="literal">null</code>, but when the prop is invalid, then it returns an error. In <a class="calibre1" title="Chapter 4. Stateful Components and Events" href="part0029_split_000.html#page">Chapter 4</a>, <span class="strong"><em class="calibre12">Stateful Components and Events</em></span> we<a id="id238" class="calibre1"/> dug into ES6. In the next example, we will be using the ES6 syntax:</p><div class="informaltable"><pre class="programlisting">"use strict"

class App extends React.Component {

  render () {

    return (

      &lt;div className="app"&gt;

        &lt;h1 ref="title" className="app__title"&gt;&lt;/h1&gt;

        &lt;div ref="content" className="widget__content"&gt;{this.props.content}&lt;/div&gt;

      &lt;/div&gt;

    )

  }

}



App.propTypes = {

  title: React.PropTypes.string.isRequired,

  content: React.PropTypes.node.isRequired

}



ReactDOM.render(&lt;App content="I am learning react"/&gt;,document.getElementById('myReactContainer'));</pre></div><div class="informaltable" title="Note"><h3 class="title2"><a id="note30" class="calibre1"/>Note</h3><p class="calibre7">Run the httpster from your app's root dir in order to see the output in your browser's <code class="literal">localhost:3333</code></p></div><p class="calibre7">The output will be as shown here:</p><div class="mediaobject"><img src="../images/00041.jpeg" alt="An example using the isRequired validator" class="calibre9"/><div class="caption"><p class="calibre25">The app screenshot—the isRequired validation in the React component prop</p></div></div><p class="calibre10"> </p><p class="calibre7">A<a id="id239" class="calibre1"/> few points from the ES6 point of view with respect to the previously mentioned code:</p><p class="calibre7"><code class="literal">use strict</code> has<a id="id240" class="calibre1"/> been used opt in to a restricted variant of JavaScript. This is used as we are using let instead of var. <code class="literal">use strict</code> allows to place a component in a <code class="literal">strict</code> operating  context and  prevents certain  actions from being taken and  throws more exceptions.</p><p class="calibre7">let declares variables that are limited in scope to the block, statement, or expression on which it is used.</p><p class="calibre7">See the details at <a class="calibre1" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/</a>.</p></div></div>

<div class="book" title="Validations">
<div class="book" title="An example using custom validator"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec51" class="calibre1"/>An example using custom validator</h2></div></div></div><p class="calibre7">The<a id="id241" class="calibre1"/> following is the template, generally used while using custom validation in the code:</p><div class="informaltable"><pre class="programlisting">error = propTypes[propName](props, propName, componentName, location); </pre></div><p class="calibre7">Let's go through an example of our own with custom error messages and use a few of these <a id="id242" class="calibre1"/>validations and see how it validates in the JavaScript console:</p><div class="informaltable"><pre class="programlisting">var ValidationApp = React.createClass({

  propTypes: {

    name: function(props, propName,componentName){

      if(!(propName in props))  {

        throw new Error("Property Name Missing ")

      }
  },

  render:function(){
    return &lt;h1&gt;{this.props.name}&lt;/h1&gt;
  }
});
 ReactDOM.render(&lt;ValidationApp /&gt;, document.getElementById('myReactContainer')); //missing prop name</pre></div><div class="informaltable" title="Note"><h3 class="title2"><a id="note31" class="calibre1"/>Note</h3><p class="calibre7">Run the httpster from your app's root dir in order to see the output in your browser's <code class="literal">localhost:3333</code></p></div><p class="calibre7">The output of this code is shown in this screenshot:</p><div class="mediaobject"><img src="../images/00042.jpeg" alt="An example using custom validator" class="calibre9"/><div class="caption"><p class="calibre25">The app screenshot—custom validation in the React component prop</p></div></div><p class="calibre10"> </p><p class="calibre7">We can<a id="id243" class="calibre1"/> add more validations in the property (name) as:</p><div class="informaltable"><pre class="programlisting">var ValidationApp = React.createClass({

  propTypes: {

    name: function(props, propName,componentName){

      if(!(propName in props))  {

        throw new Error("Property Name Missing ")

      }



<span class="strong"><strong class="calibre8">      if(props[propName].length &lt; 7) {</strong></span>

<span class="strong"><strong class="calibre8">       throw new Error("Can you add a longer Property Name, more than 7chars")</strong></span>

<span class="strong"><strong class="calibre8">      }</strong></span>


<span class="strong"><strong class="calibre8">    }</strong></span>

  },

  render:function(){

    return &lt;h1&gt;{this.props.name}&lt;/h1&gt;

  }

});



// ReactDOM.render(&lt;ValidationApp /&gt;, document.getElementById('myReactContainer')); //missing prop name

<span class="strong"><strong class="calibre8">ReactDOM.render(&lt;ValidationApp name="react" /&gt;, document.getElementById('myReactContainer')); //prop length should be more than 7 chars</strong></span>
</pre></div><div class="informaltable" title="Note"><h3 class="title2"><a id="note32" class="calibre1"/>Note</h3><p class="calibre7">Run the httpster from your app's root dir in order to see the output in your browser's <code class="literal">localhost:3333</code></p></div><p class="calibre7">The<a id="id244" class="calibre1"/> output of the following code is shown here:</p><div class="mediaobject"><img src="../images/00043.jpeg" alt="An example using custom validator" class="calibre9"/><div class="caption"><p class="calibre25">The app screenshot—validation in React component prop</p></div></div><p class="calibre10"> </p><p class="calibre7">Thus, if we pass the name property with more than seven chars, there would be no error in the JS console, as expected.</p></div></div>
<div class="book" title="The structure of component"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec39" class="calibre1"/>The structure of component</h1></div></div></div><p class="calibre7">Now that<a id="id245" class="calibre1"/> we have explored quite a lot regarding ReactJS, there might be queries in your mind about how to architecture a react component or more broadly a react application as a whole. There are no ground rules that have been set, which is ideal while writing an application based on ReactJS. However, if we dig into<a id="id246" class="calibre1"/> the tutorials by the Facebook documentation team, hyperlink <a class="calibre1" href="https://facebook.github.io/react/docs/tutorial.html">https://facebook.github.io/react/docs/tutorial.html</a>, we will be able to understand the underlying way they have used while writing such an app.</p><p class="calibre7">Let's explore first how a component is structured mostly:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">The component <code class="literal">declaredData</code> is fetched from the server [if required].</li><li class="listitem" value="2">The <code class="literal">propTypes</code> of the component are declared [used for validations].</li><li class="listitem" value="3">Component lifecycle methods [<code class="literal">componentWillMount</code>, <code class="literal">componentDidMount</code>, <code class="literal">componentDidUpdate</code>,<code class="literal">componentWillUnmount</code>, and so on] are defined.</li><li class="listitem" value="4">Within<a id="id247" class="calibre1"/> each of these lifecycle methods, the functions of these methods are either declared or called internally from another JS functions, defined explicitly for a particular task. It's to be remembered that the previously mentioned lifecycle methods are not necessary to use all at the same time/any in an application.</li><li class="listitem" value="5">The render method, which has to be present within any react component. Thus, the way to structure any react-based application varies application-wise. Although there is no best way, but like any other application, it's advisable to compartmentalize the code in order to follow separation of concerns. We should separate the react views, components and data. One component directory can call other child component(s) as and when required, which thereby increases readability and testability of the code.</li></ol><div class="calibre22"/></div><p class="calibre7">React being an open source JavaScript library, there are various open source sites and developers who are working on this library each day in order to enhance and tweak the library, as required.</p><p class="calibre7">For an application, using the ReactJS library, typically the views (React views) are separated as per their function (for example, home page, admin page, and product catalog). With each of the subfolder within the view, you can add the test.js file or you can keep all the test-related files under the same tests folder. In case you need some react views, which should be shared across other components, you can keep all those related files under the shared/lib folder.</p></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec40" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we explored how we can develop reusable components in ReactJS (Mixins, before ES6 implementation). We also came to know about the higher order components, which are used later in the latter versions of ReactJS (from 0.13), which support ES6 and doesn't support Mixins. Validations are an integral part of any application, especially those using user input (that is, form inputs). We explored how ReactJS deals with validations and how we can use our custom validations as well. We got an overview how the react components are structured. In the following chapter, we will be dealing with the testing, in a React application.</p></div></body></html>