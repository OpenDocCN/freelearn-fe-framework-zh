<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Telling the World"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Telling the World</h1></div></div></div><p>The build up of TDD focused on fundamental components, namely the life cycle and process, using step-by-step walk-throughs. We have studied several applications from the ground up, understanding how to build Angular applications and use tools to test them.</p><p>It's time to expand further into the depths of Angular and integrate services, EventEmitters, and routes.</p><p>This chapter will be slightly different from the others in a few ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Instead of building a brand new application, we will use the search application from <a class="link" href="ch07.html" title="Chapter 7. Flip Flop">Chapter 7</a>, <span class="emphasis"><em>Flip Flop</em></span></li><li class="listitem" style="list-style-type: disc">We will add the unit tests for Angular routes and navigation that were skipped in previous chapters</li><li class="listitem" style="list-style-type: disc">We will make the existing search application more modern by separating the commonly used actions into services</li><li class="listitem" style="list-style-type: disc">We will take advantage of the Angular <code class="literal">EventEmitter</code> class to communicate between the different components</li></ul></div><div class="section" title="Getting ready to communicate"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec59"/>Getting ready to communicate</h1></div></div></div><p>We will follow a different approach in this chapter, as we've already learned the TDD approach. We developed a small project in the previous chapter, and our plan is to work with that project and make it better in order to present it to the world.</p><p>So, before the walk-through, we will have to review and identify any problems and the scope for improvement of the project. To do so, we have to be confident of the code base of the search application.</p><div class="section" title="Loading the existing project"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec118"/>Loading the existing project</h2></div></div></div><p>To start with, we will copy the project from <a class="link" href="ch07.html" title="Chapter 7. Flip Flop">Chapter 7</a>, <span class="emphasis"><em>Flip Flop</em></span>, which was originally from <a class="ulink" href="https://github.com/angular/quickstart">https://github.com/angular/quickstart</a>, and rename it <code class="literal">angular-member-search</code>.</p><p>Let's proceed and get ready to run it:</p><pre class="programlisting">
<span class="strong"><strong>$ cd angular-member-search</strong></span>
<span class="strong"><strong>$ npm install </strong></span>
<span class="strong"><strong>$ npm start</strong></span>
</pre><p>To confirm the installation and run the project, the application will automatically run it in a web browser.</p><p>Here is the output we should get when we will run the project:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_001.jpg" alt="Loading the existing project"/></div><p>
</p><p>Oh! We have our end-to-end test ready in the project. Before we go for an update, we have to be sure that the existing e2e tests are successful.</p><p>Let's run the <code class="literal">e2e</code> test in a separate console:</p><pre class="programlisting">
<span class="strong"><strong>$ npm run e2e</strong></span>
</pre><p> 
 Yes, everything passes successfully:
</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_002.jpg" alt="Loading the existing project"/></div><p>
</p></div></div></div>
<div class="section" title="Unit testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec60"/>Unit testing</h1></div></div></div><p>In the previous chapter, we started with the top-down approach. The goal was to elaborate on end-to-end testing based on what we had learned. We had the user scenario clear, we went through the tests, and our scenario passed our implementation.</p><p>In the previous chapter, we only covered end-to-end testing. So, in this chapter, we'll cover unit tests as much as we can.</p><p>Also, in the previous chapter, we mostly looked at Angular routes and navigation. So now, as a logical extension, we will look at how to test Angular routes and navigation.</p><div class="section" title="Testing a component"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec119"/>Testing a component</h2></div></div></div><p>Before we go ahead with the component test, we should discuss some points about testing Angular components. We already have a basic idea: in Angular, everything is a combination of some components. So it would be great for us to learn in more detail about Angular component testing.</p><p>We can test a component in various ways, based on its behavior and use case. We could even have test specs for multiple components when they work together as an application.</p><p>Let's have a look at some of the ways of testing components.</p><div class="section" title="Isolated testing"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec52"/>Isolated testing</h3></div></div></div><p>Isolated testing, also known as solo testing, is named so because this type of test can run without the need to compile components according to test specs. If it doesn't compile, it will not have the compiled template in the test spec; only the component class and its methods. This means that if a component's features are not very DOM dependent, it can be tested in an isolated manner.</p><p>Isolated testing is mostly used for complex feature or calculation testing, where it just initiates the component class and calls all the methods.</p><p>For example, take a look at the unit tests of <a class="link" href="ch06.html" title="Chapter 6. The First Step">Chapter 6</a>, <span class="emphasis"><em>The First Step</em></span>, where <code class="literal">AppComponent</code> was responsible for adding comments and increasing their likes:</p><pre class="programlisting">beforeEach(() =&gt; { &#13;
    comp = new AppComponent(); &#13;
    comp.add('a sample comment'); &#13;
    comp.like(comp.comments[0]); &#13;
}); &#13;
 &#13;
    it('First item in the item should match', () =&gt; { &#13;
        expect(comp.comments[0].title).toBe('a sample &#13;
        comment'); &#13;
    }); &#13;
 &#13;
    it('Number of likes should increase on like', () =&gt; { &#13;
        expect(comp.comments[0].likes).toEqual(1); &#13;
    }); &#13;
</pre></div><div class="section" title="Shallow testing"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec53"/>Shallow testing</h3></div></div></div><p>Isolated testing sometimes fulfills the requirements of the test spec, but not always. Most of the time, components have DOM dependent features. In such cases, it is important to render the component's template in the test specs so that we have the compiled template in the scope and test specs are able to interact with DOM.</p><p>For example, if we want to write a basic unit test for our <code class="literal">AppComponent</code>, which is mostly DOM dependent as there is no method in the component class, then we just need to compile the component and check that it is defined. In addition, we can have a test spec if the component's template has the correct text inside the <code class="literal">&lt;h1&gt;</code> element.</p><p>The code will look as follows:</p><pre class="programlisting">beforeEach(async(() =&gt; { &#13;
    TestBed.configureTestingModule({ &#13;
        declarations: [ AppComponent ]&#13;
    }) &#13;
    .compileComponents(); &#13;
})); &#13;
 &#13;
beforeEach(() =&gt; { &#13;
    fixture = TestBed.createComponent(AppComponent); &#13;
    comp = fixture.componentInstance; &#13;
    de = fixture.debugElement.query(By.css('h1')); &#13;
}); &#13;
 &#13;
it('should create and initiate the App component', () =&gt; { &#13;
    expect(comp).toBeDefined(); &#13;
}); &#13;
 &#13;
it('should have expected test in &lt;h1&gt; element', () =&gt; { &#13;
    fixture.detectChanges(); &#13;
    const h1 = de.nativeElement; &#13;
    expect(h1.innerText).toMatch(/My First Angular 2 App/i, &#13;
    '&lt;h1&gt; should say something about "Angular App"'); &#13;
}); &#13;
</pre></div><div class="section" title="Integration testing"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec54"/>Integration testing</h3></div></div></div><p>The following are some key points on integration testing:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The name <span class="emphasis"><em>integration testing</em></span> should give us some idea of what kind of test it is. It is similar to shallow testing as it also needs to compile the component with the template and interact with the DOM.</li><li class="listitem" style="list-style-type: disc">We will next look at our route and navigation test suite, where we will integrate the <code class="literal">AppComponent</code>, router, and navigation test suites.</li><li class="listitem" style="list-style-type: disc">We have a test suite ready for <code class="literal">AppComponent</code>, as it includes the <code class="literal">navbar</code> component and <code class="literal">router-outlet</code> component. All of these together work to fulfill the routing specs.</li><li class="listitem" style="list-style-type: disc">So, to get a confident test spec for a router, we should go with integration testing.</li></ul></div><p>We will look at an example of router testing with a detailed explanation in the
following sections.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>The main difference between integration testing and shallow testing is that integration testing works for the test suite of the complete application, or a small portion of the application, where multiple components work together to solve some purpose. It shares some similarities with end-to-end testing, but with a different approach.</p></div></div></div></div></div>
<div class="section" title="Karma configuration"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec61"/>Karma configuration</h1></div></div></div><p>In previous chapters, the default Karma configuration was used, but no explanation about this default configuration has been given yet. <span class="strong"><strong>File watching</strong></span> is a useful default behavior that will now be reviewed.</p><div class="section" title="File watching"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec120"/>File watching</h2></div></div></div><p>File watching is enabled by default when the Karma <code class="literal">init</code> command is used.  File watching in Karma is configured with the following definition in the  <code class="literal">karma.conf.js</code> file:</p><pre class="programlisting">autoWatch: true, &#13;
</pre><p>The file watching feature works as expected and watches the files defined in the configuration's <code class="literal">files</code> array. When a file is updated, changed, or deleted, Karma responds by rerunning the tests. From a TDD perspective, this is a great feature, as tests will continue to run without any manual intervention.</p><p>The main point to watch out for is the addition of files. If the file being added doesn't match the criteria in the <code class="literal">files</code> array, the <code class="literal">autoWatch</code> parameter won't respond to the change. As an example, let's consider that the files are defined as follows:</p><pre class="programlisting">files : [ 'dir1/**/*.js'] &#13;
</pre><p>If this is the case, the watcher will find all the files and subdirectory files ending in <code class="literal">.js</code>. If a new file is in a different directory, not in <code class="literal">dir1</code>, then the watcher will not be able to respond to the new file because it is in a different directory from what it was configured in.
</p></div></div>
<div class="section" title="Testing routers and navigation"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec62"/>Testing routers and navigation</h1></div></div></div><p>We were introduced to Angular routers and navigation alongside the general components in <a class="link" href="ch07.html" title="Chapter 7. Flip Flop">Chapter 7</a>, <span class="emphasis"><em>Flip Flop</em></span>.</p><p>As we have discussed the different types of tests for Angular components, routers and navigation, we will look at integration testing. For that, we will use our application component test, that is, our base component, and we will then integrate navigation and <code class="literal">router-outlet</code> component tests with the application component to test the router.</p><div class="section" title="Testing the app component"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec121"/>Testing the app component</h2></div></div></div><p>Before we go ahead with router testing, we will get ready with our application component tests. In the app component test, we will test whether the component is defined and initiated correctly, and then we will test the page title by selecting the DOM element.</p><p>We learned about shallow testing in previous sections; when we interact with DOM elements, we need shallow testing. The same goes here: as we will have to deal with DOM elements, we will use shallow testing as our application component test.</p><p>For shallow testing, we will need to depend on the <code class="literal">TestBed</code> Angular test API from Angular core testing, which will be used to compile and initiate the components in the test suite. Besides that, we will have to depend on the <code class="literal">ComponentFixture</code> module from core testing. We will need two more modules, named <code class="literal">By</code> and <code class="literal">DebugElement</code>, from the Angular core and platform APIs to interact with DOM elements.</p><p>Our app component test will be located at <code class="literal">spec/unit/app.component.ts</code> and will look like this:</p><pre class="programlisting">import { async, ComponentFixture, TestBed } from '@angular/core/testing'; &#13;
import { By }           from '@angular/platform-browser'; &#13;
import { DebugElement } from '@angular/core'; &#13;
 &#13;
import { AppComponent } from '../../app/app.component'; &#13;
import { NavbarComponent } from '../../app/nav/navbar.component';&#13;
import { RouterOutlet } from '@angular/router';&#13;
 &#13;
describe('AppComponent test suite', function () { &#13;
  let comp: AppComponent; &#13;
  let fixture: ComponentFixture&lt;AppComponent&gt;; &#13;
  let de: DebugElement; &#13;
 &#13;
  beforeEach(async(() =&gt; { &#13;
   TestBed.configureTestingModule({ &#13;
      declarations: [ AppComponent ] &#13;
    }) &#13;
    .compileComponents(); &#13;
  })); &#13;
 &#13;
  beforeEach(() =&gt; { &#13;
    fixture = TestBed.createComponent(AppComponent); &#13;
    comp = fixture.componentInstance; &#13;
    de = fixture.debugElement.query(By.css('h1')); &#13;
  }); &#13;
 &#13;
  it('should create and initiate the App component', () =&gt; { &#13;
    expect(comp).toBeDefined(); &#13;
  }); &#13;
 &#13;
  it('should have expected test in &lt;h1&gt; element', () =&gt; { &#13;
    fixture.detectChanges(); &#13;
    const h1 = de.nativeElement; &#13;
    expect(h1.innerText).toMatch(/My First Angular 2 App/i, &#13;
      '&lt;h1&gt; should say something about "Angular App"'); &#13;
  }); &#13;
}); &#13;
</pre><p>If we run this test, we will see the following result:</p><pre class="programlisting">   Chrome 54.0.2840 (Mac OS X 10.10.5): Executed 2 of 2 SUCCESS&#13;
   (0 secs / 0.522 secs)&#13;
</pre><p>Our application component test is ready now; next, we will perform a router test, including <code class="literal">router-outlet</code> and navigation.</p></div><div class="section" title="Testing router"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec122"/>Testing router</h2></div></div></div><p>The Angular router is not part of Angular core; it's a separate module that has to be imported before being used. It has some directives, such as <code class="literal">RouterOutlet</code> and <code class="literal">RouterLink</code>, which play an active role in fulfilling router activities. To test the router, first we will test these directives, in order to prepare the platform for testing the complete router.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip18"/>Tip</h3><p>We can test the router using the actual router module, but sometimes it creates some complexity for the entire routing system. Due to this, test specs may fail without providing an accurate error. To avoid this, it's recommended to create router stubs and use those for router testing.</p></div></div><div class="section" title="Router stubs"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec55"/>Router stubs</h3></div></div></div><p>I had the router stubs idea from Angular's official testing docs. I liked the idea about the routing stubs and copied the <code class="literal">router-stubs</code> file from <code class="literal">angular.io/public/docs/_examples/testing/ts/testing/router-stubs.ts</code>
<span class="strong"><strong> </strong></span>in Angular's GitHub repository. The first router stubs directive is <code class="literal">RouterStubLinksDirective</code>, which is responsible for hosting the element or anchor link (<code class="literal">&lt;a&gt;</code>) to perform the <code class="literal">click</code> event for the directive's <code class="literal">onClick()</code> method. The URL bound to the <code class="literal">[routerLink]</code> attribute flows to the directive's <code class="literal">linkParams</code> property. When the anchor link (<code class="literal">&lt;a&gt;</code>) is clicked on, it should trigger the <code class="literal">onClick()</code> method, and it will set to the tentative <code class="literal">navigateTo</code> property.</p><p>This <code class="literal">router-stubs</code> file has a dependency on the Angular router and relevant directives, including <code class="literal">RouterLink</code> and <code class="literal">RouterOutlet</code>, so we will need to import those.</p><p>So, the router stubs will be located at <code class="literal">spec/unit/stub/router-stub.ts</code>, and the code will be as follows:</p><pre class="programlisting">export  {Router, NavigationExtras, RouterLink, RouterOutlet} from '@angular/router'; &#13;
 &#13;
import { Component, Directive, Injectable, Input } from '@angular/core'; &#13;
 &#13;
@Directive({ &#13;
  selector: '[routerLink]', &#13;
  host: { &#13;
    '(click)': 'onClick()' &#13;
  } &#13;
}) &#13;
export class RouterLinkStubDirective { &#13;
  @Input('routerLink') linkParams: any; &#13;
  navigatedTo: any = null; &#13;
 &#13;
  onClick() { &#13;
    this.navigatedTo = this.linkParams; &#13;
  } &#13;
} &#13;
</pre><p>Beside the <code class="literal">RouterLinkStubDirective</code>, this stub should contain the <code class="literal">RouterOutletStubComponent</code> to support the <code class="literal">router-outlet</code> directive, and <code class="literal">RouterStub</code> to support the main router module:</p><pre class="programlisting">@Component({selector: 'router-outlet', template: ''}) &#13;
export class RouterOutletStubComponent { } &#13;
 &#13;
@Injectable() &#13;
export class RouterStub { &#13;
  navigate(commands: any[], extras?: NavigationExtras) { } &#13;
} &#13;
</pre></div><div class="section" title="The router-outlet and navigation test"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec56"/>The router-outlet and navigation test</h3></div></div></div><p>As we know, the <code class="literal">router-outlet</code> and navigation (<code class="literal">RouterLink</code>) menus work together with the application landing page, that is, our application component. The testing mechanism will be of the same form. This means that we will test both of these modules with the application component.</p><p>As mentioned a bit earlier, we will use an integration test here for <code class="literal">router-outlet</code> testing. We have our application component test suite ready; now it's time to integrate <code class="literal">router-outlet</code> and navigation (<code class="literal">RouterLink</code>), and we will have our integration test suite for the application component along with <code class="literal">router-outlet</code> and <code class="literal">RouterLink</code>.</p><p>We have the <code class="literal">navbar</code> component, which is basically a navigation component that contains the <code class="literal">RouterLink</code> to navigate through the router. We will have to import that component to our test suite for it to perform correctly. Besides the actual router module, we will have to import the <code class="literal">RouterStub</code> that we have created. To reiterate, <code class="literal">router-stubs</code> contains the <code class="literal">RouterOutletStubComponent</code> and <code class="literal">RouterLinkStubDirective</code> components.</p><p>After importing all the required components, we will have to declare them in the <code class="literal">TestBed</code> configuration. And, as a part of the setup, we will get all the <code class="literal">navLinks</code> from the <code class="literal">RouterLinkStubDirective</code> in the test suite's scope to test and bind <code class="literal">click</code> events to the <code class="literal">linkParams</code>.</p><p>The test suite's setup will look like this:</p><pre class="programlisting">import { NavbarComponent } from '../../app/nav/navbar.component'; &#13;
import { AppComponent } from '../../app/app.component';&#13;
import { RouterOutletStubComponent, RouterLinkStubDirective } from './stub/router-stubs.js'; &#13;
 &#13;
describe('AppComponent test suite', function () { &#13;
  let navDestination:any; &#13;
  let navLinks:any; &#13;
  let fixture: ComponentFixture&lt;AppComponent&gt;; &#13;
  let de: DebugElement;  &#13;
&#13;
  beforeEach(async(() =&gt; { &#13;
   TestBed.configureTestingModule({ &#13;
      declarations: [ AppComponent, NavbarComponent, &#13;
                     RouterLinkStubDirective, &#13;
                     RouterOutletStubComponent ] &#13;
    }) &#13;
    .compileComponents(); &#13;
  })); &#13;
 &#13;
  beforeEach(() =&gt; { &#13;
    fixture.detectChanges(); &#13;
 &#13;
    navDestination = fixture.debugElement &#13;
      .queryAll(By.directive(RouterLinkStubDirective)); &#13;
 &#13;
    navLinks = navDestination &#13;
      .map(de =&gt; de.injector.get(RouterLinkStubDirective) as &#13;
      RouterLinkStubDirective); &#13;
  });&#13;
</pre><p>For the test specs, first we will test the link parameters in the navigation menu. We have the <code class="literal">navLinks</code>, and we will match them with the <code class="literal">linkParams</code> of the <code class="literal">navLinks</code>.</p><p>Then, we will test the expected navigation while clicking on the navigation menu items. We will test that with the help of the <code class="literal">navigatedTo</code> method.</p><p>Our test specs will look as follows:</p><pre class="programlisting">  it('can get RouterLinks from template', () =&gt; { &#13;
    expect(navLinks.length).toBe(3, 'should have 3 links'); &#13;
    expect(navLinks[0].linkParams).toBe('/view1', '1st link should&#13;
    go to View1'); &#13;
    expect(navLinks[1].linkParams).toBe('/view2', '1st link should&#13;
    go to View2'); &#13;
    expect(navLinks[2].linkParams).toBe('/members', '1st link should&#13;
    go to members search page'); &#13;
  }); &#13;
 &#13;
  it('can click nav items link in template and navigate &#13;
  accordingly', () =&gt; { &#13;
    navDestination[0].triggerEventHandler('click', null); &#13;
    fixture.detectChanges(); &#13;
    expect(navLinks[0].navigatedTo).toBe('/view1'); &#13;
 &#13;
    navDestination[1].triggerEventHandler('click', null); &#13;
    fixture.detectChanges(); &#13;
    expect(navLinks[1].navigatedTo).toBe('/view2'); &#13;
 &#13;
    navDestination[2].triggerEventHandler('click', null); &#13;
    fixture.detectChanges(); &#13;
    expect(navLinks[2].navigatedTo).toBe('/members'); &#13;
  }); &#13;
 &#13;
</pre><p>So, we can say that this will cover the tests for <code class="literal">router-outlet</code> and routerLink, which will confirm that the router links are working as expected, and that we are able to navigate though the expected router after clicking on the navigation menu.</p></div></div><div class="section" title="Implementing an integration test"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec123"/>Implementing an integration test</h2></div></div></div><p>Our test specs are ready. We have been planning for an integrated test, and we can perform one now. Here, we are combining the app component and <code class="literal">navbar</code> component, along with <code class="literal">router-outlet</code> and <code class="literal">routerLink</code>, to test the route and navigation. We have to interact with DOM elements with the help of the <code class="literal">debugElement</code> module from the browser platform API.</p><p>The test suite is ready--time to run the test.</p><p>Let's run it with the following command:</p><pre class="programlisting">
<span class="strong"><strong>npm test </strong></span>
</pre><p>And all the test specs pass as expected. The result will be as follows:</p><pre class="programlisting">   Chrome 54.0.2840 (Mac OS X 10.10.5): Executed 4 of 4 SUCCESS&#13;
   (0 secs / 1.022 secs) &#13;
</pre></div><div class="section" title="More tests..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec124"/>More tests...</h2></div></div></div><p>We just added some tests that will cover a few of the features that we have developed so far, mostly focused on the router (<code class="literal">router-outlet</code> and <code class="literal">routerLink</code>).</p><p>We will add more tests for members and the search feature, but we will update the behavior of the existing features of searching and member listing. Besides that, our current code base does not have proper decoupling between the components' features, which will make it complex to test features individually.</p><p>We already have the end-to-end test, which will verify the output we expect from our components, but for unit testing, we will need to refactor the code and decouple them. We will cover the tests for the rest of the features after we update the behavior and refactor the correct code base.</p></div></div>
<div class="section" title="Recap of the application behavior"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec63"/>Recap of the application behavior</h1></div></div></div><p>Let's look at a quick overview of the search application:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Our search application invokes the Members component in the DOM. It contains two major parts: the search area and the result area.</li><li class="listitem" style="list-style-type: disc">From the search area, we type a search query and submit it to get the expected result in the result area.</li><li class="listitem" style="list-style-type: disc">The resulting area lists down the member list based on the search query. We may have figured out that we get all the data during the initialization of the <code class="literal">Members</code> component; that's because we call the Members component's <code class="literal">search()</code> method with <code class="literal">ngOnInit()</code>, and it returns all the data as our logic has been set to return all data when no search query is set.</li><li class="listitem" style="list-style-type: disc">By clicking on a member's name, we can see the detailed information about that member on the details page.</li></ul></div></div>
<div class="section" title="Updating the application behavior"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec64"/>Updating the application behavior</h1></div></div></div><p>According to the previous specification, it seems we have some incorrect behavior in the search feature. Right now, we are calling <code class="literal">search()</code> when initializing the members of the search component. This seems a bit wrong; we should start the search after entering the search query and/or clicking on the <span class="strong"><strong>Search</strong></span> button.</p><p>The expected behavior is that it will first load all the member data and then, after starting the search, the data list will be updated based on the search query.</p><p>To do so, let's update the <code class="literal">ngOnInit()</code> method in <code class="literal">members.component.ts</code> and add a new method, <code class="literal">getMember()</code>, to have the entire data list during component initiation.</p><p>The expected change will be as follows:</p><pre class="programlisting">ngOnInit() { &#13;
    this.getMembers(); &#13;
  } &#13;
 &#13;
  getMembers() { &#13;
    this.getData() &#13;
    .then(data =&gt; { &#13;
      data.map(item =&gt; { &#13;
        this.memberList.push(item); &#13;
      }); &#13;
    }) &#13;
    return this.memberList; &#13;
  } &#13;
 &#13;
search() { &#13;
    // Do Search &#13;
  } &#13;
</pre><div class="section" title="Identifying the problem"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec125"/>Identifying the problem</h2></div></div></div><p>Based on the existing code, it seems we have defined the <code class="literal">getData()</code> method twice, in <code class="literal">members.component.ts</code> and <code class="literal">person.component.ts,</code> because in both the components, we had to call the JSON data source to get the member dataset.</p><p>So, what's the problem with that? It's bad practice as it duplicates code, and duplication of code is hard to manage when the application becomes large and complex.</p><p>For example, now we have the following method twice:</p><pre class="programlisting">getData() { &#13;
    return this.http.get('app/data/people.json') &#13;
      .toPromise() &#13;
      .then(response =&gt; response.json()); &#13;
  } &#13;
</pre><p>If we have to to change the data source URL or API, we will have to change this method in two places. It's not so tough to change it twice, but what about 10-12 times, or even more for a larger application?</p><p>Yes, it's a problem, and it needs a solution.</p></div><div class="section" title="Finding a solution"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec126"/>Finding a solution</h2></div></div></div><p>We've identified the problem, which is code duplication. We know the solution: we have to write the method in a common place and use it in both components. In short, we have to make this method reusable so that every component can share it.</p><p>It seems simple, but we have to do it in the Angular way. We can't just move the method to a separate file and import that.</p><p>Angular introduced services for such situations. We'll now look at some of those services with examples.</p></div></div>
<div class="section" title="Angular services"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec65"/>Angular services</h1></div></div></div><p>Angular services were introduced to write code shareable among components. So if we need a piece of code for many components, it's recommended to create a single reusable service, and wherever we need that piece of code, we can just inject that service to the component and use its methods as needed.</p><p>Services are used to abstract application logic. They are used to provide a single responsibility for a particular action. Single responsibility allows components to  be easily tested and changed. This is because the focus is on one component and  not all the inner dependencies.</p><p>Mostly, a service acts as the data source of any application. Whenever we need a piece of code to communicate with the server to get data (mostly JSON), we use a service.</p><p>This is because most components need to access data, and everyone can inject the common service as required. So, we have a commonly used piece of code, which is actually the data layer for our application. We should move those parts to a service to make our application smart so that we can tell the world we are not duplicating code in any way.</p><div class="section" title="We have service now?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec127"/>We have service now?</h2></div></div></div><p>As planned, we have moved the <code class="literal">getData()</code> method from the <code class="literal">members.component.ts</code> and <code class="literal">person.component.ts</code> components to a new file so that we can get rid of code duplication.</p><p>Let's create a new file at <code class="literal">app/services/members.service.ts</code>, make a new class to export, called <code class="literal">MembersService</code>, and move the <code class="literal">getData()</code> method there. Besides moving the method, we will have to import <code class="literal">{ Http, Response }</code> from the Angular HTTP module as <code class="literal">getData</code> has a dependency on HTTP.</p><p>Observe the following code sample:</p><pre class="programlisting">import { Http, Response } from '@angular/http'; &#13;
 &#13;
export class MembersService { &#13;
  constructor(private http:Http) { &#13;
 &#13;
  } &#13;
 &#13;
  getAPIData() { &#13;
    return this.http.get('app/data/people.json'); &#13;
  } &#13;
 &#13;
  getData() { &#13;
    return this.getAPIData() &#13;
      .toPromise() &#13;
      .then(response =&gt; response.json()); &#13;
  } &#13;
 &#13;
} &#13;
</pre><p>We have a service now, and we can start using it. Let's import and use it in the Members component.</p><p>Wait; before that, we will have to import the service into the application module to have identification of it. As long as it's a service, we will have to identify it as a provider; the service will act as a service provider.</p><p>Our <code class="literal">app.module.ts</code> file will look like this:</p><pre class="programlisting">import {MembersService} from './services/members.service'; &#13;
 &#13;
@NgModule({ &#13;
  declarations: [AppComponent, NavbarComponent, ....], &#13;
  imports     : [BrowserModule, FormsModule, ......], &#13;
  providers   : [MembersService], &#13;
  bootstrap   : [AppComponent] &#13;
}) &#13;
 &#13;
</pre><p>Now, to use the service in our component, we have to import and inject it into our MembersComponents with the service name <code class="literal">MembersService</code>. As long as we inject the service as the constructor of the component, we will have the service available to the entire component. To access the method, we need to call it <code class="literal">this.membersService.getData()</code>.</p><p>So, our Members component will look like this:</p><pre class="programlisting">import { MembersService } from '../services/members.service'; &#13;
@Component({ &#13;
   ............ &#13;
}) &#13;
export class MembersComponent implements OnInit { &#13;
 constructor(public membersService: MembersService, private router:Router) { &#13;
 &#13;
  } &#13;
 &#13;
  getMembers() { &#13;
    this.membersService.getData() &#13;
    .then(data =&gt; { &#13;
      data.map(item =&gt; { &#13;
        this.memberList.push(item); &#13;
      }); &#13;
    }) &#13;
    return this.memberList; &#13;
  } &#13;
 &#13;
</pre><p>Time to run and look at the output and see how the service works with the Members component.</p><p>Lets point the browser to <code class="literal">http://localhost:3000/members</code>.</p><p>Oops! What happened? We are getting an error in the browser console:</p><pre class="programlisting">Error: (SystemJS) Can't resolve all parameters for MembersService: (?) &#13;
</pre><p>Based on the error, we have made a mistake: <code class="literal">SystemJS</code> (used as the module loaded) can't inject <code class="literal">MembersService</code> as we missed adding something to the service to make it perfect. In Angular, we have to mention in every service whether it will be injectable; without doing so, we will not be able to inject that service into any component.</p><p>And, for that, we will have to use the Angular <span class="strong"><strong>Injectable</strong></span> decorator. We will take a look at it in brief.</p></div><div class="section" title="Injectable services"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec128"/>Injectable services</h2></div></div></div><p>The Injectable decorator is a part of the Angular core library, used when creating injectable services. Without defining it as injectable, it's not possible to identify the dependency of a service. To define it as injectable, we will have to use <code class="literal">@Injectable()</code> at the top of the class definition.</p><p>The code will look like this:</p><pre class="programlisting">import { Injectable } from '@angular/core'; &#13;
import { Http, Response } from '@angular/http'; &#13;
 &#13;
@Injectable() &#13;
export class MembersService { &#13;
  constructor(private http:Http) { &#13;
 &#13;
  } &#13;
 &#13;
  getData() { &#13;
    return this.http.get('app/data/people.json') &#13;
      .toPromise() &#13;
      .then(response =&gt; response.json()); &#13;
  } &#13;
} &#13;
</pre><p>We have made the service injectable. Now, we should be fine to inject it into the Members component and point our browser to <code class="literal">http://localhost:3000/members</code>.</p><p>Hurray! No more errors, and we are getting the expected data list:
</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_003.jpg" alt="Injectable services"/></div><p>
</p><p>Seems like our service is injectable and working fine. It's time to implement it in the <code class="literal">PersonComponent</code>, as we need the data service on that component as well. The same as the Members component, let's import and inject it into the <code class="literal">PersonComponent</code> with the service name <code class="literal">membersService</code>. Again, we will have to access the data service method with <code class="literal">this.membersService.getData()</code>.</p><p>Our <code class="literal">PersonComponent</code> will look like this:</p><pre class="programlisting">import { MembersService } from '../../services/members.service'; &#13;
 &#13;
@Component({ &#13;
  ........... &#13;
}) &#13;
export class PersonComponent implements OnInit { &#13;
  constructor(public membersService: MembersService, private route: ActivatedRoute, private router: Router) { &#13;
 &#13;
  } &#13;
 &#13;
.................... &#13;
 &#13;
  getPerson(id:number) { &#13;
    return this.membersService.getData() &#13;
          .then(data =&gt; data.find(member =&gt; member.id === id)); &#13;
  } &#13;
} &#13;
</pre><p>Time to run and look at the output of how the service is working with the Members component.</p><p>We have our e2e test, which will confirm that everything is going well with the new changes:</p><pre class="programlisting">
<span class="strong"><strong>$ npm run e2e</strong></span>
</pre><p>Yes, everything passes successfully:</p><p>
</p><div class="mediaobject"><img src="graphics/chapter_08_02.jpg" alt="Injectable services"/></div><p>
</p><p>Yay! Our code refactoring hasn't affected our expected behavior.</p></div><div class="section" title="Services will serve you more"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec129"/>Services will serve you more</h2></div></div></div><p>To reap the complete benefits of services, we will move two more methods from the Members and Person components. Before that, those methods were component specific; now, by adding them to a service, those methods can be used from any component just by injecting the service.</p><p>Perhaps we will benefit later from this change but want to keep these methods decoupled from the components.</p><p>The newly added code will look like this:</p><pre class="programlisting">@Injectable() &#13;
export class MembersService { &#13;
  constructor(private http:Http) { &#13;
 &#13;
  } &#13;
 &#13;
  ............ &#13;
 &#13;
  searchQuery(q:string) { &#13;
    if (!q || q === '*') { &#13;
      q = ''; &#13;
    } else { &#13;
      q = q.toLowerCase(); &#13;
    } &#13;
    return this.getData() &#13;
      .then(data =&gt; { &#13;
      let results:any = []; &#13;
      data.map(item =&gt; { &#13;
        if (JSON.stringify(item).toLowerCase().includes(q)) { &#13;
          results.push(item); &#13;
        } &#13;
      }); &#13;
      return results; &#13;
    }); &#13;
  } &#13;
 &#13;
  getPerson(id:number) { &#13;
    return this.getData() &#13;
   .then(data =&gt; data.find(member =&gt; member.id === id)); &#13;
  } &#13;
} &#13;
</pre></div><div class="section" title="Testing the service"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec130"/>Testing the service</h2></div></div></div><p>The goal behind the code decoupling and separation was to make the code testable. We did so, and we have separated the data retrieval part from the Members component and made a service so that it will be easy to test. The service is injectable; other than that, it's similar to an angular component. So, to perform unit testing, we will test the methods that the service contains.</p><div class="section" title="Testing service injection"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec57"/>Testing service injection</h3></div></div></div><p>Like other Angular components, we can test whether the service is defined well. But the main difference is that, as long as the service is injectable, we will need to inject it in the test specs to get the instance to test.</p><p>For a sample test spec, we can set it up so that it will import the <code class="literal">TestBed</code> and <code class="literal">inject</code>, and then configure the <code class="literal">TestingModule</code> using MembersService as the provider. Then, in the test spec, we will inject the service and check whether the service is defined as expected.</p><p>Our sample test suite will look like this:</p><pre class="programlisting">import { inject, TestBed } from '@angular/core/testing'; &#13;
import { MembersService } from '../../app/services/members.service'; &#13;
 &#13;
describe('Given service should be defined', () =&gt; { &#13;
 &#13;
  beforeEach(() =&gt; { &#13;
    TestBed.configureTestingModule({ &#13;
      providers: [ &#13;
        MembersService, &#13;
      ],  &#13;
    }); &#13;
  }); &#13;
 &#13;
 it('should initiate the member service', inject([MembersService], (membersService) =&gt; { &#13;
    expect(membersService).toBeDefined(); &#13;
  })); &#13;
 &#13;
}); &#13;
</pre><p>For this test, the expected result will be true.</p></div><div class="section" title="Testing HTTP requests"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec58"/>Testing HTTP requests</h3></div></div></div><p>To have a unit test for HTTP requests, we will have to use the async technique to keep the HTTP call asynchronous, and in Angular testing, we will use the <code class="literal">fakeAsync</code> module, which is an async module to use with mock HTTP requests.</p><p>Wait, "mock"?</p><p>Well yes; to test HTTP requests in an Angular test suite, we don't need to make actual HTTP requests. To achieve the effect of an HTTP request, we can mock out our HTTP services; Angular has provided a mock service called <span class="strong"><strong>MockBackend</strong></span>.</p><p><code class="literal">MockBackend</code> is a class that can be configured to provide mock responses for HTTP mock requests, and it will work exactly the same as HTTP services but without making the actual network requests.</p><p>After we have configured the <code class="literal">MockBackend</code>, it can be injected into HTTP. So, from our service where we used <code class="literal">http.get</code>, we'll have the expected data returned.</p><p>Our test suite with the HTTP request will look like this:</p><pre class="programlisting">import { fakeAsync, inject, TestBed } from '@angular/core/testing'; &#13;
 &#13;
import { Http, BaseRequestOptions, Response, ResponseOptions } from '@angular/http'; &#13;
import { MockBackend, MockConnection } from '@angular/http/testing'; &#13;
 &#13;
import { MembersService } from '../../app/services/members.service'; &#13;
 &#13;
const mockData = { &#13;
  "id": 2, &#13;
  "name": "Demaryius Thomas", &#13;
  "phone": "(720) 213-9876", &#13;
  "address": { &#13;
    "street": "5555 Marion Street", &#13;
    "city": "Denver", &#13;
    "state": "CO", &#13;
    "zip": "80202" &#13;
  } &#13;
}; &#13;
 &#13;
describe('Given service should be defined and response HTTP request', () =&gt; { &#13;
 &#13;
  beforeEach(() =&gt; { &#13;
    TestBed.configureTestingModule({ &#13;
      providers: [ &#13;
        MembersService, &#13;
        BaseRequestOptions, &#13;
        MockBackend, &#13;
        { &#13;
          provide: Http, &#13;
          useFactory: (backend, defaultOptions) =&gt; { &#13;
            return new Http(backend, defaultOptions); &#13;
          }, &#13;
          deps: [MockBackend, BaseRequestOptions], &#13;
        }, &#13;
      ], &#13;
    }); &#13;
  });&#13;
}); &#13;
</pre><p>Here, at first, besides importing the <code class="literal">MockBackend</code>, we are importing the <code class="literal">MockConnection</code>, which is used to subscribe to the backend connection and provide the connected data to the next steps. Then, we configure the <code class="literal">MockBackend</code>, which will return the HTTP object.</p><p>Next, we will get ready with our test specs by injecting <code class="literal">MockBackend</code> and <code class="literal">MembersService</code>:</p><pre class="programlisting">  it('should return response when subscribed to getUsers', fakeAsync( &#13;
    inject([MockBackend, MembersService], (backend, membersService) =&gt; { &#13;
      backend.connections.subscribe( &#13;
        (c: MockConnection) =&gt; { &#13;
          c.mockRespond( &#13;
            new Response( &#13;
              new ResponseOptions({ body: mockData }) &#13;
            )); &#13;
          }); &#13;
 &#13;
        membersService.getAPIData().subscribe(res =&gt; { &#13;
          expect(res.json()).toEqual(mockData); &#13;
        }); &#13;
  }))); &#13;
 &#13;
}); &#13;
</pre><p>In the test spec, we have injected <code class="literal">MockBackend</code>, in addition to the MembersService. <code class="literal">MockBackend</code> will subscribe to the <code class="literal">backend</code> service with the MockConnection object. MockConnection will create a new <code class="literal">ResponseOptions</code> object, where, with a <code class="literal">ResponseOptions</code> object we can configure our response properties.</p><p>Here, we just set the <code class="literal">body</code> property of the response object and set the <code class="literal">body</code> value to a predefined <code class="literal">mockData</code> object.</p></div></div><div class="section" title="Service stubs"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec131"/>Service stubs</h2></div></div></div><p>We can test the service with stub data as well. For example, we can make a stubbed version of our <code class="literal">MembersService</code> called <code class="literal">MembersServiceSpy</code>, which will fake all the necessary features of that service.</p><p>This fake service will return a resolved <code class="literal">Promise</code> with mock data, so we can just use this stubbed method for testing. It will create a spy for all of the methods we have in the service and return a separate <code class="literal">Promise</code> for every single method.</p><p>The stubbed service will be located at <code class="literal">spec/unit/stub/members.service.stub.ts</code>, and it will be as follows:</p><pre class="programlisting">import { Component, Directive, Injectable, Input } from '@angular/core'; &#13;
 &#13;
export class MembersServiceSpy { &#13;
  members = { &#13;
    "id": 2, &#13;
    "name": "Demaryius Thomas", &#13;
    "phone": "(720) 213-9876", &#13;
    "address": { &#13;
      "street": "5555 Marion Street", &#13;
      "city": "Denver", &#13;
      "state": "CO", &#13;
      "zip": "80202" &#13;
    } &#13;
  }; &#13;
 &#13;
  getData = jasmine.createSpy('getData').and.callFake( &#13;
    () =&gt; Promise &#13;
      .resolve(true) &#13;
      .then(() =&gt; Object.assign({}, this.members)) &#13;
  ); &#13;
 &#13;
  getPerson = jasmine.createSpy('getPerson').and.callFake( &#13;
    () =&gt; Promise &#13;
      .resolve(true) &#13;
      .then(() =&gt; Object.assign({}, this.members)) &#13;
  ); &#13;
 &#13;
  searchQuery = jasmine.createSpy('searchQuery').and.callFake( &#13;
    () =&gt; Promise &#13;
      .resolve(true) &#13;
      .then(() =&gt; Object.assign({}, this.members)) &#13;
  ); &#13;
 &#13;
} &#13;
</pre><div class="section" title="Service test with stubbed data"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec59"/>Service test with stubbed data</h3></div></div></div><p>Here, we will test the <code class="literal">MembersService</code> with stubbed data. To do so, we will need to import the stubbed service. And with the <code class="literal">TestBed</code> configuration, we will have to provide <code class="literal">MemberServiceSpy</code> as a service instead of an actual member service.</p><p>The <code class="literal">MembersService</code> test suite's code will look as follows:</p><pre class="programlisting">import { MembersServiceSpy } from './stub/members.service.stub.js'; &#13;
import { MembersService } from '../../app/services/members.service'; &#13;
 &#13;
const mockData = { &#13;
  "id": 2, &#13;
  "name": "Demaryius Thomas", &#13;
  "phone": "(720) 213-9876", &#13;
  "address": { &#13;
    "street": "5555 Marion Street", &#13;
    "city": "Denver", &#13;
    "state": "CO", &#13;
    "zip": "80202" &#13;
  } &#13;
}; &#13;
 &#13;
describe('Given service will response for every method', () =&gt; { &#13;
 &#13;
  beforeEach(() =&gt; { &#13;
    TestBed.configureTestingModule({ &#13;
      providers: [{ provide: MembersService, useClass: MembersServiceSpy }] &#13;
    }); &#13;
  }); &#13;
 &#13;
  it('should return data', fakeAsync(inject( &#13;
    [MembersService], (service) =&gt; { &#13;
      service.getData(); &#13;
      expect(service.members).toEqual(mockData); &#13;
    }))); &#13;
 &#13;
    it('should return data', fakeAsync(inject( &#13;
      [MembersService], (service) =&gt; { &#13;
        service.searchQuery('Thomas'); &#13;
        expect(service.members.name).toBe('Demaryius Thomas'); &#13;
    }))); &#13;
 &#13;
    it('should return data', fakeAsync(inject( &#13;
      [MembersService], (service) =&gt; { &#13;
        service.getPerson(2); &#13;
        expect(service.members.id).toBe(2); &#13;
    }))); &#13;
 &#13;
}); &#13;
</pre></div></div><div class="section" title="Combining and running the service's tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec132"/>Combining and running the service's tests</h2></div></div></div><p>We have two test suites for the Members service here. We can bring both together and run the test.</p><p>The full test suite's code will look like the following code snippet:</p><pre class="programlisting">import { fakeAsync, inject, TestBed } from '@angular/core/testing'; &#13;
 &#13;
import { Http, BaseRequestOptions, Response, ResponseOptions } from '@angular/http'; &#13;
import { MockBackend, MockConnection } from '@angular/http/testing'; &#13;
 &#13;
import { MembersServiceSpy } from './stub/members.service.stub.js'; &#13;
import { MembersService } from '../../app/services/members.service'; &#13;
 &#13;
const mockData = { &#13;
  "id": 2, &#13;
  "name": "Demaryius Thomas", &#13;
  "phone": "(720) 213-9876", &#13;
  "address": { &#13;
    "street": "5555 Marion Street", &#13;
    "city": "Denver", &#13;
    "state": "CO", &#13;
    "zip": "80202" &#13;
  } &#13;
}; &#13;
 &#13;
describe('Given service should be defined and response HTTP request', () =&gt; { &#13;
 &#13;
  beforeEach(() =&gt; { &#13;
    TestBed.configureTestingModule({ &#13;
      providers: [ &#13;
        MembersService, &#13;
        BaseRequestOptions, &#13;
        MockBackend, &#13;
        { &#13;
          provide: Http, &#13;
          useFactory: (backend, defaultOptions) =&gt; { &#13;
            return new Http(backend, defaultOptions); &#13;
          }, &#13;
          deps: [MockBackend, BaseRequestOptions], &#13;
        }, &#13;
      ], &#13;
    }); &#13;
  }); &#13;
 &#13;
  it('should initiate the member service', inject([MembersService], (membersService) =&gt; { &#13;
    expect(membersService).toBeDefined(); &#13;
  })); &#13;
 &#13;
  it('should return response when send HTTP request', fakeAsync( &#13;
    inject([MockBackend, MembersService], (backend, membersService) =&gt; { &#13;
      backend.connections.subscribe( &#13;
        (c: MockConnection) =&gt; { &#13;
          c.mockRespond( &#13;
            new Response( &#13;
              new ResponseOptions({ body: mockData }) &#13;
            )); &#13;
          }); &#13;
 &#13;
        membersService.getAPIData().subscribe(res =&gt; { &#13;
          expect(res.json()).toEqual(mockData); &#13;
        }); &#13;
  }))); &#13;
 &#13;
}); &#13;
 &#13;
describe('Given service will response for every method', () =&gt; { &#13;
 &#13;
  beforeEach(() =&gt; { &#13;
    TestBed.configureTestingModule({ &#13;
      providers: [{ provide: MembersService, useClass: MembersServiceSpy }] &#13;
    }); &#13;
  }); &#13;
 &#13;
  it('should return data', fakeAsync(inject( &#13;
    [MembersService], (service) =&gt; { &#13;
      service.getData(); &#13;
      expect(service.members).toEqual(mockData); &#13;
    }))); &#13;
 &#13;
    it('should return data', fakeAsync(inject( &#13;
      [MembersService], (service) =&gt; { &#13;
        service.searchQuery('Thomas'); &#13;
        expect(service.members.name).toBe('Demaryius Thomas'); &#13;
    }))); &#13;
 &#13;
    it('should return data', fakeAsync(inject( &#13;
      [MembersService], (service) =&gt; { &#13;
        service.getPerson(2); &#13;
        expect(service.members.id).toBe(2); &#13;
    }))); &#13;
 &#13;
}); &#13;
</pre><p>The test suite for the Members service is ready to run. Let's run it with this command:</p><pre class="programlisting">
<span class="strong"><strong>npm test </strong></span>
</pre><p>All the test specs pass as expected. The result will be as follows:</p><pre class="programlisting">   Chrome 54.0.2840 (Mac OS X 10.10.5): Executed 9 of 9 SUCCESS &#13;
   (0 secs / 4.542 secs) &#13;
</pre></div></div>
<div class="section" title="Communicating through the power of events"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec66"/>Communicating through the power of events</h1></div></div></div><p>Angular has more powerful event-handling capabilities compared to Angular 1.x. Angular 1.x has two-way data binding, whereas Angular doesn't recommend that. Angular handles the communication between data and templates through the power of events.</p><p>Angular projects stand on the combination of some components. To function, these components need to communicate with each other to share data and events. Mostly, components need to communicate when they have a parent-child relationship. There are a few ways in which Angular can communicate between parent and child components. The best is by handling custom events. We will look at details about custom events and see how they work with our search application.</p><div class="section" title="Angular events"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec133"/>Angular events</h2></div></div></div><p>As we know, Angular recommends one-way data binding, which means only from components to DOM elements. This is unidirectional data flow, and it is how Angular works. What about when we need data flow in the other direction--from DOM elements to components? Doing so depends on different events, such as clicks, keystrokes, mouseover, and touch. These events will bind with DOM elements to listen to user action and pass that action to the component.</p><p>The event binding syntax consists of the target event with parentheses to the left-hand side of the equals sign. The component contains the target event as a method, so whenever the event triggers, it will call the method from the component.
Let's look at the event that we have in the search form:</p><pre class="programlisting">&lt;button type="button" (click)="search()"&gt;Search&lt;/button&gt;&#13;
</pre><p>Any element's events are the common targets, but it's a bit different with Angular, as Angular at first checks whether the target name matches with the event property of any known directives or components.</p></div><div class="section" title="Custom events in Angular"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec134"/>Custom events in Angular</h2></div></div></div><p>Custom events are raised by directives or components with Angular <code class="literal">EventEmitter</code>. Directives create an <code class="literal">EventEmitter</code> object and expose themselves as its property to be passed via the <code class="literal">@Output</code> decorator. We will look at details of <code class="literal">@Output</code> decorator next. After exposing an <code class="literal">EventEmitter</code> object as a property, the directives will call <code class="literal">EventEmitter.emit(value)</code> to fire the event and pass the value to the parent directives.</p><p>The custom directive/component class will define the custom event as follows:</p><pre class="programlisting">  @Output() someCustomEvent: EventEmitter&lt;any&gt; = new EventEmitter(); &#13;
 &#13;
    this.someCustomEvent.emit(value);&#13;
</pre><p>Parent directives will listen for the event by binding to this property and will receive the value through the <code class="literal">$event</code> object.</p><p>The parent directive/component will contain the custom directive as follows, where it will contain the custom event as <code class="literal">someCustomEvent</code>, which will trigger the <code class="literal">doSomething()</code> method of the parent directives:</p><pre class="programlisting">&lt;custom-component (someCustomEvent)="doSomething($event)"&gt;&lt;/custom-component&gt; &#13;
</pre><p>The parent directive/component will contain the <code class="literal">doSomething()</code> method, as shown here:</p><pre class="programlisting">doSomething(someValue) { &#13;
    this.value = someValue; &#13;
} &#13;
</pre></div><div class="section" title="The Output and EventEmitter APIs"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec135"/>The Output and EventEmitter APIs</h2></div></div></div><p>Output is a decorator class from the Angular core that is used to pass custom events from a child to a parent component. To use it, we need to import it from <code class="literal">@angular/core</code>.</p><p>When we set a custom event as <code class="literal">@Output</code>, that event will be available to listen to in the parent component. This decorator will be placed inside the class, as follows:</p><pre class="programlisting">export class SearchComponent { &#13;
  @Output() someCustomEvent: EventEmitter&lt;any&gt; = new EventEmitter(); &#13;
}&#13;
</pre><p><code class="literal">EventEmitter</code> is also a core class of Angular. When we need to use it, we will have to import it from <code class="literal">@angular/core</code>. The <code class="literal">EventEmitter</code> API is used to notify the parent component by calling <code class="literal">EventEmitter.emit(value)</code> whenever the value changes in the child component. As we know, the parent component always listens to the custom event.</p></div></div>
<div class="section" title="Planning further improvements"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec67"/>Planning further improvements</h1></div></div></div><p>The search application we have so far is a simple search application. But we can make it better by keeping it as simple as it is. What I mean is, we can do this in the best way, like we were trying to decouple the data logic by separating the reusable code in the new service.</p><p>We still have a few more things to improve. It seems our application has not yet decoupled perfectly. Our components have not decoupled as we'd expected. We are talking about the <code class="literal">MembersComponent</code>, which contains the search feature and member listing feature.</p><p>We will follow the single responsibility principle here, which means every component should have a single responsibility. Here, <code class="literal">MembersComponent</code> has two. So we should break down this component to two separate components.</p><p>Let's break it down to two separate components, called <code class="literal">MembersComponent</code> and <code class="literal">SearchComponent</code>. In fact, we just made a plan for a new component called <code class="literal">SearchComponent</code> and brought the search feature over there from the Members component.</p><p>Now let's make a plan for the behavior expected from both components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The search component will have the responsibility of taking the user input as a search query and getting the expected search result using the service we have</li><li class="listitem" style="list-style-type: disc">We then pass the search result to the Members component</li><li class="listitem" style="list-style-type: disc">The Members component will get the search result from the search component and will bind the data list to the DOM</li><li class="listitem" style="list-style-type: disc">Both components will communicate and exchange data using events</li></ul></div><p>The plan is to make this simple app perfect by following best practices and using the built-in powers of Angular.</p><div class="section" title="The search component"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec136"/>The search component</h2></div></div></div><p>As planned, we will have to separate the search feature from the Members component. To do that, let's create a new component called <code class="literal">SearchComponent</code> at <code class="literal">app/search/search.component.ts</code> and create the search component's template file. The template file will simply contain the search form.</p><p>The search component file will have to import and inject the <code class="literal">MembersService</code>, as that will be used to perform the search based on the search query. The component will have the search query and will request the service for search and get the search result.</p><p>The search component's code will look like this:</p><pre class="programlisting">import { Component } from '@angular/core'; &#13;
 &#13;
import { MembersService, Person } from '../services/members.service'; &#13;
 &#13;
@Component({ &#13;
  selector: 'app-search', &#13;
  moduleId: module.id, &#13;
  templateUrl: 'search.component.html' &#13;
}) &#13;
export class SearchComponent { &#13;
  query: string; &#13;
  memberList: Array&lt;Person&gt; = []; &#13;
 &#13;
  constructor(public membersService: MembersService) { &#13;
 &#13;
  } &#13;
 &#13;
  search() { &#13;
    this.doSearch(); &#13;
  } &#13;
 &#13;
  doSearch(): void { &#13;
    this.membersService.searchQuery(this.query) &#13;
    .then(results =&gt; { &#13;
      this.memberList = results; &#13;
    }); &#13;
  } &#13;
 &#13;
} &#13;
 &#13;
</pre><p>The template of the search component will look like this:</p><pre class="programlisting">&lt;form&gt; &#13;
  &lt;input type="search" [(ngModel)]="query" name="query" (keyup.enter)="search()"&gt; &#13;
  &lt;button type="button" (click)="search()"&gt;Search&lt;/button&gt; &#13;
&lt;/form&gt; &#13;
</pre><p>As long as our application output doesn't break, we will have to bind the search component to the members list page, as it was before. So, we will have to append the search component to the template of the Members component. In that case, it will become the child component of the Members component.</p><p>The template of the Members component will look like this:</p><pre class="programlisting">&lt;h2&gt;Members&lt;/h2&gt; &#13;
&lt;app-search&gt;&lt;/app-search&gt; &#13;
&lt;table *ngIf="memberList" id="searchList"&gt; &#13;
  ...... &#13;
&lt;/table&gt; &#13;
</pre></div><div class="section" title="Enabling sharing between components"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec137"/>Enabling sharing between components</h2></div></div></div><p>Now we have two separate components, the search and Members components. The search component has been appended to the Members component, but search results are not available in the Members component.</p><p>Search and Members are separate components, and there is no bridge between them. Both have an isolated scope to contain their elements and variables.</p><p>To share data between components, we need to enable communication between them. As explained before, Angular events will come to our rescue for us to enable communication between the search and Members component. From the search component, we will need to use Angular custom events to communicate with its parent component, <code class="literal">MembersComponent</code>.
</p></div><div class="section" title="Communicating with the parent component"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec138"/>Communicating with the parent component</h2></div></div></div><p>The search component is the child component of the Members component. They need to communicate with each other to share data. We will need to use custom events with the help of the Angular <code class="literal">EventEmiiter</code> API so that we can emit the search result from the search component after getting the result. And besides that, we will need to use the <code class="literal">@OutPut</code> decorator to set the search result as the output to use for the parent component.</p><p>To use both, we will need to import both from Angular core. Then, we will need to set <code class="literal">@Output</code> searchResult to a new instance of EventEmitter. This <code class="literal">@Output</code> decorator makes the <code class="literal">searchResult</code> property available as an event binding.</p><p>When the search component updates the search result, we would like to tell the parent component that the <code class="literal">searchResult</code> event has happened. To do so, we will need to call <code class="literal">emit(data)</code> with the <code class="literal">searchResult</code> we have declared as the Emitter object with the Output decorator. The <code class="literal">emit()</code> method is used to notify every time the result has been passed via a custom event.</p><p>Now, the Members component can fetch the <code class="literal">$event</code> object, as we've passed it into the template using <code class="literal">(searchRessult)="anyMethod($event);</code>.</p><p>After updating with <code class="literal">EventEmitter</code>, the search component will look like this:</p><pre class="programlisting">import { Component, Output, EventEmitter } from '@angular/core'; &#13;
 &#13;
@Component({ &#13;
  ................... &#13;
}) &#13;
export class SearchComponent { &#13;
  ............. &#13;
  @Output() searchResult: EventEmitter&lt;any&gt; = new EventEmitter(); &#13;
 &#13;
  doSearch(): void { &#13;
    this.membersService.searchQuery(this.query) &#13;
    .then(results =&gt; { &#13;
      this.memberList = results; &#13;
      this.searchResult.emit(this.memberList)); &#13;
    }); &#13;
  } &#13;
 &#13;
} &#13;
 &#13;
</pre><p>Now it's time to communicate with the <code class="literal">MembersComponent</code>. Let's declare the <code class="literal">onSearch()</code> method in the member component, which will accept the event as an argument.</p><p>The Members component will change to the following:</p><pre class="programlisting">export class MembersComponent implements OnInit { &#13;
   &#13;
  ngOnInit() { &#13;
    this.getMembers(); &#13;
  } &#13;
 &#13;
  onSearch(searchResult) { &#13;
    this.memberList = searchResult; &#13;
  } &#13;
 &#13;
  getMembers() { &#13;
    this.membersService.getData() &#13;
    .then(data =&gt; { &#13;
      data.map(item =&gt; { &#13;
        this.memberList.push(item); &#13;
      }); &#13;
    }) &#13;
    return this.memberList; &#13;
  } &#13;
 &#13;
} &#13;
 &#13;
</pre><p>As we are appending the search component from the members template, let's hook the <code class="literal">onSearch</code> function to the search component tag. We will call this <code class="literal">(searchResult)</code>--with parentheses around it--to tell Angular that this is an event binding.</p><p>The template of the search component will look like this:</p><pre class="programlisting">&lt;h2&gt;Members&lt;/h2&gt; &#13;
&lt;app-search (searchResult)="onSearch($event)" &gt;&lt;/app-search&gt; &#13;
&lt;table *ngIf="memberList" id="searchList"&gt; &#13;
  ...... &#13;
&lt;/table&gt; &#13;
</pre></div><div class="section" title="Check output after refactoring"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec139"/>Check output after refactoring</h2></div></div></div><p>The search application will be rebranded into a store application instead of rewriting the search functionality that has already been written. In order to leverage the existing search project, it will be copied into a new project file. Then, the new project will use the tests to drive the development changes and refactoring. The refactoring steps have been left out, but a review of the code will show how the code and tests were modified to create the product application.</p><p>Time to run it and see how the service works with the Members component. Let's point our browser to <code class="literal">http://localhost:3000/members</code>.</p><p>
</p><div class="mediaobject"><img src="graphics/chapter_08_03.jpg" alt="Check output after refactoring"/></div><p>
</p><p>We have the e2e test, which will confirm that everything's going well with the new changes:</p><pre class="programlisting">
<span class="strong"><strong>    $ npm run e2e</strong></span>
</pre><p>Yes, we can see that everything passes successfully:</p><p>
</p><div class="mediaobject"><img src="graphics/chapter_08_02.jpg" alt="Check output after refactoring"/></div><p>
</p><p>Yes! Our code refactoring hasn't affected our expected behavior.</p><span class="strong"><strong>Current project directory </strong></span><p>We have updated and refactored the code, for which we have some new components, services, and so on. Now, we will have a new project structure, separating the logic and decoupling the components.</p><p>Our current directory structure looks like this:</p><p>
</p><div class="mediaobject"><img src="graphics/image_08_004.jpg" alt="Check output after refactoring"/></div><p>
</p></div></div>
<div class="section" title="Moving ahead"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec68"/>Moving ahead</h1></div></div></div><p>In this book, I have tried to cover the topics to a certain level so that anyone can start with test-driven development based on Angular. But there are a lot of things we have skipped, most importantly, rxJS.</p><p>rxJS is a separate module based on reactive programming. So, we will need to be familiar with reactive programming to understand it.
</p><div class="section" title="Observables"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec140"/>Observables</h2></div></div></div><p>HTTP requests by default return observables as responses in Angular instead of resolved promises. Since we didn't look at rxJS here, we skipped observables and converted the responses to promises. But we should learn how observables work with Angular.</p></div><div class="section" title="Publishing and subscribing"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec141"/>Publishing and subscribing</h2></div></div></div><p>Publishing and subscribing messages is a powerful tool, but as with anything, when used the wrong way, it can lead to a mess.</p><p>There are two ways in which messages can be published: emit or broadcast. It is important to know the difference, as both work slightly differently and they may affect the performance of our application.</p></div></div>
<div class="section" title="Self-test questions"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec69"/>Self-test questions</h1></div></div></div><p>Q1. A callback function refers to a function that is called after an asynchronous function completes.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">True</li><li class="listitem" style="list-style-type: disc">False</li></ul></div><p>Q2. Asynchronous functions always complete in the order in which they were called.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">True</li><li class="listitem" style="list-style-type: disc">False</li></ul></div><p>Q3. There is a module called <code class="literal">MockBackend</code> to fake HTTP calls in Angular for unit testing.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">True</li><li class="listitem" style="list-style-type: disc">False</li></ul></div><p>Q4. In Angular, the <code class="literal">EventEmitter</code> API is used for component communication.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">True</li><li class="listitem" style="list-style-type: disc">False</li></ul></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec70"/>Summary</h1></div></div></div><p>In this chapter, we explored services in Angular and the power of events. We also saw some examples of the separation of code with services and events.</p><p>In addition, we looked at different types of testing for Angular components and wrote unit tests for the Angular router, and we integrated it with application components and navigation. We also explored further configuration of Karma in order to use its features.</p><p>Now that we're at the end of the book, it's time to apply our knowledge in the real world. Before leaving, let's have a quick recap of what we have learned. We learned about TDD, how TDD works with JavaScript context, and the available testing tools, techniques, and frameworks. We learned about Karma and Protractor with real Angular projects. And now we know how to write unit and e2e tests for Angular projects.</p><p>This book showed you the path to practicing TDD; now it's your job to keep learning, improve on this knowledge, and practice more with complex projects to be more confident with TDD. </p></div></body></html>