- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Unit Testing Angular Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试Angular应用
- en: In the previous chapters, we went through many aspects of how to build an Angular
    enterprise application from scratch. But how can we ensure that an application
    can be maintained in the future without much hassle? A comprehensive automated
    testing layer can become our lifeline once our application begins to scale up
    and we have to mitigate the impact of bugs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了从零开始构建Angular企业应用的许多方面。但我们是怎样确保应用在未来可以轻松维护的呢？一旦我们的应用开始扩展，我们必须减轻bug的影响，一个全面的自动化测试层就可以成为我们的生命线。
- en: Testing, specifically unit testing, is meant to be carried out by the developer
    as the project is being developed. Now that our knowledge of the framework is
    mature, we will briefly cover all the intricacies of unit testing an Angular application
    in this chapter including the use of testing tools..
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 测试，特别是单元测试，旨在在项目开发过程中由开发者执行。现在我们的框架知识已经成熟，我们将简要介绍本章中Angular应用单元测试的所有复杂性，包括测试工具的使用。
- en: For simplicity, the examples in this chapter are not related to the e-shop application
    that we have built throughout the book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，本章中的示例与我们在整本书中构建的电子商务应用无关。
- en: 'In more detail, we will learn about the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地说，我们将学习以下内容：
- en: Why do we need unit tests?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们需要单元测试？
- en: The anatomy of a unit test
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试的结构
- en: Introducing unit tests in Angular
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular中引入单元测试
- en: Testing components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试组件
- en: Testing services
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试服务
- en: Testing pipes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试管道
- en: Testing directives
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试指令
- en: Testing forms
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试表单
- en: Testing the router
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试路由器
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The chapter contains various code samples to walk you through the concept of
    unit testing in Angular. You can find the related source code in the `ch13` folder
    of the following GitHub repository:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例，以向您介绍Angular中单元测试的概念。您可以在以下GitHub仓库的`ch13`文件夹中找到相关源代码：
- en: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition)
    .'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition)
    .'
- en: Why do we need unit tests?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么我们需要单元测试？
- en: In this section, we will learn what unit tests are and why they are useful in
    web development.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习单元测试是什么以及为什么它们在Web开发中很有用。
- en: You can skip to the next section if you’re familiar with unit testing and test-driven
    development.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉单元测试和测试驱动开发，你可以跳到下一节。
- en: Unit tests are part of an engineering philosophy for efficient and agile development
    processes. They add a layer of automated testing to the application code before
    it is developed. The core concept is that a piece of code is accompanied by its
    test, both of which are built by the developer who works on that code. First,
    we design the test against the feature we want to deliver, checking the accuracy
    of its output and behavior. Since the feature is still not implemented, the test
    will fail, so the developer’s job is to build the feature to pass the test.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是高效和敏捷开发流程的工程哲学的一部分。它们在代码开发之前为应用程序代码添加了一层自动化测试。核心概念是，一段代码及其测试都是由负责该代码的开发者构建的。首先，我们针对我们想要交付的功能设计测试，检查其输出和行为是否准确。由于该功能尚未实现，测试将失败，因此开发者的工作是构建功能以通过测试。
- en: Unit testing is quite controversial. While test-driven development is beneficial
    for ensuring code quality and maintenance over time, not everybody undertakes
    unit testing in their daily development workflow.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试相当有争议。虽然测试驱动开发有助于确保代码质量并随着时间的推移进行维护，但并非每个人都在他们的日常开发工作流程中执行单元测试。
- en: 'Building tests as we develop our code can sometimes feel like a burden, especially
    when the test results become larger than the functionality it aims to test. However,
    the arguments in favor of testing outnumber the arguments against it:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开发代码的同时构建测试有时会感觉像是一种负担，尤其是在测试结果变得比要测试的功能更大的情况下。然而，支持测试的论据超过了反对它的论据：
- en: Building tests contributes to better code design. Our code must conform to the
    test requirements and not vice versa. If we try to test an existing piece of code
    and find ourselves blocked at some point, the chances are that the code is not
    well designed and requires some rethinking. On the other hand, building testable
    features can help with the early detection of side effects.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建测试有助于更好的代码设计。我们的代码必须符合测试要求，而不是相反。如果我们试图测试现有的代码并在某个点上受阻，那么代码可能设计得不好，需要重新思考。另一方面，构建可测试的功能可以帮助早期发现副作用。
- en: Refactoring tested code is a lifeline against introducing bugs in later stages.
    Development is meant to evolve with time, and the risk of introducing a bug with
    every refactor is high. Unit tests are an excellent way to ensure we catch bugs
    early, either when introducing new features or updating existing ones.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对经过测试的代码进行重构是防止在后期引入错误的生命线。开发应当随着时间而演进，每次重构时引入错误的几率很高。单元测试是确保我们能够尽早捕捉到错误的一种极好方式，无论是引入新功能还是更新现有功能。
- en: Building tests is an excellent way to document our code. It becomes a priceless
    resource when someone unfamiliar with the code base takes over the development
    endeavor.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建测试是记录我们代码的极好方式。当有人不熟悉代码库而接管开发任务时，它成为了一种无价资源。
- en: These are only a few arguments, but you can find countless resources on the
    web about the benefits of testing your code. If you do not feel convinced yet,
    give it a try; otherwise, let’s continue with our journey and look at the overall
    form of a unit test.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是其中的一小部分论点，但你在网上可以找到无数关于测试代码好处的资源。如果你还没有确信，不妨试一试；否则，让我们继续我们的旅程，看看单元测试的整体形式。
- en: The anatomy of a unit test
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试的结构
- en: There are many different ways to test a piece of code. In this chapter, we will
    look at the anatomy of a unit test—the separate parts it’s made of.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一段代码有许多不同的方法。在本章中，我们将探讨单元测试的结构——它由哪些单独的部分组成。
- en: 'To test any code, we need a framework for writing the test and a runner to
    run it on. In this section, we will focus on the test framework. The test framework
    should provide utility functions for building test suites containing one or several
    test specs. As a result, unit testing involves the following concepts:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试任何代码，我们需要一个用于编写测试的框架和一个用于运行测试的运行器。在本节中，我们将专注于测试框架。测试框架应提供用于构建包含一个或多个测试规格的测试套件的实用函数。因此，单元测试涉及以下概念：
- en: '**Test suite** : A suite that creates a logical grouping for many tests. A
    suite, for example, can contain all the tests for a specific feature.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试套件**：一个为许多测试创建逻辑分组的套件。例如，一个套件可以包含特定功能的全部测试。'
- en: '**Test spec** : The actual unit test.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试规格**：实际的单元测试。'
- en: 'We will use **Jasmine** in this chapter, a popular test framework that is also
    used by default in Angular CLI projects. This is what a unit test looks like in
    Jasmine:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用**Jasmine**，这是一个流行的测试框架，也是Angular CLI项目中默认使用的框架。以下是Jasmine中的单元测试示例：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `describe` method defines the test suite and accepts a name and an arrow
    function as parameters. The arrow function is the body of the test suite and contains
    several unit tests. The `it` method defines a single unit test. It accepts a name
    and an arrow function as parameters.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe` 方法定义了测试套件，并接受一个名称和一个箭头函数作为参数。箭头函数是测试套件的主体，包含多个单元测试。`it` 方法定义了一个单独的单元测试。它接受一个名称和一个箭头函数作为参数。'
- en: Each test spec validates a specific functionality of the feature described in
    the suite name and declares one or several expectations in its body. Each expectation
    takes a value, called the **expected** value, which is compared against an **actual**
    value using a **matcher** function. The function checks whether the expected and
    actual values match accordingly, which is called an **assertion** . The test framework
    passes or fails the spec depending on the result of such assertions. In the previous
    example, `1+1` will return the actual value that is supposed to match the expected
    value, `2` , declared in the `toBe` matcher function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试规格验证套件名称中描述的功能的特定功能，并在其主体中声明一个或多个期望。每个期望都包含一个值，称为**期望值**，它使用**匹配器函数**与**实际值**进行比较。该函数检查期望值和实际值是否相应匹配，这被称为**断言**。测试框架根据这种断言的结果通过或失败规格。在先前的例子中，`1+1`将返回实际值，该值应与在`toBe`匹配器函数中声明的期望值`2`相匹配。
- en: The Jasmine framework contains various matcher functions according to user-specific
    needs, as we will see later in the chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 框架根据用户特定的需求包含各种匹配器函数，正如我们在本章后面将要看到的。
- en: 'Suppose the previous code contains another mathematical operation that must
    be tested. It would make sense to group both operations under the `Calculator`
    suite, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设前面的代码包含另一个必须测试的数学运算。将这两个操作组合在 `Calculator` 测试套件下进行测试是有意义的，如下所示：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So far, we have learned about test suites and how to use them to group tests
    according to their functionality. Furthermore, we have learned about invoking
    the code we want to test and affirming that it does what it should do. However,
    more concepts are involved in unit tests that are worth knowing about, namely,
    the **setup** and **teardown** functionalities.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了测试套件以及如何使用它们根据其功能分组测试。此外，我们还学习了如何调用我们想要测试的代码并确认它做了它应该做的事情。然而，单元测试中涉及的概念更多，值得了解，即**设置**和**拆卸**功能。
- en: 'A setup functionality prepares your code before you start running the tests.
    It’s a way to keep your code clean by focusing on invoking the code and checking
    the assertions. A teardown functionality is the opposite. It is responsible for
    tearing down what we initially set up, involving activities such as cleaning up
    resources. Let’s see what this looks like in practice with a code example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 设置功能是在你开始运行测试之前准备你的代码。这是一种通过调用代码并检查断言来保持代码清洁的方法。拆卸功能是相反的。它负责拆卸我们最初设置的内容，涉及诸如清理资源等活动。让我们通过一个代码示例来看看这在实际中是什么样子：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `beforeEach` method is used for the setup functionality and runs before
    every unit test. In this example, we set the value of the `total` variable to
    `1` before each test. The `afterEach` method is used to run teardown logic. After
    each test, we reset the value of the `total` variable to `0` .
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeEach` 方法用于设置功能，并在每个单元测试之前运行。在这个例子中，我们在每个测试之前将 `total` 变量的值设置为 `1`。`afterEach`
    方法用于运行拆卸逻辑。在每个测试之后，我们将 `total` 变量的值重置为 `0`。'
- en: It is evident that the test only has to care about invoking application code
    and asserting the outcome, which makes tests cleaner; however, tests tend to have
    much more setup in a real-world application. Most importantly, the `beforeEach`
    method tends to make it easier to add new tests, which is great. We want well-tested
    code; the easier it is to write and maintain such code, the better for our software.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，测试只需要关注调用应用程序代码并断言结果，这使得测试更简洁；然而，在实际应用中，测试往往需要更多的设置。最重要的是，`beforeEach` 方法通常使添加新测试变得更容易，这是非常好的。我们希望代码经过良好的测试；编写和维护这样的代码越容易，对我们软件的好处就越大。
- en: Now that we have covered the basics of a unit test, let’s see how we can implement
    them in the context of the Angular framework.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了单元测试的基础，让我们看看我们如何在 Angular 框架的上下文中实现它们。
- en: Introducing unit tests in Angular
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Angular 中引入单元测试
- en: 'In the previous section, we familiarized ourselves with unit testing and its
    general concepts, such as test suites, test specs, and assertions. It is time
    to venture into unit testing with Angular, armed with that knowledge. Before we
    start writing tests for Angular, though, let’s have a look at the tooling that
    the Angular framework and the Angular CLI provide us with:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们熟悉了单元测试及其一般概念，如测试套件、测试规范和断言。现在是时候带着这些知识去探索 Angular 的单元测试了。然而，在我们开始为
    Angular 编写测试之前，让我们看看 Angular 框架和 Angular CLI 为我们提供的工具：
- en: '**Jasmine** : We have already learned that this is the testing framework.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jasmine**：我们已经了解到，这是一个测试框架。'
- en: '**Karma** : The test runner for running our unit tests.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Karma**：运行我们的单元测试的测试运行器。'
- en: '**Angular testing utilities** : A set of helper methods that assist us in setting
    up our unit tests and writing our assertions in the context of the Angular framework.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular 测试工具**：一组辅助方法，帮助我们设置单元测试并在 Angular 框架的上下文中编写断言。'
- en: When we use the Angular CLI, we do not have to do anything to configure Jasmine
    and Karma in an Angular application. Unit testing works out of the box when we
    create a new Angular CLI project. Most of the time, we will interact with the
    Angular testing utilities.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Angular CLI 时，我们不需要对 Angular 应用程序中的 Jasmine 和 Karma 进行任何配置。当我们创建一个新的 Angular
    CLI 项目时，单元测试默认情况下就可以工作。大多数时候，我们将与 Angular 测试工具交互。
- en: 'Angular testing utilities help us to create a testing environment that makes
    writing tests for our Angular artifacts easy. It consists of the `TestBed` class
    and various helper methods in the `@angular/core/testing` namespace. As this chapter
    progresses, we will learn what these are and how they can help us test various
    artifacts. For now, let’s have a look at the most commonly used concepts so that
    you are familiar with them when we look at them in more detail later on:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 测试实用工具帮助我们创建一个测试环境，使得为我们的 Angular 艺术品编写测试变得容易。它由 `TestBed` 类和 `@angular/core/testing`
    命名空间中的各种辅助方法组成。随着本章的深入，我们将了解这些是什么以及它们如何帮助我们测试各种艺术品。现在，让我们先看看最常用的概念，以便在稍后更详细地探讨时，您能熟悉它们：
- en: '`TestBed` : A class that creates a testing module. We attach an Angular artifact
    to this testing module when we test it. The `TestBed` class contains the `configureTestingModule`
    method we use to set up the test module as needed.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestBed`：一个创建测试模块的类。当我们测试它时，我们将 Angular 艺术品附加到这个测试模块上。`TestBed` 类包含我们用来设置测试模块所需的
    `configureTestingModule` 方法。'
- en: '`ComponentFixture` : A wrapper class around an Angular component instance.
    It allows us to interact with the component and its corresponding HTML element.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ComponentFixture`：一个围绕 Angular 组件实例的包装类。它允许我们与组件及其相应的 HTML 元素进行交互。'
- en: '`DebugElement` : A wrapper around the DOM element of the component. It is an
    abstraction that operates cross-platform so that our tests are platform-independent.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DebugElement`：组件 DOM 元素的包装。它是一个跨平台操作抽象，使得我们的测试是平台无关的。'
- en: Now that we know our testing environment and the frameworks and libraries used,
    we can start writing our first unit tests in Angular.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了我们的测试环境和使用的框架和库，我们可以开始编写我们的第一个 Angular 单元测试。
- en: All the examples described in this chapter have been created in a new Angular
    CLI project.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中描述的所有示例都是在新的 Angular CLI 项目中创建的。
- en: We will embark on this great journey from the most fundamental building block
    in Angular, the component.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 Angular 最基本的构建块——组件开始，开始这段伟大的旅程。
- en: Testing components
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试组件
- en: You may have noticed that whenever we used the Angular CLI to scaffold a new
    Angular application or generate an Angular artifact, it created some test files
    for us.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，每次我们使用 Angular CLI 构建新的 Angular 应用程序或生成 Angular 艺术品时，它都会为我们创建一些测试文件。
- en: Test files in the Angular CLI contain the word `spec` in their filename. The
    filename of a test is the same as the Angular artifact it is testing, followed
    by the suffix `.spec.ts` . For example, the test file for the main component of
    an Angular application is `app.component.spec.ts` and it resides in the same path
    as the component file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI 中的测试文件文件名中包含单词 `spec`。测试文件的文件名与其所测试的 Angular 艺术品相同，后跟后缀 `.spec.ts`。例如，Angular
    应用程序主组件的测试文件是 `app.component.spec.ts`，它位于组件文件相同的路径中。
- en: We should consider an Angular artifact and its corresponding test one thing.
    When we change the logic of the artifact, we may need to modify the unit test
    as well. Placing unit test files with their Angular artifacts makes it easier
    for us to remember and edit them. It also helps us when we need to refactor our
    code, such as moving artifacts (not forgetting to move the unit test).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该将 Angular 艺术品及其相应的测试视为一件事。当我们更改艺术品的逻辑时，我们可能需要修改单元测试。将单元测试文件与其 Angular 艺术品放在一起，使我们更容易记住和编辑它们。这也有助于我们在需要重构代码时，例如移动艺术品（不要忘记移动单元测试）。
- en: 'When we scaffold a new Angular application, the Angular CLI automatically creates
    a test for the main component, `AppComponent` . At the beginning of the file,
    there is a `beforeEach` statement that is used for setup purposes:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建一个新的 Angular 应用程序时，Angular CLI 会自动为主组件 `AppComponent` 创建一个测试。在文件的开头，有一个用于设置的
    `beforeEach` 语句：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It uses the `configureTestingModule` method of the `TestBed` class and passes
    an object as a parameter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用 `TestBed` 类的 `configureTestingModule` 方法，并将一个对象作为参数传递。
- en: We can specify an `imports` array that contains the component we want to test.
    Additionally, we can define teardown options using the `teardown` property.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定一个包含我们想要测试的组件的 `imports` 数组。此外，我们可以使用 `teardown` 属性定义拆解选项。
- en: 'The `teardown` property contains an object of the `ModuleTeardownOptions` type
    that can set the following properties:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`teardown` 属性包含一个 `ModuleTeardownOptions` 类型的对象，可以设置以下属性：'
- en: '`destroyAfterEach` : It creates a new instance of the module at each test to
    eliminate bugs caused by the incomplete cleanup of HTML elements.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destroyAfterEach`：它在每个测试中创建模块的新实例，以消除由于 HTML 元素清理不完整而引起的错误。'
- en: '`rethrowErrors` : It throws any errors that occur when the module is destroyed.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rethrowErrors`：它在模块销毁时抛出任何发生的错误。'
- en: Finally, we call the `compileComponents` method to compile the TypeScript class
    and the HTML template of our component.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `compileComponents` 方法来编译我们的组件的 TypeScript 类和 HTML 模板。
- en: 'The first unit test verifies whether we can create a new instance of `AppComponent`
    using the `createComponent` method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个单元测试验证我们是否可以使用 `createComponent` 方法创建 `AppComponent` 的新实例：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The result of the `createComponent` method is a `ComponentFixture` instance
    of the `AppComponent` type that can give us the component instance using the `componentInstance`
    property. We also use the `toBeTruthy` matcher function to check whether the resulting
    instance is valid.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`createComponent` 方法的结果是 `AppComponent` 类型的 `ComponentFixture` 实例，我们可以使用 `componentInstance`
    属性获取组件实例。我们还使用 `toBeTruthy` 匹配器函数来检查生成的实例是否有效。'
- en: 'As soon as we have access to the component instance, we can query any of its
    public properties and methods:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们能够访问组件实例，我们就可以查询其任何公共属性和方法：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the previous test, we check whether the `title` component property is set
    to `my-app` using another matcher function, `toEqual` .
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们使用另一个匹配器函数 `toEqual` 检查 `title` 组件属性是否设置为 `my-app`。
- en: The value of the `title` component property in a new Angular application will
    be the name you passed in the `ng new` command while creating the application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的 Angular 应用程序中，`title` 组件属性的值将是你在创建应用程序时通过 `ng new` 命令传递的名称。
- en: 'As we have learned, a component consists of a TypeScript class and a template
    file. So, testing it only from the class perspective, as in the previous test,
    is not sufficient. We should also test whether the class interacts correctly with
    the DOM:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，组件由 TypeScript 类和模板文件组成。因此，仅从类角度测试，如前面的测试，是不够的。我们还应该测试类是否正确与 DOM 交互：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Many developers favor class testing over DOM testing and rely on **end-to-end**
    ( **E2E** ) testing, which is slower and performs poorly. E2E tests often validate
    the integration of an application with a backend API and are easy to break. Thus,
    performing DOM unit testing in your Angular applications is recommended.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者更喜欢类测试而不是 DOM 测试，并依赖于 **端到端**（**E2E**）测试，这种测试较慢且性能较差。端到端测试通常验证应用程序与后端 API
    的集成，并且容易出错。因此，在 Angular 应用程序中执行 DOM 单元测试是推荐的。
- en: In the preceding test, we create a component and call the `detectChanges` method
    of the `ComponentFixture` . The `detectChanges` method triggers the Angular change
    detection mechanism, forcing the data bindings to be updated. It executes the
    `ngOnInit` life cycle event of the component the first time it is called and the
    `ngOnChanges` in subsequent calls so that we can query the DOM element of the
    component using the `nativeElement` property. In this example, we check the `textContent`
    of the HTML element corresponding to the `title` property.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们创建了一个组件并调用了 `ComponentFixture` 的 `detectChanges` 方法。`detectChanges`
    方法触发了 Angular 的变更检测机制，强制数据绑定更新。它在第一次调用时执行组件的 `ngOnInit` 生命周期事件，在后续调用中执行 `ngOnChanges`，这样我们就可以使用
    `nativeElement` 属性查询组件的 DOM 元素。在这个例子中，我们检查与 `title` 属性对应的 HTML 元素的 `textContent`。
- en: 'To run tests, we use the `ng test` command of the Angular CLI. It will start
    the Karma test runner, fetch all unit test files, execute them, and open a browser
    to display the results of each test. The Angular CLI uses the Google Chrome browser
    by default. The output will look like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试时，我们使用 Angular CLI 的 `ng test` 命令。它将启动 Karma 测试运行器，获取所有单元测试文件，执行它们，并打开浏览器以显示每个测试的结果。Angular
    CLI 默认使用 Google Chrome 浏览器。输出将类似于以下内容：
- en: '![Εικόνα που περιέχει κείμενο, γραμματοσειρά, στιγμιότυπο οθόνης, λευκό  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_13_01.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、字体、屏幕截图、白色 描述由系统自动生成](img/B21418_13_01.png)'
- en: 'Figure 13.1: Test execution output'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1：测试执行输出
- en: In the previous figure, we can see the result of each test at the top of the
    page. We can also see how Karma visually groups each test by suite. In our case,
    the only test suite is **AppComponent** .
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以在页面顶部看到每个测试的结果。我们还可以看到 Karma 如何通过套件视觉分组每个测试。在我们的例子中，唯一的测试套件是 **AppComponent**。
- en: 'Now, let’s make one of our tests fail. Open the `app.component.ts` file, change
    the value of the `title` property to `my-new-app` , and save the file. Karma will
    re-execute our tests and display the results on the page:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们让我们的一个测试失败。打开`app.component.ts`文件，将`title`属性的值更改为`my-new-app`，然后保存文件。Karma将重新执行我们的测试，并在页面上显示结果：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, αριθμός  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_13_02.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、屏幕截图、字体、编号的图片，自动生成的描述](img/B21418_13_02.png)'
- en: 'Figure 13.2: Test failure'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：测试失败
- en: Karma runs in **watch mode** , so we do not need to execute the Angular CLI
    test command every time we make a change.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Karma以**监视模式**运行，因此我们不需要每次更改时都执行Angular CLI测试命令。
- en: 'Sometimes, reading the output of tests in the browser is not very convenient.
    Alternatively, we can inspect the console window that we used to run the `ng test`
    command, which contains a trimmed version of the test results:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在浏览器中阅读测试输出并不太方便。作为替代，我们可以检查我们用来运行`ng test`命令的控制台窗口，其中包含测试结果的裁剪版本：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We’ve gained quite a lot of insight just by looking at the test of `AppComponent`
    that the Angular CLI automatically created for us. In the following section, we
    will look at a more advanced scenario for testing a component with dependencies.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看Angular CLI为我们自动创建的`AppComponent`测试，我们已经获得了相当多的见解。在下一节中，我们将查看一个更高级的场景，用于测试具有依赖项的组件。
- en: Testing with dependencies
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带依赖项的测试
- en: In a real-world scenario, components are not usually as simple as the main component.
    They will almost certainly be dependent on one or more services. They will also
    possibly contain other child components in their template.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的场景中，组件通常不像主组件那样简单。它们几乎肯定依赖于一个或多个服务。它们也可能在其模板中包含其他子组件。
- en: 'We have different ways of dealing with testing in such situations. One thing
    is clear: if we are testing the component, we should not test the service or its
    child components. So, when we set up such a test, the dependency should not be
    the real class. There are different ways of dealing with that when it comes to
    unit testing; no solution is strictly better than another:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有不同方式处理这种情况下的测试。有一点很清楚：如果我们正在测试组件，我们不应该测试服务或其子组件。因此，当我们设置此类测试时，依赖项不应是真实类。在单元测试中，处理这个问题有不同方式；没有解决方案是绝对优于其他解决方案的：
- en: '**Stubbing** : A method that instructs the dependency injector to inject a
    stub of the dependency that we provide instead of the real class.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存根**：一种指示依赖项注入器注入我们提供的存根而不是真实类的指令。'
- en: '**Spying** : A method that injects the actual dependency but attaches a spy
    to the method that we call in our component. We can then either return mock data
    or let the method call through.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**间谍**：一种注入实际依赖项但附加一个间谍到我们在组件中调用的方法的方法。然后我们可以返回模拟数据或让方法调用通过。'
- en: Using stubbing over spying is preferable when a dependency is complicated. Some
    services inject other services, so using the real dependency in a test requires
    you to compensate for other dependencies. It is also the preferred method when
    the component we want to test contains child components in its template.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当依赖项复杂时，使用存根而不是间谍更可取。一些服务会注入其他服务，因此在测试中使用真实依赖项需要您补偿其他依赖项。当我们要测试的组件在其模板中包含子组件时，这也是首选方法。
- en: Regardless of the approach, we ensure that the test does not perform unintended
    actions, such as accessing the filesystem or attempting to communicate via HTTP;
    we are testing the component in complete isolation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 无论采用何种方法，我们都确保测试不会执行意外的操作，例如访问文件系统或尝试通过HTTP进行通信；我们正在完全隔离的情况下测试组件。
- en: Replacing the dependency with a stub
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用存根替换依赖项
- en: Replacing a dependency with a stub means that we completely replace the dependency
    with a fake one.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 用存根替换依赖项意味着我们完全用假的依赖项替换了真实的依赖项。
- en: 'We can create a fake dependency in the following ways:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式创建一个假的依赖项：
- en: Create a constant variable or class that contains properties and methods of
    the real dependency.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含真实依赖项属性和方法的常量变量或类。
- en: Create a mock definition of the actual class of the dependency.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为依赖项的实际类创建一个模拟定义。
- en: The approaches are not so different. In this section, we will look at the first
    one as it is most common in Angular development. Feel free to explore the second
    one at your own pace.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法并没有太大的区别。在本节中，我们将查看第一个方法，因为它在Angular开发中最为常见。您可以按照自己的节奏探索第二个方法。
- en: 'Consider the following `stub.component.ts` component file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下`stub.component.ts`组件文件：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It injects `StubService` , which contains two public properties. Providing
    a stub for this service in tests is pretty straightforward, as shown in the following
    example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它注入了`StubService`，该服务包含两个公共属性。在测试中为该服务提供占位符相当直接，如下面的示例所示：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have declared the service as `Partial` because we want only to set the `name`
    property initially. We can now use the object literal syntax to inject the stub
    service in our testing module:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将服务声明为`Partial`，因为我们只想最初设置`name`属性。现在我们可以使用对象字面量语法将占位符服务注入到我们的测试模块中：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `msg` component property relies on the value of the `isBusy` service property.
    Therefore, we need to get a reference to the service in the test suite and provide
    alternate values for this property in each test. We can get the injected instance
    of `StubService` using the `inject` method of the `TestBed` class:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`msg`组件属性依赖于`isBusy`服务属性的值。因此，我们需要在测试套件中获取对服务的引用，并在每个测试中为该属性提供不同的值。我们可以使用`TestBed`类的`inject`方法获取注入的`StubService`实例：'
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We pass the real `StubService` as a parameter to the `inject` method, not the
    stubbed version we created. Modifying the value of the stub will not affect the
    injected service since our component uses an instance of the real service. The
    `inject` method asks the root injector of the application for the requested service.
    If the service was provided from the component injector, we would need to get
    it from the component injector using `fixture.debugElement.injector.get(StubService)`
    .
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将真实的`StubService`作为参数传递给`inject`方法，而不是我们创建的占位符版本。修改占位符的值不会影响注入的服务，因为我们的组件使用的是真实服务的实例。`inject`方法请求应用程序的根注入器提供所需的服务。如果服务是从组件注入器提供的，我们就需要使用`fixture.debugElement.injector.get(StubService)`从组件注入器获取它。
- en: 'We can now write our tests to check whether the `msg` component property behaves
    correctly during data binding:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写测试来检查`msg`组件属性在数据绑定期间是否表现正确：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have removed the `fixture.detectChanges` line from the `beforeEach` statement
    because we want to trigger change detection in our tests separately.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从`beforeEach`语句中移除了`fixture.detectChanges`行，因为我们希望在测试中单独触发变更检测。
- en: 'Stubbing a dependency is not always viable, especially when the root injector
    does not provide it. A service can be provided at the component injector level.
    Providing a stub using the process we looked at earlier doesn’t have any effect.
    To tackle such a scenario, we can use the `overrideComponent` method of the `TestBed`
    class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 占位依赖项并不总是可行的，尤其是在根注入器不提供它的情况下。服务可以在组件注入器级别提供。使用我们之前查看的过程提供占位符没有任何效果。为了应对这种情况，我们可以使用`TestBed`类的`overrideComponent`方法：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `overrideComponent` method accepts two parameters: the type of component
    that provides the service and an override metadata object. The metadata object
    contains the `set` property, which provides services to the component.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`overrideComponent`方法接受两个参数：提供服务的组件类型和一个覆盖元数据对象。元数据对象包含`set`属性，它为组件提供服务。'
- en: 'Suppose that the component we want to test contains a child component in its
    template, such as:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要测试的组件在其模板中包含一个子组件，例如：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding case, when we tested the `StubComponent` , we also needed
    to import the TypeScript class of the `<app-child>` component when configuring
    the testing module:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，当我们测试`StubComponent`时，我们还需要在配置测试模块时导入`<app-child>`组件的TypeScript类：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `ChildComponent` class may have other dependencies as well. Providing stubs
    for those dependencies is not viable because it is not the responsibility of the
    component under test. Instead, we can create a stub TypeScript class for the component
    and import it when configuring the testing module:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChildComponent`类可能还有其他依赖。为这些依赖提供占位符不可行，因为这不是被测试组件的责任。相反，我们可以为组件创建一个占位符TypeScript类，并在配置测试模块时导入它：'
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding snippet, we passed an empty array in the `template` property
    of the component because we are not interested in the internal implementation
    of the child component.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在组件的`template`属性中传递了一个空数组，因为我们对子组件的内部实现不感兴趣。
- en: If the child component contains properties and methods that are used while testing
    the parent component, we need to define them as well in the `ChildStubComponent`
    .
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子组件包含在测试父组件时使用的属性和方法，我们还需要在`ChildStubComponent`中定义它们。
- en: 'Alternatively, to provide a stub of the component, we can pass the `NO_ERRORS_SCHEMA`
    from the `@angular/core` npm package while configuring the testing module:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，为了提供一个组件的存根，我们可以在配置测试模块时传递来自 `@angular/core` npm 包的 `NO_ERRORS_SCHEMA`：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding snippet instructs Angular to ignore any components that have not
    been imported into the testing module.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段指示 Angular 忽略任何未导入到测试模块中的组件。
- en: Stubbing a dependency is very simple, but it is not always possible, as we will
    see in the following section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 存根依赖非常简单，但并不总是可能的，正如我们将在下一节中看到的。
- en: Spying on the dependency method
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监视依赖方法
- en: Using a stub is not the only way to isolate logic in a unit test. We don’t have
    to replace the entire dependency—only the parts our component uses. Replacing
    certain parts means we point out specific methods on the dependency and assign
    a spy to them. A spy can answer what you want, but you can also see how many times
    it was called and with what arguments. So, a spy gives you much more information
    about what is happening.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用存根不是在单元测试中隔离逻辑的唯一方法。我们不必替换整个依赖——只需替换组件使用的部分。替换某些部分意味着我们指出依赖中的特定方法，并将间谍分配给它们。间谍可以回答你想要的内容，但你也可以看到它被调用了多少次以及使用了什么参数。因此，间谍为你提供了更多关于发生情况的信息。
- en: 'There are two ways to set up a spy in a dependency:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在依赖中设置间谍有两种方式：
- en: Inject the actual dependency and spy on its methods.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入实际依赖并监视其方法。
- en: Use the Jasmine `createSpyObj` method to create a fake dependency instance.
    We can then spy on the methods of this dependency as we would with the real one.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jasmine 的 `createSpyObj` 方法来创建一个假的依赖实例。然后我们可以像对待真实实例一样监视这个依赖的方法。
- en: 'The first case is most common in Angular development. Let’s see how to set
    it up. Consider the following `spy.component.ts` file, which uses the `Title`
    service of the Angular framework:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况在 Angular 开发中最为常见。让我们看看如何设置它。考虑以下 `spy.component.ts` 文件，它使用了 Angular 框架的
    `Title` 服务：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Title` service interacts with the title of the main HTML document in an
    Angular application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Title` 服务与 Angular 应用程序中主 HTML 文档的标题进行交互。'
- en: 'We do not have any control over the `Title` service since it is built into
    the framework. It may have dependencies that we do not know about. Spying on its
    methods is the easiest and safest way to use it in our tests. We inject it in
    the testing module using the `providers` array and then use it in our test, such
    as:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `Title` 服务没有控制权，因为它已经内置到框架中。它可能包含我们不知道的依赖。监视其方法是我们在测试中使用它的最简单、最安全的方式。我们通过
    `providers` 数组将其注入到测试模块中，然后在我们的测试中使用它，例如：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We use the Jasmine `spyOn` method, which accepts two parameters: the object
    and its specific method to spy. We used it before calling the `ngOnInit` component
    method to attach the spy before triggering the change detection mechanism. The
    `expect` statement validates that the `setTitle` method was called with the correct
    arguments.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Jasmine 的 `spyOn` 方法，它接受两个参数：要监视的对象及其特定的方法。我们在调用 `ngOnInit` 组件方法之前使用它来在触发变更检测机制之前附加间谍。`expect`
    语句验证 `setTitle` 方法是否以正确的参数被调用。
- en: 'Our component also uses the `getTitle` method to get the document title. We
    can spy directly on that method and return mock data:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件还使用 `getTitle` 方法来获取文档标题。我们可以直接监视该方法并返回模拟数据：
- en: 'First, we need to define the `Title` service as a spy object and initialize
    it by passing two parameters—the name of the service and an array of the method
    names that the component currently uses:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将 `Title` 服务定义为间谍对象，并通过传递两个参数——服务的名称和组件当前使用的方程序表来初始化它：
- en: '[PRE20]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then we attach a spy to the `getTitle` method and return a custom title using
    the Jasmine `returnValue` method:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将间谍附加到 `getTitle` 方法，并使用 Jasmine 的 `returnValue` 方法返回一个自定义标题：
- en: '[PRE21]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we add the `titleSpy` variable in the `providers` array of the testing
    module:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在测试模块的 `providers` 数组中添加 `titleSpy` 变量：
- en: '[PRE22]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The resulting test should look like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 结果测试应该看起来像以下这样：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Very few services are well behaved and straightforward, such as the `Title`
    service, in the sense that they are synchronous. Most of the time, they are asynchronous
    and can return observables or promises. In the following section, we will learn
    how to test asynchronous dependencies.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有服务表现得很好且直接，例如 `Title` 服务，因为它们是同步的。大多数时候，它们是异步的，可以返回可观察对象或承诺。在下一节中，我们将学习如何测试异步依赖。
- en: Testing asynchronous services
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试异步服务
- en: 'Angular testing utilities provide two artifacts to tackle asynchronous testing
    scenarios:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Angular测试工具提供了两个工具来处理异步测试场景：
- en: '`waitForAsync` : An asynchronous approach to unit test services. It is combined
    with the `whenStable` method of the `ComponentFixture` class.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waitForAsync`：这是一种异步的单元测试服务的方法。它与`ComponentFixture`类的`whenStable`方法结合使用。'
- en: '`fakeAsync` : A synchronous approach to unit test services. It is used in combination
    with the `tick` function.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fakeAsync`：这是一种同步的单元测试服务的方法。它通常与`tick`函数结合使用。'
- en: Both approaches provide roughly the same functionality; they only differ in
    how we use them. Let’s see how we can use each by looking at an example.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法提供大致相同的功能；它们只是在我们的使用方式上有所不同。让我们通过查看一个示例来看看我们如何使用每种方法。
- en: 'Consider the following `async.component.ts` file:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下`async.component.ts`文件：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It injects the `AsyncService` from the `async.service.ts` file and calls its
    `getItems` method inside the `ngOnInit` method. As we can see, the `getItems`
    method returns an observable of strings. It also introduces a slight delay so
    that the scenario looks asynchronous:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 它从`async.service.ts`文件中注入`AsyncService`，并在`ngOnInit`方法中调用其`getItems`方法。正如我们所见，`getItems`方法返回一个字符串的可观察对象。它还引入了轻微的延迟，以便使场景看起来是异步的：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The unit test queries the native element of the component and checks whether
    the value of the `items$` observable is displayed correctly:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试会查询组件的原生元素，并检查`items$`可观察对象的价值是否正确显示：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We wrap the test body inside the `waitForAsync` method and call the `detectChanges`
    method to trigger change detection. Furthermore, we call the `whenStable` method,
    which returns a promise that is resolved immediately when the `items$` observable
    is complete. When the promise is resolved, we call the `detectChanges` method
    again to trigger data binding and query the DOM accordingly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将测试的主体包裹在`waitForAsync`方法内，并调用`detectChanges`方法来触发变更检测。此外，我们调用`whenStable`方法，它返回一个立即解决的承诺，当`items$`可观察对象完成时。当承诺解决时，我们再次调用`detectChanges`方法来触发数据绑定并相应地查询DOM。
- en: The `whenStable` method is also used when we want to test a component that contains
    a template-driven form. The asynchronous nature of this method makes it preferable
    to use reactive forms in our Angular applications.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要测试包含模板驱动的表单的组件时，也会使用`whenStable`方法。此方法的异步特性使得在Angular应用程序中使用响应式表单更为可取。
- en: 'An alternative synchronous approach would be to use the `fakeAsync` method
    and write the same unit test as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种同步的方法是使用`fakeAsync`方法，并按照以下方式编写相同的单元测试：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the previous snippet, we wrapped the test body in a `fakeAsync` method and
    replaced the `whenStable` method with the `tick` function. The `tick` function
    advances the time by `500` ms, which is the virtual delay we introduced in the
    `getItems` method of the `AsyncService` .
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将测试的主体包裹在`fakeAsync`方法内，并用`tick`函数替换了`whenStable`方法。`tick`函数将时间推进`500`毫秒，这是我们引入`AsyncService`的`getItems`方法中的虚拟延迟。
- en: Testing components with asynchronous services can sometimes become a nightmare.
    Still, each of the described approaches can significantly help us in this task.
    However, components are not only about services but also input and output bindings.
    In the following section, we will learn how to test the public API of a component.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步服务测试组件有时可能变得非常困难。然而，每种描述的方法都可以显著帮助我们完成这项任务。然而，组件不仅关于服务，还包括输入和输出绑定。在接下来的部分，我们将学习如何测试组件的公共API。
- en: Testing with inputs and outputs
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入和输出测试
- en: So far, we have learned how to test components with simple properties and tackle
    synchronous and asynchronous dependencies. But there is more to a component than
    that. As we learned in *Chapter 3* , *Structuring User Interfaces with Components*
    , a component has a public API consisting of inputs and outputs that should also
    be tested.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何测试具有简单属性的组件以及处理同步和异步依赖。但组件的内容远不止于此。正如我们在*第3章*，*使用组件构建用户界面*中学到的，组件有一个由输入和输出组成的公共API，这些也应该被测试。
- en: 'Since we want to test the public API of a component, it makes sense to test
    how it interacts when hosted from another component. Testing such a component
    can be done in two ways:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要测试组件的公共API，因此测试它从另一个组件托管时的交互是有意义的。测试这样的组件可以通过两种方式完成：
- en: We can verify that our input binding is correctly set.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以验证我们的输入绑定是否设置正确。
- en: We can verify that our output binding triggers correctly and that what it emits
    is received.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以验证我们的输出绑定是否正确触发，以及它发出的内容是否被接收。
- en: 'Suppose that we have the following `bindings.component.ts` file with an input
    and output binding:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含输入和输出绑定的 `bindings.component.ts` 文件：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Before we start writing our tests, we should create a test host component inside
    the `bindings.component.spec.ts` file that is going to use the component under
    test:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写测试之前，我们应该在 `bindings.component.spec.ts` 文件中创建一个测试宿主组件，该组件将使用要测试的组件：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the setup phase, notice that the `ComponentFixture` is of the `TestHostComponent`
    type:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置阶段，请注意 `ComponentFixture` 是 `TestHostComponent` 类型：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Our unit tests will validate the behavior of `BindingsComponent` when interacting
    with `TestHostComponent` .
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单元测试将验证 `BindingsComponent` 与 `TestHostComponent` 交互时的行为。
- en: 'The first test checks whether the input binding to the `title` property has
    been applied correctly:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试检查输入绑定是否已正确应用于 `title` 属性：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The second test validates whether the `isFavorite` property is wired up correctly
    with the `liked` output event:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试验证 `isFavorite` 属性是否正确地与 `liked` 输出事件连接：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the previous test, we query the DOM for the `<button>` element using the
    `nativeElement` property of the `ComponentFixture` class. Then, we click on it
    for the output event to emit. Alternatively, we could have used the `debugElement`
    property to find the button and use its `triggerEventHandler` method to click
    on it:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个测试中，我们使用 `ComponentFixture` 类的 `nativeElement` 属性查询 DOM 中的 `<button>` 元素。然后，我们点击它以触发输出事件。或者，我们也可以使用
    `debugElement` 属性找到按钮，并使用其 `triggerEventHandler` 方法来点击它：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding test, we use the `query` method, which accepts a **predicate**
    function as a parameter. The predicate uses the CSS method of the `By` class to
    locate an element by its CSS selector.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们使用了 `query` 方法，该方法接受一个 **谓词** 函数作为参数。谓词使用 `By` 类的 CSS 方法通过 CSS 选择器定位元素。
- en: As we learned in the *Introducing unit tests in Angular* section, the `debugElement`
    is framework agnostic. If you are sure that your tests will only run in a browser,
    you should go with the `nativeElement` property.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *Angular 中引入单元测试* 部分所学，`debugElement` 是框架无关的。如果你确定你的测试只会在浏览器中运行，你应该选择
    `nativeElement` 属性。
- en: The `triggerEventHandler` method accepts the event name we want to trigger as
    a parameter; in this case, it is the `click` event.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`triggerEventHandler` 方法接受我们想要触发的事件名称作为参数；在这种情况下，是 `click` 事件。'
- en: We could have avoided a lot of code if we had only tested the `BindingsComponent`
    , which would still have been valid. But we would have missed the opportunity
    to test it as a real-world scenario. The public API of a component is intended
    to be used by other components, so we should test it in this way.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只测试了 `BindingsComponent`，就可以避免很多代码，这仍然会是有效的。但我们就会错过将其作为真实场景进行测试的机会。组件的公共
    API 旨在被其他组件使用，因此我们应该以这种方式进行测试。
- en: Currently, the button we use in the template of the `BindingsComponent` is a
    native HTML `<button>` element. If the button was an Angular Material button component,
    we could use an alternate approach for interacting with it, which is the topic
    of the following section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们在 `BindingsComponent` 的模板中使用的按钮是一个原生的 HTML `<button>` 元素。如果按钮是 Angular
    Material 按钮组件，我们可以使用另一种与之交互的方法，这是下一节的主题。
- en: Testing with a component harness
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用组件 harness 进行测试
- en: The Angular CDK library, the core of Angular Material, contains a set of utilities
    that allow a test to interact with a component over a public testing API. Angular
    CDK testing utilities enable us to access Angular Material components without
    relying on their internal implementation using a **component harness** .
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CDK 库，Angular Material 的核心，包含一组实用工具，允许测试通过公共测试 API 与组件交互。Angular CDK
    测试实用工具使我们能够通过组件 harness 访问 Angular Material 组件，而无需依赖它们的内部实现。
- en: 'The process of testing an Angular component using a harness consists of the
    following parts:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 harness 测试 Angular 组件的过程包括以下部分：
- en: '`@angular/cdk/testing` : The npm package that contains infrastructure for interacting
    with a component harness.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@angular/cdk/testing`：包含与组件 harness 交互的基础设施的 npm 包。'
- en: '**Testing environment** : The environment in which the component harness test
    will be loaded. The Angular CDK contains a built-in testing environment for unit
    testing with Karma. It also provides a rich set of tools that allow developers
    to create custom testing environments.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试环境**：组件 harness 测试将被加载的环境。Angular CDK 包含一个用于 Karma 单元测试的内置测试环境。它还提供了一套丰富的工具，允许开发者创建自定义测试环境。'
- en: '**Component harness** : A class that gives the developer access to the instance
    of a component in the browser DOM.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件harness**：一个类，它为开发者提供了访问浏览器DOM中组件实例的权限。'
- en: 'To learn how to use component harnesses, we will convert the `<button>` element
    of the `BindingsComponent` into an Angular Material button:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习如何使用组件harness，我们将`BindingsComponent`中的`<button>`元素转换为Angular Material按钮：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding snippet assumes that you have added the Angular Material library
    to the project that you are working on.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段假设你已经将Angular Material库添加到你正在工作的项目中。
- en: 'To start using a component harness from the Angular CDK, we need to import
    the following artifacts from the `@angular/cdk/testing` namespace:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Angular CDK的组件harness，我们需要从`@angular/cdk/testing`命名空间导入以下元素：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding snippet, we have added the following classes:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们添加了以下类：
- en: '`TestbedHarnessEnvironment` : Represents the testing environment for running
    unit tests with Karma.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestbedHarnessEnvironment`：表示使用Karma运行单元测试的测试环境。'
- en: '`MatButtonHarness` : The component harness for the Angular Material button
    component. Almost all components of the Angular Material library have a corresponding
    component harness that we can use.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MatButtonHarness`：Angular Material按钮组件的组件harness。Angular Material库中的几乎所有组件都有一个相应的组件harness，我们可以使用它。'
- en: If you are a component library author, the Angular CDK provides all the necessary
    tools for creating harnesses for your UI components.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你是一个组件库的作者，Angular CDK提供了创建UI组件harness所需的所有必要工具。
- en: 'After we have finished importing all the necessary artifacts, we can write
    our test:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们导入所有必要的元素之后，我们可以编写我们的测试：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding test, the `loader` method of the testing environment accepts
    the `ComponentFixture` instance of the current component as a parameter and returns
    a `HarnessLoader` object. The abstraction that an Angular CDK harness provides
    is based on the concept that it operates on the component fixture, which is an
    abstraction layer on top of the actual DOM element.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，测试环境的`loader`方法接受当前组件的`ComponentFixture`实例作为参数，并返回一个`HarnessLoader`对象。Angular
    CDK harness提供的抽象是基于它操作组件固定层（component fixture），这是一个在真实DOM元素之上的抽象层。
- en: We surround the body of the test inside an `async` function because component
    harnesses are promise-based. We use the `getHarness` method of the harness loader
    to load the specific harness for the button component. Finally, we call the `click`
    method of the button component harness to trigger the button click event.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在测试的体内包围一个`async`函数，因为组件harness是基于promise的。我们使用harness loader的`getHarness`方法来加载按钮组件的特定harness。最后，我们调用按钮组件harness的`click`方法来触发按钮点击事件。
- en: We do not need to call the `detectChanges` method because the Angular CDK component
    harness triggers change detection automatically.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要调用`detectChanges`方法，因为Angular CDK组件harness会自动触发变更检测。
- en: The component harness is a powerful Angular CDK tool that ensures we interact
    with components abstractly and safely during testing.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 组件harness是Angular CDK的一个强大工具，确保我们在测试期间以抽象和安全的方式与组件交互。
- en: We have discussed many ways to test a component with a dependency. Now, it is
    time to learn how to test the dependency itself.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了许多测试具有依赖项的组件的方法。现在，是时候学习如何测试依赖项本身了。
- en: Testing services
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试服务
- en: 'As we learned in *Chapter 5* , *Managing Complex Tasks with Services* , a service
    can inject other services. Testing a standalone service is pretty straightforward:
    we get an instance from the injector and then start to query its public properties
    and methods.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第5章*，*使用服务管理复杂任务*中学到的，一个服务可以注入其他服务。测试独立服务相当直接：我们从注入器获取一个实例，然后开始查询其公共属性和方法。
- en: We are only interested in testing the public API of a service, which is the
    interface that components and other artifacts use. Private properties and methods
    do not have any value when tested because they represent the internal implementation
    of the service.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只对测试服务的公共API感兴趣，这是组件和其他元素使用的接口。私有属性和方法在测试中没有价值，因为它们代表了服务的内部实现。
- en: 'There are two different types of testing that we can perform in a service:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务中，我们可以执行两种不同的测试：
- en: Testing synchronous and asynchronous operations, such as a method that returns
    a simple array or one that returns an observable
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试同步和异步操作，例如返回一个简单数组的方法或返回一个可观察对象的方法
- en: Testing services with dependencies, such as a method that makes HTTP requests
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试具有依赖项的服务，例如执行HTTP请求的方法
- en: In the following sections, we will go through each in more detail.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将更详细地介绍每个部分。
- en: Testing synchronous/asynchronous methods
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试同步/异步方法
- en: 'When we create an Angular service using the Angular CLI, it also creates a
    corresponding test file. Consider the following `async.service.spec.ts` file,
    which is the test file for the `AsyncService` we used earlier:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Angular CLI 创建 Angular 服务时，它也会创建一个相应的测试文件。考虑以下 `async.service.spec.ts`
    文件，这是我们之前使用的 `AsyncService` 的测试文件：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `AsyncService` is not dependent on anything. It is also provided with the
    root injector of the Angular application, so it passes an empty object to the
    `configureTestingModule` method. We can get an instance of the service we test
    using the `inject` method of the `TestBed` class.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncService` 不依赖于任何东西。它还由 Angular 应用的根注入器提供，因此它将一个空对象传递给 `configureTestingModule`
    方法。我们可以使用 `TestBed` 类的 `inject` 方法获取我们测试的服务的实例。'
- en: 'The first test that we can write is pretty straightforward as it calls the
    `setItems` method and inspects its result:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写的第一个测试相当直接，因为它调用 `setItems` 方法并检查其结果：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Writing a test for synchronous methods, as in the previous case, is usually
    relatively easy; however, things are different when we want to test an asynchronous
    method such as the following.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个案例中同步方法的测试相比，编写同步方法的测试通常相对容易；然而，当我们想要测试如下的异步方法时，情况就不同了。
- en: 'This second test is a bit tricky because it involves an observable. We need
    to subscribe to the `getItems` method and inspect the value as soon as the observable
    is complete:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试有点棘手，因为它涉及到一个可观察对象。我们需要订阅 `getItems` 方法，并在可观察对象完成时立即检查其值：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The Karma test runner does not know when an observable will complete, so we
    provide the `done` method to signal that the observable has been completed, and
    we can now assert the `expect` statement.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Karma 测试运行器不知道可观察对象何时完成，因此我们提供了 `done` 方法来表示可观察对象已完成，我们现在可以断言 `expect` 语句。
- en: Testing services with dependencies
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试具有依赖关系的服务
- en: Testing services with dependencies is similar to testing components with dependencies.
    Every method we saw in the *Testing components* section can be applied similarly;
    however, we follow a different approach when testing a service that injects the
    `HttpClient` service.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 测试具有依赖关系的服务与测试具有依赖关系的组件类似。我们在 *测试组件* 部分看到的每个方法都可以类似地应用；然而，当我们测试注入 `HttpClient`
    服务的服务时，我们遵循不同的方法。
- en: 'Consider the following `deps.service.ts` file that uses the HTTP client:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下使用 HTTP 客户端的 `deps.service.ts` 文件：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Angular testing utilities provide two artifacts for mocking HTTP requests in
    unit tests: the `provideHttpClientTesting` function, which provides an HTTP client
    for testing, and the `HttpTestingController` , which mocks the `HttpClient` service.
    We can import both from the `@angular/common/http/testing` namespace:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 测试工具提供了两个用于在单元测试中模拟 HTTP 请求的工件：`provideHttpClientTesting` 函数，它为测试提供了一个
    HTTP 客户端，以及 `HttpTestingController`，它模拟 `HttpClient` 服务。我们可以从 `@angular/common/http/testing`
    命名空间导入这两个：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Our tests should not make a real HTTP request. They only need to validate that
    it will be made with the correct options. The following is the first test that
    validates the `getItems` method:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试不应该发出真实的 HTTP 请求。它们只需要验证它将以正确的选项发出。以下是对 `getItems` 方法进行验证的第一个测试：
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding test, we create a fake request using the `expectOne` method
    of the `HttpTestingController` that takes a URL as an argument. The `expectOne`
    method creates a mock request object and asserts that only one request is made
    to the specific URL. After we have created our request, we can validate that its
    method is `GET` .
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们使用 `HttpTestingController` 的 `expectOne` 方法创建了一个假请求，该方法接受一个 URL 作为参数。`expectOne`
    方法创建一个模拟请求对象，并断言只向特定的 URL 发出了一个请求。在我们创建我们的请求后，我们可以验证其方法是 `GET`。
- en: 'We follow a similar approach when testing the `addItem` method, except that
    we need to make sure that the body of the request contains the correct data:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试 `addItem` 方法时，我们遵循类似的方法，但我们需要确保请求体包含正确的数据：
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After each test, we make sure that no unmatched requests are pending using
    the `verify` method inside an `afterEach` block:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个测试之后，我们使用 `afterEach` 块内的 `verify` 方法确保没有未匹配的请求挂起：
- en: '[PRE44]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the following section, we continue our journey through the testing world
    by learning how to test a pipe.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们继续我们的测试之旅，通过学习如何测试一个管道来继续探索测试世界。
- en: Testing pipes
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试管道
- en: As we learned in *Chapter 4* , *Enriching Applications Using Pipes and Directives*
    , a pipe is a TypeScript class that implements the `PipeTransform` interface.
    It exposes a `transform` method, which is usually synchronous, which means it
    is straightforward to test.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *第 4 章* ，*使用管道和指令丰富应用程序* 中所学，管道是一个实现了 `PipeTransform` 接口的 TypeScript 类。它公开了一个
    `transform` 方法，这个方法通常是同步的，这意味着它很容易测试。
- en: 'Consider the `list.pipe.ts` file containing a pipe that converts a comma-separated
    string into a list:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑包含将逗号分隔的字符串转换为列表的管道的 `list.pipe.ts` 文件：
- en: '[PRE45]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Writing a test is simple. The only thing that we need to do is to instantiate
    an instance of the `ListPipe` class and verify the outcome of the `transform`
    method with some mock data:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试很简单。我们唯一需要做的是实例化 `ListPipe` 类的一个实例，并使用一些模拟数据验证 `transform` 方法的输出结果：
- en: '[PRE46]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Angular testing utilities are not involved when testing a pipe. We create an
    instance of the pipe class, and we can start calling the `transform` method.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试管道时，不涉及 Angular 测试工具。我们创建管道类的实例，然后可以开始调用 `transform` 方法。
- en: Angular directives are artifacts that we may not create very often since the
    built-in collection that the framework provides is more than enough; however,
    if we create custom directives, we should also test them. In the following section,
    we will learn how to accomplish this.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 指令是我们可能不会经常创建的工件，因为框架提供的内置集合已经足够多了；然而，如果我们创建了自定义指令，我们也应该测试它们。在下一节中，我们将学习如何完成这项工作。
- en: Testing directives
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试指令
- en: Directives are usually quite straightforward in their overall shape, being components
    with no view attached. The fact that directives usually work with components gives
    us a good idea of how to proceed when testing them.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 指令在整体形状上通常非常直接，它们是没有视图的组件。指令通常与组件一起工作的事实，让我们对测试它们时如何进行有了很好的了解。
- en: 'Consider the `copyright.directive.ts` file that we created in *Chapter 5* ,
    *Enriching Applications Using Pipes and Directives* :'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们创建在 *第 5 章* ，*使用管道和指令丰富应用程序* 中的 `copyright.directive.ts` 文件：
- en: '[PRE47]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'A directive is usually used with a component, so it makes sense to unit test
    it while using it on a component. Let’s create a test host component and add it
    to the `imports` array of the testing module:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 指令通常与组件一起使用，因此在使用组件的同时对其进行单元测试是有意义的。让我们创建一个测试宿主组件并将其添加到测试模块的 `imports` 数组中：
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can now write our tests that check whether the `<span>` element contains
    the `copyright` class and displays the current year in its `textContent` property:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以编写测试来检查 `<span>` 元素是否包含 `copyright` 类，并在其 `textContent` 属性中显示当前年份：
- en: '[PRE49]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is how simple it can be to test a directive. The key takeaways are that
    you need a component to place the directive on and that you implicitly test the
    directive using the component.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是测试指令可以有多简单。关键要点是，你需要一个组件来放置指令，并且你隐式地使用组件来测试指令。
- en: In the following section, we will learn how to test reactive forms.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何测试响应式表单。
- en: Testing forms
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试表单
- en: As we saw in *Chapter 10* , *Collecting User Data with Forms* , forms are integral
    to an Angular application. It is rare for an Angular application not to have at
    least one simple form, such as a search form. In this chapter, we will focus on
    reactive forms because they are easier to test than template-driven forms.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *第 10 章* ，*使用表单收集用户数据* 中所见，表单对于 Angular 应用程序至关重要。Angular 应用程序没有至少一个简单表单的情况很少见，例如搜索表单。在本章中，我们将专注于响应式表单，因为它们比模板驱动的表单更容易测试。
- en: 'Consider the following `search.component.ts` file:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 `search.component.ts` 文件：
- en: '[PRE50]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the preceding component, we can write our unit tests to verify that:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的组件中，我们可以编写单元测试来验证以下内容：
- en: The value of the `searchText` form control can be set correctly
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchText` 表单控件的值可以正确设置'
- en: The `Search` button is disabled when the form is invalid
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当表单无效时，`Search` 按钮被禁用
- en: The `console.log` method is called when the form is valid, and the user clicks
    the **Search** button
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当表单有效，并且用户点击 **Search** 按钮时，会调用 `console.log` 方法
- en: 'To test a reactive form, we first need to import `ReactiveFormsModule` into
    the testing module:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试响应式表单，我们首先需要将 `ReactiveFormsModule` 导入到测试模块中：
- en: '[PRE51]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'For the first test, we need to assert whether the value propagates to the `searchText`
    form control when we type something into the input control:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个测试，我们需要断言当我们向输入控件中输入内容时，值是否传播到 `searchText` 表单控件：
- en: '[PRE52]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the preceding test, we use the `querySelector` method of the `nativeElement`
    property to find the `<input>` HTML element and set its value. But this alone
    will not be sufficient for the value to propagate to the form control. The Angular
    framework will not know whether the value of the `<input>` HTML element has changed
    until we trigger the `input` DOM event to that element. We are using the `dispatchEvent`
    method to trigger the event, which accepts a single method as a parameter that
    points to an instance of the `CustomEvent` class.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们使用 `nativeElement` 属性的 `querySelector` 方法找到 `<input>` HTML 元素并设置其值。但仅此不足以使值传播到表单控件。Angular
    框架将不知道 `<input>` HTML 元素的值是否已更改，直到我们触发该元素的 `input` DOM 事件。我们正在使用 `dispatchEvent`
    方法来触发事件，该方法接受一个参数，该参数指向 `CustomEvent` 类的实例。
- en: 'Now that we are sure that the `searchText` form control is wired up correctly,
    we can use it to write the remaining tests:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们确信 `searchText` 表单控件已正确连接，我们可以使用它来编写剩余的测试：
- en: '[PRE53]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that in the second test, we set the value of the `searchText` form control,
    and then we call the `detectChanges` method for the button to be enabled. Clicking
    on the button triggers the `submit` event of the form, and we can finally assert
    the expectation of our test.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第二个测试中，我们设置了 `searchText` 表单控件的值，然后调用按钮的 `detectChanges` 方法以启用它。点击按钮将触发表单的
    `submit` 事件，我们最终可以断言测试的期望。
- en: 'In cases where a form has many controls, it is not convenient to query them
    inside our tests. Alternatively, we can create a `Page` object that takes care
    of querying HTML elements and spying on services:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单有多个控件的情况下，在测试中查询它们并不方便。作为替代，我们可以创建一个 `Page` 对象，该对象负责查询 HTML 元素并监视服务：
- en: '[PRE54]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We can then create an instance of the `Page` object in the `beforeEach` statement
    and access its properties and methods in our tests.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在 `beforeEach` 语句中创建 `Page` 对象的实例，并在测试中访问其属性和方法。
- en: As we have seen, reactive forms are very easy to test since the form model is
    the single source of truth. In the following section, we will learn how to test
    parts of an Angular application that use the router.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，响应式表单很容易测试，因为表单模型是唯一的真相来源。在下一节中，我们将学习如何测试使用路由的 Angular 应用程序的某些部分。
- en: Testing the router
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试路由器
- en: 'Testing code interacting with the Angular router could easily be a separate
    chapter. In this section, we will focus on the following router concepts:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 测试与 Angular 路由交互的代码可能很容易成为一个单独的章节。在本节中，我们将关注以下路由概念：
- en: Routed and routing components
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由和路由组件
- en: Guards
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 守卫
- en: Resolvers
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析器
- en: Let’s see first how to test routed and routing components.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看如何测试路由和路由组件。
- en: Routed and routing components
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由和路由组件
- en: 'A routed component is a component that is activated when we navigate to a specific
    application route. Consider the following `app.routes.ts` file:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 路由组件是在我们导航到特定应用程序路由时被激活的组件。考虑以下 `app.routes.ts` 文件：
- en: '[PRE55]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `RoutedComponent` class is defined in the following `routed.component.ts`
    file:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`RoutedComponent` 类定义在下面的 `routed.component.ts` 文件中：'
- en: '[PRE56]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The preceding component binds the value of the `title` component property to
    a `<span>` HTML element. The test we will write will assert if the binding works
    correctly.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的组件将 `title` 组件属性的值绑定到一个 `<span>` HTML 元素上。我们将编写的测试将断言绑定是否正确工作。
- en: 'Angular router testing is based on the component harness approach we learned
    about in the *Testing components* section. It exposes the `RouterTestingHarness`
    class, which contains various utility methods for working with routed components
    in tests:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 路由测试基于我们在 *测试组件* 部分学习到的组件 harness 方法。它公开了 `RouterTestingHarness` 类，该类包含在测试中处理路由组件的各种实用方法：
- en: '[PRE57]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Before we can start testing a routed component, we must register the application
    routing configuration in the testing module:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始测试路由组件之前，我们必须在测试模块中注册应用程序的路由配置：
- en: '[PRE58]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the preceding setup process, we provide the application routing configuration
    as in the `app.config.ts` file.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的设置过程中，我们提供了与应用程序路由配置相同的 `app.config.ts` 文件。
- en: 'We have already learned that we can query the DOM of the native HTML element
    from the `ComponentFixture` class. When a component is loaded using the router,
    we use the `routeNativeElement` property instead from the `RouterTestingHarness`
    class:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，我们可以从 `ComponentFixture` 类查询原生 HTML 元素的 DOM。当使用路由器加载组件时，我们使用 `RouterTestingHarness`
    类的 `routeNativeElement` 属性：
- en: '[PRE59]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The preceding test is separated into the following steps:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试被分为以下步骤：
- en: We use the `create` method of the `RouterTestingHarness` to create a new routing
    harness for our component.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`RouterTestingHarness`的`create`方法为我们的组件创建一个新的路由测试工具。
- en: We navigate to the registered route path using the `navigateByUrl` method. According
    to the application routing configuration, the `/routed` URL will activate the
    component under test.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`navigateByUrl`方法导航到已注册的路由路径。根据应用程序的路由配置，`/routed`URL将激活测试中的组件。
- en: We use standard query methods of the `routeNativeElement` property to verify
    that the `<span>` HTML element displays the correct text.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`routeNativeElement`属性的标准化查询方法来验证`<span>`HTML元素是否显示了正确的文本。
- en: The `RouterTestingHarness` class also contains the `routeDebugElement` property,
    which works cross-platform similarly to the `debugElement` property of the `ComponentFixture`
    class.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterTestingHarness`类还包含`routeDebugElement`属性，它跨平台的工作方式类似于`ComponentFixture`类的`debugElement`属性。'
- en: 'A routing component is a component that is used to navigate to another component
    in an Angular application. It usually involves calling the `navigate` method of
    the `Router` service as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 路由组件是一个用于在Angular应用程序中导航到另一个组件的组件。它通常涉及调用`Router`服务的`navigate`方法，如下所示：
- en: '[PRE60]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'According to the preceding snippet, our test should verify that the router
    will navigate to the root path when we call the `goBack` method:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的代码片段，我们的测试应该验证当我们调用`goBack`方法时，路由器将导航到根路径：
- en: '[PRE61]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In the preceding test, we use the `inject` method of the `TestBed` class to
    get a reference to the `Router` service. We then access the `url` property to
    verify that the navigation process was completed correctly.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们使用`TestBed`类的`inject`方法获取`Router`服务的引用。然后我们访问`url`属性以验证导航过程是否正确完成。
- en: In the following section, we will learn how to test router guards.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将学习如何测试路由守卫。
- en: Guards
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 守卫
- en: We learned in *Chapter 9* , *Navigating through Applications with Routing* ,
    that router guards are plain functions.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第9章*，*使用路由导航应用程序*中了解到，路由守卫是普通的函数。
- en: 'Consider the following guard that checks the authentication status of a user:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下检查用户认证状态的守卫：
- en: '[PRE62]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the preceding guard, we check the `isLoggedIn` property of the following
    `AuthService` class:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的守卫中，我们检查了以下`AuthService`类的`isLoggedIn`属性：
- en: '[PRE63]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We decided to keep the `AuthService` class simple and focus on the logic of
    the authentication guard.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定保持`AuthService`类简单，并专注于认证守卫的逻辑。
- en: If the `isLoggedIn` property is `true` , the guard also returns `true` . Otherwise,
    it executes the `parseUrl` method of the `Router` service to redirect users to
    the root path.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`isLoggedIn`属性为`true`，守卫也返回`true`。否则，它执行`Router`服务的`parseUrl`方法，将用户重定向到根路径。
- en: 'The Angular CLI has created the following unit test for the guard:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI为守卫创建了以下单元测试：
- en: '[PRE64]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the preceding snippet, the `executeGuard` variable encapsulates the creation
    of the `authGuard` function. It uses the `runInInjectionContext` method of the
    `TestBed` class to allow the injection of required services using the `inject`
    method.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`executeGuard`变量封装了`authGuard`函数的创建。它使用`TestBed`类的`runInInjectionContext`方法，通过`inject`方法允许注入所需的服务。
- en: 'To create unit tests that validate the usage of the authentication guard, we
    must execute the following steps:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建验证认证守卫使用的单元测试，我们必须执行以下步骤：
- en: 'Modify the `import` statement of the `@angular/router` npm package as follows:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改`@angular/router`npm包的`import`语句：
- en: '[PRE65]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Add the following `import` statement:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`import`语句：
- en: '[PRE66]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Create the following variables that correspond to the injected services:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下与注入服务对应的变量：
- en: '[PRE67]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Initialize the preceding variables in the `beforeEach` statement of the test
    suite:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试套件的`beforeEach`语句中初始化前面的变量：
- en: '[PRE68]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In the preceding snippet, we use the `createSpyObj` method to create a spy object
    for the `Router` service and provide it to the testing module. Additionally, we
    get the instance of the actual `AuthService` class using the `inject` method of
    the `TestBed` class because it is a simple service with no dependencies.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用`createSpyObj`方法为`Router`服务创建一个间谍对象，并将其提供给测试模块。此外，我们使用`TestBed`类的`inject`方法获取实际`AuthService`类的实例，因为它是一个没有依赖的简单服务。
- en: 'The first unit test should assert that the guard execution returns `true` when
    the user is authenticated:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个单元测试应该断言当用户认证时，守卫执行返回`true`：
- en: '[PRE69]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We pass an empty object for the `ActivatedRouteSnapshot` and `RouterStateSnapshot`
    parameters because they are unnecessary in the guard.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`ActivatedRouteSnapshot`和`RouterStateSnapshot`参数传递一个空对象，因为它们在守卫中是不必要的。
- en: 'The second unit test should verify that the guard execution causes a redirection
    to the root path:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个单元测试应验证守卫执行导致重定向到根路径：
- en: '[PRE70]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the following section, we will learn how to test guard resolvers.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何测试守卫解析器。
- en: Resolvers
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析器
- en: Router resolvers are plain functions of a specific type similar to guards. The
    most common scenario when testing resolvers is to verify that the returned data
    is correct.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 路由解析器是特定类型的普通函数，类似于守卫。在测试解析器时最常见的情况是验证返回的数据是否正确。
- en: 'Consider the following resolver, which returns a list of items:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下解析器，它返回一个项目列表：
- en: '[PRE71]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The resolver uses the `AsyncService` we saw earlier, which returns an observable
    of items using the `getItems` method.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器使用了我们之前看到的`AsyncService`，它通过`getItems`方法返回一个包含项目的可观察对象。
- en: 'The Angular CLI will initially create the following unit test file when scaffolding
    the resolver:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI在搭建解析器时会最初创建以下单元测试文件：
- en: '[PRE72]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In the preceding snippet, the `executeResolver` variable encapsulates the creation
    of the `itemsResolver` function, similar to how it does with guards. It also uses
    the `runInInjectionContext` method of the `TestBed` class to allow the injection
    of required services.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`executeResolver`变量封装了`itemsResolver`函数的创建，类似于它对守卫的处理。它还使用了`TestBed`类的`runInInjectionContext`方法来允许注入所需的服务。
- en: 'The logic of our resolver is very simple, so we must write a single unit test:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解析器逻辑非常简单，因此我们必须编写一个单独的单元测试：
- en: 'Modify the `import` statement of the `@angular/router` npm package as follows:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`@angular/router` npm包的`import`语句如下：
- en: '[PRE73]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Add the following `import` statement:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`import`语句：
- en: '[PRE74]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Change the type of the `executeResolver` variable to `ResolveFn<string[]>`
    so that it matches the signature of the `itemsResolver` function:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`executeResolver`变量的类型更改为`ResolveFn<string[]>`，以便与`itemsResolver`函数的签名匹配：
- en: '[PRE75]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Write the following unit test:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下单元测试：
- en: '[PRE76]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: To verify that the resolver returns correct data, we must subscribe to the `executeResolver`
    function.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证解析器返回的数据是否正确，我们必须订阅`executeResolver`函数。
- en: In this section, we learned how to unit test some important features of the
    Angular router.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何对Angular路由器的一些重要功能进行单元测试。
- en: Summary
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We are at the end of our testing journey, and it’s been a long but exciting
    one. In this chapter, we saw the importance of introducing unit testing in our
    Angular applications, the basic shape of a unit test, and the process of setting
    up Jasmine for our tests.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试之旅即将结束，这是一段漫长但令人兴奋的旅程。在本章中，我们看到了在Angular应用程序中引入单元测试的重要性，单元测试的基本形状以及为我们的测试设置Jasmine的过程。
- en: We also learned how to write robust tests for our components, directives, pipes,
    and services. We also discussed how to test Angular reactive forms and the router.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何为我们的组件、指令、管道和服务编写健壮的测试。我们还讨论了如何测试Angular响应式表单和路由器。
- en: This unit testing chapter has almost completed the puzzle of building a complete
    Angular application. Only the last piece remains, which is important because web
    applications are ultimately destined for the web. Therefore, in the next chapter,
    we will learn how to produce a production build for an Angular application and
    deploy it to share with the rest of the world!
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 本单元测试章节几乎完成了构建完整Angular应用程序的拼图。只剩下最后一块，这很重要，因为网络应用程序最终注定要面向网络。因此，在下一章中，我们将学习如何为Angular应用程序生成生产构建并将其部署以与世界分享！
