- en: 14\. Deploying Your Code to the Web
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14. 将您的代码部署到网络
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to explain the benefits of a CI/CD
    workflow and how it ties into the release cycle, release cadence, and development
    workflows. To this end, you'll be able to articulate what the differences between
    Vue.js development and production builds are and what trade-offs are made. In
    order to test and deploy a Vue.js application, you'll configure GitLab CI/CD with
    pipelines, jobs, and steps. You'll become familiar with Netlify, AWS S3, and AWS
    CloudFront, and their key similarities and differences.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够解释 CI/CD 工作流程的好处以及它是如何与发布周期、发布节奏和开发工作流程相结合的。为此，您将能够阐述 Vue.js 开发与生产构建之间的差异以及所做出的权衡。为了测试和部署
    Vue.js 应用程序，您将配置 GitLab CI/CD，包括管道、作业和步骤。您将熟悉 Netlify、AWS S3 和 AWS CloudFront，以及它们的关键相似之处和差异。
- en: In this chapter, we will look at how to deploy a Vue.js application to be consumed
    over the World Wide Web and how to automate this deployment process to release
    often with ease and confidence.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何将 Vue.js 应用程序部署到万维网，以及如何自动化此部署过程以轻松和有信心地频繁发布。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will look at how you might leverage CI/CD tools and techniques
    to deliver applications to production with high confidence and at high frequency.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何利用 CI/CD 工具和技术，以高信心和高频率将应用程序交付到生产环境中。
- en: In previous chapters, we saw how to build and test complex Vue.js applications.
    This chapter is about leveraging all the techniques, including testing and automating
    them, in order to deliver software to production with minimal risk and time overhead.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何构建和测试复杂的 Vue.js 应用程序。本章是关于利用所有技术，包括测试和自动化它们，以最小风险和时间开销将软件交付到生产环境中。
- en: The Benefits of CI/CD as Part of an Agile Software Development Process
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI/CD 作为敏捷软件开发过程的一部分的好处
- en: '**Continuous integration** (**CI**) is the practice of integrating code multiple
    times a day. In order to support this, a modern **version control system** (**VCS**)
    such as Git that supports multiple working states (branches) in a single repository
    is necessary in order to allow developers to work on code independently, while
    still allowing them to collaborate and integrate their changes safely.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）是每天多次集成代码的实践。为了支持这一点，需要一个支持单个存储库中多个工作状态（分支）的现代 **版本控制系统**（**VCS**），如
    Git，以便允许开发者独立工作代码，同时仍然允许他们安全地协作和集成他们的更改。'
- en: To augment the abilities of the VCS, hosting and collaboration tools around
    repositories (such as GitLab or GitHub) have been created and allow developers
    to view and manage code changes more efficiently through a web **user interface**
    (**UI**).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增强版本控制系统（VCS）、存储库（如 GitLab 或 GitHub）周围的托管和协作工具的能力，已经创建了这些工具，并允许开发者通过网页 **用户界面**（**UI**）更有效地查看和管理代码更改。
- en: As part of, or in addition to, these hosting platforms and the collaboration
    tools they provide, automated checks are crucial to maintaining high confidence
    in the quality of the code before, during, and after integration. Adopting a CI
    approach often entails including additional code quality steps, such as unit or
    integration tests, coverage checks, and building artifacts on the mainline branches
    (branches into which changes are integrated) every time any new code is integrated.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这些托管平台及其提供的协作工具的一部分，或作为补充，自动检查对于在集成前后保持代码质量的高信心至关重要。采用 CI 方法通常意味着包括额外的代码质量步骤，例如单元或集成测试、覆盖率检查，以及每次任何新代码集成到主线分支（集成更改的分支）时构建工件。
- en: The conventions that a team follows for using Git for code collaboration and
    CI are called a **Git workflow**, which is often shortened to **Git flow**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 团队遵循的用于代码协作和 CI 的 Git 规范被称为 **Git 工作流程**，通常简称为 **Git flow**。
- en: A Git flow will predicate branch naming conventions, as well as how and when
    changes are integrated. For example, a team might decide that branches should
    be prefixed with ticket numbers followed by a short dash-cased description such
    as `WRK-2334-fix-ie-11-scroll`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Git flow 将决定分支命名规范，以及如何以及何时集成更改。例如，一个团队可能会决定分支应以工单编号开头，后跟一个简短的短划线小写描述，例如 `WRK-2334-fix-ie-11-scroll`。
- en: Other examples of conventions that are decided on and adhered to as part of
    a Git flow are commit message lengths and titles, the automated checks that should
    pass or are allowed to fail, and the number of reviewers required to merge a change
    request, which is a pull request or merge request in GitHub and GitLab parlance, respectively.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Git flows fall under two rough categories: trunk-based development and (feature)
    branch-based development. We''ll cover branch-based development first since its
    limitations have become quite clear and the majority of projects tend to use trunk-based
    development.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: In a branch-based Git workflow, multiple working branches are kept in the repository.
    Branch-based flows can be used to keep branches that mirror the state of environments.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following diagram shows three branches – **production**, **staging**,
    and **develop**. **production** does not contain any changes from **staging**
    or **develop**. **staging** is ahead of **production** but has no changes in common
    with **develop** other than the changes that are on **production**. **develop**
    is ahead of both **staging** and **production**: it''s branched off of **production**
    at the same commit as **staging** is, but it doesn''t share any further commits
    with **staging**:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1: An example of a branch-based Git commit/branch tree'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: with three environment branches
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.1: An example of a branch-based Git commit/branch tree with three
    environment branches'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: A branch-based workflow can also be used to keep track of changes going into
    release lines. This is useful in cases where a project has to maintain two versions
    of an application or library, but bug fixes or security patches need to be applied
    to both versions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we have got a similar branching example as the environment
    branch one. Release 1.0.0 contains some changes that are not present in 1.0.1
    and 1.1.0 but does not share any of the newer code. Releases 1.0.1 and 1.1.0 are
    branched off of 1.0.0 at the same time, but they do not share further changes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2: An example of a branch-based Git commit/branch tree'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: with three release branches
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.2: An example of a branch-based Git commit/branch tree with three
    release branches'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'In a trunk-based Git flow, each member of the team will create new branches
    off of a single branch, usually the "master" branch. This process is often referred
    to as "branching off of":'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3: A sample trunk-based Git commit/branch tree with two feature
    branches branched off of the master'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.3: A sample trunk-based Git commit/branch tree with two feature branches
    branched off of the master'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: An extreme case of a trunk-based workflow is to have a *single* branch that
    everyone commits on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: In a trunk-based environment, an alternative to "release branches" is to use
    Git tags to keep track of release snapshots. This gives the same advantages as
    maintaining branches with reduced branch noise and the added benefit of immutability
    since tags cannot be changed once they're created.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于仓库的环境下，"发布分支"的替代方案是使用 Git 标签来跟踪发布快照。这提供了与维护分支相同的优势，即减少了分支噪音，并且由于标签一旦创建就不能更改，因此具有不可变性的额外好处。
- en: '**Continuous delivery** (**CD**) is the ability of a team to deploy every good
    build to a production environment.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续交付（CD**）是团队能够将每个良好的构建部署到生产环境的能力。'
- en: A pre-requisite to CD is CI, since CI provides some initial confidence in the
    quality of a build. As part of CD, new systems, tools, and practices are required
    beyond CI.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付（CD）的一个先决条件是持续集成（CI），因为持续集成（CI）为构建的质量提供了一些初始的信心。作为持续交付（CD）的一部分，除了持续集成（CI）之外，还需要新的系统、工具和实践。
- en: 'Refer to the following diagram for a look at the tools and practices that relate
    more to CI and those that relate more to CD:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下图表，了解与持续集成（CI）和持续交付（CD）相关的工具和实践：
- en: '![Figure 14.4: The relationship between CI and CD practices'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.4：持续集成（CI）和持续交付（CD）实践之间的关系'
- en: '](img/B15218_14_04.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_14_04.jpg)'
- en: 'Figure 14.4: The relationship between CI and CD practices'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4：持续集成（CI）和持续交付（CD）实践之间的关系
- en: The extra ingredient required to adopt CD is a high level of confidence that
    the application is going to keep working as expected (for the end user) and that
    new defects have not been unwittingly introduced. This means an additional end-to-end
    testing step is needed during or after the CI checks, to validate the build before
    being able to deploy it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 采用持续交付（CD）所需的额外成分是对应用程序将继续按预期（对于最终用户）工作以及新缺陷没有无意中引入的高度信心。这意味着在能够部署之前，需要在持续集成（CI）检查期间或之后进行额外的端到端测试步骤来验证构建。
- en: These end-to-end tests can be conducted manually, or they can be automated.
    In an ideal CD setup, the latter (automated end-to-end tests) is preferred since
    it means deployments do not include manual interaction. If the end-to-end tests
    pass, the build can automatically be deployed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些端到端测试可以手动进行，也可以自动化。在一个理想的持续交付（CD）设置中，后者（自动化端到端测试）是首选的，因为它意味着部署不包括人工交互。如果端到端测试通过，构建可以自动部署。
- en: In order to facilitate CD, systems used to deploy software have had to be rethought.
    As part of CD, deployment cannot be a long-winded manual process. This has led
    to companies adopting cloud-native technologies, such as Docker, and infrastructure
    as code tools, such as HashiCorp's **Terraform**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了促进持续交付（CD），用于部署软件的系统必须重新思考。作为 CD 的一部分，部署不能是一个冗长的手动过程。这导致公司采用云原生技术，如 Docker，以及基础设施即代码工具，如
    HashiCorp 的 **Terraform**。
- en: The emphasis on moving toward CD practices has led to the inception of ideas
    such as **GitOps** and **ChatOps**.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 向持续交付（CD）实践转变的强调导致了 **GitOps** 和 **ChatOps** 等想法的诞生。
- en: In GitOps and ChatOps, deployments and operational tasks are driven by the tools
    that developers and stakeholders interact with daily.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitOps 和 ChatOps 中，部署和运营任务是由开发者和利益相关者每天交互的工具驱动的。
- en: In GitOps, deployments can be done through GitHub/GitLab (or another Git-hosting
    provider), directly with GitHub Actions or GitLab CI/CD, or through CI/CD software
    (such as CircleCI or Jenkins), which have tight integrations and reporting with
    GitHub/GitLab.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitOps 中，可以通过 GitHub/GitLab（或另一个 Git 托管提供商）、直接使用 GitHub Actions 或 GitLab CI/CD，或者通过具有紧密集成和报告功能的持续集成/持续交付（CI/CD）软件（如
    CircleCI 或 Jenkins）来进行部署。
- en: In the case of ChatOps, conversational interfaces are used to deploy and operate
    software. Some flavors of ChatOps can be considered a subset of GitOps, for example,
    interacting with tools such as `deploy <service-name> <environment>`, which will
    deploy the service to the relevant environment. Note that chat interfaces are
    very reminiscent of command-line interfaces that developers might be used to but
    other stakeholders might take some time to adopt.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ChatOps 的情况下，使用对话界面来部署和操作软件。某些 ChatOps 的变体可以被认为是 GitOps 的子集，例如，与 `deploy <service-name>
    <environment>` 等工具交互，这些工具会将服务部署到相关环境。请注意，聊天界面非常类似于开发者可能习惯的命令行界面，但其他利益相关者可能需要一些时间来适应。
- en: 'We''ve now looked at approaches to CI and CD; what we''ll discuss next is the
    advantages of using CI and CD:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经探讨了持续集成（CI）和持续交付（CD）的方法；接下来我们将讨论使用持续集成（CI）和持续交付（CD）的优势：
- en: '![Figure 14.5: Advantages of CI and CD'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.5：持续集成（CI）和持续交付（CD）的优势'
- en: '](img/B15218_14_05.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_14_05.jpg)'
- en: 'Figure 14.5: Advantages of CI and CD'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5：持续集成（CI）和持续交付（CD）的优势
- en: Both practices also have an impact on the team's mindset and performance. Being
    able to see the changes you make integrated within a day and in production in
    less than a week means that contributors can see their work having an impact immediately.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD also helps promote agile principles, where changes are applied and deployed
    iteratively. This is as opposed to long timelines for projects, for which inaccuracies
    in estimations compound and can cause major delays.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Building for Production
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying applications to production starts with creating an artifact that can
    be deployed. In the case of Vue.js, we're building a client-side application,
    which means our build artifact will contain HTML, JavaScript, and CSS files.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The Vue CLI comes with a `build` command. This `build` command will take our
    Vue.js single-file components (`.vue` files) and compile them into render functions
    (JavaScript functions that the Vue runtime can use to render our application)
    that will be output to JavaScript.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: As part of the build process, the Vue CLI will take JavaScript, Vue single-file
    components, and modules that are imported into each other and *bundle* them. Bundling
    means that related chunks of code that depend on each other will be output as
    a single JavaScript file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Due to our use of the Vue CLI, the Vue.js library itself can also be slimmed
    down. The Vue.js runtime bundle can include a **runtime compiler** that takes
    string templates and turns them into render functions on the client side. Since
    we are compiling to render functions with the Vue CLI at build time, this part
    of Vue.js doesn't need to be included in our JavaScript.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The Vue CLI build step also includes a `dead code elimination` step. That means
    that it can analyze the code being generated and if any of it is obviously never
    used – for example, a statement such as `if (false) { /* do something */}` – then
    it will not be present in the build output.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: By default, the Vue CLI builds for production when we call `vue service build`,
    which in Vue CLI projects is aliased to the `build` script, which can be run with
    `npm run build` or `yarn build`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'In a sample Vue CLI project, we''ll see something along these lines:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.6: Output of "npm run build" in a fresh Vue CLI project'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_06.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.6: Output of "npm run build" in a fresh Vue CLI project'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: The `dist` folder is now ready to deploy using a static hosting solution such
    as Netlify or AWS S3 and CloudFront.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how to build a Vue.js application for production using the
    Vue CLI with the `npm run build` command.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how to use GitLab CI/CD to test our code (before deploying
    it).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Using GitLab CI/CD to Test Your Code
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitLab has a built-in CI/CD tool called GitLab CI/CD.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: In order to use GitLab CI/CD, you'll need a GitLab account.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: To interact with Git repositories hosted on GitLab, you'll also need to associate
    an SSH key from your machine and to your GitLab account.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Instructions to add an SSH key in the GitLab documentation can be found at [https://docs.gitlab.com/ee/gitlab-basics/create-your-ssh-keys.html](https://docs.gitlab.com/ee/gitlab-basics/create-your-ssh-keys.html).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve created an account, you can create a new repository using the
    `New Project` button at the top right of the `Projects` page, as shown in the
    following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.7: The GitLab "Projects" page with the New Project button'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_07.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.7: The GitLab "Projects" page with the New Project button'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click the `New Project` button, you will be taken to the `New Project`
    page, where you can use the default `Blank Project` tab to create a project by
    giving it a name and a slug, as seen in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.8: The GitLab New Project page with Blank Project selected'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_08.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.8: The GitLab New Project page with Blank Project selected'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you click `Create Project`, the GitLab `Project` page will appear in an
    empty state that displays instructions on how to clone it. You should run the
    commands required to clone the repository, which probably boils down to an equivalent
    of the following (which you are expected to run on your machine):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: If you did not associate an SSH key with your account, at this stage GitLab
    should be showing you a warning with a link you can follow to set up an SSH key.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '`git clone <repository-url>`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: On your machine, you should then open the directory into which the repository
    was cloned. To add GitLab CI/CD, we need to add a `.gitlab-ci.yml` file into the
    root of the project. A sample `.gitlab-ci.yml` file that adds a `build` job to
    the `build` stage of the pipeline that installs dependencies (using `npm ci`),
    runs the production build (`npm run build`), and caches the output artifact is
    defined as follows.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The job name is defined by setting a top-level key in the YAML file – in this
    case, `build:`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: In YAML syntax, we'll then increase the indent to denote that the `build` key
    points to an object.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `build job` object, we will define which Docker image is used to run
    the job, using `image: node:lts`. This means we want this job to run on a Node.js
    **Long Term Support** (**LTS**) image, which will be Node.js 12 until October
    20, 2020, at which point it will point to a Node.js 14 image.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: You can access the up-to-date Node.js LTS schedule at [https://nodejs.org/en/about/releases/](https://nodejs.org/en/about/releases/).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'The other property we can define in our job is the stage. GitLab CI/CD pipelines
    by default have three stages: **build**, **test**, and **deploy**. These stages
    can be replaced using custom stages when a team''s workflow doesn''t fit into
    these three categories (for example, if there is more than one environment to
    deploy to). See the documentation ([https://docs.gitlab.com/ee/ci/yaml/#stages](https://docs.gitlab.com/ee/ci/yaml/#stages)).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '`stages` is used to define stages that can be used by jobs, and it is defined globally.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'The specification of `stages` allows for flexible multistage pipelines. The
    ordering of elements in stages defines the ordering of jobs'' execution:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: a) Jobs of the same stage are run in parallel.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: b) Jobs of the next stage are run after the jobs from the previous stage complete
    successfully.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Our pipeline only has one stage and one job at the moment, so most of the preceding
    doesn't apply to us.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The final properties we set are `script`, which defines steps that should be
    run when the job is running, and `artifacts`, which configures artifact storage.
    In our case, we'll run `npm ci` to install all dependencies followed by `npm run
    build`, which will run the production Vue.js CLI build. Our artifact is set up
    to be held for a week and to contain the `dist` folder (which is where the Vue
    CLI `build` output is stored).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'In full, we have the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once we push this `.gitlab-ci.yml` file to a repository containing a Vue CLI
    project, we will see the following in the repository view, where a pipeline with
    one step is running on the latest commit:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.9: GitLab repository view with the build job running on the latest
    commit'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_09.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.9: GitLab repository view with the build job running on the latest
    commit'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'If we click on the `Pipeline` icon (the blue in-progress indicator), we get
    the pipeline view. In the pipeline view, `Build` represents the `state` pipeline
    (which we set as `build`) and it represents the job name (which we defined as
    `build`). We see the same in-progress indicator until the job completes, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.10: GitLab CI pipeline view with the build job running'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_10.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.10: GitLab CI pipeline view with the build job running'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the job completes, we see a `success` icon (green check-mark). We can
    click this icon or the job name to access the job view while the job is running
    or after it has completed (whether it has failed or succeeded). When a job has
    completed, we also see a `Retry` icon, which can be useful to retry a failed pipeline
    step. The following screenshot shows that the job ran successfully:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.11: GitLab CI pipeline view with the build job passing'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_11.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.11: GitLab CI pipeline view with the build job passing'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking the job, we see the `Job` view, which shows us a detailed breakdown
    of all the steps in the job. Starting with the `Preparing the docker_machine executor`
    steps, which load up the Node.js Docker image, we see steps for running the script
    as well as cache and artifact restores, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.12: The GitLab CI job view with the successful build job'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_12.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.12: The GitLab CI job view with the successful build job'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: If we want to add a `test` step to our GitLab CI/CD runs, we need to be in a
    project that supports unit testing. This can be achieved using the Vue CLI, which
    is installed using `vue add @vue/unit-jest`. Installing and adding unit tests
    is covered in depth in *Chapter 12*, *Unit Testing*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在GitLab CI/CD运行中添加`test`步骤，我们需要在一个支持单元测试的项目中。这可以通过使用Vue CLI来实现，它是通过`vue
    add @vue/unit-jest`安装的。安装和添加单元测试在*第12章*，*单元测试*中进行了详细说明。
- en: 'We will need to add a new job to the `.gitlab-ci.yml` file; we will call it
    `test`, use the `node:lts` image, and assign the job to the `test` state. In the
    job, we run `npm ci`, followed by `npm run test:unit` (which is the `npm` script
    added by the `unit-jest` CLI plugin):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`.gitlab-ci.yml`文件中添加一个新的作业；我们将称之为`test`，使用`node:lts`镜像，并将作业分配给`test`状态。在作业中，我们运行`npm
    ci`，然后是`npm run test:unit`（这是由`unit-jest` CLI插件添加的`npm`脚本）：
- en: '[PRE1]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once we push this new `.gitlab-ci.yml` file up, we get the following view on
    the main repository page:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们推送这个新的`.gitlab-ci.yml`文件，我们将在主存储库页面上看到以下视图：
- en: '![Figure 14.13: Repository view with GitLab CI/CD running the pipeline with
    the new test step'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.13：存储库视图，GitLab CI/CD正在运行包含新测试步骤的管道'
- en: '](img/B15218_14_13.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_14_13.jpg)'
- en: 'Figure 14.13: Repository view with GitLab CI/CD running the pipeline with the
    new test step'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.13：存储库视图，GitLab CI/CD正在运行包含新测试步骤的管道
- en: 'We can click through to the pipeline view. The reason GitLab CI/CD uses pipelines
    is that a failing step at a certain stage will mean steps in any subsequent stages
    will not run. For example, if we get a failing `build` job, the jobs that are
    part of the `test` stage will not run. The following screenshot explains this
    well:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以点击进入管道视图。GitLab CI/CD使用管道的原因是，在某个阶段的失败步骤将意味着后续阶段的步骤将不会运行。例如，如果我们得到一个失败的`build`作业，`test`阶段的作业将不会运行。以下截图很好地解释了这一点：
- en: '![Figure 14.14: GitLab CI/CD pipeline view with a failed build job that stops'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.14：GitLab CI/CD管道视图，失败的构建作业阻止'
- en: the test job/stage from running
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 测试作业/阶段运行
- en: '](img/B15218_14_14.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_14_14.jpg)'
- en: 'Figure 14.14: GitLab CI/CD pipeline view with a failed build job that stops
    the test job/stage from running'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.14：GitLab CI/CD管道视图，失败的构建作业阻止测试作业/阶段运行
- en: 'If we push another commit or retry the build step (if the failure is not caused
    by changes) and navigate to the pipeline view again, we''ll see the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次提交另一个提交或重试构建步骤（如果失败不是由更改引起的）并再次导航到管道视图，我们将看到以下内容：
- en: '![Figure 14.15: GitLab CI/CD pipeline view with the test job running'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.15：GitLab CI/CD管道视图，测试作业正在运行'
- en: after the build stage jobs have all succeeded
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 构建阶段的作业全部成功后
- en: '](img/B15218_14_15.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_14_15.jpg)'
- en: 'Figure 14.15: GitLab CI/CD pipeline view with the test job running after the
    build stage jobs have all succeeded'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.15：构建阶段作业全部成功后，GitLab CI/CD管道视图中的测试作业正在运行
- en: 'Once the `test` job has succeeded, we''ll see the following pipeline:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`测试`作业成功，我们将看到以下管道：
- en: '![Figure 14.16: GitLab CI/CD pipeline view with all jobs succeeding in the
    build and test stages'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.16：GitLab CI/CD管道视图，构建和测试阶段的作业全部成功'
- en: '](img/B15218_14_16.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_14_16.jpg)'
- en: 'Figure 14.16: GitLab CI/CD pipeline view with all jobs succeeding in the build
    and test stages'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.16：GitLab CI/CD管道视图，构建和测试阶段的作业全部成功
- en: We've now added a GitLab CI/CD pipeline with the `build` and `test` stages that
    will validate that on every push to the GitLab repository, the code still integrates
    as expected.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已添加了一个包含`build`和`test`阶段的GitLab CI/CD管道，该管道将验证在每次向GitLab存储库推送时，代码仍然按预期集成。
- en: 'Exercise 14.01: Adding a Lint Step to Your GitLab CI/CD Pipeline'
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.01：向您的GitLab CI/CD管道添加Lint步骤
- en: Linting is a way to get automated formatting and code style checks. Integrating
    it as part of CI makes sure that all code merged into the mainline branches adheres
    to a team's code style guide. It also reduces the number of code style review
    comments, which can be noisy and might detract from fundamental issues with the
    change request.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Linting是一种获取自动化格式化和代码风格检查的方法。将其集成到CI中可以确保所有合并到主线分支的代码都遵循团队的代码风格指南。它还减少了代码风格审查评论的数量，这些评论可能会很嘈杂，并可能分散对更改请求的基本问题的关注。
- en: 'To access the code files for this exercise, refer to [https://packt.live/2IQDFW0](https://packt.live/2IQDFW0):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/2IQDFW0](https://packt.live/2IQDFW0)：
- en: 'In order to add linting, we need to ensure that our `package.json` file includes
    the `lint` script. If it''s missing, we''ll need to add it and set it to `vue-cli-service
    lint`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In order to run the lint on GitLab CI/CD, we need to add a new `lint` job that
    will run in a Node.js LTS Docker image at the `test` stage of the GitLab CI/CD
    pipeline. We will do this in `.gitlab-ci.yml`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For the `lint` job to run the `lint` script as per `package.json`, we need
    to add a `script` section in the `.gitlab-ci.yml` file. It first needs to run
    `npm ci` to install the dependencies, and then `npm run lint` to run the linting:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we need to commit and push the code to GitLab using the following commands:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once the code is pushed, we can see the pipeline run using the GitLab CI/CD
    UI, as follows. Note how all the jobs at the `test` stage are run in parallel:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.17: The GitLab CI/CD pipeline view with all the jobs succeeding,'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: including "test" and "lint" running in parallel
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_17.jpg)'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.17: The GitLab CI/CD pipeline view with all the jobs succeeding,
    including "test" and "lint" running in parallel'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: We've now seen how to use GitLab CI/CD to run builds and tests on every commit.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll see how to deploy a Vue.js application to Netlify.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Netlify
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Netlify is a hosting provider that specializes in static hosting and relevant
    supporting services in order to have a fully interactive site that uses static
    hosting. This includes offerings such as Netlify Functions (serverless functions),
    Netlify Forms (a no-backend form submission system), and Netlify Identity (an
    identity/authentication provider).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The following sections require you to have a Netlify account, which is free.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to deploy a site to Netlify is to use the drag and drop interface.
    You''ll find this at the bottom of the home page in the logged-in view: [https://app.netlify.com](https://app.netlify.com).
    It looks as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.18: Netlify''s drag and drop deployment section at the'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: bottom of the App home page
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_18.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.18: Netlify''s drag and drop deployment section at the bottom of
    the App home page'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, therefore, choose a project where we''ve run the `npm run build` command
    and deploy the `dist` folder by simply dragging it to the drag and drop deployment
    section, as shown in the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.19: Dragging and dropping the dist folder onto the Netlify drag
    and drop deployment section'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_19.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.19: Dragging and dropping the dist folder onto the Netlify drag and
    drop deployment section'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the upload has succeeded, Netlify redirects you to your new website''s
    administration page. This will look as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.20: The Netlify new app page for the drag and drop site'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_20.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.20: The Netlify new app page for the drag and drop site'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'We can click on the link to the site and we''ll see the default Vue CLI home
    page template, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.21: Netlify new app displaying a greeting message'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_21.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.21: Netlify new app displaying a greeting message'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how to manually deploy a site to Netlify using the drag and
    drop interface.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how to deploy our site from GitLab to Netlify.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Netlify app home page, we need to click the `New site from Git` button,
    as displayed in the following screenshot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.22: Netlify home page with the New site from Git button'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_22.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.22: Netlify home page with the New site from Git button'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll see a page asking us to choose a Git provider to connect to. For this
    example, we will use `GitLab`. The following screenshot represents how the screen
    will look:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.23: Netlify – Create a new site | Connect to Git provider'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_23.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.23: Netlify – Create a new site | Connect to Git provider'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon clicking `GitLab`, we will get an OAuth authorization challenge from GitLab,
    which we need to accept by clicking on the `Authorize` button as shown in the
    following screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.24: GitLab OAuth authorization modal'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_24.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.24: GitLab OAuth authorization modal'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'We will then be redirected to Netlify and asked to choose a repository to deploy,
    as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.25: Select a GitLab repository to deploy'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_25.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.25: Select a GitLab repository to deploy'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: We select the repository we want to deploy and are met with a configuration
    page. Since we're now building on Netlify's build servers, we need to configure
    Netlify to build the application and deploy the correct folder.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: We fill out the `build` command as `npm run build` since that's our build script.
    The publish directory is `dist`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then click the `Deploy site` button, which will start the deployment
    process, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.26: The Netlify build configuration tab, filled in with npm run
    build'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: and dist for the build command and publish directory, respectively
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_26.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.26: The Netlify build configuration tab, filled in with npm run build
    and dist for the build command and publish directory, respectively'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'We will then be redirected to the newly created app''s page, as shown here:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.27: New Netlify app'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_27.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.27: New Netlify app'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how to deploy an application to Netlify using the manual upload
    method and using GitLab as the Git hosting provider.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.02: Deploying a Site to Netlify from GitHub'
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen how to deploy a site to Netlify from GitLab, but how different
    is it from deploying it from GitHub? The answer is that they are very similar;
    the only notable difference is the first step in the `Connect to Git provider`
    tab:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin by clicking the `New site from Git` button on the home page, as follows:![Figure
    14.28: New site from Git on the Netlify dashboard'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_28.jpg)'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.28: New site from Git on the Netlify dashboard'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will then choose `GitHub` as the Git hosting provider, as shown in the following
    screenshot:![Figure 14.29: Continuous Deployment'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_29.jpg)'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.29: Continuous Deployment'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When we get the GitHub OAuth authorization challenge, as shown in the following
    screenshot, we authorize Netlify:![Figure 14.30: GitHub authorization challenge'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_30.jpg)'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.30: GitHub authorization challenge'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We select the Vue CLI project we want to deploy from the repository list, as follows:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.31: Selecting the correct repository'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_31.jpg)'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.31: Selecting the correct repository'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the deployment options tab, we select `master` as the branch to deploy.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the build command as `npm run build`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the publish directory as `dist`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The completed deployment options look as follows:![Figure 14.32: The Netlify
    build configuration tab filled in with npm run'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: build and dist for the build command and publish directory, respectively
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_32.jpg)'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.32: The Netlify build configuration tab filled in with npm run build
    and dist for the build command and publish directory, respectively'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We click `Deploy site` to start the deployment process.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've now seen how to deploy an application to Netlify using the manual upload
    method and using GitLab or GitHub as the Git hosting provider.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how to use **Amazon Web Services Simple Storage Service**
    (**AWS S3**) and AWS CloudFront to deploy a Vue.js application.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to AWS Using S3 and CloudFront
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazon S3 is a static storage offering that can be used as a host for static
    files, such as what is generated by the Vue CLI's `build` script.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: CloudFront is AWS' **content delivery network** (**CDN**) offering. A CDN can
    improve a web application's performance by serving static content from an **edge**
    location. These servers are positioned around the world and are more likely to
    be geographically located close to the end user than the **origin** servers (the
    ones that actually serve the content). Edge servers in a CDN request resources
    from the origin if they don't have them cached but will serve subsequent requests.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'A prerequisite for the following steps is an AWS account:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: We will start by creating and configuring an S3 bucket.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We begin by heading to the S3 product page. It will look similar to the following screenshot:'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.33: Select S3 from the AWS service list'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_33.jpg)'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.33: Select S3 from the AWS service list'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'On the S3 console home page, we can click the `Create bucket` button, which
    will take us to the bucket creation page, as seen here:![Figure 14.34: The Create
    bucket button on the AWS S3 console'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_34.jpg)'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.34: The Create bucket button on the AWS S3 console'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To begin, we start by naming our bucket. For the purposes of this example,
    let''s call it `vue-workshop`, as follows:![Figure 14.35: Entering the bucket
    name on the bucket creation page'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_35.jpg)'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.35: Entering the bucket name on the bucket creation page'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will also need to set the S3 bucket to be public. This is done by unselecting
    the `Block all public access` checkbox. Once this is done, we must check the acknowledgment
    checkbox, as seen here:![Figure 14.36: Set the S3 bucket to be public and acknowledge
    the warning'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_36.jpg)'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.36: Set the S3 bucket to be public and acknowledge the warning'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once this is done, we are redirected to the bucket list page. We want to click
    into our new bucket. Then, we need to access the `Properties` tag in order to
    find the `Static website hosting` option:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.37: The Static website hosting option in the S3 bucket''s Properties
    tab'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_37.jpg)'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.37: The Static website hosting option in the S3 bucket''s Properties
    tab'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can fill out the `Static website hosting` S3 property, selecting `Use this
    bucket to host a website` and setting the index document and error document to
    `index.html`. It is a good idea to take note of the `Endpoint` URL, which we''ll
    need to configure CloudFront, as follows:![Figure 14.38: Filling out the Static
    website hosting S3 property'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_38.jpg)'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.38: Filling out the Static website hosting S3 property'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now go back to the `Overview` tab of the S3 bucket page, click `Upload`,
    and drag and drop the files from one of our `dist` folders, as seen in the following
    screenshot:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.39: Adding files to the vue-workshop S3 bucket through drag and
    drop'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_39.jpg)'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.39: Adding files to the vue-workshop S3 bucket through drag and drop'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once files are dropped on the overview page, we click `Next` and need to make
    sure file permissions are set to `public` by selecting `Grant public read access
    to this object(s)` in the `Manage public permissions` section of the page. Once
    that is completed, we can complete the upload without any changes from the default
    values by clicking `Next` and `Upload`, after having reviewed the files being
    uploaded, as follows:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.40: Setting file permissions to public on files being uploaded
    to the S3 bucket'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_40.jpg)'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.40: Setting file permissions to public on files being uploaded to
    the S3 bucket'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our S3 bucket should now be configured to host static content, and by visiting
    the website endpoint (which is available in **Properties** | **Static website
    hosting**), we see the following Vue.js application (which is what we uploaded):![Figure
    14.41: The Vue.js application being served from our AWS S3 bucket'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_41.jpg)'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.41: The Vue.js application being served from our AWS S3 bucket'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that S3 can only serve sites over HTTP, and domain names cannot be configured
    directly from S3 buckets. Beyond performance and robustness, being able to set
    custom domain names and HTTPS support are other reasons to set up AWS CloudFront
    as a CDN for our website.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will start by navigating to the CloudFront console and clicking the `Create
    Distribution` button as follows:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.42: Select CloudFront from the AWS service list'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_42.jpg)'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.42: Select CloudFront from the AWS service list'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When prompted for which type of distribution we want to create, we will select
    `Web` by clicking the relevant `Get Started` button, as seen in the following screenshot:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.43: Choosing to create a Web CloudFront distribution'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_43.jpg)'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.43: Choosing to create a Web CloudFront distribution'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Origin Domain Name` should be the S3 bucket website endpoint domain – in other
    words, the domain of the URL we used to access it earlier. It looks something
    like `example.s3-website.us-west-1.amazonaws.com` for the `example` bucket in
    the `us-east-1` region. The following screenshot displays this:![Figure 14.44:
    Enter the website endpoint domain in the CloudFront'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_44.jpg)'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.44: Enter the website endpoint domain in the CloudFront distribution''s
    "Origin Domain Name" field'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'While we are setting up the distribution, it''s a good idea to select the `Redirect
    HTTP to HTTPS` option for the `Default Cache Behavior` section''s `Viewer Protocol
    Policy` field as follows:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.45: Select Redirect HTTP to HTTPS for the Viewer Protocol Policy
    field'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_45.jpg)'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.45: Select Redirect HTTP to HTTPS for the Viewer Protocol Policy
    field'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to click the `Create Distribution` button and wait for the
    changes to propagate.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: CloudFront distribution changes take a while to propagate since they are being
    deployed to servers around the world.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: We can open the domain name for the CloudFront distribution once the console
    shows its status as `Deployed`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to set up S3 and CloudFront to serve a static website. We will
    now see how to use the AWS CLI to synchronize a local directory to the S3 bucket.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: A prerequisite for the next section is a shell instance that has AWS credentials
    injected using the `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, and `AWS_DEFAULT_REGION`
    environment variables. The access key and secret key need to be generated from
    the `Account` dropdown | `My Security Credentials` | `Access Keys`. It also requires
    the AWS CLI version 2.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'If we''re in a Vue CLI project, we can deploy the `dist` folder (which can
    be built using `npm run build`) to our `vue-workshop` bucket using an AWS S3 CLI
    command. We want to update an `s3` resource so that our command will start with
    `aws s3`. The command we want to issue is to synchronize files, so we will use
    the `aws s3 sync` command. We will sync `./dist` to the `vue-workshop` S3 bucket,
    using the AWS URI syntax – that is, `s3://vue-workshop`. We also want to make
    sure that the files we upload, just like the bucket configuration, allow `public-read`.
    In full, the command looks as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Exercise 14.03: Deploying to S3 from GitLab CI/CD'
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: S3 is a very cost-effective and performant solution for storing static files
    at scale. In this exercise, we'll look at how to integrate GitLab CI/CD and AWS
    S3 to deploy a Vue.js application. This automates the deployment of the Vue.js
    application. The deployment will run on every push to GitLab without any manual
    intervention.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: To access the code files for this exercise, refer to [https://packt.live/3kJ1HPD](https://packt.live/3kJ1HPD).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to deploy to the S3 bucket from GitLab CI/CD, we will need to first
    set credential management:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the `CI/CD` settings section of GitLab as follows:![Figure 14.46:
    CI/CD in the Settings menu'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_46.jpg)'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.46: CI/CD in the Settings menu'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will want to add variables, so let''s expand that section. You will see
    a message as shown in the following screenshot:![Figure 14.47: The Variables section
    of the GitLab CI/CD settings expanded'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_47.jpg)'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.47: The Variables section of the GitLab CI/CD settings expanded'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we''ll add `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` using the
    UI (values not shown since they''re sensitive API keys), as follows:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.48: Entering the AWS_ACCESS_KEY_ID environment variable'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_48.jpg)'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.48: Entering the AWS_ACCESS_KEY_ID environment variable'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can then add the default `AWS_REGION` variable using the UI. This isn''t
    so sensitive, so its value is shown in the following screenshot:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.49: Entering the AWS_DEFAULT_REGION environment variable'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_14_49.jpg)'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.49: Entering the AWS_DEFAULT_REGION environment variable'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have set up our environment variables on GitLab CI/CD, we can start
    updating our `.gitlab-ci.yml` file. First, we want to start caching the `dist`
    directory after our `build` step. In order to do this, we need to add a `cache`
    property to the `build` job:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can now add our `deploy` job, which will be a part of the `deploy` stage.
    To access the AWS CLI, we will use a Python image (`python:latest`) and install
    the AWS CLI using `pip` (a Python package manager) in our `before_script` step.
    Once we''ve installed the AWS CLI, we will run the deployment in the `script`
    step using the `aws s3 sync` command we used to deploy from our local machine:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We don't need to invalidate caches since the Vue CLI `build` command has built-in
    cache-busting through fingerprinting the contents of a file in the filename. Fingerprinting
    means that if the contents of a file change, its name/URL will change accordingly.
    When this new file is requested, it will be loaded from an un-cached URL and will
    therefore get the latest version of the file.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once this update to the configuration is pushed to the GitLab repository, we
    can see the pipeline running three stages that all pass, as follows:'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.50: Passing build, test, and deploy jobs'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_50.jpg)'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.50: Passing build, test, and deploy jobs'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how to configure and deploy a Vue.js application to S3 and
    CloudFront using the AWS CLI and GitLab CI/CD.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 14.01: Adding CI/CD with GitLab to a Book Search App and Deploying
    to Amazon S3 and CloudFront'
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's now take a fully built **book search** Vue.js application that loads data
    from the Google Books API and deploy it to S3/CloudFront using GitLab CI/CD. We
    will start by running the production build locally and checking the output. We
    will then switch to running the build and code quality steps (linting) on GitLab
    CI. Finally, we'll set up an S3 bucket and CloudFront distribution and integrate
    them with GitLab CI/CD to deploy on every push to the repository.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'The start code for this activity can be found at `Chapter14/Activity14.01_initial`;
    we start with a `Chapter14/Activity14.01_solution`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: To start, we will want to run a production build locally. We can use the regular
    command used to build all Vue CLI projects for production. We will also want to
    check that the relevant assets (JavaScript, CSS, and HTML) are generated correctly.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We expect the `dist` folder to contain a similar structure, as follows:'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.51: Sample contents of the dist folder (generated using the tree
    command)'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: after a Vue CLI production build run
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_51.jpg)'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.51: Sample contents of the dist folder (generated using the tree
    command) after a Vue CLI production build run'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In order to run GitLab CI/CD, we will need a `.gitlab-ci.yml` file. We will
    add a job to `.gitlab-ci.yml` in which we run an install of the packages followed
    by the production build in a Node.js LTS Docker container, at the `build` stage.
    We will also make sure to cache the output of the production build.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we use `git add .gitlab-ci.yml` and commit and push the changes, we should
    see the following GitLab CI/CD pipeline run, which includes the `build` job while
    it is in the running state:'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.52: The GitLab CI/CD pipeline with the build job running'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_52.jpg)'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.52: The GitLab CI/CD pipeline with the build job running'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following screenshot, on the other hand, represents the GitLab CI/CD pipeline
    when the `build` job has completed and is in the `passed` state:'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.53: GitLab CI/CD pipeline with the build job passed'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_53.jpg)'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.53: GitLab CI/CD pipeline with the build job passed'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we will want to add a code quality job to the `test` stage on GitLab CI/CD
    (by updating `.gitlab-ci.yml`). We'll call the job `lint` and it will run an install
    of the dependencies as well as linting through the Vue CLI.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we use `git add .gitlab-ci.yml` and commit and push the changes, we should
    see the following GitLab CI/CD pipeline run, which includes the `lint` job while
    it is in the running state:'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.54: The GitLab CI/CD pipeline with the lint job running'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_54.jpg)'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.54: The GitLab CI/CD pipeline with the lint job running'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following screenshot displays the GitLab CI/CD pipeline with the `lint`
    job successfully completed:'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.55: GitLab CI/CD pipeline with the lint job passed'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_55.jpg)'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.55: GitLab CI/CD pipeline with the lint job passed'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In order to deploy our application, we'll need to create a `vue-workshop-book-search`
    S3 bucket with `public access` enabled using the S3 console.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The S3 bucket creation page should look as follows:'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.56: The S3 bucket creation page with vue-workshop-book-'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: search entered as the bucket name
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_56.jpg)'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.56: The S3 bucket creation page with vue-workshop-book-search entered
    as the bucket name'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following screenshot displays the public access and disclaimer information
    on the S3 bucket creation page:'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.57: The S3 bucket creation page with public access enabled'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and the relevant disclaimer accepted
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_57.jpg)'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.57: The S3 bucket creation page with public access enabled and the
    relevant disclaimer accepted'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To access the S3 bucket contents over the web, we'll also need to configure
    it for web hosting. We can configure the web hosting property through the S3 console.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It should be configured as follows, with the index and error page set to `index html`:'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.58: The S3 bucket properties page with web hosting enabled and
    configured with the index and error page set to index.html'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_58.jpg)'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.58: The S3 bucket properties page with web hosting enabled and configured
    with the index and error page set to index.html'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For GitLab CI/CD to be able to create and update files on S3, we will need
    to add the relevant AWS secrets to our GitLab repo CI/CD settings. The secrets
    are found in the AWS management console at the `Username` dropdown | `My Security
    Credentials` | `Access keys` (access key ID and secret access key) | `Create New
    Access Key` (or pick a key to reuse). The following screenshot displays these
    details:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.59: The GitLab CI/CD settings page with required the AWS environment'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: variables added (with values masked)
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_59.jpg)'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.59: The GitLab CI/CD settings page with required the AWS environment
    variables added (with values masked)'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we will want to add a `deploy` job to the `deploy` stage on GitLab CI/CD
    (by updating `.gitlab-ci.yml`). We will call the job `deploy`; it will need to
    download the `awscli` `pip` package (Python package manager), which means the
    Docker image that makes the most sense is `python:latest`. The `deploy` job will
    load the built production build from cache, install `awscli` with `pip`, and run
    `aws s3 sync <build_directory> s3://<s3-bucket-name> --acl=public-read`.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we use `git add .gitlab-ci.yml` and commit and push the changes, we should
    see the following GitLab CI/CD pipeline run, which includes the `deploy` job in
    the running state:'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.60: The GitLab CI/CD pipeline with the deploy job running'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_60.jpg)'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.60: The GitLab CI/CD pipeline with the deploy job running'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following screenshot displays the GitLab CI/CD pipeline with the `deploy`
    job completed successfully:'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.61: The GitLab CI/CD pipeline with the deploy job passed'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_61.jpg)'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.61: The GitLab CI/CD pipeline with the deploy job passed'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the pipeline completes, our application should be available through the
    `web` S3 endpoint as in the following screenshot:'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 14.62: Book search accessed through the S3 web endpoint URL'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_62.jpg)'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.62: Book search accessed through the S3 web endpoint URL'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we''ll create a CloudFront distribution that acts as a CDN for the
    `web` S3 endpoint. We''ll want to set `origin` to the origin of our S3 bucket''s
    web endpoint and also make sure that we''ve enabled `Redirect HTTP to HTTPS`,
    as shown in the following screenshot:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.63: The CloudFront distribution creation page, displaying the'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: origin and behavior settings
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_14_63.jpg)'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 14.63: The CloudFront distribution creation page, displaying the origin
    and behavior settings'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the CloudFront distribution is deployed, our application should be accessible
    through the CloudFront distribution''s domain as shown in the following screenshot:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.64: Book search accessed through the CloudFront domain displaying'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: results for a "harry potter" query
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_14_64.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.64: Book search accessed through the CloudFront domain displaying
    results for a "harry potter" query'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor412).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we've looked at how to introduce CI and CD practices
    to Vue.js projects in order to deploy to production safely and efficiently. We've
    seen how CI and CD are beneficial in the context of an agile delivery process.
    We used GitLab's CI/CD features to run tests, linting, and builds on every commit.
    We saw how to leverage Netlify to host a static website by connecting Netlify
    to our hosting provider. Finally, we looked at how to set up and deploy to AWS
    S3 and CloudFront.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, you have learned how to build, test, and deploy a Vue.js
    application that scales and performs for your team and your end users.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
