<html><head></head><body>
<div id="_idContainer083" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-146"><a id="_idTextAnchor147" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-147" class="calibre5"><a id="_idTextAnchor148" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Improving the Load Time Using Server-Side Rendering</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">After implementing authentication using JWTs, let’s focus on optimizing the performance of our blog app. </span><span class="kobospan" id="kobo.3.2">We are going to start by benchmarking the current load time of our application and learn about various metrics to consider. </span><span class="kobospan" id="kobo.3.3">Then, we are going to learn how to render React components and fetch data on the server. </span><span class="kobospan" id="kobo.3.4">At the end of this chapter, we are going to briefly cover advanced server-side </span><span><span class="kobospan" id="kobo.4.1">rendering concepts.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.5.1">In this chapter, we are going to cover the following </span><span><span class="kobospan" id="kobo.6.1">main topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.7.1">Benchmarking the load time of </span><span><span class="kobospan" id="kobo.8.1">our application</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.9.1">Rendering React components on </span><span><span class="kobospan" id="kobo.10.1">the server</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.11.1">Server-side </span><span><span class="kobospan" id="kobo.12.1">data fetching</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.13.1">Advanced </span><span><span class="kobospan" id="kobo.14.1">server-side rendering</span></span></li>
</ul>
<h1 id="_idParaDest-148" class="calibre5"><a id="_idTextAnchor149" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.15.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.16.1">Before we start, please install all requirements mentioned in </span><a href="B19385_01.xhtml#_idTextAnchor016" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.17.1">Chapter 1</span></em></span></a><span class="kobospan" id="kobo.18.1">, </span><em class="italic"><span class="kobospan" id="kobo.19.1">Preparing For Full-Stack Development</span></em><span class="kobospan" id="kobo.20.1">, and </span><a href="B19385_02.xhtml#_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.21.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.22.1">, </span><em class="italic"><span class="kobospan" id="kobo.23.1">Getting to Know Node.js </span></em><span><em class="italic"><span class="kobospan" id="kobo.24.1">and MongoDB</span></em></span><span><span class="kobospan" id="kobo.25.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.26.1">The versions listed in those chapters are the ones used in the book. </span><span class="kobospan" id="kobo.26.2">While installing a newer version should not be an issue, please note that certain steps might work differently on a newer version. </span><span class="kobospan" id="kobo.26.3">If you are having an issue with the code and steps provided in this book, please try using the versions mentioned in </span><em class="italic"><span class="kobospan" id="kobo.27.1">Chapters 1 </span></em><span><span class="kobospan" id="kobo.28.1">and</span></span><span><em class="italic"><span class="kobospan" id="kobo.29.1"> 2</span></em></span><span><span class="kobospan" id="kobo.30.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.31.1">You can find the code for this chapter on </span><span><span class="kobospan" id="kobo.32.1">GitHub: </span></span><a href="https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch7" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.33.1">https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch7</span></span></a><span><span class="kobospan" id="kobo.34.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.35.1">The CiA video for this chapter can be found </span><span><span class="kobospan" id="kobo.36.1">at: </span></span><a href="https://youtu.be/0OlmicibYWQ" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.37.1">https://youtu.be/0OlmicibYWQ</span></span></a></p>
<h1 id="_idParaDest-149" class="calibre5"><a id="_idTextAnchor150" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.38.1">Benchmarking the load time of our application</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.39.1">Before we can get started </span><a id="_idIndexMarker454" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.40.1">improving the load time, we first must learn about the metrics to benchmark the performance of our application. </span><span class="kobospan" id="kobo.40.2">The main metrics for measuring the performance of web applications are </span><a id="_idIndexMarker455" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.41.1">called </span><strong class="bold"><span class="kobospan" id="kobo.42.1">Core Web Vitals</span></strong><span class="kobospan" id="kobo.43.1">, and they are </span><span><span class="kobospan" id="kobo.44.1">as follows:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.45.1">First Contentful Paint (FCP)</span></strong><span class="kobospan" id="kobo.46.1">: This </span><a id="_idIndexMarker456" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.47.1">measures the loading performance of an app by reporting the time until the first image or text block is rendered on the page. </span><span class="kobospan" id="kobo.47.2">A good target would be to get this metric below </span><span><span class="kobospan" id="kobo.48.1">1.8 seconds.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.49.1">Largest Contentful Paint (LCP)</span></strong><span class="kobospan" id="kobo.50.1">: This </span><a id="_idIndexMarker457" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.51.1">measures the loading performance of an app by reporting the time until the largest image or text block is visible within the viewport. </span><span class="kobospan" id="kobo.51.2">A good target would be to get this metric below </span><span><span class="kobospan" id="kobo.52.1">2.5 seconds.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.53.1">Total Blocking Time (TBT)</span></strong><span class="kobospan" id="kobo.54.1">: This </span><a id="_idIndexMarker458" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.55.1">measures the interactivity of an app by reporting the time between the FCP and a user being able to interact with the page. </span><span class="kobospan" id="kobo.55.2">A good target would be to get this metric below </span><span><span class="kobospan" id="kobo.56.1">200 milliseconds.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.57.1">Cumulative Layout Shift (CLS)</span></strong><span class="kobospan" id="kobo.58.1">: This</span><a id="_idIndexMarker459" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.59.1"> measures the visual stability of an app by reporting unexpected movement on the page during loading, such as a link first being loaded on the top of the page, but then getting pushed further down to the bottom when other elements load. </span><span class="kobospan" id="kobo.59.2">While this metric does not directly measure the actual performance of the app, it is still an important metric to consider, as it can lead to annoying the users when they attempt to click on something, but the </span><span><span class="kobospan" id="kobo.60.1">layout shifts.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.61.1">All these metrics can be measured by using the </span><a id="_idIndexMarker460" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.62.1">open-source </span><strong class="bold"><span class="kobospan" id="kobo.63.1">Lighthouse</span></strong><span class="kobospan" id="kobo.64.1"> tool, which is also available from the Google Chrome DevTools under the </span><strong class="bold"><span class="kobospan" id="kobo.65.1">Lighthouse</span></strong><span class="kobospan" id="kobo.66.1"> panel. </span><span class="kobospan" id="kobo.66.2">Let’s get started benchmarking our </span><span><span class="kobospan" id="kobo.67.1">app now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.68.1">Copy the </span><strong class="source-inline1"><span class="kobospan" id="kobo.69.1">ch6</span></strong><span class="kobospan" id="kobo.70.1"> folder to a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.71.1">ch7</span></strong><span class="kobospan" id="kobo.72.1"> folder, </span><span><span class="kobospan" id="kobo.73.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.74.1">$ cp -R ch6 ch7</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.75.1">Open the </span><strong class="source-inline1"><span class="kobospan" id="kobo.76.1">ch7</span></strong><span class="kobospan" id="kobo.77.1"> folder in VS Code, open a Terminal, and run the frontend with the </span><span><span class="kobospan" id="kobo.78.1">following command:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.79.1">$ npm run dev</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.80.1">Make sure the </span><strong class="source-inline1"><span class="kobospan" id="kobo.81.1">dbserver</span></strong><span class="kobospan" id="kobo.82.1"> container is running </span><span><span class="kobospan" id="kobo.83.1">in Docker.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.84.1">Open a new Terminal and run the backend with the </span><span><span class="kobospan" id="kobo.85.1">following command:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.86.1">$ cd backend</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.87.1">$ npm run dev</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.88.1">Go to </span><strong class="source-inline1"><span class="kobospan" id="kobo.89.1">http://localhost:5173</span></strong><span class="kobospan" id="kobo.90.1"> in Google Chrome </span><a id="_idIndexMarker461" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.91.1">and open the inspector (right-click and then </span><span><span class="kobospan" id="kobo.92.1">press </span></span><span><strong class="bold"><span class="kobospan" id="kobo.93.1">Inspect</span></strong></span><span><span class="kobospan" id="kobo.94.1">).</span></span></li>
</ol>
<p class="callout-heading"><span class="kobospan" id="kobo.95.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.96.1">It would be best to do this in an incognito tab so that extensions do not interfere with </span><span><span class="kobospan" id="kobo.97.1">the measurements.</span></span></p>
<ol class="calibre15">
<li value="6" class="calibre11"><span class="kobospan" id="kobo.98.1">Open the </span><strong class="bold"><span class="kobospan" id="kobo.99.1">Lighthouse</span></strong><span class="kobospan" id="kobo.100.1"> tab (it might be hidden by the </span><strong class="bold"><span class="kobospan" id="kobo.101.1">&gt;&gt;</span></strong><span class="kobospan" id="kobo.102.1"> menu). </span><span class="kobospan" id="kobo.102.2">It should look </span><span><span class="kobospan" id="kobo.103.1">as follows:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer074">
<span class="kobospan" id="kobo.104.1"><img alt="Figure 7.1 – The Lighthouse tab in Google Chrome DevTools" src="image/B19385_07_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.105.1">Figure 7.1 – The Lighthouse tab in Google Chrome DevTools</span></p>
<ol class="calibre15">
<li value="7" class="calibre11"><span class="kobospan" id="kobo.106.1">In the </span><strong class="bold"><span class="kobospan" id="kobo.107.1">Lighthouse</span></strong><span class="kobospan" id="kobo.108.1"> tab, leave all</span><a id="_idIndexMarker462" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.109.1"> options as their default settings and click on the </span><strong class="bold"><span class="kobospan" id="kobo.110.1">Analyze page </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.111.1">load</span></strong></span><span><span class="kobospan" id="kobo.112.1"> button.</span></span><p class="calibre3"><span class="kobospan" id="kobo.113.1">Lighthouse will start analyzing the website and give a report with metrics such as </span><strong class="bold"><span class="kobospan" id="kobo.114.1">First Contentful Paint</span></strong><span class="kobospan" id="kobo.115.1">, </span><strong class="bold"><span class="kobospan" id="kobo.116.1">Largest Contentful Paint</span></strong><span class="kobospan" id="kobo.117.1">, </span><strong class="bold"><span class="kobospan" id="kobo.118.1">Total Blocking Time</span></strong><span class="kobospan" id="kobo.119.1">, and </span><strong class="bold"><span class="kobospan" id="kobo.120.1">Cumulative Layout Shift</span></strong><span class="kobospan" id="kobo.121.1">. </span><span class="kobospan" id="kobo.121.2">As we can see, our app already performs quite well in terms of TBT and CLS but performs particularly badly in terms of FCP and LCP. </span><span class="kobospan" id="kobo.121.3">See the following screenshot </span><span><span class="kobospan" id="kobo.122.1">for reference:</span></span></p></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer075">
<span class="kobospan" id="kobo.123.1"><img alt="Figure 7.2 – Lighthouse results when analyzing our app in development mode (while hovering the cursor over the performance score)" src="image/B19385_07_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.124.1">Figure 7.2 – Lighthouse results when analyzing our app in development mode (while hovering the cursor over the performance score)</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.125.1">There are two</span><a id="_idIndexMarker463" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.126.1"> reasons why the paint takes so long. </span><span class="kobospan" id="kobo.126.2">Firstly, we are running the server in dev mode, which generally makes everything slower. </span><span class="kobospan" id="kobo.126.3">Additionally, we are rendering everything on the client side, which means that the browser first must download and execute our JavaScript code before it can start rendering the interface. </span><span class="kobospan" id="kobo.126.4">Let’s statically build our frontend and benchmark </span><span><span class="kobospan" id="kobo.127.1">again now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.128.1">Install the </span><strong class="source-inline1"><span class="kobospan" id="kobo.129.1">serve</span></strong><span class="kobospan" id="kobo.130.1"> tool globally with the following command, which is a tool that runs a simple </span><span><span class="kobospan" id="kobo.131.1">web server:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.132.1">$ npm install -g serve</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.133.1">Build the frontend with this command (execute it in the root of </span><span><span class="kobospan" id="kobo.134.1">our project):</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.135.1">$ npm run build</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.136.1">Statically serve our app by running the </span><span><span class="kobospan" id="kobo.137.1">following command:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.138.1">$ serve dist/</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.139.1">Open </span><strong class="source-inline1"><span class="kobospan" id="kobo.140.1">http://localhost:3000</span></strong><span class="kobospan" id="kobo.141.1"> in Google Chrome and run Lighthouse again (you may have to clear the old reports or click the list in the top left and select </span><strong class="bold"><span class="kobospan" id="kobo.142.1">(new report)</span></strong><span class="kobospan" id="kobo.143.1"> to </span><span><span class="kobospan" id="kobo.144.1">analyze again).</span></span><p class="calibre3"><span class="kobospan" id="kobo.145.1">You should see the results of the new benchmark on the statically served frontend, which is closer to how it would be served in production. </span><span class="kobospan" id="kobo.145.2">You can see an example of the results in the </span><span><span class="kobospan" id="kobo.146.1">following screenshot:</span></span></p></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer076">
<span class="kobospan" id="kobo.147.1"><img alt="Figure 7.3 – Lighthouse report results on our statically built app" src="image/B19385_07_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.148.1">Figure 7.3 – Lighthouse report results on our statically built app</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.149.1">Now, the results are pretty good! </span><span class="kobospan" id="kobo.149.2">However, it could still be improved further. </span><span class="kobospan" id="kobo.149.3">Additionally, </span><strong class="bold"><span class="kobospan" id="kobo.150.1">Core Web Vitals</span></strong><span class="kobospan" id="kobo.151.1"> do not </span><a id="_idIndexMarker464" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.152.1">take into account the cascading requests to get the author usernames. </span><span class="kobospan" id="kobo.152.2">While the first and largest contentful paints are fast in our app, the author names are not even loaded yet at that point. </span><span class="kobospan" id="kobo.152.3">In addition to the Lighthouse report, we can also take a </span><a id="_idIndexMarker465" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.153.1">look at the </span><strong class="bold"><span class="kobospan" id="kobo.154.1">Network</span></strong><span class="kobospan" id="kobo.155.1"> tab to further debug the performance of our app, </span><span><span class="kobospan" id="kobo.156.1">as follows:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.157.1">In DevTools, go to the </span><span><strong class="bold"><span class="kobospan" id="kobo.158.1">Network</span></strong></span><span><span class="kobospan" id="kobo.159.1"> tab.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.160.1">Refresh the page while the tab is open. </span><span class="kobospan" id="kobo.160.2">You will see a waterfall diagram and the measured time to make requests, as shown in the </span><span><span class="kobospan" id="kobo.161.1">following screenshot:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer077">
<span class="kobospan" id="kobo.162.1"><img alt="Figure 7.4 – The waterfall diagram on the Network tab" src="image/B19385_07_4.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.163.1">Figure 7.4 – The waterfall diagram on the Network tab</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.164.1">But the times are extremely low (all below 10 ms). </span><span class="kobospan" id="kobo.164.2">This is because our backend is running locally, so there is no network delay. </span><span class="kobospan" id="kobo.164.3">This is not a realistic scenario. </span><span class="kobospan" id="kobo.164.4">In production, we would have latency on every request that we make, so we would first have to wait for the blog posts to be pulled, then fetch the names of authors for each author separately. </span><span class="kobospan" id="kobo.164.5">We can use the DevTools to simulate a slower network connection; let’s do </span><span><span class="kobospan" id="kobo.165.1">that now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.166.1">At the top of the </span><strong class="bold"><span class="kobospan" id="kobo.167.1">Network</span></strong><span class="kobospan" id="kobo.168.1"> tab, click on the </span><strong class="bold"><span class="kobospan" id="kobo.169.1">No </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.170.1">throttling</span></strong></span><span><span class="kobospan" id="kobo.171.1"> dropdown.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.172.1">Select the </span><strong class="bold"><span class="kobospan" id="kobo.173.1">Slow 3G</span></strong><span class="kobospan" id="kobo.174.1"> preset. </span><span class="kobospan" id="kobo.174.2">See the following screenshot </span><span><span class="kobospan" id="kobo.175.1">for reference:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer078">
<span class="kobospan" id="kobo.176.1"><img alt="Figure 7.5 – Simulating slow networks in Google Chrome DevTools" src="image/B19385_07_5.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.177.1">Figure 7.5 – Simulating slow networks in Google Chrome DevTools</span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.178.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.179.1">Lighthouse has a form of throttling built in, which is like the network throttling we are using here, but not the same. </span><span class="kobospan" id="kobo.179.2">While the network throttling in DevTools is a fixed delay added to all requests, the throttling in Lighthouse attempts to simulate a more realistic scenario by adjusting the throttling based on the data observed in the initial </span><span><span class="kobospan" id="kobo.180.1">unthrottled load.</span></span></p>
<ol class="calibre15">
<li value="3" class="calibre11"><span class="kobospan" id="kobo.181.1">Refresh the page. </span><span class="kobospan" id="kobo.181.2">You </span><a id="_idIndexMarker466" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.182.1">will now see the app slowly loading the main layout, then a list of all posts, and finally resolving the author IDs </span><span><span class="kobospan" id="kobo.183.1">to usernames.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.184.1">This is how our page would load on slow networks. </span><span class="kobospan" id="kobo.184.2">Now, the overall time to finish loading our app is almost nine seconds! </span><span class="kobospan" id="kobo.184.3">You can look at the waterfall diagram to see why this </span><span><span class="kobospan" id="kobo.185.1">is happening:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer079">
<span class="kobospan" id="kobo.186.1"><img alt="Figure 7.6 – Checking the waterfall diagram with Slow 3G throttling on" src="image/B19385_07_6.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.187.1">Figure 7.6 – Checking the waterfall diagram with Slow 3G throttling on</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.188.1">The issue in our app is that the requests are cascading. </span><span class="kobospan" id="kobo.188.2">First, the HTML document loads, which then loads the JavaScript file for our app. </span><span class="kobospan" id="kobo.188.3">This JavaScript file is then executed and starts rendering the layout and fetching the list of posts. </span><span class="kobospan" id="kobo.188.4">After the posts are loaded, multiple requests are made in parallel to resolve the author names. </span><span class="kobospan" id="kobo.188.5">As each request takes a bit over two seconds on</span><a id="_idIndexMarker467" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.189.1"> our simulated slow network, we end up with a total load time of over </span><span><span class="kobospan" id="kobo.190.1">eight seconds.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.191.1">Now that we have learned how to benchmark a web application and found a performance bottleneck in our app (the cascading requests), let’s learn how to improve </span><span><span class="kobospan" id="kobo.192.1">the performance!</span></span></p>
<h1 id="_idParaDest-150" class="calibre5"><a id="_idTextAnchor151" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.193.1">Rendering React components on the server</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.194.1">In</span><a id="_idIndexMarker468" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.195.1"> the previous section, we identified cascading requests as the problem for our bad performance on slow connections. </span><span class="kobospan" id="kobo.195.2">Possible solutions to this problem are </span><span><span class="kobospan" id="kobo.196.1">as follows:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.197.1">Bundled requests</span></strong><span class="kobospan" id="kobo.198.1">: Fetch everything on the server and then serve everything at once to the client </span><a id="_idIndexMarker469" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.199.1">in a single request. </span><span class="kobospan" id="kobo.199.2">This would solve the cascading requests when fetching author names, but not the initial waiting time between the HTML page being loaded and the JavaScript executing to start fetching the data. </span><span class="kobospan" id="kobo.199.3">With a latency of two seconds per request, that’s still four seconds added (two seconds for loading the JavaScript and two seconds for making the request) after the HTML </span><span><span class="kobospan" id="kobo.200.1">is fetched.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.201.1">Server-side rendering</span></strong><span class="kobospan" id="kobo.202.1">: Render the initial user interface with all data on the server and serve it</span><a id="_idIndexMarker470" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.203.1"> instead of the initial HTML that just contains a URL to the JavaScript file. </span><span class="kobospan" id="kobo.203.2">This would mean that no additional requests are needed to fetch the data or JavaScript and we can show the blog posts right away. </span><span class="kobospan" id="kobo.203.3">Another advantage of this approach is that it allows for caching the results, so, we only need to regenerate the page on the server when a blog post gets added. </span><span class="kobospan" id="kobo.203.4">A downside of this approach is that it puts more strain on the server, especially when the pages are complex </span><span><span class="kobospan" id="kobo.204.1">to render.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.205.1">In cases where data does not change so frequently or the same data is accessed by all users, server-side rendering is beneficial. </span><span class="kobospan" id="kobo.205.2">In cases where data frequently changes or is personalized to each user, it might make more sense to bundle the requests into one by making a new route or using a system that can aggregate requests, such as GraphQL, which we will learn more about later in this book, in </span><a href="B19385_11.xhtml#_idTextAnchor213" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.206.1">Chapter 11</span></em></span></a><span class="kobospan" id="kobo.207.1">, </span><em class="italic"><span class="kobospan" id="kobo.208.1">Building a Backend With a GraphQL API</span></em><span class="kobospan" id="kobo.209.1">. </span><span class="kobospan" id="kobo.209.2">In this chapter, however, we will focus on the server-side </span><span><span class="kobospan" id="kobo.210.1">rendering approach.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.211.1">Let’s have a look at the differences between server-side rendering as opposed to </span><span><span class="kobospan" id="kobo.212.1">client-side rendering:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.213.1">In </span><strong class="bold"><span class="kobospan" id="kobo.214.1">client-side rendering</span></strong><span class="kobospan" id="kobo.215.1">, the browser downloads a minimal HTML page, which, most of the time, only contains information on where to download a JavaScript bundle, which contains all the code that will render </span><span><span class="kobospan" id="kobo.216.1">the app.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.217.1">In </span><strong class="bold"><span class="kobospan" id="kobo.218.1">server-side rendering</span></strong><span class="kobospan" id="kobo.219.1">, the React components are rendered on the server and served as HTML to the browser. </span><span class="kobospan" id="kobo.219.2">This ensures that the app can be rendered immediately. </span><span class="kobospan" id="kobo.219.3">The </span><a id="_idIndexMarker471" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.220.1">JavaScript bundle can be </span><span><span class="kobospan" id="kobo.221.1">loaded later.</span></span></li>
</ul>
<div class="calibre2">
<div class="img---figure" id="_idContainer080">
<span class="kobospan" id="kobo.222.1"><img alt="Figure 7.7 – The differences between client-side rendering and server-side rendering" src="image/B19385_07_7.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.223.1">Figure 7.7 – The differences between client-side rendering and server-side rendering</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.224.1">It is also </span><a id="_idIndexMarker472" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.225.1">possible to combine the two into </span><strong class="bold"><span class="kobospan" id="kobo.226.1">isomorphic rendering</span></strong><span class="kobospan" id="kobo.227.1">. </span><span class="kobospan" id="kobo.227.2">This</span><a id="_idIndexMarker473" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.228.1"> involves rendering the initial page on the server side, and then continuing to render changes on the client side. </span><span class="kobospan" id="kobo.228.2">Isomorphic rendering combines the best of </span><span><span class="kobospan" id="kobo.229.1">both worlds.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.230.1">In addition to the performance improvements, server-side </span><a id="_idIndexMarker474" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.231.1">rendering is also good for </span><strong class="bold"><span class="kobospan" id="kobo.232.1">search engine optimization</span></strong><span class="kobospan" id="kobo.233.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.234.1">SEO</span></strong><span class="kobospan" id="kobo.235.1">), because search engine crawlers do not need to run JavaScript to see the page. </span><span class="kobospan" id="kobo.235.2">We are going to learn more about SEO in the next chapter, </span><a href="B19385_08.xhtml#_idTextAnchor162" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.236.1">Chapter 8</span></em></span></a><span class="kobospan" id="kobo.237.1">, </span><em class="italic"><span class="kobospan" id="kobo.238.1">Making Sure Customers Find You With Search </span></em><span><em class="italic"><span class="kobospan" id="kobo.239.1">Engine Optimization</span></em></span><span><span class="kobospan" id="kobo.240.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.241.1">Now that we have learned about server-side rendering, let’s get started implementing it in our frontend, </span><span><span class="kobospan" id="kobo.242.1">as follows:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.243.1">Setting up </span><span><span class="kobospan" id="kobo.244.1">the server</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.245.1">Defining the server-side </span><span><span class="kobospan" id="kobo.246.1">entry point</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.247.1">Defining the client-side </span><span><span class="kobospan" id="kobo.248.1">entry point</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.249.1">Updating </span><strong class="source-inline1"><span class="kobospan" id="kobo.250.1">index.html</span></strong> <span><span class="kobospan" id="kobo.251.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.252.1">package.json</span></strong></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.253.1">Making React Router work with </span><span><span class="kobospan" id="kobo.254.1">server-side rendering</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.255.1">Let’s start by setting up </span><span><span class="kobospan" id="kobo.256.1">the server.</span></span></p>
<h2 id="_idParaDest-151" class="calibre7"><a id="_idTextAnchor152" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.257.1">Setting up the server</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.258.1">Before we can get</span><a id="_idIndexMarker475" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.259.1"> started with server-side rendering, we need to set up some boilerplate for running an Express server in tandem with Vite, so that we do not lose the benefits of Vite, such as hot reloading. </span><span class="kobospan" id="kobo.259.2">Let’s follow these steps to set up </span><span><span class="kobospan" id="kobo.260.1">the server:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.261.1">Install the </span><strong class="source-inline1"><span class="kobospan" id="kobo.262.1">express</span></strong><span class="kobospan" id="kobo.263.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.264.1">dotenv</span></strong><span class="kobospan" id="kobo.265.1"> dependencies in the root of our project (the frontend); we are going to use them to create a small web server to serve our server-side </span><span><span class="kobospan" id="kobo.266.1">rendered page:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.267.1">$ npm install express@4.18.2 dotenv@16.3.1</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.268.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.269.1">.eslintrc.json</span></strong><span class="kobospan" id="kobo.270.1"> and add the </span><strong class="source-inline1"><span class="kobospan" id="kobo.271.1">node</span></strong><span class="kobospan" id="kobo.272.1"> env, as we are going to add server-side code to our </span><span><span class="kobospan" id="kobo.273.1">frontend now:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.274.1">
  "env": {
    "browser": true,
</span><strong class="bold1"><span class="kobospan1" id="kobo.275.1">    "node": true</span></strong><span class="kobospan1" id="kobo.276.1">
  },</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.277.1">Create a</span><a id="_idIndexMarker476" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.278.1"> new </span><strong class="source-inline1"><span class="kobospan" id="kobo.279.1">server.js</span></strong><span class="kobospan" id="kobo.280.1"> file in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.281.1">ch7</span></strong><span class="kobospan" id="kobo.282.1"> folder, and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.283.1">fs</span></strong><span class="kobospan" id="kobo.284.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.285.1">path</span></strong><span class="kobospan" id="kobo.286.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.287.1">url</span></strong><span class="kobospan" id="kobo.288.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.289.1">express</span></strong><span class="kobospan" id="kobo.290.1">, and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.291.1">dotenv</span></strong></span><span><span class="kobospan" id="kobo.292.1"> dependencies:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.293.1">
import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import express from 'express'
import dotenv from 'dotenv'
dotenv.config()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.294.1">Save the current path in a variable to be used later to reference other files in our project, using the ESM-compatible </span><strong class="source-inline1"><span class="kobospan" id="kobo.295.1">import.meta.url</span></strong><span class="kobospan" id="kobo.296.1"> variable, which contains a </span><strong class="source-inline1"><span class="kobospan" id="kobo.297.1">file://</span></strong><span class="kobospan" id="kobo.298.1"> URL to </span><span><span class="kobospan" id="kobo.299.1">our project:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.300.1">
const __dirname = path.dirname(fileURLToPath(import.meta.url))</span></pre><p class="calibre3"><span class="kobospan" id="kobo.301.1">We convert this URL to a regular </span><span><span class="kobospan" id="kobo.302.1">path here.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.303.1">Define a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.304.1">createDevServer</span></strong><span class="kobospan" id="kobo.305.1"> function, where we will create a Vite dev server with hot reloading and </span><span><span class="kobospan" id="kobo.306.1">server-side rendering:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.307.1">
async function createDevServer() {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.308.1">Inside this function, we first define the </span><span><span class="kobospan" id="kobo.309.1">Express app:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.310.1">
  const app = express()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.311.1">Then, import </span><a id="_idIndexMarker477" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.312.1">and create a Vite dev server. </span><span class="kobospan" id="kobo.312.2">We use the dynamic </span><strong class="source-inline1"><span class="kobospan" id="kobo.313.1">import</span></strong><span class="kobospan" id="kobo.314.1"> syntax here so that we don’t need to import Vite when we define the production </span><span><span class="kobospan" id="kobo.315.1">server later:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.316.1">
  const vite = await (
    await import('vite')
  ).createServer({
    server: { middlewareMode: true },
    appType: 'custom',
  })
  app.use(vite.middlewares)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.317.1">Middleware mode runs Vite as a middleware in an existing Express server. </span><span class="kobospan" id="kobo.317.2">Setting </span><strong class="source-inline"><span class="kobospan" id="kobo.318.1">appType</span></strong><span class="kobospan" id="kobo.319.1"> as </span><strong class="source-inline"><span class="kobospan" id="kobo.320.1">custom</span></strong><span class="kobospan" id="kobo.321.1"> disables Vite’s own serving logic so that we can control which HTML will </span><span><span class="kobospan" id="kobo.322.1">be served.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.323.1">Now, define a route that matches all paths and start by loading the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.324.1">index.html</span></strong></span><span><span class="kobospan" id="kobo.325.1"> file:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.326.1">
  app.use('*', async (req, res, next) =&gt; {
    try {
      const templateHtml = fs.readFileSync(
        path.resolve(__dirname, 'index.html'),
        'utf-8',
      )</span></pre><p class="calibre3"><span class="kobospan" id="kobo.327.1">Make sure to load it in UTF-8 mode to support various languages and emojis </span><span><span class="kobospan" id="kobo.328.1">in </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.329.1">index.html</span></strong></span><span><span class="kobospan" id="kobo.330.1">.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.331.1">Next, inject the Vite hot-module-replacement client to allow for </span><span><span class="kobospan" id="kobo.332.1">hot reloading:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.333.1">
      const template = await vite.transformIndexHtml(
        req.originalUrl,
        templateHtml
      )</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.334.1">Load the </span><a id="_idIndexMarker478" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.335.1">entry point file for our server-side rendered app, which we will define in the </span><span><span class="kobospan" id="kobo.336.1">next step:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.337.1">
      const { render } = await vite.ssrLoadModule('/src/entry-server.jsx')</span></pre><p class="calibre3"><span class="kobospan" id="kobo.338.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.339.1">ssrLoadModule</span></strong><span class="kobospan" id="kobo.340.1"> function in Vite automatically transforms the ESM source code so that it is usable in Node.js. </span><span class="kobospan" id="kobo.340.2">This means we can hot-reload the entry point file without having to run a </span><span><span class="kobospan" id="kobo.341.1">manual build.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.342.1">Render the app using React. </span><span class="kobospan" id="kobo.342.2">We will define the </span><strong class="source-inline1"><span class="kobospan" id="kobo.343.1">render</span></strong><span class="kobospan" id="kobo.344.1"> function later in the server-side entry point. </span><span class="kobospan" id="kobo.344.2">For now, we just call </span><span><span class="kobospan" id="kobo.345.1">the function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.346.1">
      const appHtml = await render()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.347.1">Insert the rendered HTML from our app into the HTML template by matching a placeholder string, which we will define later in the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.348.1">index.html</span></strong></span><span><span class="kobospan" id="kobo.349.1"> file:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.350.1">
      const html = template.replace(`&lt;!--ssr-outlet--&gt;`, appHtml)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.351.1">Return a </span><strong class="source-inline1"><span class="kobospan" id="kobo.352.1">200 OK</span></strong><span class="kobospan" id="kobo.353.1"> response with the final </span><span><span class="kobospan" id="kobo.354.1">HTML contents:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.355.1">
      res.status(200).set({ 'Content-Type': 'text/html' }).end(html)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.356.1">To wrap up the server creation, catch all errors and let Vite fix the stack trace, mapping source files in the stack trace back to the actual source code. </span><span class="kobospan" id="kobo.356.2">Then, return the created </span><span><span class="kobospan" id="kobo.357.1">Express app:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.358.1">
    } catch (e) {
      vite.ssrFixStacktrace(e)
      next(e)
    }
  })
  return app
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.359.1">Lastly, execute the </span><strong class="source-inline1"><span class="kobospan" id="kobo.360.1">createDevServer</span></strong><span class="kobospan" id="kobo.361.1"> function and make the app listen on a </span><span><span class="kobospan" id="kobo.362.1">defined port:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.363.1">
const app = await createDevServer()
app.listen(process.env.PORT, () =&gt;
  console.log(
    `ssr dev server running on http://localhost:${process.env.PORT}`,
  ),
)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.364.1">Let’s not</span><a id="_idIndexMarker479" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.365.1"> forget to define the </span><strong class="source-inline1"><span class="kobospan" id="kobo.366.1">PORT</span></strong><span class="kobospan" id="kobo.367.1"> environment variable in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.368.1">.env</span></strong><span class="kobospan" id="kobo.369.1"> file. </span><span class="kobospan" id="kobo.369.2">Edit the </span><strong class="source-inline1"><span class="kobospan" id="kobo.370.1">.env</span></strong><span class="kobospan" id="kobo.371.1"> file and add the </span><strong class="source-inline1"><span class="kobospan" id="kobo.372.1">PORT</span></strong><span class="kobospan" id="kobo.373.1"> environment variable, </span><span><span class="kobospan" id="kobo.374.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.375.1">
VITE_BACKEND_URL="http://localhost:3001/api/v1"
</span><strong class="bold1"><span class="kobospan1" id="kobo.376.1">PORT=5173</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.377.1">Now that we have successfully created the Express server with Vite integration, we continue by implementing the server-side </span><span><span class="kobospan" id="kobo.378.1">entry point.</span></span></p>
<h2 id="_idParaDest-152" class="calibre7"><a id="_idTextAnchor153" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.379.1">Defining the server-side entry point</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.380.1">The server-side entry point </span><a id="_idIndexMarker480" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.381.1">will use </span><strong class="source-inline"><span class="kobospan" id="kobo.382.1">ReactDOMServer</span></strong><span class="kobospan" id="kobo.383.1"> to render our React components on the server. </span><span class="kobospan" id="kobo.383.2">We need to distinguish this entry point from the client-side entry point because not everything React can do is supported on the server side. </span><span class="kobospan" id="kobo.383.3">Specifically, some hooks such as effect hooks will not run on the server side. </span><span class="kobospan" id="kobo.383.4">Also, we will have to handle the router differently on the server side, but more on </span><span><span class="kobospan" id="kobo.384.1">that later.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.385.1">Now, let’s get started defining the server-side </span><span><span class="kobospan" id="kobo.386.1">entry point:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.387.1">First, create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.388.1">src/entry-server.jsx</span></strong><span class="kobospan" id="kobo.389.1"> file and import </span><strong class="source-inline1"><span class="kobospan" id="kobo.390.1">ReactDOMServer</span></strong><span class="kobospan" id="kobo.391.1"> and the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.392.1">App</span></strong></span><span><span class="kobospan" id="kobo.393.1"> component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.394.1">
import ReactDOMServer from 'react-dom/server
import { App } from './App.jsx'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.395.1">Define and </span><a id="_idIndexMarker481" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.396.1">export the render function, which returns the </span><strong class="source-inline1"><span class="kobospan" id="kobo.397.1">App</span></strong><span class="kobospan" id="kobo.398.1"> component using the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.399.1">ReactDOMServer.renderToString</span></strong></span><span><span class="kobospan" id="kobo.400.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.401.1">
export async function render() {
  return ReactDOMServer.renderToString(
    &lt;App /&gt;,
  )
}</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.402.1">After defining the server-side entry point, we are going to continue by defining the client-side </span><span><span class="kobospan" id="kobo.403.1">entry point.</span></span></p>
<h2 id="_idParaDest-153" class="calibre7"><a id="_idTextAnchor154" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.404.1">Defining the client-side entry point</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.405.1">The</span><a id="_idIndexMarker482" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.406.1"> client-side entry point uses regular </span><strong class="source-inline"><span class="kobospan" id="kobo.407.1">ReactDOM</span></strong><span class="kobospan" id="kobo.408.1"> to render our React components. </span><span class="kobospan" id="kobo.408.2">However, we need to let React know to make use of the already server-side rendered DOM. </span><span class="kobospan" id="kobo.408.3">Instead of rendering, we </span><strong class="bold"><span class="kobospan" id="kobo.409.1">hydrate</span></strong><span class="kobospan" id="kobo.410.1"> the existing DOM. </span><span class="kobospan" id="kobo.410.2">Like when adding water to plants, hydration makes the DOM “come alive” by adding all React functionality to the server-side rendered </span><span><span class="kobospan" id="kobo.411.1">static DOM.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.412.1">Follow these steps to define the client-side </span><span><span class="kobospan" id="kobo.413.1">entry point:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.414.1">Rename the existing </span><strong class="source-inline1"><span class="kobospan" id="kobo.415.1">src/main.jsx</span></strong><span class="kobospan" id="kobo.416.1"> file </span><span><span class="kobospan" id="kobo.417.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.418.1">src/entry-client.jsx</span></strong></span><span><span class="kobospan" id="kobo.419.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.420.1">Replace the </span><strong class="source-inline1"><span class="kobospan" id="kobo.421.1">createRoot</span></strong><span class="kobospan" id="kobo.422.1"> function with the </span><strong class="source-inline1"><span class="kobospan" id="kobo.423.1">hydrateRoot</span></strong><span class="kobospan" id="kobo.424.1"> function, </span><span><span class="kobospan" id="kobo.425.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.426.1">
ReactDOM.hydrateRoot(
  document.getElementById('root'),
  &lt;React.StrictMode&gt;
    &lt;App /&gt;
  &lt;/React.StrictMode&gt;,
)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.427.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.428.1">hydrateRoot</span></strong><span class="kobospan" id="kobo.429.1"> function</span><a id="_idIndexMarker483" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.430.1"> accepts the component as a second argument, and does not require us to </span><span><span class="kobospan" id="kobo.431.1">call </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.432.1">.render()</span></strong></span><span><span class="kobospan" id="kobo.433.1">.</span></span></p></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.434.1">Now that we have defined both entry points, let’s update </span><strong class="source-inline"><span class="kobospan" id="kobo.435.1">index.html</span></strong> <span><span class="kobospan" id="kobo.436.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.437.1">package.json</span></strong></span><span><span class="kobospan" id="kobo.438.1">.</span></span></p>
<h2 id="_idParaDest-154" class="calibre7"><a id="_idTextAnchor155" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.439.1">Updating index.html and package.json</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.440.1">We still need to</span><a id="_idIndexMarker484" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.441.1"> add the placeholder string to </span><a id="_idIndexMarker485" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.442.1">the </span><strong class="source-inline"><span class="kobospan" id="kobo.443.1">index.html</span></strong><span class="kobospan" id="kobo.444.1"> file and adjust </span><strong class="source-inline"><span class="kobospan" id="kobo.445.1">package.json</span></strong><span class="kobospan" id="kobo.446.1"> to execute our custom server instead of the </span><strong class="source-inline"><span class="kobospan" id="kobo.447.1">vite</span></strong><span class="kobospan" id="kobo.448.1"> command directly. </span><span class="kobospan" id="kobo.448.2">Let’s do </span><span><span class="kobospan" id="kobo.449.1">that now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.450.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.451.1">index.html</span></strong><span class="kobospan" id="kobo.452.1"> and add a placeholder where the server-rendered HTML will </span><span><span class="kobospan" id="kobo.453.1">be injected:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.454.1">
    &lt;div id="root"&gt;</span><strong class="bold1"><span class="kobospan1" id="kobo.455.1">&lt;!--ssr-outlet--&gt;</span></strong><span class="kobospan1" id="kobo.456.1">&lt;/div&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.457.1">Adjust the module import to point to the client-side </span><span><span class="kobospan" id="kobo.458.1">entry point:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.459.1">
    &lt;script type="module" src</span><strong class="bold1"><span class="kobospan1" id="kobo.460.1">="/src/entry-client.jsx</span></strong><span class="kobospan1" id="kobo.461.1">"&gt;&lt;/script&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.462.1">Now, edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.463.1">package.json</span></strong><span class="kobospan" id="kobo.464.1"> and replace the dev script with </span><span><span class="kobospan" id="kobo.465.1">the following:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.466.1">
    "dev": </span><strong class="bold1"><span class="kobospan1" id="kobo.467.1">"node server"</span></strong><span class="kobospan1" id="kobo.468.1">,</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.469.1">Additionally, replace the </span><strong class="source-inline1"><span class="kobospan" id="kobo.470.1">build</span></strong><span class="kobospan" id="kobo.471.1"> command with commands to build the server </span><span><span class="kobospan" id="kobo.472.1">and client:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.473.1">
    "build": </span><strong class="bold1"><span class="kobospan1" id="kobo.474.1">"npm run build:client &amp;&amp; npm run build:server",</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.475.1">    "build:client": "vite build --outDir dist/client",</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.476.1">    "build:server": "vite build --outDir dist/server --ssr src/entry-server.jsx",</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.477.1">Our setup is now ready for server-side rendering. </span><span class="kobospan" id="kobo.477.2">However, when you start the server, you will immediately notice that React Router does not work with our current setup. </span><span class="kobospan" id="kobo.477.3">Let’s fix </span><span><span class="kobospan" id="kobo.478.1">that now.</span></span></p>
<h2 id="_idParaDest-155" class="calibre7"><a id="_idTextAnchor156" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.479.1">Making React Router work with server-side rendering</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.480.1">To make </span><a id="_idIndexMarker486" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.481.1">React Router work with server-side rendering, we need to use </span><strong class="source-inline"><span class="kobospan" id="kobo.482.1">StaticRouter</span></strong><span class="kobospan" id="kobo.483.1"> on the server side and </span><strong class="source-inline"><span class="kobospan" id="kobo.484.1">BrowserRouter</span></strong><span class="kobospan" id="kobo.485.1"> on the client side. </span><span class="kobospan" id="kobo.485.2">We can reuse the same route definitions for both sides. </span><span class="kobospan" id="kobo.485.3">Let’s get started refactoring our code to make React Router work on the </span><span><span class="kobospan" id="kobo.486.1">server side:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.487.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.488.1">src/App.jsx</span></strong><span class="kobospan" id="kobo.489.1"> and </span><em class="italic"><span class="kobospan" id="kobo.490.1">remove</span></em><span class="kobospan" id="kobo.491.1"> the router-related imports (the highlighted lines) </span><span><span class="kobospan" id="kobo.492.1">from it:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.493.1">
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
</span><strong class="bold1"><span class="kobospan1" id="kobo.494.1">import { createBrowserRouter, RouterProvider } from 'react-router-dom'</span></strong><span class="kobospan1" id="kobo.495.1">
import { AuthContextProvider } from './contexts/AuthContext.jsx'
</span><strong class="bold1"><span class="kobospan1" id="kobo.496.1">import { Blog } from './pages/Blog.jsx'</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.497.1">import { Signup } from './pages/Signup.jsx'</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.498.1">import { Login } from './pages/Login.jsx'</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.499.1">Import </span><strong class="source-inline1"><span class="kobospan" id="kobo.500.1">PropTypes</span></strong><span class="kobospan" id="kobo.501.1">, as we will need </span><span><span class="kobospan" id="kobo.502.1">it later:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.503.1">
import PropTypes from 'prop-types'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.504.1">Next, </span><em class="italic"><span class="kobospan" id="kobo.505.1">remove</span></em><span class="kobospan" id="kobo.506.1"> the following route definitions from it; we will put them in a new </span><span><span class="kobospan" id="kobo.507.1">file soon:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.508.1">
const router = createBrowserRouter([
  {
    path: '/',
    element: &lt;Blog /&gt;,
  },
  {
    path: '/signup',
    element: &lt;Signup /&gt;,
  },
  {
    path: '/login',
    element: &lt;Login /&gt;,
  },
])</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.509.1">Adjust the </span><a id="_idIndexMarker487" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.510.1">function to accept </span><strong class="source-inline1"><span class="kobospan" id="kobo.511.1">children</span></strong><span class="kobospan" id="kobo.512.1"> and replace </span><strong class="source-inline1"><span class="kobospan" id="kobo.513.1">RouterProvider</span></strong> <span><span class="kobospan" id="kobo.514.1">with </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.515.1">{children}</span></strong></span><span><span class="kobospan" id="kobo.516.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.517.1">
export function App(</span><strong class="bold1"><span class="kobospan1" id="kobo.518.1">{ children }</span></strong><span class="kobospan1" id="kobo.519.1">) {
  return (
    &lt;QueryClientProvider client={queryClient}&gt;
      &lt;AuthContextProvider&gt;
        </span><strong class="bold1"><span class="kobospan1" id="kobo.520.1">{children}</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.521.1">      </span></strong><span class="kobospan1" id="kobo.522.1">&lt;/AuthContextProvider&gt;
    &lt;/QueryClientProvider&gt;
  )
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.523.1">We also need to add the </span><strong class="source-inline1"><span class="kobospan" id="kobo.524.1">propTypes</span></strong><span class="kobospan" id="kobo.525.1"> definitions for the </span><strong class="source-inline1"><span class="kobospan" id="kobo.526.1">App</span></strong> <span><span class="kobospan" id="kobo.527.1">component now:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.528.1">
App.propTypes = {
  children: PropTypes.element.isRequired,
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.529.1">Create a </span><a id="_idIndexMarker488" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.530.1">new </span><strong class="source-inline1"><span class="kobospan" id="kobo.531.1">src/routes.jsx</span></strong><span class="kobospan" id="kobo.532.1"> file and import the previously removed </span><span><span class="kobospan" id="kobo.533.1">imports there:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.534.1">
import { Blog } from './pages/Blog.jsx'
import { Signup } from './pages/Signup.jsx'
import { Login } from './pages/Login.jsx'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.535.1">Then, add the route definitions and </span><span><span class="kobospan" id="kobo.536.1">export them:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.537.1">
export const routes = [
  {
    path: '/',
    element: &lt;Blog /&gt;,
  },
  {
    path: '/signup',
    element: &lt;Signup /&gt;,
  },
  {
    path: '/login',
    element: &lt;Login /&gt;,
  },
]</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.538.1">Now that we have refactored our app structure in a way where we can reuse the routes on the client-side and server-side entry points, let’s redefine the router in the client </span><span><span class="kobospan" id="kobo.539.1">entry point.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.540.1">Defining the client-side router</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.541.1">Follow</span><a id="_idIndexMarker489" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.542.1"> these steps to re-define the router in the client </span><span><span class="kobospan" id="kobo.543.1">entry point:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.544.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.545.1">src/entry-client.jsx</span></strong><span class="kobospan" id="kobo.546.1"> and import </span><strong class="source-inline1"><span class="kobospan" id="kobo.547.1">RouterProvider</span></strong><span class="kobospan" id="kobo.548.1">, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.549.1">createBrowserRouter</span></strong><span class="kobospan" id="kobo.550.1"> function, </span><span><span class="kobospan" id="kobo.551.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.552.1">routes</span></strong></span><span><span class="kobospan" id="kobo.553.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.554.1">
import React from 'react'
import ReactDOM from 'react-dom/client'
</span><strong class="bold1"><span class="kobospan1" id="kobo.555.1">import { createBrowserRouter, RouterProvider } from 'react-router-dom'</span></strong><span class="kobospan1" id="kobo.556.1">
import { App } from './App.jsx'
</span><strong class="bold1"><span class="kobospan1" id="kobo.557.1">import { routes } from './routes.jsx'</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.558.1">Then, create a new browser router based on the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.559.1">routes</span></strong></span><span><span class="kobospan" id="kobo.560.1"> definition:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.561.1">
const router = createBrowserRouter(routes)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.562.1">Adjust the </span><strong class="source-inline1"><span class="kobospan" id="kobo.563.1">render</span></strong><span class="kobospan" id="kobo.564.1"> function to render </span><strong class="source-inline1"><span class="kobospan" id="kobo.565.1">App</span></strong> <span><span class="kobospan" id="kobo.566.1">with </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.567.1">RouterProvider</span></strong></span><span><span class="kobospan" id="kobo.568.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.569.1">
ReactDOM.hydrateRoot(
  document.getElementById('root'),
  &lt;React.StrictMode&gt;
</span><strong class="bold1"><span class="kobospan1" id="kobo.570.1">    &lt;App&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.571.1">      &lt;RouterProvider router={router} /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.572.1">    &lt;/App&gt;</span></strong><span class="kobospan1" id="kobo.573.1">
  &lt;/React.StrictMode&gt;,
)</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.574.1">Next, let’s define the </span><span><strong class="bold"><span class="kobospan" id="kobo.575.1">server-side router</span></strong></span><span><span class="kobospan" id="kobo.576.1">.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.577.1">Mapping the Express request to a Fetch request</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.578.1">On the </span><a id="_idIndexMarker490" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.579.1">server side, we will get an Express request, which we first need to convert to a Fetch request, so that React Router can understand it. </span><span class="kobospan" id="kobo.579.2">Let’s do </span><span><span class="kobospan" id="kobo.580.1">that now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.581.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.582.1">src/request.js</span></strong><span class="kobospan" id="kobo.583.1"> file and define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.584.1">createFetchRequest</span></strong><span class="kobospan" id="kobo.585.1"> function there, which takes an Express request as </span><span><span class="kobospan" id="kobo.586.1">an argument:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.587.1">
export function createFetchRequest(req) {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.588.1">First, define the </span><strong class="source-inline1"><span class="kobospan" id="kobo.589.1">origin</span></strong><span class="kobospan" id="kobo.590.1"> for the request and build </span><span><span class="kobospan" id="kobo.591.1">the URL:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.592.1">
  const origin = `${req.protocol}://${req.get('host')}`
  const url = new URL(req.originalUrl || req.url, origin)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.593.1">We need to use </span><strong class="source-inline"><span class="kobospan" id="kobo.594.1">req.originalUrl</span></strong><span class="kobospan" id="kobo.595.1"> first (if available), to take into account the Vite middleware potentially changing </span><span><span class="kobospan" id="kobo.596.1">the URL.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.597.1">Then, we define a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.598.1">AbortController</span></strong><span class="kobospan" id="kobo.599.1"> to handle when the request </span><span><span class="kobospan" id="kobo.600.1">is closed:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.601.1">
  const controller = new AbortController()
  req.on('close', () =&gt; controller.abort())</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.602.1">Next, we map the Express request </span><strong class="source-inline1"><span class="kobospan" id="kobo.603.1">headers</span></strong><span class="kobospan" id="kobo.604.1"> to </span><span><span class="kobospan" id="kobo.605.1">Fetch headers:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.606.1">
  const headers = new Headers()
  for (const [key, values] of Object.entries(req.headers)) {
    if (!values) continue
    if (Array.isArray(values)) {
      for (const value of values) {
        headers.append(key, value)
      }
    } else {
      headers.set(key, values)
    }
  }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.607.1">Now, we can build the </span><strong class="source-inline1"><span class="kobospan" id="kobo.608.1">init</span></strong><span class="kobospan" id="kobo.609.1"> object for the Fetch request, which consists of </span><strong class="source-inline1"><span class="kobospan" id="kobo.610.1">method</span></strong><span class="kobospan" id="kobo.611.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.612.1">headers</span></strong><span class="kobospan" id="kobo.613.1">, </span><span><span class="kobospan" id="kobo.614.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.615.1">AbortController</span></strong></span><span><span class="kobospan" id="kobo.616.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.617.1">
  const init = {
    method: req.method,
    headers,
    signal: controller.signal,
  }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.618.1">If our request was not a </span><strong class="source-inline1"><span class="kobospan" id="kobo.619.1">GET</span></strong><span class="kobospan" id="kobo.620.1"> or </span><strong class="source-inline1"><span class="kobospan" id="kobo.621.1">HEAD</span></strong><span class="kobospan" id="kobo.622.1"> request, we also get </span><strong class="source-inline1"><span class="kobospan" id="kobo.623.1">body</span></strong><span class="kobospan" id="kobo.624.1">, so, let’s add that to the Fetch </span><span><span class="kobospan" id="kobo.625.1">request, too:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.626.1">
  if (req.method !== 'GET' &amp;&amp; req.method !== 'HEAD') {
    init.body = req.body
  }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.627.1">Finally, let’s</span><a id="_idIndexMarker491" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.628.1"> create the Fetch </span><strong class="source-inline1"><span class="kobospan" id="kobo.629.1">Request</span></strong><span class="kobospan" id="kobo.630.1"> object from our </span><span><span class="kobospan" id="kobo.631.1">extracted information:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.632.1">
  return new Request(url.href, init)
}</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.633.1">Now that we have a utility function to convert an Express request to a Fetch request, we can make use of it to define the </span><span><span class="kobospan" id="kobo.634.1">server-side router.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.635.1">Defining the server-side router</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.636.1">The server-side router</span><a id="_idIndexMarker492" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.637.1"> works very similarly to the client-side router, except that we are getting the request info from Express instead of the page, and using </span><strong class="source-inline"><span class="kobospan" id="kobo.638.1">StaticRouter</span></strong><span class="kobospan" id="kobo.639.1">, because the route cannot change on the server side. </span><span class="kobospan" id="kobo.639.2">Follow these steps to define the </span><span><span class="kobospan" id="kobo.640.1">server-side router:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.641.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.642.1">src/entry-server.jsx</span></strong><span class="kobospan" id="kobo.643.1"> and import </span><strong class="source-inline1"><span class="kobospan" id="kobo.644.1">StaticRouterProvider</span></strong><span class="kobospan" id="kobo.645.1"> and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.646.1">createStaticHandler</span></strong><span class="kobospan" id="kobo.647.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.648.1">createStaticRouter</span></strong><span class="kobospan" id="kobo.649.1"> functions. </span><span class="kobospan" id="kobo.649.2">Also, import</span><a id="_idIndexMarker493" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.650.1"> the </span><strong class="source-inline1"><span class="kobospan" id="kobo.651.1">routes</span></strong><span class="kobospan" id="kobo.652.1"> definition and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.653.1">createFetchRequest</span></strong><span class="kobospan" id="kobo.654.1"> function we </span><span><span class="kobospan" id="kobo.655.1">just defined:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.656.1">
import ReactDOMServer from 'react-dom/server'
</span><strong class="bold1"><span class="kobospan1" id="kobo.657.1">import {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.658.1">  createStaticHandler,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.659.1">  createStaticRouter,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.660.1">  StaticRouterProvider,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.661.1">} from 'react-router-dom/server'</span></strong><span class="kobospan1" id="kobo.662.1">
import { App } from './App.jsx'
</span><strong class="bold1"><span class="kobospan1" id="kobo.663.1">import { routes } from './routes.jsx'</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.664.1">import { createFetchRequest } from './request.js'</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.665.1">Define a static handler for </span><span><span class="kobospan" id="kobo.666.1">the routes:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.667.1">
const handler = createStaticHandler(routes)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.668.1">Adjust the </span><strong class="source-inline1"><span class="kobospan" id="kobo.669.1">render</span></strong><span class="kobospan" id="kobo.670.1"> function to accept an Express request object and then create a Fetch request from it using our previously </span><span><span class="kobospan" id="kobo.671.1">defined function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.672.1">
export async function render(</span><strong class="bold1"><span class="kobospan1" id="kobo.673.1">req</span></strong><span class="kobospan1" id="kobo.674.1">) {
</span><strong class="bold1"><span class="kobospan1" id="kobo.675.1">  const fetchRequest = createFetchRequest(req)</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.676.1">We can now use this converted request to pass it to our static handler, which creates </span><strong class="source-inline1"><span class="kobospan" id="kobo.677.1">context</span></strong><span class="kobospan" id="kobo.678.1"> for the route, allowing React Router to see which route we are trying to access and with </span><span><span class="kobospan" id="kobo.679.1">which parameters:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.680.1">
  const context = await handler.query(fetchRequest)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.681.1">From the routes defined by the handler and the context, we can create a </span><span><span class="kobospan" id="kobo.682.1">static router:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.683.1">
  const router = createStaticRouter(handler.dataRoutes, context)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.684.1">Finally, we can </span><a id="_idIndexMarker494" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.685.1">adjust the rendering to render the static router and our refactored </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.686.1">App</span></strong></span><span><span class="kobospan" id="kobo.687.1"> structure:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.688.1">
  return ReactDOMServer.renderToString(
</span><strong class="bold1"><span class="kobospan1" id="kobo.689.1">    &lt;App&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.690.1">      &lt;StaticRouterProvider router={router} context={context} /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.691.1">    &lt;/App&gt;,</span></strong><span class="kobospan1" id="kobo.692.1">
  )
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.693.1">There’s still one more thing left to do. </span><span class="kobospan" id="kobo.693.2">We need to pass the Express request to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.694.1">render()</span></strong><span class="kobospan" id="kobo.695.1"> function of the server-side entry point. </span><span class="kobospan" id="kobo.695.2">Edit the following line in the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.696.1">server.js</span></strong></span><span><span class="kobospan" id="kobo.697.1"> file:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.698.1">
      const appHtml = await render(</span><strong class="bold1"><span class="kobospan1" id="kobo.699.1">req</span></strong><span class="kobospan1" id="kobo.700.1">)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.701.1">If the frontend and backend are already running, make sure to </span><span><span class="kobospan" id="kobo.702.1">quit them.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.703.1">Start the frontend, </span><span><span class="kobospan" id="kobo.704.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.705.1">$ npm run dev</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.706.1">Also, start the backend in a </span><span><span class="kobospan" id="kobo.707.1">separate Terminal:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.708.1">$ cd backend</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.709.1">$ npm run dev</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.710.1">The</span><a id="_idIndexMarker495" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.711.1"> frontend will now output </span><strong class="source-inline"><span class="kobospan" id="kobo.712.1">ssr dev server running on http://localhost:5173</span></strong><span class="kobospan" id="kobo.713.1"> and successfully server-side render all our pages! </span><span class="kobospan" id="kobo.713.2">You can verify that it is server-side rendered by opening the DevTools, clicking on the cog icon in the top right, scrolling down in the </span><strong class="bold"><span class="kobospan" id="kobo.714.1">Settings</span></strong><span class="kobospan" id="kobo.715.1"> | </span><strong class="bold"><span class="kobospan" id="kobo.716.1">Preferences</span></strong><span class="kobospan" id="kobo.717.1"> pane to the </span><strong class="bold"><span class="kobospan" id="kobo.718.1">Debugger</span></strong><span class="kobospan" id="kobo.719.1"> section, and checking the box for </span><strong class="bold"><span class="kobospan" id="kobo.720.1">Disable JavaScript</span></strong><span class="kobospan" id="kobo.721.1">, </span><span><span class="kobospan" id="kobo.722.1">as follows:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer081">
<span class="kobospan" id="kobo.723.1"><img alt="Figure 7.8 – Disabling JavaScript in the DevTools" src="image/B19385_07_8.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.724.1">Figure 7.8 – Disabling JavaScript in the DevTools</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.725.1">Now, refresh the page, and you will see that part of the app still gets rendered. </span><span class="kobospan" id="kobo.725.2">Only the top part of the app is fully rendered by the server side right now. </span><span class="kobospan" id="kobo.725.3">The posts list is not rendered on the server side yet. </span><span class="kobospan" id="kobo.725.4">This is because the </span><strong class="source-inline"><span class="kobospan" id="kobo.726.1">useQuery</span></strong><span class="kobospan" id="kobo.727.1"> hooks internally use an effect hook to fetch data after the component has mounted. </span><span class="kobospan" id="kobo.727.2">As such, they do not work with server-side rendering. </span><span class="kobospan" id="kobo.727.3">However, we can still get data fetching working with server-side rendering. </span><span class="kobospan" id="kobo.727.4">Let’s learn about that in the </span><span><span class="kobospan" id="kobo.728.1">next section.</span></span></p>
<h1 id="_idParaDest-156" class="calibre5"><a id="_idTextAnchor157" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.729.1">Server-side data fetching</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.730.1">As we have seen, data fetching does </span><a id="_idIndexMarker496" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.731.1">not work out of the box on the server side. </span><span class="kobospan" id="kobo.731.2">There are two approaches for server-side data fetching with </span><span><span class="kobospan" id="kobo.732.1">React Query:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.733.1">Initial data approach</span></strong><span class="kobospan" id="kobo.734.1">: Use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.735.1">initialData</span></strong><span class="kobospan" id="kobo.736.1"> option in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.737.1">useQuery</span></strong><span class="kobospan" id="kobo.738.1"> hook to pass prefetched</span><a id="_idIndexMarker497" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.739.1"> data in. </span><span class="kobospan" id="kobo.739.2">This approach is enough for fetching a list of posts but would be tricky for fetching deeply nested data, such as the usernames of </span><span><span class="kobospan" id="kobo.740.1">each author.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.741.1">Hydration approach</span></strong><span class="kobospan" id="kobo.742.1">: This allows us to prefetch any requests and store the result by their query key </span><a id="_idIndexMarker498" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.743.1">and prefetch any request on the server side, even if it is deeply nested within the app, without having to pass the prefetched data down using props or </span><span><span class="kobospan" id="kobo.744.1">a context.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.745.1">We are first going to use the </span><strong class="source-inline"><span class="kobospan" id="kobo.746.1">initialData</span></strong><span class="kobospan" id="kobo.747.1"> option to fetch the list of blog posts, and then extend our solution to the hydration approach so that we can get a feeling for how both approaches work and what their pros and </span><span><span class="kobospan" id="kobo.748.1">cons are.</span></span></p>
<h2 id="_idParaDest-157" class="calibre7"><a id="_idTextAnchor158" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.749.1">Using initial data</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.750.1">React Router allows </span><a id="_idIndexMarker499" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.751.1">us to define </span><strong class="bold"><span class="kobospan" id="kobo.752.1">loaders</span></strong><span class="kobospan" id="kobo.753.1"> in routes, which </span><a id="_idIndexMarker500" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.754.1">we can use to fetch data on the server side and client side when the route is loaded. </span><span class="kobospan" id="kobo.754.2">We can then pass the data fetched from the loaders into the </span><strong class="source-inline"><span class="kobospan" id="kobo.755.1">Blog</span></strong><span class="kobospan" id="kobo.756.1"> component and the </span><strong class="source-inline"><span class="kobospan" id="kobo.757.1">useQuery</span></strong><span class="kobospan" id="kobo.758.1"> hook via the </span><strong class="source-inline"><span class="kobospan" id="kobo.759.1">initialData</span></strong><span class="kobospan" id="kobo.760.1"> option. </span><span class="kobospan" id="kobo.760.2">Let’s do </span><span><span class="kobospan" id="kobo.761.1">that now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.762.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.763.1">src/routes.jsx</span></strong><span class="kobospan" id="kobo.764.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.765.1">useLoaderData</span></strong><span class="kobospan" id="kobo.766.1"> hook from </span><strong class="source-inline1"><span class="kobospan" id="kobo.767.1">react-router-dom</span></strong><span class="kobospan" id="kobo.768.1"> and the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.769.1">getPosts</span></strong></span><span><span class="kobospan" id="kobo.770.1"> function:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.771.1">import { useLoaderData } from 'react-router-dom'</span></strong><span class="kobospan1" id="kobo.772.1">
import { Blog } from './pages/Blog.jsx'
import { Signup } from './pages/Signup.jsx'
import { Login } from './pages/Login.jsx'
</span><strong class="bold1"><span class="kobospan1" id="kobo.773.1">import { getPosts } from './api/posts.js'</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.774.1">Adjust the route to define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.775.1">loader</span></strong><span class="kobospan" id="kobo.776.1"> function, in which we simply call the </span><strong class="source-inline1"><span class="kobospan" id="kobo.777.1">getPosts</span></strong><span class="kobospan" id="kobo.778.1"> function. </span><span class="kobospan" id="kobo.778.2">We can then define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.779.1">Component()</span></strong><span class="kobospan" id="kobo.780.1"> method in which we use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.781.1">useLoaderData</span></strong><span class="kobospan" id="kobo.782.1"> hook </span><a id="_idIndexMarker501" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.783.1">to get the data from the loader, and pass it into the </span><strong class="source-inline1"><span class="kobospan" id="kobo.784.1">Blog</span></strong><span class="kobospan" id="kobo.785.1"> component, </span><span><span class="kobospan" id="kobo.786.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.787.1">
export const routes = [
  {
    path: '/',
</span><strong class="bold1"><span class="kobospan1" id="kobo.788.1">    loader: getPosts,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.789.1">    Component() {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.790.1">      const posts = useLoaderData()</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.791.1">      return &lt;Blog initialData={posts} /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.792.1">    },</span></strong><span class="kobospan1" id="kobo.793.1">
  },</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.794.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.795.1">src/pages/Blog.jsx</span></strong><span class="kobospan" id="kobo.796.1"> and import </span><strong class="source-inline1"><span class="kobospan" id="kobo.797.1">PropTypes</span></strong><span class="kobospan" id="kobo.798.1"> there, so that we can define a new prop for the </span><span><span class="kobospan" id="kobo.799.1">component later:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.800.1">
import PropTypes from 'prop-types'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.801.1">Then, add the </span><strong class="source-inline1"><span class="kobospan" id="kobo.802.1">initialData</span></strong><span class="kobospan" id="kobo.803.1"> prop to the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.804.1">Blog</span></strong></span><span><span class="kobospan" id="kobo.805.1"> component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.806.1">
export function Blog(</span><strong class="bold1"><span class="kobospan1" id="kobo.807.1">{ initialData }</span></strong><span class="kobospan1" id="kobo.808.1">) {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.809.1">Pass the </span><strong class="source-inline1"><span class="kobospan" id="kobo.810.1">initialData</span></strong><span class="kobospan" id="kobo.811.1"> prop into the </span><strong class="source-inline1"><span class="kobospan" id="kobo.812.1">useQuery</span></strong><span class="kobospan" id="kobo.813.1"> hook, </span><span><span class="kobospan" id="kobo.814.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.815.1">
  const postsQuery = useQuery({
    queryKey: ['posts', { author, sortBy, sortOrder }],
    queryFn: () =&gt; getPosts({ author, sortBy, sortOrder }),
</span><strong class="bold1"><span class="kobospan1" id="kobo.816.1">    initialData,</span></strong><span class="kobospan1" id="kobo.817.1">
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.818.1">Lastly, define </span><strong class="source-inline1"><span class="kobospan" id="kobo.819.1">propTypes</span></strong><span class="kobospan" id="kobo.820.1"> for </span><a id="_idIndexMarker502" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.821.1">the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.822.1">Blog</span></strong></span><span><span class="kobospan" id="kobo.823.1"> component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.824.1">
Blog.propTypes = {
  initialData: PropTypes.shape(PostList.propTypes.posts),
}</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.825.1">Refresh the frontend page (with JavaScript disabled) and it will now show the post list, but without resolving the author usernames. </span><span class="kobospan" id="kobo.825.2">As we can see, the initial data approach is quite simple. </span><span class="kobospan" id="kobo.825.3">However, if we wanted to fetch the usernames of all authors, we would have to store them somewhere and then pass them down into the user components using either props or a context, both of which would be quite tedious and would not scale well if we need to make more requests later. </span><span class="kobospan" id="kobo.825.4">Thankfully, there is another, more advanced approach, which we are going to learn </span><span><span class="kobospan" id="kobo.826.1">about now.</span></span></p>
<h2 id="_idParaDest-158" class="calibre7"><a id="_idTextAnchor159" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.827.1">Using hydration</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.828.1">With the </span><a id="_idIndexMarker503" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.829.1">hydration approach, we create a query client to prefetch any requests we want to make, and then dehydrate it, pass it to the component using a loader, and hydrate it again there. </span><span class="kobospan" id="kobo.829.2">Using this approach, we can simply make any query and store it using a query key. </span><span class="kobospan" id="kobo.829.3">If a component uses the same query key, it will be able to render the results on the server side. </span><span class="kobospan" id="kobo.829.4">Let’s implement the hydration </span><span><span class="kobospan" id="kobo.830.1">approach now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.831.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.832.1">src/routes.jsx</span></strong><span class="kobospan" id="kobo.833.1"> and import </span><strong class="source-inline1"><span class="kobospan" id="kobo.834.1">QueryClient</span></strong><span class="kobospan" id="kobo.835.1">, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.836.1">dehydrate</span></strong><span class="kobospan" id="kobo.837.1"> function, and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.838.1">Hydrate</span></strong><span class="kobospan" id="kobo.839.1"> component from </span><span><span class="kobospan" id="kobo.840.1">React Query:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.841.1">
import { QueryClient, dehydrate, HydrationBoundary } from '@tanstack/react-query'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.842.1">Also, import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.843.1">getUserInfo</span></strong><span class="kobospan" id="kobo.844.1"> function, as we are going to fetch usernames </span><span><span class="kobospan" id="kobo.845.1">too now:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.846.1">
import { getUserInfo } from './api/users.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.847.1">Adjust the loader; we are now going to create a query </span><span><span class="kobospan" id="kobo.848.1">client there:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.849.1">
  {
    path: '/',
    loader: </span><strong class="bold1"><span class="kobospan1" id="kobo.850.1">async () =&gt; {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.851.1">      const queryClient = new QueryClient()</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.852.1">Then, we simulate the </span><strong class="source-inline1"><span class="kobospan" id="kobo.853.1">getPosts</span></strong><span class="kobospan" id="kobo.854.1"> request from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.855.1">Blog</span></strong><span class="kobospan" id="kobo.856.1"> component by passing in the same default arguments to it as the </span><span><span class="kobospan" id="kobo.857.1">component would:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.858.1">
      const author = ''
      const sortBy = 'createdAt'
      const sortOrder = 'descending'
      const posts = await getPosts({ author, sortBy, sortOrder })</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.859.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.860.1">This duplication of default arguments is a bit problematic. </span><span class="kobospan" id="kobo.860.2">However, with our current server-side rendering solution, the data fetching and component rendering are too separated to properly share the code between them. </span><span class="kobospan" id="kobo.860.3">A more sophisticated server-side rendering solution, such as Next.js or Remix, can deal with this </span><span><span class="kobospan" id="kobo.861.1">pattern better.</span></span></p>
<ol class="calibre15">
<li value="5" class="calibre11"><span class="kobospan" id="kobo.862.1">Now, we</span><a id="_idIndexMarker504" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.863.1"> can call </span><strong class="source-inline1"><span class="kobospan" id="kobo.864.1">queryClient.prefetchQuery</span></strong><span class="kobospan" id="kobo.865.1">, with the same query key as the one that will be used by the </span><strong class="source-inline1"><span class="kobospan" id="kobo.866.1">useQuery</span></strong><span class="kobospan" id="kobo.867.1"> hook in the component, to prefetch the results of </span><span><span class="kobospan" id="kobo.868.1">the query:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.869.1">
      await queryClient.prefetchQuery({
        queryKey: ['posts', { author, sortBy, sortOrder }],
        queryFn: () =&gt; posts,
      })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.870.1">Next, we use the fetched posts array to get a unique list of author IDs </span><span><span class="kobospan" id="kobo.871.1">from them:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.872.1">
      const uniqueAuthors = posts
        .map((post) =&gt; post.author)
        .filter((value, index, array) =&gt; array.indexOf(value) === index)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.873.1">We now loop through all author IDs and prefetch </span><span><span class="kobospan" id="kobo.874.1">their information:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.875.1">
      for (const userId of uniqueAuthors) {
        await queryClient.prefetchQuery({
          queryKey: ['users', userId],
          queryFn: () =&gt; getUserInfo(userId),
        })
      }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.876.1">Now that we have prefetched all the necessary data, we need to call </span><strong class="source-inline1"><span class="kobospan" id="kobo.877.1">dehydrate</span></strong><span class="kobospan" id="kobo.878.1"> on </span><strong class="source-inline1"><span class="kobospan" id="kobo.879.1">queryClient</span></strong><span class="kobospan" id="kobo.880.1"> to return it in a </span><span><span class="kobospan" id="kobo.881.1">serializable format:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.882.1">
      return dehydrate(queryClient)
    },</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.883.1">In the </span><strong class="source-inline1"><span class="kobospan" id="kobo.884.1">Component()</span></strong><span class="kobospan" id="kobo.885.1"> method, we get this dehydrated state and use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.886.1">Hydrate</span></strong><span class="kobospan" id="kobo.887.1"> component to hydrate it again. </span><span class="kobospan" id="kobo.887.2">This hydration process makes the data accessible to the </span><a id="_idIndexMarker505" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.888.1">server-side rendered </span><span><span class="kobospan" id="kobo.889.1">query client:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.890.1">
    Component() {
</span><strong class="bold1"><span class="kobospan1" id="kobo.891.1">      const dehydratedState = useLoaderData()</span></strong><span class="kobospan1" id="kobo.892.1">
      return (
</span><strong class="bold1"><span class="kobospan1" id="kobo.893.1">        &lt;HydrationBoundary state={dehydratedState}&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.894.1">          &lt;Blog /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.895.1">        &lt;/HydrationBoundary&gt;</span></strong><span class="kobospan1" id="kobo.896.1">
      )
    },
  },</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.897.1">Finally, we can revert the </span><strong class="source-inline1"><span class="kobospan" id="kobo.898.1">src/pages/Blog.jsx</span></strong><span class="kobospan" id="kobo.899.1"> component to the previous state. </span><span class="kobospan" id="kobo.899.2">We start by </span><em class="italic"><span class="kobospan" id="kobo.900.1">removing</span></em><span class="kobospan" id="kobo.901.1"> the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.902.1">PropTypes</span></strong></span><span><span class="kobospan" id="kobo.903.1"> import:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.904.1">import PropTypes from 'prop-types'</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.905.1">Then, we </span><em class="italic"><span class="kobospan" id="kobo.906.1">remove</span></em><span class="kobospan" id="kobo.907.1"> the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.908.1">initialData</span></strong></span><span><span class="kobospan" id="kobo.909.1"> prop:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.910.1">
export function Blog(</span><strong class="bold1"><span class="kobospan1" id="kobo.911.1">{ initialData }</span></strong><span class="kobospan1" id="kobo.912.1">) {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.913.1">We also </span><em class="italic"><span class="kobospan" id="kobo.914.1">remove</span></em><span class="kobospan" id="kobo.915.1"> it in the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.916.1">useQuery</span></strong></span><span><span class="kobospan" id="kobo.917.1"> hook:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.918.1">
  const postsQuery = useQuery({
    queryKey: ['posts', { author, sortBy, sortOrder }],
    queryFn: () =&gt; getPosts({ author, sortBy, sortOrder }),
</span><strong class="bold1"><span class="kobospan1" id="kobo.919.1">    initialData,</span></strong><span class="kobospan1" id="kobo.920.1">
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.921.1">Lastly, we </span><em class="italic"><span class="kobospan" id="kobo.922.1">remove</span></em><span class="kobospan" id="kobo.923.1"> the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.924.1">propTypes</span></strong></span><span><span class="kobospan" id="kobo.925.1"> definition:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.926.1">Blog.propTypes = {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.927.1">  initialData: PropTypes.shape(PostList.propTypes),</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.928.1">}</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.929.1">Quit the frontend via </span><em class="italic"><span class="kobospan" id="kobo.930.1">Ctrl</span></em><span class="kobospan" id="kobo.931.1"> + </span><em class="italic"><span class="kobospan" id="kobo.932.1">C</span></em><span class="kobospan" id="kobo.933.1">, then restart it </span><span><span class="kobospan" id="kobo.934.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.935.1">$ npm run dev</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.936.1">Refresh the </span><a id="_idIndexMarker506" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.937.1">page and you will see that the full blog post list, including all author names, is properly rendered on the server side now, even with </span><span><span class="kobospan" id="kobo.938.1">JavaScript disabled!</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.939.1">Let’s do another benchmark to see how the performance </span><span><span class="kobospan" id="kobo.940.1">has improved:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.941.1">Open the </span><span><span class="kobospan" id="kobo.942.1">Chrome DevTools.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.943.1">Enable JavaScript again by going to the cog wheel, </span><strong class="bold"><span class="kobospan" id="kobo.944.1">Settings</span></strong><span class="kobospan" id="kobo.945.1"> | </span><strong class="bold"><span class="kobospan" id="kobo.946.1">Preferences</span></strong><span class="kobospan" id="kobo.947.1">, and unchecking </span><span><strong class="bold"><span class="kobospan" id="kobo.948.1">Disable JavaScript</span></strong></span><span><span class="kobospan" id="kobo.949.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.950.1">Go to the </span><strong class="bold"><span class="kobospan" id="kobo.951.1">Lighthouse</span></strong><span class="kobospan" id="kobo.952.1"> tab. </span><span class="kobospan" id="kobo.952.2">Click on </span><strong class="bold"><span class="kobospan" id="kobo.953.1">Analyze page load</span></strong><span class="kobospan" id="kobo.954.1"> to generate a </span><span><span class="kobospan" id="kobo.955.1">new report.</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer082">
<span class="kobospan" id="kobo.956.1"><img alt="Figure 7.9 – The Lighthouse Performance score of the server-side rendered app with the dev server" src="image/B19385_07_9.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.957.1">Figure 7.9 – The Lighthouse Performance score of the server-side rendered app with the dev server</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.958.1">The FCP and LCP times </span><a id="_idIndexMarker507" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.959.1">are almost half of the previously reported times from client-side rendering in production mode. </span><span class="kobospan" id="kobo.959.2">Looking at the waterfall diagram in the </span><strong class="bold"><span class="kobospan" id="kobo.960.1">Network</span></strong><span class="kobospan" id="kobo.961.1"> tab, we can now see that there is only one request to fetch the </span><span><span class="kobospan" id="kobo.962.1">initial page.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.963.1">Let’s now wrap up the chapter by learning about advanced </span><span><span class="kobospan" id="kobo.964.1">server-side rendering.</span></span></p>
<h1 id="_idParaDest-159" class="calibre5"><a id="_idTextAnchor160" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.965.1">Advanced server-side rendering</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.966.1">In the </span><a id="_idIndexMarker508" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.967.1">previous sections, we have successfully created a server that can do server-side rendering with hot reloading, which is very useful for development but will worsen the performance in production. </span><span class="kobospan" id="kobo.967.2">Let’s create another server function for a production server now, which will build files, use compression, and not load Vite middleware for hot reloading. </span><span class="kobospan" id="kobo.967.3">Follow these steps to create the </span><span><span class="kobospan" id="kobo.968.1">production server:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.969.1">In the root of our project, install the </span><strong class="source-inline1"><span class="kobospan" id="kobo.970.1">compression</span></strong><span class="kobospan" id="kobo.971.1"> dependency with the </span><span><span class="kobospan" id="kobo.972.1">following command:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.973.1">$ npm install compression@1.7.4</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.974.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.975.1">server.js</span></strong><span class="kobospan" id="kobo.976.1"> and define a new function for the production server, above the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.977.1">createDevServer</span></strong></span><span><span class="kobospan" id="kobo.978.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.979.1">
async function createProdServer() {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.980.1">In this function, we define a new Express app and use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.981.1">compression</span></strong><span class="kobospan" id="kobo.982.1"> package and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.983.1">serve-static</span></strong><span class="kobospan" id="kobo.984.1"> package to serve </span><span><span class="kobospan" id="kobo.985.1">our client:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.986.1">
  const app = express()
  app.use((await import('compression')).default())
  app.use(
    (await import('serve-static')).default(
      path.resolve(__dirname, 'dist/client'),
      {
        index: false,
      },
    ),
  )</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.987.1">Then, we</span><a id="_idIndexMarker509" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.988.1"> define a route that catches all paths again, this time loading the template from the built files in the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.989.1">dist/</span></strong></span><span><span class="kobospan" id="kobo.990.1"> folder:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.991.1">
  app.use('*', async (req, res, next) =&gt; {
    try {
      let template = fs.readFileSync(
        path.resolve(__dirname, 'dist/client/index.html'),
        'utf-8',
      )</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.992.1">We also directly import and render the server-side entry </span><span><span class="kobospan" id="kobo.993.1">point now:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.994.1">
      const render = (await import('./dist/server/entry-server.js')).render</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.995.1">As before, we render the React app, replace the placeholder in </span><strong class="source-inline1"><span class="kobospan" id="kobo.996.1">index.html</span></strong><span class="kobospan" id="kobo.997.1"> with the rendered app, and return the </span><span><span class="kobospan" id="kobo.998.1">resulting HTML:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.999.1">
      const appHtml = await render(req)
      const html = template.replace(`&lt;!--ssr-outlet--&gt;`, appHtml)
      res.status(200).set({ 'Content-Type': 'text/html' }).end(html)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1000.1">For the error handling, we simply pass it on to the next middleware now and return </span><span><span class="kobospan" id="kobo.1001.1">the app:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1002.1">
    } catch (e) {
      next(e)
    }
  })
  return app
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1003.1">At the </span><a id="_idIndexMarker510" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1004.1">bottom of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1005.1">server.js</span></strong><span class="kobospan" id="kobo.1006.1"> file, where we created the dev server, we now do a check for the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1007.1">NODE_ENV</span></strong><span class="kobospan" id="kobo.1008.1"> environment variable and use it to decide whether to start the production server or the </span><span><span class="kobospan" id="kobo.1009.1">development server:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1010.1">if (process.env.NODE_ENV === 'production') {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1011.1">  const app = await createProdServer()</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1012.1">  app.listen(process.env.PORT, () =&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1013.1">    console.log(</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1014.1">      `ssr production server running on http://localhost:${process.env.PORT}`,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1015.1">    ),</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1016.1">  )</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1017.1">} else {</span></strong><span class="kobospan1" id="kobo.1018.1">
  const app = await createDevServer()
  app.listen(process.env.PORT, () =&gt;
    console.log(
      `ssr dev server running on http://localhost:${process.env.PORT}`,
    ),
  )
</span><strong class="bold1"><span class="kobospan1" id="kobo.1019.1">}</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1020.1">Install the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1021.1">cross-env</span></strong><span class="kobospan" id="kobo.1022.1"> package, </span><span><span class="kobospan" id="kobo.1023.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1024.1">$ npm install cross-env@7.0.3</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1025.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1026.1">package.json</span></strong><span class="kobospan" id="kobo.1027.1"> and add a </span><strong class="source-inline1"><span class="kobospan" id="kobo.1028.1">start</span></strong><span class="kobospan" id="kobo.1029.1"> script, which starts the server in </span><span><span class="kobospan" id="kobo.1030.1">production mode:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1031.1">
    "start": "cross-env NODE_ENV=production node server",</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1032.1">Quit the</span><a id="_idIndexMarker511" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1033.1"> frontend dev server, build, and start the </span><span><span class="kobospan" id="kobo.1034.1">production server:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1035.1">$ npm run build</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1036.1">$ npm start</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.1037.1">As we can see, our server still serves the app just fine, but now we are not in development mode anymore, so we do not have hot reloading available. </span><span class="kobospan" id="kobo.1037.2">This wraps up our implementation of server-side rendering! </span><span class="kobospan" id="kobo.1037.3">As you can imagine, the server-side rendering implementation in this chapter is somewhat basic, and there are still multiple things we would need </span><span><span class="kobospan" id="kobo.1038.1">to handle:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.1039.1">Redirects and proper HTTP </span><span><span class="kobospan" id="kobo.1040.1">status codes</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1041.1">Static-site generation (caching resulting HTML pages so we don’t have to server-side render them again </span><span><span class="kobospan" id="kobo.1042.1">every time)</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1043.1">Better data </span><span><span class="kobospan" id="kobo.1044.1">fetching functionality</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1045.1">Better code splitting between the server </span><span><span class="kobospan" id="kobo.1046.1">and client</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1047.1">Better </span><a id="_idIndexMarker512" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1048.1">handling of environment variables between the server </span><span><span class="kobospan" id="kobo.1049.1">and client</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1050.1">To solve these issues, it is better to use a fully-fledged server-side rendering implementation in a web framework, such as Next.js or Remix. </span><span class="kobospan" id="kobo.1050.2">These frameworks already provide ways to do server-side rendering, data fetching, and routing out of the box, and do not require us to manually get everything to work in tandem. </span><span class="kobospan" id="kobo.1050.3">We are going to learn more about Next.js in </span><a href="B19385_16.xhtml#_idTextAnchor291" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.1051.1">Chapter 16</span></em></span></a><span class="kobospan" id="kobo.1052.1">, </span><em class="italic"><span class="kobospan" id="kobo.1053.1">Getting Started </span></em><span><em class="italic"><span class="kobospan" id="kobo.1054.1">with Next.js</span></em></span><span><span class="kobospan" id="kobo.1055.1">.</span></span></p>
<h1 id="_idParaDest-160" class="calibre5"><a id="_idTextAnchor161" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1056.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1057.1">In this chapter, we first learned how to benchmark web applications using Lighthouse and Chrome DevTools. </span><span class="kobospan" id="kobo.1057.2">We also learned about useful metrics for such benchmarks, called Core Web Vitals. </span><span class="kobospan" id="kobo.1057.3">Then, we learned about rendering React components on the server and the differences between client-side rendering and server-side rendering. </span><span class="kobospan" id="kobo.1057.4">Next, we implemented server-side rendering for our app using Vite and React Router. </span><span class="kobospan" id="kobo.1057.5">Then, we implemented server-side data fetching using React Query. </span><span class="kobospan" id="kobo.1057.6">We then benchmarked our app again and saw an improvement in the performance of more than 40%. </span><span class="kobospan" id="kobo.1057.7">Lastly, we learned about getting our server-side rendering server ready for production and concepts that a more sophisticated server-side rendering framework needs to </span><span><span class="kobospan" id="kobo.1058.1">deal with.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1059.1">In the next chapter, </span><a href="B19385_08.xhtml#_idTextAnchor162" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.1060.1">Chapter 8</span></em></span></a><span class="kobospan" id="kobo.1061.1">, </span><em class="italic"><span class="kobospan" id="kobo.1062.1">Making Sure Customers Find You with Search Engine Optimization</span></em><span class="kobospan" id="kobo.1063.1">, we are going to learn how to make our web app more accessible to search engine crawlers, increasing the SEO score that we saw in the Lighthouse report. </span><span class="kobospan" id="kobo.1063.2">We are going to add meta tags to have more information about our web app and add integrations for various social </span><span><span class="kobospan" id="kobo.1064.1">media sites.</span></span></p>
</div>
</body></html>