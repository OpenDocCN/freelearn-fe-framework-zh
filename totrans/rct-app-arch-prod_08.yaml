- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have finally finished developing our application. Before we release it to
    production, we want to ensure that everything works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to test our application by using different
    testing approaches. This will give us the confidence to refactor the application,
    build new features, and modify the existing ones without worrying about breaking
    the current application behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will know how to test our application with different
    methods and tools.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get started, we need to set up our project. To be able to develop
    our project, we will need the following things installed on our computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node.js** version 16 or above and **npm** version 8 or above'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are multiple ways to install Node.js and npm. Here is a great article
    that goes into more detail: [https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js](https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js).'
  prefs: []
  type: TYPE_NORMAL
- en: '**VSCode** (optional) is currently the most popular editor/IDE for JavaScript/TypeScript,
    so we will be using it. It is open source, has great integration with TypeScript,
    and we can extend its features via extensions. It can be downloaded from [https://code.visualstudio.com/](https://code.visualstudio.com/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/React-Application-Architecture-for-Production](https://github.com/PacktPublishing/React-Application-Architecture-for-Production).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The repository can be cloned locally with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the repository has been cloned, we need to install the application’s dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can provide the environment variables using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the dependencies have been installed, we need to select the right stage
    of the code base that matches this chapter. We can do that by executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will prompt us with a list of stages for each chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is the eighth chapter, so we can select `chapter-08-start` if we want to
    follow along, or `chapter-08` to see the final results of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Once the chapter has been selected, all the files required to follow along with
    this chapter will appear.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the setup details, check out the `README.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is a testing method where application units are tested in isolation
    without depending on other parts.
  prefs: []
  type: TYPE_NORMAL
- en: For unit testing, we will use Jest, which is the most popular framework for
    testing JavaScript applications.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, we will unit test the notifications store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s open the `src/stores/notifications/__tests__/notifications.test.ts` file
    and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The notifications test works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We assert that the `notifications` array is initially empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we fire the `showNotification` action and test that the newly created
    notification exists in the `notifications` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we call the `dismissNotification` function to dismiss the notification
    and make sure the notification is removed from the `notifications` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To run unit tests, we can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Another use case for unit testing would be various utility functions and reusable
    components, including logic that could be tested in isolation. However, in our
    case, we will test our components mostly with integration tests, which we will
    see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration testing is a testing method where multiple parts of the application
    are tested together. Integration tests are generally more helpful than unit tests,
    and most application tests should be integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests are more valuable because they can give more confidence in
    our application since we are testing the functionality of different parts, the
    relationship between them, and how they communicate.
  prefs: []
  type: TYPE_NORMAL
- en: For integration testing, we will use Jest and the React Testing Library. This
    is a great approach to testing features of the application in the same way the
    user would use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/testing/test-utils.ts`, we can define some utilities we can use in
    our tests. We should also re-export all utilities provided by the React Testing
    Library from here so that we can easily reach out to them whenever they are needed
    in our tests. Currently, in addition to all the functions provided by the React
    Testing Library, we are also exporting the following utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`appRender` is a function that calls the `render` function from the React Testing
    Library and adds `AppProvider` as a `wrapper`. We need this because, in our integration
    tests, our components rely on multiple dependencies defined in `AppProvider`,
    such as the React Query context, notifications, and more. Providing `AppProvider`
    as a `wrapper` will make it available when we render the component during testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkTableValues` is a function that goes through all the cells in the table
    and compares each value with the corresponding value from the provided data, ensuring
    that all the information is displayed in the table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`waitForLoadingToFinish` is a function that waits for all loading spinners
    to disappear before we can proceed further with our tests. This is useful when
    we must wait for some data to be fetched before we can assert the values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another file worth mentioning is `src/testing/setup-tests.ts`, where we can
    configure different initialization and cleanup actions. In our case, it helps
    us initialize and reset the mocked API between tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can split our integration tests by pages and test all the parts on each
    page. The idea is to perform integration tests on the following parts of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: Dashboard jobs page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dashboard job page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create job page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Login page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public job page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public organization page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dashboard jobs page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The functionality of the dashboard jobs page is based on the currently logged-in
    user. Here, we are fetching all the jobs of the user’s organization and displaying
    them in the jobs table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by opening the `src/__tests__/dashboard-jobs-page.test.tsx` file
    and adding the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The test is working as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Since loading the jobs depends on the currently logged-in user, we need to mock
    the `useUser` hook to return the proper user object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we render the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we make sure the jobs page’s title is displayed on the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To get the loaded jobs, we need to wait for them to finish loading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we assert the jobs values in the table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dashboard job page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The functionality of the dashboard job page is that we want to load the job
    data and display it on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by opening the `src/__tests__/dashboard-job-page.test.tsx` file
    and adding the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The test works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Since we are loading job data based on the `jobId` URL parameter, we need to
    mock the `useRouter` hook to return the proper job ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we render the page and wait for the data to load by waiting for all loaders
    to disappear from the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we check that the job data is displayed on the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Job creation page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The job creation page contains a form which, when submitted, calls the API endpoint
    that creates a new job on the backend. When the request succeeds, we redirect
    the user to the dashboard jobs page and show the notification about successful
    job creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by opening the `src/__tests__/dashboard-create-job-page.test.tsx`
    file and adding the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The test works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to mock the `useRouter` hook to contain the `push` method because
    it is used for navigating to the jobs page after the submission.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we render the page component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we get all the inputs and insert values into them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we submit the form by simulating the click event on the **Submit** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the submission, we need to wait for the **Job Created** notification to
    appear in the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Public organization page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the organization page, since we are rendering it on the server, we need
    to fetch the data on the server and display it on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by opening the `src/__tests__/public-organization-page.test.tsx`
    file and defining the skeleton of the test suite, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will focus on each test in the test suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we want to test that the `getServerSideProps` function fetches the right
    data and returns it as props, which will be provided on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are calling the `getServerSideProps` function and asserting that the
    returned value contains the corresponding data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second test, we want to verify that the data provided as props to the
    `PublicOrganizationPage` component is rendered properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we are rendering the page component and verifying that all the
    values are displayed on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the third test of the test suite, we want to assert that if the organization
    does not exist, we want to display the *not* *found* message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are rendering the `PublicOrganizationPage` component with an organization
    value of `null`, and then verifying that the *not found* message should be in
    the document.
  prefs: []
  type: TYPE_NORMAL
- en: Public job page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the public job page, since we are rendering it on the server, we need to
    fetch the data on the server and display it on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by opening the `src/__tests__/public-job-page.test.tsx` file and
    defining the skeleton for the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can focus on each test in the test suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to test the `getServerSideProps` function, which will fetch
    the data and return it via props to the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are calling `getServerSideProps` and asserting whetherthe return value
    matches the expected data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can test `PublicJobPage`, where we want to ensure the provided data
    is displayed on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are rendering the page component and verifying that the given job’s
    data is displayed on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we want to assert the case where the data provided by `getServerSideProps`
    does not exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Since there are several cases where the data can be considered invalid, we are
    using the `rerender` function, which can re-render the component with a different
    set of props. We assert that if the data is not found, the *not found* message
    is displayed on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Login page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The login page renders the login form, which, when submitted successfully, navigates
    the user to the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by opening the `src/__tests__/login-page.test.tsx` file and adding
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The test works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to mock the `useRouter` hook because it is being used to navigate the
    user to the dashboard on successful submission.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we render the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we enter the credentials into the form and submit it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we expect the `replace` method on the router to be called with the
    `/dashboard/jobs` value, which should navigate the user to the dashboard if the
    login submission succeeds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To run the integration tests, we can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to watch the changes in the test, we can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: End-to-end testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: End-to-end testing is a testing method where an application is tested as a complete
    entity. Usually, these tests consist of running the entire application with the
    frontend and the backend in an automated way and verifying that the entire system
    works.
  prefs: []
  type: TYPE_NORMAL
- en: In end-to-end tests, we usually want to test the happy path to confirm that
    everything works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: To test our application end to end, we will be using Cypress, a very popular
    testing framework that works by executing the tests in a headless browser. This
    means that the tests will be running in a real browser environment. In addition
    to Cypress, since we have become familiar with the React Testing Library, we will
    use the Testing Library plugin for Cypress to interact with the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our application, we want to test two flows of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: Dashboard flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dashboard flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dashboard flow is the flow for organization admins where we want to test
    authenticating the user and accessing and interacting with different parts of
    the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by opening the `cypress/e2e/dashboard.cy.ts` file and adding the
    skeleton for our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s implement the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we want to authenticate into the dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we want to clear cookies and `localStorage`. Then, we must attempt to
    navigate to the dashboard; however, the application will redirect us to the login
    page. We must enter the credentials in the login form and submit it. After that,
    we will be redirected to the dashboard jobs page, where we can see the **Jobs**
    title.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are on the dashboard jobs page, we can proceed further by visiting
    the job details page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are clicking the **View** link of one of the jobs and navigating to
    the job details page, where we verify that the selected job data is being displayed
    on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s test the job creation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Since we are on the job details page, we need to navigate back to the dashboard
    jobs page, where we can click on the **Create Job** link. This will take us to
    the create job page. Here, we fill in the form and submit it. When the submission
    succeeds, the **Job Created** notification should appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have tested at all the features of the dashboard, we can log out
    from the dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Clicking the **Log Out** button logs the user out and redirects them to the
    login page.
  prefs: []
  type: TYPE_NORMAL
- en: Public flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The public flow of the application is available for everyone who visits it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by opening the `cypress/e2e/public.cy.ts` file and adding the skeleton
    of the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s start implementing the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we want to visit the organization page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are visiting an organization details page and checking whether the
    data displayed there matches the organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are on the organization details page, we can view a job of the
    organization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we click the **View** link of a job, and then we navigate to the job details
    page, where we are asserting the job data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run end-to-end tests, we need to build the application first by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can start the tests by opening the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can run the tests in headless mode since it is less resource-demanding,
    which is great for CI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to test our application, thus making it ready
    for production.
  prefs: []
  type: TYPE_NORMAL
- en: We started by learning about unit testing by implementing unit tests for our
    notifications store.
  prefs: []
  type: TYPE_NORMAL
- en: Since integration tests are much more valuable because they give more confidence
    that something is working properly, we used these tests to test the pages.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we created end-to-end tests for public and dashboard flows, where we
    tested the entire functionality of each flow.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to prepare and release our application
    to production. We will use these tests and integrate them within our CI/CD pipeline,
    where we will not allow the application to be released to production if any of
    the tests fail. This will keep our users more satisfied as there is less chance
    of bugs ending up in production.
  prefs: []
  type: TYPE_NORMAL
