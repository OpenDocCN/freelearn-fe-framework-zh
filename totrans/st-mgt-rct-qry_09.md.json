["```js\nconst { data } = useQuery({\n    queryKey: [\"api\"]\n    queryFn: fetchData,\n});\nconst { data } = useQuery([\"api\"], fetchData);\n```", "```js\nuseQuery({ queryKey, queryFn, ...options })\nuseMutation({ mutationFn, ...options })\nuseInfiniteQuery({ queryKey, queryFn, ...options })\n```", "```js\nconst ComponentA = () => {\n  const { data, error, isPending, isError, isFetching } =\n    useQuery({\n    queryKey: [{ queryIdentifier: \"api\", apiName: apiA }],\n    queryFn: fetchData,\n  });\n  if (isPending) return <div> Loading data... </div>;\n  ...\n};\n```", "```js\nuseQuery({\n    gcTime: 60000\n});\n```", "```js\nimport { useState } from \"react\";\nimport {\n  HydrationBoundary,\n  QueryClient,\n  QueryClientProvider,\n} from \"@tanstack/react-query\";\nexport default function App({ Component, pageProps }) {\n  const [queryClient] = useState(() => new QueryClient());\n  return (\n  <QueryClientProvider client={queryClient}>\n    <HydrationBoundary state={pageProps.\n          dehydratedState}>\n      <Component {...pageProps} />\n    </HydrationBoundary>\n  </QueryClientProvider>\n  );\n}\n```", "```js\nimport {\n  ...\n  Outlet,\n} from \"@remix-run/react\";\nimport { useState } from \"react\";\nimport {\n  HydrationBoundary,\n  QueryClient,\n  QueryClientProvider,\n} from \"@tanstack/react-query\";\nimport { useDehydratedState } from \"use-dehydrated-state\";\nexport default function App() {\n  const [queryClient] = useState(() => new QueryClient());\n  const dehydratedState = useDehydratedState();\n  return (\n  ...\n     <QueryClientProvider client={queryClient}>\n       <HydrationBoundary state={dehydratedState}>\n         <Outlet />\n       </HydrationBoundary>\n     </QueryClientProvider>\n   ...\n  );\n}\n```", "```js\nimport { useQuery, keepPreviousData } from \"@tanstack/react-query\";\n...\nconst PaginatedQuery = () => {\n  ...\n  const { isPending, isError, error, data, isFetching,\n    isPlaceholderData } =\n    useQuery({\n      queryKey: userKeys.paginated(page),\n      queryFn: fetchData,\n      placeholderData: keepPreviousData,\n    });\n  if (isPending) {\n    return <h2>Loading initial data...</h2>;\n  }\n  ...\n  return (\n    <>\n     ...\n        <button\n          disabled={isPlaceholderData}\n          onClick={() => setPage((old) => old + 1)}\n        >\n          Next Page\n        </button>\n...\n    </>\n  );\n};\nexport default PaginatedQuery;\n```", "```js\nexport const NewOptimisticMutation = () => {\n  const [name, setName] = useState(\"\");\n  const [age, setAge] = useState(0);\n  const queryClient = useQueryClient();\n  const { data } = useQuery({\n    queryKey: userKeys.all(),\n    queryFn: fetchAllData,\n    retry: 0,\n  });\n  const mutation = useMutation({\n    mutationFn: createUser,\n    onSettled: () =>\n      queryClient.invalidateQueries({ queryKey: userKeys.\n        all() }),\n  });\n  return (\n    <div>\n      {data?.map((user, index) => (\n        <div key={user.userID + index}>\n          Name: {user.name} Age: {user.age}\n        </div>\n      ))}\n      {mutation.isPending && (\n        <div key={String(mutation.submittedAt)}>\n          Name: {mutation.variables.name} Age:\n            {mutation.variables.age}\n        </div>\n      )}\n      <form>\n        <input\n          name=\"name\"\n          type={\"text\"}\n          onChange={(e) => setName(e.target.value)}\n          value={name}\n        />\n        <input\n          name=\"number\"\n          type={\"number\"}\n          onChange={(e) => setAge(Number(e.target.value))}\n          value={age}\n        />\n        <button\n          disabled={mutation.isPaused ||\n            mutation.isPending}\n          type=\"button\"\n          onClick={(e) => {\n            e.preventDefault();\n            mutation.mutate({ name, age });\n          }}\n        >\n          Add\n        </button>\n      </form>\n    </div>\n  );\n};\n```", "```js\nexport const NewOptimisticMutationV2 = () => {\n  const { data } = useQuery({\n    queryKey: userKeys.all(),\n    queryFn: fetchAllData,\n    retry: 0,\n  });\n\n  const [mutation] = useMutationState({\n    filters: { mutationKey: userKeys.userMutation(),\n      status: \"pending\" },\n    select: (mutation) => ({\n      ...mutation.state.variables,\n      submittedAt: mutation.state.submittedAt,\n    }),\n  });\n  return (\n    <div>\n      {data?.map((user, index) => (\n        <div key={user.userID + index}>\n          Name: {user.name} Age: {user.age}\n        </div>\n      ))}\n      {mutation && (\n        <div key={String(mutation.submittedAt)}>\n          Name: {mutation.name} Age: {mutation.age}\n        </div>\n      )}\n      <MutationForm />\n    </div>\n  );\n};\n```", "```js\nconst mutation = useMutation({\n    mutationFn: createUser,\n    mutationKey: userKeys.userMutation(),\n  });\n```", "```js\nconst {\n    isPending,\n    isError,\n    error,\n    data,\n    fetchNextPage,\n    isFetchingNextPage,\n    hasNextPage,\n  } = useInfiniteQuery({\n    queryKey: userKeys.api(),\n    queryFn: getInfiniteData,\n    defaultPageParam: 0,\n    maxPages: 5,\n    getNextPageParam: (lastPage, pages) => {\n      return lastPage?.info?.nextPage;\n    },\n    getPreviousPageParam: (firstPage, pages) => {\nreturn firstPage?.info?.prevPage\n    }\n  });\n  if (isPending) {\n    return <h2>Loading initial data...</h2>;\n  }\n  ...\n```"]