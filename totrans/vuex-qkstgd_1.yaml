- en: Rethinking User Interfaces with Flux, Vue, and Vuex
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I started my first job as a Java EE programmer at the end of 2007\. I still
    remember my friend Giuseppe saying, *You don't like JavaScript, do you?* and me
    answering, *No, I don't. Each time I write something in JavaScript, it doesn't
    work in all versions of Internet Explorer... not to mention Firefox!* He just
    replied, *Have a look at jQuery*. Today, I like to call myself a JavaScript programmer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Since then, web development has evolved a lot. A number of JavaScript frameworks
    became popular and then declined because new frameworks emerged. You may think
    that it is not worth learning new frameworks since they will eventually decline
    in popularity. Well, in my opinion, that is not true. Each framework added something
    useful to web development, something that we still use. For example, jQuery made
    use of JavaScript that was so simple that we started moving client logic to the
    browser instead of rendering everything server-side.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Today, we write progressive web applications that are complex applications with
    web user interfaces. This complexity requires discipline and best practices. Fortunately,
    big companies such as Facebook, Google, and others have introduced frameworks
    and guidelines to help web programmers. You may have heard about Google's *Material
    Design* or Facebook's *Flux*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will focus on the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '**Model-view-controller** (**MVC**) problems, and using Facebook Flux architecture
    to solve these problems'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flux fundamentals
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What Vuex is
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architectural differences between Flux and Vuex
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand this book, you need a good knowledge of Vue.js and JavaScript,
    a basic understanding of ECMAScript 6, and a very basic knowledge of webpack.
    In any case, almost all the concepts used here, Vuex and otherwise, are explained.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: After explaining the Flux concepts, this book will help you understand how Vuex
    implements these concepts, how to use Vue.js and Vuex to build professional web
    applications, and finally how to extend Vuex functionality.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: MVC problems and the Flux solution
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each time we speak about an application with a user interface, the MVC pattern
    comes out. But what is the MVC pattern? It is an architectural pattern that divides
    components into three parts: a **Model**, a **View**, and a **Controller**. You
    can see the classic diagram describing MVC in the following figure:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97330382-a3be-4205-9fb3-64fcd418944f.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.0: Classic MVC diagram'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the modern frameworks for progressive web applications use the MVC
    pattern. In fact, if you look at the Vue.js single file component shown in the
    following figure, you can clearly see the three parts of the MVC pattern:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0ea9c0a-8155-4ab5-b80c-35373ae3fcec.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Vue.js single file component'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The `template` and `style` parts represent the view section, the `script` part
    provides the controller, and the `data` section of the controller is the model.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: But what happens when we need some data from the model of a component that's
    inside another component? Moreover, in general, how can we interconnect all the
    components of a page?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly, providing direct access to the model of the components from other
    components is not a good idea. The following screenshot shows the dependencies
    in the case of exposing the models:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6574c3ed-6a76-4d69-94d5-29984a28dc37.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: MVC hell'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Vue.js provides a good way of communicating between parent and child components:
    You can use P*rops* to pass values from a parent to a child component, and you
    can *emit* data from a child component to its parent. The following figure shows
    a visual representation of this concept:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99cc432f-79f5-46f8-badc-398fd5b46feb.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: Vue.js parent–child communication'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when multiple components share a common state, this way of communicating
    is not enough. The following are the issues that would come up:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Multiple views may share the same piece of state
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User actions from different views may need to change the same piece of state
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some frameworks provide a component called `EventBus`; in fact, the Vue instance
    itself is an `EventBus`. It has two methods: `Vue.$emit(event, [eventData])` and
    `Vue.$on(event, callback([eventData]))`. The following is an example of how to
    create a global event bus:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Even with a global event bus, making components communicate is not easy. What
    if a component that registers to an event gets loaded after the event is fired?
    It will miss the event. This may happen if that component is inside a module that
    gets loaded later, which is likely to happen in a progressive web app where modules
    are lazily loaded.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: For example, say that a user wants to add a product to the cart list. She taps
    on the *Add to cart* button, which is likely to be in the `CartList` component,
    and she expects the product she sees on the screen to be saved in the cart. How
    can the `CartList` component find out what the product is that should be added
    to its list?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, it seems that Facebook programmers faced similar problems, and to solve
    those problems, they designed what they called *Flux*: Application architecture
    for building user interfaces.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Inspired by Flux and Elm architecture, Evan You, the author of *Vue.js*, created
    Vuex. You may know Redux already. In that case, you will find that Vuex and Redux
    are similar, and that Evan You saved us time by implementing Vuex instead of forcing
    every programmer to integrate Redux inside a Vue.js application. In addition,
    Vuex is designed around Vue.js to provide the best integration between the two
    frameworks.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: But what is Vuex? That is the topic of the next section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: What is Vuex?
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Evan Youdefines Vuex as:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '*"*state management pattern + library for Vue.js applications. It serves as
    a centralized store for all the components in an application, with rules ensuring
    that the state can only be mutated in a predictable fashion."'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Without knowing Flux, this definition sounds a little bit obscure. Actually,
    Vuex is a Flux implementation that exploits the reactivity system of Vue using
    a single, centralized store, and ensures that *the state can only be mutated in
    a predictable fashion*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Before focusing on Vuex itself, we are going to understand the fundamentals
    of Flux and how Vuex took inspiration from these concepts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Flux fundamentals
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flux is a pattern for managing data flow in your application, and it is the
    application architecture that Facebook uses for building its web applications.
    The following diagram shows the structure and data flow in Flux:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/022c599e-8a98-4e29-947f-fde93d093c77.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: Structure and data flow in Flux'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the preceding figure, Flux is divided into four parts, and *data
    flows in only one direction*. In the next sections, we will see how data flows
    through the following parts:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dispatchers
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stores
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Views
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although it is important to understand how Flux works, Vuex has its own implementation
    of Flux architecture that differs from Flux, and it will be explained in detail
    in the following chapters.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Actions define the internal API of your application. They represent what can
    be done, but not how it is done. The logic of state mutation is contained inside
    stores. An action is simply an object with a type and some data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Actions should be meaningful to the reader and they should avoid implementation
    details. For example, `remove-product-from-cart` is better than splitting it into
    `update-server-cart`, `refresh-cart-list`, and `update-money-total`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: An action is dispatched to all the stores and it can cause more than one store
    to update. So dispatching an action will result in one or more stores executing
    the corresponding action handler.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when a user taps on the *Remove from cart* button, a `remove-product-from-cart`
    action is dispatched:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In Vuex, the action system is a bit different, and it splits Flux actions into
    two concepts:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutations
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions represent a behavior of an application, something that the application
    must do. The result of an action consists typically of one or more mutations being
    committed. Committing a mutation means executing its associated handler. It is
    not possible to change the Vuex state directly inside an action; instead, actions
    commit mutations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: You have to deal with asynchronous code inside actions, since mutations must
    be synchronous.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Mutations, on the other hand, can and do modify the application state. They
    represent the application logic directly connected to the application state. Mutations
    should be simple, since complex behavior should be handled by actions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Since there is only one store in Vuex, actions are dispatched using the store,
    and there is a direct connection between an action and its handler. In Flux, on
    the other hand, every store knows what to do when responding to the action.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: You will read about the Vuex action/mutation system in the following chapters.
    Right now, you just need to understand the concepts behind actions, and that Vuex
    implements actions in a slightly different way than the one used by Flux.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Dispatcher
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is only one dispatcher per application, and it receives actions and dispatches
    them to the stores. Every store receives every action. It is a simple mechanism
    to dispatch actions, and it can handle dependencies between stores by dispatching
    actions to the stores in a specific order.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: A user taps on the *Add to cart* button
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The view captures this event and dispatches an `add-to-cart` action
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every store receives this action
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since Vuex differs from Flux because the dispatcher is inside the store, what
    you should remember here is that every change in the application begins by dispatching
    an action.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Stores
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Stores contain the application state and logic. Stores can be mutated only
    by actions and do not expose any setter method. There can be more than one store
    in Flux, each one representing a domain within the application. In Vuex, there
    is only one store, and its state is called a single state tree. Vuex is not the
    only framework that enforces the use of a single store: Redux explicitly states
    that there is one store per Redux application. You may think that a single store
    may break modularity. We will see later how modularity works on Vuex.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Before switching to Flux architecture, Facebook chat kept experiencing a bug
    where the number of unread messages was wrong. Instead of having two lists—one
    of read messages and another of unread ones—they used to derive the number of
    unread messages from other components events. It is indeed better to have an explicit
    state where all the information is stored. Think of the state as an application
    snapshot: You could save it before the application page gets closed and restore
    it when the application gets opened again so that the user will find the application
    in the same state it was left in.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three important concepts regarding stores:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Stores can be mutated only by actions
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a store is mutated, it notifies it has changed to the views
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stores represent explicit data, as opposed to deriving data from events
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of a store reacting to the `add-to-cart` action dispatched
    in the previous example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The store receives the `add-to-cart` action
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It decides it is relevant and executes the logic of the action by adding the
    current product to the cart product list
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It updates its data and then notifies the views that it has changed
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Views
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Views, or view controllers, display data from the stores. Here is where a framework
    like Vue.js plugs in.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Rendering data in the stores
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Facebook video introducing Flux, software engineer Jing Chen talks about
    some of the problems they faced while developing Facebook Chat, and what lessons
    they learned. One interesting lesson they learned concerns rendering: They didn''t
    want to rerender all the messages in the chat, but instead wanted to optimize
    it a bit by updating the chat view with only the new messages. If you are an experienced
    programmer, you may think, T*his is a premature optimization*. Indeed it is! It
    is much more simple to pass the whole view-model to the views rather than just
    pass the differences from the old and new model.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Say that a programmer wants to add a new feature to a view: If the view-model
    is rendered by the view each time it is modified, they just need to add some properties
    to the model and add some code to the view to display these new properties. They
    don''t need to worry about updating/rendering logic.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'But what about performance? Isn''t it bad to rerender the whole page just because
    the number of unread messages has changed? Here, Vue.js comes to help us. A programmer
    just needs to update the view-model and Vue.js will understand what has changed
    and will rerender only the **Document Object Model** (**DOM**) parts that actually
    changed. The following diagram schematizes this concept:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37625ad0-2d63-46fe-891d-02d91f4d847c.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: Vue.js updating a DOM node'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'The lesson is this: Spend time on designing explicit, meaningful models and
    let Vue.js take care of the performance and rendering logic.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The **DOM** is used to render a web page. See [https://www.w3schools.com/js/js_htmldom.asp](https://www.w3schools.com/js/js_htmldom.asp)
    for more information.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Stores and private components model
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since views display data from stores, you may think that a view-model is just
    a portion of a store. Actually, each component can have a private model that can
    hold values that are needed just inside the component. There is no need to put
    every value in a store. Stores should contain only data relevant to the application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to select some photos from a list and share them.
    The view-model of the photo list component will contain the list of selected photos,
    and when a user taps on the Share button, the view-controller just needs to dispatch
    an action called `share-photos` with the selected photo list as data in the `action`
    object. There is no need to put the selected photo list inside a store.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing Flux architecture
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the Flux architecture summarized in a single image:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a48c973-8e31-4f23-942f-560cb9cbdd84.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6: Flux data flow explained'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of using Flux
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some of the benefits that Facebook gained after introducing
    Flux to their web applications:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Better scalability than the classic MVC
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy-to-understand data flow
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier and more effective unit tests
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since actions represent behaviors of the application, behavior-driven development
    is a perfect match to write applications using Flux architecture
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于动作代表了应用程序的行为，因此以行为驱动的开发非常适合使用Flux架构编写应用程序。
- en: By adding the Vuex framework to your `Vue.js` application, you will experience
    the same benefits. In addition, Vuex, like Redux, simplified this architecture
    in several different ways, such as using a single store per application and removing
    the dispatcher from the process in favor of using the store to dispatch actions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将Vuex框架添加到您的`Vue.js`应用程序中，您将体验到同样的好处。此外，Vuex，就像Redux一样，以几种不同的方式简化了这种架构，例如每个应用程序使用一个存储库，并且为了使用存储库来分发动作，从过程中移除了分发器。
- en: Summary
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we looked at why Facebook engineers designed the Flux architecture.
    We focused on the fundamentals of Flux and learned that Vuex differs slightly
    from Flux. We can now summarize Flux in one sentence: Flux is a predictable state
    management system with a one-way data flow.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了为什么Facebook工程师设计了Flux架构。我们关注了Flux的基本原理，并了解到Vuex与Flux略有不同。现在我们可以用一句话来概括Flux：Flux是一个具有单向数据流的可预测状态管理系统。
- en: In [Chapter 2](80f5c4a1-49e4-44f6-aa6e-8012d8608f3d.xhtml), *Implementing Flux
    Architecture with Vuex*, you will learn the core concepts of Vuex, as well as
    how you can use Vuex in your applications.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](80f5c4a1-49e4-44f6-aa6e-8012d8608f3d.xhtml)《使用Vuex实现Flux架构》中，您将学习Vuex的核心概念，以及如何在您的应用程序中使用Vuex。
