- en: CSS-in-JS (in Reason)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS-in-JS（在Reason中）
- en: One of the great things about React is that it lets us collocate a component's
    markup, behavior and styles in a single file. This collocation has cascading effects
    (no pun intended) on the developer experience, version control, and code quality
    over time. In this chapter, we'll briefly explore what CSS-in-JS is and how we
    can approach CSS-in-JS in Reason. Of course, it's perfectly valid to break a component
    up across separate files and/or use a more traditional CSS solution, if that's
    what you prefer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: React的一个优点是它允许我们将组件的标记、行为和样式放在一个文件中。这种组合对开发者的体验、版本控制和代码质量产生了连锁反应（无意中用了双关语）。在本章中，我们将简要探讨CSS-in-JS是什么以及我们如何在Reason中处理CSS-in-JS。当然，如果你更喜欢，完全可以将组件拆分到单独的文件中，并/或使用更传统的CSS解决方案。
- en: 'In this chapter, we will be looking at the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: What is CSS-in-JS?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是CSS-in-JS？
- en: Using `styled-components`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`styled-components`
- en: Using `bs-css`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`bs-css`
- en: What is CSS-in-JS?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是CSS-in-JS？
- en: Defining CSS-in-JS is currently a polarizing topic in the JavaScript community.
    CSS-in-JS was born during the component age. The modern web is largely built with
    the component model. Pretty much all JavaScript frameworks have embraced it. As
    its adoption grew, more and more teams started working on various components of
    the same project. Imagine that you're working on a large app in a distributed
    team and each team is working on a component in parallel. Without having the team
    standardize CSS conventions, you're going to run into CSS scoping issues. Without
    some type of standardized CSS style guide, it's going to be easy for multiple
    teams to style a class name such that other unintended components are affected.
    Over time, a number of solutions emerged to solve this and other related problems
    with CSS at-scale.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 定义CSS-in-JS目前在JavaScript社区中是一个有争议的话题。CSS-in-JS是在组件时代诞生的。现代网络主要使用组件模型构建。几乎所有的JavaScript框架都采用了它。随着其采用率的增长，越来越多的团队开始在同一项目的各个组件上工作。想象一下，你在一个分布式团队中工作，正在开发一个大型应用程序，每个团队都在并行地开发一个组件。如果没有团队标准化CSS约定，你将遇到CSS作用域问题。如果没有某种类型的标准化CSS风格指南，多个团队很容易对类名进行样式化，从而影响其他未预期的组件。随着时间的推移，出现了一些解决方案来解决这些问题以及其他与CSS相关的规模问题。
- en: A brief history
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简要历史
- en: Some CSS conventions that became popular include BEM, SMACSS, and OOCSS. Each
    of these solutions required developers to learn the convention and remember to
    apply it correctly; otherwise, frustrating scoping issues could still occur.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流行的CSS约定包括BEM、SMACSS和OOCSS。每个解决方案都要求开发者学习该约定并记住正确应用它；否则，仍然可能会遇到令人沮丧的作用域问题。
- en: CSS modules became a safer option, where developers would import CSS into JavaScript
    modules and a build step would automatically scope that CSS locally to that JavaScript
    module. The CSS itself is still written in a normal CSS (or SASS) file.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: CSS模块成为了一个更安全的选项，开发者可以将CSS导入JavaScript模块，构建步骤会自动将CSS局部作用域到该JavaScript模块。CSS本身仍然是在一个正常的CSS（或SASS）文件中编写的。
- en: 'CSS-in-JS went one step further and allowed you to write your CSS directly
    in your JavaScript module, automatically scoping that CSS locally to the component.
    This felt right for a lot of developers; others didn''t like it from the start.
    Some CSS-in-JS solutions, such as `styled-components`, allow developers to couple
    CSS together with components directly. Instead of `<header className="..." />`,
    you could have `<Header />`, where the `Header` component is defined using `styled-components`
    and its CSS, as shown in the following code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: CSS-in-JS更进一步，允许你直接在JavaScript模块中编写CSS，自动将CSS局部作用域到组件。这对许多开发者来说感觉是正确的；而有些人从一开始就不喜欢它。一些CSS-in-JS解决方案，如`styled-components`，允许开发者直接将CSS与组件耦合。你不必使用`<header
    className="..." />`，而是可以有`<Header />`，其中`Header`组件是用`styled-components`及其CSS定义的，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There was a time when `styled-components` had performance issues, since the
    JavaScript bundle had to download, compile, and execute before the library could
    create style sheets dynamically in the DOM. These problems have now been largely
    solved thanks to server-side rendering support. So, are we able to do this in
    Reason? Let's see!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经有一段时间，`styled-components`存在性能问题，因为JavaScript包必须下载、编译和执行，然后库才能在DOM中动态创建样式表。这些问题的现在已经基本得到解决，多亏了服务器端渲染的支持。那么，我们能在Reason中这样做吗？让我们看看吧！
- en: Using styled-components
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用styled-components
- en: One of the most loved features of `styled-components` is the ability to dynamically
    create CSS based on a component's props. One reason to use this feature is to
    create alternate versions of a component. These alternate versions would then
    be encapsulated within the styled component itself. The following is an example
    of a `<Title />` where the text could be either centered or left-aligned and optionally
    underlined.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`styled-components`最受欢迎的功能之一是能够根据组件的属性动态创建CSS。使用这个功能的一个原因是可以创建组件的替代版本。这些替代版本将被封装在样式化组件本身中。以下是一个示例，其中文本可以是居中对齐或左对齐，并且可选地带有下划线。'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The challenge in the context of Reason lies in creating a component via the
    `style-components` API that can work with props dynamically. Consider the following
    binding for the `styled.h1` function and our `<Title />` component.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Reason的上下文中，挑战在于通过`style-components` API创建一个可以动态处理属性的组件。考虑以下对`styled.h1`函数和我们的`<Title
    />`组件的绑定。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `h1` function accepts an array of strings as its first argument, and an
    array of expressions as its second argument. This is because that is the ES5 representation
    of ES6-tagged template literals. In the case of the `h1` function, the array of
    expressions are functions of the props passed to the React component.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`h1`函数接受一个字符串数组作为其第一个参数，以及一个表达式数组作为其第二个参数。这是因为这是ES5对ES6标记模板字面量的表示。在`h1`函数的情况下，表达式数组是传递给React组件的属性所调用的函数。'
- en: We're using the `[@bs.variadic]` decorator to allow an arbitrary number of arguments.
    On the Reason side, we use an array, and on the JavaScript side the array is expanded
    as an arbitrary number of arguments.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`[@bs.variadic]`装饰器来允许任意数量的参数。在Reason端，我们使用一个数组，而在JavaScript端，这个数组被展开为任意数量的参数。
- en: Using [@bs.variadic]
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用[@bs.variadic]
- en: 'Let''s go off on a quick tangent to explore `[@bs.variadic]` a bit further.
    Let''s assume you''d like to bind to `Math.max()`, which can take one or more
    arguments:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速偏离一下主题，进一步探讨`[@bs.variadic]`。假设你想要绑定到`Math.max()`，它可以接受一个或多个参数：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a perfect case for `[@bs.variadic]`. We use an array on the Reason side
    to hold the arguments, and the array will be expanded to match the above syntax
    in JavaScript.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完美的`[@bs.variadic]`用例。我们在Reason端使用一个数组来保存参数，这个数组将被展开以匹配上述JavaScript中的语法。
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Okay, we''re back to the `styled-components` example. We can use the `<Title
    />` component as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们回到了`styled-components`的例子。我们可以这样使用`<Title />`组件：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code is a styled ReasonReact component that renders an `h1` with
    some CSS. The CSS was defined previously within the `StyledComponents.Title` module.
    The `<Title />` component has two props—center and underline—both of which default
    to `false`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码是一个样式化的ReasonReact组件，它使用CSS渲染了一个`h1`元素。该CSS之前在`StyledComponents.Title`模块中定义过。《Title
    />》组件有两个属性——center和underline，它们都默认为`false`。
- en: Of course, this wouldn't be an elegant way to write styled components but it's
    functionally similar to the JavaScript version. Another option is to drop back
    into raw JavaScript to take advantage of the familiar tagged template literal
    syntax. Let's illustrate this example in `Title.re`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是编写样式化组件的优雅方式，但它在功能上与JavaScript版本相似。另一个选择是回到原始JavaScript，以利用熟悉的标记模板字面量语法。让我们在`Title.re`中展示这个例子。
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The usage would be similar, except that now the `<Title />` component is no
    longer a submodule of `StyledComponents`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法类似，但现在`<Title />`组件不再是`StyledComponents`的子模块。
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Personally, I like the developer experience when using the `[%bs.raw]` version.
    I'd like to give Adam Coll (`@acoll1`) a big round of applause for coming up with
    both versions of the `styled-components` bindings. I'm also very excited to see
    what the community comes up with.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 个人来说，我喜欢使用`[%bs.raw]`版本的开发者体验。我想对Adam Coll (`@acoll1`)表示衷心的感谢，因为他想出了`styled-components`绑定的两个版本。我也非常期待看到社区会提出什么。
- en: 'Let''s now explore the community''s most popular CSS-in-JS solution: `bs-css`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索社区最受欢迎的CSS-in-JS解决方案：`bs-css`。
- en: Using bs-css
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用bs-css
- en: While there is no official recommendation from the Reason team for a CSS-in-JS
    solution, many are currently using a library called `bs-css` that wraps the emotion
    CSS-in-JS library (version 9). The `bs-css` library provides a type-safe API for
    use in Reason. With this approach, we can have the compiler check our CSS as well.
    We'll get a feel for this library by converting our `App.scss`, which we created
    in [Chapter 3](21586d11-fa31-446f-99f1-dae3beecdb9b.xhtml), *Creating ReasonReact
    Components*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Reason团队没有对CSS-in-JS解决方案提出官方推荐，但许多人目前都在使用一个名为`bs-css`的库，该库封装了emotion CSS-in-JS库（版本9）。`bs-css`库为Reason提供了类型安全的API。使用这种方法，我们可以让编译器检查我们的CSS。我们将通过将我们的`App.scss`转换为`App.scss`，这是我们在[第3章](21586d11-fa31-446f-99f1-dae3beecdb9b.xhtml)中创建的，*创建ReasonReact组件*，来了解这个库。
- en: 'To follow along, clone this book''s GitHub repository and start from `Chapter06/app-start` using
    the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟上，请克隆这本书的GitHub仓库，并从`Chapter06/app-start`开始，使用以下代码：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To get started with `bs-css`, we''ll include it as a dependency for both `package.json`
    and `bsconfig.json` as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用`bs-css`，我们将将其作为依赖项包含在`package.json`和`bsconfig.json`中，如下所示：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After installing `bs-css` via npm and configuring `bsconfig.json`, we''ll have
    access to the `Css` module provided by the library. It''s standard practice to
    define your own submodule called `Styles`, where we open the `Css` module and
    write all of our CSS-in-Reason there. Since we''ll be converting `App.scss`, we''ll
    declare a `Styles` submodule in `App.re`, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过npm安装`bs-css`并配置`bsconfig.json`之后，我们将能够访问库提供的`Css`模块。定义自己的子模块`Styles`是标准做法，我们在其中打开`Css`模块，并将所有的CSS-in-Reason写在那里。由于我们将转换`App.scss`，我们将在`App.re`中声明一个`Styles`子模块，如下所示：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s convert the following Sass:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将以下Sass转换为：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Inside `Styles`, we declare a binding called `app` that will be used later
    in the `<App />` component''s `className` prop. We''ll bind to the result of a
    `bs-css` function called `style`. The `style` function takes in a list of CSS
    rules. Let''s explore the syntax using the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Styles`内部，我们声明了一个名为`app`的绑定，它将在`<App />`组件的`className`属性中使用。我们将绑定到名为`style`的`bs-css`函数的结果。`style`函数接受一个CSS规则列表。让我们通过以下代码来探索其语法：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It''s a bit weird at first, but the more you use it, the nicer it feels. All
    CSS properties and all units are functions. The functions have types. If the types
    don''t match, the compiler will complain. Consider the following invalid CSS:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 起初可能有点奇怪，但用得越多，感觉越好。所有CSS属性和所有单位都是函数。函数有类型。如果类型不匹配，编译器会报错。考虑以下无效的CSS：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This just silently fails in CSS, Sass, and even `styled-components`. With `bs-css`,
    we can at least prevent a lot of invalid CSS. The compiler will also inform us
    of any unused bindings, which can help us maintain CSS style sheets, and, as usual,
    we have full IntelliSense, which helps us learn the API as we go.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这在CSS、Sass甚至`styled-components`中都是静默失败的。使用`bs-css`，我们至少可以防止很多无效的CSS。编译器还会通知我们任何未使用的绑定，这可以帮助我们维护CSS样式表，并且，像往常一样，我们有完整的IntelliSense，这有助于我们在使用过程中学习API。
- en: 'Personally, I''m a big fan of nesting CSS via Sass, and I''m thrilled that
    we can do the same with `bs-css`. To nest the `:after` pseudo selector, we use
    the `after` function. To nest the `.overlay` selector, we use the `selector` function.
    Just like in Sass, we use the `&` symbol to reference the parent element, as shown
    in the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 个人来说，我是Sass嵌套CSS的大粉丝，我很高兴我们也可以用`bs-css`做到这一点。为了嵌套`:after`伪选择器，我们使用`after`函数。为了嵌套`.overlay`选择器，我们使用`selector`函数。就像在Sass中一样，我们使用`&`符号来引用父元素，如下所示：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note how we are using the polymorphic variant `` `transition `` for the transition
    strings. Transitions are not valid otherwise.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何使用多态变体`transition`来表示过渡字符串的。否则，过渡是不有效的。
- en: 'You can find the rest of the conversion in the GitHub repository''s `Chapter06/app-end/src/App.re`
    file. Now all that''s left to do is apply the styles to the `<App />` component''s
    `className` prop, as shown in the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub仓库的`Chapter06/app-end/src/App.re`文件中找到其余的转换。现在我们只剩下将样式应用到`<App />`组件的`className`属性上了，如下所示：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After deleting `App.scss`, everything looks mostly the same. Awesome! The exception
    is the `nav > ul > li:after` selector. In previous chapters, we used the content
    property to render an image, like so:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`App.scss`后，一切看起来几乎都一样。太棒了！例外的是`nav > ul > li:after`选择器。在之前的章节中，我们使用内容属性来渲染图像，如下所示：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'According to `Css.rei`, the `contentRule` function accepts a string. Therefore,
    using the `url` function does not typecheck, as shown in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `Css.rei`，`contentRule` 函数接受一个字符串。因此，使用 `url` 函数不会进行类型检查，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As an escape route, `bs-css` provides the `unsafe` function (as shown in the
    following code), which will bypass this problem:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条逃生路线，`bs-css` 提供了 `unsafe` 函数（如下面的代码所示），这将绕过这个问题：
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: However, while our webpack configuration previously pulled the preceding image
    in as a dependency, it no longer does this when using `bs-css`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管我们之前的 webpack 配置会将前面的图像作为依赖项拉入，但在使用 `bs-css` 时，它不再这样做。
- en: Trade-offs
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权衡
- en: Using CSS-in-JS in Reason clearly is a trade-off. On the one hand, we can get
    type-safe, locally scoped CSS and we get to collocate our CSS with our components.
    On the other hand, the syntax is a bit more verbose and there may be some weird
    edge cases. It's perfectly valid to choose Sass over a CSS-in-JS solution as there
    is no clear winner here.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Reason 中使用 CSS-in-JS 显然是一个权衡。一方面，我们可以获得类型安全的、局部作用域的 CSS，并且可以将我们的 CSS 与组件一起定位。另一方面，语法稍微有点冗长，可能会有一些奇怪的边缘情况。选择
    Sass 而不是 CSS-in-JS 解决方案是完全合理的，因为在这里没有明显的胜者。
- en: Other libraries
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他库
- en: I encourage you to try other CSS-in-JS Reason libraries. And whenever you're
    looking for a Reason library, your first stop should be Redex (**Re**ason Package
    In**dex**).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励您尝试其他 CSS-in-JS Reason 库。并且无论您在寻找 Reason 库时，您的第一个目的地应该是 Redex（**Re**ason
    **P**ackage **I**ndex**）。
- en: 'You can find Redex (**Re**ason Package In**dex**) at:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置找到 Redex（**Re**ason **P**ackage **I**ndex**）：
- en: '[https://redex.github.io/](https://redex.github.io/)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://redex.github.io/](https://redex.github.io/)'
- en: Another helpful resource is the Reason Discord channel. It's a good place to
    ask about the various CSS-in-JS solutions and their trade-offs.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的资源是 Reason Discord 频道。这是一个询问各种 CSS-in-JS 解决方案及其权衡的好地方。
- en: 'You can find the Reason Discord channel at:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置找到 Reason Discord 频道：
- en: '[https://discord.gg/reasonml](https://discord.gg/reasonml)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/reasonml](https://discord.gg/reasonml)'
- en: Summary
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: CSS-in-JS is still fairly new, and there will be a lot of experimentation with
    it in the Reason community in the near future. In this chapter, we learned about
    some of the benefits and challenges of CSS-in-JS (in Reason). Where do you stand?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: CSS-in-JS 仍然相对较新，在 Reason 社区中未来将会有很多关于它的实验。在本章中，我们了解了一些 CSS-in-JS（在 Reason 中）的好处和挑战。您站在哪一边？
- en: In [Chapter 7](baf36f3b-7e4f-4a31-afae-1ef9ee48b17c.xhtml), *JSON in Reason*,
    we're going to learn about handling JSON in Reason and see how GraphQL can help
    reduce boilerplate code while achieving some pretty compelling guarantees.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 7 章](baf36f3b-7e4f-4a31-afae-1ef9ee48b17c.xhtml)，“Reason 中的 JSON”，我们将学习如何在
    Reason 中处理 JSON，并看看 GraphQL 如何帮助减少样板代码同时实现一些相当吸引人的保证。
