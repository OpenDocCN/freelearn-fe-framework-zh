- en: Chapter 6. Working with the Angular Router and Forms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。使用 Angular 路由器和表单
- en: By now, we're already familiar with the core of the framework. We know how to
    define components and directives in order to develop the view of our applications.
    We also know how to encapsulate business-related logic into services and wire
    everything together with the DI mechanism of Angular.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经熟悉了框架的核心。我们知道如何定义组件和指令来开发我们应用程序的视图。我们还知道如何将业务逻辑封装到服务中，并使用 Angular
    的依赖注入（DI）机制将一切连接起来。
- en: 'In this chapter, we''ll explain a few more concepts that will help us build
    real-life Angular applications. They are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释一些更多概念，这将帮助我们构建实际的 Angular 应用程序。它们如下：
- en: The component-based router of the framework.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架的基于组件的路由器。
- en: Using Angular's forms module.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular 的表单模块。
- en: Developing custom form validators.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发自定义表单验证器。
- en: Developing template-driven forms.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发模板驱动表单。
- en: Let's begin!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Developing the "Coders repository" application
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 "Coders repository" 应用程序
- en: Throughout the process of explaining the listed concepts, we'll develop a sample
    application that contains a repository of developers. Before we start coding,
    let's discuss the structure of the application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释所列概念的过程中，我们将开发一个包含开发者库的示例应用程序。在我们开始编码之前，让我们讨论应用程序的结构。
- en: The "Coders repository" will allow its users to add developers, either by filling
    a form with details about them, or by providing the GitHub handle for the developer
    and importing their profile from GitHub.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '"Coders repository" 将允许其用户通过填写包含开发者详细信息的表单，或者提供开发者的 GitHub 处理器并从 GitHub 导入他们的个人资料来添加开发者。'
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the purpose of this chapter, we will store information about the developers
    in memory, which means that, after the page is refreshed, we'll lose all the data
    stored during the session.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章的目的，我们将在内存中存储开发者的信息，这意味着在页面刷新后，我们将丢失在会话期间存储的所有数据。
- en: 'The application will have the following views:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将具有以下视图：
- en: A list of all the developers.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有开发者的列表。
- en: A view for adding or importing new developers.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于添加或导入新开发者的视图。
- en: 'A view that shows the given developer''s details. This view has two subviews:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个显示给定开发者详细信息的视图。这个视图有两个子视图：
- en: '**Basic details**: Shows the name of the developer and their GitHub avatar
    if available.'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本详情**：显示开发者的姓名以及如果有的话他们的 GitHub 头像。'
- en: '**Advanced profile**: Shows all the details known of the developer.'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级资料**：显示开发者所知的所有详细信息。'
- en: 'The end result of the application''s home page will look as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序主页的最终结果将如下所示：
- en: '![Developing the "Coders repository" application](img/1-1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![开发 "Coders repository" 应用程序](img/1-1.jpg)'
- en: Figure 1
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this chapter, we will build only a few of the listed views. The rest of the
    application will be explained in [Chapter 7](ch07.html "Chapter 7. Explaining
    Pipes and Communicating with RESTful Services"), *Explaining Pipes and Communicating
    with RESTful Services*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只将构建所列视图中的几个。其余的应用程序将在 [第 7 章](ch07.html "第 7 章。解释管道和与 RESTful 服务通信")
    中解释，*解释管道和与 RESTful 服务通信*。
- en: 'Each developer will be an instance of the following class:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开发者都将是一个以下类的实例：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'All the developers will reside within the `DeveloperCollection` class:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所有开发者都将位于 `DeveloperCollection` 类中：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The classes mentioned here encapsulate a simple business logic and don't have
    anything Angular-specific, so we won't get into any details.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到的类封装了简单的业务逻辑，没有 Angular 特定的内容，所以我们不会深入细节。
- en: Now, let's continue with the implementation by exploring the new router.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过探索新的路由器继续实现：
- en: Exploring the Angular router
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Angular 路由器
- en: As we already know, in order to bootstrap any Angular application, we need to
    develop a root NgModule and a bootstrap component. The "Coders repository" application
    is not any different; the only addition in this specific case is that we will
    have multiple pages that need to be connected together with the Angular router.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，为了启动任何 Angular 应用程序，我们需要开发一个根 NgModule 和一个启动组件。"Coders repository" 应用程序也不例外；在这个特定情况下，唯一的增加是我们将有多个页面需要通过
    Angular 路由器连接在一起。
- en: 'Let''s start with the imports required for the router''s configuration and
    define the root component right after this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从路由器配置所需的导入开始，并在之后定义根组件：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding snippet, we import the `RouterModule` directly from `@angular/router`;
    as we can see, the router is externalized outside the framework's core. This module declares
    all the routing-specific directives, as well as all the routing-related providers,
    which means that, if we import it, we'll get access to all of them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们直接从`@angular/router`导入`RouterModule`；正如我们所看到的，路由器被外部化到框架的核心之外。此模块声明了所有路由特定的指令以及所有与路由相关的提供者，这意味着如果我们导入它，我们将获得访问它们的权限。
- en: The `LocationStrategy` class is an abstract class that defines the common logic
    between `HashLocationStrategy` (used for hash-based routing) and `PathLocationStrategy`
    (used for HTML5-based routing by taking advantage of the history API).(that is,
    meaningful for the router).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocationStrategy`类是一个抽象类，它定义了`HashLocationStrategy`（用于基于哈希的路由）和`PathLocationStrategy`（通过利用历史API进行基于HTML5的路由）之间的共同逻辑。（即对路由器有意义）。'
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`HashLocationStrategy` does not support server-side rendering, because the hash
    of the page does not get sent to the server. Since the hash is our application''s
    view identifier, the server will not be aware of the page that needs to be rendered.
    Fortunately, all modern browsers except IE9 support the HTML5 history API. You
    can find more about server-side rendering in the final chapter of this book.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashLocationStrategy`不支持服务器端渲染，因为页面的哈希值不会发送到服务器。由于哈希是应用程序的视图标识符，服务器将不会知道需要渲染的页面。幸运的是，除了IE9之外的所有现代浏览器都支持HTML5历史API。你可以在本书的最后一章中找到更多关于服务器端渲染的信息。'
- en: 'Now, let''s define a bootstrap component and configure the application''s root
    module:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个引导组件并配置应用程序的根模块：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding snippet, we can notice a syntax we're already familiar with
    from [Chapter 4](ch04.html "Chapter 4. Getting Started with Angular Components
    and Directives"), *Getting Started with Angular Components and Directives* and
    [Chapter 5](ch05.html "Chapter 5. Dependency Injection in Angular"), *Dependency
    Injection in Angular*. We define a component with an `app` selector, `template`,
    which we will take a look at later, and sets of providers and directives.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以注意到一个我们已经在[第4章](ch04.html "第4章。开始使用Angular组件和指令")和[第5章](ch05.html
    "第5章。Angular中的依赖注入")中熟悉的语法，*开始使用Angular组件和指令*和*Angular中的依赖注入*。我们定义了一个具有`app`选择器的组件，`template`，我们将在稍后查看它，以及提供者和指令的集合。
- en: The `App` component declares a single provider associated with the `DeveloperCollection`
    token. This is the class that contains all of the developers stored by the application.
    Later, we invoke the `forRoot` method of the `RouterModule`; this method allows
    us to configure the router by declaring some of the routes of the application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`组件声明了一个与`DeveloperCollection`令牌关联的单个提供者。这是包含应用程序存储的所有开发者的类。稍后，我们将调用`RouterModule`的`forRoot`方法；此方法允许我们通过声明应用程序的一些路由来配置路由器。'
- en: Once we have imported the module, returned as a result of the invocation of
    `forRoot`, we already have access to a set of directives. These directives can
    help us link to the other routes defined as part of the router's configuration (the
    `routerLink` directive) and declare the place where the components associated
    with the different routes should be rendered (`router-outlet`). We'll explain
    how we can use them later in this section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们导入了模块，该模块作为`forRoot`调用返回的结果，我们就可以访问一组指令。这些指令可以帮助我们链接到作为路由器配置一部分定义的其他路由（`routerLink`指令）并声明与不同路由关联的组件应该渲染的位置（`router-outlet`）。我们将在本节后面解释如何使用它们。
- en: 'Now, let''s take a look at the configuration of our `AppModule`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的`AppModule`的配置：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We add a single declaration-the `App` component-that we use for bootstrapping
    the application. Note that, here, we import not only the `BrowserModule`, but
    also the result returned from the invocation of the `forRoot` method of the `RouterModule`.
    In the `providers` array, we configure the provider for the `LocationStrategy`.
    The default `LocationStrategy` implementation, which Angular uses, is `PathLocationStrategy`
    (that is, the HTML5-based one). However, in this case, we will use the hash-based
    one.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个单独的声明——用于引导应用程序的`App`组件。请注意，在这里，我们不仅导入了`BrowserModule`，还导入了从`RouterModule`的`forRoot`方法调用返回的结果。在`providers`数组中，我们配置了`LocationStrategy`的提供者。Angular使用的默认`LocationStrategy`实现是`PathLocationStrategy`（即基于HTML5的）。然而，在这种情况下，我们将使用基于哈希的。
- en: When we have to choose between the two location strategies, we should bear in
    mind that the default location strategy (`PathLocationStrategy`) is supported
    by the server-rendering module of Angular, and the application's URL looks more
    natural to the end user (there's no `#` used). On the other hand, if we use `PathLocationStrategy`,
    we may need to configure our application server in order to work with the HTML5
    history API, which is not necessary for `HashLocationStrategy`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不得不在两种位置策略之间做出选择时，我们应该记住，默认的位置策略（`PathLocationStrategy`）由 Angular 的服务器端渲染模块支持，并且应用程序的
    URL 对最终用户来说看起来更自然（没有使用 `#`）。另一方面，如果我们使用 `PathLocationStrategy`，我们可能需要配置我们的应用程序服务器以与
    HTML5 历史API一起工作，这对于 `HashLocationStrategy` 是不必要的。
- en: Using PathLocationStrategy
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PathLocationStrategy
- en: 'The `PathLocationStrategy` uses `APP_BASE_HREF`, which by default has the string `"/"` as
    a value. This means that, in case the base pathname of our application is different,
    we must set it explicitly, in order to have a properly functioning location strategy. For
    instance, in our case, the configuration should look as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`PathLocationStrategy` 使用 `APP_BASE_HREF`，默认值为字符串 `"/"`。这意味着，如果我们的应用程序的基本路径名不同，我们必须明确设置它，以便位置策略能够正常工作。例如，在我们的情况下，配置应该如下所示：'
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`APP_BASE_HREF` represents the base path of the application. For instance,
    in our case, the "Coders repository" will be located under the `/dist/dev/ch6/ts/multi-page-template-driven/`
    directory (or, if we include the schema and the host, `http://localhost:5555/dist/dev/ch6/ts/multi-page-template-driven/`).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`APP_BASE_HREF` 表示应用程序的基本路径。例如，在我们的情况下，“Coders 仓库”将位于 `/dist/dev/ch6/ts/multi-page-template-driven/`
    目录下（或者，如果我们包括方案和主机，`http://localhost:5555/dist/dev/ch6/ts/multi-page-template-driven/`）。'
- en: We will need to provide the value of `APP_BASE_HREF` in order to hint to Angular
    which part of the path is an application route (that is, meaningful for the router).
    For instance, for the URL `http://localhost:5555/dist/dev/ch6/ts/multi-page-template-driven/**home**`
    , by having `APP_BASE_HREF` equal to `/dist/dev/ch6/ts/multi-page-template-driven/`,
    Angular will know that it needs to provide the component associated with the `home`
    path since the rest of the URL is not relevant to the declared routes within the application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供 `APP_BASE_HREF` 的值，以便向 Angular 暗示路径的哪一部分是应用程序路由（即对路由器有意义的）。例如，对于 URL
    `http://localhost:5555/dist/dev/ch6/ts/multi-page-template-driven/**home**`，如果
    `APP_BASE_HREF` 等于 `/dist/dev/ch6/ts/multi-page-template-driven/`，Angular 将知道它需要提供与
    `home` 路径关联的组件，因为 URL 的其余部分与应用程序中声明的路由无关。
- en: Configuring routes
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置路由
- en: 'As the next step, let''s update the routes'' declarations. Open `ch6/ts/step-0/app.ts` and
    update the invocation of the `forRoot` method of `RouteModule`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，让我们更新路由的声明。打开 `ch6/ts/step-0/app.ts` 并更新对 `RouteModule` 的 `forRoot` 方法的调用：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As the preceding snippet shows, the method `forRoot` accepts an array of route
    declarations as an argument. We define two redirects and two routes with components
    associated with them.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文示例所示，`forRoot` 方法接受一个路由声明数组作为参数。我们定义了两个重定向和两个与它们关联的路由。
- en: 'Each non-lazy-loaded route must define the following properties:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个非懒加载的路由都必须定义以下属性：
- en: '`component`: The component associated with the given route.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`component`：与给定路由关联的组件。'
- en: '`path`: The path to be used for the route – it will be visible in the browser''s
    location bar.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：用于路由的路径 – 它将在浏览器的地址栏中可见。'
- en: 'On the other hand, the redirect''s definition should contain:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，重定向的定义应该包含：
- en: '`path`: The path to be used for the redirection.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：用于重定向的路径。'
- en: '`redirectTo`: The path the user will be redirected to.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redirectTo`：用户将被重定向到的路径。'
- en: '`pathMatch`: Defines the matching strategy.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pathMatch`：定义匹配策略。'
- en: In the previous example, we declare that when the user navigates to the path,
    we want `/add-dev` to be redirected to `/dev-add`. As we mentioned, `pathMatch`
    defines the path matching strategy. By default, it has the value `"prefix"`, which
    means that the router will try to match the beginning of the current route with
    the `path` property declared in the redirect. In contrast, when we set the `pathMatch` property to
    the value `"full"`, the router will redirect to the `redirectTo` path only when
    the entire path has been matched. It's important to explicitly set `pathMatch`
    to `"full"` in the first redirect, because otherwise every route will match the
    `""` path in case of a match by prefix.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们声明当用户导航到路径时，我们希望 `/add-dev` 被重定向到 `/dev-add`。正如我们提到的，`pathMatch` 定义了路径匹配策略。默认情况下，它的值是
    `"prefix"`，这意味着路由器将尝试将当前路由的开始部分与重定向中声明的 `path` 属性匹配。相比之下，当我们将 `pathMatch` 属性设置为
    `"full"` 时，只有当整个路径匹配时，路由器才会重定向到 `redirectTo` 路径。在第一次重定向中显式设置 `pathMatch` 为 `"full"`
    非常重要，否则在以前缀匹配的情况下，每个路由都会匹配到 `""` 路径。
- en: 'Now, in order to make everything work, we will need to define the `AddDeveloper`
    and `Home` components, which are referenced in the router''s configuration. First,
    we will provide a basic implementation that we''ll incrementally extend over time,
    through the course of this chapter. In `ch6/ts/step-0`, create a file called `home.ts`
    and enter the following content:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使一切正常工作，我们需要定义 `AddDeveloper` 和 `Home` 组件，这些组件在路由配置中被引用。首先，我们将提供一个基本的实现，我们将在本章的整个过程中逐步扩展它。在
    `ch6/ts/step-0` 中，创建一个名为 `home.ts` 的文件，并输入以下内容：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, open the file called `add_developer.ts`, and enter the following content
    in it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开名为 `add_developer.ts` 的文件，并在其中输入以下内容：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do not forget to import the `Home` and `AddDeveloper` components in `app.ts`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在 `app.ts` 中导入 `Home` 和 `AddDeveloper` 组件。
- en: Using routerLink and router-outlet
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 routerLink 和 router-outlet
- en: We have the routes' declarations and all the components associated with them.
    The only thing left is to define the template of the root `App` component in order
    to link everything together.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了路由声明以及与之相关的所有组件。唯一剩下的事情就是定义根 `App` 组件的模板，以便将一切连接起来。
- en: 'Add the following content to the `template` property inside the `@Component`
    decorator in `ch6/ts/step-0/app.ts`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ch6/ts/step-0/app.ts` 中的 `@Component` 装饰器的 `template` 属性内添加以下内容：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the template, there are two Angular-specific directives:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，有两个 Angular 特定的指令：
- en: '`routerLink`: This allows us to add a link to a specific route.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routerLink`：这允许我们向特定路由添加链接。'
- en: '`router-outlet`: This defines the container where the components associated
    with the currently selected route should be rendered.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router-outlet`：这定义了当前选定的路由相关组件应该渲染的容器。'
- en: Let's take a look at the `routerLink` directive. As value, it accepts an array
    of route paths and parameters. In our case, we provide only a single route path.
    Note that the route name used by `routerLink` is declared by the `path` property
    of the route declaration inside `forRoot`. Later in this book, we'll see how we
    can link to nested routes and pass route parameters.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `routerLink` 指令。作为值，它接受一个路由路径和参数的数组。在我们的例子中，我们只提供了一个路由路径。请注意，`routerLink`
    所使用的路由名称是由 `forRoot` 内部路由声明中的 `path` 属性声明的。在本书的后续内容中，我们将看到如何链接到嵌套路由并传递路由参数。
- en: This directive allows us to declare links independently from the `LocationStrategy`
    that we configured. For instance, imagine we are using `HashLocationStrategy`;
    this means that we will need to prefix all the routes in our templates with `#`.
    In case we switch to `PathLocationStrategy`, we'll need to remove all the hash
    prefixes. This is only a partial benefit of the neat abstraction that `routerLink` creates
    on top of path references.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令允许我们独立于我们配置的 `LocationStrategy` 声明链接。例如，假设我们正在使用 `HashLocationStrategy`；这意味着我们需要在我们的模板中为所有路由添加前缀
    `#`。如果我们切换到 `PathLocationStrategy`，我们需要删除所有的哈希前缀。这是 `routerLink` 在路径引用之上创建的整洁抽象的部分好处。
- en: 'The next directive that is new to us from the previous template is `router-outlet`.
    It has a similar responsibility to the `ng-view` directive in AngularJS. Basically,
    they both have the same role: to point out where the target component should be
    rendered. This means that, according to the definition, when the user navigates
    to `/`, the `Home` component will be rendered at the position pointed out by `router-outlet`,
    the same for the `AddDeveloper` component once the user navigates to `dev-add`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一个模板中我们新接触到的下一个指令是 `router-outlet`。它具有与 AngularJS 中的 `ng-view` 指令类似的责任。基本上，它们都扮演相同的角色：指出目标组件应该渲染的位置。这意味着，根据定义，当用户导航到
    `/` 时，`Home` 组件将在 `router-outlet` 指示的位置渲染，同样，当用户导航到 `dev-add` 时，`AddDeveloper`
    组件也是如此。
- en: 'Now, we have these two routes up and running! Open `http://localhost:5555/dist/dev/ch6/ts/step-0/`,
    and you should see a page which looks similar to the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个路由正在运行！打开 `http://localhost:5555/dist/dev/ch6/ts/step-0/`，你应该看到一个类似于以下截图的页面：
- en: '![Using routerLink and router-outlet](img/2-1-e1485857368986.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![使用 routerLink 和 router-outlet](img/2-1-e1485857368986.jpg)'
- en: Figure 2
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图2
- en: If you don't, just take a look at `ch6/ts/step-1` that contains the end result.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不这样做，只需查看包含最终结果的 `ch6/ts/step-1`。
- en: Lazy-loading with loadChildren
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `loadChildren` 进行懒加载
- en: AngularJS modules allow us to group together logically related units in the
    application. However, by default, they need to be available during the initial
    application's bootstrap and do not allow deferred loading. This requires downloading
    the entire code base of the application during the initial page load that, in
    case of large single-page apps, can be an unacceptable performance hit.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 模块允许我们将逻辑上相关的单元组合在一起。然而，默认情况下，它们需要在初始应用程序的引导期间可用，并且不允许延迟加载。这要求在初始页面加载时下载整个应用程序的代码库，这在大型单页应用的情况下可能是一个不可接受的性能打击。
- en: In a perfect scenario, we would want to load only the code associated with the
    page the user is currently viewing or to prefetch bundled modules based on heuristics
    related to the user's behavior, which is out of the scope of this book. For instance,
    open the application from the first step of our example, `http://localhost:5555/dist/dev/ch6/ts/step-1/`.
    Once the user is at `/`, we only need the `Home` component to be available, and
    once they navigate to `dev-add`, we want to load the `AddDeveloper` component.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想情况下，我们希望只加载用户当前查看的页面相关的代码，或者根据与用户行为相关的启发式方法预取捆绑模块，但这超出了本书的范围。例如，从我们的示例的第一个步骤打开应用程序，`http://localhost:5555/dist/dev/ch6/ts/step-1/`。一旦用户到达
    `/`，我们只需要 `Home` 组件可用，一旦他们导航到 `dev-add`，我们希望加载 `AddDeveloper` 组件。
- en: 'Let''s inspect what is actually going on in Chrome DevTools:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Chrome DevTools 中检查实际发生的情况：
- en: '![Lazy-loading with loadChildren](img/3-1.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![使用 loadChildren 进行懒加载](img/3-1.jpg)'
- en: Figure 3
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图3
- en: We can notice that during the initial page load, Angular downloads the components
    associated with all the routes, even `AddDeveloper`, which is not required. This
    happens because, in `app.ts`, we explicitly require both the `Home` and the `AddDeveloper`
    components and use them in the routes' declarations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到，在初始页面加载期间，Angular 下载了与所有路由相关的组件，甚至包括不需要的 `AddDeveloper`。这是因为，在 `app.ts`
    中，我们明确地要求了 `Home` 和 `AddDeveloper` 组件，并在路由声明中使用它们。
- en: In this specific case, loading both components may not seem like a big problem
    because, at this step, they are pretty simple and do not have any dependencies.
    However, in real-life applications, they will have imports of other directives,
    components, pipes, services, or even third-party libraries. Once any of the components
    is required, its entire dependency graph will be downloaded, even if the component
    is not needed at that point.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定情况下，加载这两个组件可能看起来不是什么大问题，因为在这个阶段，它们相当简单，没有依赖项。然而，在实际应用中，它们将导入其他指令、组件、管道、服务，甚至第三方库。一旦任何组件被要求，其整个依赖图都将被下载，即使此时该组件并不需要。
- en: 'The router of Angular comes with a solution to this problem:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的路由器提供了一个解决方案来解决这个问题：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The declaration of the lazy-loaded routes is an object with the following properties:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载路由的声明是一个具有以下属性的对象：
- en: '`loadChildren`: A string that points to the path of the lazy-loaded module.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadChildren`: 一个指向懒加载模块路径的字符串。'
- en: '`path`: The path of the route.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`: 路由的路径。'
- en: Once the user navigates to a route that matches any of the lazy-routes' definitions,
    a module loader (by default, SystemJS) will download the module from the location
    provided by `loadChildren`. When the promise returned by the loader is resolved
    with a value of the target module, the module will be cached and its bootstrap
    component will be rendered. The next time the user navigates to the same route,
    the cached module will be used, so the routing module won't download the same
    component twice.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户导航到与任何懒加载路由定义匹配的路由时，模块加载器（默认为SystemJS）将从`loadChildren`提供的位置下载模块。当加载器返回的promise解析为目标模块的值时，该模块将被缓存，其引导组件将被渲染。下次用户导航到相同的路由时，将使用缓存的模块，因此路由模块不会下载相同的组件两次。
- en: Note the `#` symbol in the value of the `loadChildren` property. If we split
    the string by the `#` symbol, its first part will be the module's URL and its
    second part will be the name of the export that represents the Angular module
    the router will use for the route. If we don't provide a module name, Angular
    will use the default export.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`loadChildren`属性值中的`#`符号。如果我们通过`#`符号分割字符串，其第一部分将是模块的URL，其第二部分将是表示路由器将用于该路由的Angular模块的导出名称。如果我们不提供模块名称，Angular将使用默认导出。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding example uses `loadChildren`, which by default loads modules with
    SystemJS. You can use a more advanced configuration and a custom module loader.
    For further information, take a look at the Angular documentation at [http://angular.io](http://angular.io).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例使用了`loadChildren`，它默认使用SystemJS加载模块。您可以使用更高级的配置和自定义模块加载器。有关更多信息，请参阅Angular文档[http://angular.io](http://angular.io)。
- en: Prefetching of lazy-loaded routes
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预加载懒加载路由
- en: As we have already mentioned, in the perfect scenario, we would want to download only
    the minimum set of resources that the user needs at a given time. For instance,
    if the user visits the home page, we'd want to download only the bundle that corresponds
    to the home module (i.e. `HomeModule`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，在理想情况下，我们希望下载用户在特定时间需要的最小资源集。例如，如果用户访问主页，我们只想下载对应于主页模块（即`HomeModule`）的包。
- en: Later, when the user navigates to `dev-add`, the router will need to download
    the `AddDeveloperModule`. Although, this way, the user will consume network bandwidth
    only for the assets they use, the user experience will be far from perfect because
    of the slowdown that happens while navigating to as yet unvisited pages.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，当用户导航到`dev-add`时，路由器需要下载`AddDeveloperModule`。尽管这样，用户只为他们使用的资产消耗网络带宽，但由于导航到尚未访问的页面时发生的减速，用户体验将远非完美。
- en: 'In order to handle this problem, we can add a route preloading strategy:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以添加一个路由预加载策略：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding snippet, we declare that we want to use the default `preloadingStrategy` that
    Angular provides. As a result, when the user opens `home` and the `HomeModule` is
    successfully downloaded, the router will automatically start prefetching all the
    other routes. So, next time, when the user navigates to a different page, it will
    most likely be already available in-memory. This will introduce a neat improvement
    to the user experience at almost no cost.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明我们想要使用Angular提供的默认`preloadingStrategy`。因此，当用户打开`home`并且`HomeModule`成功下载后，路由器将自动开始预加载所有其他路由。因此，下次用户导航到不同的页面时，它很可能已经在内存中可用。这将几乎不花费任何成本地提高用户体验。
- en: By providing a custom implementation of the abstract class `PreloadingStrategy` (located
    in the `@angular/router` package), we can introduce a custom mechanism for the
    prefetching of lazy-loaded modules.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供位于`@angular/router`包中的抽象类`PreloadingStrategy`的自定义实现，我们可以引入一个用于预加载懒加载模块的自定义机制。
- en: RouterModule.forRoot versus RouterModule.forChild
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RouterModule.forRoot与RouterModule.forChild
- en: There are two methods we can invoke using the `RouterModule` in order to register
    routes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`RouterModule`调用两种方法来注册路由。
- en: In case we declare the top-level routes of our application, we need to use `RouterModule.forRoot`.
    This method will register the top-level routes and return the routing module that
    should be imported by the application's root module.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们声明应用程序的最高级路由，我们需要使用`RouterModule.forRoot`。此方法将注册顶级路由并返回应由应用程序的根模块导入的路由模块。
- en: If we want to define routes in a lazy-loaded module and import the module returned
    by the invocation of the `forRoot` method, we'll get a runtime error. This is
    because the `forRoot` method will return a module with providers, which should
    be imported only once, by the top-level module. In order to register nested routes
    in a lazy-loaded module, we will need to use the `forChild` method.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在懒加载的模块中定义路由并导入由`forRoot`方法调用返回的模块，我们将得到一个运行时错误。这是因为`forRoot`方法将返回一个包含提供者的模块，这个模块应该只由顶层模块导入一次。为了在懒加载的模块中注册嵌套路由，我们需要使用`forChild`方法。
- en: We'll take a further look at how we can define nested routes in [Chapter 7](ch07.html
    "Chapter 7. Explaining Pipes and Communicating with RESTful Services"), *Explaining
    Pipes and Communicating with RESTful Services.*
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进一步探讨如何在[第7章](ch07.html "第7章。解释管道和与RESTful服务通信")中定义嵌套路由，*解释管道和与RESTful服务通信*。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As a rule of thumb, we can remember that `RouterModule.forRoot` is meant for
    the registration of top-level routes, and `RouterModule.forChild` should be used
    only for the registration of nested routes in a lazy-loaded module.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，我们可以记住`RouterModule.forRoot`是用来注册顶级路由的，而`RouterModule.forChild`应该只用于在懒加载模块中注册嵌套路由。
- en: Using Angular's forms module
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular的表单模块
- en: Now, let's continue with the implementation of the application. For the next
    step, we'll work on the `AddDeveloper` and `Home` components. You can continue
    your implementation by extending what you currently have in `ch6/ts/step-0`, or
    if you haven't reached step 1 yet, you can keep working on the files in `ch6/ts/step-1`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行应用程序的实现。对于下一步，我们将处理`AddDeveloper`和`Home`组件。你可以通过扩展当前在`ch6/ts/step-0`中的内容来继续你的实现，或者如果你还没有达到步骤1，你可以继续在`ch6/ts/step-1`中的文件上工作。
- en: 'Angular offers two ways of developing forms with validation:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了两种开发带有验证的表单的方法：
- en: '**A template-driven approach**: This provides a declarative API where we declare
    the validations into the template of the component.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板驱动方法**：这提供了一个声明式API，其中我们在组件的模板中声明验证。'
- en: '**A model-driven approach (also known as reactive forms)**: This provides an
    imperative, reactive API.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型驱动方法（也称为响应式表单）**：这提供了一个命令式、响应式的API。'
- en: Let's start with the template-driven approach for now and explore the model-driven
    approach in the next chapter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们先从模板驱动方法开始，并在下一章中探索模型驱动方法。
- en: Developing template-driven forms
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发模板驱动表单
- en: Forms are essential for each **CRUD** (**Create Retrieve Update and Delete**)
    application. In our case, we want to build a form for entering the details of
    the developers we want to store.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 表单对于每个**CRUD**（**创建、检索、更新和删除**）应用程序都是必不可少的。在我们的案例中，我们想要构建一个表单来输入我们想要存储的开发者的详细信息。
- en: 'By the end of this section, we''ll have a form that allows us to enter the
    real name of a given developer, to add their preferred technology, enter their
    e-mail, and declare whether they are popular in the community or not yet. The
    end result will look as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，我们将有一个表单，允许我们输入给定开发者的真实姓名，添加他们偏好的技术，输入他们的电子邮件，并声明他们是否在社区中受欢迎或尚未。最终结果将如下所示：
- en: '![Developing template-driven forms](img/4-1.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![开发模板驱动表单](img/4-1.jpg)'
- en: Figure 4
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图4
- en: 'Add the following import to `app.ts`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.ts`中添加以下导入：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The next thing we need to do is import `FormsModule` in our `AppModule`. The
    `FormsModule` contains a set of predefined directives for managing Angular forms,
    such as the `form` and `ngModel` directives. The `FormsModule` also declares an
    array with a predefined set of form-related providers that we can use in our application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，我们需要在我们的`AppModule`中导入`FormsModule`。`FormsModule`包含一组预定义的指令，用于管理Angular表单，如`form`和`ngModel`指令。`FormsModule`还声明了一个数组，其中包含一组预定义的与表单相关的提供者，我们可以在应用程序中使用这些提供者。
- en: 'After the import of the `FormsModule`, our `app.ts` will look like:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入`FormsModule`之后，我们的`app.ts`将看起来如下：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, update the `AddDeveloper` implementation to the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更新`AddDeveloper`实现如下：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `developer` property contains the information associated with the current
    developer that we're adding with the form. The last two properties, `errorMessage`
    and `successMessage`, will be used respectively to display the current form's
    error or success messages once the developer has been successfully added to the
    developers collection, or when an error has occurred.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`developer` 属性包含与当前开发者相关的信息，这些信息是通过表单添加的。最后两个属性，`errorMessage` 和 `successMessage`，将分别用于在开发者成功添加到开发者集合或发生错误时显示当前表单的错误或成功消息。'
- en: Digging into the template-driven form's markup
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入模板驱动表单的标记
- en: 'As the next step, let''s create the template for the `AddDeveloper` component
    (`step-1/add_developer.html`). Add the following content to the file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，让我们为 `AddDeveloper` 组件创建模板 (`step-1/add_developer.html`)。将以下内容添加到文件中：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These two elements are intended to display the error and success messages when
    you add a new developer. They will be visible when `errorMessage` or `successMessage` have
    non-falsy values (that is, something different from the empty string, `false`,
    `undefined`, `0`, `NaN`, or `null`).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个元素旨在在添加新开发者时显示错误和成功消息。当 `errorMessage` 或 `successMessage` 有非假值（即与空字符串、`false`、`undefined`、`0`、`NaN`
    或 `null` 不同的值）时，它们将是可见的。
- en: 'Now, let''s develop the actual form:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开发实际的表单：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We declare a new form using the HTML `form` tag. Once Angular finds such tags
    in a template with an included form directive in the parent component, it will
    automatically enhance its functionality in order to be used as an Angular form.
    Once the form is processed by Angular, we can apply form validation and data bindings.
    After this, using `#f="ngForm"`, we define a local variable in template, which
    allows us to reference to the form using the identifier `f`. The last thing left
    from the form element is the submit event handler. We use a syntax that we're
    already familiar with, `(ngSubmit)="expr"`; in this case, the value of the expression
    is the call of the `addDeveloper` method defined in the component's controller.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 HTML `form` 标签声明一个新的表单。一旦 Angular 在模板中找到这样的标签，并且父组件中包含了一个表单指令，它将自动增强其功能，以便用作
    Angular 表单。一旦表单被 Angular 处理，我们就可以应用表单验证和数据绑定。之后，使用 `#f="ngForm"`，我们在模板中定义了一个局部变量，这允许我们使用标识符
    `f` 来引用表单。表单元素最后剩下的东西是提交事件处理程序。我们使用我们已熟悉的语法，`(ngSubmit)="expr"`；在这种情况下，表达式的值是调用组件控制器中定义的
    `addDeveloper` 方法。
- en: Now, let's take a look at the `div` element with the class name `control-group`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下具有类名 `control-group` 的 `div` 元素。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this is not an Angular-specific class; it is a CSS class defined by
    Bootstrap that we use in order to provide a better look and feel to the form.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这并不是一个 Angular 特定的类；这是一个由 Bootstrap 定义的 CSS 类，我们使用它来为表单提供更好的外观和感觉。
- en: Inside the `div` element, we can find a `label` element that doesn't have any
    Angular-specific markup and an input element that allows us to set the real name
    of the current developer. We set the control to be of a type text and declare
    its identifier and name equal to `realNameInput`. The `required` attribute is
    defined by the HTML5 specification and is used for validation. By using it on
    the element, we declare that this element is required to have a value. Although
    the `required` attribute is not Angular-specific, Angular will extend its semantics by
    including an Angular-specific validation behavior. This behavior includes setting
    specific CSS classes on the control when its status changes and managing its state
    which the framework keeps internally.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `div` 元素内部，我们可以找到一个没有 Angular 特定标记的 `label` 元素和一个允许我们设置当前开发者真实姓名的输入元素。我们将控件设置为文本类型，并声明其标识符和名称等于
    `realNameInput`。`required` 属性由 HTML5 规范定义，用于验证。通过在元素上使用它，我们声明此元素必须有值。尽管 `required`
    属性不是 Angular 特定的，但 Angular 会通过包括 Angular 特定的验证行为来扩展其语义。这种行为包括在控件状态改变时设置特定的 CSS
    类，并管理框架内部保持的状态。
- en: The behavior of the form controls will be enhanced by running validation over
    them when their values change, and applying specific classes during the controls'
    life cycles. You may be familiar with this from AngularJS, where the form controls
    are decorated with the `ng-pristine`, `ng-invalid`, and `ng-valid` classes, and
    so on.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当控件的值发生变化时，将运行验证以增强表单控件的行为，并在控件的生命周期中应用特定的类。您可能已经从 AngularJS 中熟悉了这一点，其中表单控件被装饰有
    `ng-pristine`、`ng-invalid` 和 `ng-valid` 类等。
- en: 'The following table summarizes the CSS classes that the framework adds to the
    form controls during their life cycle:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '| **Classes** | **Description** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| `ng-untouched` | The control hasn''t been visited |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| `ng-touched` | The control has been visited |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| `ng-pristine` | The control''s value hasn''t been changed |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| `ng-dirty` | The control''s value has been changed |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| `ng-valid` | All the validators attached to the control have returned `true`
    |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| `ng-invalid` | Any of the validators attached to the control has a `false`
    value |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: 'According to this table, we can define that we want all the input controls
    with an invalid value to have a red border in the following way:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The exact semantics behind the preceding CSS in the context of Angular is that
    we use a red border for all the input elements whose values were changed and are
    invalid according to the validators attached to them.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's explore how we can attach validation behavior to our controls.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Using the built-in validators
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already seen that we can alter validation behavior to any control using
    the `required` attribute. Angular provides two more built-in validators, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '`minlength`: This allows us to specify the minimum length of value that a given
    control should have.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxlength`: This allows us to specify the maximum length of value that a given
    control should have.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These validators are defined with Angular directives and can be used in the
    following way:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This way, we specify that we want the value of the input to be between `2` and
    `30` characters.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Defining custom validators
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another data property defined in the `Developer` class is `email`. Let''s add
    an input field for it. Above the **Add** button in the preceding form, add the
    following markup:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can think of the `[(ngModel)]` as an alternative to the `ng-model` directive
    from AngularJS. We will explain it in detail in the *Two-way data binding with
    Angular* section.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Angular provides a set of predefined validators, they are not enough
    for all the various formats our data can live in. Sometimes, we''ll need custom
    validation logic for our application-specific data. For instance, in this case,
    we want to define an e-mail validator. A typical regular expression, which works
    in general cases (but does not cover the entire specification that defines the
    format of the e-mail addresses), looks as follows: `/^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$/`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'In `ch6/ts/step-1/email_validator.ts`, define a function that accepts an instance
    of Angular control as an argument and returns `null` if the control''s value is
    empty or matches the regular expression mentioned earlier, and `{ ''invalidEmail'':
    true }` otherwise:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, from the `@angular/common` and `@angular/core` modules, import `NG_VALIDATORS`
    and `Directive`, and wrap this validation function within the following directive:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, we defined a multiprovider for the token `NG_VALIDATORS`.
    Once we inject the value associated with this token, we'll get an array with all
    the validators attached to the given control (for reference, take a look at the
    section for multiproviders in [Chapter 5](ch05.html "Chapter 5. Dependency Injection
    in Angular"), *Dependency Injection in Angular*).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'There are only two steps left in order to make our custom validation work.
    First, add the `email-input` attribute to the e-mail control:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, add the directive to the declarations in the `AppModule`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We're using an external template for the `AddDeveloper` control. There's no
    ultimate answer to whether a given template should be externalized or inlined.
    Best practice states that we should inline the short templates and externalize
    the longer ones. However, there's no specific definition as to which templates
    are considered short and which are considered long. The decision of whether the
    template should be used inline or put into an external file depends on the developer's
    personal preferences or common conventions within the organization.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Using select inputs with Angular
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the next step, we should allow the user of the application to enter the technology
    into which the input developer has the most proficiency. We can define a list
    of technologies and show them in the form as a select input.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `AddDeveloper` class, add the `technologies` property:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, in the template, just above the **Add** button, add the following markup:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Just like for the input elements we declared earlier, Angular will add the
    same classes depending on the state of the select input. In order to show a red
    border around the select element when its value is invalid, we will need to alter
    the CSS rules:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that inlining all the styles in our components' declaration could be a
    bad practice because, this way, they won't be reusable. What we can do is extract
    all the common styles across our components into separate files. The `@Component`
    decorator has a property called `styleUrls` of type `string[]` where we can add
    a reference to the extracted styles used by the given component. This way, we
    can inline only the component-specific styles, if required.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Right after this, we declare the name of the control to be equal to `"technology"`
    using `name="technology"`. Using the `required` attribute, we declare that the
    user of the application must specify the technology in which the current developer
    is proficient. Let's skip the `[(ngModel)]` attribute for now and see how we can
    define the options of the select element.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the select element, we define the different options using:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is a syntax we're already familiar with. We simply iterate over all the
    technologies defined within the `AddDeveloper` class, and for each technology
    we show an `option` element with a value for the technology name.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Using the NgForm directive
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already mentioned that the form directive enhances the HTML5 form''s
    behavior by adding some additional Angular-specific logic. Now, let''s take a
    step back and take a look at the form that surrounds the input elements:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding snippet, we define a new identifier called `f`, which references
    to the form. We can think of the form as a composition of controls; we can access
    the individual controls through the form's `controls` property. On top of this,
    the form has the **touched**, **untouched**, **pristine**, **dirty**, **invalid**,
    and **valid** properties, which depend on the individual controls defined within
    the form. For example, if none of the controls within the form have been touched,
    then the form itself will show untouched as its status. However, if any of the
    controls in the form have been touched at least once, the form will show as touched.
    Similarly, the form will be valid only if all its controls are valid.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to illustrate the usage of the `form` element, let''s define a component
    with the `control-errors` selector, which shows the current errors for a given
    control. We can use it in the following way:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that we've also added the `maxlength` validator to the `realName` control.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'The `control-errors` element has the following attributes:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '`control`: This declares the name of the control we want to show errors for.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`errors`: This creates a mapping between control error and an error message.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, create a new file called `control_errors.ts` and add the following imports
    in it:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In these imports, `NgForm` represents the Angular forms, and `Host` is a parameter
    decorator related to the DI mechanism, which we have already covered in [Chapter
    5](ch05.html "Chapter 5. Dependency Injection in Angular"), *Dependency Injection
    in Angular*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a part of the component''s definition:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `ControlErrors` component defines two inputs: `control`, the name of the
    control (the value of the `name` attribute) and `errors`, the mapping between
    an error identifier and an error message. They can be specified, respectively,
    by the `control` and the `errors` attributes of the `control-errors` element.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, lets suppose we have the following input:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can declare its associated `control-errors` component using the following
    markup:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Inside the `currentError` getter, in the declaration of the `ControlErrors`
    class above, we need to do the following two things:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Find a reference to the component declared with the `control` attribute.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the error message associated with any of the errors that make the current
    control invalid.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a snippet that implements this behavior:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the first line of the implementation of `currentError`, we get the target
    control using the `controls` property of the injected form. The `controls` property is
    of the type `{[key: string]: AbstractControl}`, where the `key` is the name of
    the control we''ve declared with the `name` attribute. Once we have a reference
    to the instance of the target control, we can check whether its status is touched
    (that is, whether it has been focused), and if it is, we can loop over all the
    errors within the `errors` property of the instance of `ControlErrors`. The `map`
    function will return an array with either an error message or a `null` value.
    The only thing left to do is to filter all the `null` values and get only the
    error messages. Once we get the error messages for each error, we will return
    the last one by popping it from the `errorMessages` array.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'The end result should look as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the NgForm directive](img/5.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: Figure 5
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you experience any problems during the implementation of the `ControlErrors`
    component, you can take a look at its implementation at `ch6/ts/step-2/control_errors.ts`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'The `hasError` method of every control accepts as an argument an error message
    identifier, which is defined by the corresponding validator. For instance, in
    the preceding example, where we defined the custom e-mail validator, we return
    the `{ ''invalidEmail'': true }` object literal when the input control has an
    invalid value. If we apply the `ControlErrors` component to the e-mail control,
    its declaration should look as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Two-way data binding with Angular
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most famous rumors about Angular 2 was that the two-way data binding
    functionality was removed because of the enforced unidirectional data flow. This
    is not exactly true; the Angular''s form module implements a directive with the
    selector `[(ngModel)]` (we''ll also refer to this directive as `NgModel`, because
    of the name of its controller), which allows us to easily achieve data binding
    in two directions: from the view to the model and from the model to the view.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following simple component:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding example, we import the `FormsModule` from the `@angular/common`
    package. Later, in the template, we set the attribute `[(ngModel)]` to `name`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: At first, the `[(ngModel)]` syntax might seem a little bit unusual. From [Chapter
    4](ch04.html "Chapter 4. Getting Started with Angular Components and Directives"),
    *Getting Started with Angular Components and Directives*, we know that the `(eventName)`
    syntax is used for binding to events (or outputs) triggered by a given component.
    On the other hand, we use the `[propertyName]="foobar"` syntax to achieve one-way
    data binding by setting the value of the property (or, in the terminology of the
    Angular components, the input) with the name `propertyName` to the result of the
    evaluation of the expression `foobar`. The `[(ngModel)]` syntax combines both
    in order to achieve data binding in two directions. That's why we can think of
    it more like a syntax sugar, rather than a new concept. One of the main advantages
    of this syntax compared to AngularJS is that we can tell which bindings are one-way
    and which are two-way by just looking at the template.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another name of the `[(foo)]` syntax is "banana in a box" or "banana brackets"
    syntax. The source of this term is the paper *Functional Programming with Bananas,
    Lenses, Envelopes and Barbed Wire* by *Erik Meijer*, *Maarten Fokkinga*, and *Ross
    Paterson* ([http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf](http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf)).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Just like `(click)` has its canonical syntax `on-click`, and `[propertyName]`
    has its own `bind-propertyName`, the alternative syntax of `[(ngModel)]` is `bindon-ngModel`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open `http://localhost:5555/dist/dev/ch6/ts/simple-two-way-data-binding/`,
    you will see the following result:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![Two-way data binding with Angular](img/6-2.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: Figure 6
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Once the value of the input box is changed, the label below it will update automatically.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already used the `[(ngModel)]` directive in the previous snippets.
    For example, we bound to the developer''s e-mail using:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This way, the value of the e-mail property of the developer object defined in the
    `AddDeveloper` component's instance will be updated once we change the value of
    the text input.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Storing the form data
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s peek at the interface of the `AddDeveloper` component''s controller
    again:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It has a field of the `Developer` type, and we bind the form controls to its
    properties using the `NgModel` directive. The class also has a method called `addDeveloper`,
    which is being invoked on the submission of the form. We declare this by binding
    to the `ngSubmit` event using:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding snippet, we can note two more things. We got a reference to
    the form using `#f="ngForm"` and bound the disabled property of the button to
    the `!f.form.valid` expression. We have already described the `NgForm` control
    in the previous section; its `valid` property will have a value `true` once all
    the controls within the form have valid values.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s suppose we''ve entered valid values for all the input controls
    in the form. This means that its submit button will be enabled. Once we press
    *Enter* or click on the submit button, the `addDeveloper` method will be invoked.
    The following is a sample implementation of this method:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Initially, we set the `id` property of the current developer equal to the total
    number of developers in `DeveloperCollection`, plus one. Later, we add the developer
    to the collection and set the value of the `successMessage` property. Right after
    this, we set the property submitted equal to `true`, which will result in hiding
    the form.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Listing all the stored data
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can add a new entry to the developers' collection, let's show a
    list of all the developers on the front page of the "Coders repository".
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file `ch6/ts/step-1/home.ts` (or step-2, depending on your progress
    during the past section), and enter the following content:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There is nothing new to us here. We extend the functionality of the `Home` component
    by providing an external template and implementing the `getDevelopers` method,
    which delegates its call to the instance of `DeveloperCollection` that is injected
    in the constructor.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'The template itself is something that we''re already familiar with:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We list all the developers as rows within an HTML table. For each developer,
    we check the status of its `popular` flag. If its value is `true`, then for the
    **Popular** column, we show a span with the text `Yes`, otherwise we set the text
    to `No`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'When you enter a few developers in the **Add developer** page and then navigate
    to the home page, you should see a result similar to the following screenshot:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing all the stored data](img/7.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
- en: Figure 7
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the complete functionalities of the application at `ch6/ts/multi-page-template-driven`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have explained the basics of routing in Angular. We took a look at
    how we can define different routes and implement the components associated with
    them that are displayed on route change. In order to link to the different routes,
    we introduced `routerLink`, and we also used the `router-outlet` directives for
    pointing out where the components associated with the individual routes should
    be rendered.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Another thing we took a look at was the Angular forms functionality with built-in
    and custom validation. After this, we explained the `NgModel` directive, which
    provides us with two-way data binding.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover how we can develop model-driven forms, child
    and parameterized routes, use the `Http` module for making RESTful calls, and
    transform data with custom pipes.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
