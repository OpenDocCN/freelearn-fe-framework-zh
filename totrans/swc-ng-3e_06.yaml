- en: Dependency Injection in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll explain how to take advantage of the **Dependency Injection**
    (**DI**) mechanism of the framework, with all its various features.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring and creating providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting dependencies, instantiated with the declared providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lower level APIs for creating and configuring injectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusing business logic defined in services across our UI components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do I need dependency injection?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s suppose that we have a `Car` class that depends on the `Engine` and
    `Transmission` classes. How can we implement this system? Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we create the dependencies of the `Car` class inside
    its constructor. Although it looks simple, it is far from being flexible. Each
    time we create an instance of the `Car` class, in its constructor, instances of
    the same `Engine` and `Transmission` classes will be created. This may be problematic
    because of the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Car` class gets less testable because we can't test it independently of
    its `engine` and `transmission` dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We couple the `Car` class with the logic used for the instantiation of its dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way we can approach this is by taking advantage of the DI pattern.
    We''re already familiar with it from AngularJS; let''s demonstrate how we can
    refactor the preceding code using DI in the context of Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: All we did in the preceding snippet was adding the `@Injectable` class decorator
    on top of the definition of the `Car` class and providing type annotations for
    the parameters of its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of using dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one more step left, which we''ll take a look at in the next section.
    Before that, let''s take a look at what the benefits of the mentioned approach
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: We can easily pass different versions of the dependencies of the `Car` class
    for a testing environment, or for instantiating different `Car` models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We're not coupled with the logic around the instantiation of the dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Car` class is only responsible for implementing its own domain-specific
    logic instead of being coupled with additional functionalities, such as the management
    of its dependencies. Our code also got more declarative and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've realized some of the benefits of DI, let's take a look at the
    missing pieces in order to make this code work.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primitive used for the instantiation of the individual dependencies in our
    Angular applications via the DI mechanism of the framework is called **injector**.
    The injector contains a set of **providers** that encapsulate the logic for the
    instantiation of registered dependencies associated with **tokens**. We can think
    of tokens as identifiers of the different providers registered within the injector.
  prefs: []
  type: TYPE_NORMAL
- en: In Angular, we can declare the providers for the individual dependencies using
    `@NgModule`. Internally, **Angular will create an injector based on the providers
    we've declared in a module**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following snippet, which is located at `ch6/injector-basics/basics/app.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you set up the code for the book (for instructions take a look at [Chapter
    5](1b60c28e-5f34-493d-8371-c69968f09020.xhtml)*, Getting Started with Angular
    Components and Directives*) and run `npm start`, you can see the result of the
    execution on the `http://localhost:5555/dist/dev/ch6/injector-basics/basics/`
    address. When you open the browser''s console you''ll see these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In *Figure 1*, we can see that `AppComponent` depends on the `Socket` class,
    which depends on the `Buffer` class, which depends on the `BUFFER_SIZE` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce5069e4-fd32-4490-97ce-2508046d432e.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1
  prefs: []
  type: TYPE_NORMAL
- en: 'We set the value of the `BUFFER_SIZE` class constant to `new InjectionToken<number>(''buffer-size'')`.
    We can think of the value of `BUFFER_SIZE` as a unique identifier that cannot
    be duplicated in the application. `InjectionToken` is an alternative of the `Symbol`
    class from ES2015, since at the time of writing this book, it is not supported
    by TypeScript. `InjectionToken` provides one additional feature that `Symbol`
    doesn''t: better type checking; Angular and TypeScript can use the type parameter
    that we pass to `InjectionToken` (`number`, in the preceding case) in order to
    perform more sophisticated type checking algorithms.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We defined two classes: `Buffer` and `Socket`. The `Buffer` class has a constructor
    that accepts only a single dependency called `size`, which is of the `number`
    type. In order to add additional metadata for the process of dependency resolution
    (that is, hint Angular that it should inject the value associated with the `BUFFER_SIZE`
    token), we use the `@Inject` parameter decorator. This decorator accepts a token
    for the dependency we want to inject. Usually, this token is the type of the dependency
    (that is, a reference of a class), but in some cases, it can be a different type
    of value. For example, in our case, we used the instance of the `InjectionToken`
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the @Injectable decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's take a look at the `Socket` class. We decorate it with the `@Injectable`
    decorator. This decorator is supposed to be used by any class that accepts dependencies
    that should be injected via the DI mechanism of Angular.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Injectable` decorator hints Angular that a given class accepts arguments
    which should be injected with the dependency injection mechanism of the framework.
    This means that if we omit the `@Injectable` decorator, Angular's DI mechanism
    will not know that it needs to resolve the dependencies of the class before it
    instantiates it.
  prefs: []
  type: TYPE_NORMAL
- en: Before version 5 of Angular, the `@Injectable` decorator had different semantics
    related to the generation of metadata with type information by the TypeScript
    compiler. Although this is an important detail, it doesn't have any impact on
    the way we use the dependency injection mechanism of the framework or the `@Injectable`
    decorator in particular.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, always use the `@Injectable` decorator when a given class
    accepts dependencies that need to be injected with the dependency injection mechanism
    of Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing forward references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular introduced the concept of **forward references**. It is required because
    of the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: ES2015 classes are not hoisted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing resolution of the dependencies that are declared after the declaration
    of the dependent providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will explain the problem that forward references solve and
    the way we can take advantage of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s suppose that we have defined the `Buffer` and `Socket` classes
    in the opposite order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have the exact same dependencies as the ones in the previous example;
    however, in this case, the `Socket` class definition precedes the definition of
    the `Buffer` class. Note that the value of the `Buffer` identifier will equal
    `undefined` before the declaration of the `Buffer` class. This means that, during
    the interpretation of the generated JavaScript, the value of the `Buffer` identifier
    will equal `undefined`: that is, as the token of the dependency, the framework
    will get an invalid value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the preceding snippet will result in a runtime error of the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The best way to resolve this issue is by swapping the definitions with their
    proper order. Another way we can proceed is to take advantage of a solution that
    Angular provides: a forward reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous snippet demonstrates how we can take advantage of forward references.
    All we need to do is to invoke the `@Inject` parameter decorator with argument
    as the result of the invocation of the `forwardRef` function. The `forwardRef`
    function is a higher-order function that accepts a single argument: another function
    that is responsible for returning the token associated with the dependency (or
    more precisely associated with its provider) that needs to be injected. This way,
    the framework provides a way to defer the process of resolving the types (tokens)
    of dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: The token of the dependency will be resolved the first time `Socket` needs to
    be instantiated, unlike the default behavior in which the token is required at
    the time of the declaration of the given class.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at an example similar to the one used earlier, but
    with a syntactically different configuration of the injector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this case, inside the provider, we explicitly declared that we want the `Buffer`
    class to be used for the construction of the dependency with a token equal to
    the reference of the `Buffer` identifier. We do the exact same thing for the dependency
    associated with the `Socket` token; however, this time, we provided the `Socket`
    class instead. This is how Angular will proceed when we omit the explicit provider
    declaration and pass only a reference to a class instead.
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly declaring the class used for the creation of an instance of the same
    class may seem quite worthless, and given the examples we have looked at so far,
    that'd be completely correct. In some cases, however, we might want to provide
    a different class for the instantiation of a dependency associated with a given
    token.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s suppose we have the `Http` service that is used in a service
    called `UserService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now let's trace the process of instantiation of the `UserService` service, in
    case we want to inject it somewhere in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Internally, Angular will create an injector based on the providers passed to
    `@NgModule`: this is the injector that Angular will use to instantiate the `UserService`
    service. Initially, the provider will find out that `UserService` service accepts
    a dependency with the `Http` token, so the provider will try to find the provider
    associated with this token. Since there''s such a provider in the same injector,
    it''ll create an instance of the `Http` service and pass it to `UserService`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far so good; however, if we want to test `UserService` service, we don''t
    really need to make HTTP calls through the network. In the case of unit testing,
    we can provide a dummy implementation that will only fake these HTTP calls. In
    order to inject an instance of a different class to the `UserService` service,
    we can change the configuration of the provider to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this case, Angular will again create an injector based on the providers pass
    to `@NgModule`. The difference this time is that with the `Http` token we have
    associated the `DummyHttp` service. Now when the injector instantiates the `UserService`,
    it'll look for providers associated with the `Http` token inside of the list of
    providers it maintains, and find out that it needs to use the `DummyHttp` service
    for creating the required dependency. When Angular finds that we've declared a
    `useClass` provider, it'll create an instance of the `DummyHttp` service with
    `new DummyHttp()`.
  prefs: []
  type: TYPE_NORMAL
- en: This code is available at `ch6/configuring-providers/dummy-http/app.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Using existing providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way to proceed is using the `useExisting` property of the provider''s
    configuration object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we register providers for three tokens: `DummyHttp`,
    `UserService`, and `Http`. We declare that we want to bind the `Http` token to
    the existing token, `DummyHttp`. This means that, when the `Http` service is requested,
    the injector will find the provider for the token used as the value of the `useExisting`
    property and instantiate it or get the value associated with it (in case it was
    already instantiated). We can think of `useExisting` as creating an alias of the
    given token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet will create an alias of the `Http` token to the `DummyHttp`
    token. This means that once the `Http` token is requested, the call will be forwarded
    to the provider associated with the `DummyHttp` token, which will be resolved
    to the value of `dummyHttp`.
  prefs: []
  type: TYPE_NORMAL
- en: The `useValue` provider returns the value set to the `useValue` property of
    the provider's declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Defining factories for instantiating services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's suppose that we want to create a complex object, for example, one
    that represents a **Transport Layer Security** (**TLS**) connection. A few of
    the properties of such an object are a socket, a set of crypto protocols, and
    a certificate. In the context of this problem, the features of the DI mechanism
    of Angular we have looked at so far might seem a bit limited.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we might need to configure some of the properties of the `TLSConnection`
    class without coupling the process of its instantiation with all the configuration
    details (choose appropriate crypto algorithms, open the TCP socket over which
    we will establish the secure connection, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we can take advantage of the `useFactory` property of the provider''s
    configuration object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet seems a bit complex at first, but let''s take a look
    at it step by step. We can start with the parts we''re already familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, we register a number of providers: `Buffer`, `Socket`, `Certificate`,
    and `Crypto`. Just like in the previous example, we also register the `BUFFER_SIZE`
    token and associated it with the value `42`. This means that we can already inject
    dependencies of the `Buffer`, `Socket`, `Certificate`, and `Crypto` types in the
    constructors of the classes in our application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create and configure an instance of the `TLSConnection` object in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, in order to allow Angular to use the previous snippet for the instantiation
    of `TLSConnection`, we can use the `useFactory` property of the provider's configuration
    object. This way, we can specify a function in which we can manually create the
    instance of the object associated with the provider's token.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `useFactory` property together with the `deps` property in order
    to specify the dependencies to be passed to the factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we define the factory function used for the instantiation
    of `TLSConnection`. As dependencies, we declare `Socket`, `Certificate`, and `Crypto`.
    These dependencies are resolved by the DI mechanism of Angular and injected into
    the factory function. You can take a look at the entire implementation and play
    with it at `ch6/configuring-providers/factory/app.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Interesting to note is that, internally, Angular translates the `useClass` providers
    to `useFactory`. Angular lists the dependencies of the class in the `deps` array
    and invokes the class with the `new` operator, passing its dependencies received
    as arguments of the factory.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring optional dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular introduced the `@Optional` decorator, which allows us to deal with dependencies
    that don't have a registered provider associated with them. Let's suppose that
    a dependency of a provider is not available in any of the target injectors responsible
    for its instantiation. If we use the `@Optional` decorator, during the instantiation
    of the dependent provider a value of the missing dependency will be passed asÂ `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we define an abstract class called `SortingAlgorithm` and a class
    called `Collection`, which as dependency accepts an instance of a concrete class
    that extends `SortingAlgorithm`. Inside the `Collection` constructor, we set the
    `sort` instance property to the passed dependency or to a default sorting algorithm
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We didn't define any providers for the `SortingAlgorithm` token in the providers
    of `@NgModule` we declared. So, if we want to inject an instance of the `Collection`
    class in the `AppComponent`, we'll get a runtime error. This means that if we
    want to get an instance of the `Collection` class using the DI mechanism of the
    framework, we must register a provider for the `SortingAlgorithm` token, although
    we may want to fall back to a default sorting algorithm, returned by the `getDefaultSort`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular provides a solution to this problem with the `@Optional` decorator.
    This is how we can approach the problem using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we declare the `sort` dependency as optional, which
    means that if Angular doesn't find any provider for its token, it will pass the
    `null` value.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding multiproviders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multiproviders is another new concept introduced to the DI mechanism of Angular.
    They allow us to associate multiple providers with the same token. This can be
    quite useful if we're developing a third-party library that comes with some default
    implementations of different services, but you want to allow the users to extend
    it with custom ones. For instance, in the Angular's form module, multiproviders
    are exclusively used to declare multiple validations over a single control. We
    will explain this module in [Chapter 7](0880a64a-a64d-41a9-9ffd-7b2d55270110.xhtml),
    *Working with the Angular Router and Forms*, and [Chapter 8](503e1c1c-afb1-4dd4-98e2-657ceb32cc59.xhtml),
    *Explaining Pipes and Communicating with RESTful Services*.
  prefs: []
  type: TYPE_NORMAL
- en: Another sample of an applicable use case of multiproviders is what Angular uses
    for event management in its web workers implementation. Users create multiproviders
    for event management plugins. Each of the providers return a different strategy,
    which supports a different set of events (touch events, keyboard events, and so
    on). Once a given event occurs, Angular can choose the appropriate plugin that
    handles it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example that illustrates a typical usage of multiproviders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we declare a constant called `VALIDATOR` and as its
    value, we set a new instance of `InjectionToken`. We also create `@NgModule` where
    we register three providers: two of them provide functions that, based on different
    criteria, validate instances of the `Employee` class. These functions are of the
    `EmployeeValidator` type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to declare that we want the injector to pass all the registered validators
    to the constructor of the `Employee` class, we need to use the following `constructor`
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example, we declare a `Employee` class that accepts a single dependency:
    an array of `EmployeeValidator`. In the `validate` method, we apply the individual
    validators over the current class instance and filter the results in order to
    get only the ones that have returned an error message.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `validators` constructor argument is of the `EmployeeValidator[]`
    type. Since we can't use the *array of objects* type as a token for a provider,
    because it is not a valid value in JavaScript and can't be used as a token, we
    will need to use the `@Inject` parameter decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, we can inject an instance of the `Employee` type as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Child injectors and visibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a look at how we can build a hierarchy of injectors.
    There's no alternative to this concept in AngularJS. Each injector can have either
    zero or one parent injectors, and each parent injector can have one or more children.
    In contrast to AngularJS, where all the registered providers are stored in a flat
    structure, in Angular they are stored in a tree. The flat structure is more limited;
    for instance, it doesn't support the namespacing of tokens; we cannot declare
    different providers for the same token. So far, we looked at an example of an
    injector that doesn't have any children or a parent. Now, let's build a hierarchy
    of injectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to gain a better understanding of this hierarchical structure of injectors,
    let''s take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/863d4bb1-1b86-4fa5-b44d-798f056b7c93.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we see a tree where each node is an injector, and each of these injectors
    keeps a reference to its parent. The `House` injector has three child injectors:
    `Bathroom`, `Kitchen`, and `Garage`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Garage` has two child injectors: `Car` and `Storage`. We can think of these
    injectors as containers with registered providers inside of them.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose that we want to get the value of the provider associated with
    the `Tire` token. If we use the `Car` injector, this means that Angular's DI mechanism
    will try to find the provider associated with this token in `Car` and all of its
    parents, `Garage` and `House`, until it reaches the root injector.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating an injector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Internally, Angular builds this hierarchy of injectors, but everything happens
    implicitly. In order to do this ourselves, we'll have to use lower level APIs
    which will be unusual for our day-to-day development process.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create an instance of an injector, in order to use it for the
    instantiation of registered tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, first we import `Injector` from `@angular/core`. This abstraction has
    a static method called `create`, which is used for instantiation of injectors.
    Inside of the `create` method, we pass as argument an array of providers. We can
    see syntax that we're already familiar with from the *Configuring providers* section.
  prefs: []
  type: TYPE_NORMAL
- en: We declare a provider for `BUFFER_SIZE` to use the value `42`; we declare a
    factory for `Buffer` and list all of its dependencies (in this case, only `BUFFER_SIZE`);
    finally, we declare a factory provider for `Socket` as well. The `create` method
    is going to create an instance of `StaticInjector`, which we can use to get instances
    for the individual `tokens`. As a reminder, the **injector** is the abstraction
    which contains the individual providers and knows how to instantiate the dependencies
    associated with them.
  prefs: []
  type: TYPE_NORMAL
- en: An important detail in the preceding example is that in `StaticInjector`, we
    can use only a limited types of providers, for instance, we can't use the `useClass`
    provider. This is due to the fact that Angular uses `StaticInjector` with the
    normalized version of the providers, and the normalized version of `useClass`
    is `useFactory`. Internally, Angular will collect the providers passed to `@NgModule`,
    transform them to their normalized version, and instantiate `StaticInjector`.
  prefs: []
  type: TYPE_NORMAL
- en: Building a hierarchy of injectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to gain a better understanding of the paragraph, let''s take a look
    at this simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The imports are omitted since they are not essential to explaining the code.
    We have two services, `Http` and `UserService`, where `UserService` depends on
    the `Http` service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, we create an injector using the `create` static method of the `Injector`
    class. We pass a factory provider to this injector, with an `Http` token. Later,
    again using `create`, we instantiate the child injector by passing an array that
    contains the provider for `UserService`. Notice that as second argument, we pass
    the `parentInjector` constant, so, we get the same relation as the one between
    `Garage` and `House`, shown in the previous diagram: `parentInjector` is the parent
    of `childInjector`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, using `childInjector.get(UserService)`, we are able to get the value associated
    with the `UserService` token. Similarly, using `childInjector.get(Http)` and `parentInjector.get(Http)`,
    we get the same value associated with the `Http` token. This means that `childInjector`
    asks its parent for the value associated with the requested token.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we try to use `parentInjector.get(UserService)`, we won't be able
    to get the value associated with the token since its provider is registered in
    `childInjector`.
  prefs: []
  type: TYPE_NORMAL
- en: Using dependency injection with components and directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 5](1b60c28e-5f34-493d-8371-c69968f09020.xhtml), *Getting Started
    with Angular Components and Directives*, when we developed our first Angular directive,
    we saw how we can take advantage of the DI mechanism to inject services into our
    UI-related building blocks (that is, directives and components).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at what we did earlier, but from a DI perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Most of the code from the earlier implementation is omitted because it is not
    directly related to our current focus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the constructor of `Tooltip` accepts two dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: An instance of the `ElementRef` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An instance of the `Overlay` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The types of dependencies are the tokens associated with their providers and
    the corresponding values obtained from the providers will be injected with the
    DI mechanism of Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'The declaration of the dependencies of the `Tooltip` class looks exactly the
    same as what we did in the previous sections: we''re just listing them as parameters
    of the constructor of the class. However, note that in this case, we don''t have
    any explicit provider declaration for the `ElementRef` token, we only have a provider
    for the `Overlay` token, declared within the metadata of the `App` component.
    In this case, Angular internally creates and configures the so called **element
    injector**.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the element injectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Under the hood, Angular will create injectors for all the directives and components,
    and add a default set of providers to them. These are the so called **element
    injectors** and are something the framework takes care of itself. The injectors
    associated with the components are called **host injectors**. One of the providers
    in each element injector is associated with the `ElementRef` token; it will return
    a reference to the host element of the directive. But what about the provider
    for the `Overlay` class? Let''s take a look at the implementation of the top-level
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We configure the element injector for the `App` component by declaring the `providers`
    property inside the `@Component` decorator. At this point, the registered providers
    will be visible by the directive or the component associated with the corresponding
    element injector and the component's entire component subtree, unless they are
    overridden somewhere in the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring providers for the element injectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having the declaration of all the providers in the same place might be quite
    inconvenient. For example, imagine we're developing a large-scale application
    that has hundreds of components depending on thousands of services. In this case,
    configuring all the providers in the root component is not a practical solution.
    There will be name collisions when two or more providers are associated with the
    same token. The configuration will be huge, and it will be hard to trace where
    the different dependencies need to be injected.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned, Angular''s `@Directive` (and `@Component`) decorator allows
    us to declare a set of providers for the element injector corresponding to a given
    directive using the `providers` property. Here is how we can approach this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example overrides the provider for the `Overlay` token in the
    declaration of the `Tooltip` directive. This way, Angular will inject an instance
    of `OverlayMock` instead of `Overlay` during the instantiation of the tooltip.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring dependency injection with components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since components are generally directives with templates, everything we've seen
    so far regarding how the DI mechanism works with directives is valid for components
    as well. However, because of the extra features that the components provide, we're
    allowed to have further control over their providers.
  prefs: []
  type: TYPE_NORMAL
- en: As we said, the injector associated with each component will be marked as a
    **host** injector. There's a parameter decorator called `@Host`, which allows
    us to retrieve a given dependency from any injector until it reaches the closest
    host injector. This means that, using the `@Host` decorator in a directive, we
    can declare that we want to retrieve the given dependency from the current injector
    or any parent injector until we reach the injector of the closest parent component.
  prefs: []
  type: TYPE_NORMAL
- en: On top of that, the Angular's API allows us to be even more specific regarding
    the visibility of the providers in the component tree using the `viewProviders`
    property, part of the configuration object of the `@Component` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: View providers versus providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of a component called `MarkdownPanel`. This
    component will be used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of each section of the panel will be translated from markdown to
    HTML. We can delegate this functionality to a service called `Markdown`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `Markdown` service wraps the `markdown` module in order to make it injectable
    through the DI mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's implement `MarkdownPanel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, we can find all the important details from the implementation
    of the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `@Component` decorator, we use the `markdown-panel` selector and set
    the `viewProviders` property. In this case, there''s only a single view provider:
    the one for the `Markdown` service. By setting this property, we declare that
    all the providers declared in it will be accessible from the component itself
    and all of its **view children**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s suppose we have a component called `MarkdownButton`, and we want
    to add it to our template in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Markdown` service will not be accessible by `MarkdownButton` used below
    the `panel-content` element; however, it''ll be accessible if we use the button
    in the template of the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If we need the provider to be visible in all the content and view children,
    all we should do is change the name of the `viewProviders` property to `providers`.
  prefs: []
  type: TYPE_NORMAL
- en: You can find this example in the examples directory at `ch6/directives/app.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, for any component or directive, we can override an existing provider
    declared in `@NgModule` using the `providers` properties of the object literal
    we pass to the `@Component` or `@Directive` decorators. If we want to override
    a specific provider only for the view children of a given component, we can use
    `viewProviders`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the @SkipSelf decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are cases when in an hierarchy, we have defined providers for the same
    token in different injectors. For instance, let''s suppose that we have the preceding
    example, but with the following injector configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, in case we try to inject the `Markdown` service in
    the constructor of `MarkdownPanel`, we'll get `null`, because that's the value
    associated with the `Markdown` token in the `viewProviders` declaration in the
    metadata of the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, notice that in the `App` component, we have another declaration of
    providers, which will be used for the instantiation of `ElementInjector` of the
    `App` component. How can we use the `Markdown` provider declared in the metadata
    of `App` instead of the one declared in the metadata of `MarkdownPanel`? All we
    need to do is to add the `@SkipSelf()` decorator in the constructor of `MarkdownPanel`.
    This will hint Angular to skip the current injector and instead, look for the
    provider associated with the required token in the parent injector and above in
    the hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Angular also provides the `@Self` decorator, which hints the framework to get
    the provider for a given token from the current injector. In that case, if Angular
    doesn't find the provider in the current injector, it'll throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the DI mechanism of Angular. We briefly discussed
    the positives of using DI in our projects by introducing it in the context of
    the framework. The second step in our journey was how to configure injectors using
    `@NgModule`; we also explained the hierarchy of injectors and the visibility of
    the registered providers. In order to enforce a better separation of concerns,
    we mentioned how we can inject services carrying the business logic of our application
    in our directives and components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll introduce the new routing mechanism of the framework.
    We'll explain how we can configure the component-based router and add multiple
    views to our application. Another important topic we will cover is the new form
    module. By building a simple application, we will demonstrate how we can create
    and manage forms.
  prefs: []
  type: TYPE_NORMAL
