<html><head></head><body>
<div id="_idContainer016">
<h1 class="chapter-number" id="_idParaDest-33"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-34"><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.2.1">Powerful Angular Features</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Angular has built-in tools for everything you need to build robust web applications. </span><span class="koboSpan" id="kobo.3.2">In this chapter, you will learn about the newest and most powerful features in the Angular framework. </span><span class="koboSpan" id="kobo.3.3">We will also dive into Angular component communication, the router, and arguably the most important and powerful part of the Angular framework: dependency injection. </span><span class="koboSpan" id="kobo.3.4">By the end of this chapter, you will know how to inject, consume, provide, and adjust the hierarchy of dependencies, how to communicate between components, and how to effectively use the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">Angular router.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">This chapter will cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">What makes Angular </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">so powerful?</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">New features in the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Angular framework</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">A deep dive into the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">Angular router</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.13.1">Component communication</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.14.1">Dependency injection</span></span></li>
</ul>
<h1 id="_idParaDest-35"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.15.1">What makes Angular so powerful?</span></h1>
<p><span class="koboSpan" id="kobo.16.1">Angular sets itself apart</span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.17.1"> from other popular frontend frameworks and libraries such as ReactJS and VueJS because it is strongly opinionated and has everything you need to develop complex web applications embedded in the </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">framework itself.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">Using Angular effectively ensures that there is a certain level of consistency and that best practices are implemented. </span><span class="koboSpan" id="kobo.19.2">This is because Angular makes many decisions</span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.20.1"> for you, such as using TypeScript and relying on </span><strong class="bold"><span class="koboSpan" id="kobo.21.1">object-oriented programming</span></strong><span class="koboSpan" id="kobo.22.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.23.1">OOP</span></strong><span class="koboSpan" id="kobo.24.1">) principles and built-in tools to handle common problems such as routing, HTTP requests, and testing! </span><span class="koboSpan" id="kobo.24.2">Because Angular has everything built into it, you donâ€™t need to bring in a lot of external packages, reducing the surface for potential exploits or packages that stop being maintained. </span><span class="koboSpan" id="kobo.24.3">These aspects often make Angular the framework of choice when building complex frontend systems or enterprise software composed of </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">multiple applications.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">Angular comes packed with powerful and useful features for building web applications. </span><span class="koboSpan" id="kobo.26.2">If you are reading this book, you should already be familiar with the main features, but we will still mention the ones that are most essential to </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">the framework:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.28.1">Components and services</span></strong><span class="koboSpan" id="kobo.29.1">: Components and services</span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.30.1"> are the building blocks of Angular applications. </span><span class="koboSpan" id="kobo.30.2">Components are used to develop reusable UI elements and pages comprised of these UI elements. </span><span class="koboSpan" id="kobo.30.3">Angular services are injected throughout your applications using dependency injection and communicate with backend APIs, handle state management, provide data, and implement </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">business logic.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.32.1">Dependency injection</span></strong><span class="koboSpan" id="kobo.33.1">: Angular dependency injection is one</span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.34.1"> of the fundamental concepts of the framework and is often regarded as its most powerful feature. </span><span class="koboSpan" id="kobo.34.2">Dependency injection allows you to inject values and logic throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">your applications.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.36.1">Signals</span></strong><span class="koboSpan" id="kobo.37.1">: Signals are a new concept within the Angular framework</span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.38.1"> that is used to define stateful properties. </span><span class="koboSpan" id="kobo.38.2">Angular tracks where and how the Signal values are used to optimize change detection, resulting in improved performance. </span><span class="koboSpan" id="kobo.38.3">Signals are also reactive, allowing you to automatically react when a Signal </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">value changes.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.40.1">HTTP client</span></strong><span class="koboSpan" id="kobo.41.1">: The built-in HTTP client</span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.42.1"> provides an elegant and intuitive interface for communicating with APIs and fetching data. </span><span class="koboSpan" id="kobo.42.2">With built-in features such as request and response interceptors, error handling, and observable-based responses, the Angular HTTP client is everything you need for handling </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">HTTP logic.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.44.1">Data binding</span></strong><span class="koboSpan" id="kobo.45.1">: Angular data binding enables real-time</span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.46.1"> synchronization between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">component</span></strong><span class="koboSpan" id="kobo.48.1"> class and its corresponding template, facilitating data updates without manual intervention. </span><span class="koboSpan" id="kobo.48.2">In the Angular framework, data binding can be done in three ways: from the component class to the view by using the square bracket notation, from the view to the component class with events and the round bracket notation, and two-way data binding with the square </span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.49.1">and round bracket </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.50.1">notation, also known </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">as banana-in-a-box.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.52.1">Router</span></strong><span class="koboSpan" id="kobo.53.1">: The Angular Router facilitates</span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.54.1"> the creation of single-page applications with dynamic routing capabilities. </span><span class="koboSpan" id="kobo.54.2">It enables developers to define routes and associate them with specific components, allowing seamless navigation between different views and pages within </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">the application.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.56.1">Directives</span></strong><span class="koboSpan" id="kobo.57.1">: Angular directives are an essential building</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.58.1"> block of the framework and allow you to extend HTML elements with additional functionality and behavior or add and remove </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">DOM elements.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.60.1">Pipes</span></strong><span class="koboSpan" id="kobo.61.1">: Pipes are used for transforming</span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.62.1"> and formatting data within HTML templates. </span><span class="koboSpan" id="kobo.62.2">Using pipes helps to maintain clean and concise templates while avoiding excessive logic in the </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">component code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.64.1">Forms</span></strong><span class="koboSpan" id="kobo.65.1">: Forms are at the heart </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.66.1">of each web application. </span><span class="koboSpan" id="kobo.66.2">Angular forms</span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.67.1"> come in two types: </span><strong class="bold"><span class="koboSpan" id="kobo.68.1">template-driven forms</span></strong><span class="koboSpan" id="kobo.69.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.70.1">reactive forms</span></strong><span class="koboSpan" id="kobo.71.1">. </span><span class="koboSpan" id="kobo.71.2">With features such</span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.72.1"> as validation, error handling, and data synchronization, forms help you to develop </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">robust applications.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.74.1">These features are just some of the most powerful features the framework offers. </span><span class="koboSpan" id="kobo.74.2">Letâ€™s move on and explore what the Angular team changed in the latest versions. </span><span class="koboSpan" id="kobo.74.3">The framework is changing rapidly, and new concepts and tools are being introduced to make Angular even more powerful </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">and future-proof.</span></span></p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.76.1">New features in the Angular framework</span></h1>
<p><span class="koboSpan" id="kobo.77.1">The world of web development is evolving rapidly, and because of that, frameworks such as Angular have to keep growing to stay relevant. </span><span class="koboSpan" id="kobo.77.2">In this section, we will explore whatâ€™s new in the Angular framework and why these changes are </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">being made.</span></span></p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.79.1">Standalone components</span></h2>
<p><span class="koboSpan" id="kobo.80.1">In Angular version 14, </span><strong class="bold"><span class="koboSpan" id="kobo.81.1">standalone components</span></strong><span class="koboSpan" id="kobo.82.1"> were introduced as a </span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.83.1">developerâ€™s preview; version</span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.84.1"> 15 released them for production usage. </span><span class="koboSpan" id="kobo.84.2">The Angular team introduced standalone components to simplify how we build Angular applications. </span><span class="koboSpan" id="kobo.84.3">Before standalone components, everything had to be declared in ngModules. </span><span class="koboSpan" id="kobo.84.4">Many developers dislike ngModules, and errors related to ngModules can be hard </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">to resolve.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">With standalone components, you can build applications without ngModules. </span><span class="koboSpan" id="kobo.86.2">Components, directives, and pipes can be marked as standalone, and then they donâ€™t have to be declared in </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">an ngModule.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">In </span><a href="B21625_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.89.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.90.1">, we made Nx generators for libraries and applications and applied the standalone flag for both. </span><span class="koboSpan" id="kobo.90.2">Because of that, when we generated our Angular applications, they were created with standalone components. </span><span class="koboSpan" id="kobo.90.3">Letâ€™s look at the decorator from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">app.component.ts</span></strong><span class="koboSpan" id="kobo.92.1"> file in your </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">expenses-registration</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.94.1"> application:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.95.1">
@Component({
Â Â </span><strong class="bold"><span class="koboSpan" id="kobo.96.1">standalone</span></strong><span class="koboSpan" id="kobo.97.1">: true,
Â Â </span><strong class="bold"><span class="koboSpan" id="kobo.98.1">imports</span></strong><span class="koboSpan" id="kobo.99.1">: [RouterModule], â€¦â€¦â€¦
})</span></pre> <p><span class="koboSpan" id="kobo.100.1">If you compare this to a non-standalone component, you might</span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.101.1"> notice two things</span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.102.1"> that are out of the ordinary: the </span><strong class="bold"><span class="koboSpan" id="kobo.103.1">standalone</span></strong><span class="koboSpan" id="kobo.104.1"> flag and the </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">imports</span></strong><span class="koboSpan" id="kobo.106.1"> array. </span><span class="koboSpan" id="kobo.106.2">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">standalone</span></strong><span class="koboSpan" id="kobo.108.1"> flag is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">true</span></strong><span class="koboSpan" id="kobo.110.1">, the component becomes standalone. </span><span class="koboSpan" id="kobo.110.2">When something is standalone, it must import all its dependencies directly in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">imports</span></strong><span class="koboSpan" id="kobo.112.1"> array instead of getting dependencies from an ngModule. </span><span class="koboSpan" id="kobo.112.2">For example, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">app.component.html</span></strong><span class="koboSpan" id="kobo.114.1">, we use the router outlet in the template, and because of that, the component needs to import </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">RouterModule</span></strong><span class="koboSpan" id="kobo.116.1">; you can also only import </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">RouterOutlet</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.118.1"> instead.</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">You can also create applications without any ngModules. </span><span class="koboSpan" id="kobo.119.2">To do this, bootstrap the application with a standalone component instead of an ngModule. </span><span class="koboSpan" id="kobo.119.3">We need to look at our </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">main.ts</span></strong><span class="koboSpan" id="kobo.121.1"> file to see how this is done. </span><span class="koboSpan" id="kobo.121.2">In an application that uses ngModules, you will find something like this in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">main.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.123.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.124.1">
platformBrowserDynamic().bootstrapModule(AppModule).catch()</span></pre> <p><span class="koboSpan" id="kobo.125.1">In this scenario, the Angular application bootstraps with the AppModule, the root ngModule. </span><span class="koboSpan" id="kobo.125.2">When you want to work without ngModules, you can change this and bootstrap with your root standalone component instead. </span><span class="koboSpan" id="kobo.125.3">If you look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">main.ts</span></strong><span class="koboSpan" id="kobo.127.1"> file of your </span><em class="italic"><span class="koboSpan" id="kobo.128.1">expenses-registration application</span></em><span class="koboSpan" id="kobo.129.1">, you will find </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.131.1">
bootstrapApplication(AppComponent, appConfig).catch(â€¦â€¦);</span></pre> <p><span class="koboSpan" id="kobo.132.1">As you can see, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">bootstrapApplication</span></strong><span class="koboSpan" id="kobo.134.1"> function instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">bootstrapModule</span></strong><span class="koboSpan" id="kobo.136.1">. </span><span class="koboSpan" id="kobo.136.2">We provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">bootstrapApplication</span></strong><span class="koboSpan" id="kobo.138.1"> function with a standalone component and a configuration object. </span><span class="koboSpan" id="kobo.138.2">This configuration object configures things such as routing, the HTTP client, and third-party modules. </span><span class="koboSpan" id="kobo.138.3">We will come back to this configuration object a couple of times. </span><span class="koboSpan" id="kobo.138.4">For now, remember you can configure application settings here when bootstrapping with a </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">standalone component.</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">You can also mix ngModules with standalone components. </span><span class="koboSpan" id="kobo.140.2">If you have an application that already uses ngModules, you can start</span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.141.1"> using standalone components alongside your existing code and leave</span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.142.1"> your </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">modules as-is.</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">Now that you understand the basics of standalone components and how to use them, letâ€™s explore the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">inject</span></strong><span class="koboSpan" id="kobo.146.1"> function for </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">dependency injection.</span></span></p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.148.1">Dependency injection using the inject function</span></h2>
<p><span class="koboSpan" id="kobo.149.1">Another cool feature</span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.150.1"> that was introduced</span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.151.1"> in Angular 14 is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">inject</span></strong><span class="koboSpan" id="kobo.153.1"> function, which is used</span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.154.1"> as an alternative for constructor dependency injection. </span><span class="koboSpan" id="kobo.154.2">Up until now, constructor dependency injection was the only way to inject dependencies into your </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">Angular applications:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.156.1">
constructor(private userService: UserService) {}</span></pre> <p><span class="koboSpan" id="kobo.157.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">inject</span></strong><span class="koboSpan" id="kobo.159.1"> function, we have an alternative approach that looks </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.161.1">
private userService = </span><strong class="bold"><span class="koboSpan" id="kobo.162.1">inject</span></strong><span class="koboSpan" id="kobo.163.1">(UserService);</span></pre> <p><span class="koboSpan" id="kobo.164.1">When we reach the </span><em class="italic"><span class="koboSpan" id="kobo.165.1">Dependency injection</span></em><span class="koboSpan" id="kobo.166.1"> section, we will dive deeper into this new syntax. </span><span class="koboSpan" id="kobo.166.2">For now, we will move on to the next new feature: </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">directive composition.</span></span></p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.168.1">Directive composition</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.169.1">Directive composition</span></strong><span class="koboSpan" id="kobo.170.1"> was a much-requested feature by the Angular</span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.171.1"> community and was added</span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.172.1"> to the framework in version 15. </span><span class="koboSpan" id="kobo.172.2">With directive composition, you can apply directives to components by configuring them in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">component</span></strong><span class="koboSpan" id="kobo.174.1"> decorator. </span><span class="koboSpan" id="kobo.174.2">Each time you use the component in a template, the configured directives will be applied automatically without adding the directive to the HTML element. </span><span class="koboSpan" id="kobo.174.3">You can also use directive composition inside other directives, resulting in a directive that applies multiple directives. </span><span class="koboSpan" id="kobo.174.4">In </span><a href="B21625_03.xhtml#_idTextAnchor058"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.175.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.176.1">, we will dive deeper into the topic of </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">directive composition.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">For now, you just need to know that you can configure directives inside the component decorators to share common behavior and reduce template complexity. </span><span class="koboSpan" id="kobo.178.2">Now that you know about directive composition, letâ€™s explore Angular Signals </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">a bit.</span></span></p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.180.1">Angular Signals</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.181.1">Angular Signals</span></strong><span class="koboSpan" id="kobo.182.1"> were introduced in Angular 16, and itâ€™s one of the most</span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.183.1"> significant changes for the framework since it went from AngularJS to Angular. </span><span class="koboSpan" id="kobo.183.2">In Angular 17, the framework also introduced Signal component inputs, and query Signals to query template elements using Signals. </span><span class="koboSpan" id="kobo.183.3">With </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.184.1">Signals, we have a </span><strong class="bold"><span class="koboSpan" id="kobo.185.1">reactive primitive</span></strong><span class="koboSpan" id="kobo.186.1"> in the Angular framework with which we can manage the </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">application state.</span></span></p>
<p><span class="koboSpan" id="kobo.188.1">Signals allow you to declare, compute, mutate, and consume values reactively, meaning the Signal will automatically notify all consumers when the Signalâ€™s value changes. </span><span class="koboSpan" id="kobo.188.2">Because Signals are reactive, you can automatically react when a Signalâ€™s value changes, performing logic or updating other values when a Signal is set with a new value. </span><span class="koboSpan" id="kobo.188.3">Signals wrap around values and expose them through a getter, which allows the Angular framework to track who is consuming the Signal and notify the consumers when the value changes. </span><span class="koboSpan" id="kobo.188.4">Signals can wrap around simple values or complex data structures and can be writable or read-only. </span><span class="koboSpan" id="kobo.188.5">Hereâ€™s a straightforward example of a Signal and a computed </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">Signal value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.190.1">
@Component({ â€¦â€¦â€¦ , template: `
Â Â Â Â &lt;div&gt;Count: {{count()}}&lt;/div&gt;
Â Â Â Â &lt;div&gt;Double: {{double()}}&lt;/div&gt;`
})
export class AppComponent {
Â Â count = signal(10);
Â Â double = computed(() =&gt; this.count() * 2);
}</span></pre> <p><span class="koboSpan" id="kobo.191.1">In the preceding example, we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">count</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.193.1">signal</span></strong><span class="koboSpan" id="kobo.194.1"> value and a computed Signal that doubles the count. </span><span class="koboSpan" id="kobo.194.2">The computed Signal will automatically compute a new value when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">count</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.196.1">signal</span></strong><span class="koboSpan" id="kobo.197.1"> value changes. </span><span class="koboSpan" id="kobo.197.2">To better explain the advantages of Signals, letâ€™s define what a reactive primitive is. </span><span class="koboSpan" id="kobo.197.3">In JavaScript, you have primitive and non-primitive values. </span><span class="koboSpan" id="kobo.197.4">The JavaScript primitives are </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">string</span></strong><span class="koboSpan" id="kobo.199.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">number</span></strong><span class="koboSpan" id="kobo.201.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">bigint</span></strong><span class="koboSpan" id="kobo.203.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">boolean</span></strong><span class="koboSpan" id="kobo.205.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">symbol</span></strong><span class="koboSpan" id="kobo.207.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">null</span></strong><span class="koboSpan" id="kobo.209.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">undefined</span></strong><span class="koboSpan" id="kobo.211.1">. </span><span class="koboSpan" id="kobo.211.2">The non-primitives </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">are objects.</span></span></p>
<p><span class="koboSpan" id="kobo.213.1">JavaScript non-primitives</span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.214.1"> are reference types, meaning that if you assign them to a new variable, you donâ€™t create a new object but make a reference to the existing object. </span><span class="koboSpan" id="kobo.214.2">Primitives donâ€™t work like that; if you assign a string to a new variable, it doesnâ€™t hold a reference to the original variable but it does create a new string. </span><span class="koboSpan" id="kobo.214.3">Primitives are immutable, and non-primitives are mutable. </span><span class="koboSpan" id="kobo.214.4">This means you can change a non-primitive after itâ€™s created. </span><span class="koboSpan" id="kobo.214.5">If you reassign a string, itâ€™s a new string and not the same string with a different value. </span><span class="koboSpan" id="kobo.214.6">When you adjust an object, it remains the same object, only with </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">different values.</span></span></p>
<p><span class="koboSpan" id="kobo.216.1">A reactive primitive</span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.217.1"> is an immutable value that alerts consumers when itâ€™s set with a new value. </span><span class="koboSpan" id="kobo.217.2">All consumers can automatically track and react to changes in this </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">reactive primitive.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.219.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.220.1">The Signal</span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.221.1"> itself is a reactive primitive and is immutable. </span><span class="koboSpan" id="kobo.221.2">You can only update the Signal and notify consumers of the Signal by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">set()</span></strong><span class="koboSpan" id="kobo.223.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">update()</span></strong><span class="koboSpan" id="kobo.225.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">on it.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.227.1">Yet, the value held by the Signal is not immutable! </span><span class="koboSpan" id="kobo.227.2">So, if you use a non-primitive (an object or array) as a Signal value, you can still mutate the value without updating the </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">Signal itself.</span></span></p>
<p><span class="koboSpan" id="kobo.229.1">Because Signals are reactive</span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.230.1"> primitives, the Angular framework can better detect changes and optimize change detection and rendering, resulting in better performance. </span><span class="koboSpan" id="kobo.230.2">Signals are the first step to an Angular version with fully fine-grained change detection that doesnâ€™t need </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">Zone.js</span></strong><span class="koboSpan" id="kobo.232.1"> to detect changes based on browser events. </span><span class="koboSpan" id="kobo.232.2">At the time of writing, Angular assumes that any triggered browser event handler can change any data bound to a template. </span><span class="koboSpan" id="kobo.232.3">Because of that, each time a browser event is triggered, Angular checks the entire component tree for changes because it canâ€™t detect them in a fine-grained manner. </span><span class="koboSpan" id="kobo.232.4">This is a significant drain on resources and impacts </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">performance negatively.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">In </span><a href="B21625_07.xhtml#_idTextAnchor129"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.235.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.236.1">, we will dive deeper into Signals and look at different implementations and how you can combine them with RxJS. </span><span class="koboSpan" id="kobo.236.2">For now, you just need to know that Signals can be used to manage application state and that they introduce a reactive primitive, which can significantly improve the reactivity</span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.237.1"> and performance of your </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">Angular applications.</span></span></p>
<p><span class="koboSpan" id="kobo.239.1">Now that you know what Signals are and why they are important, letâ€™s learn about the new Angular control </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">flow system.</span></span></p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.241.1">Angular control flow</span></h2>
<p><span class="koboSpan" id="kobo.242.1">The control flow system </span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.243.1">was introduced in Angular 17 and provides a new mechanism to show, hide, and repeat elements inside HTML templates. </span><span class="koboSpan" id="kobo.243.2">Until Angular 17, you could only use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">*ngIf</span></strong><span class="koboSpan" id="kobo.245.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">*ngFor</span></strong><span class="koboSpan" id="kobo.247.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">*ngSwitch</span></strong><span class="koboSpan" id="kobo.249.1"> directives to show, hide, or repeat elements inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">HTML templates.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">As of Angular 17, you can use both the directives and the new control flow system interchangeably. </span><span class="koboSpan" id="kobo.251.2">Letâ€™s look at an example for each option using the new control flow syntax, starting with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">@if</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.253.1">control flow:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.254.1">
@if (a &gt; b) {
Â Â {{a}} is greater than {{b}}
} @else if (b &gt; a) {
Â Â {{a}} is less than {{b}}
} @else {
Â Â {{a}} is equal to {{b}}
}</span></pre> <p><span class="koboSpan" id="kobo.255.1">As you can see, the new control flow syntax uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">@if</span></strong><span class="koboSpan" id="kobo.257.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">@else if</span></strong><span class="koboSpan" id="kobo.259.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">@else</span></strong><span class="koboSpan" id="kobo.261.1"> to define </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">if</span></strong><span class="koboSpan" id="kobo.263.1">-</span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">else</span></strong><span class="koboSpan" id="kobo.265.1"> statements inside your HTML templates. </span><span class="koboSpan" id="kobo.265.2">The new control flow syntax makes it a lot easier to create </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">if</span></strong><span class="koboSpan" id="kobo.267.1">-</span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">else</span></strong><span class="koboSpan" id="kobo.269.1"> statements. </span><span class="koboSpan" id="kobo.269.2">You can use both the control flow and the directive syntax, so pick whichever you and your team prefer. </span><span class="koboSpan" id="kobo.269.3">Now that youâ€™ve seen an example of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">@if</span></strong><span class="koboSpan" id="kobo.271.1"> control flow, letâ€™s see how you can repeat elements inside the template using the new control </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">flow syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.273.1">
@for (item of items; track item.id) {
Â Â &lt;li&gt; {{ item.name }}&lt;/li&gt;
} @empty {
Â Â &lt;li&gt; There are no items.&lt;/li&gt;
}</span></pre> <p><span class="koboSpan" id="kobo.274.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">@for</span></strong><span class="koboSpan" id="kobo.276.1"> syntax can be used interchangeably </span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.277.1">with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">*ngFor</span></strong><span class="koboSpan" id="kobo.279.1"> directive. </span><span class="koboSpan" id="kobo.279.2">The new control flow syntax requires you to define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">track</span></strong><span class="koboSpan" id="kobo.281.1"> property. </span><span class="koboSpan" id="kobo.281.2">You assign the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">track</span></strong><span class="koboSpan" id="kobo.283.1"> property with a unique identifier such as an ID, which allows Angular to only re-render changed items when the list you are rendering changes. </span><span class="koboSpan" id="kobo.283.2">You can also provide an </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">@empty</span></strong><span class="koboSpan" id="kobo.285.1"> block to display something when the array provided to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">@for</span></strong><span class="koboSpan" id="kobo.287.1"> block is empty. </span><span class="koboSpan" id="kobo.287.2">Now that you know how to repeat elements inside your template with the new control flow syntax, letâ€™s learn about the alternative for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">*</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">ngSwitch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.290.1"> directive:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.291.1">
@switch (condition) {
Â Â @case (caseA) { Case A. </span><span class="koboSpan" id="kobo.291.2">}
Â Â @case (caseB) { Case B. </span><span class="koboSpan" id="kobo.291.3">}
Â Â @default { Default case. </span><span class="koboSpan" id="kobo.291.4">}
}</span></pre> <p><span class="koboSpan" id="kobo.292.1">Just as with the other control flow blocks, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">@switch</span></strong><span class="koboSpan" id="kobo.294.1"> block interchangeably with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">*ngSwitch</span></strong><span class="koboSpan" id="kobo.296.1"> directive. </span><span class="koboSpan" id="kobo.296.2">The new Angular control flow also introduced a new concept: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">defer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.299.1"> block.</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">@defer</span></strong><span class="koboSpan" id="kobo.302.1"> block allows you to lazy-load components or native HTML elements inside your HTML templates. </span><span class="koboSpan" id="kobo.302.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">@defer</span></strong><span class="koboSpan" id="kobo.304.1"> block can lazy load and display elements based on different triggers, such as when a condition is met, when the elements enter the viewport, when the users interact with the placeholder, or based on a timer. </span><span class="koboSpan" id="kobo.304.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">@defer</span></strong><span class="koboSpan" id="kobo.306.1"> block can improve your performance because fewer components have to be loaded when the user lands on a page. </span><span class="koboSpan" id="kobo.306.2">Additionally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">@defer</span></strong><span class="koboSpan" id="kobo.308.1"> block reduces the bundle sizes as lazy-loaded page elements donâ€™t have to be included in the initial application bundle. </span><span class="koboSpan" id="kobo.308.2">Hereâ€™s an example of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">@defer</span></strong><span class="koboSpan" id="kobo.310.1"> block with </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">a placeholder:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.312.1">
@defer (on viewport) {
Â Â &lt;calendar-cmp /&gt;
} @placeholder { &lt;div&gt;Calendar placeholder&lt;/div&gt; }</span></pre> <p><span class="koboSpan" id="kobo.313.1">Now that you know about the new control flow</span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.314.1"> syntax, letâ€™s explore the remainder of the features that were introduced by the </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">Angular framework.</span></span></p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.316.1">Other noteworthy new Angular features</span></h2>
<p><span class="koboSpan" id="kobo.317.1">Before we move on to the next section </span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.318.1">of this chapter, we will briefly go over other noteworthy improvements that have been made to the </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">Angular framework:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.320.1">Types forms</span></strong><span class="koboSpan" id="kobo.321.1">: In Angular 14, reactive forms were made fully type-safe. </span><span class="koboSpan" id="kobo.321.2">The values inside form controls, groups, and arrays are now type-safe across the entire API of reactive forms, enabling </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">safer forms.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.323.1">Improved page titles</span></strong><span class="koboSpan" id="kobo.324.1">: Since Angular 14, you can add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">title</span></strong><span class="koboSpan" id="kobo.326.1"> property to your route configurations. </span><span class="koboSpan" id="kobo.326.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">title</span></strong><span class="koboSpan" id="kobo.328.1"> property will set the page title without other </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">implementations needed.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.330.1">NgOptimizedImage</span></strong><span class="koboSpan" id="kobo.331.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">NgOptimizedImage</span></strong><span class="koboSpan" id="kobo.333.1"> is a built-in image directive for optimized image fetching, rendering, and sizing. </span><span class="koboSpan" id="kobo.333.2">It has been stable for usage since </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">Angular 15.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.335.1">Functional approach</span></strong><span class="koboSpan" id="kobo.336.1">: Since Angular 15, you can use a functional approach for HTTP interceptors, route resolvers, and </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">route guards.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.338.1">Route parameter mapping</span></strong><span class="koboSpan" id="kobo.339.1">: This feature allows you to automatically map route data, query parameters, and path parameters to your component inputs. </span><span class="koboSpan" id="kobo.339.2">Because of this, you donâ€™t have to subscribe anymore, reducing complexity </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">and boilerplate.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.341.1">Injectable OnDestroy</span></strong><span class="koboSpan" id="kobo.342.1">: In Angular 16, the team introduced the </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">OnDestroy</span></strong><span class="koboSpan" id="kobo.344.1"> injectable, which allows you to inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">DestroyRef</span></strong><span class="koboSpan" id="kobo.346.1"> and access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">OnDestroy</span></strong><span class="koboSpan" id="kobo.348.1"> life cycle hook more flexibly. </span><span class="koboSpan" id="kobo.348.2">It allows you to subscribe to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">OnDestroy</span></strong><span class="koboSpan" id="kobo.350.1"> life cycle as well as inject it outside of </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">your components.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.352.1">Self-closing tags</span></strong><span class="koboSpan" id="kobo.353.1">: In Angular 16, you can use a self-closing tag for your component selectors. </span><span class="koboSpan" id="kobo.353.2">This can improve the readability of your </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">HTML templates.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.355.1">Required inputs</span></strong><span class="koboSpan" id="kobo.356.1">: In Angular 16, you can make component inputs </span><em class="italic"><span class="koboSpan" id="kobo.357.1">required</span></em><span class="koboSpan" id="kobo.358.1">. </span><span class="koboSpan" id="kobo.358.2">If no input is provided</span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.359.1"> in the template, the compiler will specify </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">an error.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.361.1">There are more newly added features, such as Vite support and better page hydration, but the ones we mentioned in this section are the most important for your daily </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">development practices.</span></span></p>
<p><span class="koboSpan" id="kobo.363.1">Now that you know about the new features that have been added to the Angular framework, we will move on and do deep dives into specific topics, starting with the </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">Angular router.</span></span></p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.365.1">A deep dive into Angular routing</span></h1>
<p><span class="koboSpan" id="kobo.366.1">This section</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.367.1"> will teach you about the </span><strong class="bold"><span class="koboSpan" id="kobo.368.1">Angular router</span></strong><span class="koboSpan" id="kobo.369.1">, a powerful tool that handles navigation in your Angular applications. </span><span class="koboSpan" id="kobo.369.2">The router is responsible for seamless transitions without full page loads, updating the browser URL, as well as handling route data, redirects, query parameters, path parameters, route resolvers, and guarding routes from </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">unauthorized visitors.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">Letâ€™s start by creating two new components we can </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">navigate to.</span></span></p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.373.1">Creating new components</span></h2>
<p><span class="koboSpan" id="kobo.374.1">We are going to use an Nx generator</span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.375.1"> for this. </span><span class="koboSpan" id="kobo.375.2">You can write a custom generator, but I will use the built-in component generator for now. </span><span class="koboSpan" id="kobo.375.3">Right-click on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">app</span></strong><span class="koboSpan" id="kobo.377.1"> folder inside your </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">expenses-registration</span></strong><span class="koboSpan" id="kobo.379.1"> folder and select the Nx console. </span><span class="koboSpan" id="kobo.379.2">In the dropdown, search for </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">component</span></strong><span class="koboSpan" id="kobo.381.1"> and select </span><strong class="bold"><span class="koboSpan" id="kobo.382.1">@nx/angular - </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.383.1">component</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">Follow these steps to generate the </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">necessary components:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.387.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.388.1">name*</span></strong><span class="koboSpan" id="kobo.389.1"> input field, </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">enter </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">pages/expenses-overview-page</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.393.1">Check the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.394.1">standalone</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.395.1"> checkbox.</span></span></li>
<li><span class="koboSpan" id="kobo.396.1">Click </span><strong class="bold"><span class="koboSpan" id="kobo.397.1">Show </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.398.1">all options</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.400.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.401.1">changeDetection</span></strong><span class="koboSpan" id="kobo.402.1"> select box, </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">select </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.404.1">OnPush</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.406.1">In the top-right corner, </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">click </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.408.1">Generate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.410.1">Once youâ€™ve completed these steps, repeat the same steps for creating the second component. </span><span class="koboSpan" id="kobo.410.2">You will only change the name </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">pages/expenses-approval-page</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.414.1">Now, letâ€™s serve the</span><em class="italic"> </em><em class="italic"><span class="koboSpan" id="kobo.415.1">finance-expenses-registration application</span></em><span class="koboSpan" id="kobo.416.1"> with </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">this command:</span></span></p>
<pre class="console">
<strong class="source-inline"><span class="koboSpan" id="kobo.418.1">nx serve finance-expenses-registration</span></strong></pre> <p><span class="koboSpan" id="kobo.419.1">You can also use the Nx console to serve your application. </span><span class="koboSpan" id="kobo.419.2">Just select the application under the </span><strong class="bold"><span class="koboSpan" id="kobo.420.1">PROJECTS</span></strong><span class="koboSpan" id="kobo.421.1"> tab and click on the </span><strong class="bold"><span class="koboSpan" id="kobo.422.1">play</span></strong><span class="koboSpan" id="kobo.423.1"> button after hovering </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">over </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.425.1">serve</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.427.1">When you open the application at </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">http://localhost:4200/</span></strong><span class="koboSpan" id="kobo.429.1">, youâ€™ll see a white screen. </span><span class="koboSpan" id="kobo.429.2">This is because you only have a router outlet in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">app.component.html</span></strong><span class="koboSpan" id="kobo.431.1"> file, which displays the current route, and no routes</span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.432.1"> have been configured for our </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">application yet.</span></span></p>
<p><span class="koboSpan" id="kobo.434.1">Your application is running, and two components are ready to route to, so letâ€™s configure some routes for </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">your application.</span></span></p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.436.1">Configuring routes in Angular applications</span></h2>
<p><span class="koboSpan" id="kobo.437.1">Before </span><strong class="bold"><span class="koboSpan" id="kobo.438.1">standalone components</span></strong><span class="koboSpan" id="kobo.439.1">, you added routing for your application</span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.440.1"> in your ngModules by</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.441.1"> importing </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">RouterModule</span></strong><span class="koboSpan" id="kobo.443.1"> and providing it with routes in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">forRoot</span></strong><span class="koboSpan" id="kobo.445.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">forChild</span></strong><span class="koboSpan" id="kobo.447.1"> method. </span><span class="koboSpan" id="kobo.447.2">Because weâ€™re using the latest Angular techniques, we wonâ€™t use ngModules. </span><span class="koboSpan" id="kobo.447.3">When bootstrapping with a standalone component, your routing is configured differently. </span><span class="koboSpan" id="kobo.447.4">When you open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">main.ts</span></strong><span class="koboSpan" id="kobo.449.1"> file, youâ€™ll see an </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">appConfig</span></strong><span class="koboSpan" id="kobo.451.1"> object being passed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">bootstrapApplication</span></strong><span class="koboSpan" id="kobo.453.1"> function. </span><span class="koboSpan" id="kobo.453.2">Open your </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">app.config.ts</span></strong><span class="koboSpan" id="kobo.455.1"> file to locate this </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">appConfig</span></strong><span class="koboSpan" id="kobo.457.1"> object. </span><span class="koboSpan" id="kobo.457.2">Inside, youâ€™ll find your </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">routing configurations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.459.1">
provideRouter(appRoutes, withEnabledBlockingInitialNavigation())</span></pre> <p><span class="koboSpan" id="kobo.460.1">Routing is configured by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">provideRouter</span></strong><span class="koboSpan" id="kobo.462.1"> function inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">providers</span></strong><span class="koboSpan" id="kobo.464.1"> array of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">ApplicationConfig</span></strong><span class="koboSpan" id="kobo.466.1"> object. </span><span class="koboSpan" id="kobo.466.2">When Nx created the application, it already set this up </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">for us.</span></span></p>
<p><span class="koboSpan" id="kobo.468.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">provideRouter</span></strong><span class="koboSpan" id="kobo.470.1"> function, youâ€™ll find an array</span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.471.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">Route</span></strong><span class="koboSpan" id="kobo.473.1"> objects</span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.474.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">a </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">with</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">
EnabledBlockingInitialNavigation</span></strong><span class="koboSpan" id="kobo.478.1"> function, which is required for routing with server-side rendering. </span><span class="koboSpan" id="kobo.478.2">We arenâ€™t using server-side rendering, so you can </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">delete </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">with</span></strong></span><strong class="source-inline">
</strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">EnabledBlockingInitialNavigation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.483.1">Open your </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">app.routes.ts</span></strong><span class="koboSpan" id="kobo.485.1"> file to set up the routes for your application. </span><span class="koboSpan" id="kobo.485.2">To start, we will add two </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">Route</span></strong><span class="koboSpan" id="kobo.487.1"> objects inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">appRoutes</span></strong><span class="koboSpan" id="kobo.489.1"> array â€“ one for the expenses approval page and another for the expenses </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">overview page:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.491.1">
export const appRoutes: Route[] = [{ path: 'expenses-overview', component: ExpensesOverviewPageComponent },
{ path: 'expenses-approval', component: ExpensesApprovalPageComponent }];</span></pre> <p><span class="koboSpan" id="kobo.492.1">As you can see, each object has two properties: a </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">path</span></strong><span class="koboSpan" id="kobo.494.1"> property to define the URL path and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">component</span></strong><span class="koboSpan" id="kobo.496.1"> property for specifying the loaded component when we reach the path. </span><span class="koboSpan" id="kobo.496.2">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">ExpensesOverviewPageComponent</span></strong><span class="koboSpan" id="kobo.498.1">, we configured </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">expenses-overview</span></strong><span class="koboSpan" id="kobo.500.1">, which means itâ€™s accessible </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">http://localhost:4200/expenses-overview</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.504.1">When you navigate to this URL, youâ€™ll see </span><strong class="bold"><span class="koboSpan" id="kobo.505.1">expenses-overview-page works!</span></strong><span class="koboSpan" id="kobo.506.1"> You can navigate to your routes inside TypeScript files by injecting </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">Router</span></strong><span class="koboSpan" id="kobo.508.1"> as a dependency. </span><span class="koboSpan" id="kobo.508.2">Then, you can use </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">this syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.510.1">
this.router.navigate(['expenses-overview']); //Option 1
this.router.navigateByUrl('/expenses-overview'); //Option 2</span></pre> <p><span class="koboSpan" id="kobo.511.1">You can navigate instead your HTML templates with </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">routerLink</span></strong><span class="koboSpan" id="kobo.513.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.515.1">
&lt;a [routerLink]="['path', { outlets: { sidebar: 'path'} }]"&gt;Click to navigate&lt;/a&gt;</span></pre> <p><span class="koboSpan" id="kobo.516.1">Now that youâ€™ve</span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.517.1"> configured</span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.518.1"> two routes, letâ€™s explore what else you can configure in your </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">route configurations.</span></span></p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.520.1">Route configuration options</span></h2>
<p><span class="koboSpan" id="kobo.521.1">In this section, you will make your routing more robust and explore properties you can configure on your </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">route objects.</span></span></p>
<h3><span class="koboSpan" id="kobo.523.1">Adding page titles</span></h3>
<p><span class="koboSpan" id="kobo.524.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">title</span></strong><span class="koboSpan" id="kobo.526.1"> property was added</span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.527.1"> in Angular 14 and is used to set HTML page titles dynamically. </span><span class="koboSpan" id="kobo.527.2">Before Angular 14, you needed subscriptions and a lot of logic to set the page title. </span><span class="koboSpan" id="kobo.527.3">With the introduction of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">title</span></strong><span class="koboSpan" id="kobo.529.1"> property, Angular handles all of that behind the scenes and sets the page title for you. </span><span class="koboSpan" id="kobo.529.2">You can set your titles with a simple string or </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">ResolveFn&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.531.1">. </span><span class="koboSpan" id="kobo.531.2">When you use a string, you can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">following syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.533.1">
{ path: '', component: ExpensesApprovalPageComponent, title: 'Expenses Approval Page' }</span></pre> <p><span class="koboSpan" id="kobo.534.1">We will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">ResolveFn&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.536.1"> to set page titles dynamically, </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.538.1">
export const titleResolver: ResolveFn&lt;string&gt; =
Â Â (route: ActivatedRouteSnapshot) =&gt;
Â Â Â Â route.routeConfig?.path?.replace('-', ' ') ?? </span><span class="koboSpan" id="kobo.538.2">'';</span></pre> <p><span class="koboSpan" id="kobo.539.1">This is a simple example where we take the route path and replace the hyphen with a space, but you can add any logic you want. </span><span class="koboSpan" id="kobo.539.2">Once youâ€™ve defined your title resolver, you can assign it to your route configuration </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.541.1">
{ path: '', component: SomeComponent, title: titleResolver}</span></pre> <p><span class="koboSpan" id="kobo.542.1">You can also overwrite the default behavior Angular uses to add the titles to your pages by overwriting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">TitleStrategy</span></strong><span class="koboSpan" id="kobo.544.1"> class. </span><span class="koboSpan" id="kobo.544.2">This is only useful in edge cases, but itâ€™s good to know itâ€™s possible. </span><span class="koboSpan" id="kobo.544.3">We wonâ€™t cover an example in this book, but you can find a simple overwrite of </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">TitleStrategy</span></strong><span class="koboSpan" id="kobo.546.1"> in this bookâ€™s GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">repository: </span></span><a href="https://github.com/PacktPublishing/Effective-Angular/blob/main/apps/finance/expenses-registration/src/app/app.routes.ts"><span class="No-Break"><span class="koboSpan" id="kobo.548.1">https://github.com/PacktPublishing/Effective-Angular/blob/main/apps/finance/expenses-registration/src/app/app.routes.ts</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.549.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.550.1">Lazy loading standalone components</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.551.1">Lazy loading components</span></strong><span class="koboSpan" id="kobo.552.1"> is one of the most essential features</span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.553.1"> of the router. </span><span class="koboSpan" id="kobo.553.2">It allows you to divide your application</span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.554.1"> into small chunks that are only loaded when a user reaches a specific route of your application. </span><span class="koboSpan" id="kobo.554.2">With the introduction of standalone components, you can lazy load components, whereas before, you could only lazy load modules. </span><span class="koboSpan" id="kobo.554.3">Now, splitting your application into small bundles is easier because you can lazy load components instead of modules. </span><span class="koboSpan" id="kobo.554.4">You can lazy load each route by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">loadComponent</span></strong><span class="koboSpan" id="kobo.556.1"> property in your </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">route configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.558.1">Since Angular 15, the router also supports automated unwraps of default imports. </span><span class="koboSpan" id="kobo.558.2">With automated unwraps, you donâ€™t need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">.then()</span></strong><span class="koboSpan" id="kobo.560.1"> method to be chained to unwrap your import for the router. </span><span class="koboSpan" id="kobo.560.2">Because of this, we can make the syntax for lazy loading shorter and easier. </span><span class="koboSpan" id="kobo.560.3">Change your routes to lazy-loaded routes by changing the export of your component classes to </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">default</span></strong><span class="koboSpan" id="kobo.562.1"> exports, </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.564.1">
export </span><strong class="bold"><span class="koboSpan" id="kobo.565.1">default</span></strong><span class="koboSpan" id="kobo.566.1"> class ExpensesApprovalPageComponent {}</span></pre> <p><span class="koboSpan" id="kobo.567.1">Once youâ€™ve done this, you can configure lazy-loaded routes </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.569.1">
{ path: 'â€¦â€¦', loadComponent: () =&gt; import('@pages/expenses-approval-page/expenses-approval-page.component') }</span></pre> <p><span class="koboSpan" id="kobo.570.1">Do the same for your other route</span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.571.1"> so that all your routes </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">are lazy-loaded.</span></span></p>
<p><span class="koboSpan" id="kobo.573.1">Next, we will learn how to use multiple router outlets and </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">auxiliary routes.</span></span></p>
<h3><span class="koboSpan" id="kobo.575.1">Router outlets and auxiliary routes</span></h3>
<p><span class="koboSpan" id="kobo.576.1">If you want to develop</span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.577.1"> dynamic user interfaces</span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.578.1"> while reducing your bundle sizes even more, </span><strong class="bold"><span class="koboSpan" id="kobo.579.1">named router outlets</span></strong><span class="koboSpan" id="kobo.580.1"> are a great way to achieve</span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.581.1"> this. </span><span class="koboSpan" id="kobo.581.2">We wonâ€™t implement named router outlets, but I do want to explain how </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">they work.</span></span></p>
<p><span class="koboSpan" id="kobo.583.1">With named router outlets, you can lazy load specific sections of your pages and lazy load different components for these page sections based on your application state. </span><span class="koboSpan" id="kobo.583.2">You can, for example, display different sidebars on each page or even on the same page based on application states. </span><span class="koboSpan" id="kobo.583.3">Because you can lazy load these sidebar components, they will not be part of your main application bundle and will only be loaded when displayed. </span><span class="koboSpan" id="kobo.583.4">To use named router outlets, you need to configure a route with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">outlet</span></strong><span class="koboSpan" id="kobo.585.1"> property, </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.587.1">
{ path: 'list', component: SomeComponet, </span><strong class="bold"><span class="koboSpan" id="kobo.588.1">outlet</span></strong><span class="koboSpan" id="kobo.589.1">: 'sidebar'}</span></pre> <p><span class="koboSpan" id="kobo.590.1">If you want to use lazy loading for these routes, you can replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">component</span></strong><span class="koboSpan" id="kobo.592.1"> property with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">loadComponent</span></strong><span class="koboSpan" id="kobo.594.1"> property and import </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">the component.</span></span></p>
<p><span class="koboSpan" id="kobo.596.1">Routes with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">outlet</span></strong><span class="koboSpan" id="kobo.598.1"> property defined can only be loaded by a router outlet with the same name specified on it. </span><span class="koboSpan" id="kobo.598.2">You can define named router outlets by adding a name attribute on the router outlet HTML tag </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.600.1">
&lt;router-outlet name="sidebar"&gt;&lt;router-outlet/&gt;</span></pre> <p><span class="koboSpan" id="kobo.601.1">With the named router outlet in your template and a route configuration with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">outlet</span></strong><span class="koboSpan" id="kobo.603.1"> property defined, you have everything set up. </span><span class="koboSpan" id="kobo.603.2">Your main router outlet will work as expected and navigate to the expenses overview page when you add </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">/expenses-overview</span></strong><span class="koboSpan" id="kobo.605.1"> after your root URL. </span><span class="koboSpan" id="kobo.605.2">The named router outlets work differently. </span><span class="koboSpan" id="kobo.605.3">The routes that are used by your named router outlets are called </span><em class="italic"><span class="koboSpan" id="kobo.606.1">auxiliary routes</span></em><span class="koboSpan" id="kobo.607.1"> and can be seen as sub-routes </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.608.1">that operate independently from your main route. </span><span class="koboSpan" id="kobo.608.2">These auxiliary routes form a special kind of URL that looks like </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">this: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">http://localhost:4200/expenses-overview(sidebar:list)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.612.1">As you can see, round brackets are added to your URL to represent your auxiliary routes. </span><span class="koboSpan" id="kobo.612.2">There is only one auxiliary route in our example, but there could be more, and they would all be inside the round brackets separated by a double forward slash. </span><span class="koboSpan" id="kobo.612.3">Your auxiliary routes are isolated inside these round brackets so that you can activate different auxiliary routes for the same </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">main route.</span></span></p>
<p><span class="koboSpan" id="kobo.614.1">Routing to auxiliary routes inside your TypeScript files can be done </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.616.1">
this.router.navigate(['path', { outlets: { sidebar: 'path'} }]);</span></pre> <p><span class="koboSpan" id="kobo.617.1">When using </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">routerLink</span></strong><span class="koboSpan" id="kobo.619.1"> in your HTML</span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.620.1"> templates, you must</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.621.1"> add the following syntax to your </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">HTML tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.623.1">
[routerLink]="['path', { outlets: { sidebar: 'path'} }]"</span></pre> <p><span class="koboSpan" id="kobo.624.1">Now that you know about named router outlets, letâ€™s learn about </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">route guards.</span></span></p>
<h3><span class="koboSpan" id="kobo.626.1">Route guards</span></h3>
<p><span class="koboSpan" id="kobo.627.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">canActivate</span></strong><span class="koboSpan" id="kobo.629.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">canMatch</span></strong><span class="koboSpan" id="kobo.631.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">canActivateChild</span></strong><span class="koboSpan" id="kobo.633.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">canDeactivate</span></strong><span class="koboSpan" id="kobo.635.1"> properties declare </span><strong class="bold"><span class="koboSpan" id="kobo.636.1">route guards</span></strong><span class="koboSpan" id="kobo.637.1"> in your route </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.638.1">configurations. </span><span class="koboSpan" id="kobo.638.2">Route guards help you to secure routes and prevent users from accessing a route they are not intended to access. </span><span class="koboSpan" id="kobo.638.3">All four properties define a type of route guard that prevents the user from performing a specific routing task, such as activating or deactivating </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">a route.</span></span></p>
<p><span class="koboSpan" id="kobo.640.1">The implementations with the rules when these guards should allow or block a user are created by yourself and can contain any logic you need. </span><span class="koboSpan" id="kobo.640.2">Each route can configure multiple guard types, and you can add various implementations for each type. </span><span class="koboSpan" id="kobo.640.3">You can configure these guard types and the implementations for them in your route configurations, </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.642.1">
{ path: 'â€¦â€¦', loadComponent: â€¦â€¦,
Â Â Â Â canActivate: [IsLoggedInGuard, IsAdminGuard],
Â Â Â Â canDeactivate: [hasDoneSomeTaskGuard] },</span></pre> <p><span class="koboSpan" id="kobo.643.1">In </span><a href="B21625_09.xhtml#_idTextAnchor170"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.644.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.645.1">, we will create route guards and look at their implementations; for now, you just need to know that you can protect routes </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.646.1">with </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">route guards.</span></span></p>
<p><span class="koboSpan" id="kobo.648.1">Now that you know about route guards, letâ€™s move on and start learning about </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">child routes.</span></span></p>
<h3><span class="koboSpan" id="kobo.650.1">Defining child routes</span></h3>
<p><span class="koboSpan" id="kobo.651.1">Route configurations</span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.652.1"> can also define </span><strong class="bold"><span class="koboSpan" id="kobo.653.1">child routes</span></strong><span class="koboSpan" id="kobo.654.1">, which helps organize your routes</span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.655.1"> better and easily create an initiative URL structure. </span><span class="koboSpan" id="kobo.655.2">Child routes are defined </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.657.1">
{ path: 'dashboard', component: DashboardComponent,
 children: [{ path: 'summary', component: SummaryComponent }]}</span></pre> <p><span class="koboSpan" id="kobo.658.1">The preceding example would load </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">SummaryComponent</span></strong><span class="koboSpan" id="kobo.660.1"> on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">/dashboard/summary</span></strong><span class="koboSpan" id="kobo.662.1"> route. </span><span class="koboSpan" id="kobo.662.2">You can configure the same route without using child routes, but using child routes offers some advantages. </span><span class="koboSpan" id="kobo.662.3">The most apparent benefit is that you can better organize your routes. </span><span class="koboSpan" id="kobo.662.4">Another advantage of child routes is that you can share route resolvers and guards. </span><span class="koboSpan" id="kobo.662.5">When you use a route guard on a parent route, the guard will automatically be applied to all child routes. </span><span class="koboSpan" id="kobo.662.6">You can also use child routes to omit the round brackets in the URLs of your auxiliary routes from the named router outlets. </span><span class="koboSpan" id="kobo.662.7">However, there are some drawbacks to this compared to regular auxiliary routes. </span><span class="koboSpan" id="kobo.662.8">When using child routes to omit the round brackets, you canâ€™t load different auxiliary routes on the same main URL; instead, you need</span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.663.1"> to add a new configuration for each route and auxiliary</span><a id="_idIndexMarker176"/> <span class="No-Break"><span class="koboSpan" id="kobo.664.1">route combination.</span></span></p>
<h3><span class="koboSpan" id="kobo.665.1">Fallback routes and redirecting</span></h3>
<p><span class="koboSpan" id="kobo.666.1">You can configure </span><strong class="bold"><span class="koboSpan" id="kobo.667.1">fallback routes</span></strong><span class="koboSpan" id="kobo.668.1"> by using a double asterisk</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.669.1"> for the path. </span><span class="koboSpan" id="kobo.669.2">Your fallback</span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.670.1"> route will be triggered when no route to the current browser URL is found. </span><span class="koboSpan" id="kobo.670.2">Most of the time, the fallback route is used to display a </span><strong class="bold"><span class="koboSpan" id="kobo.671.1">404 Page Not Found</span></strong><span class="koboSpan" id="kobo.672.1"> error. </span><span class="koboSpan" id="kobo.672.2">You can configure fallback routes </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.674.1">
{ path: '**', component: NotFoundComponent }</span></pre> <p><span class="koboSpan" id="kobo.675.1">When working with child routes and named router outlets, you can configure multiple fallback routes, but in most scenarios, one fallback that redirects to a </span><strong class="bold"><span class="koboSpan" id="kobo.676.1">404 Page Not Found</span></strong><span class="koboSpan" id="kobo.677.1"> page will be enough. </span><span class="koboSpan" id="kobo.677.2">Another</span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.678.1"> useful route configuration is a </span><strong class="bold"><span class="koboSpan" id="kobo.679.1">redirect route</span></strong><span class="koboSpan" id="kobo.680.1">. </span><span class="koboSpan" id="kobo.680.2">You can use redirects to send a user</span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.681.1"> to a specific route when some other route is loaded. </span><span class="koboSpan" id="kobo.681.2">When working with child and auxiliary routes, redirects are especially useful because often, you want to redirect to a specific child or auxiliary route when a parent or root route is accessed by the user. </span><span class="koboSpan" id="kobo.681.3">Because we donâ€™t have any auxiliary or child routes, we will add a simple redirect and send the user to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">/expenses-overview</span></strong><span class="koboSpan" id="kobo.683.1"> route when they load the root route. </span><span class="koboSpan" id="kobo.683.2">You can add this redirect to your </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">appRoutes</span></strong><span class="koboSpan" id="kobo.685.1"> array </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.687.1">
{ path: '', pathMatch: 'full', redirectTo: '/expenses-overview' }</span></pre> <p><span class="koboSpan" id="kobo.688.1">Now that you know about fallback routes, letâ€™s dive into </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">route resolvers.</span></span></p>
<h3><span class="koboSpan" id="kobo.690.1">Route resolvers</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.691.1">Route resolvers</span></strong><span class="koboSpan" id="kobo.692.1"> can resolve data before a route is activated </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.693.1">and provide that data to your component. </span><span class="koboSpan" id="kobo.693.2">That might sound nice, but your route wonâ€™t be activated until the data is fetched and can be passed to the route. </span><span class="koboSpan" id="kobo.693.3">As a result, when you fetch asynchronous data and the API isnâ€™t responding, the route will not be activated, and the user will be staring at a white screen. </span><span class="koboSpan" id="kobo.693.4">Resolvers should only be used if you have some edge case where a component cannot work without having specific data before the component renders. </span><span class="koboSpan" id="kobo.693.5">A simple implementation of a route resolver function looks </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.695.1">
export const userDataResolver: ResolveFn&lt;User&gt; = (
Â Â route: ActivatedRouteSnapshot) =&gt; inject(UserService)
Â Â Â Â .getUserData(route.paramMap.get("userId")).catch(â€¦â€¦);</span></pre> <p><span class="koboSpan" id="kobo.696.1">You can declare the route resolver on your route configurations </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.698.1">
{ path: 'path', resolve: productResolver, component: â€¦â€¦},</span></pre> <p><span class="koboSpan" id="kobo.699.1">You can access the resolved data inside your components using the data property of the </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">route snapshot:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.701.1">
protected readonly route = inject(ActivatedRoute)
ngOnInit() { this.route.snapshot.data; }</span></pre> <p><span class="koboSpan" id="kobo.702.1">Donâ€™t use route resolvers unless you donâ€™t have any other option. </span><span class="koboSpan" id="kobo.702.2">Such scenarios donâ€™t arise often, if at all; however, I wanted to mention resolvers and make you aware of them and their drawbacks. </span><span class="koboSpan" id="kobo.702.3">When working on Angular applications, you will find route resolvers quite</span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.703.1"> often in the </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.705.1">Now that youâ€™ve created components, set up routes, and learned about the Angular router, we will learn about </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">component communication.</span></span></p>
<h1 id="_idParaDest-47"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.707.1">Component communication</span></h1>
<p><span class="koboSpan" id="kobo.708.1">This section will dive deep into </span><strong class="bold"><span class="koboSpan" id="kobo.709.1">component communication</span></strong><span class="koboSpan" id="kobo.710.1">, starting with input and output</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.711.1"> decorators. </span><span class="koboSpan" id="kobo.711.2">Before we begin, letâ€™s create a new component with the Nx generator so that we have something to </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">work with.</span></span></p>
<p><span class="koboSpan" id="kobo.713.1">Name your new component </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">navbar</span></strong><span class="koboSpan" id="kobo.715.1"> and add it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">shared-ui-common-components</span></strong><span class="koboSpan" id="kobo.717.1"> library. </span><span class="koboSpan" id="kobo.717.2">Donâ€™t forget to check the </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">standalone</span></strong><span class="koboSpan" id="kobo.719.1"> checkbox and select </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">OnPush</span></strong><span class="koboSpan" id="kobo.721.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">changeDetection</span></strong><span class="koboSpan" id="kobo.723.1">. </span><span class="koboSpan" id="kobo.723.2">When the component has been created, add it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">index.ts</span></strong><span class="koboSpan" id="kobo.725.1"> area of </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">your library:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.727.1">
export * from './lib/navbar/navbar.component';</span></pre> <p><span class="koboSpan" id="kobo.728.1">After that, add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">navbar</span></strong><span class="koboSpan" id="kobo.730.1"> component to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">app.component.html</span></strong><span class="koboSpan" id="kobo.732.1"> file of your </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">expenses-registration</span></strong><span class="koboSpan" id="kobo.734.1"> application. </span><span class="koboSpan" id="kobo.734.2">Itâ€™s important to note that you need to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">NavBarComponent</span></strong><span class="koboSpan" id="kobo.736.1"> class to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">imports</span></strong><span class="koboSpan" id="kobo.738.1"> array of your </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">app</span></strong><span class="koboSpan" id="kobo.740.1"> component decorator. </span><span class="koboSpan" id="kobo.740.2">This is because we are using standalone components, and a standalone component needs to import everything it uses. </span><span class="koboSpan" id="kobo.740.3">Once youâ€™ve added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">navbar</span></strong><span class="koboSpan" id="kobo.742.1"> component to the template of your app component, you can get the code for the HTML and SCSS of the navbar from this bookâ€™s GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">repository: </span></span><a href="https://github.com/PacktPublishing/Effective-Angular"><span class="No-Break"><span class="koboSpan" id="kobo.744.1">https://github.com/PacktPublishing/Effective-Angular</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.745.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.746.1">Because </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">navbar</span></strong><span class="koboSpan" id="kobo.748.1"> is also a standalone component, you need to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">RouterLink</span></strong><span class="koboSpan" id="kobo.750.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">CommonModule</span></strong><span class="koboSpan" id="kobo.752.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">imports</span></strong><span class="koboSpan" id="kobo.754.1"> array of the component decorator. </span><span class="koboSpan" id="kobo.754.2">These two imports are necessary because we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">routerLink</span></strong><span class="koboSpan" id="kobo.756.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">*ngFor</span></strong><span class="koboSpan" id="kobo.758.1"> directives in the template</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.759.1"> of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">navbar</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.761.1"> component.</span></span></p>
<p><span class="koboSpan" id="kobo.762.1">Now that youâ€™ve created and added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">navbar</span></strong><span class="koboSpan" id="kobo.764.1"> component to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">app</span></strong><span class="koboSpan" id="kobo.766.1"> component template, we can look into parent-child </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">component communication.</span></span></p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.768.1">Receiving values with the @input() decorator</span></h2>
<p><span class="koboSpan" id="kobo.769.1">As we explained in </span><a href="B21625_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.770.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.771.1">, when we develop</span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.772.1"> Angular applications, we divide our components</span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.773.1"> into smart and dumb components. </span><span class="koboSpan" id="kobo.773.2">Dumb </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.774.1">components are presentational components that are used in the templates of smart components. </span><span class="koboSpan" id="kobo.774.2">These dumb components should only receive data through </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">@Input()</span></strong><span class="koboSpan" id="kobo.776.1"> decorators (alternatively, you can use the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">input()</span></strong><span class="koboSpan" id="kobo.778.1"> Signal that was introduced in Angular 17; we will dive deeper into Signals in </span><a href="B21625_07.xhtml#_idTextAnchor129"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.779.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.780.1">, so for now, we will use the decorator); dumb components do not inject services for data as that is the responsibility of </span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">smart components.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">@Input()</span></strong><span class="koboSpan" id="kobo.783.1"> decorators are only defined on child components; the parent components pass data to the input. </span><span class="koboSpan" id="kobo.783.2">A component can be considered a child component when itâ€™s declared inside another componentâ€™s HTML template. </span><span class="koboSpan" id="kobo.783.3">On the other hand, the component that declares a component in its HTML template is regarded as the parent component. </span><span class="koboSpan" id="kobo.783.4">Dumb components are always meant to be child components, whereas smart components can be both. </span><span class="koboSpan" id="kobo.783.5">Still, smart components are generally used as parent components and seldom declare input and </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">output decorators.</span></span></p>
<p><span class="koboSpan" id="kobo.785.1">Our newly created </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">navbar</span></strong><span class="koboSpan" id="kobo.787.1"> component</span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.788.1"> is a dumb component thatâ€™s used</span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.789.1"> as a building block</span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.790.1"> for our pages. </span><span class="koboSpan" id="kobo.790.2">Since itâ€™s a dumb component, it must rely on input decorators to receive its data. </span><span class="koboSpan" id="kobo.790.3">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">navbar</span></strong><span class="koboSpan" id="kobo.792.1"> component needs </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">navbar</span></strong><span class="koboSpan" id="kobo.794.1"> items, so letâ€™s define an interface and input. </span><span class="koboSpan" id="kobo.794.2">First, define the interface in a new file or underneath your </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">navbar</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.796.1">componentâ€™s class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.797.1">
export interface NavbarItem {label: string; route: string;}</span></pre> <p><span class="koboSpan" id="kobo.798.1">Here, we defined the interface. </span><span class="koboSpan" id="kobo.798.2">Now, letâ€™s add the input to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">navbar</span></strong><span class="koboSpan" id="kobo.800.1"> component, </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">like this:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.802.1">@Input()</span></strong><span class="koboSpan" id="kobo.803.1"> navbarItems: NavbarItem[] = [];</span></pre> <p><span class="koboSpan" id="kobo.804.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">@Input()</span></strong><span class="koboSpan" id="kobo.806.1"> is a decorator for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">navbarItems</span></strong><span class="koboSpan" id="kobo.808.1"> field that tells the Angular compiler that the property can receive input from parent components. </span><span class="koboSpan" id="kobo.808.2">We gave the field a </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">NavbarItem</span></strong><span class="koboSpan" id="kobo.810.1"> array type and an empty arrayâ€™s default value. </span><span class="koboSpan" id="kobo.810.2">If you donâ€™t give it a default value, the compiler will start to complain; you can prevent this by adding an exclamation mark after the propertyâ€™s name, </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.812.1">
@Input() navbarItems</span><strong class="bold"><span class="koboSpan" id="kobo.813.1">!</span></strong><span class="koboSpan" id="kobo.814.1">: NavbarItem[];</span></pre> <p><span class="koboSpan" id="kobo.815.1">In our example, we declared the </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">navbar</span></strong><span class="koboSpan" id="kobo.817.1"> component in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">app</span></strong><span class="koboSpan" id="kobo.819.1"> component template from our </span><em class="italic"><span class="koboSpan" id="kobo.820.1">expenses-registration application</span></em><span class="koboSpan" id="kobo.821.1">, making </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">navbar</span></strong><span class="koboSpan" id="kobo.823.1"> a child component of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">app</span></strong><span class="koboSpan" id="kobo.825.1"> component. </span><span class="koboSpan" id="kobo.825.2">To pass our new input property data, letâ€™s declare a </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">NavbarItem</span></strong><span class="koboSpan" id="kobo.827.1"> array inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">app</span></strong><span class="koboSpan" id="kobo.829.1"> component class, </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.831.1">
navItems: NavbarItem[] = [</span><strong class="bold"><span class="koboSpan" id="kobo.832.1">{ label: 'home', route: '/' }</span></strong><span class="koboSpan" id="kobo.833.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.834.1">{ label: 'expenses approval', route: '/expenses-approval'}</span></strong><span class="koboSpan" id="kobo.835.1">];</span></pre> <p><span class="koboSpan" id="kobo.836.1">We want to pass this </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">navItems</span></strong><span class="koboSpan" id="kobo.838.1"> array to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">navbar</span></strong><span class="koboSpan" id="kobo.840.1"> component using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">navbarItems</span></strong><span class="koboSpan" id="kobo.842.1"> input property. </span><span class="koboSpan" id="kobo.842.2">We can do this in the HTML template of the app component, where we declare the HTML selector tag for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">navbar</span></strong><span class="koboSpan" id="kobo.844.1"> component. </span><span class="koboSpan" id="kobo.844.2">You can pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">navItems</span></strong><span class="koboSpan" id="kobo.846.1"> array as input using </span><span class="No-Break"><span class="koboSpan" id="kobo.847.1">this syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.848.1">
&lt;bt-libs-navbar [navbarItems]="navItems" /&gt;</span></pre> <p><span class="koboSpan" id="kobo.849.1">On the left-hand side, between the square brackets, youâ€™ll use the property name of the input property thatâ€™s declared inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">navbar</span></strong><span class="koboSpan" id="kobo.851.1"> component â€“ in our case </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">navbarItems</span></strong><span class="koboSpan" id="kobo.853.1">. </span><span class="koboSpan" id="kobo.853.2">On the right-hand side, you must assign the input with a value thatâ€™s declared in the parent component â€“ in our case, the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">navItems</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.855.1"> array.</span></span></p>
<p><span class="koboSpan" id="kobo.856.1">It is important to know that when a component receives input values, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">ngOnChanges</span></strong><span class="koboSpan" id="kobo.858.1"> life cycle hook is triggered â€“ once this component has been created, before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">ngOnInit</span></strong><span class="koboSpan" id="kobo.860.1"> life cycle hook runs, and then once more every time an input receives a new value. </span><span class="koboSpan" id="kobo.860.2">You can access the previous and new input values inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">ngOnChanges</span></strong><span class="koboSpan" id="kobo.862.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.864.1">
ngOnChanges(changes: SimpleChanges) {console.log(changes)};</span></pre> <p><span class="koboSpan" id="kobo.865.1">The current value inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">SimpleChanges</span></strong><span class="koboSpan" id="kobo.867.1"> object should be equal to the value of the input property declared in the component. </span><span class="koboSpan" id="kobo.867.2">So, if you need the current value, you can also access the component property. </span><span class="koboSpan" id="kobo.867.3">In our example, this would </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">navbarItems</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.871.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">ngOnChanges</span></strong><span class="koboSpan" id="kobo.873.1"> life cycle hook is a good place to perform extra logic when you receive an input value. </span><span class="koboSpan" id="kobo.873.2">Still, this can become messy when you have a lot of input properties and want to perform logic for each when they receive a new value. </span><span class="koboSpan" id="kobo.873.3">If this is the case, or if you want to transform the value into something else, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">@Input()</span></strong><span class="koboSpan" id="kobo.875.1"> decorator as a getter </span><span class="No-Break"><span class="koboSpan" id="kobo.876.1">and setter.</span></span></p>
<p><span class="koboSpan" id="kobo.877.1">Letâ€™s say we want to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">NavbarItem</span></strong><span class="koboSpan" id="kobo.879.1"> for the home page</span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.880.1"> to our input each time it receives values so that we donâ€™t have </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.881.1">to declare the home page and</span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.882.1"> its route inside the object we pass as input to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">navbar</span></strong><span class="koboSpan" id="kobo.884.1"> component. </span><span class="koboSpan" id="kobo.884.2">We can do this by transforming the input into an input with a getter and setter. </span><span class="koboSpan" id="kobo.884.3">Start by adding a private property to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">navbar</span></strong><span class="koboSpan" id="kobo.886.1"> component, </span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.888.1">
private _navItems: NavbarItem[] = [];</span></pre> <p><span class="koboSpan" id="kobo.889.1">Now, change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">navbarItems</span></strong><span class="koboSpan" id="kobo.891.1"> input property to a getter and setter and use the private property inside the getter and setter, </span><span class="No-Break"><span class="koboSpan" id="kobo.892.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.893.1">
@Input()
</span><strong class="bold"><span class="koboSpan" id="kobo.894.1">set</span></strong><span class="koboSpan" id="kobo.895.1"> navbarItems(value: NavbarItem[]) {
Â Â </span><strong class="bold"><span class="koboSpan" id="kobo.896.1">this._navItems</span></strong><span class="koboSpan" id="kobo.897.1"> = [{label: 'home', route: '/'}, ...value];
}
</span><strong class="bold"><span class="koboSpan" id="kobo.898.1">get</span></strong><span class="koboSpan" id="kobo.899.1"> navbarItems(): NavbarItem[] { return </span><strong class="bold"><span class="koboSpan" id="kobo.900.1">this._navItems;</span></strong><span class="koboSpan" id="kobo.901.1"> }</span></pre> <p><span class="koboSpan" id="kobo.902.1">When the input property receives new input values, it will set the private property and add the home page route to these values. </span><span class="koboSpan" id="kobo.902.2">When you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">navbarItems</span></strong><span class="koboSpan" id="kobo.904.1"> property inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">navbar</span></strong><span class="koboSpan" id="kobo.906.1"> component or template, it will use the getter, which returns the private property, including the extra home page item. </span><span class="koboSpan" id="kobo.906.2">After you change the input property, you can remove the object for the home navbar item from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">navItems</span></strong><span class="koboSpan" id="kobo.908.1"> array declared in your </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">app</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.910.1"> component.</span></span></p>
<p><span class="koboSpan" id="kobo.911.1">Since Angular 16.1, you can</span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.912.1"> achieve the same with the </span><strong class="bold"><span class="koboSpan" id="kobo.913.1">transform property</span></strong><span class="koboSpan" id="kobo.914.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">@Input</span></strong><span class="koboSpan" id="kobo.916.1"> decorator instead of creating a getter and setter. </span><span class="koboSpan" id="kobo.916.2">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.917.1">transform</span></strong><span class="koboSpan" id="kobo.918.1"> property requires a lot less code and looks much cleaner. </span><span class="koboSpan" id="kobo.918.2">Letâ€™s convert our getter and setter into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">transform</span></strong><span class="koboSpan" id="kobo.920.1"> property. </span><span class="koboSpan" id="kobo.920.2">First, remove the private </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">_navItems</span></strong><span class="koboSpan" id="kobo.922.1"> property and the getter and setter we just added and replace them </span><span class="No-Break"><span class="koboSpan" id="kobo.923.1">with this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.924.1">
@Input({</span><strong class="bold"><span class="koboSpan" id="kobo.925.1">transform</span></strong><span class="koboSpan" id="kobo.926.1">: addHome}) navbarItems: NavbarItem[] = []</span></pre> <p><span class="koboSpan" id="kobo.927.1">Now, you only need to add</span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.928.1"> a function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">addHome</span></strong><span class="koboSpan" id="kobo.930.1"> with the transformation</span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.931.1"> logic. </span><span class="koboSpan" id="kobo.931.2">You can add this function</span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.932.1"> to a separate file or the same file underneath the </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">navbar</span></strong><span class="koboSpan" id="kobo.934.1"> component class. </span><span class="koboSpan" id="kobo.934.2">The function looks </span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.936.1">
function addHome(items: NavbarItem[]) {
Â Â return [{ label: 'home', route: '/' }, ...items];
}</span></pre> <p><span class="koboSpan" id="kobo.937.1">Thatâ€™s all you need; no more private property or getter and setter needed for transforming input values! </span><span class="koboSpan" id="kobo.937.2">If you need to perform other logic, such as setting component properties or running functions inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">component</span></strong><span class="koboSpan" id="kobo.939.1"> class, you can still use the getter and </span><span class="No-Break"><span class="koboSpan" id="kobo.940.1">setter approach.</span></span></p>
<p><span class="koboSpan" id="kobo.941.1">Lastly, since Angular 16, you can also make input properties required. </span><span class="koboSpan" id="kobo.941.2">When you make an input property required, it needs to be declared on the HTML tag when the component is used in a componentâ€™s template. </span><span class="koboSpan" id="kobo.941.3">The parent thatâ€™s using the component in its template must add the input property to the HTML tags and pass it a valid value; otherwise, the compiler will throw an error. </span><span class="koboSpan" id="kobo.941.4">To make our </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">navbarItem</span></strong><span class="koboSpan" id="kobo.943.1"> input property required, we can change the input decorator </span><span class="No-Break"><span class="koboSpan" id="kobo.944.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.945.1">
@Input({ transform: addHome, </span><strong class="bold"><span class="koboSpan" id="kobo.946.1">required</span></strong><span class="koboSpan" id="kobo.947.1">: true }) navbarItems: NavbarItem[] = [];</span></pre> <p><span class="koboSpan" id="kobo.948.1">Now that you know how to input values</span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.949.1"> into a component, transform</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.950.1"> these inputs, or perform</span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.951.1"> extra logic when a component receives new input values, we will learn how to emit values using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">Output()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.954.1"> decorator.</span></span></p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.955.1">Emitting values with the @Output() decorator</span></h2>
<p><span class="koboSpan" id="kobo.956.1">Child components also need a way</span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.957.1"> to send events and data</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.958.1"> to the parent</span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.959.1"> component. </span><span class="koboSpan" id="kobo.959.2">For example, if you have a table component in which you can display and update data, the table component shouldnâ€™t inject services to receive and update the data. </span><span class="koboSpan" id="kobo.959.3">This would result in a tight coupling of the table component and the data it displays. </span><span class="koboSpan" id="kobo.959.4">Each time you use the table with different data, it needs to add extra services and new logic to persist the data updates, and this is not a </span><span class="No-Break"><span class="koboSpan" id="kobo.960.1">desirable situation.</span></span></p>
<p><span class="koboSpan" id="kobo.961.1">Instead, the table component should be a dumb component that receives data as inputs and emits an event with the updated data as output. </span><span class="koboSpan" id="kobo.961.2">By doing so, your table component remains reusable and doesnâ€™t create unnecessary dependencies. </span><span class="koboSpan" id="kobo.961.3">The parent components are smart components that are used for specific business use cases or pages, so each can implement whatever logic is needed to handle the data updates for its specific page or business use case without creating </span><span class="No-Break"><span class="koboSpan" id="kobo.962.1">unwanted dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.963.1">To emit an event to a parent component, we need to create something that can emit our events. </span><span class="koboSpan" id="kobo.963.2">We can do this with the </span><span class="No-Break"><span class="koboSpan" id="kobo.964.1">following syntax:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.965.1">@Output()</span></strong><span class="koboSpan" id="kobo.966.1"> dataChanged = </span><strong class="bold"><span class="koboSpan" id="kobo.967.1">new EventEmitter</span></strong><span class="koboSpan" id="kobo.968.1">&lt;tableData&gt;();</span></pre> <p><span class="koboSpan" id="kobo.969.1">On the left-hand side, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">@output</span></strong><span class="koboSpan" id="kobo.971.1"> decorator and the property name for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">EventEmitter</span></strong><span class="koboSpan" id="kobo.973.1">. </span><span class="koboSpan" id="kobo.973.2">On the right-hand side, we assign the property with </span><strong class="source-inline"><span class="koboSpan" id="kobo.974.1">new EventEmitter</span></strong><span class="koboSpan" id="kobo.975.1">, and between the arrow symbols we add the type we wish to emit â€“ in this example, this </span><span class="No-Break"><span class="koboSpan" id="kobo.976.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">tableData</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.978.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.979.1">Next, you need to listen for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">dataChanged</span></strong><span class="koboSpan" id="kobo.981.1"> event in the HTML template of a parent component where the data table component would be defined. </span><span class="koboSpan" id="kobo.981.2">Listening for </span><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">@Output</span></strong><span class="koboSpan" id="kobo.983.1"> works the same as listening for regular DOM events such as </span><em class="italic"><span class="koboSpan" id="kobo.984.1">click</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.985.1">and </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.986.1">mouseleave</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.987.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.988.1">
&lt;bt-lib-table (</span><strong class="bold"><span class="koboSpan" id="kobo.989.1">dataChanged</span></strong><span class="koboSpan" id="kobo.990.1">)="handleDataChange(</span><strong class="bold"><span class="koboSpan" id="kobo.991.1">$event</span></strong><span class="koboSpan" id="kobo.992.1">)" /&gt;</span></pre> <p><span class="koboSpan" id="kobo.993.1">Between the round brackets, you can define the eventâ€™s name, similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">click</span></strong><span class="koboSpan" id="kobo.995.1">; in our example, we named the event </span><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">dataChanged</span></strong><span class="koboSpan" id="kobo.997.1">. </span><span class="koboSpan" id="kobo.997.2">On the right-hand side, you call a function youâ€™ve created in the component class of the parent component. </span><span class="koboSpan" id="kobo.997.3">So, </span><strong class="source-inline"><span class="koboSpan" id="kobo.998.1">$event</span></strong><span class="koboSpan" id="kobo.999.1"> will contain whatever values you emit from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1000.1">child component.</span></span></p>
<p><span class="koboSpan" id="kobo.1001.1">Lastly, we must </span><em class="italic"><span class="koboSpan" id="kobo.1002.1">emit</span></em><span class="koboSpan" id="kobo.1003.1"> events from</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.1004.1"> the child component</span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.1005.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">dataChanged</span></strong><span class="koboSpan" id="kobo.1007.1"> property. </span><span class="koboSpan" id="kobo.1007.2">Inside</span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.1008.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">table</span></strong><span class="koboSpan" id="kobo.1010.1"> component, whenever the data changes and you want to emit an event to the parent, you can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.1011.1">following syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1012.1">
this.dataChanged.</span><strong class="bold"><span class="koboSpan" id="kobo.1013.1">emit</span></strong><span class="koboSpan" id="kobo.1014.1">(updatedTableData);</span></pre> <p><span class="koboSpan" id="kobo.1015.1">As you can see, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1016.1">dataChanged</span></strong><span class="koboSpan" id="kobo.1017.1"> property and call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">.emit()</span></strong><span class="koboSpan" id="kobo.1019.1"> method on it. </span><span class="koboSpan" id="kobo.1019.2">You can pass whatever value you want to emit to the parent component inside the brackets. </span><span class="koboSpan" id="kobo.1019.3">In this example, that would be the updated table data. </span><span class="koboSpan" id="kobo.1019.4">To better illustrate how the input and output mechanism works, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1020.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1021.1">.1</span></em><span class="koboSpan" id="kobo.1022.1"> shows how data flows from the parent to the child and </span><span class="No-Break"><span class="koboSpan" id="kobo.1023.1">vice versa:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<span class="koboSpan" id="kobo.1024.1"><img alt="Figure 2.1: Hierarchical dependency creation" src="image/B21625_02_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1025.1">Figure 2.1: Hierarchical dependency creation</span></p>
<p><span class="koboSpan" id="kobo.1026.1">Now that you also know how to emit</span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.1027.1"> events to the parent</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.1028.1"> component</span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.1029.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">@output</span></strong><span class="koboSpan" id="kobo.1031.1"> decorator, letâ€™s explore how we can combine the input and output decorators to create custom two-way </span><span class="No-Break"><span class="koboSpan" id="kobo.1032.1">data bindings.</span></span></p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.1033.1">Two-way data binding using @Input and @Output</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.1034.1">Two-way data binding</span></strong><span class="koboSpan" id="kobo.1035.1"> lets your components listen for events</span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.1036.1"> and update the corresponding</span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.1037.1"> value simultaneously. </span><span class="koboSpan" id="kobo.1037.2">Letâ€™s say</span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.1038.1"> we have a custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.1039.1">select</span></strong><span class="koboSpan" id="kobo.1040.1"> drop-down</span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.1041.1"> component with two</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.1042.1"> input properties, one for the select options and one for the selected option. </span><span class="koboSpan" id="kobo.1042.2">Besides this, the component also has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1043.1">selectionChanged</span></strong><span class="koboSpan" id="kobo.1044.1"> output to emit a value when a new selection </span><span class="No-Break"><span class="koboSpan" id="kobo.1045.1">is made.</span></span></p>
<p><span class="koboSpan" id="kobo.1046.1">In the parent component, we have a property for the currently selected value of the select component. </span><span class="koboSpan" id="kobo.1046.2">This property is used as an input for the selected input and needs to be updated whenever a new value is selected and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">selectionChanged</span></strong><span class="koboSpan" id="kobo.1048.1"> output is emitted. </span><span class="koboSpan" id="kobo.1048.2">To achieve this, you must have something like the following inside the template of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1049.1">parent component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1050.1">
&lt;select [selected]= "selectedValue" (selectionChanged)="this.selectedValue = $event" /&gt;</span></pre> <p><span class="koboSpan" id="kobo.1051.1">We can improve the preceding</span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.1052.1"> code snippet with</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.1053.1"> two-way data binding</span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.1054.1"> and the banana-in-a-box</span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.1055.1"> syntax. </span><span class="koboSpan" id="kobo.1055.2">For two-way </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.1056.1">data binding to work, the input and output properties in the child component must have the same name; only the output needs to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">changed</span></strong><span class="koboSpan" id="kobo.1058.1"> after the name. </span><span class="koboSpan" id="kobo.1058.2">So, in our example, the input is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1059.1">selected</span></strong><span class="koboSpan" id="kobo.1060.1">, which means the output needs to be named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1061.1">selectedChanged</span></strong><span class="koboSpan" id="kobo.1062.1">. </span><span class="koboSpan" id="kobo.1062.2">When we use this naming convention, Angular knows to handle it as two-way </span><span class="No-Break"><span class="koboSpan" id="kobo.1063.1">data binding.</span></span></p>
<p><span class="koboSpan" id="kobo.1064.1">To use two-way data binding, in the parent component, we must update the HTML </span><span class="No-Break"><span class="koboSpan" id="kobo.1065.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1066.1">
&lt;select </span><strong class="bold"><span class="koboSpan" id="kobo.1067.1">[(selected)]</span></strong><span class="koboSpan" id="kobo.1068.1">= "selectedValue" /&gt;</span></pre> <p><span class="koboSpan" id="kobo.1069.1">That looks a lot cleaner! </span><span class="koboSpan" id="kobo.1069.2">With the preceding syntax, we pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1070.1">selectedValue</span></strong><span class="koboSpan" id="kobo.1071.1"> property of the parent component as an input to the selected input property of the child component. </span><span class="koboSpan" id="kobo.1071.2">When the child component emits the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1072.1">selectedChanged</span></strong><span class="koboSpan" id="kobo.1073.1"> event, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1074.1">selectedValue</span></strong><span class="koboSpan" id="kobo.1075.1"> property will automatically be updated in the parent component. </span><span class="koboSpan" id="kobo.1075.2">Take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.1076.1">following syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1077.1">
&lt;select [(selected)]= "selectedValue" /&gt;</span></pre> <p><span class="koboSpan" id="kobo.1078.1">This is the same as using </span><span class="No-Break"><span class="koboSpan" id="kobo.1079.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1080.1">
&lt;select [selected]= "selectedValue" (selectedChanged)="this. </span><span class="koboSpan" id="kobo.1080.2">selectedValue = $event" /&gt;</span></pre> <p><span class="koboSpan" id="kobo.1081.1">As you can see, the banana-in-a-box syntax combined with the square and round brackets is much cleaner and more compact. </span><span class="koboSpan" id="kobo.1081.2">Alternatively, you can use the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1082.1">model()</span></strong><span class="koboSpan" id="kobo.1083.1"> Signal that was introduced as a developer preview in Angular 17.2, but we will cover this scenario in </span><a href="B21625_07.xhtml#_idTextAnchor129"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1084.1">Chapter 7</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1085.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1086.1">Now that you know how</span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.1087.1"> to input, output, and two-way</span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.1088.1"> bind properties</span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.1089.1"> with the input</span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.1090.1"> and output</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.1091.1"> properties, letâ€™s look for another way to communicate data between components </span><span class="No-Break"><span class="koboSpan" id="kobo.1092.1">and routes.</span></span></p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.1093.1">Other component communication methods</span></h2>
<p><span class="koboSpan" id="kobo.1094.1">There are a few other means of communication for Angular components. </span><span class="koboSpan" id="kobo.1094.2">You can access public properties and methods of child components with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">@ViewChild</span></strong><span class="koboSpan" id="kobo.1096.1"> decorator, communicate with child, parent, sibling, and unconnected components with </span><em class="italic"><span class="koboSpan" id="kobo.1097.1">services</span></em><span class="koboSpan" id="kobo.1098.1">, and pass data in various manners to components with the </span><em class="italic"><span class="koboSpan" id="kobo.1099.1">router</span></em><span class="koboSpan" id="kobo.1100.1">. </span><span class="koboSpan" id="kobo.1100.2">Letâ€™s start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1102.1">ViewChild</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1103.1"> decorator.</span></span></p>
<h3><span class="koboSpan" id="kobo.1104.1">Using the @ViewChild decorator to access child components</span></h3>
<p><span class="koboSpan" id="kobo.1105.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1106.1">@ViewChild</span></strong><span class="koboSpan" id="kobo.1107.1"> decorator is used to access template</span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.1108.1"> elements inside the component class. </span><span class="koboSpan" id="kobo.1108.2">As in alternative</span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.1109.1"> to the decorator, you can also use the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1110.1">viewChild()</span></strong><span class="koboSpan" id="kobo.1111.1"> Signal that was introduced in Angular 17.2; we will cover this in more detail in </span><a href="B21625_07.xhtml#_idTextAnchor129"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1112.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.1113.1">. </span><span class="koboSpan" id="kobo.1113.2">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1114.1">@ViewChild</span></strong><span class="koboSpan" id="kobo.1115.1"> decorator to access or update child properties and methods is straightforward but has some drawbacks. </span><span class="koboSpan" id="kobo.1115.2">When using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1116.1">@ViewChild</span></strong><span class="koboSpan" id="kobo.1117.1"> to communicate with your components, you can mutate values within your child component, which can lead to unexpected behavior and bugs that are hard to debug. </span><span class="koboSpan" id="kobo.1117.2">Besides that, it makes your component hard to test. </span><span class="koboSpan" id="kobo.1117.3">If you have a scenario where you need to update properties from the child in the parent, hereâ€™s </span><span class="No-Break"><span class="koboSpan" id="kobo.1118.1">the syntax:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1119.1">@ViewChild</span></strong><span class="koboSpan" id="kobo.1120.1">(NavbarComponent) navBar!: NavbarComponent;</span></pre> <p><span class="koboSpan" id="kobo.1121.1">Here, you declare the decorator; inside the function brackets of the decorator, you enter the child componentâ€™s class name, then give it a variable name and type it with the componentâ€™s class name. </span><span class="koboSpan" id="kobo.1121.2">After the view of the parent component has been initialized, you can access the child component and its public properties and methods </span><span class="No-Break"><span class="koboSpan" id="kobo.1122.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1123.1">
this.navBar.navbarItems;</span></pre> <p><span class="koboSpan" id="kobo.1124.1">As mentioned previously, Iâ€™m not a fan of this decorator, and itâ€™s recommended not to use it unless you need to achieve something that canâ€™t be done in </span><span class="No-Break"><span class="koboSpan" id="kobo.1125.1">another way.</span></span></p>
<p><span class="koboSpan" id="kobo.1126.1">Now that you know how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1127.1">@ViewChild</span></strong><span class="koboSpan" id="kobo.1128.1"> decorator to access </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.1129.1">properties and methods in child</span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.1130.1"> components, letâ€™s explore communication through the </span><span class="No-Break"><span class="koboSpan" id="kobo.1131.1">Angular router.</span></span></p>
<h3><span class="koboSpan" id="kobo.1132.1">Component communication with the Angular router</span></h3>
<p><span class="koboSpan" id="kobo.1133.1">The </span><em class="italic"><span class="koboSpan" id="kobo.1134.1">router</span></em><span class="koboSpan" id="kobo.1135.1"> is meant to navigate between routes</span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.1136.1"> but can also send data</span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.1137.1"> to a component thatâ€™s been loaded on a route. </span><span class="koboSpan" id="kobo.1137.2">The most common examples are route parameters and additional query parameters in the route, but you can also add data to the route using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1138.1">data</span></strong><span class="koboSpan" id="kobo.1139.1"> property in the route configuration or with </span><span class="No-Break"><span class="koboSpan" id="kobo.1140.1">route resolvers.</span></span></p>
<p><span class="koboSpan" id="kobo.1141.1">Letâ€™s say we have the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1142.1">route configuration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1143.1">
const routes = [{ path: 'dashboard/:id',
Â Â Â Â component: DashboardComponent,
Â Â Â Â data: {caption: 'Dashboard caption'},
Â Â Â Â resolve: {permissions: DashboardResolver}}]</span></pre> <p><span class="koboSpan" id="kobo.1144.1">We also have this URL in our </span><span class="No-Break"><span class="koboSpan" id="kobo.1145.1">browser: </span></span><a href="https://some-url.com/dashboard/123?queryParam=paramValue"><span class="No-Break"><span class="koboSpan" id="kobo.1146.1">https://some-url.com/dashboard/123?queryParam=paramValue</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1147.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1148.1">When we reach this route, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1149.1">dashboard</span></strong><span class="koboSpan" id="kobo.1150.1"> component will be loaded. </span><span class="koboSpan" id="kobo.1150.2">In that component, we can access the dashboard ID, the caption we added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1151.1">data</span></strong><span class="koboSpan" id="kobo.1152.1"> property, the resolved permission data, and the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1153.1">query</span></strong><span class="koboSpan" id="kobo.1154.1"> parameter. </span><span class="koboSpan" id="kobo.1154.2">To do so, you need to inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.1155.1">ActivatedRoute</span></strong><span class="koboSpan" id="kobo.1156.1"> into the constructor or use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1157.1">inject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1158.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1159.1">
private route = inject(ActivatedRoute);</span></pre> <p><span class="koboSpan" id="kobo.1160.1">After that, you can access the properties in the route snapshot </span><span class="No-Break"><span class="koboSpan" id="kobo.1161.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1162.1">
this.route.snapshot.paramMap.get('id');
this.route.snapshot.queryParamMap.get('queryParam');
this.route.snapshot.data['caption'];
this.route.snapshot.data['permissions'];</span></pre> <p><span class="koboSpan" id="kobo.1163.1">You can also access the properties more reactively by subscribing â€“ just remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1164.1">snapshot</span></strong><span class="koboSpan" id="kobo.1165.1"> property and then add your subscription logic instead of accessing the properties through the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1166.1">get</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1167.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1168.1">
this.route.queryParamMap.subscribe(â€¦â€¦)</span></pre> <p><span class="koboSpan" id="kobo.1169.1">You can subscribe to the routerâ€™s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1170.1">paramMap</span></strong><span class="koboSpan" id="kobo.1171.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1172.1">queryParamMap</span></strong><span class="koboSpan" id="kobo.1173.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1174.1">data</span></strong><span class="koboSpan" id="kobo.1175.1"> objects. </span><span class="koboSpan" id="kobo.1175.2">Since Angular 16, you can also directly bind the route values to your componentâ€™s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">@Input()</span></strong><span class="koboSpan" id="kobo.1177.1"> decorators. </span><span class="koboSpan" id="kobo.1177.2">To achieve this, you need to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">withComponentInputBinding</span></strong><span class="koboSpan" id="kobo.1179.1"> to your app config where you provide </span><span class="No-Break"><span class="koboSpan" id="kobo.1180.1">your routes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1181.1">
provideRouter(appRoutes, </span><strong class="bold"><span class="koboSpan" id="kobo.1182.1">withComponentInputBinding()</span></strong><span class="koboSpan" id="kobo.1183.1">),</span></pre> <p><span class="koboSpan" id="kobo.1184.1">Next, you can define the inputs in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1185.1">component</span></strong><span class="koboSpan" id="kobo.1186.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.1187.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1188.1">
@Input() caption?: string;
@Input() id?: string;
@Input() queryParam?: string;
@Input() permissions?: string;</span></pre> <p><span class="koboSpan" id="kobo.1189.1">If you want to use a different property name, you can alias the inputs </span><span class="No-Break"><span class="koboSpan" id="kobo.1190.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1191.1">
@Input(</span><strong class="bold"><span class="koboSpan" id="kobo.1192.1">'caption'</span></strong><span class="koboSpan" id="kobo.1193.1">) </span><strong class="bold"><span class="koboSpan" id="kobo.1194.1">captionFromRouteData</span></strong><span class="koboSpan" id="kobo.1195.1">?: string;</span></pre> <p><span class="koboSpan" id="kobo.1196.1">This will probably give you a linting error because aliasing inputs is not recommended, but when using input aliases for binding your route data, itâ€™s not a bad practice. </span><span class="koboSpan" id="kobo.1196.2">So, in this case, you can disable</span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.1197.1"> the linting rule if itâ€™s throwing</span><a id="_idIndexMarker232"/> <span class="No-Break"><span class="koboSpan" id="kobo.1198.1">an error.</span></span></p>
<p><span class="koboSpan" id="kobo.1199.1">Now that you know everything about component communication using decorators and route data, we will start to look at dependency injection, which can be used to provide data to every part of </span><span class="No-Break"><span class="koboSpan" id="kobo.1200.1">your application.</span></span></p>
<h1 id="_idParaDest-52"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.1201.1">Dependency injection</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.1202.1">Dependency injection</span></strong><span class="koboSpan" id="kobo.1203.1"> is one of the cornerstones of the Angular</span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.1204.1"> framework. </span><span class="koboSpan" id="kobo.1204.2">Angular relies on the dependency injection design pattern to manage the relationships and interactions between different elements within an application. </span><span class="koboSpan" id="kobo.1204.3">When using dependency injection, there</span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.1205.1"> are two main roles: the </span><strong class="bold"><span class="koboSpan" id="kobo.1206.1">providers</span></strong><span class="koboSpan" id="kobo.1207.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1208.1">consumers</span></strong><span class="koboSpan" id="kobo.1209.1"> of the dependencies. </span><span class="koboSpan" id="kobo.1209.2">As such, Angular</span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.1210.1"> dependency injection lets you provide logic or data to sections of your application that need to consume the given logic or data. </span><span class="koboSpan" id="kobo.1210.2">Dependency injection is vital for developing loosely coupled applications with more modular, testable, and maintainable code. </span><span class="koboSpan" id="kobo.1210.3">Generally speaking, dependencies in an Angular application are services (classes decorated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1211.1">@Injectable()</span></strong><span class="koboSpan" id="kobo.1212.1"> decorator), but they can be strings, functions, or anything else you want to provide throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.1213.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.1214.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1215.1">Injector</span></strong><span class="koboSpan" id="kobo.1216.1"> abstraction is the core element of the Angular dependency injection system and facilitates the connection between providers and consumers of your dependencies. </span><span class="koboSpan" id="kobo.1216.2">Make sure you distinguish </span><strong class="source-inline"><span class="koboSpan" id="kobo.1217.1">Injector</span></strong><span class="koboSpan" id="kobo.1218.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1219.1">@Injectable()</span></strong><span class="koboSpan" id="kobo.1220.1"> decorator, which marks a class as a candidate for dependency injection. </span><span class="koboSpan" id="kobo.1220.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1221.1">Injector</span></strong><span class="koboSpan" id="kobo.1222.1"> abstraction checks if an instance of a dependency has already been created and provides it if the dependency has already been registered; it provides the dependency and registers if it hasnâ€™t been registered before. </span><span class="koboSpan" id="kobo.1222.2">When your application is bootstrapped, Angular creates an application-wide </span><em class="italic"><span class="koboSpan" id="kobo.1223.1">root</span></em> <strong class="source-inline"><span class="koboSpan" id="kobo.1224.1">Injector</span></strong><span class="koboSpan" id="kobo.1225.1"> and makes other injectors as needed for all dependencies</span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.1226.1"> that arenâ€™t accessible throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.1227.1">the application.</span></span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.1228.1">Providing dependencies</span></h2>
<p><span class="koboSpan" id="kobo.1229.1">You can provide classes and other values</span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.1230.1"> such as strings, dates, objects, and functions as dependencies. </span><span class="koboSpan" id="kobo.1230.2">Both are provided differently. </span><span class="koboSpan" id="kobo.1230.3">We will start with the most common use case, which is </span><span class="No-Break"><span class="koboSpan" id="kobo.1231.1">providing classes.</span></span></p>
<h3><span class="koboSpan" id="kobo.1232.1">Providing classes as dependencies</span></h3>
<p><span class="koboSpan" id="kobo.1233.1">When you provide a class</span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.1234.1"> in Angular, itâ€™s most likely an Angular service, but you can provide any class through dependency injection. </span><span class="koboSpan" id="kobo.1234.2">The most common way to prepare a class for dependency injection is to decorate it with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1235.1">@Injectable()</span></strong><span class="koboSpan" id="kobo.1236.1"> decorator, </span><span class="No-Break"><span class="koboSpan" id="kobo.1237.1">like this:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1238.1">@Injectable()</span></strong><span class="koboSpan" id="kobo.1239.1">
class SampleService {}</span></pre> <p><span class="koboSpan" id="kobo.1240.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1241.1">@Injectable()</span></strong><span class="koboSpan" id="kobo.1242.1"> decorator shows a class is used for dependency injection; you can do this by marking it as a root injector or by adding it inside a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1243.1">providers</span></strong><span class="koboSpan" id="kobo.1244.1"> array of a specific component or ngModule. </span><span class="koboSpan" id="kobo.1244.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1245.1">@Injectable()</span></strong><span class="koboSpan" id="kobo.1246.1"> decorator also ensures Angular can perform optimizations such as tree shaking. </span><span class="koboSpan" id="kobo.1246.2">You can also provide classes without the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1247.1">@Injectable()</span></strong><span class="koboSpan" id="kobo.1248.1"> decorator inside your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1249.1">providers</span></strong><span class="koboSpan" id="kobo.1250.1"> array, but itâ€™s a good practice to mark them with the decorator unless you need to provide the classes in a specific place. </span><span class="koboSpan" id="kobo.1250.2">Hereâ€™s an example of how to provide a service inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1251.1">providers</span></strong><span class="koboSpan" id="kobo.1252.1"> array of </span><span class="No-Break"><span class="koboSpan" id="kobo.1253.1">a component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1254.1">
@Component({â€¦â€¦â€¦ , </span><strong class="bold"><span class="koboSpan" id="kobo.1255.1">providers</span></strong><span class="koboSpan" id="kobo.1256.1">: [SampleService] })
class ListComponent {}</span></pre> <p><span class="koboSpan" id="kobo.1257.1">When using the</span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.1258.1"> component-level </span><strong class="source-inline"><span class="koboSpan" id="kobo.1259.1">providers</span></strong><span class="koboSpan" id="kobo.1260.1"> array, the provided dependency becomes available for dependency injection for each component instance and all child components or directives used within the componentâ€™s tree. </span><span class="koboSpan" id="kobo.1260.2">If you add a dependency inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1261.1">providers</span></strong><span class="koboSpan" id="kobo.1262.1"> array of an ngModule, the dependency can be injected and accessed everywhere within that module. </span><span class="koboSpan" id="kobo.1262.2">You can declare classes inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1263.1">providers</span></strong><span class="koboSpan" id="kobo.1264.1"> array of your modules </span><span class="No-Break"><span class="koboSpan" id="kobo.1265.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1266.1">
@NgModule({ declarations: [ListComponent],
Â Â </span><strong class="bold"><span class="koboSpan" id="kobo.1267.1">providers</span></strong><span class="koboSpan" id="kobo.1268.1">: [SampleService]})
class AppModule {}</span></pre> <p><span class="koboSpan" id="kobo.1269.1">In our </span><em class="italic"><span class="koboSpan" id="kobo.1270.1">expenses-registration application</span></em><span class="koboSpan" id="kobo.1271.1">, we donâ€™t have ngModules. </span><span class="koboSpan" id="kobo.1271.2">When developing an Angular application without ngModules, you can provide dependencies inside your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1272.1">ApplicationConfig</span></strong><span class="koboSpan" id="kobo.1273.1"> object; this is similar to marking a dependency as a root injector because it will be available for dependency injection throughout your application. </span><span class="koboSpan" id="kobo.1273.2">Adding classes to your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1274.1">providers</span></strong><span class="koboSpan" id="kobo.1275.1"> array inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1276.1">ApplicationConfig</span></strong><span class="koboSpan" id="kobo.1277.1"> objects works </span><span class="No-Break"><span class="koboSpan" id="kobo.1278.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1279.1">
export const appConfig: ApplicationConfig = {
Â Â </span><strong class="bold"><span class="koboSpan" id="kobo.1280.1">providers</span></strong><span class="koboSpan" id="kobo.1281.1">: [SampleService],
};</span></pre> <p><span class="koboSpan" id="kobo.1282.1">Lastly, the most common way to provide your classes as dependencies is by marking the class as a </span><em class="italic"><span class="koboSpan" id="kobo.1283.1">root</span></em><span class="koboSpan" id="kobo.1284.1"> injector. </span><span class="koboSpan" id="kobo.1284.2">You can do this inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1285.1">@Injectable()</span></strong><span class="koboSpan" id="kobo.1286.1"> decorator with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1287.1">providedIn</span></strong><span class="koboSpan" id="kobo.1288.1"> property, </span><span class="No-Break"><span class="koboSpan" id="kobo.1289.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1290.1">
@Injectable(</span><strong class="bold"><span class="koboSpan" id="kobo.1291.1">{ providedIn: 'root' }</span></strong><span class="koboSpan" id="kobo.1292.1">)</span></pre> <p><span class="koboSpan" id="kobo.1293.1">Now that you know how to provide</span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.1294.1"> classes as dependencies with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1295.1">@Injectable()</span></strong><span class="koboSpan" id="kobo.1296.1"> decorator, letâ€™s learn how to provide classes and other values such as strings, Booleans, and functions using </span><span class="No-Break"><span class="koboSpan" id="kobo.1297.1">provider objects.</span></span></p>
<h3><span class="koboSpan" id="kobo.1298.1">Providing dependencies with provider objects</span></h3>
<p><span class="koboSpan" id="kobo.1299.1">When you provide</span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.1300.1"> dependencies with a </span><strong class="bold"><span class="koboSpan" id="kobo.1301.1">provider object</span></strong><span class="koboSpan" id="kobo.1302.1">, you always declare</span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.1303.1"> them inside a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1304.1">providers</span></strong><span class="koboSpan" id="kobo.1305.1"> array. </span><span class="koboSpan" id="kobo.1305.2">You can use two properties to declare a dependency with a </span><span class="No-Break"><span class="koboSpan" id="kobo.1306.1">provider object:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1307.1">Provide</span></strong><span class="koboSpan" id="kobo.1308.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1309.1">provide</span></strong><span class="koboSpan" id="kobo.1310.1"> property holds the </span><strong class="bold"><span class="koboSpan" id="kobo.1311.1">provider token</span></strong><span class="koboSpan" id="kobo.1312.1"> thatâ€™s used to identify and inject your </span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.1313.1">dependencies. </span><span class="koboSpan" id="kobo.1313.2">Itâ€™s also used to configure the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1314.1">Injector</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1315.1"> instance.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1316.1">Provider definition</span></strong><span class="koboSpan" id="kobo.1317.1">: The second property is used to tell </span><strong class="source-inline"><span class="koboSpan" id="kobo.1318.1">Injector</span></strong><span class="koboSpan" id="kobo.1319.1"> how to create the dependency, and it can be defined with </span><span class="No-Break"><span class="koboSpan" id="kobo.1320.1">four values:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.1321.1">useClass</span></strong><span class="koboSpan" id="kobo.1322.1">: This tells Angular to provide the given class when the corresponding provider token </span><span class="No-Break"><span class="koboSpan" id="kobo.1323.1">is used</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.1324.1">useExisting</span></strong><span class="koboSpan" id="kobo.1325.1">: This aliases another provider token and accesses the same dependency with two </span><span class="No-Break"><span class="koboSpan" id="kobo.1326.1">different tokens</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.1327.1">useFactory</span></strong><span class="koboSpan" id="kobo.1328.1">: This defines a factory function to construct the dependencies based on </span><span class="No-Break"><span class="koboSpan" id="kobo.1329.1">some logic</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.1330.1">useValue</span></strong><span class="koboSpan" id="kobo.1331.1">: This provides a static value such as a string or date as </span><span class="No-Break"><span class="koboSpan" id="kobo.1332.1">a dependency</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.1333.1">Now, letâ€™s explore the four provider definitions in </span><span class="No-Break"><span class="koboSpan" id="kobo.1334.1">more detail.</span></span></p>
<h4><span class="koboSpan" id="kobo.1335.1">Declaring provider objects with useClass</span></h4>
<p><span class="koboSpan" id="kobo.1336.1">Hereâ€™s an example of a provider</span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.1337.1"> object using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1338.1">useClass</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1339.1">provider definition:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1340.1">
providers: [{ provide: Logger, </span><strong class="bold"><span class="koboSpan" id="kobo.1341.1">useClass</span></strong><span class="koboSpan" id="kobo.1342.1">: Logger }]</span></pre> <p><span class="koboSpan" id="kobo.1343.1">The preceding syntax is the same as using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1344.1">following syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1345.1">
providers: [Logger]</span></pre> <p><span class="koboSpan" id="kobo.1346.1">In the scenario where you only supply a class name, the provider object is automatically created behind the scenes. </span><span class="koboSpan" id="kobo.1346.2">The provider object uses the class for the provider token and definition, so when would you use the provider object instead of only using </span><span class="No-Break"><span class="koboSpan" id="kobo.1347.1">the class?</span></span></p>
<p><span class="koboSpan" id="kobo.1348.1">Commonly, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1349.1">useClass</span></strong><span class="koboSpan" id="kobo.1350.1"> is used when you want to overwrite a dependency injection class with a new implementation. </span><span class="koboSpan" id="kobo.1350.2">In the preceding example, we provided a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1351.1">Logger</span></strong><span class="koboSpan" id="kobo.1352.1"> class; letâ€™s say you create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1353.1">BetterLogger</span></strong><span class="koboSpan" id="kobo.1354.1"> class extending the original </span><strong class="source-inline"><span class="koboSpan" id="kobo.1355.1">Logger</span></strong><span class="koboSpan" id="kobo.1356.1"> class. </span><span class="koboSpan" id="kobo.1356.2">If you have a large application and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1357.1">Logger</span></strong><span class="koboSpan" id="kobo.1358.1"> service is used throughout your application, itâ€™s a lot of work to change the service everywhere itâ€™s declared. </span><span class="koboSpan" id="kobo.1358.2">Instead of updating all dependency injection consumers, you can create a provider object and return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1359.1">BetterLogger</span></strong><span class="koboSpan" id="kobo.1360.1"> class for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1361.1">Logger</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1362.1"> token:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1363.1">
providers: [{ provide: Logger, useClass: BetterLogger }]</span></pre> <p><span class="koboSpan" id="kobo.1364.1">If you provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1365.1">Logger</span></strong><span class="koboSpan" id="kobo.1366.1"> service inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1367.1">providers</span></strong><span class="koboSpan" id="kobo.1368.1"> array as well, you must make sure that you declare the new provider object with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1369.1">BetterLogger</span></strong><span class="koboSpan" id="kobo.1370.1"> class below your previous provider object, or simply remove the old object. </span><span class="koboSpan" id="kobo.1370.2">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1371.1">Logger</span></strong><span class="koboSpan" id="kobo.1372.1"> service is provided using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1373.1">providedIn</span></strong><span class="koboSpan" id="kobo.1374.1"> property inside the injectable decorator, the overwrite with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1375.1">BetterLogger</span></strong><span class="koboSpan" id="kobo.1376.1"> will just work without </span><span class="No-Break"><span class="koboSpan" id="kobo.1377.1">any gotchas.</span></span></p>
<p><span class="koboSpan" id="kobo.1378.1">Now that you know how to create provider objects with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1379.1">useClass</span></strong><span class="koboSpan" id="kobo.1380.1"> provider definition, letâ€™s examine the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1381.1">useExisting</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1382.1">provider definition.</span></span></p>
<h4><span class="koboSpan" id="kobo.1383.1">Declaring provider objects with useExisting</span></h4>
<p><span class="koboSpan" id="kobo.1384.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1385.1">useExisting</span></strong><span class="koboSpan" id="kobo.1386.1"> property allows</span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.1387.1"> you to map one provider token to another provider token, making sure two tokens will return the </span><span class="No-Break"><span class="koboSpan" id="kobo.1388.1">same dependency:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1389.1">
providers: [ BetterLogger,
Â Â { provide: Logger, </span><strong class="bold"><span class="koboSpan" id="kobo.1390.1">useExisting</span></strong><span class="koboSpan" id="kobo.1391.1">: BetterLogger}]</span></pre> <p><span class="koboSpan" id="kobo.1392.1">In the preceding example, you can inject the better logger using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1393.1">BetterLogger</span></strong><span class="koboSpan" id="kobo.1394.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1395.1">Logger</span></strong><span class="koboSpan" id="kobo.1396.1"> tokens. </span><span class="koboSpan" id="kobo.1396.2">Both will provide the same instance of the service. </span><span class="koboSpan" id="kobo.1396.3">Be careful not to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1397.1">useClass</span></strong><span class="koboSpan" id="kobo.1398.1"> definition </span><span class="No-Break"><span class="koboSpan" id="kobo.1399.1">for this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1400.1">
providers: [ BetterLogger,
Â Â { provide: Logger, </span><strong class="bold"><span class="koboSpan" id="kobo.1401.1">useClass</span></strong><span class="koboSpan" id="kobo.1402.1">: BetterLogger}]</span></pre> <p><span class="koboSpan" id="kobo.1403.1">You might think the preceding example gives the same result, but it creates two tokens called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1404.1">Logger</span></strong><span class="koboSpan" id="kobo.1405.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1406.1">BetterLogger</span></strong><span class="koboSpan" id="kobo.1407.1"> that each return an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1408.1">BetterLogger</span></strong><span class="koboSpan" id="kobo.1409.1"> class instead</span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.1410.1"> of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1411.1">same instance.</span></span></p>
<p><span class="koboSpan" id="kobo.1412.1">Now that you know about </span><strong class="source-inline"><span class="koboSpan" id="kobo.1413.1">useExisting</span></strong><span class="koboSpan" id="kobo.1414.1">, letâ€™s </span><span class="No-Break"><span class="koboSpan" id="kobo.1415.1">explore </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1416.1">useFactory</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1417.1">.</span></span></p>
<h4><span class="koboSpan" id="kobo.1418.1">Declaring provider objects with useFactory</span></h4>
<p><span class="koboSpan" id="kobo.1419.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1420.1">useFactory</span></strong><span class="koboSpan" id="kobo.1421.1"> provider definition</span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.1422.1"> allows you to define a function as a dependency. </span><span class="koboSpan" id="kobo.1422.2">This can be just a regular function you want to inject into multiple places of your application or a factory function that constructs a service class. </span><span class="koboSpan" id="kobo.1422.3">Letâ€™s say you have </span><strong class="source-inline"><span class="koboSpan" id="kobo.1423.1">AdminDashboardService</span></strong><span class="koboSpan" id="kobo.1424.1"> and a regular </span><strong class="source-inline"><span class="koboSpan" id="kobo.1425.1">DashboardService</span></strong><span class="koboSpan" id="kobo.1426.1"> you want to inject using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1427.1">DashboardService</span></strong><span class="koboSpan" id="kobo.1428.1"> tokens, depending on the active user role. </span><span class="koboSpan" id="kobo.1428.2">You can achieve this with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1429.1">useFactory</span></strong><span class="koboSpan" id="kobo.1430.1">. </span><span class="koboSpan" id="kobo.1430.2">First, create your </span><span class="No-Break"><span class="koboSpan" id="kobo.1431.1">factory function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1432.1">
const DashboardServiceFactory = (userService: UserService) =&gt; userService.user.isAdmin ? </span><span class="koboSpan" id="kobo.1432.2">new AdminDashboardService() : new DashboardService();</span></pre> <p><span class="koboSpan" id="kobo.1433.1">Next, declare the provider object inside your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1434.1">providers</span></strong><span class="koboSpan" id="kobo.1435.1"> array, </span><span class="No-Break"><span class="koboSpan" id="kobo.1436.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1437.1">
{ provide: DashboardService,
Â Â </span><strong class="bold"><span class="koboSpan" id="kobo.1438.1">useFactory</span></strong><span class="koboSpan" id="kobo.1439.1">: DashboardServiceFactory, </span><strong class="bold"><span class="koboSpan" id="kobo.1440.1">deps</span></strong><span class="koboSpan" id="kobo.1441.1">: [UserService]}</span></pre> <p><span class="koboSpan" id="kobo.1442.1">The factory function relies on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1443.1">UserService</span></strong><span class="koboSpan" id="kobo.1444.1"> to check if the current user is an admin user. </span><span class="koboSpan" id="kobo.1444.2">Because of this, you need to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.1445.1">UserService</span></strong><span class="koboSpan" id="kobo.1446.1"> inside a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1447.1">deps</span></strong><span class="koboSpan" id="kobo.1448.1"> array of your </span><span class="No-Break"><span class="koboSpan" id="kobo.1449.1">provider object.</span></span></p>
<p><span class="koboSpan" id="kobo.1450.1">Now that you know more about </span><strong class="source-inline"><span class="koboSpan" id="kobo.1451.1">useFactory</span></strong><span class="koboSpan" id="kobo.1452.1">, letâ€™s </span><span class="No-Break"><span class="koboSpan" id="kobo.1453.1">export </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1454.1">useValue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1455.1">.</span></span></p>
<h4><span class="koboSpan" id="kobo.1456.1">Declaring provider objects with useValue</span></h4>
<p><span class="koboSpan" id="kobo.1457.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1458.1">useValue</span></strong><span class="koboSpan" id="kobo.1459.1"> provider definition</span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.1460.1"> is the simplest one. </span><span class="koboSpan" id="kobo.1460.2">It returns a constant value such as a string, date, or Boolean. </span><span class="koboSpan" id="kobo.1460.3">Itâ€™s useful for providing things such as a base website URL, base API URLs, or other </span><span class="No-Break"><span class="koboSpan" id="kobo.1461.1">constant values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1462.1">
{ provide: BASE_URL, </span><strong class="bold"><span class="koboSpan" id="kobo.1463.1">useValue</span></strong><span class="koboSpan" id="kobo.1464.1">: 'www.someurl.com/'}</span></pre> <p><span class="koboSpan" id="kobo.1465.1">Now that you know about all four provider definitions, letâ€™s explore the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1466.1">InjectionToken</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1467.1"> object.</span></span></p>
<h3><span class="koboSpan" id="kobo.1468.1">Using InjectionToken as a provider token</span></h3>
<p><span class="koboSpan" id="kobo.1469.1">When you declare</span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.1470.1"> a provider object, you supply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1471.1">provide</span></strong><span class="koboSpan" id="kobo.1472.1"> property </span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.1473.1">with a provider token. </span><span class="koboSpan" id="kobo.1473.2">The provider token is used to inject the dependency into the consumers of the dependency. </span><span class="koboSpan" id="kobo.1473.3">You can use three values for the provider token, but only two should be used. </span><span class="koboSpan" id="kobo.1473.4">You can use a class name, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1474.1">InjectionToken</span></strong><span class="koboSpan" id="kobo.1475.1">, or a string. </span><span class="koboSpan" id="kobo.1475.2">Only the class name and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1476.1">InjectionToken</span></strong><span class="koboSpan" id="kobo.1477.1"> should be used. </span><span class="koboSpan" id="kobo.1477.2">When providing a class-based dependency, you should use the class name as the provider token; when using a non-class-based dependency, you should use an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1478.1">InjectionToken</span></strong><span class="koboSpan" id="kobo.1479.1"> object. </span><span class="koboSpan" id="kobo.1479.2">You can create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1480.1">InjectionToken</span></strong><span class="koboSpan" id="kobo.1481.1"> object </span><span class="No-Break"><span class="koboSpan" id="kobo.1482.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1483.1">
export const BASE_URL = </span><strong class="bold"><span class="koboSpan" id="kobo.1484.1">new InjectionToken</span></strong><span class="koboSpan" id="kobo.1485.1">&lt;string&gt;('URL');</span></pre> <p><span class="koboSpan" id="kobo.1486.1">You can export a constant, give it a name â€“ in our case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1487.1">BASE_URL</span></strong><span class="koboSpan" id="kobo.1488.1"> â€“ and assign it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1489.1">new InjectionToken</span></strong><span class="koboSpan" id="kobo.1490.1">. </span><span class="koboSpan" id="kobo.1490.2">The value between the arrow brackets is the type of your dependency â€“ in this example, a string â€“ and the value between the round brackets is a description for your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1491.1">InjectionToken</span></strong><span class="koboSpan" id="kobo.1492.1">. </span><span class="koboSpan" id="kobo.1492.2">Now, you can use this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1493.1">InjectionToken</span></strong><span class="koboSpan" id="kobo.1494.1"> in a provider object </span><span class="No-Break"><span class="koboSpan" id="kobo.1495.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1496.1">
{ provide: BASE_URL, useValue: 'www.someurl.com/'}</span></pre> <p><span class="koboSpan" id="kobo.1497.1">When assigning a provider token, you can also use a simple string </span><span class="No-Break"><span class="koboSpan" id="kobo.1498.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1499.1">
{ provide: </span><strong class="bold"><span class="koboSpan" id="kobo.1500.1">'BASE_URL'</span></strong><span class="koboSpan" id="kobo.1501.1">, useValue: 'www.someurl.com/'}</span></pre> <p><span class="koboSpan" id="kobo.1502.1">But there are some reasons why you should always use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1503.1">InjectionToken</span></strong><span class="koboSpan" id="kobo.1504.1"> instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.1505.1">a string:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1506.1">InjectionToken</span></strong><span class="koboSpan" id="kobo.1507.1"> objects are type-safe and allow TypeScript to perform type-checking on your injected value. </span><span class="koboSpan" id="kobo.1507.2">When you use a simple string, the compiler will not know what type your </span><span class="No-Break"><span class="koboSpan" id="kobo.1508.1">dependency is.</span></span></li>
<li><span class="koboSpan" id="kobo.1509.1">When using a string, you can run into name collisions, meaning you can assign two dependencies with the same string, which can result in wrongly injected values, errors, and bugs. </span><span class="koboSpan" id="kobo.1509.2">This doesnâ€™t have to be because you define two dependencies with the same string; it can also happen when a dependency you use from a third-party library uses the same string as a provider token. </span><span class="koboSpan" id="kobo.1509.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1510.1">InjectionToken</span></strong><span class="koboSpan" id="kobo.1511.1"> object ensures a unique value is used for your </span><span class="No-Break"><span class="koboSpan" id="kobo.1512.1">provider token.</span></span></li>
<li><span class="koboSpan" id="kobo.1513.1">When you minify your code during the production build, string values can be renamed. </span><span class="koboSpan" id="kobo.1513.2">This can result in problems with your dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.1514.1">injection system.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1515.1">Now that you know how</span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.1516.1"> to provide dependencies</span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.1517.1"> and what </span><strong class="source-inline"><span class="koboSpan" id="kobo.1518.1">InjectionToken</span></strong><span class="koboSpan" id="kobo.1519.1"> objects are, letâ€™s learn how to inject and </span><span class="No-Break"><span class="koboSpan" id="kobo.1520.1">consume dependencies.</span></span></p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.1521.1">Injecting dependencies</span></h2>
<p><span class="koboSpan" id="kobo.1522.1">There are two ways</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.1523.1"> to inject dependencies: </span><strong class="bold"><span class="koboSpan" id="kobo.1524.1">constructor injection</span></strong><span class="koboSpan" id="kobo.1525.1"> or the new </span><strong class="bold"><span class="koboSpan" id="kobo.1526.1">inject function</span></strong><span class="koboSpan" id="kobo.1527.1"> introduced in Angular 14. </span><span class="koboSpan" id="kobo.1527.2">At their core, both constructor injection</span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.1528.1"> and the inject function</span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.1529.1"> do the same thing, but with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1530.1">inject</span></strong><span class="koboSpan" id="kobo.1531.1"> function, you can improve some architectural patterns and inject values in places where you donâ€™t have a constructor. </span><span class="koboSpan" id="kobo.1531.2">You can inject services everywhere within your Angular applications â€“ in component classes, services, other classes, and even in functions you export. </span><span class="koboSpan" id="kobo.1531.3">Letâ€™s examine how to inject class-based dependencies using constructor injection and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1532.1">inject</span></strong><span class="koboSpan" id="kobo.1533.1"> function, starting with </span><span class="No-Break"><span class="koboSpan" id="kobo.1534.1">constructor injection:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1535.1">
constructor(private logger: LoggerService) {}</span></pre> <p><span class="koboSpan" id="kobo.1536.1">Doing the same thing with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1537.1">inject</span></strong><span class="koboSpan" id="kobo.1538.1"> function looks </span><span class="No-Break"><span class="koboSpan" id="kobo.1539.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1540.1">
private logger = </span><strong class="bold"><span class="koboSpan" id="kobo.1541.1">inject</span></strong><span class="koboSpan" id="kobo.1542.1">(LoggerService);</span></pre> <p><span class="koboSpan" id="kobo.1543.1">You can use the two examples mentioned here interchangeably; both achieve the same thing, only with different syntax. </span><span class="koboSpan" id="kobo.1543.2">When injecting class-based dependencies, you inject the dependency using the provider token, which is typically the class name. </span><span class="koboSpan" id="kobo.1543.3">When you inject non-class-based dependencies, you need to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1544.1">InjectionToken</span></strong><span class="koboSpan" id="kobo.1545.1"> as a provider token. </span><span class="koboSpan" id="kobo.1545.2">The syntax to do this is slightly different in the case of constructor injection. </span><span class="koboSpan" id="kobo.1545.3">You need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1546.1">@Inject()</span></strong><span class="koboSpan" id="kobo.1547.1"> decorator function inside your constructor </span><span class="No-Break"><span class="koboSpan" id="kobo.1548.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1549.1">
constructor(</span><strong class="bold"><span class="koboSpan" id="kobo.1550.1">@Inject</span></strong><span class="koboSpan" id="kobo.1551.1">(BASE_URL) private baseUrl: string) {}</span></pre> <p><span class="koboSpan" id="kobo.1552.1">Injecting </span><strong class="source-inline"><span class="koboSpan" id="kobo.1553.1">InjectionToken</span></strong><span class="koboSpan" id="kobo.1554.1">-based dependencies with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1555.1">inject</span></strong><span class="koboSpan" id="kobo.1556.1"> function can be done </span><span class="No-Break"><span class="koboSpan" id="kobo.1557.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1558.1">
private logger = inject(LoggerService);</span></pre> <p><span class="koboSpan" id="kobo.1559.1">As you can see, you donâ€™t need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1560.1">@Inject()</span></strong><span class="koboSpan" id="kobo.1561.1"> decorator for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1562.1">inject</span></strong><span class="koboSpan" id="kobo.1563.1"> function; you can simply use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1564.1">InjectionToken</span></strong><span class="koboSpan" id="kobo.1565.1"> inside the function brackets of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1566.1">inject</span></strong><span class="koboSpan" id="kobo.1567.1"> function, and the rest is done for you. </span><span class="koboSpan" id="kobo.1567.2">After injecting a dependency, you can use it like any </span><span class="No-Break"><span class="koboSpan" id="kobo.1568.1">other value:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1569.1">this.logger</span></strong><span class="koboSpan" id="kobo.1570.1">.logValue('Value to log');Â Â Â Â Â Â </span><strong class="bold"><span class="koboSpan" id="kobo.1571.1">this.baseUrl</span></strong><span class="koboSpan" id="kobo.1572.1">;</span></pre> <p><span class="koboSpan" id="kobo.1573.1">Now that you know how to inject</span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.1574.1"> dependencies, letâ€™s dive deeper into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1575.1">inject</span></strong><span class="koboSpan" id="kobo.1576.1"> function, why you should use it instead of contractor injection, and where to declare the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1577.1">inject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1578.1"> function.</span></span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.1579.1">Using the inject function for better dependency injection</span></h2>
<p><span class="koboSpan" id="kobo.1580.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1581.1">inject</span></strong><span class="koboSpan" id="kobo.1582.1"> function is more flexible</span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.1583.1"> than constructor injection</span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.1584.1"> because it can be used in more places and works better when using inheritance. </span><span class="koboSpan" id="kobo.1584.2">You can declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1585.1">inject</span></strong><span class="koboSpan" id="kobo.1586.1"> function anywhere, but it needs to run inside the </span><em class="italic"><span class="koboSpan" id="kobo.1587.1">injection context</span></em><span class="koboSpan" id="kobo.1588.1">; otherwise, youâ€™ll get an error. </span><span class="koboSpan" id="kobo.1588.2">The injection context is inside the constructor of a class, where you initialize fields inside a class inside the factory function of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1589.1">useFactory</span></strong><span class="koboSpan" id="kobo.1590.1">, route guards, route resolvers, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1591.1">HTTP interceptors:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1592.1">
export class AppComponent {
Â Â private url = inject(BASE_URL); </span><strong class="bold"><span class="koboSpan" id="kobo.1593.1">// Is injection context</span></strong><span class="koboSpan" id="kobo.1594.1">
Â Â constructor() { </span><strong class="bold"><span class="koboSpan" id="kobo.1595.1">// Is injection context</span></strong><span class="koboSpan" id="kobo.1596.1"> }
Â Â someMethod() { </span><strong class="bold"><span class="koboSpan" id="kobo.1597.1">// No injection context</span></strong><span class="koboSpan" id="kobo.1598.1"> }
}</span></pre> <p><span class="koboSpan" id="kobo.1599.1">One of the main advantages of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1600.1">inject</span></strong><span class="koboSpan" id="kobo.1601.1"> function is that it allows you to abstract logic into a function. </span><span class="koboSpan" id="kobo.1601.2">Letâ€™s say you want to fetch dashboards; you can abstract this logic into a separate function using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1602.1">inject</span></strong><span class="koboSpan" id="kobo.1603.1"> function. </span><span class="koboSpan" id="kobo.1603.2">To do this, you can create a function </span><span class="No-Break"><span class="koboSpan" id="kobo.1604.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1605.1">
export const fetchDashboards = (): Observable&lt;Dashboard[]&gt; =&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.1606.1">inject</span></strong><span class="koboSpan" id="kobo.1607.1">(HttpClient).get&lt;Dashboard[]&gt;('api/dashboards');</span></pre> <p><span class="koboSpan" id="kobo.1608.1">Here, we use an arrow function. </span><span class="koboSpan" id="kobo.1608.2">Because we donâ€™t use brackets, the arrow function directly returns what we write after the arrow. </span><span class="koboSpan" id="kobo.1608.3">This is the same as </span><span class="No-Break"><span class="koboSpan" id="kobo.1609.1">writing this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1610.1">
export const fetchDashboards = (): Observable&lt;Dashboard[]&gt; =&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.1611.1">{ return</span></strong><span class="koboSpan" id="kobo.1612.1"> inject(HttpClient).getâ€¦â€¦â€¦ </span><strong class="bold"><span class="koboSpan" id="kobo.1613.1">}</span></strong></pre> <p><span class="koboSpan" id="kobo.1614.1">Our function uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1615.1">inject</span></strong><span class="koboSpan" id="kobo.1616.1"> function to inject the Angular </span><strong class="source-inline"><span class="koboSpan" id="kobo.1617.1">HttpClient</span></strong><span class="koboSpan" id="kobo.1618.1"> as a dependency to fetch the dashboards. </span><span class="koboSpan" id="kobo.1618.2">You can use this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1619.1">fetchDashboards</span></strong><span class="koboSpan" id="kobo.1620.1"> function inside the injection context of your components and services. </span><span class="koboSpan" id="kobo.1620.2">For example, you can assign the function to a component property and subscribe to it in your template using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1621.1">async pipe:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1622.1">
export default class DashboardsListComponent {
Â Â </span><strong class="bold"><span class="koboSpan" id="kobo.1623.1">dashboards$ = fetchDashboards();</span></strong><span class="koboSpan" id="kobo.1624.1">
}</span></pre> <p><span class="koboSpan" id="kobo.1625.1">Now, inside the template of this component, you can do something </span><span class="No-Break"><span class="koboSpan" id="kobo.1626.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1627.1">
&lt;h1 *ngFor="let dashboard of (</span><strong class="bold"><span class="koboSpan" id="kobo.1628.1">dashboards$ | async</span></strong><span class="koboSpan" id="kobo.1629.1">)"&gt;
Â Â {{dashboard.title}}
&lt;/h1&gt;</span></pre> <p><span class="koboSpan" id="kobo.1630.1">When using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1631.1">fetchDashboards</span></strong><span class="koboSpan" id="kobo.1632.1"> function</span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.1633.1"> outside the injection</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.1634.1"> context, such as in a method, you get an error telling you that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1635.1">inject</span></strong><span class="koboSpan" id="kobo.1636.1"> function canâ€™t be used outside the injection context. </span><span class="koboSpan" id="kobo.1636.2">But there is a solution to this: you can use JavaScript closure to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1637.1">fetchDashboards</span></strong><span class="koboSpan" id="kobo.1638.1"> function anywhere, even outside the injection context. </span><span class="koboSpan" id="kobo.1638.2">To use closure, adjust the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1639.1">fetchDashboards</span></strong><span class="koboSpan" id="kobo.1640.1"> function so that it returns </span><span class="No-Break"><span class="koboSpan" id="kobo.1641.1">a function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1642.1">
return </span><strong class="bold"><span class="koboSpan" id="kobo.1643.1">() =&gt; </span></strong><span class="koboSpan" id="kobo.1644.1">inject(HttpClient).getâ€¦â€¦â€¦</span></pre> <p><span class="koboSpan" id="kobo.1645.1">As you can see, we returned an arrow function, which returns the HTTP call instead of directly returning the HTTP call. </span><span class="koboSpan" id="kobo.1645.2">Inside your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1646.1">component</span></strong><span class="koboSpan" id="kobo.1647.1"> class, you must assign this closure function to a property, </span><span class="No-Break"><span class="koboSpan" id="kobo.1648.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1649.1">
protected _fetchDashboards = fetchDashboards();</span></pre> <p><span class="koboSpan" id="kobo.1650.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1651.1">fetchDashboards</span></strong><span class="koboSpan" id="kobo.1652.1"> function returns another function, and because of that, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1653.1">_fetchDashboards</span></strong><span class="koboSpan" id="kobo.1654.1"> property</span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.1655.1"> is also a function. </span><span class="koboSpan" id="kobo.1655.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.1656.1">_fetchDashboards</span></strong><span class="koboSpan" id="kobo.1657.1"> function</span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.1658.1"> now holds the function that returns the observable HTTP call for fetching the dashboards and can be used anywhere in your class, also outside the </span><span class="No-Break"><span class="koboSpan" id="kobo.1659.1">injection context:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1660.1">
export default class AppComponent {
Â Â private _fetchDashboards = fetchDashboards();
Â Â loadDashboards() { this._fetchDashboards().subscribe(â€¦) }
}</span></pre> <p><span class="koboSpan" id="kobo.1661.1">Before converting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1662.1">fetchDashboards</span></strong><span class="koboSpan" id="kobo.1663.1"> function so that it can use closure, it canâ€™t be used inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1664.1">loadDashboards</span></strong><span class="koboSpan" id="kobo.1665.1"> function of the component because this is outside the injection context. </span><span class="koboSpan" id="kobo.1665.2">By using a closure and returning the function to a property in our injection context, we can now use the function to fetch the dashboards outside the injection context. </span><span class="koboSpan" id="kobo.1665.3">Using this pattern allows for great abstraction of logic and functions with a single responsibility that can be shared throughout your application while keeping component classes simple </span><span class="No-Break"><span class="koboSpan" id="kobo.1666.1">and clean.</span></span></p>
<p><span class="koboSpan" id="kobo.1667.1">Besides abstracting logic into dedicated functions, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1668.1">inject</span></strong><span class="koboSpan" id="kobo.1669.1"> function offers some advantages when working with inheritance. </span><span class="koboSpan" id="kobo.1669.2">When using dependency injection in both the base class and the class inheriting from the base class, you need to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.1670.1">super()</span></strong><span class="koboSpan" id="kobo.1671.1"> and pass the dependencies to the base class. </span><span class="koboSpan" id="kobo.1671.2">Hereâ€™s a </span><span class="No-Break"><span class="koboSpan" id="kobo.1672.1">simple example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1673.1">
export class baseService {
Â Â constructor(private router: Router) { }
}
export class DashboardService extends baseService {
Â Â constructor(private logger: Logger, router: Router) {
Â Â Â Â super(router);
Â Â }}</span></pre> <p><span class="koboSpan" id="kobo.1674.1">Calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.1675.1">super()</span></strong><span class="koboSpan" id="kobo.1676.1"> and passing along dependencies can become a hindrance and look messy. </span><span class="koboSpan" id="kobo.1676.2">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1677.1">inject</span></strong><span class="koboSpan" id="kobo.1678.1"> function, you can prevent this. </span><span class="koboSpan" id="kobo.1678.2">By using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1679.1">inject</span></strong><span class="koboSpan" id="kobo.1680.1"> function in both classes, you donâ€™t have to pass along anything or call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1681.1">super()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1682.1">method anymore:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1683.1">
export class baseService {private router = inject(Router);}
export class DashboardService extends baseService {
Â Â private logger = inject(Logger);
}</span></pre> <p><span class="koboSpan" id="kobo.1684.1">As you can see, you donâ€™t have to pass along </span><strong class="source-inline"><span class="koboSpan" id="kobo.1685.1">router</span></strong><span class="koboSpan" id="kobo.1686.1"> to the base service, and there is no need for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1687.1">super()</span></strong><span class="koboSpan" id="kobo.1688.1"> call anymore; that looks much cleaner! </span><span class="koboSpan" id="kobo.1688.2">Letâ€™s say you only used the router for navigation inside the base class. </span><span class="koboSpan" id="kobo.1688.3">In that case, you can even take it a step further and abstract the navigation functionality into a separate closure function, as we did before, with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1689.1">fetchDashboards</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1690.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1691.1">
export const navigateFn = </span><strong class="bold"><span class="koboSpan" id="kobo.1692.1">() =&gt;</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.1693.1">(url: string) =&gt;</span></strong><span class="koboSpan" id="kobo.1694.1"> inject(Router).navigate([url]);
export class baseService {
Â Â protected _navigateFn = navigateFn();
}</span></pre> <p><span class="koboSpan" id="kobo.1695.1">Because weâ€™re using an arrow function that returns another arrow function, we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1696.1">_navigateFn</span></strong><span class="koboSpan" id="kobo.1697.1"> outside the injection context. </span><span class="koboSpan" id="kobo.1697.2">Inside the service that inherits the base class, you can navigate using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1698.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1699.1">
this._navigateFn('some/url');</span></pre> <p><span class="koboSpan" id="kobo.1700.1">Now that you know why, when, and how</span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.1701.1"> to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1702.1">inject</span></strong><span class="koboSpan" id="kobo.1703.1"> function instead of constructor</span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.1704.1"> injection, letâ€™s explore how dependency injection creates instances of the injected services and what hierarchical </span><span class="No-Break"><span class="koboSpan" id="kobo.1705.1">injectors are.</span></span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.1706.1">Dependency instances, injector hierarchy, and resolution modifiers</span></h2>
<p><span class="koboSpan" id="kobo.1707.1">The last thing you need</span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.1708.1"> to learn is how Angular</span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.1709.1"> creates instances</span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.1710.1"> of the dependencies you inject, how the </span><strong class="bold"><span class="koboSpan" id="kobo.1711.1">injector hierarchy</span></strong><span class="koboSpan" id="kobo.1712.1"> works, and how to control it with </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1713.1">resolution modifiers</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1714.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1715.1">Each time you inject a dependency, Angular will check how the dependency is provided, starting at the lowest level of the injector hierarchy â€“ the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1716.1">providers</span></strong><span class="koboSpan" id="kobo.1717.1"> array inside your component or directive. </span><span class="koboSpan" id="kobo.1717.2">If Angular canâ€™t find a provider, it will start to move up in the injector hierarchy, first to the parent components; if it canâ€™t find the provider in any of the parent components, Angular will check the ngModule of the component or your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1718.1">ApplicationConfig</span></strong><span class="koboSpan" id="kobo.1719.1"> object in case you donâ€™t use ngModules. </span><span class="koboSpan" id="kobo.1719.2">If Angular canâ€™t find a provider in the ngModules, it will look in the root injector for a service with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1720.1">@Injectable</span></strong><span class="koboSpan" id="kobo.1721.1"> decorator and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1722.1">providedIn</span></strong><span class="koboSpan" id="kobo.1723.1"> root. </span><span class="koboSpan" id="kobo.1723.2">If Angular still canâ€™t find a provider for the inject dependency, Angular will throw an error. </span><span class="koboSpan" id="kobo.1723.3">If you inject a dependency in a service, Angular will skip the component </span><span class="No-Break"><span class="koboSpan" id="kobo.1724.1">hierarchy steps.</span></span></p>
<p><span class="koboSpan" id="kobo.1725.1">Letâ€™s say we want to inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.1726.1">LoggerService</span></strong><span class="koboSpan" id="kobo.1727.1"> as a dependency. </span><span class="koboSpan" id="kobo.1727.2">When Angular finds the provider for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1728.1">LoggerService</span></strong><span class="koboSpan" id="kobo.1729.1">, it will check if the injector already created an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1730.1">LoggerService</span></strong><span class="koboSpan" id="kobo.1731.1"> at the hierarchy level where the provider was located. </span><span class="koboSpan" id="kobo.1731.2">If the injector already made </span><strong class="source-inline"><span class="koboSpan" id="kobo.1732.1">LoggerService</span></strong><span class="koboSpan" id="kobo.1733.1"> for the given hierarchy level, it will return the created instance. </span><span class="koboSpan" id="kobo.1733.2">Otherwise, it will create one and then return it. </span><span class="koboSpan" id="kobo.1733.3">For each hierarchy level, a singleton instance will be created and shared by all consumers on the lower hierarchical levels. </span><span class="koboSpan" id="kobo.1733.4">If two or more sibling components declare a provider, a singleton will be created for each provider, and each component will use its own singleton of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1734.1">LoggerService</span></strong><span class="koboSpan" id="kobo.1735.1"> and share it with all its subsequent child components </span><span class="No-Break"><span class="koboSpan" id="kobo.1736.1">and directives.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1737.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1738.1">.2</span></em><span class="koboSpan" id="kobo.1739.1"> depicts how hierarchical dependencies are created </span><span class="No-Break"><span class="koboSpan" id="kobo.1740.1">and shared:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.1741.1"><img alt="Figure 2.2: Hierarchical dependency creation" src="image/B21625_02_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1742.1">Figure 2.2: Hierarchical dependency creation</span></p>
<p><span class="koboSpan" id="kobo.1743.1">Knowing how Angular dependency</span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.1744.1"> injection creates and shares dependencies allows you to provide</span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.1745.1"> the correct instance to all application</span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.1746.1"> sections. </span><span class="koboSpan" id="kobo.1746.2">If you want a singleton to be shared among all dependency consumers in the application, you just need to provide the dependency in the root injector. </span><span class="koboSpan" id="kobo.1746.3">In some more complex and edge cases, you need to be able to have more control over how Angular looks for providers. </span><span class="koboSpan" id="kobo.1746.4">In this scenario, you can adjust the behavior with </span><span class="No-Break"><span class="koboSpan" id="kobo.1747.1">resolution modifiers.</span></span></p>
<p><span class="koboSpan" id="kobo.1748.1">There are four resolution modifiers you can apply to your injected dependencies. </span><span class="koboSpan" id="kobo.1748.2">Each has its own function and how you apply these modifiers differs depending on if you use constructor injection or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1749.1">inject</span></strong><span class="koboSpan" id="kobo.1750.1"> function. </span><span class="koboSpan" id="kobo.1750.2">Letâ€™s examine these four resolution modifiers and what </span><span class="No-Break"><span class="koboSpan" id="kobo.1751.1">they do:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1752.1">@Optional()</span></strong><span class="koboSpan" id="kobo.1753.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1754.1">@Optional()</span></strong><span class="koboSpan" id="kobo.1755.1"> modifier makes sure a dependency is optional. </span><span class="koboSpan" id="kobo.1755.2">Angular wonâ€™t throw an error if it canâ€™t find a provider for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1756.1">given dependency.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1757.1">@SkipSelf()</span></strong><span class="koboSpan" id="kobo.1758.1">: With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1759.1">@SkipSelf()</span></strong><span class="koboSpan" id="kobo.1760.1"> modifier, you tell Angular it should start looking for a provider in the first parent in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1761.1">dependency hierarchy.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1762.1">@Self()</span></strong><span class="koboSpan" id="kobo.1763.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1764.1">@Self()</span></strong><span class="koboSpan" id="kobo.1765.1"> modifier tells Angular to only look at the component or directive itself for </span><span class="No-Break"><span class="koboSpan" id="kobo.1766.1">the provider.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1767.1">@Host()</span></strong><span class="koboSpan" id="kobo.1768.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1769.1">@Host()</span></strong><span class="koboSpan" id="kobo.1770.1"> property marks a component as the last step in the search for a provider, even if there are more components higher up in the tree. </span><span class="koboSpan" id="kobo.1770.2">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1771.1">@Host()</span></strong><span class="koboSpan" id="kobo.1772.1"> property is found, Angular stops looking for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1773.1">dependency provider.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1774.1">Now that you know</span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.1775.1"> what resolution</span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.1776.1"> modifiers are available </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.1777.1">and what they do, letâ€™s see how you can apply them to dependencies. </span><span class="koboSpan" id="kobo.1777.2">When you want to apply a resolution modifier to a dependency thatâ€™s been injected with constructor injection, you can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.1778.1">following syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1779.1">
constructor(</span><strong class="bold"><span class="koboSpan" id="kobo.1780.1">@Optional()</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.1781.1">@SkipSelf()</span></strong><span class="koboSpan" id="kobo.1782.1"> logger?: Logger) {}</span></pre> <p><span class="koboSpan" id="kobo.1783.1">If you want to apply the resolution modifiers to a dependency thatâ€™s been injected with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1784.1">inject</span></strong><span class="koboSpan" id="kobo.1785.1"> function, you can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.1786.1">following syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1787.1">
logger = inject(Logger, </span><strong class="bold"><span class="koboSpan" id="kobo.1788.1">{optional: true, self: true}</span></strong><span class="koboSpan" id="kobo.1789.1">);</span></pre> <p><span class="koboSpan" id="kobo.1790.1">Now that you know everything you need to know about Angular dependency injection, letâ€™s create a simple service before we move on to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1791.1">next chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.1792.1">To create this service, we are going to use the Nx generator again. </span><span class="koboSpan" id="kobo.1792.2">First, create a new library called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1793.1">expenses</span></strong><span class="koboSpan" id="kobo.1794.1"> under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1795.1">finance</span></strong><span class="koboSpan" id="kobo.1796.1"> domain with its type set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1797.1">data-access</span></strong><span class="koboSpan" id="kobo.1798.1">. </span><span class="koboSpan" id="kobo.1798.2">Next, open your Nx console again and click </span><strong class="bold"><span class="koboSpan" id="kobo.1799.1">Generate</span></strong><span class="koboSpan" id="kobo.1800.1">. </span><span class="koboSpan" id="kobo.1800.2">In the dropdown that appears, search for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1801.1">service</span></strong><span class="koboSpan" id="kobo.1802.1"> and select </span><strong class="bold"><span class="koboSpan" id="kobo.1803.1">@schematics/angular - </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1804.1">service</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1805.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1806.1">Follow these steps to generate </span><span class="No-Break"><span class="koboSpan" id="kobo.1807.1">the service:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1808.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.1809.1">name*</span></strong><span class="koboSpan" id="kobo.1810.1"> input field, </span><span class="No-Break"><span class="koboSpan" id="kobo.1811.1">enter </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1812.1">services/expenses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1813.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1814.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.1815.1">project*</span></strong><span class="koboSpan" id="kobo.1816.1"> select box, </span><span class="No-Break"><span class="koboSpan" id="kobo.1817.1">select </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1818.1">finance-data-access-expenses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1819.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1820.1">In the top-right corner, </span><span class="No-Break"><span class="koboSpan" id="kobo.1821.1">click </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1822.1">Generate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1823.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1824.1">Go to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1825.1">index.ts</span></strong><span class="koboSpan" id="kobo.1826.1"> file of your </span><em class="italic"><span class="koboSpan" id="kobo.1827.1">expenses library</span></em><span class="koboSpan" id="kobo.1828.1"> and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.1829.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1830.1">
export * from './lib/services/expenses.service';</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1831.1">Thatâ€™s all for now! </span><span class="koboSpan" id="kobo.1831.2">With that, youâ€™ve created</span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.1832.1"> a service and know everything </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.1833.1">you need to know about Angular</span><a id="_idIndexMarker276"/> <span class="No-Break"><span class="koboSpan" id="kobo.1834.1">dependency injection.</span></span></p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.1835.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1836.1">In this chapter, we explored some of the most fundamental features in the Angular framework and learned what Angular added in their latest major releases. </span><span class="koboSpan" id="kobo.1836.2">You learned about Signals, the new control flow syntax, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1837.1">@defer</span></strong><span class="koboSpan" id="kobo.1838.1"> blocks. </span><span class="koboSpan" id="kobo.1838.2">We covered how to communicate between components using input and output decorators, as well as less conventional methods for component communication using router data and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1839.1">viewChild</span></strong><span class="koboSpan" id="kobo.1840.1"> decorator. </span><span class="koboSpan" id="kobo.1840.2">You also learned about the Angular router and how to configure route objects for more advanced scenarios and auxiliary routes. </span><span class="koboSpan" id="kobo.1840.3">Finally, you learned about dependency injection in great detail. </span><span class="koboSpan" id="kobo.1840.4">You now know what the difference is between constructor injection and dependency injection when using the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1841.1">inject</span></strong><span class="koboSpan" id="kobo.1842.1"> function. </span><span class="koboSpan" id="kobo.1842.2">We also created some </span><strong class="source-inline"><span class="koboSpan" id="kobo.1843.1">provides</span></strong><span class="koboSpan" id="kobo.1844.1"> arrays and demonstrated how to declare the injection value and token. </span><span class="koboSpan" id="kobo.1844.2">Lastly, you learned about the injector hierarchy and how you can control the provider that should be used by applying </span><span class="No-Break"><span class="koboSpan" id="kobo.1845.1">resolution modifiers.</span></span></p>
<p><span class="koboSpan" id="kobo.1846.1">In the next chapter, we will learn about Angular directives, pipes, </span><span class="No-Break"><span class="koboSpan" id="kobo.1847.1">and animations.</span></span></p>
</div>
</body></html>