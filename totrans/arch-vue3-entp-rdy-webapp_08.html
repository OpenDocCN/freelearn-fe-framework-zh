<html><head></head><body>
<div id="_idContainer071">
<h1 class="chapter-number" id="_idParaDest-125"><a id="_idTextAnchor266"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-126"><a id="_idTextAnchor267"/><span class="koboSpan" id="kobo.2.1">Testing and What to Test in Vue.js 3</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, you learned the nitty-gritty details of the steps involved in dockerizing your Vue.js 3 project. </span><span class="koboSpan" id="kobo.3.2">In addition, you learned about the best practices and industry standards to dockerize an enterprise Vue.js 3 </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">web application.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, you will explore the concept of software testing. </span><span class="koboSpan" id="kobo.5.2">You will learn what to test from an array of available components and methods. </span><span class="koboSpan" id="kobo.5.3">In addition, you will learn about best practices and industry standards related to testing libraries and how to integrate them with </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">Vue.js 3.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">We will cover the following key topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Overview </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">of testing</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Testing in </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">software engineering</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">What </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">to test</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Testing a basic Vue.js </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">3 app</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Component testing in </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Vue.js 3</span></span></li>
</ul>
<h1 id="_idParaDest-127"><a id="_idTextAnchor268"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">To get started with this chapter, I recommend you read through </span><a href="B17237_07.xhtml#_idTextAnchor230"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.21.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.22.1">,</span><em class="italic"><span class="koboSpan" id="kobo.23.1"> Dockerizing a Vue 3 App</span></em><span class="koboSpan" id="kobo.24.1">, first, where we took a more practical approach by dockerizing a full stack web application using Docker Compose. </span><span class="koboSpan" id="kobo.24.2">We will be using the application a lot in this chapter to learn about Vue.js 3 </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">enterprise testing.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">All the code files for this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">at </span></span><a href="https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-8"><span class="No-Break"><span class="koboSpan" id="kobo.28.1">https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-8</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.29.1">.</span></span></p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.30.1">Overview of testing</span></h1>
<p><span class="koboSpan" id="kobo.31.1">Anyone who has studied computer science should be familiar with the concept of SDLC. </span><span class="koboSpan" id="kobo.31.2">If you are </span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.32.1">not aware, </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">SDLC</span></strong><span class="koboSpan" id="kobo.34.1"> stands for </span><strong class="bold"><span class="koboSpan" id="kobo.35.1">software development </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.36.1">life cycle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">Synopsys (</span><a href="https://www.synopsys.com/glossary/what-is-sdlc.html"><span class="koboSpan" id="kobo.39.1">https://www.synopsys.com/glossary/what-is-sdlc.html</span></a><span class="koboSpan" id="kobo.40.1">) provides the </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">following definition:</span></span></p>
<p class="author-quote"><span class="koboSpan" id="kobo.42.1">Software Development Life Cycle (SDLC) is a structured process that enables the production of high-quality, low-cost software, in the shortest possible production time. </span><span class="koboSpan" id="kobo.42.2">The goal of the SDLC is to produce superior software that meets and exceeds all customer expectations and demands.</span></p>
<p><span class="koboSpan" id="kobo.43.1">If you explore </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.44.1">the SDLC further, you’ll see that it defines and outlines eight detailed plans with stages or phases that quality and enterprise-level software must pass through to produce software that meets and exceeds all customer expectations </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">and demands.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">Each stage is crucial, including planning, coding, building, and testing. </span><span class="koboSpan" id="kobo.46.2">However, the testing phase is particularly important, especially when you need to build a bug- or defect-free </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">enterprise-level application.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">To elaborate further, the testing phase evaluates the created software against any bugs, any potential errors, and the requirements of the software from the </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">planning phase.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">Next, we will see what we mean by </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">software testing</span><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.52.1">.</span></span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.53.1">What is software testing?</span></h2>
<p><span class="koboSpan" id="kobo.54.1">Software testing is the method of checking whether the software in production matches the expected </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.55.1">requirements and, most importantly, whether it is defect free. </span><span class="koboSpan" id="kobo.55.2">The method used to carry out software testing differs depending on the organization. </span><span class="koboSpan" id="kobo.55.3">However, the method is divided into manual and </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">automated processes.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">Individuals and organizations will have different names for software testing. </span><span class="koboSpan" id="kobo.57.2">It can also be categorized as whitebox or blackbox testing. </span><span class="koboSpan" id="kobo.57.3">However, the end result of any approach is always the same, which is identifying errors, gaps, or missing requirements in contrast to </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">actual requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">Blackbox testing involves testing a system without knowing the internal workings of the system, while whitebox testing is an approach of testing that allows the tester to inspect and verify the internal workings of </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">Regardless of </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.62.1">the names, terms, or categories used when referring to software testing, in simple terms, software testing means the verification of the </span><strong class="bold"><span class="koboSpan" id="kobo.63.1">Application Under Test</span></strong><span class="koboSpan" id="kobo.64.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.65.1">AUT</span></strong><span class="koboSpan" id="kobo.66.1">), and </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.67.1">it’s a critical and crucial stage in producing high-quality </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">enterprise-level software.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">In the next section, we will go through the importance of </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">software test</span><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.71.1">ing.</span></span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor273"/><span class="koboSpan" id="kobo.72.1">Why software testing is important</span></h2>
<p><span class="koboSpan" id="kobo.73.1">The need to incorporate software testing into your application development pipeline cannot be </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.74.1">overemphasized. </span><span class="koboSpan" id="kobo.74.2">It is as important as the planning and development phases in the SDLC. </span><span class="koboSpan" id="kobo.74.3">In fact, without a proper software testing strategy, it is likely that the end product of the software under development will be filled with bugs, errors, and unmet </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">software requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">Software testing is important because software bugs could be expensive and also very dangerous to businesses, and organizations at large. </span><span class="koboSpan" id="kobo.76.2">Over the years, there have been numerous examples of potential software bugs and </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">monetary losses.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">For instance, in April 2015, the Bloomberg terminal in London crashed due to a software glitch that affected more than 300,000 traders in financial markets. </span><span class="koboSpan" id="kobo.78.2">It forced the UK government to postpone a 3 billion pound debt sale, according to The </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">Guardian (</span></span><a href="https://www.theguardian.com/business/2015/apr/17/uk-halts-bond-sale-bloomberg-terminals-crash-worldwide"><span class="No-Break"><span class="koboSpan" id="kobo.80.1">https://www.theguardian.com/business/2015/apr/17/uk-halts-bond-sale-bloomberg-terminals-crash-worldwide</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.81.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">Also, according to Windows Report (</span><a href="https://windowsreport.com/windows-10-vulnerability/"><span class="koboSpan" id="kobo.83.1">https://windowsreport.com/windows-10-vulnerability/</span></a><span class="koboSpan" id="kobo.84.1">), there was a vulnerability in Windows 10 that enabled users to escape from security sandboxes through a flaw in the </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">win32k system.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">There have been many vulnerability reports on different malicious attempts on businesses that have impacted revenue or monetary value, of which some could be avoided with proper software testing. </span><span class="koboSpan" id="kobo.86.2">This indicates that software testing is a very important stage in </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">the SDLC.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">Though software testing costs money, I’m sure you will agree with me that the cost is nothing compared to the millions per year in development and support companies would have to spend if they don’t have a good testing technique and QA processes </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">in place.</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">In addition, having early software testing in place uncovers problems before the products go to market. </span><span class="koboSpan" id="kobo.90.2">Early testing also uncovers different defects, including but not limited to </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.92.1">Architectural flaws</span></span></li>
<li><span class="koboSpan" id="kobo.93.1">Poor </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">design decisions</span></span></li>
<li><span class="koboSpan" id="kobo.95.1">Invalid or </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">incorrect functionality</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.97.1">Security vulnerabilities</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.98.1">Scalability issues</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.99.1">Having </span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.100.1">proper testing processes in place along the software development pipeline improves software reliability and means high-quality applications are delivered with few errors. </span><span class="koboSpan" id="kobo.100.2">In the next section, we will further explore the benefits of </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">software te</span><a id="_idTextAnchor274"/><span class="koboSpan" id="kobo.102.1">sting.</span></span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor275"/><span class="koboSpan" id="kobo.103.1">The benefits of software testing</span></h2>
<p><span class="koboSpan" id="kobo.104.1">In the previous section, we explained why enterprise applications need to include testing </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.105.1">in their development pipeline. </span><span class="koboSpan" id="kobo.105.2">In this section, we will explore the benefits of having a proper software testing process. </span><span class="koboSpan" id="kobo.105.3">We will go through the following points </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">in detail:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.107.1">Helps in </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">saving money</span></span></li>
<li><span class="koboSpan" id="kobo.109.1">Satisfaction </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">of customers</span></span></li>
<li><span class="koboSpan" id="kobo.111.1">Enhancing the </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">development pipeline</span></span></li>
<li><span class="koboSpan" id="kobo.113.1">Quality </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">of product</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.115.1">S</span><a id="_idTextAnchor276"/><span class="koboSpan" id="kobo.116.1">ecurity</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.117.1">Helps in saving money</span></h3>
<p><span class="koboSpan" id="kobo.118.1">Launching buggy software to market can end up being more expensive than creating the entire software. </span><span class="koboSpan" id="kobo.118.2">As stated previously, there have been many cases of company’s monetary value reducing due to software defects and </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">error-prone software.</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">This problem </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.121.1">can be curtailed to some extent if there is a proper software testing process built into the development pipeline to detect and rectify these errors before moving on to the next stage of </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">the p</span><a id="_idTextAnchor277"/><span class="koboSpan" id="kobo.123.1">ipeline.</span></span></p>
<h3><span class="koboSpan" id="kobo.124.1">Satisfaction of customers</span></h3>
<p><span class="koboSpan" id="kobo.125.1">For users of your enterprise application to be satisfied, the software must work properly and in </span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.126.1">accordance with </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">the requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">Therefore, before launching the software to market, an acceptance test must be conducted to ensure that the product works in accordance with the requirements and also to get a sense of how users will access and use the product day </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">to day.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">While in the testing phase, if any issues or bugs are detected, the software under test can easily be moved back to the development stage instead of finding out about the problems in the production stage where real users are interacting with </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">the app</span><a id="_idTextAnchor278"/><span class="koboSpan" id="kobo.132.1">lication.</span></span></p>
<h3><span class="koboSpan" id="kobo.133.1">Enhancing the development pipeline</span></h3>
<p><span class="koboSpan" id="kobo.134.1">Including software testing in the development pipeline creates an enhanced development </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.135.1">pipeline. </span><span class="koboSpan" id="kobo.135.2">Also, it is an industry-standard practice to include software testing. </span><span class="koboSpan" id="kobo.135.3">In addition, it is simpler for developers to fix errors in the development stage than in the </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">production stage.</span></span></p>
<p><span class="koboSpan" id="kobo.137.1">Thus, incorporating the software testing process in the development pipeline reduces the risk of launching error-prone software to market and enhances the </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">development</span><a id="_idTextAnchor279"/><span class="koboSpan" id="kobo.139.1"> pipeline.</span></span></p>
<h3><span class="koboSpan" id="kobo.140.1">Quality of product</span></h3>
<p><span class="koboSpan" id="kobo.141.1">When the </span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.142.1">quality of the product drops, the company might lose customers, resulting in a loss of revenue. </span><span class="koboSpan" id="kobo.142.2">However, one of the attributes of low-quality software is an untested and error-prone </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">software application.</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">Furthermore, if there is a proper software testing process built into the development pipeline, most errors, bugs, and defects will be detected and fixed before production, thereby producing </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">qualit</span><a id="_idTextAnchor280"/><span class="koboSpan" id="kobo.146.1">y software.</span></span></p>
<h3><span class="koboSpan" id="kobo.147.1">Security</span></h3>
<p><span class="koboSpan" id="kobo.148.1">According to OWASP (</span><a href="https://owasp.org/www-project-top-ten/"><span class="koboSpan" id="kobo.149.1">https://owasp.org/www-project-top-ten/</span></a><span class="koboSpan" id="kobo.150.1">), security should be an integral part of every software. </span><span class="koboSpan" id="kobo.150.2">Not considering it could result in a reduction in the monetary value of </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">the business.</span></span></p>
<p><span class="koboSpan" id="kobo.152.1">Software </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.153.1">testing is one way to detect security loopholes and fix them in the development stage. </span><span class="koboSpan" id="kobo.153.2">If a product has undergone testing, the user can be assured that they are receiving a reliable product. </span><span class="koboSpan" id="kobo.153.3">They will be assured that their personal details are safe. </span><span class="koboSpan" id="kobo.153.4">Users can receive products that are more likely to be free from vulnerabilities with the aid of </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">software testing.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">In this subsection, we covered some benefits you can derive from implementing software testing into your pipeline when building </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">enterprise-ready applications.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">In the next section, we will explore the different types of testing and different strategies you can integrate into your </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">developmen</span><a id="_idTextAnchor281"/><span class="koboSpan" id="kobo.159.1">t pipeline.</span></span></p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor282"/><span class="koboSpan" id="kobo.160.1">Testing in software engineering</span></h1>
<p><span class="koboSpan" id="kobo.161.1">As stated in </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.162.1">the previous section, software testing is an integral part of the SDLC, and therefore, according to ANSI/IEEE 1059, testing in software engineering is a method of evaluating the software under test to discover whether it meets the requirements, as well as whether it is error, bug, and </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">defect free.</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">The process involves evaluating the features of the software under test for requirements in terms of any missing requirements, bugs or errors, security, reliability, </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">and performance.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">In this section, we explored the benefits of testing and why software testing is important, and in the next section, we will understand different types of software testing. </span><span class="koboSpan" id="kobo.166.2">We will explore what to test and how to write basic unit and </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">integ</span><a id="_idTextAnchor283"/><span class="koboSpan" id="kobo.168.1">ration tests.</span></span></p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor284"/><span class="koboSpan" id="kobo.169.1">Types of software testing</span></h2>
<p><span class="koboSpan" id="kobo.170.1">Software </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.171.1">testing has been given different names. </span><span class="koboSpan" id="kobo.171.2">There are over 150 types of software testing according to </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">Guru99 (</span></span><a href="https://www.guru99.com/types-of-software-testing.html"><span class="No-Break"><span class="koboSpan" id="kobo.173.1">https://www.guru99.com/types-of-software-testing.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.174.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">However, we are going to classify software testing into two main categories and then explore each of the categories and the different types within them. </span><span class="koboSpan" id="kobo.175.2">The following are the two </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">main categories:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.177.1">Functional </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">software testing</span></span></li>
<li><span class="koboSpan" id="kobo.179.1">Performance software </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">testing (non-functional)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.181.1">The following </span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.182.1">figure shows the high-level classification of software </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">testing types:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<span class="koboSpan" id="kobo.184.1"><img alt="Figure 8.1 – A high-level classification of software testing (source: softwaretestinghelp)" src="image/Figure_8.01_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.185.1">Figure 8.1 – A high-level classification of software testing (source: softwaretestinghelp)</span></p>
<p><span class="koboSpan" id="kobo.186.1">You can explore more about the different categories of software testing on Youtube. </span><span class="koboSpan" id="kobo.186.2">However, we will only focus on three main categories of functional software testing, </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">as follows:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.188.1">Unit testing</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.189.1">Integration testing</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.190.1">End-</span><a id="_idTextAnchor285"/><span class="koboSpan" id="kobo.191.1">to-end testing</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.192.1">Unit testing</span></h3>
<p><span class="koboSpan" id="kobo.193.1">This basic approach to software testing is carried out by a programmer to test the unit or smallest </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.194.1">part of the program. </span><span class="koboSpan" id="kobo.194.2">It helps developers to know </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.195.1">whether individual units of code are working </span><a id="_idTextAnchor286"/><span class="koboSpan" id="kobo.196.1">properly </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">or not.</span></span></p>
<h3><span class="koboSpan" id="kobo.198.1">Integration testing</span></h3>
<p><span class="koboSpan" id="kobo.199.1">This type of </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.200.1">testing focuses on the construction and design of the software. </span><span class="koboSpan" id="kobo.200.2">You </span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.201.1">need to see whether the integrated units are working with</span><a id="_idTextAnchor287"/><span class="koboSpan" id="kobo.202.1">out errors </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">or not.</span></span></p>
<h3><span class="koboSpan" id="kobo.204.1">End-to-end testing</span></h3>
<p><span class="koboSpan" id="kobo.205.1">End-to-end </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.206.1">testing is a methodology that assesses the working order of a complex product in a </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">start-to-finish process.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">In the coming chapters, we will focus on exploring these different types of testing individually. </span><span class="koboSpan" id="kobo.208.2">Nevertheless, you can explore more than 150 different types of software testing from </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">Guru99 (</span></span><a href="https://www.guru99.com/types-of-software-testing.html"><span class="No-Break"><span class="koboSpan" id="kobo.210.1">https://www.guru99.com/types-of-software-testing.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.211.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.212.1">In summary, now that we know how important software testing is and the different types of software testing, how do we know what to test in a large enterprise application? </span><span class="koboSpan" id="kobo.212.2">In the next section, we are going to explore what to test and how to integrate a testing pipeline into the </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">de</span><a id="_idTextAnchor288"/><span class="koboSpan" id="kobo.214.1">velopment workflow.</span></span></p>
<h1 id="_idParaDest-134"><a id="_idTextAnchor289"/><span class="koboSpan" id="kobo.215.1">What to test</span></h1>
<p><span class="koboSpan" id="kobo.216.1">A popular question among software teams is </span><em class="italic"><span class="koboSpan" id="kobo.217.1">what should we test and what should we not test?</span></em><span class="koboSpan" id="kobo.218.1"> In this section, we will explore the different things you should and shouldn’t test when considering </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">software tests.</span></span></p>
<p><span class="koboSpan" id="kobo.220.1">We will first explore different test strategies to employ when integrating software testing into your </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">de</span><a id="_idTextAnchor290"/><span class="koboSpan" id="kobo.222.1">velopment workflow.</span></span></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor291"/><span class="koboSpan" id="kobo.223.1">Testing strategy</span></h2>
<p><span class="koboSpan" id="kobo.224.1">The best testing </span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.225.1">strategy to implement in your enterprise application is the combination of normal (manual) testing and automated testing. </span><span class="koboSpan" id="kobo.225.2">In addition, normal </span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.226.1">testing should be done more extensively by the </span><strong class="bold"><span class="koboSpan" id="kobo.227.1">Quality Assurance</span></strong><span class="koboSpan" id="kobo.228.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.229.1">QA</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">) team.</span></span></p>
<p><span class="koboSpan" id="kobo.231.1">To explain this further, when automated testing is written and implemented successfully, we usually program it to look for fundamental errors and edge cases that may not properly assimilate how a real customer will interact </span><a id="_idTextAnchor292"/><span class="koboSpan" id="kobo.232.1">with </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">the application.</span></span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor293"/><span class="koboSpan" id="kobo.234.1">What you should test</span></h2>
<p><span class="koboSpan" id="kobo.235.1">As much as software testing is important to the efficiency of an enterprise-ready application, knowing </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.236.1">what to test is paramount so that developers don’t waste time testing the </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">wrong things.</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">The following is a list of some of the things you can look for when testing your enterprise project for errors, bugs, </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">and defects:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.240.1">Passed parameters</span></strong><span class="koboSpan" id="kobo.241.1">: The collection of parameters or arguments passed into the method or function to make sure that it has not changed. </span><span class="koboSpan" id="kobo.241.2">In some cases, the data type of the parameter remains </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">the same.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.243.1">Algorithm engines</span></strong><span class="koboSpan" id="kobo.244.1">: Every method has a purpose, and the purpose is implemented using logic or an algorithm. </span><span class="koboSpan" id="kobo.244.2">Your test case should test the algorithm to make sure it’s correct and it results in the right output based on the input into </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">the method.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.246.1">Simple database queries checking predicates</span></strong><span class="koboSpan" id="kobo.247.1">: If your job as a developer is related to queries and manipulating databases, you really want to test your database queries to make sure it performs the right manipulation </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">and queries.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.249.1">Utility methods</span></strong><span class="koboSpan" id="kobo.250.1">: Utility methods are helpers in your project that are created for a specific task. </span><span class="koboSpan" id="kobo.250.2">They are usually used when you need to do stuff that does not need an instance of a class. </span><span class="koboSpan" id="kobo.250.3">This set of methods needs to be tested properly to ensure it produces the correct output </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">when used.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.252.1">Testing less critical codes:</span></strong><span class="koboSpan" id="kobo.253.1"> Test the edge cases of a few unusually complex pieces of code that you think will probably have errors. </span><span class="koboSpan" id="kobo.253.2">Additionally, carry out edge-case tests of less critical code whenever someone has time </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">to kill.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.255.1">The preceding are a few things you can consider for your test cases. </span><span class="koboSpan" id="kobo.255.2">However, it is important to </span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.256.1">note that writing tests and having 100% code coverage do not necessarily mean that your code is bug free. </span><span class="koboSpan" id="kobo.256.2">In the next section, we will explore things you should no</span><a id="_idTextAnchor294"/><span class="koboSpan" id="kobo.257.1">t test in </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">your project.</span></span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor295"/><span class="koboSpan" id="kobo.259.1">What you should not test</span></h2>
<p><span class="koboSpan" id="kobo.260.1">The following </span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.261.1">are the things that you should not be testing in </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">your project:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.263.1">Constructors or properties (if they just return variables). </span><span class="koboSpan" id="kobo.263.2">Test them only if they </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">contain validations.</span></span></li>
<li><span class="koboSpan" id="kobo.265.1">Methods that call another </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">public method.</span></span></li>
<li><span class="koboSpan" id="kobo.267.1">If the code needs to interact with other deployed systems, then an integration test should </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">be used.</span></span></li>
<li><span class="koboSpan" id="kobo.269.1">Configurations such as constants, read-only fields, configs, </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">and enumerations.</span></span></li>
<li><span class="koboSpan" id="kobo.271.1">You should not test POJO classes or models; rather, you can test each of the methods inside </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">the class.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.273.1">In summary, we have explored the software testing strategy, what to test, and what you should not test to help you understand the relevance of software testing in your enterprise application. </span><span class="koboSpan" id="kobo.273.2">In the next section, we will explore how to test a b</span><a id="_idTextAnchor296"/><span class="koboSpan" id="kobo.274.1">asic </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">Vue.js application.</span></span></p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor297"/><span class="koboSpan" id="kobo.276.1">Testing a basic Vue.js 3 app</span></h1>
<p><span class="koboSpan" id="kobo.277.1">In the previous </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.278.1">chapter, we created a Pinterest application using Strapi for the backend and Vue.js 3 for </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">the frontend.</span></span></p>
<p><span class="koboSpan" id="kobo.280.1">Previously, we added internationalization, structured the project, and built out a complete Pinterest clone. </span><span class="koboSpan" id="kobo.280.2">In this section, we will continue by using the official project we created for this book to set up software testing, resulting in a full-blown enterprise-ready Pinterest </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">clone application.</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">You can clone the project from this repository, </span><a href="https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications"><span class="koboSpan" id="kobo.283.1">https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applic</span><span id="_idTextAnchor298"/><span class="koboSpan" id="kobo.284.1">ations</span></a><span class="koboSpan" id="kobo.285.1">, to jump </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">right in.</span></span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor299"/><span class="koboSpan" id="kobo.287.1">Creating a test folder</span></h2>
<p><span class="koboSpan" id="kobo.288.1">It is always </span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.289.1">confusing knowing where to add your test files and folder when it comes to creating enterprise applications. </span><span class="koboSpan" id="kobo.289.2">There are two methods for structuring your test files depending on the approach you used fo</span><a id="_idTextAnchor300"/><span class="koboSpan" id="kobo.290.1">r your </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">enterprise project.</span></span></p>
<h3><span class="koboSpan" id="kobo.292.1">Method 1 – adding test files inside each component</span></h3>
<p><span class="koboSpan" id="kobo.293.1">First, you </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.294.1">can create a specific test file inside each of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">component</span></strong><span class="koboSpan" id="kobo.296.1"> folders. </span><span class="koboSpan" id="kobo.296.2">For instance, inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">component</span></strong><span class="koboSpan" id="kobo.298.1"> folder in our Vue.js 3 project, we will create a folder for each component and move the files of each component into the folder, including the test file for </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">each component.</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">The following figure shows an example of how we could arrange our component folder to accommodate our testing files and other files related to a </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">particular component:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<span class="koboSpan" id="kobo.302.1"><img alt="Figure 8.2 – A screenshot showing our component structure" src="image/Figure_8.02_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.303.1">Figure 8.2 – A screenshot showing our component structure</span></p>
<p><span class="koboSpan" id="kobo.304.1">In the preceding figure, you can see how you can add any files related to any of the components. </span><span class="koboSpan" id="kobo.304.2">For example, if you want to add an end-to-end testing or integration testing file for each component, you just create the file within each specific </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">component folder.</span></span></p>
<p><span class="koboSpan" id="kobo.306.1">Also, because </span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.307.1">of the structure of our practice project and the introduction of the atomic pattern, we can easily see how many files will be created in each component. </span><span class="koboSpan" id="kobo.307.2">The same goes for different areas we will be testing throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">the project.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">However, we can use the next method to arrange everything related to testing in a separate folder and create all the files and folders inside</span><a id="_idTextAnchor301"/><span class="koboSpan" id="kobo.310.1"> the specific </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">tests</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.312.1"> folder.</span></span></p>
<h3><span class="koboSpan" id="kobo.313.1">Method 2 – creating a tests folder</span></h3>
<p><span class="koboSpan" id="kobo.314.1">In this </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.315.1">section, we will create a folder inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">src</span></strong><span class="koboSpan" id="kobo.317.1"> folder called </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">tests</span></strong><span class="koboSpan" id="kobo.319.1">, which will contain every file and folder related to testing and </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">test configurations.</span></span></p>
<p><span class="koboSpan" id="kobo.321.1">The following figure shows the folder structure for implementing testing with </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">this method:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<span class="koboSpan" id="kobo.323.1"><img alt="Figure 8.3 – A screenshot of the folder structure" src="image/Figure_8.03_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.324.1">Figure 8.3 – A screenshot of the folder structure</span></p>
<p><span class="koboSpan" id="kobo.325.1">This method </span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.326.1">has a single folder that contains all the files and folders related to testing, including all the configurations. </span><span class="koboSpan" id="kobo.326.2">It is a central place and single point of truth for all your software testing files and folders. </span><span class="koboSpan" id="kobo.326.3">You can arrange this folder in a different structure as per your </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">use case.</span></span></p>
<p><span class="koboSpan" id="kobo.328.1">Furthermore, the method of structuring your test folder or files and folders related to testing does not matter. </span><span class="koboSpan" id="kobo.328.2">What matters the most is implementing software testing properly and knowing exactly what to test to avoid production bugs </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">and errors.</span></span></p>
<p><span class="koboSpan" id="kobo.330.1">We will </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.331.1">use the second method in this demo in writing some basic unit tests to demonstrate. </span><span class="koboSpan" id="kobo.331.2">This is because we don’t want the testing files to be scattered across different folders since we </span><a id="_idTextAnchor302"/><span class="koboSpan" id="kobo.332.1">are using the </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">atomic pattern.</span></span></p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor303"/><span class="koboSpan" id="kobo.334.1">Writing a basic unit test</span></h2>
<p><span class="koboSpan" id="kobo.335.1">First, we will </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.336.1">start by installing the new testing library for </span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.337.1">Vue.js 3. </span><span class="koboSpan" id="kobo.337.2">Since we are using Vite in the project, we will also install the Vitest library for our test runner. </span><span class="koboSpan" id="kobo.337.3">You can read more about the new Vue.js 3 test librar</span><a id="_idTextAnchor304"/><span class="koboSpan" id="kobo.338.1">y </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">at </span></span><a href="https://vitest.dev/guide/"><span class="No-Break"><span class="koboSpan" id="kobo.340.1">https://vitest.dev/guide/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.341.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.342.1">Installing the test library</span></h3>
<p><span class="koboSpan" id="kobo.343.1">Vitest is a </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.344.1">blazing-fast unit test framework powered by Vite. </span><span class="koboSpan" id="kobo.344.2">Install the library by using any of </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">these commands:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.346.1">
```bash
# with npm
npm install -D vitest
# or with yarn
yarn add -D vitest
# or with pnpm
pnpm add -D vitest
```</span></pre>
<p><span class="koboSpan" id="kobo.347.1">Now that we have our testing library set up, let’s create a simple helper</span><a id="_idTextAnchor305"/><span class="koboSpan" id="kobo.348.1"> file to test </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">our configuration.</span></span></p>
<h3><span class="koboSpan" id="kobo.350.1">Creating a helper file</span></h3>
<p><span class="koboSpan" id="kobo.351.1">For our </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.352.1">demonstration, we will create a helper file inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">src/helpers</span></strong><span class="koboSpan" id="kobo.354.1"> folder and add a simple function to increment a value. </span><span class="koboSpan" id="kobo.354.2">The following snippet shows the code example we have added to the newly </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">created file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.356.1">
// src/helpers/index.js
export function increment(current, max = 10) {
 if (current &lt; max) {
   return current + 1;
 }
 return current;
}</span></pre>
<p><span class="koboSpan" id="kobo.357.1">The increment function written previously increments a value by </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">1</span></strong><span class="koboSpan" id="kobo.359.1"> until the max value is reached. </span><span class="koboSpan" id="kobo.359.2">If the max value is reached, it simply returns the current value. </span><span class="koboSpan" id="kobo.359.3">Next, let’</span><a id="_idTextAnchor306"/><span class="koboSpan" id="kobo.360.1">s write a basic unit test </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">for it.</span></span></p>
<h3><span class="koboSpan" id="kobo.362.1">Writing a basic test</span></h3>
<p><span class="koboSpan" id="kobo.363.1">In this </span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.364.1">section, we will write a simple unit test for this function. </span><span class="koboSpan" id="kobo.364.2">You can follow this by writing unit tests for all the functions and methods of your </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">enterprise project:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.366.1">
import { describe, it, expect } from 'vitest';
import { increment } from '../../helpers';
describe('increment', () =&gt; {
 it('increments the current number by 1', () =&gt; {
   expect(increment(0, 10)).toBe(1);
 });
 it('does not increment the current number over the max', () =&gt; {
   expect(increment(10, 10)).toBe(10);
 });
 it('has a default max of 10', () =&gt; {
   expect(increment(10)).toBe(10);
 });
});</span></pre>
<p><span class="koboSpan" id="kobo.367.1">We will </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.368.1">explore unit te</span><a id="_idTextAnchor307"/><span class="koboSpan" id="kobo.369.1">sting in depth in the </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">next chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">Let’s walk through the preceding code together and underst</span><a id="_idTextAnchor308"/><span class="koboSpan" id="kobo.372.1">and the nitty-gritty details </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">of it:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.374.1">Step 1: Adding the </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.375.1">required packages</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.376.1">First, we need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">vitest</span></strong><span class="koboSpan" id="kobo.378.1"> package and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">helper</span></strong><span class="koboSpan" id="kobo.380.1"> file to test. </span><span class="koboSpan" id="kobo.380.2">Next, we use the exported functions to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">describe</span></strong><span class="koboSpan" id="kobo.382.1"> block, and </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">so on:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.384.1">
import { describe, it, expect } from 'vitest';
import { increment } from '../../helpers';
describe('increment', () =&gt; {
….
</span><span class="koboSpan" id="kobo.384.2">});</span></pre>
<p><span class="koboSpan" id="kobo.385.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">describe</span></strong><span class="koboSpan" id="kobo.387.1"> block is used to group related test cases, as demonstr</span><a id="_idTextAnchor309"/><span class="koboSpan" id="kobo.388.1">ated in the preceding </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">code snippet.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.390.1">Step 2: Using the </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.391.1">it function</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.392.1">Next, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">it</span></strong><span class="koboSpan" id="kobo.394.1"> function to test specific use cases of our function. </span><span class="koboSpan" id="kobo.394.2">For instance, we test to make sure the number actually increases by </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">1</span></strong><span class="koboSpan" id="kobo.396.1"> each time the function </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">is called:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.398.1">
 it('increments the current number by 1', () =&gt; {
   exp</span><a id="_idTextAnchor310"/><a id="_idTextAnchor311"/><span class="koboSpan" id="kobo.399.1">ect(increment(0, 10)).toBe(1);
 });</span></pre>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.400.1">Step 3: Using the </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.401.1">except function</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.402.1">Lastly, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">expect</span></strong><span class="koboSpan" id="kobo.404.1"> function is used to test the use case. </span><span class="koboSpan" id="kobo.404.2">You pass in a value and expect the value to be equal to another value, as shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">the example.</span></span></p>
<p><span class="koboSpan" id="kobo.406.1">You can </span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.407.1">access different methods (</span><a href="https://vitest.dev/api/#expect"><span class="koboSpan" id="kobo.408.1">https://vitest.dev/api/#expect</span></a><span class="koboSpan" id="kobo.409.1">) from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">expect</span></strong><span class="koboSpan" id="kobo.411.1"> object aside from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">toBe()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.413.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.414.1">In the next section, we will cover the process of running your test with Vitest and creating your first com</span><a id="_idTextAnchor312"/><span class="koboSpan" id="kobo.415.1">ponent/integration </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">testing examples.</span></span></p>
<h3><span class="koboSpan" id="kobo.417.1">Running a test with Vitest</span></h3>
<p><span class="koboSpan" id="kobo.418.1">We will </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.419.1">now run the test to see whether it passes or not. </span><span class="koboSpan" id="kobo.419.2">Type the following command into your </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">root terminal:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.421.1">
yarn test</span></pre>
<p><span class="koboSpan" id="kobo.422.1">If your test is successful, you should see that the three cases passed, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<span class="koboSpan" id="kobo.424.1"><img alt="Figure 8.4 – A screenshot showing the test result" src="image/Figure_8.04_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.425.1">Figure 8.4 – A screenshot showing the test result</span></p>
<p><span class="koboSpan" id="kobo.426.1">In this </span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.427.1">section, we have demonstrated how to configure and structure software testing with Vue.js 3 using the latest Vitest testing library for Vue.js 3. </span><span class="koboSpan" id="kobo.427.2">We have also learned how to write a basic unit test. </span><span class="koboSpan" id="kobo.427.3">In the next section, we will learn how to </span><a id="_idTextAnchor313"/><span class="koboSpan" id="kobo.428.1">create basic </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">component-based testing.</span></span></p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor314"/><span class="koboSpan" id="kobo.430.1">Component testing in Vue.js 3</span></h1>
<p><span class="koboSpan" id="kobo.431.1">In Vue.js, components are the main building block of the UI and refer to a single unit of the application </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.432.1">that is shareable, testable, and reusable. </span><span class="koboSpan" id="kobo.432.2">Therefore, component testing sits between unit testing and end-to-end testing. </span><span class="koboSpan" id="kobo.432.3">It can also be referred to as </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">integration testing.</span></span></p>
<p><span class="koboSpan" id="kobo.434.1">In the </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.435.1">previous chapters, where we integrated atomic patterns using Storybook, we discussed creating component stories and how to create them. </span><span class="koboSpan" id="kobo.435.2">If you created stories for all your components and configured them to work properly as demonstrated, then you will have already implemented component testing using </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">Storybook stories.</span></span></p>
<p><span class="koboSpan" id="kobo.437.1">However, </span><a href="B17237_10.xhtml#_idTextAnchor363"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.438.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.439.1">, </span><em class="italic"><span class="koboSpan" id="kobo.440.1">Integrating Testing in Vue.js 3</span></em><span class="koboSpan" id="kobo.441.1"> is dedicated to exploring component testing. </span><span class="koboSpan" id="kobo.441.2">Nevertheless, we will briefly illustrate in this chapter how to implement simple component-based testing to aid </span><a id="_idTextAnchor315"/><span class="koboSpan" id="kobo.442.1">our understanding of the </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">next chapters.</span></span></p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor316"/><span class="koboSpan" id="kobo.444.1">Writing a basic component test</span></h2>
<p><span class="koboSpan" id="kobo.445.1">We will </span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.446.1">start by installing the new testing library for Vue.js 3. </span><span class="koboSpan" id="kobo.446.2">Since we are using Vite in the project, we will also install the Vitest library for our test runner. </span><span class="koboSpan" id="kobo.446.3">You can read more about the new Vue.js 3 test </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">library (</span></span><a href="https://vuejs.org/guide/scaling-up/testing.html"><span class="No-Break"><span class="koboSpan" id="kobo.448.1">https://</span><span id="_idTextAnchor317"/><span class="koboSpan" id="kobo.449.1">vuejs.org/guide/scaling-up/testing.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.450.1">).</span></span></p>
<h3><span class="koboSpan" id="kobo.451.1">Installing the test library</span></h3>
<p><span class="koboSpan" id="kobo.452.1">As of the </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.453.1">time of writing, </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">@testing-library/vue</span></strong><span class="koboSpan" id="kobo.455.1"> (</span><a href="https://github.com/testing-library/vue-testing-library"><span class="koboSpan" id="kobo.456.1">https://github.com/testing-library/vue-testing-library</span></a><span class="koboSpan" id="kobo.457.1">) is recommended for component testing, and we will install it in our example. </span><span class="koboSpan" id="kobo.457.2">Run the following command to </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">install it:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.459.1">
```bash
npm install -D vitest happy-dom @testing-library/vue
```</span></pre>
<p><span class="koboSpan" id="kobo.460.1">Next, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">vite.config.js</span></strong><span class="koboSpan" id="kobo.462.1"> file and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">following configuration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.464.1">
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
// https://vitejs.dev/config/
export default defineConfig({
 plugins: [vue()],
 test: {
   environment: 'happy-dom',
   globals: true,
 },
});</span></pre>
<p><span class="koboSpan" id="kobo.465.1">This </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.466.1">configuration should allow us to run both unit and component tests at the same time. </span><span class="koboSpan" id="kobo.466.2">N</span><a id="_idTextAnchor318"/><span class="koboSpan" id="kobo.467.1">ext, let’s create a simple </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">component test.</span></span></p>
<h3><span class="koboSpan" id="kobo.469.1">Creating a basic component test</span></h3>
<p><span class="koboSpan" id="kobo.470.1">Here </span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.471.1">is a simple component test snippet to demonstrate </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">the process:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.473.1">
import { render } from '@testing-library/vue';
import Button from '../../components/atoms/Button.vue';
test('mounted a button with custom label', async () =&gt; {
 // The render method returns a collection of utilities to
 // query your component.
 </span><span class="koboSpan" id="kobo.473.2">const { getByText } = render(Button, {
   props: {
     label: 'Test',
   },
 });
 // getByText returns the first matching node for the
 // provided text, and Check if button is render with Label
 // from props
 const button = getByText('Test');
});</span></pre>
<p><span class="koboSpan" id="kobo.474.1">The test simply renders </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">Button</span></strong><span class="koboSpan" id="kobo.476.1"> with a custom label value and also checks whether we can retrieve the custo</span><a id="_idTextAnchor319"/><span class="koboSpan" id="kobo.477.1">m label added during the </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">rendering process.</span></span></p>
<h3><span class="koboSpan" id="kobo.479.1">Running the test</span></h3>
<p><span class="koboSpan" id="kobo.480.1">Running the </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.481.1">test will result in four passed test cases, including the unit test we </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">created earlier:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<span class="koboSpan" id="kobo.483.1"><img alt="Figure 8.5 – A screenshot showing the final test result with integration testing" src="image/Figure_8.05_B17237.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.484.1">Figure 8.5 – A screenshot showing the final test result with integration testing</span></p>
<p><span class="koboSpan" id="kobo.485.1">In this section, we have demonstrated how to configure and structure component testing, also known as integration testing, with Vue.js 3 using the latest Vitest testing library for Vue.js 3. </span><span class="koboSpan" id="kobo.485.2">We have also written basic component tests to help us understand the process. </span><span class="koboSpan" id="kobo.485.3">In the next chapters, we will look in-depth at the different types of testing we can perform when building enterprise projects with </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">Vue.js 3.</span></span></p>
<p><span class="koboSpan" id="kobo.487.1">You can clone the latest repository for this chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">here: </span></span><a href="https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-8"><span class="No-Break"><span class="koboSpan" id="kobo.489.1">https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterp</span><span id="_idTextAnchor320"/><span class="koboSpan" id="kobo.490.1">rise-Ready-Web-Applications/tree/chapter-8</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.491.1">.</span></span></p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor321"/><span class="koboSpan" id="kobo.492.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.493.1">This chapter dove deeper into the concept of software testing to deliver scalable, high-performing, and bug-free applications. </span><span class="koboSpan" id="kobo.493.2">We also explored what to test from an array of available components and methods. </span><span class="koboSpan" id="kobo.493.3">In addition, we utilized our knowledge of software testing to create basic unit and component test cases in Vue.js 3 </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">using Vitest.</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">In the next chapter, we will explore everything related to unit testing. </span><span class="koboSpan" id="kobo.495.2">We will learn how to unit test a Vue.js 3 component and the component and page methods. </span><span class="koboSpan" id="kobo.495.3">We will also learn about unit testing tools such as Vitest and use them to effectively unit test an </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">enterprise project.</span></span></p>
</div>
</body></html>