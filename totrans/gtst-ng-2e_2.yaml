- en: Chapter 2. The Building Blocks of an Angular Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。Angular应用程序的构建块
- en: In the previous chapter, we looked at the drivers for the design decisions behind
    the new Angular. We described the main reasons that led to the development of
    a brand new framework; Angular takes advantage of the newest Web standards while
    keeping the past lessons in mind. Although we are familiar with the main drivers,
    we still haven't described the core Angular concepts. The last major release of
    the framework took a different path from AngularJS and introduced a lot of changes
    in the fundamental building blocks used for the development of single-page applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了新Angular背后的设计决策的驱动因素。我们描述了导致开发全新框架的主要原因；Angular利用最新的Web标准，同时吸取过去的教训。尽管我们熟悉主要驱动因素，但我们还没有描述Angular的核心概念。框架的最后一个主要版本与AngularJS采取了不同的路径，并在用于开发单页应用程序的基本构建块中引入了许多变化。
- en: The mission of this chapter is to describe the framework's core and make a brief
    introduction to its main concepts. In the next couple of pages, we will also make an
    overview of how these concepts can be put together to help us build professional
    user interfaces for our Web applications. The subsequent sections will give us
    an overview of everything that we will learn in more detail later in this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的使命是描述框架的核心，并对其主要概念进行简要介绍。在接下来的几页中，我们还将概述如何将这些概念组合起来，以帮助我们为Web应用程序构建专业的用户界面。随后的章节将概述我们将在本书的后续部分更详细地学习的内容。
- en: 'In this chapter, we will take a look at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: A conceptual overview of the framework, showing how different concepts relate
    to each other.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架的概念概述，展示了不同概念之间的关系。
- en: How we can build a user interface as a composition of components.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何将用户界面构建为组件的组合。
- en: What path the directives took in the new versions of Angular, and how their
    interface changed compared to the previous major version of the framework.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular的新版本中，指令采取了什么路径，以及它们的接口与框架的前一个主要版本相比发生了怎样的变化。
- en: The reasons for the enforced separation of concerns, which led to the decomposition
    of the directives into two different concepts. In order to get a better sense
    of them, we will demonstrate basic syntax for their definition.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制分离关注点的原因，这导致了指令分解为两个不同的概念。为了更好地理解它们，我们将演示它们定义的基本语法。
- en: An overview of the improved change detection, and how it involves the context
    that directives provide.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进的变化检测概述，以及它如何涉及指令提供的上下文。
- en: What zones are, and how they can make our daily development process easier.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区域是什么，以及它们如何使我们的日常开发过程变得更简单。
- en: What pipes are, and how they are related to the AngularJS filters.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道是什么，以及它们与AngularJS过滤器的关系。
- en: Introduction to the brand new **dependency injection** (**DI**) mechanism in
    Angular and how it is related to the services.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Angular中全新的**依赖注入（DI**）机制及其与服务的关联。
- en: A conceptual overview of Angular
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular的概念概述
- en: 'Before we dive into the different parts of Angular, let''s get a conceptual
    overview of how everything fits together. Let''s take a look at the following
    diagram:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究Angular的不同部分之前，让我们先了解一个概念性的概述，看看所有这些是如何结合在一起的。让我们看一下以下图表：
- en: '![A conceptual overview of Angular](img/5081_02_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![Angular的概念概述](img/5081_02_01.jpg)'
- en: Figure 1
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图1
- en: '*Figure 1* to *Figure 4* show the main Angular concepts and the connections
    between them. The main purpose of these diagrams is to illustrate the core blocks
    for building single-page applications with Angular, and their relations.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1* 到 *图4* 展示了Angular的主要概念及其之间的联系。这些图表的主要目的是说明使用Angular构建单页应用程序的核心模块及其关系。'
- en: The **Component** is the main building block we will use to create the user
    interface of our applications with Angular. The **Component** is a direct successor
    of the **Directive**, which is the primitive for attaching behavior to the DOM.
    Components extend **Directives** by providing further features, such as a template,
    which can be used to render composition of directives. Inside the template of
    the view can reside different expressions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件**是我们将使用来创建Angular应用程序用户界面的主要构建块。**组件**是**指令**的直接后继者，而**指令**是用于将行为附加到DOM的原始形式。组件通过提供进一步的功能（如模板）来扩展**指令**，该模板可以用于渲染指令的组合。在视图的模板内部可以存在不同的表达式。'
- en: '![A conceptual overview of Angular](img/5081_02_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Angular的概念概述](img/5081_02_02.jpg)'
- en: Figure 2
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图2
- en: The preceding diagram conceptually illustrates the **Change Detection** mechanism
    of Angular. It performs dirty checking, which evaluates the registered expressions
    in the context of specific UI components. Since the concept of scope has been removed
    from Angular, the execution context of the expressions are the instances of the
    controllers of the components associated with them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表从概念上说明了Angular的**变更检测**机制。它执行脏检查，评估特定UI组件上下文中的注册表达式。由于作用域的概念已经从Angular中移除，因此表达式的执行上下文是与它们关联的组件控制器的实例。
- en: The **Change Detection** mechanism can be enhanced using **Differs**; that's
    why there's a direct relation between these two elements on the diagram.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用**Differs**增强**变更检测**机制；这就是为什么这两个元素在图表中存在直接关系的原因。
- en: '**Pipes** are another component of Angular. We can think of Pipes as the filters
    from AngularJS. Pipes can be used together with components. We can include them
    in the expressions, which are defined in the context of any component.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**管道**是Angular的另一个组件。我们可以将管道视为AngularJS中的过滤器。管道可以与组件一起使用。我们可以在任何组件的上下文中定义的表达式中包含它们。'
- en: '![A conceptual overview of Angular](img/5081_02_03.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Angular的概念概述](img/5081_02_03.jpg)'
- en: Figure 3
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图3
- en: Now let's take a look at the preceding diagram. **Directives** and **Components**
    delegate the business logic to **Services**. This enforces better separation of
    concerns, maintainability, and code reusability. **Directives** receive references
    to instances of specific services declared as dependencies using the **DI** mechanism
    of the framework, and delegate the execution of the business-related logic to
    them. Both **Directives** and **Components** may use the **DI** mechanism, not
    only to inject services but also to inject DOM elements and/or other **Components**
    or **Directives**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看前面的图表。**指令**和**组件**将业务逻辑委托给**服务**。这强制执行更好的关注点分离、可维护性和代码重用性。**指令**通过框架的DI机制接收声明为依赖关系的特定服务的实例引用，并将与业务相关的逻辑执行委托给它们。**指令**和**组件**都可以使用**DI**机制，不仅用于注入服务，还可以注入DOM元素和/或其他**组件**或**指令**。
- en: '**Modules** (also known as **NgModules**) are a core concept which combines the
    building blocks into separate, logically related, groups. NgModules are quite
    similar to the AngularJS modules but bring more semantics on top. Note that NgModules
    are different from the ES2015 modules that we described in [Chapter 3](ch03.html
    "Chapter 3. TypeScript Crash Course"), *TypeScript Crash Course*. The Angular
    modules are a framework feature, in contrast to ES2015 modules which are a language
    construct.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块**（也称为**NgModules**）是一个核心概念，它将构建块组合成单独的、逻辑上相关的组。NgModules与AngularJS模块非常相似，但在此基础上增加了更多的语义。请注意，NgModules与我们[第3章](ch03.html
    "第3章。TypeScript快速入门")中描述的ES2015模块不同，*TypeScript快速入门*。Angular模块是一个框架特性，而ES2015模块是一个语言结构。'
- en: 'NgModules have the following responsibilities:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: NgModules有以下职责：
- en: Provide context of the Angular template compiler.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供Angular模板编译器的上下文。
- en: Provide a level of encapsulation where we can have components or directives,
    which are used only within the boundaries of a given module.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一种封装级别，其中我们可以拥有仅限于给定模块边界内使用的组件或指令。
- en: In NgModules, we can configure the providers for the DI mechanism of the framework.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在NgModules中，我们可以配置框架的DI机制的提供者。
- en: '![A conceptual overview of Angular](img/5081_02_04.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Angular的概念概述](img/5081_02_04.jpg)'
- en: Figure 4
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图4
- en: Lastly, the new router is used to define the routes in our application. Since
    **Directives** do not own a template, only the **Components** can be rendered
    by the router, representing the different views in our application. The router
    also uses a set of predefined directives, which allow us to define hyperlinks
    between the different views and the container where they should be rendered.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，新的路由器用于定义我们应用程序中的路由。由于**指令**不拥有模板，只有**组件**可以被路由器渲染，代表我们应用程序中的不同视图。路由器还使用一组预定义的指令，允许我们在不同的视图和它们应该渲染的容器之间定义超链接。
- en: Now, we will look more closely at these concepts, see how they work together
    to make Angular applications, and how they've changed from their AngularJS predecessors.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更仔细地研究这些概念，看看它们是如何一起工作来构建Angular应用程序的，以及它们是如何从它们的AngularJS前辈中演变而来的。
- en: Changing directives
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改指令
- en: AngularJS introduced the concept of directives in the development of single-page
    applications. The purpose of directives is to encapsulate the DOM-related logic
    and allow us to build user interfaces by composing them. This way, we are able
    to extend the syntax and the semantics of HTML. Initially, like most innovative
    concepts, directives were viewed controversially because they predispose us to
    write invalid HTML when using custom elements or attributes without the `data-`
    prefix. However, over time, this concept has gradually been accepted and has proved
    that it is here to stay.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 在开发单页应用程序的过程中引入了指令的概念。指令的目的是封装与 DOM 相关的逻辑，并允许我们通过组合它们来构建用户界面。这样，我们能够扩展
    HTML 的语法和语义。最初，像大多数创新概念一样，指令受到了争议性的看法，因为它们使我们倾向于在不使用 `data-` 前缀的自定义元素或属性时编写无效的
    HTML。然而，随着时间的推移，这个概念逐渐被接受，并证明它将长期存在。
- en: Another drawback of the implementation of directives in AngularJS is the different
    ways we can use them. This requires an understanding of the attribute values,
    which can be literals, expressions, callbacks, or microsyntax. This makes tooling
    essentially impossible.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 中指令实现的另一个缺点是我们可以使用它们的不同方式。这需要理解属性值，这些值可以是字面量、表达式、回调或微语法。这使得工具基本上变得不可能。
- en: The latest versions of Angular keep the concept of directives, but take the
    best parts from AngularJS and add some new ideas and syntax to it. The main purpose
    of Angular's directives is to attach behavior to the DOM by extending it with
    custom logic defined in an ES2015 class. We can think of these classes as controllers
    associated to the directives and think of their constructors as similar to the
    linking function of the directives from AngularJS. However, the new directives
    have limited configurability. They do not allow to associate a template with them,
    which makes most of the already known properties for defining directives unnecessary.
    The simplicity of the API does not limit directives' behavior, but only enforces
    stronger separation of concerns. To complement this simpler API, Angular 2 introduced
    a richer interface for the definition of UI elements, called components. Components
    extend the functionality of directives by allowing them to own a template, through
    the** component metadata**. We will take a further look at components later in
    this book.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的最新版本保留了指令的概念，但从中吸取了 AngularJS 的最佳部分，并添加了一些新的想法和语法。Angular 指令的主要目的是通过扩展到在
    ES2015 类中定义的自定义逻辑来将行为附加到 DOM 上。我们可以将这些类视为与指令关联的控制器，并将它们的构造函数视为与 AngularJS 指令的链接函数类似。然而，新的指令具有有限的配置性。它们不允许将模板与它们关联，这使得大多数已知用于定义指令的属性变得不必要。API
    的简单性并不限制指令的行为，但只强制执行更严格的关注点分离。为了补充这个更简单的 API，Angular 2 引入了一个更丰富的界面来定义 UI 元素，称为组件。组件通过允许它们拥有模板，通过
    **组件元数据** 扩展了指令的功能。我们将在本书的后面进一步探讨组件。
- en: 'The syntax used for Angular directives involves ES2016 decorators. We can use
    TypeScript, ES2015, or even **ECMAScript** **5** (**ES5**) in order to achieve
    the same result with a little bit more typing. This code defines a simple directive,
    written in TypeScript:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 用于 Angular 指令的语法涉及 ES2016 装饰器。我们可以使用 TypeScript、ES2015，甚至 **ECMAScript** **5**
    （**ES5**）来通过稍微多一点的输入实现相同的结果。此代码定义了一个简单的指令，使用 TypeScript 编写：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The directive can be used with the following markup in our template:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 指令可以用以下标记在我们的模板中使用：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once the user points over the label, **Tell me the answer!**, Angular will invoke
    the method defined under the `@HostListener` decorator in the directive's definition.
    In the end, the `open` method of the overlay manager will be executed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户将鼠标悬停在标签上，**告诉我答案！**，Angular 将会调用在指令定义中由 `@HostListener` 装饰器定义的方法。最终，覆盖管理器的
    `open` 方法将被执行。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since we can have multiple directives on a single element, the best practices
    state that we should use an attribute as a selector.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以在单个元素上使用多个指令，最佳实践建议我们应该使用一个属性作为选择器。
- en: 'An alternative ECMAScript 5 syntax for the definition of this directive is
    as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 定义此指令的 ECMAScript 5 语法如下：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding ES5 syntax demonstrates the internal JavaScript DSL that Angular
    provides in order to allow us to write our code without the syntax, which is not
    yet supported by modern browsers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 ES5 语法展示了 Angular 提供的内部 JavaScript DSL，以便我们能够在现代浏览器尚未支持的语法下编写我们的代码。
- en: We can summarize that Angular kept the concept of directives by maintaining
    the idea of attaching behavior to the DOM. The core differences with AngularJS
    are the new syntax, and the further separation of concerns introduced by bringing
    the components. In [Chapter 4](ch04.html "Chapter 4. Getting Started with Angular
    Components and Directives"), *Getting Started with Angular Components and Directives*,
    we will take a further look at directives' API. We'll also compare the directives'
    definition syntax using ES2016 and ES5\. Now, let's take a look at the big change to
    Angular components.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以总结说，Angular 通过保持将行为附加到 DOM 的想法来保留了指令的概念。与 AngularJS 的核心区别在于新的语法，以及通过引入组件带来的关注点分离的进一步分离。在[第
    4 章](ch04.html "第 4 章。开始使用 Angular 组件和指令")，*开始使用 Angular 组件和指令*中，我们将进一步探讨指令的 API。我们还将比较使用
    ES2016 和 ES5 定义的指令定义语法。现在，让我们看看 Angular 组件的巨大变化。
- en: Getting to know Angular components
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Angular 组件
- en: '**Model View Controller** (**MVC**) is a micro-architectural pattern initially
    introduced for the implementation of user interfaces. As Angular developers, we
    use different variations of this pattern on a daily basis, most often **Model
    View ViewModel** (**MVVM**). In MVC, we have the model, which encapsulates the
    business logic of our application, and the view, which is responsible for rendering
    the user interface, accepting user input, and delegating the user interaction
    logic to the controller. The view is represented as composition of components,
    which is formally known as the **composite design pattern**.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）是一种最初为用户界面实现引入的微架构模式。作为 Angular 开发者，我们每天都在使用这种模式的多种变体，最常见的是**模型-视图-视图模型**（**MVVM**）。在
    MVC 中，我们有模型，它封装了应用程序的业务逻辑，以及视图，它负责渲染用户界面、接受用户输入并将用户交互逻辑委托给控制器。视图被表示为组件的组合，这正式称为**组合设计模式**。'
- en: 'Let''s take a look at the following structural diagram, which shows the composite
    design pattern:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下的结构图，它展示了组合设计模式：
- en: '![Getting to know Angular components](img/5081_02_05.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![了解 Angular 组件](img/5081_02_05.jpg)'
- en: Figure 5
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5
- en: 'Here, we have three classes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有三个类：
- en: An abstract class called `Component`.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `Component` 的抽象类。
- en: Two concrete classes called `Leaf` and `Composite`. The `Leaf` class is a simple
    terminal component in the component tree that we will build soon.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个具体的类，称为 `Leaf` 和 `Composite`。`Leaf` 类是我们即将构建的组件树中的简单终端组件。
- en: The `Component` class defines an abstract operation called `operation`. Both
    `Leaf` and `Composite` inherit from the `Component` class. However, the `Composite`
    class also owns references to it. We can take this even further and allow `Composite`
    to own a list of references to instances of `Component`, as shown in the diagram.
    The components list inside `Composite` can hold references to different `Composite`
    or `Leaf` instances, or instances of other classes, which extend the `Component`
    class or any of its successors. We can have a different behavior of the `operation`
    methods of the individual `Component` instances invoked within the implementation
    of the `operation` method of `Composite`. This is because of the late-binding
    mechanism used for the implementation of polymorphism in object-oriented programming
    languages.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Component` 类定义了一个名为 `operation` 的抽象操作。`Leaf` 和 `Composite` 都继承自 `Component`
    类。然而，`Composite` 类还拥有对其的引用。我们可以更进一步，允许 `Composite` 拥有一个 `Component` 实例的引用列表，如图中所示。`Composite`
    内部的组件列表可以持有对不同的 `Composite` 或 `Leaf` 实例，或扩展 `Component` 类或其任何后继类的其他类的实例的引用。我们可以在
    `Composite` 的 `operation` 方法实现中调用单个 `Component` 实例的 `operation` 方法的不同行为。这是因为对象面向编程语言中实现多态所使用的后期绑定机制。'
- en: Components in action
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件应用
- en: 'Enough of theory! Let''s build a component tree based on the class hierarchy
    illustrated in the preceding diagram. This way, we will demonstrate how we can
    take advantage of the composite pattern for building user interface using simplified
    syntax. We will take a look at a similar example in the context of Angular in
    [Chapter 4](ch04.html "Chapter 4. Getting Started with Angular Components and
    Directives"), *Getting Started with Angular Components and Directives*:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 理论就到这里！让我们根据前面图中展示的类层次结构构建一个组件树。这样，我们将展示如何利用组合模式通过简化的语法构建用户界面。我们将在[第 4 章](ch04.html
    "第 4 章。开始使用 Angular 组件和指令")，*开始使用 Angular 组件和指令*的上下文中查看一个类似的例子：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding pseudo-code creates three instances of the `Composite` class
    and three instances of the `Leaf` class. The `c1` instance holds references to
    `c2` and `c3` inside the components list. The `c2` instance holds references to
    `l1` and `l2`, and `c3` holds reference to `l3`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上述伪代码创建了三个 `Composite` 类的实例和三个 `Leaf` 类的实例。`c1` 实例在组件列表中持有对 `c2` 和 `c3` 的引用。`c2`
    实例持有对 `l1` 和 `l2` 的引用，而 `c3` 持有对 `l3` 的引用：
- en: '![Components in action](img/5081_02_06.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![组件在行动中](img/5081_02_06.jpg)'
- en: Figure 6
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6
- en: The preceding diagram is a graphical representation of the component tree we
    built in the snippet. This is a simplified version of what the view in the modern
    JavaScript frameworks looks similar to. However, it illustrates the very basics
    of how we can compose directives and components. For instance, in the context
    of Angular, we can think of directives as instances of the `Leaf` class (since
    they don't own view and, thus, cannot compose other directives and components)
    and components as instances of the `Composite` class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示是我们片段中构建的组件树的图形表示。这是现代 JavaScript 框架中视图类似的一个简化版本。然而，它说明了我们可以如何组合指令和组件的基础。例如，在
    Angular 的上下文中，我们可以将指令视为 `Leaf` 类的实例（因为它们不拥有视图，因此不能组合其他指令和组件），而组件则是 `Composite`
    类的实例。
- en: If we think more abstractly for the user interface in AngularJS, we can notice
    that we used quite a similar approach. The templates of our views compose different
    directives together in order to deliver a fully functional user interface to the
    end user of our application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更抽象地考虑 AngularJS 的用户界面，我们可以注意到我们使用了相当类似的方法。我们视图的模板将不同的指令组合在一起，以便向我们的应用程序的最终用户提供一个完全功能化的用户界面。
- en: Components in Angular
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 中的组件
- en: 'Angular took this approach by introducing new building blocks called components.
    Components extend the directive concept we described in the previous section and
    provide a broader functionality. Here is the definition of a basic "Hello world"
    component:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 通过引入称为组件的新构建块采取了这种方法。组件扩展了我们之前章节中描述的指令概念，并提供了更广泛的功能。以下是一个基本的 "Hello
    world" 组件的定义：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can use it by inserting the following markup in our view:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在视图中插入以下标记来使用它：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: According to the best practices, we should use a selector of type element for
    components since we may have only a single component per DOM element.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据最佳实践，我们应该为组件使用类型为元素的选择器，因为我们可能每个 DOM 元素只有一个组件。
- en: 'The alternative ES5 syntax Angular provides using the DSL is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 使用 DSL 提供的替代 ES5 语法如下：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will take a look at the preceding syntax in more detail later in this book.
    Now let's briefly describe the functionality that this component provides. Once
    the Angular application is bootstrapped, it will look at all the elements in the DOM
    tree and process them. When it finds an element called `hello-world`, it will
    invoke the logic associated with its definition, which means that the template
    of the component will be rendered and the expression between the curly brackets
    will be evaluated. This will result in the markup, `<h1>Hello, world!</h1>`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面部分更详细地探讨前面的语法。现在让我们简要描述该组件提供的功能。一旦 Angular 应用程序启动，它将查看 DOM 树中的所有元素并处理它们。当它找到一个名为
    `hello-world` 的元素时，它将调用与其定义相关的逻辑，这意味着组件的模板将被渲染，花括号之间的表达式将被评估。这将导致以下标记 `<h1>Hello,
    world!</h1>`。
- en: So, to summarize, the Angular core team separated out the directives from AngularJS
    into two different parts-components and directives. Directives provide an easy
    way to attach behavior to DOM elements without defining a view. Components in
    Angular provide a powerful, and yet simple-to-learn API, which makes it easier
    to define the user interface of our applications. Angular components allow us
    to do the same amazing things as AngularJS directives, but with less typing and
    fewer things to learn. Components extend the Angular directive concept by adding
    a view to it. We can think of the relation between Angular components and directives
    the same way as the relation between `Composite` and `Leaf` from the diagram we
    saw in *Figure 5*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，Angular 核心团队将 AngularJS 中的指令分离成两个不同的部分——组件和指令。指令提供了一种简单的方法来将行为附加到 DOM
    元素上，而无需定义视图。Angular 中的组件提供了一个强大且易于学习的 API，这使得定义我们应用程序的用户界面变得更加容易。Angular 组件允许我们像
    AngularJS 指令一样做同样惊人的事情，但需要更少的输入和更少的学习内容。组件通过添加视图来扩展 Angular 指令的概念。我们可以将 Angular
    组件和指令之间的关系视为与我们在 *图 5* 中看到的 "Composite" 和 "Leaf" 之间的关系相同。
- en: Conceptually, we can present the relation between Directive and Component as
    inheritance. [Chapter 4](ch04.html "Chapter 4. Getting Started with Angular Components
    and Directives"), *Getting Started with Angular Components and Directives*, describes
    these two concepts in further detail.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，我们可以将指令和组件之间的关系表示为继承。[第 4 章](ch04.html "第 4 章。开始使用 Angular 组件和指令")，*开始使用
    Angular 组件和指令*，将这两个概念描述得更加详细。
- en: Angular modules
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 模块
- en: In AngularJS, we have the concept of modules. Modules there are responsible
    for grouping pieces of related functionality together and registering it internally during
    the bootstrap process. Unfortunately, they didn't provide features such as encapsulation and
    lazy loading.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AngularJS 中，我们有模块的概念。那里的模块负责将相关功能分组并在引导过程中内部注册。不幸的是，它们没有提供诸如封装和懒加载等特性。
- en: 'Angular introduced the NgModules as part of the fifth release candidate of
    the framework. The main purpose of the new modules is to give a context for the
    Angular compiler and achieve a good level of encapsulation. For instance, if we
    are building a library with NgModules, we can have a number of declarations, which
    are used internally but not exported as part of the public interface. Let''s take
    a look at the following example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 将 NgModules 作为框架第五个候选版本的组成部分引入。新模块的主要目的是为 Angular 编译器提供一个上下文，并实现良好的封装级别。例如，如果我们使用
    NgModules 构建库，我们可以有一些内部使用但不是作为公共接口一部分的声明。让我们看看以下例子：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Do not worry if you're not familiar with the TypeScript syntax in the preceding
    example; we will take a deep dive into the language in the next chapter.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对前面例子中的 TypeScript 语法不熟悉，请不要担心；我们将在下一章深入探讨这门语言。
- en: In the preceding code snippet, using the `@NgModule` decorator, we declare `TabModule`.
    Note that in the list of `declarations`, we include both `TabComponent` and `TabItemComponent`,
    but in the list of `exports`, we have only `TabComponent`. This way, we can achieve
    a level of encapsulation for our library. The users of the module will be able
    to use only `TabComponent`, so we don't have to worry about backward compatibility
    of the API of `TabItemComponent` since it's accessible only internally, within
    the boundaries of our module. Finally, by setting the `imports` property of the
    object literal passed to `@NgModule`, we can list modules that we want to use
    inside of the current module. This way, we will be able to take advantage of all
    the `exports` and `providers` (we'll discuss providers in [Chapter 5](ch05.html
    "Chapter 5. Dependency Injection in Angular"), *Dependency Injection in Angular*)
    declared by them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，使用 `@NgModule` 装饰器，我们声明了 `TabModule`。请注意，在 `declarations` 列表中，我们包括了
    `TabComponent` 和 `TabItemComponent`，但在 `exports` 列表中，我们只有 `TabComponent`。这样，我们可以为我们的库实现一定程度的封装。模块的使用者只能使用
    `TabComponent`，因此我们不必担心 `TabItemComponent` API 的向后兼容性，因为它只能在我们模块的内部访问，在我们的模块边界内。最后，通过设置传递给
    `@NgModule` 的对象字面量的 `imports` 属性，我们可以列出我们想要在当前模块内部使用的模块。这样，我们将能够利用它们声明的所有 `exports`
    和 `providers`（我们将在第 5 章[依赖注入](ch05.html "第 5 章。Angular 中的依赖注入")中讨论提供者），*Angular
    中的依赖注入*。
- en: Bootstrapping an Angular application
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导 Angular 应用
- en: 'Similar to AngularJS, before our application gets rendered, it goes through the
    bootstrap process. In the new Angular, we can bootstrap an application in different
    ways, depending on the used platform (for instance, web, NativeScript, with JiT
    or AoT compilation enabled, and so on). Let''s take a look at a simple example,
    of how we can bootstrap a Web app, in order to get a better understanding of how
    the new Angular modules can be used in the process:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与 AngularJS 类似，在我们应用渲染之前，它需要经过引导过程。在新的 Angular 中，我们可以根据所使用的平台（例如，Web、NativeScript、启用
    JiT 或 AoT 编译等）以不同的方式引导应用。让我们来看一个简单的例子，了解我们如何引导一个 Web 应用，以便更好地理解新 Angular 模块在过程中的使用方法：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the `@NgModule` decorator in the preceding example, we declare `AppComponent`
    and we also import `BrowserModule`. Note that this time, we provide value to the
    `bootstrap` property where we explicitly declare that we want `AppComponent` to
    be used for bootstrapping our application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`@NgModule` 装饰器中，我们声明了 `AppComponent` 并导入了 `BrowserModule`。请注意，这次，我们为
    `bootstrap` 属性提供了值，明确声明我们希望使用 `AppComponent` 来引导我们的应用。
- en: On the last line of the file, we invoke the `bootstrapModule` method of the
    object returned by the invocation of `platformBrowserDynamic` with argument `AppModule`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的最后一行，我们调用`platformBrowserDynamic`方法返回的对象的`bootstrapModule`方法，其中包含参数`AppModule`。
- en: In recap, the modules in Angular have an important role-they not only group
    the building blocks of our application logically but also provide a way we can
    achieve encapsulation. Last, but not least, NgModules are heavily used in the
    application's bootstrap process.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，Angular中的模块扮演着重要的角色——它们不仅逻辑上组织了我们应用程序的构建块，还提供了一种我们可以实现封装的方法。最后但同样重要的是，NgModules在应用程序的引导过程中被大量使用。
- en: Pipes
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道
- en: In business applications, we often need to have different visual representations
    of the same piece of data. For example, if we have the number 100,000 and we want
    to format it as currency, most likely we won't want to display it as plain data;
    more likely, we'll want something like $100,000.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在商业应用程序中，我们经常需要具有相同数据的不同视觉表示。例如，如果我们有数字100,000，并且想将其格式化为货币，我们很可能不想显示为纯数据；更有可能的是，我们希望显示为$100,000。
- en: The responsibility for formatting data in AngularJS was assigned to filters.
    Another example for a data formatting requirement is when we use collections of
    items. For instance, if we have a list of items, we may want to filter it based
    on a predicate (a boolean function); in a list of numbers, we may want to display
    only the prime numbers. AngularJS has a filter called `filter`, which allows us
    to do this. However, the duplication of the names often leads to confusion. That's
    another reason the core team renamed the filter component to a **pipe**.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularJS中，格式化数据的责任被分配给了过滤器。另一个数据格式化需求示例是当我们使用项目集合时。例如，如果我们有一个项目列表，我们可能希望根据谓词（一个布尔函数）对其进行过滤；在一个数字列表中，我们可能只想显示素数。AngularJS有一个名为`filter`的过滤器，允许我们这样做。然而，名称的重复经常导致混淆。这也是核心团队将过滤器组件重命名为**管道**的另一个原因。
- en: 'The motivation behind the new name is the syntax used for pipes and filters:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 新名称背后的动机是管道和过滤器所使用的语法：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding example, we apply the pipes, `decimal`, and `currency`, to
    the value returned by the `expression`. The entire expression between the curly
    braces looks like Unix pipe syntax.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将管道`decimal`和`currency`应用于`expression`返回的值。大括号之间的整个表达式看起来像Unix管道语法。
- en: Defining pipes
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义管道
- en: The syntax for defining pipes is similar to the one used for the definition
    of modules, directives, and components. In order to create a new pipe, we can
    use the ES2015 decorator, `@Pipe`. It allows us to add metadata to a class, declaring
    it as a pipe. All we need to do is provide a name for the pipe and define the
    data formatting logic. There's also an alternative ES5 syntax, which can be used
    if we want to skip the process of transpilation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 定义管道的语法类似于用于定义模块、指令和组件的语法。为了创建一个新的管道，我们可以使用ES2015装饰器`@Pipe`。它允许我们向类添加元数据，将其声明为管道。我们所需做的只是为管道提供一个名称并定义数据格式化逻辑。还有一个替代的ES5语法，如果我们想跳过转译过程，可以使用它。
- en: During runtime, once the Angular expression interpreter finds out that a given
    expression includes a call of a pipe, it will retrieve it out of the pipes' collection
    allocated within the component and invoke it with appropriate arguments.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，一旦Angular表达式解释器发现给定的表达式包含对管道的调用，它将从中检索出分配在组件内的管道集合，并使用适当的参数调用它。
- en: 'The following example illustrates how we can define a simple pipe called `lowercase1`,
    which transforms the given string, passed as argument to its lowercase representation:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了我们如何定义一个简单的名为`lowercase1`的管道，该管道将作为参数传递给它的字符串转换为小写表示：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In order to be consistent, let''s show the ECMAScript 5 syntax for defining
    pipes:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一致性，让我们展示定义管道的ECMAScript 5语法：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using the TypeScript syntax, we implement the `PipeTransform` interface and
    define the `transform` method declared inside it. However, in ECMAScript 5, we
    do not have support for interfaces, but we still need to implement the `transform`
    method in order to define a valid Angular pipe. We will explain the TypeScript
    interfaces in the next chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TypeScript语法，我们实现`PipeTransform`接口并定义其中声明的`transform`方法。然而，在ECMAScript 5中，我们没有对接口的支持，但我们需要实现`transform`方法以定义一个有效的Angular管道。我们将在下一章解释TypeScript接口。
- en: 'Now, let''s demonstrate how we can use the `lowercase1` pipe inside a component:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们演示如何在组件内部使用`lowercase1`管道：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Also, the alternative ECMAScript 5 syntax for this is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，此处的替代 ECMAScript 5 语法如下：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can use the `App` component with the following markup:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下标记使用 `App` 组件：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The result we will see on the screen is the text sample within an `h1` element.
    Note that we're including a reference to the `LowerCasePipe1` in the `declarations`
    property of the `@NgModule` decorator.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在屏幕上看到的将是 `h1` 元素内的文本样本。请注意，我们在 `@NgModule` 装饰器的 `declarations` 属性中包含了 `LowerCasePipe1`
    的引用。
- en: By keeping the data formatting logic as a separate component, Angular keeps
    the strong separation of concerns that can be seen throughout. We will take a
    look at how we can define stateful and stateless pipes for our application in
    [Chapter 7](ch07.html "Chapter 7. Explaining Pipes and Communicating with RESTful
    Services"), *Explaining Pipes and Communicating with RESTful Services*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将数据格式化逻辑作为一个单独的组件，Angular 保持了一直以来可以看到的强关注点分离。我们将在 [第 7 章](ch07.html "第 7 章。解释管道和与
    RESTful 服务通信") *解释管道和与 RESTful 服务通信* 中看看我们如何为我们的应用程序定义有状态和无状态的管道。
- en: Improving change detection
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进变更检测
- en: As we saw earlier, the view in MVC updates itself, based on change events it
    receives from the model. A number of **Model View Whatever** (**MVW**) frameworks
    took this approach and embedded the observer pattern in the core of their change
    detection mechanism.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前看到的，MVC 中的视图根据从模型接收到的变更事件来更新自己。许多 **Model View Whatever** (**MVW**) 框架采取了这种方法，并在其变更检测机制的核心中嵌入观察者模式。
- en: Classical change detection
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经典的变更检测
- en: 'Let''s take a look at a simple example, which doesn''t use any framework. Suppose,
    we have a model called `User`, which has a property called `name`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子，它没有使用任何框架。假设我们有一个名为 `User` 的模型，它有一个名为 `name` 的属性：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding snippet again uses TypeScript. Do not worry if the syntax does
    not look familiar to you, we will make an introduction to the language in the
    next chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段再次使用了 TypeScript。如果你对语法不熟悉，不要担心，我们将在下一章介绍这门语言。
- en: The `user` class extends the `EventEmitter` class. This provides primitives
    for emitting and subscribing to events.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`user` 类扩展了 `EventEmitter` 类。这为发出和订阅事件提供了原语。'
- en: 'Now, let''s define a view, which displays the `name` of an instance of the
    `User` class, passed as an argument to its `constructor`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个视图，该视图显示 `User` 类实例的 `name`，它作为参数传递给其 `constructor`：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can initialize the `view` element by:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式初始化 `view` 元素：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As the end result, the user will see a label with the content **foo**. However,
    changes in user will not be reflected by the view. In order to update the view
    when the `name` of the user changes, we need to subscribe to the `change` event
    and then update the content of the DOM element. We need to update the `View` definition
    in the following way:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果，用户将看到一个包含内容 **foo** 的标签。然而，用户的更改不会在视图中反映出来。为了在用户 `name` 发生更改时更新视图，我们需要订阅
    `change` 事件，然后更新 DOM 元素的内容。我们需要以下方式更新 `View` 定义：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is how most frameworks used to implement their change detection before
    the era of AngularJS.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是大多数框架在 AngularJS 时代之前如何实现变更检测的方式。
- en: Change detection in AngularJS
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AngularJS 的变更检测
- en: 'Most beginners are fascinated by the data binding mechanism in AngularJS. The
    basic "Hello world" example looks similar to this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数初学者都对 AngularJS 中的数据绑定机制着迷。基本的 "Hello world" 示例看起来像这样：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you run this, **Hello world!** magically appears on the screen. However,
    that is not the only most impressive thing! If we add a text input and we bind
    it to the `label` property of the scope, each change will reflect in the content
    displayed by the interpolation directive:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序，**Hello world!** 就会神奇地出现在屏幕上。然而，这并不是唯一令人印象深刻的事情！如果我们添加一个文本输入并将其绑定到作用域的
    `label` 属性，每次更改都会反映在插值指令显示的内容中：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How awesome is that! This is one of the main selling points of AngularJS-the
    extreme ease of achieving data binding. We add a few attributes in our markup,
    interpolation directive, the `label` property to a mystical object called `$scope`,
    which is magically passed to a custom function we define, and everything simply
    works!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这有多么酷！这是 AngularJS 的主要卖点之一——实现数据绑定的极端简单性。我们在标记中添加了一些属性，插值指令，将 `label` 属性添加到一个神秘的对象
    `$scope` 中，这个对象神奇地传递给我们定义的自定义函数，然后一切就简单地工作了！
- en: The more experienced Angular developer has a better understanding of what is
    actually going on behind the scenes. In the preceding example, inside the directives,
    `ng-model` and `ng-bind` (in our case, the interpolation directive, `{{}}`), Angular
    adds watchers with different behavior associated with the same expression - `label`.
    These watchers are quite similar to the observers in the classical MVC pattern.
    On some specific events (in our case, change of the content of the text input),
    AngularJS will loop over all such watchers, evaluate the expressions associated
    with them in the context of a given scope, and store their results. This loop
    is known as the **digest loop**.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 经验更丰富的Angular开发者对幕后实际发生的事情有更好的理解。在前面的例子中，在指令内部，Angular添加了与相同表达式`label`相关联的不同行为的观察者——`ng-model`和`ng-bind`（在我们的例子中，是插值指令`{{}}`）。这些观察者与经典MVC模式中的观察者相当相似。在特定事件（在我们的例子中，是文本输入内容的变化）发生时，AngularJS会遍历所有这样的观察者，在给定作用域的上下文中评估与它们相关联的表达式，并存储它们的结果。这个循环被称为**消化循环**。
- en: In the preceding examples, the evaluation of the expression, `label`, in the
    context of the scope will return the text, **Hello world!**. On each iteration,
    AngularJS will compare the current result of the evaluation with the previous
    result and will invoke the associated callback in case the values differ. For
    instance, the callback added by the interpolation directive will set the content
    of the element to be the new result of the expression's evaluation. This is an
    example of the dependency between the callbacks of the watchers of two directives.
    The callback of the watcher added by `ng-model` modifies the result of the expression
    associated with the watcher added by the interpolation directive.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，在作用域的上下文中评估表达式`label`将返回文本，**Hello world!**。在每次迭代中，AngularJS会将当前评估结果与上一个结果进行比较，并在值不同的情况下调用相关回调。例如，插值指令添加的回调会将元素的
    内容设置为表达式评估的新结果。这是一个两个指令观察者回调之间依赖性的例子。由`ng-model`添加的观察者回调修改了与插值指令添加的观察者相关联的表达式的结果。
- en: This approach has its own drawbacks. We said that the digest loop will be invoked
    on some specific events, but what if these events happen outside the framework;
    for example, what if we use `setTimeout`, and inside the callback, passed as the
    first argument, we change properties attached to the scope that we're watching?
    AngularJS will be unaware of the change and won't invoke the digest loop, so we
    need to do that explicitly using `$scope.$apply`. But, what if the framework knew
    about all the asynchronous events happening in the browser, such as user events,
    the `XMLHttpRequest` events, the `WebSocket`-related events, and others? In such
    a case, Angular would be able to intercept the event's handling and could invoke
    the digest loop without forcing us to do so!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有其自身的缺点。我们说过，消化循环将在某些特定事件上被调用，但如果我们使用`setTimeout`，并在回调函数中（作为第一个参数传递），改变我们正在监视的作用域附加的属性，这些事件会发生在框架之外；例如，如果我们使用`setTimeout`，并在回调函数中（作为第一个参数传递），改变我们正在监视的作用域附加的属性，AngularJS将不会意识到这种变化，并且不会调用消化循环，因此我们需要显式地使用`$scope.$apply`来做这件事。但是，如果框架知道浏览器中发生的所有异步事件，例如用户事件、`XMLHttpRequest`事件、与`WebSocket`相关的事件以及其他事件，会怎样呢？在这种情况下，Angular将能够拦截事件处理，并可以在不强迫我们这样做的情况下调用消化循环！
- en: In the zone.js
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`zone.js`
- en: That's exactly the case in the new versions of Angular. This functionality is
    implemented with zones using `zone.js`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular的新版本中，这种情况正是如此。这个功能是通过使用`zone.js`来实现的。
- en: At ng-conf in 2014, Brian Ford gave a talk about zones. Brian presented zones
    as meta-monkey patching of browser APIs. Zone.js is a library developed by the
    Angular team, which implements zones in JavaScript. They represent an execution
    context, which allows us to intercept asynchronous browser calls. Basically, using
    zones, we are able to invoke a piece of logic just after the given `XMLHttpRequest`
    completes or when we receive a new `WebSocket` event. Angular took advantage of
    `zone.js` by intercepting asynchronous browser events and invoking the digest
    loop just at the right time. This totally eliminates the need for explicit calls
    of the digest loop by the developer using Angular.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在2014年的ng-conf上，Brian Ford做了一次关于zones的演讲。Brian将zones描述为浏览器API的元猴子补丁。Zone.js是由Angular团队开发的一个库，它在JavaScript中实现了zones。它们代表一个执行上下文，允许我们拦截异步浏览器调用。基本上，使用zones，我们能够在给定的`XMLHttpRequest`完成或当我们收到新的`WebSocket`事件时调用一段逻辑。Angular通过拦截异步浏览器事件并在正确的时间调用消化循环来利用`zone.js`。这完全消除了使用Angular的开发者显式调用消化循环的需要。
- en: Simplified data flow
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化的数据流
- en: The cross-watcher dependencies may create a tangled data flow in our application,
    which is hard to follow. This may lead to unpredictable behavior and bugs, which
    are hard to find. Although Angular kept the dirty checking as a way to achieve
    change detection, it enforced unidirectional data flow. This happened by disallowing
    dependencies between the different watchers, which allows the digest loop to be
    run only once. This strategy increases the performance of our applications dramatically
    and reduces the complexity of the data flow. Angular also made improvements to
    memory efficiency and the performance of the digest loop. Further details on Angular's
    change detection and the different strategies used for its implementation can
    be found in [Chapter 4](ch04.html "Chapter 4. Getting Started with Angular Components
    and Directives"), *Getting Started with Angular Components and Directives*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 跨观察者依赖关系可能会在我们的应用程序中创建复杂的数据流，难以追踪。这可能导致不可预测的行为和难以发现的错误。尽管Angular将脏检查作为一种实现变更检测的方式，但它强制执行单向数据流。这是通过不允许不同观察者之间的依赖关系来实现的，这允许仅运行一次消化循环。这种策略显著提高了我们应用程序的性能，并降低了数据流的复杂性。Angular还对内存效率和消化循环的性能进行了改进。有关Angular的变更检测及其实现的不同策略的更多详细信息，请参阅[第4章](ch04.html
    "第4章。开始使用Angular组件和指令")，*开始使用Angular组件和指令*。
- en: Enhancing AngularJS's change detection
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升AngularJS的变更检测
- en: Now, let's take a step back and again think about the change detection mechanism
    of the framework.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们退一步，再次思考框架的变更检测机制。
- en: We said that inside the digest loop, Angular evaluates registered expressions
    and compares the evaluated values with the values associated with the same expressions
    in the previous iteration of the loop.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过，在消化循环内部，Angular评估注册的表达式，并将评估的值与循环前一次迭代中与相同表达式关联的值进行比较。
- en: The most optimal algorithm used for the comparison may differ depending on the
    type of the value returned from the expression's evaluation. For instance, if
    we get a mutable list of items, we need to loop over the entire collection and
    compare the items in the collections one by one in order to verify if there is
    a change or not. However, if we have an immutable list, we can perform a check
    with a constant complexity, only by comparing references. This is the case because
    the instances of immutable data structures cannot change. Instead of applying
    an operation, which intends to modify such instances, we'll get a new reference
    with the modification applied.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 用于比较的最优算法可能取决于从表达式评估返回的值的类型。例如，如果我们得到一个可变的项目列表，我们需要遍历整个集合，逐个比较集合中的项目，以验证是否有变化。然而，如果我们有一个不可变列表，我们只需通过比较引用来执行检查，就可以以恒定的复杂度进行检查。这是因为不可变数据结构的实例不能改变。而不是应用一个旨在修改这些实例的操作，我们将得到一个应用了修改的新引用。
- en: 'In AngularJS, we can add watchers using a few methods. Two of them are `$watch(exp,
    fn, deep)` and `$watchCollection(exp, fn)`. These methods give us some level of
    control over the way the change detection will perform the equality check. For
    example, adding a watcher using `$watch` and passing a `false` value as a third
    argument will make AngularJS perform a reference check (that is, compare the current
    value with the previous one using `===`). However, if we pass a truthy (any `true`
    value), the check will be deep (that is, using `angular.equals`). This way, depending
    on the expected type of the return by the expression value, we can add listeners
    in the most appropriate way in order to allow the framework to perform equality
    checks with the most optimal algorithm available. This API has two limitations:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularJS中，我们可以使用几种方法添加观察者。其中两种是`$watch(exp, fn, deep)`和`$watchCollection(exp,
    fn)`。这些方法让我们在一定程度上控制变更检测将如何执行相等性检查。例如，使用`$watch`添加观察者并将`false`值作为第三个参数传递，将使AngularJS执行引用检查（即使用`===`比较当前值和前一个值）。然而，如果我们传递一个真值（任何`true`值），检查将是深层次的（即使用`angular.equals`）。这样，根据表达式值的预期类型，我们可以以最合适的方式添加监听器，以便让框架使用最优化算法执行相等性检查。此API有两个限制：
- en: It does not allow you to choose the most appropriate equality check algorithm
    at runtime.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不允许你在运行时选择最合适的相等性检查算法。
- en: It does not allow you to extend the change detection to third parties for their
    specific data structures.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不允许你将变更检测扩展到第三方特定的数据结构。
- en: 'The Angular core team assigned this responsibility to differs, allowing them
    to extend the change detection mechanism and optimize it, based on the data we
    use in our applications. Angular defines two base classes, which we can extend
    in order to define custom algorithms:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 核心团队将这项责任分配给了 differs，使他们能够根据我们在应用程序中使用的数据扩展并优化更改检测机制。Angular 定义了两个基本类，我们可以扩展它们来定义自定义算法：
- en: '`KeyValueDiffer`: This allows us to perform advanced diffing over key value-based
    data structures.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KeyValueDiffer`：这允许我们对基于键值的数据结构进行高级的 diffing 操作。'
- en: '`IterableDiffer`: This allows us to perform advanced diffing over list-like
    data structures.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IterableDiffer`：这允许我们对类似列表的数据结构进行高级的 diffing 操作。'
- en: Angular allows us to take full control over the change detection mechanism by
    extending it with custom algorithms, which wasn't possible in the previous version
    of the framework. We'll take a further look into the change detection and how
    we can configure it in [Chapter 4](ch04.html "Chapter 4. Getting Started with
    Angular Components and Directives"), *Getting Started with Angular Components
    and Directives*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 允许我们通过扩展自定义算法来完全控制更改检测机制，这在框架的先前版本中是不可能的。我们将在第 4 章[入门 Angular 组件和指令](ch04.html
    "第 4 章。入门 Angular 组件和指令")中进一步探讨更改检测以及我们如何配置它。
- en: Services
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: 'Services are the building blocks that Angular provides for the definition of
    the business logic of our applications. In AngularJS, we had three different ways
    of defining services:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是 Angular 为定义我们应用程序的业务逻辑提供的构建块。在 AngularJS 中，我们有三种不同的方法来定义服务：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Although the first two syntactical variations provide similar functionality,
    they differ in the way the registered service will be instantiated. The third
    syntax allows further configuration of the registered provider during configuration
    time.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前两种语法变体提供了类似的功能，但它们在注册服务实例化的方式上有所不同。第三种语法允许在配置时间进一步配置注册提供者。
- en: 'Having three different methods for defining services is quite confusing for
    the AngularJS beginners. Let''s think for a second what necessitated the introduction
    of these methods for registering services. Why can''t we simply use JavaScript
    constructor functions, object literals, or ES2015 classes instead, which Angular
    will not be aware of? We could encapsulate our business logic inside a custom
    JavaScript constructor function like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 AngularJS 初学者来说，有三种不同的方法来定义服务确实很令人困惑。让我们思考一下，是什么促使引入这些方法来注册服务。为什么我们不能简单地使用
    Angular 不会意识到的 JavaScript 构造函数、对象字面量或 ES2015 类呢？我们可以像这样将我们的业务逻辑封装在一个自定义 JavaScript
    构造函数中：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This code is completely valid. However, it doesn''t take advantage of one of
    the key features that AngularJS provides: the DI mechanism. The `MainCtrl` function
    uses the constructor function, `UserTransaction`, which is visible in its body.
    The preceding code has two main pitfalls:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码完全有效。然而，它没有充分利用 AngularJS 提供的一个关键特性：DI 机制。`MainCtrl` 函数使用构造函数 `UserTransaction`，该函数在其主体中可见。前述代码有两个主要缺陷：
- en: We're coupled with the logic used for the service's instantiation.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们与服务实例化所使用的逻辑耦合在一起。
- en: The code is not testable. In order to mock `UserTransactions`, we need to monkey
    patch it.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码不可测试。为了模拟 `UserTransactions`，我们需要对其进行猴子补丁。
- en: How does AngularJS deal with these two things? When a given service is required,
    through the DI mechanism of the framework, AngularJS resolves all of its dependencies
    and instantiates it by passing it to a factory function, which encapsulates the
    logic for its creation. The factory function is passed as the second argument
    to the `factory` and `service` methods. The `provider` method allows the definition
    of a service on a lower level; the factory method there is the one under the `$get`
    property.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 如何处理这两件事？当需要某个服务时，通过框架的 DI 机制，AngularJS 解析其所有依赖项，并通过传递给一个封装其创建逻辑的工厂函数来实例化它。工厂函数作为
    `factory` 和 `service` 方法的第二个参数传递。`provider` 方法允许在较低级别上定义服务；那里的工厂方法是 `$get` 属性下的一个。
- en: 'Just like AngularJS, the new versions of Angular tolerates this separation
    of concerns as well, so the core team kept the services. In contrast to AngularJS,
    the last major version of the framework provides a much simpler interface for
    their definition by allowing us to use plain ES2015 classes or ES5 constructor
    functions. We cannot escape from the fact that we need to explicitly state the
    services that should be available for injection and somehow specify instructions
    for their instantiation. In contrast to AngularJS, now the framework uses the
    ES2016 decorator''s syntax for this purpose, instead of the methods familiar to
    us from AngularJS. This allows us to define the services in our applications as
    simple as ES2015 classes, with decorators for configuration of the DI:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 就像AngularJS一样，Angular的新版本也容忍这种关注点的分离，因此核心团队保留了服务。与AngularJS相比，框架的最后一个主要版本通过允许我们使用纯ES2015类或ES5构造函数来定义它们的接口，提供了一个更简单的接口。我们无法逃避这样一个事实，即我们需要明确声明应可注入的服务，并
    somehow指定它们的实例化指令。与AngularJS相比，现在框架使用ES2016装饰器的语法来实现这一目的，而不是我们从AngularJS中熟悉的方法。这允许我们将应用程序中的服务定义为简单的ES2015类，并使用装饰器来配置DI：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is the alternative ECMAScript 5 syntax:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是替代的ECMAScript 5语法：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Services are related to the components and the directives described in the previous
    sections. For developing highly coherent and reusable UI components, we need to
    move all the business-related logic to inside our services. Also, in order to
    develop testable components, we need to take advantage of the DI mechanism to
    resolve all their dependencies.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 服务与前面章节中描述的组件和指令相关。为了开发高度一致和可重用的UI组件，我们需要将所有与业务相关的逻辑移动到我们的服务内部。此外，为了开发可测试的组件，我们需要利用DI机制来解决它们的所有依赖项。
- en: A core difference with the services in AngularJS is the way their dependencies
    are being resolved and represented internally. AngularJS uses strings to identify
    the different services and the associated factories used for their instantiation.
    On the other hand, now Angular uses keys instead. Usually, the keys are the types
    of the distinct services. Another core difference in the instantiation is the
    hierarchical structure of injectors, which encapsulate different dependency providers
    with different visibility.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与AngularJS中的服务相比，它们依赖项的解决和内部表示方式存在一个核心差异。AngularJS使用字符串来标识不同的服务和用于其实例化的相关工厂。另一方面，现在Angular使用键。通常，键是不同服务的类型。在实例化方面的另一个核心差异是注入器的分层结构，它们封装了具有不同可见性的不同依赖项提供者。
- en: Another distinction between the services in the last two major versions of the
    framework is the simplified syntax. Although the new versions of Angular use ES2015
    classes for the definition of our business logic, we can use the ECMAScript 5
    `constructor` functions as well or use the DSL provided by the framework. The
    DI in the latest versions of Angular has a completely different syntax and has
    improved behavior by providing a consistent way of injecting dependencies. The
    syntax used in the preceding example uses ES2016 decorators, and in [Chapter 5](ch05.html
    "Chapter 5. Dependency Injection in Angular"), *Dependency Injection in Angular*,
    we'll take a look at alternative syntax, which uses ECMAScript 5\. You can also
    find a more detailed explanation of Angular services and DI in [Chapter 5](ch05.html
    "Chapter 5. Dependency Injection in Angular"), *Dependency Injection in Angular*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在框架的最后两个主要版本中，服务之间的另一个区别是简化的语法。尽管Angular的新版本使用ES2015类来定义我们的业务逻辑，但我们也可以使用ECMAScript
    5的`constructor`函数，或者使用框架提供的DSL。Angular最新版本的依赖注入（DI）具有完全不同的语法，并通过提供一种一致的方式来注入依赖项，从而改善了行为。前一个示例中使用的语法是ES2016装饰器，在[第5章](ch05.html
    "第5章。Angular中的依赖注入")，*Angular中的依赖注入*中，我们将探讨另一种语法，它使用ECMAScript 5。你还可以在[第5章](ch05.html
    "第5章。Angular中的依赖注入")，*Angular中的依赖注入*中找到对Angular服务和DI的更详细解释。
- en: The new router
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的router
- en: In traditional Web applications, all the page changes are associated with a
    full-page reload, which fetches all of the referenced resources and data and renders
    the entire page onto the screen. However, requirements for Web applications have
    evolved over time.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的Web应用程序中，所有页面更改都与整个页面重新加载相关联，这会获取所有引用的资源和数据，并将整个页面渲染到屏幕上。然而，Web应用程序的需求随着时间的推移而发展。
- en: '**Single-page applications** (**SPAs**) that we build with Angular simulate
    desktop user experiences. This often involves incremental loading of the resources
    and data required by the application, and no full-page reloads after the initial
    page load. Often, the different pages or views in SPAs are represented by different
    templates, which are loaded asynchronously and rendered on a specific position
    on the screen. Later, when the template with all the required resources is loaded
    and the route is changed, the logic attached to the selected page is invoked and
    populates the template with data. If the user presses the refresh button after
    the given page in our SPA is loaded, the same page needs to be re-rendered after
    the refresh of the view completes. This involves similar behavior: finding the
    requested view, fetching the required template with all referenced resources,
    and invoking the logic associated with that view.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用 Angular 构建的单页应用程序（**SPAs**）模拟桌面用户体验。这通常涉及按需加载应用程序所需的资源和数据，并且在初始页面加载后没有全页刷新。在
    SPAs 中，不同的页面或视图通常由不同的模板表示，这些模板异步加载并在屏幕上的特定位置渲染。稍后，当包含所有所需资源的模板加载并且路由更改时，与所选页面关联的逻辑被调用，并用数据填充模板。如果用户在我们的
    SPA 中加载给定页面后按下刷新按钮，则在视图刷新完成后，需要重新渲染相同的页面。这涉及到类似的行为：找到请求的视图，获取所有引用资源的所需模板，并调用与该视图关联的逻辑。
- en: The template that needs to be fetched, and the logic that should be invoked
    after the page reloads successfully, depends on the view selected before the user
    pressed the refresh button. The framework determines this by parsing the page
    URL, which contains the identifier of the currently selected page, represented
    in a hierarchical structure.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 需要获取的模板以及页面成功刷新后应调用的逻辑，取决于用户在按下刷新按钮之前选中的视图。框架通过解析包含当前选中页面标识符的页面 URL 来确定这一点，该标识符以分层结构表示。
- en: All the responsibilities related to the navigation, changing the URL, loading
    the appropriate template, and invoking specific logic when the view is loaded
    are assigned to the router component. These are some quite challenging tasks,
    and support for different navigation APIs required for cross-browser compatibility
    makes the implementation of routing in modern SPAs a nontrivial problem.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与导航、更改 URL、加载适当的模板以及在视图加载时调用特定逻辑相关的责任都分配给了路由器组件。这些是一些相当具有挑战性的任务，并且支持不同导航 API
    以实现跨浏览器兼容性，使得在现代 SPAs 中实现路由成为一个非平凡问题。
- en: AngularJS introduced the router in its core, which was later externalized into
    the `ngRoute` module. It allows a declarative way for defining the different views
    in our SPA, by providing a template for each page and a piece of logic that needs
    to be invoked when a page is selected. However, the functionality of the router
    is limited. It does not support essential features, such as nested view routing.
    That's one of the reasons most developers preferred to use `ui-router`, developed
    by the community. Both AngularJS's router, and `ui-router`, route-definitions
    include a route configuration object, which defines a template and a controller
    associated with the page.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 在其核心中引入了路由器，后来将其外部化为 `ngRoute` 模块。它允许通过为每个页面提供一个模板以及当页面被选中时需要调用的逻辑，以声明式的方式定义我们
    SPA 中的不同视图。然而，路由器的功能有限。它不支持基本功能，例如嵌套视图路由。这就是为什么大多数开发者更愿意使用社区开发的 `ui-router` 的一个原因。AngularJS
    的路由器和 `ui-router` 的路由定义都包含一个路由配置对象，该对象定义了一个与页面关联的模板和一个控制器。
- en: As described in the previous sections, Angular changed the building blocks it
    provides for the development of SPAs. Angular removes the floating controllers
    and instead represents views as a composition of components. This necessitates
    the development of a brand new router, which empowers these new concepts.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几节所述，Angular 改变了它为开发 SPAs 提供的构建块。Angular 移除了浮动控制器，而是将视图表示为组件的组合。这需要开发一个全新的路由器，它赋予这些新概念能力。
- en: 'The core differences between the AngularJS router and the new Angular router
    are as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 路由器和新的 Angular 路由器之间的核心区别如下：
- en: The new router is component based, `ngRoute` is not. The new Angular router
    associates a component with the individual routes or a module in case of lazy-loaded
    routes.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 路由器是基于组件的，`ngRoute` 不是。新的 Angular 路由器将组件与单个路由或模块关联，这在懒加载路由的情况下适用。
- en: There is now support for nested views.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在支持嵌套视图。
- en: Angular route definition syntax
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 路由定义语法
- en: 'Let''s take a brief look at the new syntax used by the Angular router to define
    routes in our applications:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要了解一下Angular路由器在应用中定义路由所使用的新语法：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We won't go into too much detail here since [Chapter 6](ch06.html "Chapter 6. Working
    with the Angular Router and Forms"), *Working with the Angular Router and Forms,* and
    [Chapter 7](ch07.html "Chapter 7. Explaining Pipes and Communicating with RESTful
    Services"), *Explaining Pipes and Communicating with RESTful Services*, are dedicated
    to the new router, but let's mention the main points in the preceding code snippet.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于[第6章](ch06.html "第6章。使用Angular路由器和表单")*使用Angular路由器和表单*和[第7章](ch07.html "第7章。解释管道和与RESTful服务通信")*解释管道和与RESTful服务通信*专门介绍了新路由器，所以我们这里不会过多深入，但让我们提及前面代码片段中的主要点。
- en: The router lives in `@angular/router`. Since `AppModule` is the root module
    of our application, we use the `forRoot` method of `RouterModule` in order to
    import all the required directives and services exported by the router.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器位于`@angular/router`。由于`AppModule`是我们应用的根模块，我们使用`RouterModule`的`forRoot`方法来导入路由器导出的所有所需指令和服务。
- en: The parameter passed to the `RouterModule.forRoot` decorator shows how we define
    the routes in our application. We use an array with objects, which defines the
    mappings between routes and the components associated with them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`RouterModule.forRoot`装饰器的参数显示了我们在应用中如何定义路由。我们使用一个对象数组，它定义了路由与其相关组件之间的映射。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a quick overview of the main building blocks for developing
    SPAs provided by Angular. We pointed out the main differences with the core concepts
    from AngularJS.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们快速概述了Angular提供的用于开发单页应用（SPAs）的主要构建块。我们指出了与AngularJS核心概念的主要区别。
- en: Although we can use ES2015, or even ES5, to build Angular applications, the
    recommendation from Google is to take advantage of the language used for the development
    of the framework-TypeScript. This way we can use advanced features such as Ahead-of-Time
    compilation that we're going to describe in [Chapter 8](ch08.html "Chapter 8. Tooling
    and Development Experience"), *Tooling and * *Development Experience*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使用ES2015，甚至ES5来构建Angular应用，但谷歌的建议是利用用于框架开发的语言-TypeScript。这样我们就可以使用诸如预编译等高级功能，这些功能我们将在[第8章](ch08.html
    "第8章。工具和开发体验")*工具和开发体验*中描述。
- en: In the next chapter, we'll take a look at TypeScript and how we can start using
    it in our next application. We will also explain how with ambient type definitions we
    can take advantage of the static typing in the JavaScript libraries and frameworks
    written in vanilla JavaScript.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨TypeScript以及我们如何在下一个应用中开始使用它。我们还将解释如何通过环境类型定义利用用纯JavaScript编写的JavaScript库和框架中的静态类型。
