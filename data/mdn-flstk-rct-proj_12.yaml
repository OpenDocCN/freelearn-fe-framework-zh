- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Implementing End-to-End Tests Using Playwright
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Playwright 实现端到端测试
- en: In the previous chapters, we have written unit tests for our backend using Jest.
    Now, we are going to learn how to write and run end-to-end tests on our user interface
    using Playwright. First, we set up Playwright in our project and VS Code to allow
    for running frontend tests. Then, we are going to write some frontend tests for
    our application. Next, we are going to learn about reusing test setups with fixtures.
    Finally, we are going to learn how to view test reports and run Playwright in
    CI using GitHub Actions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经使用 Jest 为我们的后端编写了单元测试。现在，我们将学习如何使用 Playwright 在我们的用户界面编写和运行端到端测试。首先，我们在项目中设置
    Playwright 和 VS Code，以便运行前端测试。然后，我们将为我们的应用程序编写一些前端测试。接下来，我们将了解如何使用 fixtures 重复使用测试设置。最后，我们将学习如何查看测试报告，并使用
    GitHub Actions 在 CI 中运行 Playwright。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主要主题：
- en: Setting up Playwright for end-to-end testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Playwright 以进行端到端测试
- en: Writing and running end-to-end tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写和运行端到端测试
- en: Reusable test setups using fixtures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 fixtures 重复使用测试设置
- en: Viewing test reports and running in CI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看测试报告和在 CI 中运行
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before we start, please install all requirements from [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016)*,
    Preparing for Full-Stack Development*, and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028)*,
    Getting to Know Node.js* *and MongoDB*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请从[*第 1 章*](B19385_01.xhtml#_idTextAnchor016)*，准备全栈开发*和[*第 2 章*](B19385_02.xhtml#_idTextAnchor028)*，了解
    Node.js*和 MongoDB*中安装所有要求。
- en: The versions listed in those chapters are the ones used throughout the book.
    While installing a newer version should not be an issue, please note that certain
    steps might work differently on a newer version. If you are having an issue with
    the code and steps provided in this book, please try using the versions mentioned
    in the *Technical requirements* section of *Chapters 1* and *2*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那些章节中列出的版本是本书中使用的版本。虽然安装较新版本不应有问题，但请注意，某些步骤在较新版本上可能有所不同。如果您在使用本书中提供的代码和步骤时遇到问题，请尝试使用*第
    1 章*和*第 2 章*中*技术要求*部分中提到的版本。
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch9](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch9).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的代码：[https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch9](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch9).
- en: If you cloned the full repository for the book, Husky may not find the `.git`
    directory when running `npm install`. In that case, just run `git init` in the
    root of the corresponding chapter folder.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您克隆了本书的完整仓库，当运行 `npm install` 时，Husky 可能找不到 `.git` 目录。在这种情况下，只需在相应章节文件夹的根目录下运行
    `git init`。
- en: 'The CiA link for this chapter can be found at: [https://youtu.be/WjwEwUR8g2c](https://youtu.be/WjwEwUR8g2c)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 CiA 链接可在：[https://youtu.be/WjwEwUR8g2c](https://youtu.be/WjwEwUR8g2c)
- en: Setting up Playwright for end-to-end testing
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Playwright 以进行端到端测试
- en: 'Playwright is a test runner to facilitate end-to-end testing on various web
    rendering engines, such as Chromium (Chrome, Edge, Opera, etc.), WebKit (Safari),
    and Firefox. It can run tests on Windows, Linux, and macOS, locally or on CI.
    There are two ways of running Playwright:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Playwright 是一个测试运行器，用于在各种网页渲染引擎上方便地进行端到端测试，例如 Chromium（Chrome、Edge、Opera 等）、WebKit（Safari）和
    Firefox。它可以在 Windows、Linux 和 macOS 上本地或 CI 中运行测试。运行 Playwright 有两种方式：
- en: '**Headed**: Opens a browser window where it can be seen what Playwright is
    doing'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Headed**：打开一个浏览器窗口，可以看到 Playwright 正在做什么'
- en: '**Headless**: Runs the rendering engine in the background and only displays
    the results of the tests in the Terminal or a generated test report'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Headless**：在后台运行渲染引擎，仅在终端或生成的测试报告中显示测试结果'
- en: In this chapter, we are going to explore both ways of running Playwright. Let’s
    now install Playwright in our project.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨运行 Playwright 的两种方式。现在，让我们在我们的项目中安装 Playwright。
- en: Installing Playwright
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Playwright
- en: 'To install Playwright, we can use `npm init playwright`, which runs a command
    that installs Playwright, creates a folder for end-to-end tests for us, adds a
    GitHub Actions workflow to run tests in CI, and installs Playwright browsers so
    it can run tests in various engines. Follow these steps to install Playwright:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Playwright，我们可以使用 `npm init playwright`，这将运行一个命令来安装 Playwright，为我们创建一个用于端到端测试的文件夹，添加一个
    GitHub Actions 工作流程以在 CI 中运行测试，并安装 Playwright 浏览器以便在多种引擎中运行测试。按照以下步骤安装 Playwright：
- en: 'Copy the existing **ch8** folder to a new **ch9** folder, as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的 **ch8** 文件夹复制到新的 **ch9** 文件夹，如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Open the **ch9** folder in VS Code and open a new Terminal.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开 **ch9** 文件夹并打开一个新的终端。
- en: 'Run the following command:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Usually, it is a good idea to install the latest version here by running **npm
    init playwright@latest**. However, to make sure the instructions in this book
    are reproducible even when new versions with breaking changes are released, we
    pin the version here.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在这里安装最新版本是一个好主意，方法是运行 **npm init playwright@latest**。然而，为了确保即使发布带有破坏性更改的新版本，本书中的说明也是可重复的，我们在这里锁定版本。
- en: When asked if you want to proceed with installing the **create-playwright**
    package, press *Return/Enter* to confirm it. Then select **JavaScript**. As for
    the directory name, keep the **tests** default name and press *Return/Enter* to
    confirm it. Type **y** to add a GitHub Actions workflow. Type **y** again to install
    Playwright browsers. It will now take a while to download and install the different
    browser engines.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当询问是否要继续安装 **create-playwright** 包时，按 *Return/Enter* 确认。然后选择 **JavaScript**。至于目录名，保持
    **tests** 的默认名称并按 *Return/Enter* 确认。输入 **y** 以添加 GitHub Actions 工作流程。再次输入 **y**
    以安装 Playwright 浏览器。现在将花费一些时间下载和安装不同的浏览器引擎。
- en: 'We need to adjust some files to make Playwright work with ES modules. Edit
    **playwright.config.js** and change the line with the **require()** import at
    the beginning of the file to the following:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要调整一些文件以使 Playwright 能够与 ES 模块一起工作。编辑 **playwright.config.js** 并将文件开头的 **require()**
    导入行更改为以下内容：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Also, change the export from **module.exports** to the following:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，将 **module.exports** 的导出更改为以下内容：
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Delete* the **tests-examples/** folder and the **tests/example.spec.js** file.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*删除* **tests-examples/** 文件夹和 **tests/example.spec.js** 文件。'
- en: After installing Playwright, we need to prepare our backend for end-to-end testing,
    so let’s do that now.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Playwright 后，我们需要为端到端测试准备我们的后端，所以现在就来做这件事。
- en: Preparing the backend for end-to-end testing
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备后端进行端到端测试
- en: 'To prepare the backend for end-to-end testing, we need to start an instance
    of the backend with the in-memory MongoDB server, similarly to what we did for
    the Jest tests. Let’s do that now:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备后端进行端到端测试，我们需要启动一个带有内存中 MongoDB 服务器的后端实例，类似于我们为 Jest 测试所做的那样。现在就来做这件事：
- en: 'Create a new **backend/src/e2e.js** file. Inside it, import **dotenv**, **globalSetup**,
    and the **app** and **initDatabase** functions:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **backend/src/e2e.js** 文件。在文件内部，导入 **dotenv**、**globalSetup** 以及 **app**
    和 **initDatabase** 函数：
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, define a new **async** function to run a testing server:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个新的 **async** 函数来运行测试服务器：
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inside this function, we first run the **globalSetup** function, which runs
    an in-memory MongoDB server. Then, we initialize the database and run the Express
    app:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数内部，我们首先运行 **globalSetup** 函数，该函数运行一个内存中的 MongoDB 服务器。然后，初始化数据库并运行 Express
    应用程序：
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we run the defined function:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们运行定义好的函数：
- en: '[PRE7]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Edit **backend/package.json** and add a new script to run the **e2e.js** file:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **backend/package.json** 并添加一个新的脚本来运行 **e2e.js** 文件：
- en: '[PRE8]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the root of the project, install **concurrently**, a tool to run two commands
    in parallel:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录中，安装 **concurrently**，这是一个用于并行运行两个命令的工具：
- en: '[PRE9]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We are going to use this tool to run the backend and frontend in parallel.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用这个工具并行运行后端和前端。
- en: 'Edit **package.json** in the root of the project and define an **e2e** script
    that will run **e2e:client** and **e2e:server** scripts in parallel:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录中编辑 **package.json** 并定义一个 **e2e** 脚本，该脚本将并行运行 **e2e:client** 和 **e2e:server**
    脚本：
- en: '[PRE10]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, define the **e2e:client** script, in which we just run the prebuilt frontend:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义 **e2e:client** 脚本，其中我们只是运行预构建的前端：
- en: '[PRE11]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For performance reasons, we do not run the dev server. Otherwise, we would be
    slowing down our end-to-end tests. We could omit the build script here, but then
    we must remember to build our frontend after making changes before running tests,
    and we must do this in CI as well. Alternatively, when running the tests locally,
    especially when we are only running certain tests and not all of them, we could
    run the dev server instead of building.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于性能原因，我们不运行开发服务器。否则，我们会减慢我们的端到端测试速度。我们在这里可以省略构建脚本，但这样我们必须在运行测试之前记住构建我们的前端，并且我们必须在
    CI 中这样做。或者，当本地运行测试时，尤其是当我们只运行某些测试而不是所有测试时，我们可以运行开发服务器而不是构建。
- en: 'Then, we define the **e2e:server** script, which runs the **e2e** script in
    the **backend** folder:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义 **e2e:server** 脚本，该脚本在 **backend** 文件夹中运行 **e2e** 脚本：
- en: '[PRE12]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Edit **playwright.config.js** and set the **baseURL** by changing the following
    line:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**playwright.config.js**并设置**baseURL**，通过更改以下行：
- en: '[PRE13]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, edit **playwright.config.js** and *replace* the **webServer** config
    at the bottom of the file with the following:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编辑**playwright.config.js**并将文件底部的**webServer**配置*替换*为以下内容：
- en: '[PRE14]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we have successfully set up Playwright and prepared the backend for
    end-to-end testing, let’s get started writing and running end-to-end tests!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功设置了Playwright并准备好了后端进行端到端测试，让我们开始编写和运行端到端测试！
- en: Writing and running end-to-end tests
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写和运行端到端测试
- en: 'We are now going to write and run our first end-to-end test with Playwright.
    Let’s start with a simple test, which just verifies that we have properly optimized
    our title for search engines. Follow these steps to write and run your first end-to-end
    test:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用Playwright编写和运行我们的第一个端到端测试。让我们从一个简单的测试开始，这个测试只是验证我们是否已经正确优化了标题以供搜索引擎使用。按照以下步骤编写和运行你的第一个端到端测试：
- en: Create a new **tests/seo.spec.js** file. Inside this file, we are going to check
    whether the title of our page is set properly.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**tests/seo.spec.js**文件。在这个文件中，我们将检查我们的页面标题是否设置正确。
- en: 'Inside this newly created file, first import the **test** and **expect** functions
    from **@playwright/test**:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新创建的文件中，首先从**@playwright/test**导入**test**和**expect**函数：
- en: '[PRE15]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we define a test in which we check whether the title of the blog is set
    properly:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个测试，检查博客的标题是否设置正确：
- en: '[PRE16]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, the `test` function is similar to how we defined tests in Jest.
    Playwright additionally allows us to access special contexts in our test, called
    `page` fixture is the most essential fixture in Playwright and allows us to access
    browser features and interact with a page.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，`test`函数与我们在Jest中定义测试的方式相似。Playwright还允许我们访问测试中的特殊上下文，称为`page`。`page`是Playwright中最基本的固定装置，允许我们访问浏览器功能和与页面交互。
- en: 'Inside the test, we first navigate to the URL of our frontend by using the
    **page.goto** function:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试中，我们首先使用**page.goto**函数导航到我们的前端URL：
- en: '[PRE17]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we use the **expect** function to check whether the page displays the
    correct title:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用**expect**函数来检查页面是否显示了正确的标题：
- en: '[PRE18]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we can see, the syntax of Playwright is very similar to Jest. We also have
    an `expect` function to make assertions, such as the page having a certain title.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们所见，Playwright的语法与Jest非常相似。我们还有一个`expect`函数来进行断言，例如检查页面是否有特定的标题。
- en: Before running the tests, make sure the **dbserver** Docker container is running.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行测试之前，请确保**dbserver**Docker容器正在运行。
- en: 'We can now run this test by opening a new Terminal and executing the following
    command:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以通过打开一个新的终端并执行以下命令来运行这个测试：
- en: '[PRE19]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You will see that Playwright runs our test three times (on Chromium, Firefox,
    and Webkit) and that all of them passed successfully. The following screenshot
    shows the result of running Playwright in the command line:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到Playwright在我们的测试中运行了三次（在Chromium、Firefox和Webkit上），并且所有测试都成功通过。以下截图显示了在命令行中运行Playwright的结果：
- en: '![Figure 9.1 – Running our first test in Playwright!](img/B19385_09_1.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 在Playwright中运行我们的第一个测试！](img/B19385_09_1.jpg)'
- en: Figure 9.1 – Running our first test in Playwright!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 在Playwright中运行我们的第一个测试！
- en: Now that we have successfully executed our test, let’s move on to running tests
    using the VS Code extension.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功执行了测试，让我们继续使用VS Code扩展运行测试。
- en: Using the VS Code extension
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用VS Code扩展
- en: Instead of manually running all tests via the command line, we can also run
    specific tests (or all tests) using a VS Code extension, similar to what we did
    for Jest. Additionally, the extension also allows us to get a visual overview
    of which tests are succeeding (or not), allows us to inspect tests while running
    in a browser, and can even record our interactions in the browser and generate
    tests from it!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过VS Code扩展运行特定的测试（或所有测试），而不是手动通过命令行运行所有测试，这与我们对Jest所做的方式类似。此外，该扩展还允许我们获得测试成功（或失败）的视觉概述，允许我们在浏览器中运行时检查测试，甚至可以记录我们在浏览器中的交互并从中生成测试！
- en: 'Let’s start by setting up the VS Code extension and running our test from it:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先设置VS Code扩展并从中运行我们的测试：
- en: Open the **Extensions** tab in VS Code and search for **Playwright**.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开**扩展**选项卡并搜索**Playwright**。
- en: Click the **Install** button to install **Playwright Test for VS Code** by Microsoft.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**安装**按钮通过Microsoft安装**Playwright Test for VS Code**。
- en: Click on the **Testing** tab in VS Code (the flask icon), which we also used
    for the Jest extension. Here, you will now see **Jest** and **Playwright** in
    the list.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中点击**测试**选项卡（flask图标），我们之前也用它来使用Jest扩展。在这里，您现在将看到列表中的**Jest**和**Playwright**。
- en: Expand the **Playwright** | **tests** path, click on **seo.spec.js** to load
    the file, and then click on the **Play** icon next to **seo.spec.js** to run the
    test.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开到**Playwright** | **tests**路径，点击**seo.spec.js**来加载文件，然后点击**seo.spec.js**旁边的**运行**图标来运行测试。
- en: 'As we can see in the following screenshot, the test was executed successfully,
    and all tests are passing:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，测试已成功执行，所有测试都通过：
- en: '![Figure 9.2 – Our playwright test successfully running from the VS Code extension!](img/B19385_09_2.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 我们从VS Code扩展中成功运行的剧作家测试！](img/B19385_09_2.jpg)'
- en: Figure 9.2 – Our playwright test successfully running from the VS Code extension!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 我们从VS Code扩展中成功运行的剧作家测试！
- en: Now that we have successfully run the tests in the VS Code extension in headless
    mode, let’s move on to running them in headed mode, where we show what Playwright
    is doing in the browser while running tests.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在无头模式下成功运行了VS Code扩展中的测试，让我们继续在带头模式下运行它们，这样我们可以在运行测试时显示浏览器中Playwright正在做什么。
- en: Showing the browser while running tests
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在运行测试时显示浏览器
- en: 'The Playwright VS Code extension also has a useful **Show browser** option,
    which opens the browser while running the tests. This allows us to debug tests
    or the frontend while the tests are running. Let’s try it out now:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Playwright VS Code扩展还有一个有用的**显示浏览器**选项，在运行测试时打开浏览器。这允许我们在测试运行时调试测试或前端。现在让我们试试：
- en: On the bottom of the **Testing** sidebar, check the **Show browser** box at
    the bottom of the sidebar and run the test again.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**测试**侧边栏的底部，勾选侧边栏底部的**显示浏览器**复选框，然后再次运行测试。
- en: A browser window will open and run the test. However, our test is very quick
    and simple, so it runs within a short amount of time and there is not much to
    see.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将打开一个浏览器窗口并运行测试。然而，我们的测试非常快且简单，所以它会在很短的时间内运行，没有太多可看。
- en: 'To better inspect the test, we can use the trace viewer. Check **Show trace
    viewer** at the bottom of the **Testing** sidebar and run the test again. You
    will see the following window open:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更好地检查测试，我们可以使用跟踪查看器。在**测试**侧边栏的底部勾选**显示跟踪查看器**，然后再次运行测试。您将看到以下窗口打开：
- en: '![Figure 9.3 – The Playwright trace viewer](img/B19385_09_3.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – The Playwright trace viewer](img/B19385_09_3.jpg)'
- en: Figure 9.3 – The Playwright trace viewer
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – Playwright跟踪查看器
- en: As we can see, the Playwright trace viewer shows us that the test ran `page.goto`
    and then `expect.toHaveTitle`. It also shows the state of the app at each step
    of the test. In our case, we only have one step though. This feature is especially
    useful when developing larger and more complex tests.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Playwright跟踪查看器显示测试运行了`page.goto`然后`expect.toHaveTitle`。它还显示了测试的每个步骤中的应用程序状态。在我们的例子中，我们只有一个步骤。这个功能在开发更大、更复杂的测试时特别有用。
- en: Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'It is also possible to run Playwright in UI mode, which opens the Playwright
    app in a separate window that allows us to run the tests separately and look at
    them being executed, similar to using the **Show trace viewer** function in the
    VS Code extension. You can run Playwright in UI mode by executing the following
    command: **npx playwright** **test --ui**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在UI模式下运行Playwright，这将在单独的窗口中打开Playwright应用程序，允许我们单独运行测试并观察它们的执行，类似于在VS Code扩展中使用**显示跟踪查看器**功能。您可以通过执行以下命令在UI模式下运行Playwright：**npx
    playwright test --ui**
- en: 'Now that we have learned about using the extension to run tests, we can move
    on to a very useful feature of the extension: recording actions to create a new
    test. Let’s do that now.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用扩展来运行测试，我们可以继续到扩展的一个非常有用的功能：记录操作以创建一个新的测试。现在让我们来做这件事。
- en: Recording a test
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录测试
- en: 'The Playwright extension can also record new tests. Let’s now create a new
    test for the signup page by using the test recording functionality of the VS Code
    extension:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Playwright扩展还可以记录新的测试。现在让我们使用VS Code扩展的测试录制功能为注册页面创建一个新的测试：
- en: 'Unlike running a Playwright test, the test recorder does not automatically
    start our frontend and backend, so we need to start them manually first. Open
    a new Terminal and execute the following command:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与运行Playwright测试不同，测试录制器不会自动启动我们的前端和后端，因此我们首先需要手动启动它们。打开一个新的终端并执行以下命令：
- en: '[PRE20]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the bottom section of the **Testing** sidebar, click on **Record new**. A
    browser window should open.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**测试**侧边栏的底部部分，点击**记录新**。应该会打开一个浏览器窗口。
- en: In the browser window, navigate to the frontend by pasting **http://localhost:5173/**
    into the URL bar.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器窗口中，将**http://localhost:5173/**粘贴到URL栏中，导航到前端。
- en: '![Figure 9.4 – The Playwright test recorder while hovering over the “Sign Up”
    link](img/B19385_09_4.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 当悬停在“注册”链接上时的Playwright测试记录器](img/B19385_09_4.jpg)'
- en: Figure 9.4 – The Playwright test recorder while hovering over the “Sign Up”
    link
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 当悬停在“注册”链接上时的Playwright测试记录器
- en: Then, click on the **Sign Up** link. The sign-up page should open.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**注册**链接。注册页面应该会打开。
- en: On this new page, enter a username and password; for example, **test** and **test**.
    Then press the **Sign** **Up** button.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新页面上，输入用户名和密码；例如，**test**和**test**。然后按**注册**按钮。
- en: You will get redirected to the login page. Now, log in with the same username
    and password as before.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将被重定向到登录页面。现在，使用之前相同的用户名和密码登录。
- en: You will get redirected to the main page and will be logged in as **test**.
    You can now close the browser window. You will see that inside VS Code you now
    have a new **test-1.spec.ts** file containing all the actions we just did in the
    browser!
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将被重定向到主页，并以**test**身份登录。现在您可以关闭浏览器窗口。您会看到在VS Code中现在有一个新的**test-1.spec.ts**文件，其中包含我们在浏览器中刚刚执行的所有操作！
- en: Save the file and quit the **e2e** script running the backend and frontend.
    You will now see the **test-1.spec.ts** file in the **Testing** sidebar. If you
    try running the test, you will notice that it gets stuck on the login part, because
    our test currently does not wait for the redirect to the login page.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并退出正在运行后端和前端的**e2e**脚本。现在您将在**测试**侧边栏中看到**test-1.spec.ts**文件。如果您尝试运行测试，您会注意到它在登录部分卡住了，因为我们的测试目前还没有等待重定向到登录页面。
- en: While recording tests is a useful feature to speed up writing end-to-end tests,
    it cannot always write functioning tests for us. We now need to clean up our recorded
    test and add assertions to it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然记录测试是一个有用的功能，可以加快编写端到端测试的速度，但它并不能总是为我们编写功能测试。我们现在需要清理我们的记录测试并向其中添加断言。
- en: 'For reference, here is the full code generated by the Playwright test recorder:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 仅供参考，以下是Playwright测试记录器生成的完整代码：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we have recorded a test, let’s clean it up to make it run properly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经记录了一个测试，让我们清理它以使其正常运行。
- en: Cleaning up and finalizing the recorded test
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清理并最终确定记录的测试
- en: 'If you have a look at the test, you will see that it has all the actions we
    performed in the browser, but it does not verify that we have been successfully
    logged in. It also does not wait for pages to finish loading and some matchers
    do not match the proper text. Let’s fix those problems now:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看测试，您会看到它包含了我们在浏览器中执行的所有操作，但它并没有验证我们是否成功登录。它也没有等待页面加载完成，并且一些匹配器没有匹配正确的文本。让我们现在修复这些问题：
- en: Rename **tests/test-1.spec.ts** to **tests/auth.spec.js**.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**tests/test-1.spec.ts**重命名为**tests/auth.spec.js**。
- en: 'Edit **tests/auth.spec.js** and rename the test to **allows sign up and** **log
    in**:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**tests/auth.spec.js**并将测试重命名为**allows sign up and** **log in**：
- en: '[PRE22]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We need to define a unique username to be able to run our test multiple times
    without having to restart the backend to clear the MongoDB memory server:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要定义一个唯一的用户名，以便能够在不重启后端以清除MongoDB内存服务器的情况下多次运行我们的测试：
- en: '[PRE23]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to not sign up twice with the same username, as the in-memory
    MongoDB database is reused for all the tests. Make sure that tests can run independently
    from each other and do not rely on data from other test files, as the test files
    could run in any order. Only the order within a single test file is guaranteed.
    Using **Date.now()** returns the current time in milliseconds and is mostly collision-safe
    as long as we do not run too many tests in parallel. For a more collision-safe
    solution, you could use a UUID generator instead.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是不要使用相同的用户名注册两次，因为内存中的MongoDB数据库被所有测试重用。确保测试可以独立运行，不要依赖于其他测试文件中的数据，因为测试文件可能会以任何顺序运行。单个测试文件内的顺序是保证的。使用**Date.now()**返回当前时间的毫秒数，只要我们不过度并行运行太多测试，它就基本上是防碰撞的。为了获得更安全的防碰撞解决方案，您可以使用UUID生成器。
- en: 'Change the **page.goto()** URL to **/** to ensure it uses the **baseURL** we
    set up earlier:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**page.goto()**的URL更改为**/**，以确保它使用我们之前设置的**baseURL**：
- en: '[PRE24]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Fill in the generated username when signing up:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在注册时填写生成的用户名：
- en: '[PRE25]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After the click on the **Sign Up** button, wait for the URL to update by using
    the following function:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在点击 **注册** 按钮后，使用以下函数等待 URL 更新：
- en: '[PRE26]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Waiting for the next page to load is necessary because the recording does not
    support page-loading detection right now and it would otherwise fire the commands
    on the old page or during the redirect, which would cause the test to fail.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等待下一页加载是必要的，因为当前录制不支持页面加载检测，否则它会在旧页面上或重定向期间触发命令，这会导致测试失败。
- en: 'For the login, we also fill in the generated username:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于登录，我们也会填写生成的用户名：
- en: '[PRE27]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After that, make the test click on on the **Log In** button and wait for the
    URL to update again:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，让测试点击 **登录** 按钮并等待 URL 再次更新：
- en: '[PRE28]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To more easily match the **Header** React component, edit **src/components/Header.jsx**
    and turn the **<div>** elements into **<****nav>** elements:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更方便地匹配 **Header** React 组件，编辑 **src/components/Header.jsx** 并将 **<div>** 元素转换为
    **<nav>** 元素：
- en: '[PRE29]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'At the end of the test, we now add an assertion that checks whether the Header
    (**<nav>** element) contains the text **Logged in as** and the generated username:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试结束时，我们现在添加一个断言来检查 Header（**<nav>** 元素）是否包含文本 **Logged in as** 和生成的用户名：
- en: '[PRE30]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Using `toContainText` instead of `toHaveText` ensures that the text does not
    have to be exactly the provided string. In our case, the `<nav>` element, so the
    full text would be **Logged in** **as testXXXXLogout**.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `toContainText` 而不是 `toHaveText` 确保文本不必与提供的字符串完全匹配。在我们的例子中，是 `<nav>` 元素，所以完整的文本将是
    **Logged in** **as testXXXXLogout**。
- en: Run the test either using the VS Code extension or by running the **npx playwright
    test** command in the Terminal (whichever you prefer), and you will see that it
    passes successfully now!
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 VS Code 扩展或通过在终端中运行 **npx playwright test** 命令（根据你的喜好）运行测试，你现在会看到它已经成功通过！
- en: Note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If the test does not execute successfully, you might have accidentally recorded
    some additional actions and not cleaned them up properly. Compare your test to
    the code example provided by this book to make sure the test is properly defined
    and cleaned.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试没有成功执行，你可能不小心记录了一些额外的操作并且没有正确清理。将你的测试与本书提供的代码示例进行比较，以确保测试被正确定义并清理。
- en: Now that we know how defining basic tests works in Playwright, let’s learn about
    reusable test setups using fixtures.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了在 Playwright 中定义基本测试的工作方式，让我们学习如何使用固定装置进行可重复的测试设置。
- en: Reusable test setups using fixtures
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用固定装置的可重复测试设置
- en: 'After creating the authentication test, you might be thinking: what if I want
    to define a test for creating a new post now? We would have to first sign up,
    then log in, then create the post. This is quite tedious and the more complex
    our tests get; the more tedious defining tests would get. Fortunately, Playwright
    has a solution for these kinds of problems. Playwright introduces a concept called
    fixtures, which are contexts for the test that can contain reusable functions.
    For example, we could define an `auth` fixture to provide sign-up and log-in functions
    to all tests.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建认证测试后，你可能正在想：如果我想定义一个创建新帖子的测试怎么办？我们首先必须注册，然后登录，然后创建帖子。这相当繁琐，并且随着测试变得越来越复杂，定义测试也会变得越来越繁琐。幸运的是，Playwright
    为这类问题提供了解决方案。Playwright 引入了一个称为固定装置的概念，它是测试的上下文，可以包含可重复使用的函数。例如，我们可以定义一个 `auth`
    固定装置，为所有测试提供注册和登录函数。
- en: When we used Jest, we were using before/after hooks to prepare the common environment
    for multiple tests. Fixtures have some advantages over before/after hooks. Mainly,
    they encapsulate setup and teardown in the same place and are reusable between
    test files, composable, and more flexible. Additionally, fixtures are provided
    *on demand*, which means that Playwright will only set up the fixtures necessary
    for running a certain test.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Jest 时，我们使用 before/after 钩子来为多个测试准备公共环境。固定装置相对于 before/after 钩子有一些优势。主要的是，它们将设置和清理封装在同一个地方，并且可以在测试文件之间重复使用，可组合，并且更灵活。此外，固定装置是按需提供的，这意味着
    Playwright 将只为运行某个特定测试设置必要的固定装置。
- en: Playwright also includes some fixtures out of the box, which we are going to
    learn about now.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Playwright 还包含一些开箱即用的固定装置，我们现在将要学习这些内容。
- en: Overview of built-in fixtures
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置固定装置概述
- en: 'Playwright comes with some built-in fixtures, one of which we have already
    learned about: the `page` fixture. We are now going to briefly introduce the most
    important built-in fixtures Playwright provides out of the box:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Playwright 随带一些内置固定装置，其中之一我们已经学习过：`page` 固定装置。我们现在将简要介绍 Playwright 提供的一些最重要的内置固定装置：
- en: '**browser**: Allows controlling browser features, such as opening a new page'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览器**：允许控制浏览器功能，例如打开新页面'
- en: '**browserName**: Contains the name of the browser that is currently running
    the test'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**browserName**：包含当前运行测试的浏览器的名称'
- en: '**page**: By far the most important built-in fixture, used to control interactions
    with the page, visiting URLs, matching elements, doing actions, and much more'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**page**：迄今为止最重要的内置固定装置，用于控制与页面的交互、访问 URL、匹配元素、执行操作等'
- en: '**context**: An isolated context for the current test run'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**：当前测试运行的独立上下文'
- en: '**request**: Used to make API requests from Playwright'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求**：用于从 Playwright 发送 API 请求'
- en: Now that we have learned about the built-in fixtures Playwright provides, let’s
    continue by defining our own fixture.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Playwright 提供的内置固定装置，让我们继续定义我们自己的固定装置。
- en: Writing our own fixture
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写我们自己的固定装置
- en: 'Signing up and logging in are common actions that we will need to do often
    in our end-to-end tests, so they are the perfect case for creating a fixture.
    Follow these steps to create a new `auth` fixture:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注册和登录是我们将在端到端测试中经常需要执行的操作，因此它们是创建固定装置的完美案例。按照以下步骤创建一个新的 `auth` 固定装置：
- en: Create a new **tests/fixtures/** folder.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **tests/fixtures/** 文件夹。
- en: 'Inside it, create a new **tests/fixtures/AuthFixture.js** file, where we define
    an **AuthFixture** class:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，创建一个新的 **tests/fixtures/AuthFixture.js** 文件，在那里我们定义一个 **AuthFixture** 类：
- en: '[PRE31]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This class will receive the **page** fixture in the constructor:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类将在构造函数中接收 **page** 固定装置：
- en: '[PRE32]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Define a **signUpAndLogIn** method, which follows the actions from the auth
    test to generate a unique username, then sign up and log in the user:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 **signUpAndLogIn** 方法，该方法遵循 auth 测试中的操作以生成一个唯一的用户名，然后注册并登录用户：
- en: '[PRE33]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a new **tests/fixtures/index.js** file. Inside it, import the **test**
    function from Playwright (renaming it to **baseTest**) and the **AuthFixture**
    we just defined:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **tests/fixtures/index.js** 文件。在其中，从 Playwright 导入 **test** 函数（将其重命名为
    **baseTest**）和刚刚定义的 **AuthFixture**：
- en: '[PRE34]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, define and export a new **test** function, extending the **baseTest**
    function from Playwright by defining a new **auth** fixture inside it:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义并导出一个新的 **test** 函数，通过在其中定义一个新的 **auth** 固定装置来扩展 Playwright 的 **baseTest**
    函数：
- en: '[PRE35]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Tip
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is also possible to do additional setup of the fixture context before calling
    the **use()** function, and additional breakdown after calling it. This can be
    used to, for example, create a set of example posts before executing tests and
    deleting them again afterward. If the backend had a way to delete a user, creating
    a temporary user and deleting the created username again after using the fixture
    would be a better option to deal with the issue of username collisions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 **use()** 函数之前，也可以对固定装置上下文进行额外的设置，在调用之后进行额外的清理。这可以用于，例如，在执行测试之前创建一组示例帖子，然后在测试之后再次删除它们。如果后端有删除用户的方法，在使用固定装置后创建一个临时用户，并在使用固定装置后再次删除创建的用户名，将是一个更好的选项来处理用户名冲突的问题。
- en: 'Additionally, re-export the **expect** function from Playwright to make it
    easier to import from our fixtures:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，重新导出 Playwright 的 **expect** 函数，以便更容易从我们的固定装置中导入：
- en: '[PRE36]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now that we have defined our custom fixture, let’s use it while creating a new
    test!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的自定义固定装置，让我们在创建新测试时使用它！
- en: Using custom fixtures
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义固定装置
- en: 'We are now going to define an end-to-end test for creating a new post. To create
    a post, we need to be logged in so we can use our `auth` fixture for preparing
    the environment. Follow these steps to define the new test and use our custom
    fixture:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将定义一个创建新帖子的端到端测试。要创建帖子，我们需要登录，以便我们可以使用我们的 `auth` 固定装置来准备环境。按照以下步骤定义新测试并使用我们的自定义固定装置：
- en: 'Create a new **tests/create-post.spec.js** file. To use the custom fixture,
    we now need to import the **test** and **expect** functions from the **fixtures/index.js**
    file:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **tests/create-post.spec.js** 文件。为了使用自定义固定装置，我们现在需要从 **fixtures/index.js**
    文件中导入 **test** 和 **expect** 函数：
- en: '[PRE37]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Define a new test to verify that post creation works, using the **page** and
    **auth** fixtures:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的测试来验证帖子创建功能，使用 **page** 和 **auth** 固定装置：
- en: '[PRE38]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can now use the **signUpAndLogIn** method from our custom **auth** fixture
    to create and log in a new user:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用自定义 **auth** 固定装置中的 **signUpAndLogIn** 方法来创建和登录新用户：
- en: '[PRE39]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We can make use of Playwright code generation again to record our test. First,
    save the file and execute the **create-post.spec.js** test with **Show** **browser**
    enabled.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以再次使用 Playwright 代码生成来记录我们的测试。首先，保存文件并启用 **Show** **browser** 执行 **create-post.spec.js**
    测试。
- en: Then, create a new line after the **auth.signUpAndLogIn** function is called
    and press **Record** **at cursor**.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在调用**auth.signUpAndLogIn**函数后创建一个新行，并按**光标处**的**Record**。
- en: Now we can record actions from the already opened browser window (which is also
    already logged in, because the fixture methods were called already!). Click into
    the title field and enter **Test Post** as the post title, then press *Tab* to
    go to the next field, enter **Hello World!** as the post content, then press *Tab*
    again and press *Return/Enter* to create a new post.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以从已经打开的浏览器窗口（也已经登录，因为已经调用了固定装置方法！）中记录操作。点击标题字段，将**Test Post**作为帖子标题输入，然后按*Tab*键跳到下一个字段，输入**Hello
    World**作为帖子内容，然后再次按*Tab*键并按*Return/Enter*键创建一个新的帖子。
- en: Note
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The post does not actually get created, because Playwright closes the backend
    right after it finishes running it, so at the time of recording, the backend is
    already shut down. If you want to record with the backend running, explore the
    **webServer.reuseExistingServer** setting in **playwright.config.js**.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上并没有创建帖子，因为Playwright在运行完毕后立即关闭了后端，所以在录制时后端已经关闭。如果你想在后端运行时录制，请探索**playwright.config.js**中的**webServer.reuseExistingServer**设置。
- en: 'Go back to the file, and you will see that all actions were properly recorded!
    The following code should have been recorded:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到文件，你会看到所有操作都已正确记录！以下代码应该已被记录：
- en: '[PRE40]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we just need to add a check whether the post was created successfully:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要添加一个检查以确保帖子已成功创建：
- en: '[PRE41]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As we are controlling the test environment, it is enough to check that the text
    **Test PostWritten by testXXX** (without a space between “Post” and “Written”)
    is visible on the page. This will tell us that the post was created in the list.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们控制测试环境，检查文本**Test PostWritten by testXXX**（在“Post”和“Written”之间没有空格）在页面上可见就足够了。这将告诉我们帖子已在列表中创建。
- en: Run the test, and you will see that it passes successfully!
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试，你会看到它成功通过！
- en: We could create additional fixtures for handling posts (creating, editing, deleting)
    and use these to, for example, verify that the link to a single post works properly
    and adjusts the title accordingly. However, extending end-to-end tests like that
    is similar to what we have already done and is thus left as an exercise for you.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为处理帖子（创建、编辑、删除）创建额外的固定装置，并使用这些装置，例如，验证单个帖子的链接是否正常工作并相应地调整标题。然而，像这样扩展端到端测试与我们已经做过的类似，因此留作你的练习。
- en: Viewing test reports and running in CI
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看测试报告和在CI中运行
- en: After successfully creating some end-to-end tests for our blog application,
    let’s wrap up the chapter by learning how to view HTML test reports and how to
    run Playwright in CI.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功创建我们博客应用的端到端测试之后，让我们通过学习如何查看HTML测试报告以及如何在CI中运行Playwright来结束本章。
- en: Viewing an HTML report
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看HTML报告
- en: 'Playwright automatically generates HTML reports of test runs. We can generate
    these by executing the following command to run all tests:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Playwright会自动生成测试运行的HTML报告。我们可以通过执行以下命令来运行所有测试：
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, run the following command to serve and view the HTML report of the last
    run:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下命令来提供和查看最后一次运行的HTML报告：
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The report should open in a new browser window, and look as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 报告应在新的浏览器窗口中打开，如下所示：
- en: '![Figure 9.5 – An HTML test report generated by Playwright](img/B19385_09_5.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 由Playwright生成的HTML测试报告](img/B19385_09_5.jpg)'
- en: Figure 9.5 – An HTML test report generated by Playwright
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 由Playwright生成的HTML测试报告
- en: As we can see, our three tests were successfully run on all three browsers.
    Click on one of the test runs to view all executed test steps in detail.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们的三个测试在所有三个浏览器上成功运行。点击其中一个测试运行，以查看所有执行测试步骤的详细信息。
- en: Running Playwright tests in CI
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在CI中运行Playwright测试
- en: 'When we initialized Playwright, we were asked if we want to generate a GitHub
    Actions CI file. We agreed, so Playwright automatically generated a CI configuration
    for us in the `.github/workflows/playwright.yml` file. This workflow checks out
    the repository, installs all dependencies, installs Playwright browsers, runs
    all Playwright tests, and then uploads the report as an artifact so it can be
    viewed from the CI run. We still need to adjust the CI workflow to also install
    dependencies for our backend, so let’s do that now:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们初始化Playwright时，我们被问及是否想要生成一个GitHub Actions CI文件。我们同意了，因此Playwright自动在`.github/workflows/playwright.yml`文件中为我们生成了一个CI配置。此工作流程会检出仓库，安装所有依赖项，安装Playwright浏览器，运行所有Playwright测试，然后将报告作为工件上传，以便可以从CI运行中查看。我们仍然需要调整CI工作流程，以便也安装后端依赖项，所以现在让我们来做这件事：
- en: 'Edit **.github/workflows/playwright.yml** and add the following step to it:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**.github/workflows/playwright.yml**，并向其中添加以下步骤：
- en: '[PRE44]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Add, commit, and push everything to a GitHub repository to see Playwright running
    in CI.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有内容添加、提交并推送到GitHub仓库，以查看Playwright在CI中的运行情况。
- en: Note
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure to create a new repository from just the contents of the **ch9** folder
    (not the whole **Full-Stack-React-Projects** folder!), otherwise GitHub Actions
    will not detect the **.****github** folder.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 确保仅从**ch9**文件夹的内容（而不是整个**Full-Stack-React-Projects**文件夹）创建一个新的仓库，否则GitHub Actions将无法检测到**.****github**文件夹。
- en: Go to GitHub, click on the **Actions** tab, select the **Playwright Tests**
    workflow on the sidebar, and then click on the latest workflow run.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往GitHub，点击**操作**标签，在侧边栏中选择**Playwright Tests**工作流程，然后点击最新的工作流程运行。
- en: At the bottom of the run, there is an **Artifacts** section, which contains
    a **playwright-report** object that can be downloaded to view the HTML report.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行的底部，有一个**工件**部分，其中包含一个**playwright-report**对象，可以下载以查看HTML报告。
- en: 'The following screenshot shows the Playwright tests running in GitHub Actions,
    with the report provided as an artifact:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在GitHub Actions中运行的Playwright测试，报告作为工件提供：
- en: '![Figure 9.6 – Playwright running in GitHub Actions](img/B19385_09_6.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – Playwright在GitHub Actions中运行](img/B19385_09_6.jpg)'
- en: Figure 9.6 – Playwright running in GitHub Actions
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 在GitHub Actions中运行的Playwright
- en: As we can see, running Playwright in CI by using the provided template is simple
    and straightforward.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，通过提供的模板在CI中运行Playwright既简单又直接。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about using Playwright for end-to-end testing. We
    first set up Playwright in our project and prepared our backend for end-to-end
    testing. Then, we wrote and ran our first test. Next, we learned about fixtures
    to make reusable test contexts. Finally, we viewed the generated HTML report and
    set up CI to run Playwright, generate a report, and save it as an artifact in
    the pipeline.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Playwright进行端到端测试。我们首先在我们的项目中设置Playwright，并为端到端测试准备了我们的后端。然后，我们编写并运行了我们的第一个测试。接下来，我们学习了关于固定装置的内容，以便创建可重用的测试上下文。最后，我们查看了生成的HTML报告，并设置了CI以运行Playwright，生成报告，并将其作为工件保存在管道中。
- en: In the next chapter, [*Chapter 10*](B19385_10.xhtml#_idTextAnchor192)*, Aggregating
    and Visualizing Statistics Using MongoDB and Victory*, we are going to learn how
    to aggregate data using MongoDB and expose this aggregated data via a backend.
    Then, we are going to consume the aggregated data in the frontend and visualize
    it using Victory with various visualization types.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章[*第10章*](B19385_10.xhtml#_idTextAnchor192)*，使用MongoDB和Victory聚合和可视化统计信息*，我们将学习如何使用MongoDB聚合数据，并通过后端公开这些聚合数据。然后，我们将在前端消费这些聚合数据，并使用Victory和各种可视化类型来可视化它。
