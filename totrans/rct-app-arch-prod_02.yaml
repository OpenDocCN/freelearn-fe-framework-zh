- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Setup and Project Structure Overview
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和项目结构概述
- en: In the previous chapter, we looked at all the challenges when building a React
    application and some great solutions that can help us handle them. We also planned
    out how our application should work and what tools we should use.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了构建 React 应用程序时遇到的挑战以及一些可以帮助我们处理这些挑战的出色解决方案。我们还规划了我们的应用程序应该如何工作以及我们应该使用哪些工具。
- en: In this chapter, we will look at the project structure and the setup tools that
    make a good baseline for our project.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨项目结构和为我们的项目提供良好基线的设置工具。
- en: 'We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Next.js application overview
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Next.js 应用程序概述
- en: TypeScript setup overview and usage
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 设置概述及使用
- en: ESLint setup overview
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ESLint 设置概述
- en: Prettier setup overview
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prettier 设置概述
- en: Pre-committing checks setup overview
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预提交检查设置概述
- en: Project structure overview
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目结构概述
- en: By the end of this chapter, we will have a good understanding of the tools we
    will be using for the project setup and the feature-based project structure to
    make organizing our code more manageable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将对用于项目设置和基于功能的项目的工具有一个很好的理解，这将使我们的代码组织更加易于管理。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we get started, we need to set up our project. To be able to develop
    our project, we will need the following things installed on our computer:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要设置我们的项目。为了能够开发我们的项目，我们需要在计算机上安装以下内容：
- en: '**Node.js** version 16 or above and **npm** version 8 or above.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js** 版本 16 或更高版本和 **npm** 版本 8 或更高版本。'
- en: 'There are multiple ways to install Node.js and npm. Here is a great article
    that goes into more detail: [https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js](https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Node.js 和 npm 有多种方式。这里有一篇很好的文章，详细介绍了更多细节：[https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js](https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js)。
- en: '**VSCode** (optional) is currently the most popular editor/IDE for JavaScript/TypeScript,
    so we will be using it. It is open source, has great integration with TypeScript,
    and we can extend its features via extensions. It can be downloaded from [https://code.visualstudio.com/](https://code.visualstudio.com/).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VSCode**（可选）是目前最流行的 JavaScript/TypeScript 编辑器/IDE，因此我们将使用它。它是开源的，与 TypeScript
    集成良好，并且我们可以通过扩展来扩展其功能。可以从 [https://code.visualstudio.com/](https://code.visualstudio.com/)
    下载。'
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/React-Application-Architecture-for-Production](https://github.com/PacktPublishing/React-Application-Architecture-for-Production).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/React-Application-Architecture-for-Production](https://github.com/PacktPublishing/React-Application-Architecture-for-Production)。
- en: 'The repository can be cloned locally with the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令在本地克隆仓库：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the repository has been cloned, we need to install the application’s dependencies:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆完仓库后，我们需要安装应用程序的依赖项：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We also need to provide the environment variables:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要提供环境变量：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the dependencies have been installed, we need to select the right stage
    of the code base that matches this chapter. We can do that by executing the following
    command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项安装完成后，我们需要选择与本章匹配的代码库的正确阶段。我们可以通过执行以下命令来完成：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command will prompt us with a list of stages for each chapter:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将为我们显示每个章节的阶段列表：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is the second chapter so we can select the `chapter-02` option.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二章，因此我们可以选择 `chapter-02` 选项。
- en: Once the chapter has been selected, all files required to follow along with
    the chapter will appear. To follow along with this chapter, we don’t need to make
    any changes to the code. We can just use it as a reference to help get a better
    overview of the code base.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 选择好章节后，所有必要的文件将显示出来。为了跟随本章，我们不需要对代码进行任何更改。我们只需将其作为参考，以帮助更好地了解代码库。
- en: For more information about the setup details, check out the `README.md` file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于设置细节的信息，请查看 `README.md` 文件。
- en: Next.js application overview
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Next.js 应用程序概述
- en: Next.js is a web framework built on top of React and Node.js, allowing us to
    build web applications. Because it can run on the server, it can be used as a
    full-stack framework.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 是一个基于 React 和 Node.js 的 Web 框架，允许我们构建 Web 应用程序。因为它可以在服务器上运行，所以它可以作为一个全栈框架使用。
- en: Why Next.js?
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择 Next.js？
- en: 'Using Next.js has multiple benefits. We want to use it because of several reasons:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Next.js 有多个好处。我们想使用它，原因如下：
- en: '**Very easy to get started with**: In the early days of React, it was very
    challenging to start a project. To get a simple page on the screen, we had to
    deal with many tools such as Webpack, Babel, and others. We still use those tools
    today, but fortunately, most tooling configuration is hidden from us with an interface
    to extend the configuration if required.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非常容易上手**：在React的早期阶段，开始一个项目非常具有挑战性。为了在屏幕上显示一个简单的页面，我们必须处理许多工具，如Webpack、Babel等。我们今天仍在使用这些工具，但幸运的是，大多数工具配置都通过界面隐藏起来，如果需要，可以扩展配置。'
- en: Besides the challenges of setting up the project, it is very challenging to
    maintain all those dependencies over time. Next.js hides all those complexities
    away from developers and allows them to get started quickly with a new project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置项目时的挑战外，随着时间的推移维护所有这些依赖项也非常具有挑战性。Next.js将所有这些复杂性隐藏起来，让开发者能够快速开始新的项目。
- en: '**Allows multiple rendering strategies**: Being able to use multiple rendering
    strategies is probably the main reason why we want to use Next.js, although it
    comes with other great benefits. First, it allows us to define the behavior of
    page rendering at the page level, meaning we can define how we want to render
    each page individually. It also supports multiple rendering strategies, such as
    the following:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**允许多种渲染策略**：能够使用多种渲染策略可能是我们想要使用Next.js的主要原因，尽管它还带来了其他许多好处。首先，它允许我们在页面级别定义页面渲染的行为，这意味着我们可以定义我们想要如何单独渲染每个页面。它还支持多种渲染策略，例如以下：'
- en: Client-side rendering
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端渲染
- en: Server-side rendering
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: Static site generation
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态站点生成
- en: Incremental static regeneration
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渐进式静态再生
- en: We will be using different strategies based on the application’s needs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据应用程序的需求使用不同的策略。
- en: '**Performance optimizations**: Next.js is built with web performance in mind.
    It implements performance optimization techniques such as the following:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能优化**：Next.js是考虑到网络性能而构建的。它实现了以下性能优化技术：'
- en: Code splitting
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码拆分
- en: Lazy loading
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载
- en: Prefetching
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预取
- en: Image optimization
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片优化
- en: That sums up why we want to use Next.js for our application. Now, let’s see
    what the Next.js application structure looks like.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们想要为我们的应用程序使用Next.js的原因。现在，让我们看看Next.js应用程序的结构是什么样的。
- en: Next.js application structure
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Next.js应用程序结构
- en: The easiest way to get started with Next.js is to use the `create-next-app`
    CLI to generate a new application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用Next.js的最简单方法是使用`create-next-app` CLI生成新应用程序。
- en: 'Since we have already generated the application as part of the code samples,
    we do not need to use the CLI, but if we were generating the application from
    scratch, we would execute the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在代码示例中作为部分生成了应用程序，我们不需要使用CLI，但如果我们从头开始生成应用程序，我们将执行以下命令：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By executing this command, we would generate a new Next.js application with
    TypeScript configured out of the box.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行此命令，我们将生成一个带有TypeScript配置的新Next.js应用程序。
- en: 'There are a couple of things that are specific to Next.js. Let’s look at the
    following file and folder structure of a simple Next.js application:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有几件事情是Next.js特有的。让我们看看以下简单Next.js应用程序的文件和文件夹结构：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s analyze each file and folder one by one:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个分析每个文件和文件夹：
- en: '`.next`: Contains production-ready files generated by running the `build` command
    of Next.js.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.next`：包含通过运行Next.js的`build`命令生成的生产就绪文件。'
- en: '`public`: Contains all static assets of the application.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`：包含应用程序的所有静态资源。'
- en: '`src/pages`: This is a special folder in Next.js where all pages defined here
    become available at corresponding routes. This is possible thanks to the filesystem-based
    routing system. The `pages` folder can also live in the root of the project, but
    it is nice to keep everything in the `src` folder.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/pages`：这是Next.js中的一个特殊文件夹，其中定义的所有页面都可在相应的路由中访问。这是由于基于文件系统的路由系统实现的。`pages`文件夹也可以位于项目的根目录中，但将所有内容保持在`src`文件夹中会更好。'
- en: '`src/pages/_app.tsx`: The `_app.tsx` file is a special file that exports a
    React component that wraps every page when rendered. By wrapping pages with this
    special component, we can add custom behavior for our application, such as adding
    any global configurations, providers, styles, layouts, and more to all the pages.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/pages/_app.tsx`：`_app.tsx`文件是一个特殊的文件，它导出一个React组件，该组件在渲染时包裹每个页面。通过使用这个特殊组件包裹页面，我们可以为我们的应用程序添加自定义行为，例如向所有页面添加任何全局配置、提供者、样式、布局等。'
- en: '`src/pages/index.tsx`: This is how we declare pages of the application. This
    shows how the root page is defined. We will dive into Next.js-specific routing
    in the upcoming chapters.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/pages/index.tsx`: 这是我们声明应用程序页面的方式。这显示了根页面的定义。我们将在接下来的章节中深入探讨 Next.js 特定的路由。'
- en: '`next.config.js`: This is where we can extend the default functionalities such
    as Webpack configuration and other things in a simple way.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next.config.js`: 这是我们以简单方式扩展默认功能，如 Webpack 配置和其他事物的位置。'
- en: '`package.json`: Every Next.js application includes the following npm scripts:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.json`: 每个Next.js应用程序都包含以下npm脚本：'
- en: '`dev`: Starts a development server on `localhost:3000`'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`: 在 `localhost:3000` 上启动开发服务器'
- en: '`build`: Builds the application for production'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`: 为生产构建应用程序'
- en: '`start`: Starts the production build on `localhost:3000`'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`: 在 `localhost:3000` 上启动生产构建'
- en: We will cover more on these topics in the following chapters, but for now, this
    should give us enough information to get started with Next.js.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中更详细地介绍这些主题，但到目前为止，这应该足以让我们开始使用 Next.js。
- en: TypeScript setup overview and usage
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 设置概述和使用
- en: JavaScript is a dynamically typed programming language, meaning it doesn’t catch
    any type errors during build time. That’s where TypeScript comes into play.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种动态类型的编程语言，这意味着它在构建时不会捕获任何类型错误。这就是 TypeScript 发挥作用的地方。
- en: TypeScript is a programming language that acts as a superset of JavaScript,
    which allows us to write JavaScript with some behaviors of a statically typed
    language. This comes in handy as we can catch many potential bugs before they
    get into production.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 是一种作为 JavaScript 超集的编程语言，它允许我们用静态类型语言的一些行为来编写 JavaScript。这很有用，因为我们可以在它们进入生产之前捕获许多潜在的错误。
- en: Why TypeScript?
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择 TypeScript？
- en: TypeScript is especially useful for large applications built by large teams.
    Code written in TypeScript is much better documented than code written in vanilla
    JavaScript. By looking at the type definitions, we can figure out how a piece
    of code is supposed to work.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 特别适用于由大型团队构建的大型应用程序。用 TypeScript 编写的代码比用纯 JavaScript 编写的代码文档更完善。通过查看类型定义，我们可以了解一段代码应该如何工作。
- en: Another reason is that TypeScript makes refactoring much easier because most
    of the issues can be caught before running the application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是 TypeScript 使得重构变得更加容易，因为大多数问题可以在运行应用程序之前被发现。
- en: TypeScript also helps us utilize our editor’s IntelliSense, which shows us intelligent
    code completion, hover information, and signature information, which speeds up
    our productivity.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 还帮助我们利用编辑器的 IntelliSense，它显示智能代码补全、悬停信息和签名信息，这提高了我们的生产力。
- en: TypeScript setup
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript 设置
- en: 'Our project already has TypeScript configured. The TypeScript configuration
    is defined in the `tsconfig.json` file at the root of the project. It allows us
    to configure how strict we want it to be based on our needs:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目已经配置了 TypeScript。TypeScript 配置定义在项目根目录下的 `tsconfig.json` 文件中。它允许我们根据我们的需求配置其严格程度：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will not dive too deeply into every configuration property since most of
    the properties have been auto-generated. However, there is one thing that was
    also provided:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入到每个配置属性，因为大多数属性已经被自动生成。然而，还有一件事也被提供了：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will tell the TypeScript compiler that anything imported via `@/*` will
    refer to the `src` folder.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉 TypeScript 编译器，通过 `@/*` 导入的任何内容都将引用 `src` 文件夹。
- en: 'Previously, we had to perform messy imports, like so:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们必须进行混乱的导入，如下所示：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we can import components like so:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以这样导入组件：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: No matter how many nested levels we have, we can always import with absolute
    paths, and we will not be required to change our import statement should we decide
    to move the consumer file somewhere else.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们有多少嵌套级别，我们都可以始终使用绝对路径进行导入，并且如果我们决定将消费者文件移动到其他地方，我们不需要更改我们的导入语句。
- en: Basic TypeScript usage
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本TypeScript用法
- en: Let’s cover some TypeScript basics so that we are comfortable using it throughout
    this book.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一些 TypeScript 基础知识，以便我们在这本书中能够舒适地使用它。
- en: Primitive types
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始类型
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we can see, we are only allowed to assign values with the corresponding type.
    Assigning to any other type except the `any` type, which we will cover in a moment,
    will cause a TypeScript error.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们只能使用相应的类型赋值。将值赋给除 `any` 类型（我们将在下一刻介绍）之外的任何其他类型将导致 TypeScript 错误。
- en: Any
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Any
- en: 'The `any` type is the loosest type in TypeScript and using it will disable
    any type checking. We can use it when we want to bypass errors that would usually
    occur. However, we should only use it as a last resort and try to use other types
    first:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`any` 类型是 TypeScript 中最宽松的类型，使用它将禁用任何类型检查。当我们想要绕过通常会发生的错误时，我们可以使用它。然而，我们应将其作为最后的手段，并首先尝试使用其他类型：'
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we can see, variables with the `any` type can accept and be assigned to a
    value of any other type, which makes it very flexible.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，具有 `any` 类型的变量可以接受并分配为任何其他类型的值，这使得它非常灵活。
- en: Unknown
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Unknown
- en: 'Sometimes, we can’t know upfront which types we will have. This might happen
    with some dynamic data where we don’t know its type yet. Here, we can use the
    `unknown` type:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能无法提前知道我们将会有哪些类型。这可能会发生在一些动态数据上，我们不知道它的类型。在这里，我们可以使用 `unknown` 类型：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we can see, we can assign values of any type to the variable with `unknown`
    `type`. However, we can only assign values with type `unknown` to the variables
    with `any` and `unknown` types.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们可以将任何类型的值分配给具有 `unknown` 类型的变量。然而，我们只能将具有 `unknown` 类型的值分配给具有 `any`
    和 `unknown` 类型的变量。
- en: Arrays
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组
- en: 'There are two ways to define array types with TypeScript:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中定义数组类型有两种方式：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Objects
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象
- en: 'Object shapes can be defined in two ways:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对象形状可以通过两种方式定义：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first one is called type alias, while the second is called interface.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个被称为类型别名，而第二个被称为接口。
- en: There are a few differences between type aliases and interfaces, but we won't
    get into them right now. For any object shape type we define, we can use type
    aliases.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名和接口之间有一些区别，但我们现在不会深入探讨。对于我们定义的任何对象形状类型，我们都可以使用类型别名。
- en: Unions
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 联合
- en: 'The basic types we just mentioned are great, but sometimes, we want to allow
    a variable to be one of many types. Let’s look at the following example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才提到的基本类型很棒，但有时我们希望允许一个变量可以是许多类型之一。让我们看看以下示例：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we can see, the `content` variable can now be either `string` or `number`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`content` 变量现在可以是 `string` 或 `number`。
- en: 'We can also add literal types in the union, as shown in the following example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在联合中添加字面量类型，如下面的示例所示：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we are defining colors as strings, but we want to add more constraints
    so that we can only take one of those three colors. If we try to add anything
    else, TypeScript will warn us with an error.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在将颜色定义为字符串，但我们想添加更多约束，以便我们只能接受这三种颜色之一。如果我们尝试添加其他任何东西，TypeScript 将通过错误警告我们。
- en: Intersections
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交集
- en: 'Intersection types allow us to combine the properties of two different objects
    into a single type. Consider this example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 交集类型允许我们将两个不同对象的属性组合成一个单一的类型。考虑以下示例：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `FooBar` type will now contain the `x`, `y`, and `z` properties.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`FooBar` 类型现在将包含 `x`、`y` 和 `z` 属性。'
- en: Generics
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛型
- en: 'Generics is a mechanism of creating reusable types by parameterizing them.
    They can help us reduce code repetition. Consider the following type:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是一种通过参数化创建可重用类型的机制。它们可以帮助我们减少代码重复。考虑以下类型：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s see what happens if we need the same structure but with `x` as a string:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们需要相同的结构但 `x` 是字符串会发生什么：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we can see that there is some code duplication going on. We can simplify
    this by making it generic so that it accepts the type as `T`. This would be assigned
    as the type of the `x` property:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到存在一些代码重复。我们可以通过使其泛型化来简化它，使其接受类型 `T`。这将作为 `x` 属性的类型分配：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, we have a nice way to reuse the structure by passing different types to
    the generic.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一种通过向泛型传递不同类型来重用结构的好方法。
- en: 'We can also use generics with functions:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在函数中使用泛型：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To try out these snippets and see how different types behave, go to [https://www.typescriptlang.org/play](https://www.typescriptlang.org/play),
    copy the snippets, and play around with the types to see how they work.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这些代码片段并查看不同类型的行为，请访问 [https://www.typescriptlang.org/play](https://www.typescriptlang.org/play)，复制代码片段，并尝试不同的类型以查看它们的工作方式。
- en: TypeScript and React
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TypeScript 和 React
- en: Every TypeScript file that uses JSX must have the `.``tsx` extension.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每个使用 JSX 的 TypeScript 文件都必须有 `.tsx` 扩展名。
- en: 'Typing React components is very straightforward:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 React 组件非常简单：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: These examples are pretty trivial. We will see more practical examples in the
    upcoming chapters when we start building the application. To learn more about
    TypeScript, it is recommended to check the TypeScript handbook at [https://www.typescriptlang.org/docs](https://www.typescriptlang.org/docs),
    which covers all these topics in much more detail.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子相当简单。在我们开始构建应用程序时，将在接下来的章节中看到更多实用的例子。要了解更多关于TypeScript的信息，建议查看TypeScript手册[https://www.typescriptlang.org/docs](https://www.typescriptlang.org/docs)，它详细介绍了所有这些主题。
- en: ESLint setup overview
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ESLint设置概述
- en: '**Linting** is a process where linters analyze source code and detect any potential
    issues in the code base.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码检查**是一个过程，其中代码检查器分析源代码并检测代码库中任何潜在的问题。'
- en: We will be using **ESLint**, which is the most popular linting tool for JavaScript.
    It can be configured with different plugins and rules to adapt the linter to our
    application’s needs.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**ESLint**，这是JavaScript中最受欢迎的代码检查工具。它可以配置不同的插件和规则，以适应我们应用程序的需求。
- en: The ESLint configuration is defined in the `.eslintrc.js` file at the root of
    the project. We can add different rules, extend them with different plugins, and
    override which files to apply the rules to so that they suit our application’s
    needs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint配置定义在项目根目录下的`.eslintrc.js`文件中。我们可以添加不同的规则，通过不同的插件扩展它们，并覆盖应用到哪些文件上，以便它们满足我们应用程序的需求。
- en: Sometimes, we don’t want to lint every folder and file, so we can tell ESLint
    to ignore folders and files by defining them in the `.``eslintignore` file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们不想检查每个文件夹和文件，因此我们可以通过在`.eslintignore`文件中定义它们来告诉ESLint忽略文件夹和文件。
- en: ESLint has great integration with editors and IDEs so that we can see any potential
    issues in the file while we are coding.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint与编辑器和IDE有很好的集成，这样我们可以在编码时看到文件中的任何潜在问题。
- en: 'To run our linter, we have defined the linting script in `package.json`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行我们的代码检查器，我们在`package.json`中定义了代码检查脚本：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By running `npm run lint`, we will lint every `.ts` and `.tsx` file in the `src`
    directory, and the linter will notify us about any potential issues.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`npm run lint`，我们将检查`src`目录中的每个`.ts`和`.tsx`文件，并且代码检查器将通知我们任何潜在的问题。
- en: Prettier setup overview
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Prettier设置概述
- en: '`.prettierrc` file. It will also give us good feedback when something is wrong
    with the code. If it doesn’t auto-format, something is wrong with the code and
    it needs to be fixed.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`.prettierrc`文件。它还会在代码出现问题时给我们提供良好的反馈。如果它没有自动格式化，那么代码中可能存在问题，需要修复。'
- en: Prettier comes with a default configuration out of the box. We can override
    this by creating the `.prettierrc` file and modifying the configuration.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Prettier默认提供了一套配置。我们可以通过创建`.prettierrc`文件并修改配置来覆盖它。
- en: Just as with ESLint, sometimes, there are files we do not want to auto-format.
    We can tell Prettier to ignore files and folders by adding them to the `.``prettierignore`
    file.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 就像ESLint一样，有时，有些文件我们不想自动格式化。我们可以通过将它们添加到`.prettierignore`文件中来告诉Prettier忽略文件和文件夹。
- en: 'To run Prettier, we have defined a couple of scripts in `package.json`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行Prettier，我们在`package.json`中定义了一些脚本：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As we can see, we can run `npm run format:check` to just check the formatting
    without trying to fix it. If we want to fix it, then we can run `npm run format:fix`,
    which will modify the files that need to be fixed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们可以运行`npm run format:check`来仅检查格式而不尝试修复它。如果我们想修复它，则可以运行`npm run format:fix`，这将修改需要修复的文件。
- en: Pre-committing checks setup overview
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预提交检查设置概述
- en: Having static code analysis tools such as TypeScript, ESLint, and Prettier is
    great; we have configured them and can run individual scripts whenever we make
    some changes to ensure everything is in the best order.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有像TypeScript、ESLint和Prettier这样的静态代码分析工具是很好的；我们已经配置了它们，并且每次我们进行一些更改时都可以运行单个脚本，以确保一切处于最佳状态。
- en: However, there are some drawbacks. Developers can forget to run all checks before
    committing to the repo, which can still bring problematic and inconsistent code
    to production.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有一些缺点。开发者可能会忘记在提交到仓库之前运行所有检查，这仍然会将问题和不一致的代码带到生产环境中。
- en: 'Fortunately, there is a solution that can fix this problem: whenever we try
    to commit to the repository, we want to run all checks in an automated way.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个解决方案可以解决这个问题：每次我们尝试向仓库提交时，我们希望以自动化的方式运行所有检查。
- en: 'This is the flow we want to have:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们要实现的工作流程：
- en: '![Figure 2.1 – Pre-commit code checking diagram ](img/B17297_02_01.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 预提交代码检查图](img/B17297_02_01.jpg)'
- en: Figure 2.1 – Pre-commit code checking diagram
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 预提交代码检查图
- en: As we can see, whenever we attempt to commit to the repository, the `git pre-commit`
    hook will run and execute the scripts that will do the checking. If all the checks
    pass, the changes will be committed to the repository; otherwise, we will have
    to fix the issues and try again.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，每次我们尝试向仓库提交时，`git pre-commit` 钩子都会运行并执行检查脚本。如果所有检查都通过，更改将被提交到仓库；否则，我们必须修复问题并再次尝试。
- en: 'To enable this flow, we will use `husky` and `lint-staged`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用这个流程，我们将使用 `husky` 和 `lint-staged`：
- en: '`husky` is a tool that allows us to run git hooks. We want to run the pre-commit
    hook to run the checks before committing our changes.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`husky` 是一个允许我们运行 git 钩子的工具。我们希望运行预提交钩子在提交更改之前进行检查。'
- en: '`lint-staged` is a tool that allows us to run those checks only on files that
    are in the staging area of Git. This improves the speed of code checking since
    doing that on the entire code base might be too slow.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lint-staged` 是一个工具，它允许我们只在 Git 的暂存区域中的文件上运行这些检查。这提高了代码检查的速度，因为在整个代码库上执行可能会太慢。'
- en: 'We already have these tools installed and configured, but if we didn’t, they
    could be installed using the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经安装并配置了这些工具，但如果我们没有，可以使用以下命令进行安装：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we would need to enable Git hooks:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要启用 Git 钩子：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we would need to create the pre-commit hook:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要创建预提交钩子：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The Husky pre-commit hook will run lint-staged. Then, we would need to define
    what commands lint-staged should run inside the `lint-staged.config.js` file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Husky 预提交钩子将运行 `lint-staged`。然后，我们需要在 `lint-staged.config.js` 文件中定义 `lint-staged`
    应该运行的命令：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If we try to commit code that contains any violations, it will fail and stop
    us from committing the changes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试提交包含任何违规的代码，它将失败并阻止我们提交更改。
- en: Now that we covered most of our setup, let’s look at the structure of our project.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经覆盖了大部分设置，让我们看看我们项目的结构。
- en: Project structure overview
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构概述
- en: As we already mentioned, React is very flexible when it comes to project structure.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，React 在项目结构方面非常灵活。
- en: 'Some of the benefits of having a good project structure are as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有良好项目结构的某些好处如下：
- en: Separation of concerns
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点的分离
- en: Easier refactors
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易的重构
- en: Better reasoning about the code base
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的代码库推理
- en: Easier for larger teams to work on the code base simultaneously
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易让大型团队同时处理代码库
- en: Let’s see what the feature-based project structure looks like.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看基于功能的工程项目结构是什么样的。
- en: Note
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will focus on the `src` folder only since, from now on, most of the code
    base lives there.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只关注 `src` 文件夹，因为从现在起，大部分代码库都存放在那里。
- en: 'Here is the structure of our `src` folder:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的 `src` 文件夹的结构：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let’s analyze each of the folders, one by one:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个分析每个文件夹：
- en: '`components`: Contains all shared components that are used across the entire
    application.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`components`：包含在整个应用程序中使用的所有共享组件。'
- en: '`config`: Contains the application configuration files.'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`config`：包含应用程序配置文件。'
- en: '`features`: Contains all the feature-based modules. We will analyze this one
    in more detail in the following section.'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`features`：包含所有基于功能的模块。我们将在下一节中更详细地分析这个模块。'
- en: '`layouts`: Contains different layouts for the pages.'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`layouts`：包含页面使用的不同布局。'
- en: '`lib`: Contains configurations for different libraries that are used in our
    application.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lib`：包含我们在应用程序中使用的不同库的配置。'
- en: '`pages`: Contains the pages of our application. This is where Next.js will
    look for pages in the filesystem-based routing.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pages`：包含我们的应用程序页面。这是 Next.js 在基于文件系统的路由中查找页面的地方。'
- en: '`providers`: Contains all application providers. For example, if our application
    uses many different providers for styling, state, and so on, we can combine them
    here and export a single application provider with which we can wrap our `_app.tsx`
    to make all the providers available on all the pages.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`providers`：包含所有应用程序提供者。例如，如果我们的应用程序使用许多不同的提供者进行样式、状态等，我们可以在这里将它们组合起来，并导出一个单一的应用程序提供者，我们可以用这个提供者包裹
    `_app.tsx`，使所有提供者对所有页面都可用。'
- en: '`stores`: Contains all global state stores that are used in the application.'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`stores`：包含在应用程序中使用的所有全局状态存储。'
- en: '`testing`: Contains test-related mocks, helpers, utilities, and configurations.'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`testing`：包含与测试相关的模拟、辅助工具、实用程序和配置。'
- en: '`types`: Contains base TypeScript type definitions that are used across the
    application.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`types`：包含跨应用程序使用的基 TypeScript 类型定义。'
- en: '`utils`: Contains all shared utility functions.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`utils`：包含所有共享的实用函数。'
- en: There is nothing wrong with grouping files in folders based on their types.
    However, once the application starts to grow, it becomes more difficult to reason
    about and maintain the code base because there are too many files of a single
    type.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文件类型将文件分组到文件夹中并没有什么问题。然而，一旦应用程序开始增长，就变得更加难以推理和维护代码库，因为存在太多单一类型的文件。
- en: Features
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能
- en: To scale the application in the easiest and most maintainable way, we want to
    keep most of the application code inside the `features` folder, which should contain
    different feature-based things. Every `feature` folder should contain domain-specific
    code for a given feature. This will allow us to keep functionalities scoped to
    a feature and not mix its declarations with the shared things. This is much easier
    to maintain than a flat folder structure with many files.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以最简单和最可维护的方式扩展应用程序，我们希望将大部分应用程序代码保存在`features`文件夹中，该文件夹应包含基于功能的不同事物。每个`feature`文件夹应包含特定功能的领域特定代码。这将使我们能够将功能的功能范围限定在功能内，而不是将其声明与共享事物混合。这比具有许多文件的扁平文件夹结构更容易维护。
- en: 'Let’s look at one of our feature folders, which has the following structure:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的一个功能文件夹，它具有以下结构：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`api`: Contains the API request declarations and API hooks related to a specific
    feature. This makes our API layer and the UI layer separate and reusable.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`api`：包含与特定功能相关的API请求声明和API钩子。这使得我们的API层和UI层分离且可重用。'
- en: '`components`: Contains all components that are scoped to a specific feature.'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`components`：包含所有特定于特定功能的部分组件。'
- en: '`types`: This contains the TypeScript type definitions for a specific feature.'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`types`：这包含特定功能的TypeScript类型定义。'
- en: '`index.ts`: This is the entry point of every feature. It behaves as the public
    API of the feature, and it should only export things that should be public for
    other parts of the application.'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`index.ts`：这是每个功能的入口点。它作为功能的公共API，应该只导出其他应用程序部分应该公开的东西。'
- en: Note
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A feature might have other folders, such as `hooks`, `utils`, and others, depending
    on the needs of the feature. The only required file is the `index.ts` file, which
    acts as the public API of a feature.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 功能可能还有其他文件夹，例如`hooks`、`utils`等，具体取决于功能的需要。唯一必需的文件是`index.ts`文件，它作为功能的公共API。
- en: 'Let’s try to visualize the project structure with the following diagram:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用以下图表来可视化项目结构：
- en: '![Figure 2.2 – Project structure ](img/B17297_02_02.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 项目结构](img/B17297_02_02.jpg)'
- en: Figure 2.2 – Project structure
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 项目结构
- en: As we can see, most of our application code will live within features.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们的大部分应用程序代码将存在于功能中。
- en: 'One more thing we can configure is enforcing developers to import features
    code via the `index.ts` file, like so:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以配置强制开发者通过`index.ts`文件导入功能代码，如下所示：
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We shouldn’t do this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该这样做：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will give us a better picture of which dependency is used where and where
    it comes from. Also, if the feature gets refactored, it doesn’t have to impact
    any external parts of the application where that component is used.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们更好地了解哪些依赖项在哪里使用以及它们来自何处。此外，如果功能被重构，它不会影响应用程序中该组件被使用的外部部分。
- en: 'We can constrain our code by having the following ESLint rule in the `.``eslintrc.js`
    file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`.eslintrc.js`文件中设置以下ESLint规则来约束我们的代码：
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `no-restricted-imports` rule will add constraints to imports from other
    features by erroring if any violations in the preceding pattern are detected.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`no-restricted-imports`规则将通过错误报告前一个模式中的任何违规行为来对其他功能的导入添加约束。'
- en: Things from a feature can only be consumed if they’re exported from the `index.ts`
    file of that feature. This will force us to explicitly make something in a feature
    publicly available.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当它们从该功能的`index.ts`文件中导出时，才能消费来自功能的东西。这将迫使我们明确地将功能中的某些内容公开。
- en: If we decide to use features this way, we should also include the `import/no-cycle`
    rule to prevent cyclic dependencies where Feature A imports things from Feature
    B and vice versa. If this happens, that means something with the application design
    is wrong and it needs to be restructured.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定以这种方式使用功能，我们还应该包括`import/no-cycle`规则，以防止A功能从B功能导入东西，反之亦然的情况。如果发生这种情况，这意味着应用程序设计中有问题，需要重构。
- en: In this section, we learned what our application structure will look like. Then,
    we focused on splitting the application by feature, which will allow our code
    base to scale well if we decide to add more features.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了我们的应用程序结构将如何呈现。然后，我们专注于按功能拆分应用程序，这样如果我们决定添加更多功能，我们的代码库将能够很好地扩展。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the basics of our Next.js application setup, which
    has been configured to work with TypeScript. Then, we learned about absolute imports,
    which will make it easier to move files around. We also overviewed ESLint and
    Prettier and made them static code analysis tools so that they can run checks
    before committing the changes to our repository by using lint-staged and Husky.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Next.js 应用程序设置的基础知识，该设置已配置为与 TypeScript 一起使用。然后，我们学习了绝对导入，这将使移动文件变得更容易。我们还概述了
    ESLint 和 Prettier，并将它们作为静态代码分析工具，以便通过使用 lint-staged 和 Husky 在将更改提交到我们的存储库之前运行检查。
- en: Finally, we learned what our project structure will look like. We learned that
    the best way is to group code by features. We also defined an ESLint rule to enforce
    importing code from a feature in a specific way and prevent cyclic dependencies
    to make the code base clean and easy to reason about.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了我们的项目结构将如何呈现。我们了解到最佳方式是将代码按功能分组。我们还定义了一个 ESLint 规则，以强制以特定方式从功能中导入代码，并防止循环依赖，从而使代码库整洁且易于推理。
- en: In the next chapter, we will create the shared components that will act as the
    baseline for our application’s user interface.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建作为我们应用程序用户界面基准的共享组件。
