- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Creating a Custom Translation Module in a Nuxt 3 Monorepo
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Nuxt 3 单一代码库中创建自定义翻译模块
- en: In [*Chapter 8*](B19760_08.xhtml#_idTextAnchor165), we will learn how to build
    a custom `translation` module within a Nuxt 3 monorepo. This chapter is designed
    to guide you through the complexities of monorepo setup and modular development,
    providing a complete foundation for managing large-scale projects efficiently.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第8章*](B19760_08.xhtml#_idTextAnchor165) 中，我们将学习如何在 Nuxt 3 单一代码库中构建自定义的 `translation`
    模块。本章旨在指导你通过单一代码库设置和模块化开发的复杂性，为高效管理大型项目提供一个完整的基石。
- en: We will start by setting up a monorepo using `pnpm` workspaces, emphasizing
    the benefits of centralized management for multiple interlinked projects. You
    will also learn how to craft a custom `translation` module, embedding it seamlessly
    into a Nuxt application, by detailing the steps to create, configure, and extend
    this module with additional functionality through components and plugins.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用 `pnpm` 工作空间设置单一代码库，强调集中管理多个相互关联项目的优势。你还将学习如何通过详细说明创建、配置和通过组件和插件扩展此模块以添加额外功能的方式，将自定义
    `translation` 模块无缝嵌入到 Nuxt 应用程序中。
- en: This chapter demonstrates the modularity and reusability that monorepos facilitate.
    Each section aims to equip you with the skills to enhance your Nuxt applications
    with scalable and maintainable modules, preparing you for future projects that
    require advanced architecture solutions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了单一代码库如何促进模块化和可重用性。每个部分的目标是帮助你掌握增强 Nuxt 应用程序的可扩展性和可维护性模块的技能，为未来需要高级架构解决方案的项目做好准备。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Setting up a Nuxt monorepo
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Nuxt 单一代码库
- en: Developing a custom `translation` module
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发自定义 `translation` 模块
- en: Configuring `translation` module options
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 `translation` 模块选项
- en: Expanding the module with plugins, components, and composables
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过插件、组件和可组合函数扩展模块
- en: Future directions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来方向
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be found at .
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 。
- en: The CiA video for this chapter can be found on [https://packt.link/kdT64](https://packt.link/kdT64)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 CiA 视频可以在 [https://packt.link/kdT64](https://packt.link/kdT64) 找到
- en: Essential background – fundamentals of testing
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要的背景知识 – 测试基础
- en: In this chapter, we’re diving into setting up a Nuxt 3 monorepo for creating
    a custom `translation` module. A monorepo is a strategy where you manage all your
    project’s parts within a single repository. It’s like keeping all your development
    eggs in one basket, which simplifies many aspects of development, especially for
    large projects. In our setup, the monorepo will include not just a Nuxt application
    but a series of packages and apps, each contributing different functionalities
    to the overarching system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨如何为创建自定义的 `translation` 模块设置 Nuxt 3 单一代码库。单一代码库是一种策略，其中你将所有项目的部分管理在一个单一的仓库中。这就像把所有开发鸡蛋放在一个篮子里，这简化了开发中的许多方面，尤其是对于大型项目。在我们的设置中，单一代码库将不仅包括一个
    Nuxt 应用程序，还包括一系列的包和应用程序，每个都为整个系统贡献不同的功能。
- en: 'Monorepos are valuable for the following reasons:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 单一代码库有以下价值：
- en: '**Unified version control**: Everything from code to documentation is stored
    in one place, making it easier to track changes and maintain versions.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**统一版本控制**：从代码到文档的所有内容都存储在一个地方，这使得跟踪更改和维护版本更加容易。'
- en: '**Simplified dependency management**: All parts of the project use the same
    dependencies, which means they all get updated at once, reducing compatibility
    issues.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化依赖管理**：项目的所有部分使用相同的依赖项，这意味着它们都会同时更新，从而减少了兼容性问题。'
- en: '**Enhanced code reusability**: Monorepos allow teams to easily share common
    code and resources across multiple projects within the same repository. This facilitates
    reusing packages, reducing redundancy, and enhancing consistency across different
    applications.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强代码重用性**：单一代码库允许团队轻松地在同一仓库内的多个项目中共享通用代码和资源。这促进了包的重用，减少了冗余，并增强了不同应用程序之间的一致性。'
- en: Now we understand monorepos’ role in handling complex projects efficiently,
    we’ve set the stage for exploring how they facilitate the development of extensive
    applications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了单一代码库在高效处理复杂项目中的作用，我们已经为探索它们如何促进广泛应用程序的开发做好了准备。
- en: Setting up a Nuxt monorepo
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Nuxt 单一代码库
- en: In this chapter, we begin by establishing the foundational structure for our
    Nuxt monorepo. Instead of starting with the typical Nuxt project creation command,
    we’ll approach this setup by first crafting a dedicated environment that supports
    a multi-package architecture.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先为我们的Nuxt单一代码库建立基础结构。我们不会从典型的Nuxt项目创建命令开始，而是首先构建一个支持多包架构的专用环境。
- en: 'Let’s start by creating a new directory specifically for this chapter’s project
    to keep our workspace organized and separate from other projects:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先为本章的项目创建一个新目录，以保持我们的工作空间组织有序，并与其他项目分开：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, use `pnpm` to initialize a new project. This step involves creating a
    `package.json` file that will define our workspace and manage our project’s dependencies:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`pnpm`初始化一个新的项目。此步骤涉及创建一个`package.json`文件，该文件将定义我们的工作空间并管理项目依赖项：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, you can open the newly created project directory in Visual Studio Code
    or your preferred IDE.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在Visual Studio Code或您首选的IDE中打开新创建的项目目录。
- en: 'To designate our directory as a monorepo, we introduce a `pnpm-workspace.yaml`
    file. This configuration file plays a crucial role in managing multiple packages
    within a single repository efficiently. In this, we specify where the packages
    of our monorepo are located. The structure we’ve chosen categorizes our workspace
    into two primary directories:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的目录指定为单一代码库，我们引入一个`pnpm-workspace.yaml`文件。此配置文件在高效管理单个存储库中的多个包方面发挥着至关重要的作用。在此，我们指定了单一代码库中包的位置。我们选择的架构将工作空间分为两个主要目录：
- en: '`packages/*`: This directory is reserved for shared libraries or modules that
    can be reused across multiple applications within the monorepo. In our case, this
    is where the `translation` module will reside.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`packages/*`：此目录保留用于可以在单一代码库中的多个应用程序之间重用的共享库或模块。在我们的情况下，这是`翻译`模块将驻留的地方。'
- en: '`apps/*`: Dedicated to housing applications that may depend on any shared modules.
    Our Nuxt application demonstrating the use of the `translation` module will be
    placed here.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apps/*`：专门用于容纳可能依赖于任何共享模块的应用程序。我们将放置使用`translation`模块的Nuxt应用程序。'
- en: 'Here is the code of the file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是文件的代码：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, we’re ready to set up the website application that we’ll use to include
    the custom Nuxt module inside it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好设置我们将用于在其中包含自定义Nuxt模块的网站应用程序。
- en: Creating a website application
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建网站应用程序
- en: 'To set up our project directories properly within the monorepo, begin by creating
    an `apps` directoy:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要在单一代码库中正确设置我们的项目目录，首先创建一个`apps`目录：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Within the `apps` directory, we’ll establish a new Nuxt application using the
    latest version of Nuxt 3:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`apps`目录中，我们将使用Nuxt 3的最新版本创建一个新的Nuxt应用程序：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After initializing the Nuxt application, you can typically start the application
    by navigating into the `demo-website` directory and running `pnpm dev`. However,
    leveraging the full capability of our monorepo setup facilitated by `pnpm` workspaces,
    we can streamline this process. First, ensure the project name within the `apps/demo-website/package.json`
    file is set appropriately to reflect our specific setup:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化Nuxt应用程序后，您通常可以通过导航到`demo-website`目录并运行`pnpm dev`来启动应用程序。然而，利用由`pnpm`工作空间提供的单一代码库设置的完整功能，我们可以简化此过程。首先，请确保`apps/demo-website/package.json`文件中的项目名称设置适当，以反映我们的特定设置：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After updating the project name, you can now execute commands from the root
    of the monorepo. This is done using `pnpm`’s `--filter` option, which targets
    specific subprojects. To run our Nuxt application from the monorepo root, use
    the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新项目名称后，你现在可以从单一代码库的根目录执行命令。这是通过使用`pnpm`的`--filter`选项来完成的，该选项针对特定的子项目。要从单一代码库根目录运行我们的Nuxt应用程序，请使用以下命令：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command tells `pnpm` to apply the `dev` script specifically to the `demo-website`
    project, allowing you to manage and run multiple projects within your monorepo
    seamlessly from a central location.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令告诉`pnpm`将`dev`脚本专门应用于`demo-website`项目，从而允许您从中央位置无缝地管理和运行单一代码库中的多个项目。
- en: 'Going further, you can create a custom script in the root `package.json` file,
    which calls this command under the hood:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，您可以在根`package.json`文件中创建一个自定义脚本，该脚本在幕后调用此命令：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, run this command in the root folder:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在根目录中运行以下命令：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The application should start, and you should see a welcome page as usual. With
    our application set up, let’s continue to create a `translation` module.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序应该启动，你应该看到通常的欢迎页面。在我们的应用程序设置完成后，让我们继续创建一个`翻译`模块。
- en: Developing a custom translation module
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发自定义翻译模块
- en: 'As we continue creating our custom `translation` module, the first step in
    this process is to set up a dedicated directory for our shared packages. Navigate
    to the root of your monorepo and create a directory named `packages`. This directory
    will host all our shared logic, including the new `translation` module:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续创建自定义`translation`模块的过程中，此过程的第一步是为我们的共享包设置一个专门的目录。导航到您的单仓库根目录，创建一个名为`packages`的目录。此目录将托管所有我们的共享逻辑，包括新的`translation`模块：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once inside the `packages` directory, we will use Nuxt’s module template to
    kickstart our `translation` module:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入`packages`目录，我们将使用Nuxt的模块模板来启动我们的`translation`模块：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This command sets up a new module with a starter template provided by Nuxt,
    complete with several essential directories and files:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令设置了一个新的模块，它包含Nuxt提供的启动模板，包括几个必要的目录和文件：
- en: '`module.ts`: This is the core file where our module is defined. It acts as
    the entry point and defines the configuration and setup of the module.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module.ts`：这是我们模块定义的核心文件。它作为入口点，定义了模块的配置和设置。'
- en: '`runtime/plugin.ts`: This file serves as an example plugin. It’s a place to
    extend the module with additional functionalities such as Vue plugins and helper
    functions.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runtime/plugin.ts`：此文件作为示例插件。它是扩展模块以添加额外功能（如Vue插件和辅助函数）的地方。'
- en: '`playground/`: Contains a Nuxt application with our module already installed.
    This environment is useful for testing and demonstrating the module’s functionality.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playground/`：包含已安装我们的模块的Nuxt应用程序。此环境对于测试和演示模块的功能非常有用。'
- en: '`test/`: A directory set up for writing tests for the module to ensure its
    functionality and stability.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test/`：为模块编写测试的目录，以确保其功能性和稳定性。'
- en: 'Let’s discover the `module.ts` file to understand its structure and components:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索`module.ts`文件，了解其结构和组件：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This script outlines the basic structure of a Nuxt `pnpm` module using `defineNuxtModule`.
    The `meta` property defines the module’s name and configuration key. The `setup`
    function is where module-specific logic is added, such as registering plugins,
    using Nuxt hooks, adding an auto import directory, or even extending routes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本概述了使用`defineNuxtModule`的Nuxt `pnpm`模块的基本结构。`meta`属性定义了模块的名称和配置键。`setup`函数是添加模块特定逻辑的地方，例如注册插件、使用Nuxt钩子、添加自动导入目录，甚至扩展路由。
- en: The `createResolver` function helps in resolving paths correctly, ensuring that
    any URL is added without issues related to path resolution.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`createResolver`函数有助于正确解析路径，确保添加任何URL时不会出现与路径解析相关的问题。'
- en: Next, let’s use this module in our application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在我们的应用程序中使用此模块。
- en: Installing the module in our application
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的应用程序中安装模块
- en: 'First, rename the newly created module directory from `my-module` to `translation`
    to better reflect its purpose. This involves updating the name in the module:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将新创建的模块目录从`my-module`重命名为`translation`，以更好地反映其用途。这涉及到在模块中更新名称：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Also, update the name in the package configuration:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 还需更新包配置中的名称：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Then, ensure that build files of the modules are generated. To do so, run the
    following command in the `translation`
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，确保生成模块的构建文件。为此，请在`translation`目录中运行以下命令：
- en: 'module root folder:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 模块根目录：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This prepares local files for development.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这为开发准备本地文件。
- en: 'With the module configured, you can now add it to our demo website. From the
    root of your monorepo, run the following command to link the module locally to
    your application:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好模块后，您现在可以将它添加到我们的演示网站中。从您的单仓库根目录运行以下命令，将模块本地链接到您的应用程序：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `--workspace` flag tells `pnpm` to resolve the translation package from
    the local workspace instead of fetching it from an external registry. This setup
    ensures that the web app recognizes our packages and that any changes to the module
    are immediately available to the application during development.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`--workspace`标志告诉`pnpm`从本地工作区解析翻译包，而不是从外部注册表获取。这种设置确保Web应用程序识别我们的包，并且模块的任何更改在开发期间都能立即提供给应用程序。'
- en: 'To ensure that the module was added successfully, check the `package.json`
    file of your demo website:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保模块已成功添加，请检查您的演示网站中的`package.json`文件：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `translation` dependency should now be listed and pointing to your local
    workspace.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`translation`依赖项现在应列出并指向您的本地工作区。'
- en: 'Finally, add the module to your Nuxt configuration to activate it within your
    project:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将模块添加到您的Nuxt配置中，以在项目中激活它：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, start your application to see the module in action:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，启动您的应用程序以查看模块的实际效果：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Look for the console output or other indicators from the module’s default setup
    to confirm that it’s functioning:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 查找模块默认设置的控制台输出或其他指示，以确认其正在运行：
- en: '![Figure 8.1: Translation plugin injected](img/B19760_08_01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1：翻译插件注入](img/B19760_08_01.jpg)'
- en: 'Figure 8.1: Translation plugin injected'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：翻译插件注入
- en: This message, if visible, confirms that the `translation` module’s example plugin
    is actively injecting functionality into your Nuxt application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此消息可见，则确认`translation`模块的示例插件正在积极地向您的Nuxt应用程序注入功能。
- en: With these steps completed, your demo website now successfully incorporates
    the `translation` module. We’re now ready to customize the module further and
    define specific options specified to our project’s needs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，您的演示网站现在已成功整合了`translation`模块。我们现在可以进一步自定义模块，并定义针对项目需求指定的特定选项。
- en: Configuring translation module options
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置翻译模块选项
- en: Before we start adding options for our `translation` module, it’s essential
    to understand how Nuxt modules typically offer configuration flexibility. Similar
    to how the official Nuxt `i18n` module allows configuration of `defaultLocale`
    and `locales` through the Nuxt config, we aim to provide a similar configurability
    in our custom module. This setup will enable users to define and manage locales
    dynamically through the module’s options.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始为我们的`translation`模块添加选项之前，了解Nuxt模块通常如何提供配置灵活性是至关重要的。类似于官方Nuxt `i18n`模块通过Nuxt配置允许配置`defaultLocale`和`locales`，我们旨在在我们的自定义模块中提供类似的可配置性。这种设置将使用户能够通过模块的选项动态定义和管理区域设置。
- en: 'In our `translation` module, we begin by defining the expected options for
    configuration. This involves setting up an interface in `types.ts` that outlines
    the structure of the configuration options:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`translation`模块中，我们首先定义配置的预期选项。这涉及到在`types.ts`中设置一个接口，概述配置选项的结构：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, `ModuleOptions` allows for specifying a `defaultLocale` instance and an
    array of `locales` instances, each with a name and a file path pointing to the
    translations. We’ll discuss later on how to import these files.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ModuleOptions`允许指定一个`defaultLocale`实例和一个`locales`实例数组，每个实例都有一个名称和一个指向翻译的文件路径。我们将在稍后讨论如何导入这些文件。
- en: 'The next step involves integrating these types into the main module file. Import
    the defined types into `module.ts` and use them to strongly type the module’s
    configuration. Make sure to remove the empty defined interface:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将这些类型集成到主模块文件中。将定义的类型导入到`module.ts`中，并使用它们为模块的配置提供强类型。请确保删除空定义接口：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `defaults` object is updated to provide a fallback for `defaultLocale` and
    an empty array for locales, ensuring that the module can initialize even if specific
    configurations are not provided.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaults`对象被更新，为`defaultLocale`提供后备，并为区域设置提供一个空数组，确保即使没有提供特定配置，模块也可以初始化。'
- en: 'To utilize the module’s capabilities fully, add it to the `nuxt.config.ts`
    file of your Nuxt application, specifying the options like so:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分利用模块的功能，将其添加到您的Nuxt应用程序的`nuxt.config.ts`文件中，并指定如下选项：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Upon specifying these options, Nuxt’s intelligent configuration handling should
    offer autocomplete suggestions for `translation` options, reflecting the integration
    of our module options into the Nuxt ecosystem:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定这些选项后，Nuxt的智能配置处理应该为`translation`选项提供自动完成建议，反映我们的模块选项与Nuxt生态系统的集成：
- en: '![Figure 8.2: IntelliSense translation options](img/B19760_08_02.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2：IntelliSense翻译选项](img/B19760_08_02.jpg)'
- en: 'Figure 8.2: IntelliSense translation options'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：IntelliSense翻译选项
- en: When adjusting settings in the Nuxt configuration file, you should be able to
    see IntelliSense suggestions that validate the correct integration of our module
    options, confirming that the setup is recognized by Nuxt.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当调整Nuxt配置文件中的设置时，您应该能够看到IntelliSense建议，以验证我们的模块选项的正确集成，确认Nuxt已识别设置。
- en: After setting up basic configuration handling in our module, the subsequent
    task involves implementing logic within the module to dynamically load and apply
    the specified locales based on the provided configuration options.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模块中设置基本配置处理之后，接下来的任务是在模块内部实现逻辑，以根据提供的配置选项动态加载和应用指定的区域设置。
- en: Reading local files inside the module
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模块内部读取本地文件
- en: Let’s integrate local file reading capabilities into our Nuxt module to handle
    translations effectively. This functionality will enable our module to dynamically
    load translation files specified in the module’s configuration.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将本地文件读取功能集成到我们的Nuxt模块中，以有效地处理翻译。此功能将使我们的模块能够动态加载模块配置中指定的翻译文件。
- en: 'Begin by defining the expected structure of the translation files. Assume each
    file contains flat key-value pairs representing localized strings. For instance,
    set up the English and French localization files within the demo website:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义翻译文件的预期结构。假设每个文件都包含表示本地化字符串的扁平键值对。例如，在演示网站中设置英语和法语本地化文件：
- en: 'English localization file:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英语本地化文件：
- en: '[PRE22]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'French localization file:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 法语本地化文件：
- en: '[PRE23]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, modify your Nuxt configuration file and add these files to the `locales`
    array:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，修改你的Nuxt配置文件并将这些文件添加到`locales`数组中：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let’s go back to the module to process these files. Start by defining
    a type for the messages:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到模块来处理这些文件。首先定义消息的类型：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Remember that we’re assuming the `locales` translation files will be a flat
    key-value pair. You can handle nested objects, but to simplify the process, we’ll
    only use one level of keys.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们假设`locales`翻译文件将是一个扁平的键值对。你可以处理嵌套对象，但为了简化过程，我们只会使用一个级别的键。
- en: 'Finally, update your module’s `setup` function to loop through the locales,
    resolve their paths, read their contents, and then parse them into a usable format.
    Here’s how you can do this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新你的模块的`setup`函数以遍历区域设置，解析它们的路径，读取它们的内 容，然后将它们解析成可用的格式。以下是你可以这样做的方式：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here’s a code breakdown:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个代码分解：
- en: '`localesResolver`: Resolves paths relative to the project’s source directory,
    which is stored in `nuxt.options.srcDir`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localesResolver`：解析相对于项目源目录的路径，该路径存储在`nuxt.options.srcDir`'
- en: '`readFileSync`: Synchronously reads the content of the file at the resolved
    path'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readFileSync`：同步读取解析路径的文件内容'
- en: '`JSON.parse`: Converts the JSON string from the file into a JavaScript object'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JSON.parse`：将文件中的JSON字符串转换为JavaScript对象'
- en: '`nuxt.options.runtimeConfig.public.translation`: Stores messages in the Nuxt
    runtime config, making them accessible throughout the application via the `useRuntimeConfig()`
    composable'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nuxt.options.runtimeConfig.public.translation`：在Nuxt运行时配置中存储消息，通过`useRuntimeConfig()`可组合的组件在整个应用程序中访问'
- en: 'To verify the integration, modify the main application component to display
    the loaded messages:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证集成，修改主应用程序组件以显示加载的消息：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Restart your Nuxt application and navigate to the home page. You should now
    see the translation options displayed, as well as the localization messages:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动你的Nuxt应用程序并导航到主页。你现在应该看到显示的翻译选项以及本地化消息：
- en: '![Figure 8.3: Displaying translation array output](img/B19760_08_03.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3：显示翻译数组输出](img/B19760_08_03.jpg)'
- en: 'Figure 8.3: Displaying translation array output'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：显示翻译数组输出
- en: Now that our module can load translation messages, we’ll enhance its functionality
    by adding a plugin to create a global helper function. This function will allow
    us to easily retrieve and display translated strings throughout the Nuxt application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们模块可以加载翻译消息，我们将通过添加一个插件来增强其功能，创建一个全局辅助函数。这个函数将允许我们轻松地在Nuxt应用程序中检索和显示翻译字符串。
- en: Expanding the module with plugins, composables, and components
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过插件、可组合的组件和组件扩展模块
- en: We’ll start by developing a composable that manages the user’s preferred language.
    This composable will help in retrieving the correct locale from cookies or default
    to the configured locale from our module options.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先开发一个可组合的组件来管理用户的偏好语言。这个可组合的组件将帮助从cookie中检索正确的区域设置，或者默认为模块选项中配置的区域设置。
- en: 'Inside the module, create a new file for the composable: `runtime/composables/useTranslation.ts`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块内部，为可组合的组件创建一个新文件：`runtime/composables/useTranslation.ts`。
- en: 'Develop the composable function as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式开发可组合函数：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here’s a code breakdown:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个代码分解：
- en: '`useRuntimeConfig`: Accesses runtime configuration, which includes translation
    settings'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useRuntimeConfig`：访问运行时配置，包括翻译设置'
- en: '`useCookie`: A `ref` that manages cookie values: `get` – `set`, particularly
    for storing user’s locale preference'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useCookie`：一个管理cookie值的`ref`：`get` – `set`，特别是用于存储用户的区域偏好'
- en: '`computed`: Reactively calculates the correct messages to use based on the
    current locale'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`computed`：根据当前区域设置反应性地计算要使用正确的消息'
- en: Note
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When developing a Nuxt module, it’s essential to import any function or composable
    that is auto-imported by default in a Nuxt app explicitly from `#imports`. This
    approach ensures that the module can utilize Nuxt’s auto-import feature, which
    is not inherently available in the module’s scope as it would be within a Nuxt
    application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发Nuxt模块时，显式地从`#imports`导入任何默认在Nuxt应用中自动导入的函数或组合式是至关重要的。这种方法确保了模块可以利用Nuxt的自动导入功能，而该功能在模块的作用域中并不固有，就像在Nuxt应用中那样。
- en: 'To ensure our composable is easily accessible within the Nuxt app, we’ll automate
    its import. Update the `module.ts` file to auto-import the `composables` directory:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的组合式在Nuxt应用中易于访问，我们将自动化其导入。更新`module.ts`文件以自动导入`composables`目录：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`addImportsDir` automatically imports files from the specified directory, making
    the composables readily available to the Nuxt app without manual `import` statements.
    Thus, this folder will act exactly like the `composables` folder, which is inside
    your Nuxt application!'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`addImportsDir`自动从指定的目录导入文件，使得组合式可以轻松地供Nuxt应用使用，无需手动`import`语句。因此，这个文件夹将完全像Nuxt应用内部的`composables`文件夹一样工作！'
- en: 'With the composable ready, let’s test its functionality. Update `app.vue` as
    follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 组合式准备就绪后，让我们测试其功能。按照以下方式更新`app.vue`：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This setup should display a welcome message based on the default or user-defined
    locale. Because we didn’t update the default locale, the module will use `''en''`
    as the default value, as it is configured in the module file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置应该根据默认或用户定义的区域显示欢迎消息。因为我们没有更新默认区域，所以模块将使用`'en'`作为默认值，因为它在模块文件中已配置：
- en: '![Figure 8.4: Messages array based on the default locale](img/B19760_08_04.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4：基于默认区域的消息数组](img/B19760_08_04.jpg)'
- en: 'Figure 8.4: Messages array based on the default locale'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：基于默认区域的消息数组
- en: 'Now, let’s ensure that our module can respect locale overrides specified in
    the Nuxt configuration:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们确保我们的模块可以尊重Nuxt配置中指定的区域设置覆盖：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'By setting `defaultLocale` to `''fr''` and accessing the app in a private window
    (to clear previous cookies), a French translation should appear, demonstrating
    the flexibility and dynamic capability of our `translation` module:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`defaultLocale`设置为`'fr'`并在私有窗口中访问应用（以清除之前的cookie），应该出现法语翻译，这证明了我们的`translation`模块的灵活性和动态能力：
- en: '![Figure 8.5: Messages array based on the default locale](img/B19760_08_05.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5：基于默认区域的消息数组](img/B19760_08_05.jpg)'
- en: 'Figure 8.5: Messages array based on the default locale'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：基于默认区域的消息数组
- en: Now, let’s move forward to enhance the module with a plugin that provides a
    global `$t` global function for fetching translated messages directly. This will
    simplify the use of translations throughout the application.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续前进，通过一个插件增强模块，该插件提供了一个全局的$t函数，用于直接获取翻译消息。这将简化在整个应用中使用翻译。
- en: Creating a $t helper function
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个$t辅助函数
- en: 'First, we create a new `translate.ts` file inside the `runtime/plugins` directory
    of the module. This file will contain the logic for our translation function.
    Here’s how to write a plugin to fetch translations:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在模块的`runtime/plugins`目录内创建一个新的`translate.ts`文件。这个文件将包含我们翻译函数的逻辑。以下是编写用于获取翻译的插件的步骤：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here’s a code breakdown:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码分解：
- en: We’re importing `useTranslation`, which manages the translation state and provides
    translations based on the current locale.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在导入`useTranslation`，它管理翻译状态并根据当前区域提供翻译。
- en: We’re defining plugins using `defineNuxtPlugin`. The `#imports` alias is used
    here to automatically resolve to the correct utility versions provided by Nuxt.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用`defineNuxtPlugin`定义插件。这里的`#imports`别名用于自动解析到Nuxt提供的正确工具版本。
- en: We’re implementing a `t` translator function that takes a key as an argument.
    It attempts to retrieve the translation for this key from the `messages` object
    obtained from `useTranslation`. If a translation for the key doesn’t exist, it
    defaults back to the key itself.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在实现一个`t`翻译函数，它接受一个键作为参数。它尝试从`useTranslation`获取的`messages`对象中检索该键的翻译。如果该键不存在翻译，则默认回退到该键本身。
- en: 'We’re providing `Translator` as a global helper function by adding `return
    { provide: { t } }` to the end of the plugin definition function. By providing
    `t`, any component within the application can use this function to render translated
    text using: `$t`. Nuxg automatically add `$` to any function provided by nuxt
    module to access it globally.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们通过在插件定义函数的末尾添加 `return { provide: { t } }` 来提供 `Translator` 作为全局辅助函数。通过提供
    `t`，应用程序中的任何组件都可以使用此函数来使用 `$t` 渲染翻译文本。Nuxt 自动将 `$` 添加到由 nuxt 模块提供的任何函数中，以便全局访问。'
- en: 'Next, integrate this plugin into our Nuxt module by updating the `module.ts`
    file:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过更新 `module.ts` 文件将此插件集成到我们的 Nuxt 模块中：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, update your application’s main component, `app.vue`, to use the `$``t`
    function:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新您的应用程序的主要组件 `app.vue`，以使用 `$t` 函数：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once implemented, test by running your application and navigating. You should
    see the translated strings rendering based on the active locale:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实现，通过运行应用程序并导航来测试。您应该看到基于活动区域设置的翻译字符串的渲染：
- en: '![Figure 8.6: $t function output](img/B19760_08_06.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6：$t 函数输出](img/B19760_08_06.jpg)'
- en: 'Figure 8.6: $t function output'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6：$t 函数输出
- en: For the final expansion, we’ll create a component that allows users to switch
    languages directly from their web interface.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最终的扩展，我们将创建一个允许用户直接从他们的网络界面切换语言的组件。
- en: Setting up a language switcher component
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置语言切换组件
- en: 'We’ll create a language switcher component using the menu component from the
    `@nuxt/ui` package. Firstly, install the `@nuxt/ui` package within our module’s
    scope. From the root of your project, run the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自 `@nuxt/ui` 包的菜单组件创建一个语言切换组件。首先，在我们的模块范围内安装 `@nuxt/ui` 包。从项目的根目录运行以下命令：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `module.ts` file, verify and install `@nuxt/ui` if it’s not already
    present in the host application, and ensure to auto-import the new `components`
    directory. Nuxt Kit provides various helper functions to achieve this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `module.ts` 文件中，验证并安装 `@nuxt/ui`（如果它尚未存在于宿主应用程序中），并确保自动导入新的 `components` 目录。Nuxt
    Kit 提供了各种辅助函数来实现这一点：
- en: '`hasNuxtModule`: Checks whether `@nuxt/ui` is already installed in the host
    application'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasNuxtModule`：检查 `@nuxt/ui` 是否已安装在宿主应用程序中'
- en: '`installModule`: Dynamically installs `@nuxt/ui` if it is not found'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`installModule`：如果未找到，则动态安装 `@nuxt/ui`'
- en: '`addComponentsDir`: Adds the directory containing our custom components to
    Nuxt’s auto-import feature, allowing these components to be used without manual
    import'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addComponentsDir`：将包含我们的自定义组件的目录添加到 Nuxt 的自动导入功能中，允许这些组件无需手动导入'
- en: 'Here’s the updated version of the `module.ts` setup function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `module.ts` 设置函数的更新版本：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, create a new `LanguageSwitcher.vue` component within the `runtime/components`
    directory. This component will utilize the `USelectMenu` UI component from `@nuxt/ui`
    to render a dropdown for language selection:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `runtime/components` 目录中创建一个新的 `LanguageSwitcher.vue` 组件。此组件将利用来自 `@nuxt/ui`
    的 `USelectMenu` UI 组件来渲染语言选择的下拉菜单：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here’s an explanation of the components:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对组件的解释：
- en: '`USelectMenu`: A UI component from `@nuxt/ui` that renders a dropdown menu.
    It binds to the `locale` reactive variable and updates it based on user selection.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USelectMenu`：来自 `@nuxt/ui` 的 UI 组件，用于渲染下拉菜单。它绑定到 `locale` 响应变量，并根据用户选择更新它。'
- en: '`locales`: An array of available languages that populate the dropdown options.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`locales`：一个包含可用语言的数组，用于填充下拉选项。'
- en: 'To ensure the `LanguageSwitcher` component is functioning correctly, run the
    following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保 `LanguageSwitcher` 组件正常工作，运行以下命令：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This prepares the module with the new component. Then, update the `app.vue`
    file in your Nuxt application to use the `LanguageSwitcher` component:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用新组件准备模块。然后，更新您的 Nuxt 应用程序中的 `app.vue` 文件以使用 `LanguageSwitcher` 组件：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Refresh your browser to test the functionality. You should see a welcome message
    as well as a select menu that contains two locales: `en` and `fr`. Changing the
    language using the dropdown should dynamically update the welcome message, demonstrating
    the reactive translation updates across the application:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新您的浏览器以测试功能。您应该看到一个欢迎消息以及包含两个区域设置（`en` 和 `fr`）的选择菜单。使用下拉菜单更改语言应该会动态更新欢迎消息，从而演示应用程序中的响应式翻译更新：
- en: '![Figure 8.7: LanguageSelector component](img/B19760_08_07.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7：LanguageSelector 组件](img/B19760_08_07.jpg)'
- en: 'Figure 8.7: LanguageSelector component'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7：LanguageSelector 组件
- en: Note that we managed to use the `@nuxt/ui` package within the module without
    direct installation in the host application, exemplifying the flexibility of Nuxt
    modules. We can still install this package in our host application, and this won’t
    result in any error due to the `hasNuxtModule` checker function.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们设法在模块中使用了 `@nuxt/ui` 包，而无需在宿主应用程序中直接安装，这展示了 Nuxt 模块的灵活性。我们仍然可以在宿主应用程序中安装此包，并且由于
    `hasNuxtModule` 检查函数，这不会导致任何错误。
- en: Now that we’ve finished implementing our custom modules in Nuxt 3, let’s look
    ahead to how we can further refine and expand these concepts in real-world applications.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了在 Nuxt 3 中实现自定义模块，让我们展望一下如何在现实世界的应用中进一步精炼和扩展这些概念。
- en: Future directions
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未来方向
- en: As we conclude this chapter, it’s important to reflect on the underlying principles
    that guided our journey through building a custom `i18n` module within a monorepo
    structure. The focus was not on the aesthetics of the application but on the architecture—specifically,
    the creation of a module system. This approach is particularly beneficial for
    large-scale projects where managing complexity efficiently is crucial.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这一章时，重要的是反思指导我们通过在单仓库结构中构建自定义 `i18n` 模块之旅的潜在原则。重点不在于应用程序的美学，而在于架构——特别是模块系统的创建。这种方法对于需要高效管理复杂性的大型项目尤其有益。
- en: POS system example
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POS 系统示例
- en: In real-world scenarios, especially in enterprise environments, applications
    are rarely simple. They often consist of numerous interconnected parts, such as
    a **point-of-sale** (**POS**) system, which might include modules for handling
    orders, promotions, customer management, and more. Each of these modules can be
    designed to operate independently, containing its own pages, logic, components,
    and state management.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的场景中，尤其是在企业环境中，应用程序很少简单。它们通常由许多相互连接的部分组成，例如**销售点**（**POS**）系统，这可能包括处理订单、促销、客户管理和更多模块。每个模块都可以设计为独立运行，包含自己的页面、逻辑、组件和状态管理。
- en: In such a system, different modules can be developed and maintained independently.
    For instance, a promotions module might handle all promotional offers and discount
    logic. If the business decided to overhaul its promotions strategy, only the promotions
    module would need to be updated or replaced, minimizing risk and disruption to
    other parts of the system.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的系统中，不同的模块可以独立开发和维护。例如，一个促销模块可能处理所有促销活动和折扣逻辑。如果企业决定彻底改革其促销策略，只需更新或替换促销模块，从而最小化对系统其他部分的风险和干扰。
- en: E-commerce platform example
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电子商务平台示例
- en: Modular systems are particularly beneficial in complex e-commerce platforms,
    where different functionalities such as product catalog management, order processing,
    payment integrations, and user profiles are essential yet distinct components.
    Each module can be separately developed, tested, and deployed, allowing for flexible
    updates and scalability.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化系统在复杂的电子商务平台上特别有益，在这些平台上，如产品目录管理、订单处理、支付集成和用户资料等不同功能是基本且独立的组件。每个模块都可以单独开发、测试和部署，从而实现灵活的更新和可扩展性。
- en: For example, the payment integration module might support various payment gateways
    and handle all the complexities of transactions. If new payment methods need to
    be added or existing ones need updates due to regulatory changes, developers can
    focus solely on this module. This modular approach speeds up development and deployment
    and ensures that updates in one area, such as payment processing, do not inadvertently
    affect unrelated parts such as the product catalog or user management systems.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，支付集成模块可能支持各种支付网关并处理所有交易复杂性。如果需要添加新的支付方式或由于监管变化需要对现有支付方式进行更新，开发者可以仅关注此模块。这种模块化方法加快了开发和部署速度，并确保一个区域的更新，如支付处理，不会无意中影响产品目录或用户管理系统等无关部分。
- en: Final thoughts
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最后的想法
- en: The goal of this chapter was to underscore the transformative impact of modular
    architecture on the development and scalability of large-scale applications. By
    adopting a modular approach, developers can efficiently manage complex systems,
    facilitating easier updates, testing, and expansion. Moving forward, apply the
    strategies explored here to structure your projects effectively.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是强调模块化架构对大型应用程序开发和可扩展性的变革性影响。通过采用模块化方法，开发者可以有效地管理复杂系统，促进更轻松的更新、测试和扩展。向前看，将这里探索的策略应用于有效地构建项目。
- en: Additionally, this journey highlighted the great developer experience provided
    by Nuxt, which simplifies the creation of custom modules. Nuxt’s framework supports
    extensive customization, allowing for seamless integration of options, components,
    plugins, and composables. This flexibility ensures our applications meet current
    needs while also being well prepared for future advancements and integrations.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we spotlit the creation of a custom `translation` module within
    a Nuxt 3 monorepo, designed to streamline the management of large-scale projects.
    We began by establishing a monorepo setup using `pnpm`, which allowed us to structure
    our project into separate but interconnected workspaces. This foundation supported
    the development of our `translation` module, starting from a basic Nuxt module
    template. By configuring module options, we customized the module to handle multiple
    languages.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Further enhancing the module, we integrated plugins, components, and composables,
    providing a dynamic and user-friendly way to switch languages and manage translations.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: This practical application demonstrated how modular architecture enhances code
    reuse while also simplifying enhancements and scalability. The concluding discussion
    on future directions explored the potential for where we can use this modular
    approach in other domains, such as e-commerce or enterprise systems, illustrating
    the broad applicability and flexibility of the techniques learned.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: This chapter serves as a blueprint for developers looking to fully utilize Nuxt’s
    modular capabilities in their projects.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Practice questions
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Describe the process of setting up a monorepo with `pnpm` for a Nuxt 3 project.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the key benefits of using a monorepo structure in large-scale Nuxt
    3 projects?
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you initiate a new Nuxt 3 module within a monorepo?
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you add a Nuxt module to a Nuxt application within the same monorepo?
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does the `addPlugin` function do within a Nuxt module?
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the role of `runtimeConfig` in a Nuxt module?
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe the purpose of using `createResolver` within a Nuxt module.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain how the `hasNuxtModule` and `installModule` functions are used in a
    module setup.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you add and use a composable within a Nuxt module?
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you configure a Nuxt module to automatically import components from
    a specified directory when the module is used in a project?
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nuxt modules: [https://nuxt.com/docs/guide/concepts/modules](https://nuxt.com/docs/guide/concepts/modules)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Module author guide: [https://nuxt.com/docs/guide/going-further/modules/](https://nuxt.com/docs/guide/going-further/modules/)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pnpm` workspaces: [https://pnpm.io/workspaces](https://pnpm.io/workspaces)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nuxt lifecycle hooks: [https://nuxt.com/docs/guide/going-further/hooks](https://nuxt.com/docs/guide/going-further/hooks)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nuxt auto-imports concept: [https://nuxt.com/docs/guide/concepts/auto-imports](https://nuxt.com/docs/guide/concepts/auto-imports)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
