- en: '*Chapter 5*: Using CSS Custom Properties'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 5 章*：使用 CSS 自定义属性'
- en: We will now dive into the practical details of how to implement the features
    you encountered in *Part 1 A Quick and Functional Guide to Angular Ivy* in the
    Angular Academy application, which will allow you to browse and select a curriculum
    of available Angular video courses on YouTube.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将深入探讨如何在 Angular Academy 应用程序中实现你在 *第 1 部分 快速且实用的 Angular Ivy 指南* 中遇到的功能的实践细节，这将允许你浏览并选择可用的
    Angular 视频课程。
- en: 'We''ll start by describing the Angular Academy application while covering the
    following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先描述 Angular Academy 应用程序，同时涵盖以下主题：
- en: Building a theme picker using custom CSS properties
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义 CSS 属性构建主题选择器
- en: Implementing the theme service
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现主题服务
- en: Controlling CSS Grid templates using custom CSS properties
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义 CSS 属性控制 CSS 网格模板
- en: By the end of the chapter, you will have gained practical experience in using
    custom CSS properties in a real-world application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将在实际应用程序中使用自定义 CSS 属性方面获得实践经验。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Combining and using all the new features in the Angular Academy application
    will involve a series of practical choices that are usually hidden in the descriptions
    in *Part 1*, *A Quick and Functional Guide to Angular Ivy* which means we will
    need to provide an overview of the application as a whole.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 结合并使用 Angular Academy 应用程序中的所有新功能将涉及一系列通常隐藏在 *第 1 部分*，*快速且实用的 Angular Ivy 指南*
    描述中的实际选择，这意味着我们需要提供整个应用程序的概述。
- en: So, before we dive into an in-depth description of all the details, let's check
    out the code first and have it available for inspection while reading the in-depth
    description in the upcoming chapters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们深入所有细节描述之前，让我们先查看代码，并在阅读即将到来的章节中的深入描述时进行检查。
- en: 'Open the terminal and issue the following command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并执行以下命令：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The demo project source code will be placed in `projects`/`demo` and can be
    started on your development machine, like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 示例项目源代码将被放置在 `projects`/`demo` 目录中，可以在你的开发机器上启动，如下所示：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you go to [http://localhost:4200](http://localhost:4200) on your browser,
    you should now be able to see the Angular Academy app:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在你的浏览器中访问 [http://localhost:4200](http://localhost:4200)，你现在应该能够看到 Angular
    Academy 应用程序：
- en: '![Figure 5.1 – In the Angular Academy application, you can see a list of YouTube
    video courses'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – 在 Angular Academy 应用程序中，你可以看到一系列 YouTube 视频课程列表'
- en: '](img/Figure_5.1_B16295.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B16295.jpg)'
- en: Figure 5.1 – In the Angular Academy application, you can see a list of YouTube
    video courses
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 在 Angular Academy 应用程序中，你可以看到一系列 YouTube 视频课程列表
- en: When the Angular Academy application is started, you will see a list of YouTube
    courses on the default page (as illustrated in *Figure 5.1*). Feel free to browse
    to get a feel of what we will be covering in the upcoming chapters. As an example,
    try clicking the **Edit Theme** menu entry to open the theme picker. We will be
    looking at this in the next section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Angular Academy 应用程序启动时，你将在默认页面上看到一系列 YouTube 课程（如图 5.1 所示）。请随意浏览，以了解我们将在接下来的章节中介绍的内容。例如，尝试点击
    **编辑主题** 菜单项以打开主题选择器。我们将在下一节中探讨这个问题。
- en: Building a theme picker using custom CSS properties
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义 CSS 属性构建主题选择器
- en: Having a theme available for your application is a common and important use
    case that is already covered by popular Angular libraries. You may be aware that
    Angular Material already supports several available themes (for example, the popular
    **deeppurple-amber** and **indigo-pink**). The common approach of using preprocessor
    variables when using SCSS has been available for some time. But now, you can support
    dynamic theming using custom CSS properties without having to generate the CSS
    files using a preprocessor. This adds new options for interactive theming that
    we will cover in this section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的应用程序提供一个主题是一个常见且重要的用例，这已经被流行的 Angular 库所覆盖。你可能知道 Angular Material 已经支持几个可用的主题（例如，流行的
    **deeppurple-amber** 和 **indigo-pink**）。当使用 SCSS 时，使用预处理器变量的常见方法已经存在了一段时间。但现在，你可以使用自定义
    CSS 属性来支持动态主题，而无需使用预处理器生成 CSS 文件。这为我们提供了新的交互式主题选项，我们将在本节中介绍。
- en: 'Given that further CSS rules can be built using CSS Custom Properties, we can
    now change several styling rules in one go, directly from one of the components
    in the application. Here, one or more CSS classes can be calculated on the fly
    via the `--headerbackground` custom property or simply by attaching the value
    of the property as the CSS class, like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可以使用CSS自定义属性构建进一步的CSS规则，我们现在可以直接从应用程序中的一个组件开始更改多个样式规则。在这里，可以通过`--headerbackground`自定义属性动态计算一个或多个CSS类，或者简单地通过将属性的值作为CSS类附加，如下所示：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `headerbackground` color can be picked by the user using a theme picker
    construct, similar to this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用类似于这样的主题选择器结构来选择`headerbackground`颜色：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For interactive use, the value of the `headerbackground` custom property could
    be a variable stored in `localStorage` that's available during use. `headergroundcolor`
    could then affect the styling of the elements inside the specific tile component.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于交互式使用，`headerbackground`自定义属性的值可以是存储在`localStorage`中的变量，在使用期间可用。然后`headergroundcolor`可以影响特定瓷砖组件内部元素的样式。
- en: 'In the Angular Academy application, we will wrap it with an Angular Material
    form field in the theme component template, like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular Academy应用程序中，我们将在主题组件模板中使用Angular Material表单字段将其包装，如下所示：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Using the Material form input field in the theme picker component will look
    like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在主题选择器组件中使用Material表单输入字段将看起来像这样：
- en: '![Figure 5.2 – You can use the theme picker component to select the header''s
    background color'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 – 您可以使用主题选择器组件来选择标题的背景颜色'
- en: '](img/Figure_5.2_B16295.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.2_B16295.jpg)'
- en: Figure 5.2 – You can use the theme picker component to select the header's background
    color
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 您可以使用主题选择器组件来选择标题的背景颜色
- en: We can apply the chosen color *directly* from the custom SCSS properties to
    the relevant component SCSS files in the application or directly at the app scope
    using the style syntax precedence works implemented in Ivy.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接从自定义SCSS属性将选定的颜色应用到应用程序中相关组件的SCSS文件，或者在应用程序作用域内直接使用Ivy实现的样式语法优先级使用，如下所示：
- en: 'For practical purposes, we will use a `@HostBinding` to bind each theme setting
    to a theme variable for the application scope, like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实际应用，我们将使用`@HostBinding`将每个主题设置绑定到应用程序作用域的主题变量，如下所示：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The values for the CSS properties can be retrieved in the theme component via
    a getter, which retrieves the value via the theme service, like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过getter在主题组件中检索CSS属性的值，该getter通过主题服务检索值，如下所示：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `update($event)` callback on the theme component could refer to the theme
    service, which would update the chosen value behind the scenes. Additionally,
    the theme component would allow access to the chosen values for the custom CSS
    properties by binding them to the application''s scope, like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 主题组件上的`update($event)`回调可以引用主题服务，这将更新幕后选择的值。此外，主题组件将通过绑定到应用程序的作用域来允许访问自定义CSS属性的所选值，如下所示：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the app component, we are referring to the same theme service for handling
    data updates related to the theme component. By separating handling data updates
    into a service, we can abstract the details of how to store and retrieve the theme
    settings for later.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序组件中，我们引用相同的主题服务来处理与主题组件相关的数据更新。通过将处理数据更新分离到服务中，我们可以抽象出如何存储和检索主题设置的细节，以便以后使用。
- en: Implementing the theme service
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现主题服务
- en: The theme service has the responsibility of retrieving the dynamic theme settings.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 主题服务负责检索动态主题设置。
- en: 'Let''s start with a simple implementation by using `localStorage`. In this
    implementation, we will also provide default settings if the value is not available:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用`localStorage`的简单实现开始。在这个实现中，如果值不可用，我们还将提供默认设置：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we will provide example settings if the setting has no previous value.
    For example, if `headerBackground` has not previously been set, then we will set
    it to `#00aa00`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果设置没有之前的值，我们将提供示例设置。例如，如果`headerBackground`之前没有被设置，那么我们将将其设置为`#00aa00`。
- en: One of the benefits of using the theme service from the theme picker component
    is that you, at a later stage, could choose to implement the theme service to
    use another mechanism for storing and retrieving settings (for example, you could
    choose to retrieve values from a corporate design token system that may contain
    the default settings). Additionally, you can also use a provider scope for the
    service to share data related to the usage scenario, as you will see later in
    [*Chapter 8*](B16295_08_ePub_RK.xhtml#_idTextAnchor094), *Additional Provider
    Scopes*. Another aspect of theming is controlling the relative sizes and placement
    of items on the screen, depending on user preferences. A modern approach to this
    is using CSS Grids – and it turns out that we can encapsulate these settings well
    using custom CSS properties. We will cover how to do this in the next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用主题选择器组件的主题服务的一个好处是，在以后的某个阶段，你可以选择实现主题服务以使用另一种机制来存储和检索设置（例如，你可以选择从可能包含默认设置的机构设计令牌系统中检索值）。此外，你还可以使用服务提供者作用域来共享与使用场景相关的数据，正如你将在[*第8章*](B16295_08_ePub_RK.xhtml#_idTextAnchor094)，“附加提供者作用域”中看到的。主题的另一个方面是控制屏幕上项目的相对大小和位置，这取决于用户偏好。对此的现代方法是使用
    CSS 网格，而且我们发现我们可以很好地使用自定义 CSS 属性封装这些设置。我们将在下一节中介绍如何做到这一点。
- en: Controlling CSS Grid templates using custom CSS properties
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义 CSS 属性控制 CSS 网格模板
- en: Imagine that you want to emphasize the importance of the textual descriptions
    of videos, so you would like to increase the amount of space for text, and most
    likely decrease the amount of space used for the video. This could be implemented
    using a dynamic viewer using some TypeScript logic, which could perform the sizing
    calculations on the fly. Given that you would like to be able to view the content
    on your mobile phone as well, you would need to implement considerations for the
    grid layout on smaller screens. This additional requirement would be complex enough
    that custom theming would be required. However, as it turns out, we can combine
    media queries with inline custom CSS properties in a manner that is both compact
    and easy to understand.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想强调视频文本描述的重要性，因此你想增加文本的空间量，并且很可能会减少用于视频的空间量。这可以通过使用一些 TypeScript 逻辑的动态查看器来实现，该查看器可以在运行时执行尺寸计算。鉴于你希望能够在手机上查看内容，你需要为较小屏幕的网格布局考虑。这个额外要求足够复杂，以至于需要自定义主题。然而，实际上，我们可以以既紧凑又易于理解的方式将媒体查询与内联自定义
    CSS 属性结合起来。
- en: 'If we introduce the `video` and `text` CSS classes for the course video tiles,
    then we can style them using custom CSS properties and CSS Grid techniques while
    referencing the `container` grid-columns, like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为课程视频瓷砖引入`video`和`text` CSS 类，那么我们可以使用自定义 CSS 属性和 CSS 网格技术来设置它们的样式，同时参考`container`网格列，如下所示：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `videosize` and `textsize` CSS properties would then control how many columns
    are assigned to `video` and `text`. The declaration of the `container` grid looks
    like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`videosize`和`textsize` CSS 属性将控制分配给`video`和`text`的列数。`container`网格的声明如下：'
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'These new CSS classes could be combined in the `Course` component to render
    the videos alongside accompanying text descriptions, like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新的 CSS 类可以在`Course`组件中组合使用，以渲染视频和相关的文本描述，如下所示：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To control the sizing inside the course tiles, we will introduce two new variables
    to the theme component: **video size** and **text size**. These two variables
    will be bound in their range by the available columns in the CSS Grid (in this
    case, 12). Additionally. it would make sense that they sum up to the number of
    columns.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制课程瓷砖内的尺寸，我们将向主题组件引入两个新变量：**视频大小**和**文本大小**。这两个变量将绑定在 CSS 网格（在这种情况下，为12）的可用列数范围内。此外，它们相加应该等于列数。
- en: 'The **video size** and **text size** sliders could be implemented as part of
    the theme picker. This would look like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**视频大小**和**文本大小**滑块可以作为主题选择器的一部分来实现。这看起来是这样的：'
- en: '![Figure 5.3 – Using sliders for video and text size'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 – 使用滑块调整视频和文本大小'
- en: '](img/Figure_5.3_B16295.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.3_B16295.jpg)'
- en: Figure 5.3 – Using sliders for video and text size
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 使用滑块调整视频和文本大小
- en: 'For practical purposes, we will bound the `3` and `7` (to allow for a max of
    `5` for **text size**). This should leave sufficient room for both the video and
    the text inside the grid. This simple approach can be implemented via a Material
    Slider, like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际应用，我们将绑定 `3` 和 `7`（以允许最大值为 `5` 的 **文本大小**）。这应该为网格内的视频和文本留下足够的空间。这种简单的方法可以通过
    Material Slider 实现，如下所示：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, the `setSize` callback will update the variable using the theme service
    in the same manner as the other variables – just with the added complexity that
    we have received a `MatSliderChange`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`setSize` 回调将以与其他变量相同的方式使用主题服务更新变量——只是增加了复杂性，因为我们收到了一个 `MatSliderChange`：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Every time we change the value in one of the sliders, the layout of components
    inside the grid could be changed. We should pay attention when including output
    from external components that have their own layout systems (for example, the
    YouTube Player). We will learn about integrating the YouTube Player in the next
    chapter, but for now, let's just settle with a simple `location.reload()`. This
    should illustrate how to force a render of the grid (and all the other components
    too).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们更改其中一个滑块的值时，网格内组件的布局可能会发生变化。在包含具有自己布局系统的外部组件的输出时，我们应该注意（例如，YouTube Player）。我们将在下一章学习如何集成
    YouTube Player，但现在，让我们只满足于简单的 `location.reload()`。这应该可以说明如何强制渲染网格（以及所有其他组件）。
- en: 'Before we leave the topic of using custom CSS properties from Angular, let''s
    remember that we want to support smaller screens as well. It turns out that we
    can introduce an elegant solution by combining custom CSS properties and media
    queries without referring to Angular code, like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开从 Angular 使用自定义 CSS 属性的话题之前，让我们记住，我们还想支持较小的屏幕。实际上，我们可以通过结合自定义 CSS 属性和媒体查询，而不需要引用
    Angular 代码，来引入一个优雅的解决方案，如下所示：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we can see one of the strengths of adding support for using custom CSS
    properties directly from within Angular in the application scope: by using a combination
    of CSS Custom Properties and media queries outside the Angular components, we
    can rely on the expertise of dedicated designers that can work with little or
    no knowledge about Angular code. Additionally, we would also have the option of
    creating integrations that could retrieve theme settings from corporate design
    token systems, without requiring the application to be redeployed when the design
    tokens change.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到直接在应用程序范围内添加对使用自定义 CSS 属性的支持的一个优势：通过结合 CSS 自定义属性和媒体查询，我们可以依赖那些几乎不需要了解
    Angular 代码的专门设计师的专长。此外，我们还可以选择创建可以检索企业设计令牌系统主题设置的集成，而无需在设计令牌更改时重新部署应用程序。
- en: Summary
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you encountered the Angular Academy application for the first
    time and learned how CSS Custom Properties can be used to implement the theme
    picker using a theme service. Along the way, you also had a brief first encounter
    with the YouTube Player in the course list.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您第一次遇到了 Angular Academy 应用程序，并学习了如何使用 CSS 自定义属性通过主题服务实现主题选择器。在这个过程中，您也对课程列表中的
    YouTube Player 有了一个简短的初次接触。
- en: In the next chapter, we will dig deeper into how to use the YouTube Player and
    how you can combine a curriculum of YouTube videos using the Angular components
    you learned about in *Part 1, A Quick and Functional Guide to Angular Ivy*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨如何使用 YouTube Player，以及您如何可以使用在 *第1部分，Angular Ivy 快速实用指南* 中学到的
    Angular 组件组合 YouTube 视频课程。
