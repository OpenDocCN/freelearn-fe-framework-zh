<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Advanced React"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Advanced React</h1></div></div></div><p>In the first part of this chapter, we'll look at<a class="indexterm" id="id428"/> <span class="strong"><strong>Webpack</strong></span>, <a class="indexterm" id="id429"/>
<span class="strong"><strong>Redux</strong></span>, and how to write components with the new class syntax introduced in JavaScript 2015. Writing ReactJS components with the class syntax is a little bit different than using <code class="literal">React.createClass</code>, so we'll be looking at the differences and the pros and cons.</p><p>In the second part of this chapter, we'll write an app that handles authentication using Redux.</p><p>This is what we'll cover in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A new bundling strategy:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How Browserify works</li><li class="listitem" style="list-style-type: disc">How Webpack works</li><li class="listitem" style="list-style-type: disc">A difficult choice</li></ul></div></li><li class="listitem" style="list-style-type: disc">Creating a new scaffold with Webpack<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Babel configuration</li><li class="listitem" style="list-style-type: disc">The Webpack configuration</li><li class="listitem" style="list-style-type: disc">Adding assets</li><li class="listitem" style="list-style-type: disc">Creating an Express server</li><li class="listitem" style="list-style-type: disc">Adding ReactJS to the mix</li><li class="listitem" style="list-style-type: disc">Starting the server</li></ul></div></li><li class="listitem" style="list-style-type: disc">Introducing Redux<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The single store</li><li class="listitem" style="list-style-type: disc">Actions in Redux</li><li class="listitem" style="list-style-type: disc">Understanding reducers</li><li class="listitem" style="list-style-type: disc">Adding Devtools</li></ul></div></li><li class="listitem" style="list-style-type: disc">Create a login API</li></ul></div><div class="section" title="A new bundling strategy"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec26"/>A new bundling strategy</h1></div></div></div><p>Until now, we've been using <a class="indexterm" id="id430"/>Browserify, but from now on, we'll switch to Webpack. You may wonder why we should make this switch and what the differences between the technologies are.</p><p>Let's take a closer look at both of them.</p><div class="section" title="How Browserify works"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec63"/>How Browserify works</h2></div></div></div><p>
<span class="strong"><strong>Browserify</strong></span><a class="indexterm" id="id431"/> works by examining the entry point that you specify and building a dependency tree based on all the files and modules you require in your code. Each dependency gets wrapped in a <code class="literal">closure</code> code, which contains the module's source code, a map of the module's dependencies, and a key. It injects features that are native to the <span class="emphasis"><em>node</em></span> but don't exist in JavaScript, such as <a class="indexterm" id="id432"/>
<span class="strong"><strong>module handling</strong></span>.</p><p>In short, it is able <a class="indexterm" id="id433"/>to analyze your source code, find and wrap up all your dependencies, and compile them into a single bundle. It's very performant and is an excellent start up tool for new projects.</p><p>Using it in practice is as simple as writing a set of code and sending it to Browserify. Let's write two files that require each other.</p><p>Let's call the first one <code class="literal">helloworld.js</code> and place the following code into it:</p><div class="informalexample"><pre class="programlisting">module.exports = function () {
  return 'Hello world!';
}</pre></div><p>Let's call the second one <code class="literal">entry.js</code> and place the following code into it:</p><div class="informalexample"><pre class="programlisting">var Hello = require("./helloworld");
console.log(Hello());</pre></div><p>Then, pass both the files to Browserify from the command line, like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>browserify entry.js</strong></span>
</pre></div><p>The result will be an immediately invoked function expression (IIFE for short) containing your "<code class="literal">hello world</code>" code. An IIFE is also referred to as an anonymous self-executing function or simply a code block that executes as soon as you load it.</p><p>The generated code looks rather incomprehensible, but let's try to understand it:</p><div class="informalexample"><pre class="programlisting">(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" &amp;&amp; require;
        if (!u &amp;&amp; a) return a(o, !0);
        if (i) return i(o, !0);
        var f = new Error("Cannot find module '" + o + "'");
        throw f.code = "MODULE_NOT_FOUND", f
      }
      var l = n[o] = {
        exports: {}
      };
      t[o][0].call(l.exports, function(e) {
        var n = t[o][1][e];
        return s(n ? n : e)
      }, l, l.exports, e, t, n, r)
    }
    return n[o].exports
  }
  var i = typeof require == "function" &amp;&amp; require;
  for (var o = 0; o &lt; r.length; o++) s(r[o]);
  return s
})</pre></div><p>This entire<a class="indexterm" id="id434"/> first block passes the module source and executes it. The first argument takes our source code, the second a cache (usually empty), and the third a key, mapping it to the module it is required from.</p><p>The inner function is an internal <code class="literal">cache</code> function. It's used at the end of the function to either retrieve the function from the cache, or store it so that it's ready the next time it's requested. Here, a required module is listed, along with the entire source code: </p><div class="informalexample"><pre class="programlisting">({
  1: [function(require, module, exports) {
    var Hello = require("./helloworld");
    console.log(Hello());

  }, {
    "./helloworld": 2
  }],
  2: [function(require, module, exports) {
    module.exports = (function() {
      return 'Hello world!';
    })

  }, {}]
}, {}, [1]);</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>Note that this is passed in a parenthesis with three arguments, matching the IIFE function.</p></div></div><p>It's not vital <a class="indexterm" id="id435"/>that you fully understand how this works. The important thing to take away is that Browserify will generate a complete static bundle containing all of your code and will also take care of how they relate to each other.</p><p>So far, Browserify looks fantastic. However, there is a fly in the ointment. If you want to do something more with your code—for instance, minify it or convert <span class="emphasis"><em>JavaScript 2015</em></span> to <span class="emphasis"><em>ECMAScript 5</em></span> or the <span class="emphasis"><em>ReactJS JSX</em></span> code to plain JavaScript—you would need to pass additional transforms to it.</p><p>Browserify has a huge ecosystem of transforms that you can use to transmogrify your code. Knowing how to wire it up is the hard part, and the fact that Browserify itself is not entirely opinionated on the matter means that you are left on your own.</p><p>Let's add a JavaScript 2015 transform to illustrate how you run Browserify with transforms. Change <code class="literal">helloworld.js</code> to this code:</p><div class="informalexample"><pre class="programlisting">import Hello from "./helloworld";
console.log(Hello());</pre></div><p>Running the standard <code class="literal">browserify</code> command now will result in a parse error. Let's try it with the Babel transformer that we've been using in our scaffold:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>browserify entry.js --transform [babelify --presets [es2015]]</strong></span>
</pre></div><p>The code will now parse.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>If you compare the resulting code, you'll notice that the generated JavaScript 2015 code from Babel is rather different from the code Browserify generated using plain ECMAScript 5. It's a little bit bigger (in this example, it's approximately 25 percent larger, but it's a very small sample code set, so the difference won't be as dramatic with a more realistic code set).</p></div></div><p>You can run the code in several ways. You can create an HTML file and reference it in a script tag, or you can simply open a browser and paste it into the console window in Chrome or the Scratchpad in FireFox. The result will be the same in any case; the text <span class="strong"><strong>Hello world!</strong></span> will appear in your console log.</p></div><div class="section" title="How Webpack works"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec64"/>How Webpack works</h2></div></div></div><p>Like <a class="indexterm" id="id436"/>Browserify, Webpack is a module bundler. It's operationally similar to Browserify but is very different under the hood. There are many differences, but the key difference is that Webpack can be used dynamically, while Browserify is strictly static. We'll take a look at how Webpack works and show how this can benefit us greatly while using Webpack to write code.</p><p>As with Browserify, generating code with Webpack is initiated from an <code class="literal">entry</code> file. Let's use the "<code class="literal">Hello World</code>" code from the previous example (the ECMAScript 5 version). Webpack requires you to specify an <code class="literal">output</code> file, so let's write it to <code class="literal">bundle.js</code> like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>webpack helloworld.js --output-filename bundle.js</strong></span>
</pre></div><p>The generated code is a lot more verbose than Browserify by default and is actually quite readable (adding the <code class="literal">-p</code> parameter will generate a minified version).</p><p>Running the<a class="indexterm" id="id437"/> preceding code will result in the following code being generated:</p><div class="informalexample"><pre class="programlisting">(function(modules) { // webpackBootstrap
  var installedModules = {};
  function __webpack_require__(moduleId) {

  if(installedModules[moduleId])
  return installedModules[moduleId].exports;

  var module = installedModules[moduleId] = {
    exports: {},
    id: moduleId,
    loaded: false
  };</pre></div><p>Like Browserify, Webpack generates an IIFE. The first thing it does is set up a module cache and then check whether the module is cached. If not, the module is put into the cache, let's take a look at the following code snippet:</p><div class="informalexample"><pre class="programlisting">  modules[moduleId].call(module.exports, module, module.exports,
    __webpack_require__);
  module.loaded = true;
  return module.exports;
}</pre></div><p>Next, it executes the <code class="literal">module</code> function, flags it as loaded, and returns the exports of the module, let's take a look at the following code snippet:</p><div class="informalexample"><pre class="programlisting">__webpack_require__.m = modules;
__webpack_require__.c = installedModules;
__webpack_require__.p = "";
return __webpack_require__(0);
})</pre></div><p>Then, it exposes the module's object, cache, and the public path and then returns the entry module, let's take a look at the following code snippet:</p><div class="informalexample"><pre class="programlisting">([
  /* 0 */
  /***/ function(module, exports, __webpack_require__) {

  var Hello = __webpack_require__(1);
  console.log(Hello());</pre></div><p>
<code class="literal">Hello</code> is now assigned to <code class="literal">__webpack_require__(1)</code>. The number refers to the next module (since it starts counting at <code class="literal">0</code>). Now refer to the following:</p><div class="informalexample"><pre class="programlisting">  /***/ },
  /* 1 */
  /***/ function(module, exports) {

  module.exports = (function () {
    return 'Hello world!';
    })
  }
]);</pre></div><p>Both module <a class="indexterm" id="id438"/>sources themselves are executed as arguments to the IIFE.</p><p>So far, both Webpack and Browserify look very much alike. They both analyze your entry file and wrap the sources in a self-executable closure. They also include a caching strategy and maintain a relation tree so that it can tell how the module requires one another.</p><p>In fact, just by looking at the generated code, it's hard to see that there's much to separate them, different code styles aside.</p><p>There's a very big difference, however, and that is how Webpack has organized its ecosystem and configuration strategy. While it's true the configuration is convoluted and slightly hard to understand, it's hard to argue against the results you can achieve.</p><p>You can configure Webpack to do (almost) anything you want, including replacing the current code loaded in your browser with the updated code while preserving the state of the app. This is called <span class="strong"><strong>hot module replacement</strong></span><a class="indexterm" id="id439"/> or <span class="strong"><strong>hmr</strong></span> for short.</p><p>Webpack is configured by writing a special configuration file, usually called <a class="indexterm" id="id440"/>
<code class="literal">webpack.config.js</code>. In this file, you specify the entry and output parameters, plugins, module loaders, and various other configuration parameters.</p><p>A very basic <code class="literal">config</code> file looks like this:</p><div class="informalexample"><pre class="programlisting">var webpack = require('webpack');
module.exports = {
  entry: [
    './entry'
  ],
  output: {
    path: './',
    filename: 'bundle.js'
  }
};</pre></div><p>It's executed by<a class="indexterm" id="id441"/> issuing this command from the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>webpack --config webpack.config.js</strong></span>
</pre></div><p>Or simply, without the <code class="literal">config</code> parameters, Webpack will automatically look for the presence of <code class="literal">webpack.config.js</code>.</p><p>In order to convert the <code class="literal">source</code> files before bundling, you use module loaders. Adding this section to the Webpack config file will make sure Babel converts JavaScript 2015 code into ECMAScript 5:</p><div class="informalexample"><pre class="programlisting">module: {
  loaders: [{
    test: /.js?$/',
    loader: 'babel',
    exclude: /node_modules/,
    query: {
      presets: ['es2015','react']
    }
  }]
}</pre></div><p>Let's review the options in detail:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first option (required), <code class="literal">test</code>, is a regex match that tells Webpack which files this loader operates on. The regex tells Webpack to look for files with a <span class="emphasis"><em>period</em></span> followed by the letters <span class="emphasis"><em>js</em></span> and then any optional letters <code class="literal">(?)</code> before the end <code class="literal">($)</code>. This makes sure the loader reads both plain JavaScript files and JSX files.</li><li class="listitem" style="list-style-type: disc">The second option (required), <code class="literal">loader</code>, is the name of the package that we'll use to convert the code.</li><li class="listitem" style="list-style-type: disc">The third option (optional), <code class="literal">exclude</code>, is another regex used to explicitly ignore a set of folders or files.</li><li class="listitem" style="list-style-type: disc">The final option (optional), <code class="literal">query</code>, contains special configuration options for your loader. In our case, it contains options for the Babel loader. For Babel, the recommended way to do it is actually setting them in a special file called <code class="literal">.babelrc</code>. We'll be doing this later in the scaffold that we'll develop.</li></ul></div></div><div class="section" title="A difficult choice – Browserify or Webpack"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec65"/>A difficult choice – Browserify or Webpack</h2></div></div></div><p>Browserify<a class="indexterm" id="id442"/> gets points for being easy to get started with, but loses out<a class="indexterm" id="id443"/> because of the increase in complexity when you need to add transforms and because it's, in general, more limited than Webpack.</p><p>Webpack is harder to grasp initially, but progressively gets more useful as you unravel the complexity. The big upside to using Webpack is its ability to replace code in runtime with its ecosystem of hot reload tools, and the powerful, opinionated way in which it can be extended to suit every need. It's worth noting that there's efforts underway to develop an <code class="literal">hmr</code> module<a class="indexterm" id="id444"/> for Browserify as well. You can preview the project at <a class="ulink" href="https://github.com/AgentME/browserify-hmr">https://github.com/AgentME/browserify-hmr</a>.</p><p>They're both terrific tools, and it's worth learning to use both. For some types of projects, using Browserify makes the most sense, and for others, Webpack is clearly the way to go.</p><p>Moving on, we'll create a new basic setup, a scaffold, which we'll use when developing a login app with Redux later in this chapter.</p><p>This is going to be a lot of fun!</p></div></div></div>
<div class="section" title="Creating a new scaffold with Webpack"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec27"/>Creating a new scaffold with Webpack</h1></div></div></div><p>Create a <a class="indexterm" id="id445"/>new folder and initialize it with <code class="literal">npm init</code> and then add the following dependencies:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm i --save-dev babel-core@6.8.0 babel-loader@6.2.4 babel-plugin-react-transform@2.0.2 babel-preset-es2015@6.6.0 babel-preset-react@6.5.0 react@15.0.2 react-dom@15.0.2 react-transform-catch-errors@1.0.2 react-transform-hmr@1.0.4 redbox-react@1.2.4 webpack@1.13.0 webpack-dev-middleware@1.6.1 webpack-hot-middleware@2.10.0 &amp;&amp; npm i --save express@4.13.4</strong></span>
</pre></div><p>All but one of the dependencies will be saved as <code class="literal">devDependencies</code>. When you perform an <code class="literal">npm install</code> command later, all modules in both the <code class="literal">dependencies</code> section and the <code class="literal">devDependencies</code> section will be installed.</p><p>You can specify which section to install by providing <code class="literal">npm</code> with either the <code class="literal">dev</code> or <code class="literal">production</code> flag. For instance, this will install only the packages in the dependencies section:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install --production</strong></span>
</pre></div><p>Your <code class="literal">package.json</code> file should now look like this:</p><div class="informalexample"><pre class="programlisting">{
  "name": "chapter6",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "babel-core": "^6.8.0",
    "babel-loader": "^6.2.4",
    "babel-plugin-react-transform": "^2.0.2",
    "babel-preset-es2015": "^6.6.0",
    "babel-preset-react": "^6.5.0",
    "react": "^15.0.2",
    "react-dom": "^15.0.2",
    "react-transform-catch-errors": "^1.0.2",
    "react-transform-hmr": "^1.0.4",
    "redbox-react": "^1.2.4",
    "webpack": "^1.13.0",
    "webpack-dev-middleware": "^1.6.1",
    "webpack-hot-middleware": "^2.10.0"
  },
  "dependencies": {
    "express": "^4.13.4"
  }
}</pre></div><div class="section" title="The Babel configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec66"/>The Babel configuration</h2></div></div></div><p>Next, create a<a class="indexterm" id="id446"/> new file, name it <code class="literal">.babelrc</code> (no prefix before the dot), and add the following code to it:</p><div class="informalexample"><pre class="programlisting">{
  "presets": ["react", "es2015"],
  "env": {
    "development": {
      "plugins": [
        ["react-transform", {
          "transforms": [{
            "transform": "react-transform-hmr",
            "imports": ["react"],
            "locals": ["module"]
          }, {
            "transform": "react-transform-catch-errors",
            "imports": ["react", "redbox-react"]
          }]
        }]
      ]
    }
  }
}</pre></div><p>This <code class="literal">configuration</code> <a class="indexterm" id="id447"/>file will be used by Babel to use the presets we just installed (React and ES2015). It will also instruct Babel which transforms we'd like to use. Putting the transforms inside the <code class="literal">env:development</code> file will make sure it won't be accidentally enabled in production.</p></div><div class="section" title="The Webpack configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec67"/>The Webpack configuration</h2></div></div></div><p>Next, let's add the<a class="indexterm" id="id448"/> Webpack configuration module. Create a new file called <code class="literal">webpack.config.js</code> and add this code to it:</p><div class="informalexample"><pre class="programlisting">var path = require('path');
var webpack = require('webpack');

module.exports = {
  devtool: 'cheap-module-eval-source-map',
  entry: [
    'webpack-hot-middleware/client',
    './source/index'
  ],</pre></div><p>This will instruct Webpack to first use the hot module replacement as the initial entry point and then our source root. Now refer to the following:</p><div class="informalexample"><pre class="programlisting">  output: {
    path: path.join(__dirname, 'public'),
    filename: 'bundle.js',
    publicPath: '/assets/'
  },</pre></div><p>We'll set the output path to be the <code class="literal">public</code> folder, meaning that any content that is accessed should reside in this folder. We'll also instruct Webpack to use the <code class="literal">bundle.js</code> filename and specify that it should be accessed from the <code class="literal">assets</code> folder.</p><p>In our <code class="literal">index.html</code> file, we will access the file via a script tag pointing to <code class="literal">assets/bundle.js</code>, but we won't actually put a real <code class="literal">bundle.js</code> file in the <code class="literal">assets</code> folder.</p><p>The hot middleware client will make sure that when we try to access the bundle, the generated bundle will be served instead.</p><p>When we're ready to create the real bundle for production, we'll generate a <code class="literal">bundle.js</code> file with the production <code class="literal">flag</code> parameter and store it in <code class="literal">public/assets/bundle.js</code>:</p><div class="informalexample"><pre class="programlisting">  plugins: [
    new webpack.optimize.OccurenceOrderPlugin(),
    new webpack.NoErrorsPlugin(),
    new webpack.HotModuleReplacementPlugin()
  ],</pre></div><p>We'll use three<a class="indexterm" id="id449"/> plugins. The first one makes sure the modules are loaded in order, the second is to prevent unnecessary error reporting in our console log, and the third one is to enable the hot module loader, such as follows:</p><div class="informalexample"><pre class="programlisting">  module: {
    loaders: [{
      tests: /\.js?$/,
      loaders: ['babel'],
      include: path.join(__dirname, 'source')
    }]
  },</pre></div><p>We'll add the Babel loader so that any JavaScript or JSX file gets transpiled before being bundled:</p><div class="informalexample"><pre class="programlisting">  resolve: {
    extensions: ['', '.js', '.jsx']
  }
};</pre></div><p>And finally, we'll tell Webpack to resolve files that we import regardless of them having the <code class="literal">.js</code> or <code class="literal">.jsx</code> extension. This means that we will not have to write <code class="literal">import foo from 'foo.jsx'</code>, but can write <code class="literal">import foo from 'foo'</code> instead.</p></div><div class="section" title="Adding assets"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec68"/>Adding assets</h2></div></div></div><p>Next, let's add the <code class="literal">assets</code><a class="indexterm" id="id450"/> folder and the files we'll reference there. We'll create it in the <code class="literal">root</code> folder rather than create a <code class="literal">public</code> folder. (We actually won't need to do this at all. This folder is not necessary to create while in development mode).</p><p>Create the folder and add two files: <code class="literal">app.css</code> and <code class="literal">favicon.ico</code>.</p><p>The <code class="literal">favicon.ico</code> is not strictly necessary, so you may choose to drop it. You can probably find one scattered around your computer, or create one by going to favicon<a class="indexterm" id="id451"/> generator sites such as <a class="ulink" href="http://www.favicon.cc">http://www.favicon.cc</a>.</p><p>The reason it's included here is this: if it's not present, you'll see failed requests for the icon in your log every time you reload your site, so it represents log noise that's worth getting rid of.</p><p>Open <code class="literal">assets/app.css</code> and add this code:</p><div class="informalexample"><pre class="programlisting">body {
  font-family: serif;
  padding: 50px;
}</pre></div><p>This simply adds a<a class="indexterm" id="id452"/> general padding of <code class="literal">50</code> pixels around the body.</p><p>Next, we need to add an <code class="literal">index.html</code> file. Create it in the root of your app and add this content:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;ReactJS + Webpack Scaffold&lt;/title&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, 
    initial-scale=1"&gt;
    &lt;link rel="stylesheet" href="app.css"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;&lt;/div&gt;
    &lt;script src="assets/bundle.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div></div><div class="section" title="Creating an Express server"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec69"/>Creating an Express server</h2></div></div></div><p>We also need to create an <a class="indexterm" id="id453"/>Express app to power our development server. Add <code class="literal">server.js</code> to your root folder and then add this code:</p><div class="informalexample"><pre class="programlisting">var path = require('path');</pre></div><p>This module lets us join path strings in a more comfortable and safe manner than concatenating strings. For one, it takes away our worry of knowing whether the directory path has a trailing slash or not.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>You almost always get this wrong on your first try when you're concatenating strings manually.</p></div></div><p>We'll use the Express web server, Webpack, and the Webpack config we just created:</p><div class="informalexample"><pre class="programlisting">var express = require('express');
var webpack = require('webpack');
var config = require('./webpack.config');
var port = process.env.PORT || 8080;</pre></div><p>We'll preset the port we're going to use as <code class="literal">8080</code> unless it's specified as a parameter to the node. To specify parameters, such as the port, start the server in a way that it would look like <code class="literal">PORT=8081 node server.js</code>:</p><div class="informalexample"><pre class="programlisting">var app = express();
var compiler = webpack(config);</pre></div><p>We'll create a local variable called <code class="literal">app</code> and point it to a new instance of the <span class="emphasis"><em>Express</em></span> web server. We'll also create another variable called <code class="literal">compiler</code> that will configure <span class="emphasis"><em>Webpack</em></span> to use our <code class="literal">config</code> file. This is equivalent to starting Webpack from the command line with <code class="literal">webpack –config webpack.config.js</code>:</p><div class="informalexample"><pre class="programlisting">app.use('/', express.static(path.join(__dirname, 'assets')));</pre></div><p>We'll define the <code class="literal">assets</code> folder as a <code class="literal">static</code> folder in Express. This is built-in middleware that configures Express to<a class="indexterm" id="id454"/> look for files in the provided folders. Middleware is software that serves to glue applications together or provide additional functionality. The static middleware lets us reference <code class="literal">app.css</code> directly in the link tag in our <code class="literal">index.html</code> file rather than referencing the <code class="literal">assets</code> folder:</p><div class="informalexample"><pre class="programlisting">app.use(require('webpack-dev-middleware')(compiler, {
  quiet: true,
  noInfo: true,
  publicPath: config.output.publicPath
}));</pre></div><p>We'll tell <span class="emphasis"><em>Express</em></span> to use <code class="literal">webpack-dev-middleware</code> with the <code class="literal">compiler</code> variable, along with some extra instructions (<code class="literal">noInfo</code> will prevent the console log from showing the Webpack compile information every time it recompiles; <code class="literal">publicPath</code> instructs the middleware to use the path we defined in our <code class="literal">config</code> file, and <code class="literal">quiet</code> hushes up any other debug that <code class="literal">noInfo</code> covers):</p><div class="informalexample"><pre class="programlisting">app.use(require("webpack-hot-middleware")(compiler, {
  log: console.log,
  path: '/__webpack_hmr',
  heartbeat: 10 * 1000
}));</pre></div><p>This instructs <span class="emphasis"><em>Express</em></span> to use the <code class="literal">hot</code> <code class="literal">middleware</code> package (while the previous one told it to use the <code class="literal">dev</code> middleware). The <code class="literal">dev</code> middleware is a wrapper for Webpack that serves the files emitted from Webpack in memory rather than bundling them as files. When we couple this with the <code class="literal">hot middleware</code> package, we gain the ability to have any code changes reloaded and executed in the browser. The <code class="literal">heartbeat</code> parameter tells the middleware how often it should update. </p><p>You can adjust the heartbeat to update more often, but the number chosen works rather well:</p><div class="informalexample"><pre class="programlisting">app.get('*', function(req, res) {
  res.sendFile(path.join(__dirname, 'index.html'));
});</pre></div><p>This section routes every request to the Express app to our root folder:</p><div class="informalexample"><pre class="programlisting">app.listen(port, 'localhost', function(err) {
  if (err) {
    console.log(err);
    return;
  }</pre></div><p>Finally, we start the app on the chosen port:</p><div class="informalexample"><pre class="programlisting">  console.log('Listening at http://localhost:'+port);
});</pre></div><p>The server is now<a class="indexterm" id="id455"/> ready. All you need to complete your setup now is add a ReactJS component. We'll use the new ES6 class-based syntax rather than the <code class="literal">createClass</code> syntax we've used until now.</p></div><div class="section" title="Adding ReactJS to the mix"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec70"/>Adding ReactJS to the mix</h2></div></div></div><p>Add a new folder<a class="indexterm" id="id456"/> called <code class="literal">source</code>
and add a file called <code class="literal">index.jsx</code>. Then, add this code:</p><div class="informalexample"><pre class="programlisting">'use strict';
import React, { Component, PropTypes } from 'react';
import { render } from 'react-dom';

class App extends Component {
  render() {
    return &lt;div&gt;
      &lt;h1&gt;ReactJS Blueprints Chapter 6 Webpack scaffold&lt;/h1&gt;
      &lt;div&gt;
        To use:
        &lt;p&gt;
          1. Run &lt;strong&gt;npm i&lt;/strong&gt; to install
        &lt;/p&gt;
        &lt;p&gt;
          2. Run &lt;strong&gt;npm start&lt;/strong&gt; to run dev server
        &lt;/p&gt;
        &lt;p&gt;
          3. View results in &lt;strong&gt;http://localhost:8080/
          &lt;/strong&gt;
        &lt;/p&gt;
        &lt;p&gt;
          4. Success
        &lt;/p&gt;
      &lt;/div&gt;

    &lt;/div&gt;
  }</pre></div><p>The <code class="literal">render</code> function looks the same as before.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>Note that we've also not used commas anymore to separate our functions. They aren't necessary within a class.</p></div></div><p>Let's take a look at the following code snippet:</p><div class="informalexample"><pre class="programlisting">}

render(
  &lt;App /&gt;,
  document.getElementById('app')
);</pre></div><p>The last function call is <a class="indexterm" id="id457"/>made to<a class="indexterm" id="id458"/> react-dom <code class="literal">render</code>, which takes care of populating the document container with the <code class="literal">app</code> ID along with the contents of our source file.</p></div><div class="section" title="Starting the server"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec71"/>Starting the server</h2></div></div></div><p>We're ready to run our <a class="indexterm" id="id459"/>server and be able to see the results for the first time. Start the app by executing <code class="literal">node server.js</code> in your terminal and open <code class="literal">http://localhost:8080</code> in your browser:</p><div class="mediaobject"><img alt="Starting the server" src="graphics/B04943_06_01.jpg"/></div><p>You should now be<a class="indexterm" id="id460"/> greeted with the intro text you added to <code class="literal">source/index.jsx</code>.</p><p>Congratulations! You've completed all the steps necessary to get going with Webpack and hot reload.</p><p>Granted, this setup is a bit more complex as compared to the <code class="literal">Browserify</code> setup, but the benefits of increased complexity will be apparent to you as you go ahead and make modifications to your source files; you'll be able to see the changes being updated in your browser as soon as you hit the <span class="strong"><strong>Save</strong></span> button.</p><p>This is superior to the way we did it before because the app is able to keep the state of the app intact, even while reloading changes in your code. This means that when you're developing a complex app, you don't need to reiterate a lot of state changes to reach some code that you changed. This is guaranteed to save you a lot of time and frustration in the long run.</p></div></div>
<div class="section" title="Introducing Redux"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec28"/>Introducing Redux</h1></div></div></div><p>Until now, we've used<a class="indexterm" id="id461"/> <span class="strong"><strong>Reflux</strong></span> to handle store and state interaction, but moving forward, we'll use a<a class="indexterm" id="id462"/> different implementation of the <a class="indexterm" id="id463"/>
<span class="emphasis"><em>Flux</em></span> architecture. It's called <span class="strong"><strong>Redux</strong></span> and is quickly gaining traction as a superior <span class="emphasis"><em>Flux</em></span> implementation.</p><p>It's also infamous for being hard to understand, throwing both newcomers and experienced developers off-kilter with its duality of simplicity and complexity. This is partly because it's purely a functional approach to <span class="emphasis"><em>Flux</em></span>.</p><p>When ReactJS was first introduced to the public in late 2013 / early 2014, you would often hear it mentioned together with functional programming.</p><p>However, there's no <a class="indexterm" id="id464"/>inherent requirement to write functional code when writing React, and JavaScript itself being a multi-paradigm language is neither strictly functional nor strictly procedural, imperative, or even object-oriented.</p><p>There are a number of benefits to choosing a<a class="indexterm" id="id465"/> functional approach:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">No side-effects allowed, that is, the operation is stateless</li><li class="listitem" style="list-style-type: disc">Always returns the same output for a given input</li><li class="listitem" style="list-style-type: disc">Ideal for creating recursive operations</li><li class="listitem" style="list-style-type: disc">Ideal for parallel execution</li><li class="listitem" style="list-style-type: disc">Easy to establish the single source of truth</li><li class="listitem" style="list-style-type: disc">Easy to debug</li><li class="listitem" style="list-style-type: disc">Easy to persist the store state for a faster development cycle</li><li class="listitem" style="list-style-type: disc">Easy to create functionalities, such as undo and redo</li><li class="listitem" style="list-style-type: disc">Easy to inject a store state for server rendering</li></ul></div><p>The concept of stateless operations is possibly the number one benefit, as it makes it very easy to reason the state of your application. We already used this approach with the <span class="emphasis"><em>Reflux</em></span> example in our first app in <a class="link" href="ch02.html" title="Chapter 2. Creating a Web Shop">Chapter 2</a>, <span class="emphasis"><em>Creating a Web Shop</em></span>, where the store state was only changed in the main app and then propagated downward to all the app's children. This is, however, not the idiomatic <span class="emphasis"><em>Reflux</em></span> approach, because it's actually designed to create many stores and have the children listen to changes separately.</p><p>The application state is the single hardest part of any application, and every single implementation of <span class="emphasis"><em>Flux</em></span> has attempted to solve this problem. <span class="emphasis"><em>Redux</em></span> solves it by not actually doing <span class="emphasis"><em>Flux</em></span> at all; it actually uses an amalgamation of the ideas of <span class="emphasis"><em>Flux</em></span> and the functional <a class="indexterm" id="id466"/>programming language, <span class="strong"><strong>Elm</strong></span>.</p><p>There are three parts to <span class="emphasis"><em>Redux</em></span>: <span class="strong"><strong>actions</strong></span>, <span class="strong"><strong>reducers</strong></span>, and <span class="strong"><strong>the global store</strong></span>.</p><div class="section" title="The global store"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec72"/>The global store</h2></div></div></div><p>In <span class="emphasis"><em>Redux</em></span>, there is<a class="indexterm" id="id467"/> only one <a class="indexterm" id="id468"/>global store. It is an object that holds the state of your entire application. You create a store by passing your <code class="literal">root-reducing</code>
function<a class="indexterm" id="id469"/> (or reducer for short) to a method called <code class="literal">createStore</code>.</p><p>Rather than creating more stores, you use a concept called <span class="strong"><strong>reducer composition</strong></span><a class="indexterm" id="id470"/> to split data-handling logic. You will then need to use a function called <code class="literal">combineReducers</code> to create a single root reducer.</p><p>The <code class="literal">createStore</code> function is derived from <a class="indexterm" id="id471"/>Redux and is usually called once in the root of your app (or your <code class="literal">store</code> file). It is then passed on to your app and then propagated to the app's children.</p><p>The only way to<a class="indexterm" id="id472"/> change the state of the store is to dispatch an action to it. This is not the same as a Flux dispatcher, because Redux doesn't have one. You can also subscribe to changes from the store in order to update your components when the store changes state.</p></div><div class="section" title="Understanding actions"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec73"/>Understanding actions</h2></div></div></div><p>An action <a class="indexterm" id="id473"/>is an object that represents an intention to change the state. It must have a type field that indicates what kind of action is being performed. They can be defined as constants and<a class="indexterm" id="id474"/> imported from other modules.</p><p>Apart from this requirement, designing the structure of an object is entirely up to you.</p><p>A basic action object can look like this:</p><div class="informalexample"><pre class="programlisting">{
  type: 'UPDATE',
  payload: {
    value: "some value"
  }
}</pre></div><p>The <code class="literal">payload</code> property is optional and can work like objects we discussed earlier or any other valid JavaScript type, such as a function or primitive.</p></div><div class="section" title="Understanding reducers"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec74"/>Understanding reducers</h2></div></div></div><p>A <span class="strong"><strong>reducer</strong></span> is a<a class="indexterm" id="id475"/> function that accepts<a class="indexterm" id="id476"/> an accumulation along with a value and returns a new accumulation. In other words, it returns the next state based on the previous state and an action.</p><p>It must be a pure function, free of side effects, and it does not mutate the existing state.</p><p>For smaller apps, it's okay to start with a single reducer, but as your app grows, you split off smaller reducers that manage specific parts of your state tree.</p><p>This is what's called <span class="strong"><strong>reducer composition</strong></span><a class="indexterm" id="id477"/> and is the fundamental pattern of building apps with Redux.</p><p>You start with a single reducer, but as your app grows, you need to split it off into smaller reducers that manage specific parts of the state tree. Because reducers are just functions, you can control the order in which they are called, pass additional data, or even make reusable reducers for <a class="indexterm" id="id478"/>common tasks such as pagination.</p><p>It's okay to have many <a class="indexterm" id="id479"/>reducers. In fact, it's encouraged.</p></div><div class="section" title="Installing Redux"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec75"/>Installing Redux</h2></div></div></div><p>Let's add<a class="indexterm" id="id480"/> <span class="emphasis"><em>Redux</em></span> to our scaffold and see how it works. You only need two packages when getting started with redux: <code class="literal">redux</code> and <code class="literal">react-redux</code>. We'll add a few more to our app that will help us debug when we are developing the app. First, install these dependencies:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install --save-dev redux@3.5.2 redux-devtools@3.3.1 react-redux@4.4.5 redux-thunk@2.1.0 isomorphic-fetch@2.2.0 react-bootstrap@0.29.4 redux-devtools-dock-monitor@1.1.1 redux-devtools-log-monitor@1.0.11</strong></span>
</pre></div><p>When this is done, the <code class="literal">devDepencies</code> section of your <code class="literal">package.json</code> file should have these packages:</p><div class="informalexample"><pre class="programlisting">"devDependencies": {
  "react-redux": "^4.4.5",
  "redux": "^3.5.2",
  "redux-thunk": "^2.1.0",
  "redux-devtools": "^3.3.1",
  "isomorphic-fetch": "^2.2.0",
  "react-bootstrap": "^0.29.4",
  "redux-devtools-dock-monitor": "^1.1.1",
  "redux-devtools-log-monitor": "^1.0.11"
}</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>It's worth noting that new versions get released all the time, so it's good to make sure you have the same version numbers that were current when these examples were written. You can install the exact version numbers when you install packages by adding the version number to the <code class="literal">install</code> command, like we've done in the preceding code snippet.</p></div></div></div></div>
<div class="section" title="Creating a login app"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec29"/>Creating a login app</h1></div></div></div><p>Now that we've made a<a class="indexterm" id="id481"/> new scaffold based on Webpack and added Redux to the mix, let's go ahead and make an app that handles authentication using the new libraries.</p><div class="section" title="Creating an action"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec76"/>Creating an action</h2></div></div></div><p>We're going to start by adding an <a class="indexterm" id="id482"/>action. The app we'll be making is a login app, where you'll be prompted for a username and password upon entry.</p><p>Let's start by making a folder structure separating the functionality. Create a folder called <code class="literal">actions</code> within the <code class="literal">source</code>
folder and add a file called <code class="literal">login.js</code>; then, add this code:</p><div class="informalexample"><pre class="programlisting">'use strict';
import fetch from 'isomorphic-fetch';</pre></div><p>
<code class="literal">Fetch</code> is a new interface for fetching resources. It will be recognizable if you've used <code class="literal">XMLHttpRequest</code>
in the past or<a class="indexterm" id="id483"/> <span class="strong"><strong>Superagent</strong></span> with <span class="strong"><strong>Promises</strong></span><a class="indexterm" id="id484"/>, as we've used in previous chapters. The new API supports Promises out of the box, supporting a generic definition of Request <a class="indexterm" id="id485"/>and Response<a class="indexterm" id="id486"/> objects. It also provides a definition for concepts such as <a class="indexterm" id="id487"/>
<span class="strong"><strong>Cross-Origin Resource Sharing</strong></span> (<span class="strong"><strong>CORS</strong></span>) and HTTP Origin header semantics.</p><p>We could have used <code class="literal">Fetch</code> right out of the box with Babel, but this package is preferable because it adds <code class="literal">Fetch</code> as a global function that has a consistent API for use in both server and client code. This will be in a later chapter where we'll create an isomorphic app. Consider the following code:</p><div class="informalexample"><pre class="programlisting">export const LOGIN_USER = 'LOGIN_USER';</pre></div><p>This defines a single action constant that we can use when we want to dispatch the action. Now check this out:</p><div class="informalexample"><pre class="programlisting">export function login(userData) {</pre></div><p>With this, we create and export a single function called <code class="literal">login</code> that accepts a <code class="literal">userData</code> object. Now we'll create a <code class="literal">body</code> variable that holds the username and password:</p><div class="informalexample"><pre class="programlisting">  const body = { username: userData.username,
    password: userData.password };</pre></div><p>This is not strictly necessary as we can easily pass the <code class="literal">userData</code> object along, but the idea is that by making it explicit, we're sending a username and password and nothing else. This will be easy to understand when you look at the next chunk of code:</p><div class="informalexample"><pre class="programlisting">  const options = {headers: {
    'Accept': 'application/json',
    'Content-Type': 'application/json',
    'Authorization': 'Bearer 1234567890'
  },
  method: 'post',
  body: JSON.stringify(body)
}</pre></div><p>We will send the <code class="literal">POST</code> request with an <code class="literal">Accept</code> header and <code class="literal">Content-Type</code>, both specifying that we're working with JSON data. We'll also send an authorization header with a bearer token.</p><p>You have seen this bearer token before, in <a class="link" href="ch04.html" title="Chapter 4. Building a Real-Time Search App">Chapter 4</a>, <span class="emphasis"><em>Building a Real-Time Search App</em></span>. The API that we're going to reference is very similar to the one we built then. We'll look at the API as soon as we're finished with the frontend code.</p><p>The body is passed through the <code class="literal">JSON.stringify()</code> method because we can't send a raw JavaScript object through HTTP. The method converts an object to a proper JSON representation, optionally replacing values<a class="indexterm" id="id488"/> if a replacer function is specified. Check this out:</p><div class="informalexample"><pre class="programlisting">  return dispatch =&gt; {
    return fetch(`http://reactjsblueprints-useradmin.herokuapp.com/v1/login`, options)
      .then(response =&gt; response.json())
    .then(json =&gt; dispatch(setLoginDetails(json)))
  }
}</pre></div><p>This is the <code class="literal">return</code> section of our <code class="literal">login</code> function. It first connects to our login API through the <code class="literal">fetch</code> function, which returns a <code class="literal">Promise</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>Notice that we're using the new backticks available through JavaScript 2015.</p></div></div><p>When the Promise is resolved, we fetch the JSON response from the object through the <code class="literal">native json()</code> method available with the fetch API. Finally, we return the JSON data through a dispatch to an internal function called <code class="literal">setLoginDetails</code>:</p><div class="informalexample"><pre class="programlisting">function setLoginDetails(json) {
  if(json.length === 0 ) {
    return {
      type: LOGIN_FAIL,
      timestamp: Date.now()
    }
  }
  return {
    type: LOGIN_USER,
    loginResponse: json,
    timestamp: Date.now()
  }
}</pre></div><p>If <code class="literal">json</code> contains a valid response, <code class="literal">setLoginDetails</code> returns an <code class="literal">action</code> object with a type that maps to the <code class="literal">LOGIN_USER</code> string value and two custom values. Remember that an action must always return a <code class="literal">type</code> and that anything else it returns is optional and up to you. If the <code class="literal">json</code> parameter is empty, the<a class="indexterm" id="id489"/> function returns <code class="literal">LOGIN_FAIL</code>.</p></div><div class="section" title="Creating a reducer"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec77"/>Creating a reducer</h2></div></div></div><p>The next file we're<a class="indexterm" id="id490"/> going to add is a <code class="literal">reducer</code>. We'll put it in a folder of its own. So create a folder called <code class="literal">reducers</code> within <code class="literal">source</code> and add a file called <code class="literal">login.js</code> (same as the action), then add this code:</p><div class="informalexample"><pre class="programlisting">'use strict';
import {
  LOGIN_USER,
  LOGIN_FAIL
} from '../actions/login';
import { combineReducers } from 'redux'</pre></div><p>We'll import the file we just created as well as the <code class="literal">combineReducer()</code> method from Redux. We'll only create one reducer for now, but I like to add it from the start since it's typical to add more reducers as the app grows. It generally makes sense to have a <code class="literal">root</code> file to combine reducers as the number of your reducers grow. Next, we'll declare a function that expects a <code class="literal">state</code> object and <code class="literal">action</code> as its arguments:</p><div class="informalexample"><pre class="programlisting">function user(state = {
  message: "",
  userData: {}
}, action){</pre></div><p>When <code class="literal">action.type</code> returns a successful state, we return the state and add or update the <code class="literal">userData</code> and <code class="literal">timestamp</code> parameters:</p><div class="informalexample"><pre class="programlisting">switch(action.type) {
  case LOGIN_USER:
    return {
      ...state,
      userData: action.loginResponse[0],
      timestamp: action.timestamp
    };</pre></div><p>Note that in order to use the spread operator in our reducer, we need to add a new preset to our <code class="literal">.babelrc</code> configuration. This is not part of EcmaScript 6 but is proposed as an extension to the language. Open up your terminal and run this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install –save-dev babel-preset-stage-2</strong></span>
</pre></div><p>Next, modify the presets section in <code class="literal">.babelrc</code> so that it looks like this:</p><div class="informalexample"><pre class="programlisting">"presets": ["react", "es2015", "stage-2"]</pre></div><p>We'll also add a <span class="emphasis"><em>case</em></span> in case there is a failure to log the user in:</p><div class="informalexample"><pre class="programlisting">    case LOGIN_FAIL:
      return {
        ...state,
        userData: [],
        error: "Invalid login",
        timestamp: action.timestamp
      };</pre></div><p>Finally, we'll add a <span class="emphasis"><em>default case</em></span>. It's <a class="indexterm" id="id491"/>not strictly necessary, but it's generally prudent to handle any unforeseen cases like this:</p><div class="informalexample"><pre class="programlisting">      default:
        return state
  }
}

const rootReducer = combineReducers({user});

export default rootReducer</pre></div></div><div class="section" title="Creating a store"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec78"/>Creating a store</h2></div></div></div><p>The next file we're going to add is<a class="indexterm" id="id492"/> a store. Create a folder called <code class="literal">stores</code> within your <code class="literal">source</code> folder, add the <code class="literal">store.js</code> file, and then add this code:</p><div class="informalexample"><pre class="programlisting">'use strict';
import rootReducer from '../reducers/login';</pre></div><p>We'll import the <code class="literal">reducer</code> we just created:</p><div class="informalexample"><pre class="programlisting">import { persistState } from 'redux-devtools';
import { compose, createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';
import DevTools from '../devtools';</pre></div><p>We'll need a few methods from Redux. The <code class="literal">devtools</code> package is needed for development only and must be removed when going to production.</p><p>In computer science, <code class="literal">thunk</code> is an anonymous expression that has no parameters of its own wrapped in an argument expression. A <code class="literal">redux-thunk</code> package lets you write action creators that return a function instead of an action. The <code class="literal">thunk</code> package can be used to delay the dispatch of an action, or to dispatch only if a certain condition is met. The inner function receives the store methods dispatch and <code class="literal">getState()</code> as parameters.</p><p>We'll use this to send an asynchronous dispatch to our login API:</p><div class="informalexample"><pre class="programlisting">const configureStore = compose(
  applyMiddleware(thunk),
  DevTools.instrument()
)(createStore);
const store = configureStore(rootReducer);

export default store;</pre></div></div><div class="section" title="Adding devtools"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec79"/>Adding devtools</h2></div></div></div><p>Devtools are the <a class="indexterm" id="id493"/>primary way you will work with the state in your app. We'll install the default log and dock monitors, but you may develop your own if they don't suit you.</p><p>Add a file called <code class="literal">devtools.js</code> to your <code class="literal">source</code> folder and add this code:</p><div class="informalexample"><pre class="programlisting">'use strict';
import React from 'react';

import { createDevTools } from 'redux-devtools';

import LogMonitor from 'redux-devtools-log-monitor';
import DockMonitor from 'redux-devtools-dock-monitor';</pre></div><p>
<code class="literal">Monitors</code> are separate packages, and you can make custom ones, let's take a look at the following code:</p><div class="informalexample"><pre class="programlisting">const DevTools = createDevTools(</pre></div><p>
<span class="strong"><strong>Monitors</strong></span> are individually adjustable with props. Take a look at the source code for the devtools to learn more about how they're built. Here, we put <code class="literal">LogMonitor</code> inside a <code class="literal">DockMonitor</code> class:</p><div class="informalexample"><pre class="programlisting">  &lt;DockMonitor toggleVisibilityKey='ctrl-h'
    changePositionKey='ctrl-q'&gt;
    &lt;LogMonitor theme='tomorrow' /&gt;
  &lt;/DockMonitor&gt;
);

export default DevTools;</pre></div></div><div class="section" title="Tying the files together"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec80"/>Tying the files together</h2></div></div></div><p>It's time to tie the app<a class="indexterm" id="id494"/> together. Open <code class="literal">index.jsx</code> and replace the existing content with this code:</p><div class="informalexample"><pre class="programlisting">import React, { Component, PropTypes } from 'react'
import { Grid, Row, Col, Button, Input } from 'react-bootstrap';
import { render, findDOMNode } from 'react-dom';
import store from './stores/store';
import { login } from './actions/login'
import { Provider } from 'react-redux'
import { connect } from 'react-redux'
import DevTools from './devtools';</pre></div><p>This adds all the files we created and the methods we needed from ReactJS. Now refer to the following code:</p><div class="informalexample"><pre class="programlisting">class App extends Component {

  handleSelect() {
    const { dispatch } = this.props;
    dispatch(
    login(
    {
      username: findDOMNode(this.refs.username).value,
      password: findDOMNode(this.refs.password).value
    }))
  }</pre></div><p>This function dispatches <a class="indexterm" id="id495"/>the <code class="literal">login</code> action we defined in <code class="literal">actions/login.js</code> with the contents of the <code class="literal">username</code> and <code class="literal">password</code> input fields defined in the <code class="literal">render()</code> method, as follows:</p><div class="informalexample"><pre class="programlisting">  renderWelcomeMessage() {
    const { user } = this.props;
    let response;
    if(user.userData.name) {
      response = "Welcome "+user.userData.name;
    }
    else {
      response = user.error;
    }
    return (&lt;div&gt;
      { response }
      &lt;/div&gt;);
  }</pre></div><p>This is a small piece of JSX code that we use to display either a welcome message or an error message after a login attempt. Now check out the following code:</p><div class="informalexample"><pre class="programlisting">  renderInput() {
    return &lt;form&gt;
      &lt;div&gt;
        &lt;FormGroup&gt;
          &lt;ControlLabel&gt;Username&lt;/ControlLabel&gt;
          &lt;FormControl type= "text"
            ref = "username"
            placeholder= "username"
          /&gt;
        &lt;FormControl.Feedback /&gt;
        &lt;/FormGroup&gt;
      &lt;/div&gt;

      &lt;div&gt;
        &lt;FormGroup&gt;
          &lt;ControlLabel&gt;Password&lt;/ControlLabel&gt;
          &lt;FormControl type= "password"
            ref = "password"
            placeholder= "password"
          /&gt;
          &lt;FormControl.Feedback /&gt;
        &lt;/FormGroup&gt;
      &lt;/div&gt;

      &lt;Button onClick={this.handleSelect.bind(this)}&gt;Log in&lt;/Button&gt;
    &lt;/form&gt;)
  }</pre></div><p>These are the input fields<a class="indexterm" id="id496"/> for logging in a user.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>Note that we must bind the context ourselves with <code class="literal">.bind(this)</code>.</p></div></div><p>With <code class="literal">createClass</code>, binds were created automatically, but no such magic exists when you use JavaScript 2015 classes. The next iteration of JavaScript may bring a proposed new syntactic sugar for bind (<code class="literal">::</code>), which means that we could have used <code class="literal">this.handleSelect</code> without explicitly binding it, but it's still a way off from being implemented:</p><div class="informalexample"><pre class="programlisting">  render () {
    const { user } = this.props;
    return (
      &lt;Grid&gt;
        &lt;DevTools store={store} /&gt;
        &lt;Row&gt;
          &lt;Col xs={ 12 }&gt;
            &lt;h3&gt; Please log in &lt;/h3&gt;
          &lt;/Col&gt;

          &lt;Col xs={ 12 }&gt;
            { this.renderInput() }
          &lt;/Col&gt;

          &lt;Col xs={ 12 }&gt;
            { this.renderWelcomeMessage() }
          &lt;/Col&gt;
        &lt;/Row&gt;
      &lt;/Grid&gt;
    );
  }
};</pre></div><p>This <code class="literal">render</code> block simply<a class="indexterm" id="id497"/> presents the visitor with the option to log in. The app will attempt to log in when the user clicks on <span class="emphasis"><em>Enter</em></span>, and it will either present the visitor with a welcome message or the <span class="strong"><strong>invalid login</strong></span> message.</p><p>This function converts the app state to a set of properties that we can pass to the children components:</p><div class="informalexample"><pre class="programlisting">function mapStateToProps(state) {
  const { user } = state;
  const {
    message
  } = user || {
    message: ""
  }

  return {
    user
  }
}</pre></div><p>This is where we define the app with the Redux <code class="literal">connect()</code> method, which connects a React component to a Redux store. Rather than modifying the component in place, it returns a new <code class="literal">component</code> class that we can render:</p><div class="informalexample"><pre class="programlisting">const LoginApp = connect(mapStateToProps)(App);</pre></div><p>We create a new component class that wraps the <code class="literal">LoginApp</code> component inside a <code class="literal">Provider</code> component:</p><div class="informalexample"><pre class="programlisting">class Root extends Component {
  render() {
    return (
      &lt;Provider store={store}&gt;
        &lt;LoginApp /&gt;
      &lt;/Provider&gt;
    )
  }
}</pre></div><p>The <code class="literal">Provider</code> component is special because it is responsible for passing the store as a property to the children components. It's recommended that you create a <code class="literal">root</code> component wrapping the app inside <code class="literal">Provider</code>, unless you want to manually pass the store yourself to all children components. Finally, we pass the <code class="literal">Root</code> component to render it and to ask it to display the contents<a class="indexterm" id="id498"/> inside <code class="literal">div</code> with the ID
<code class="literal">App</code> in <code class="literal">index.html</code>:</p><div class="informalexample"><pre class="programlisting">render(
  &lt;Root /&gt;,
  document.getElementById('app')
);</pre></div><p>The result of doing this is illustrated in the following screenshot:</p><div class="mediaobject"><img alt="Tying the files together" src="graphics/B04943_06_02.jpg"/></div><p>The app itself looks very unassuming, but it's worth looking at the devtools to the right of the screen. This is the <span class="emphasis"><em>Redux dev tools</em></span>, and it tells you that you have an app state with a user object with two keys. If you click on <span class="strong"><strong>user</strong></span>, it will open and show you that it consists of an object with an empty <code class="literal">message</code> string and an empty <code class="literal">userData</code> object.</p><p>This is exactly how we configured it in <code class="literal">source/index.jsx</code>, so if you see this, it's working as expected.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>Try to log in by typing in a username and password. Hint: the combo <span class="emphasis"><em>darth/vader</em></span> or <span class="emphasis"><em>john/sarah</em></span> will let you log in.</p></div></div><p>Notice that you can now instantly navigate through your app state by clicking on the action buttons in your developer toolbar.</p></div><div class="section" title="Handling refresh"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec81"/>Handling refresh</h2></div></div></div><p>Your app is ready<a class="indexterm" id="id499"/> and you're able to log in, but if you refresh, your login information is gone.</p><p>While it'd be nice if your users never refreshed your page after login, it's not feasible to expect this behavior from your users, and you'd surely be left with users either complaining or leaving your site and never coming back.</p><p>What we need to do is find a way to inject the previous state in our stores upon initializing. Fortunately, this is not very hard; we just need a secure place to store the data that we want to survive a refresh.</p><p>To this end, we'll use <code class="literal">sessionStorage</code>. It is similar to <code class="literal">localStorage</code>, the only difference being that while data stored in <code class="literal">localStorage</code> has no expiration set, any data stored in <code class="literal">sessionStorage</code> gets cleared when the page session ends.</p><p>A session lasts for as long as the browser window is open and it survives page reloads and restores.</p><p>It doesn't support opening the same page in a new tab or a window, which is the main difference between this and, for instance, session cookies.</p><p>The first thing we'll do is change <code class="literal">actions/login.js</code> and modify the function <code class="literal">setLoginDetails</code>. Replace the function with this code (and note that now we will export it):</p><div class="informalexample"><pre class="programlisting">export function setLoginDetails(json) {
  const loginData = {
    type: LOGIN_USER,
    loginResponse: json,
    timestamp: Date.now()
  };
  sessionStorage.setItem('login',JSON.stringify(loginData));
  return loginData;
}</pre></div><p>We'll then enter <code class="literal">index.jsx</code> and add the function to our imports. Add it to the line with imports from <code class="literal">actions/login</code> like this:</p><div class="informalexample"><pre class="programlisting">import { login, setLoginDetails } from './actions/login'</pre></div><p>And then, we'll add a new function within the <code class="literal">App</code> class:</p><div class="informalexample"><pre class="programlisting">componentWillMount() {
  const { dispatch, } = this.props;
  let storedSessionLogin = sessionStorage.getItem('login');
  if(storedSessionLogin){
    dispatch(
      setLoginDetails(
        JSON.parse(storedSessionLogin).loginResponse)
      );
    }
  }</pre></div><p>Before the component mounts, it will check whether there's a stored entry inside <code class="literal">sessionStorage</code> that holds the user info. If there is, it will dispatch an action call to <code class="literal">setLoginDetails</code>, which will simply set the state to logged in and display the familiar welcome message.</p><p>And that's all you need to do.</p><p>There are other <a class="indexterm" id="id500"/>ways to inject a state than by simply dispatching actions. You could do it in the <code class="literal">mapStateToProps</code> function and set an initial state based on <code class="literal">sessionStorage</code>, session cookies, or some other source of data (we'll come back to this when making an isomorphic app).</p></div></div>
<div class="section" title="The Login API"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec30"/>The Login API</h1></div></div></div><p>In the <a class="indexterm" id="id501"/>app we just created, we logged in to an existing API. You may wonder how the API is constructed, so let's take a look at it.</p><p>To create the API, start a new project and execute <code class="literal">npm init</code> to create an empty <code class="literal">package.json</code> file. Then, install the following packages:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install --save body-parser@1.14.1 cors@2.7.1 crypto@0.0.3 express@4.13.3 mongoose@@4.3.0 passport@0.3.2 passport-http-bearer@1.0.1</strong></span>
</pre></div><p>Your <code class="literal">package.json</code> file should now look like this:</p><div class="informalexample"><pre class="programlisting">{
  "name": "chapter6_login_api",
  "version": "1.0.0",
  "description": "Login API for Chapter 6 ReactJS Blueprints",
  "main": "index.js",
  "dependencies": {
    "body-parser": "^1.14.1",
    "cors": "^2.7.1",
    "crypto": "0.0.3",
    "express": "^4.13.3",
    "mongoose": "^4.3.0",
    "passport": "^0.3.2",
    "passport-http-bearer": "^1.0.1"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\"  "
  },
  "author": "Your name &lt;your@email&gt;",
  "license": "ISC"
}</pre></div><p>We'll use <span class="strong"><strong>3</strong></span> to<a class="indexterm" id="id502"/> hold our user data as we did in <a class="link" href="ch04.html" title="Chapter 4. Building a Real-Time Search App">Chapter 4</a>, <span class="emphasis"><em>Building a Real-Time Search App</em></span>, and I refer you to this chapter to set it up on your system.</p><p>The entire API is a single Express application. Create a file in the root of your app called <code class="literal">index.js</code> and add this code:</p><div class="informalexample"><pre class="programlisting">'use strict';
var express = require('express');
var bodyparser = require('body-parser');
var mongoose = require('mongoose');
var cors = require('cors');
var passport = require('passport');
var Strategy = require('passport-http-bearer').Strategy;

var app = express();
app.use(cors({credentials: true, origin: true}));</pre></div><p>Cross-Origin Resource Sharing (CORS)<a class="indexterm" id="id503"/> defines a way in which a browser and server can interact to safely<a class="indexterm" id="id504"/> determine whether or not to allow a cross-origin request. It's famous for making life hard for API developers, so it's worth your while to install the <code class="literal">cors</code> package and use it in your Express app to alleviate the pain:</p><div class="informalexample"><pre class="programlisting">mongoose.connect(process.env.MONGOLAB_URI ||
  'mongodb://localhost/loginapp/users');</pre></div><p>We'll use a free MongoLab instance if it exists in our config file, or a local MongoDB database if not. We'll use the same token as in <a class="link" href="ch04.html" title="Chapter 4. Building a Real-Time Search App">Chapter 4</a>, <span class="emphasis"><em>Building a Real-Time Search App</em></span>, but we'll look at making it more secure in a later chapter:</p><div class="informalexample"><pre class="programlisting">var appToken = '1234567890';

passport.use(new Strategy(
  function (token, cb) {
    //console.log(token);
    if (token === appToken) {
      return cb(null, true);
    }
    return cb(null, false);
  })
);</pre></div><p>The database model is very simple, but could be expanded to add user e-mail addresses and more information if it's deemed as worthwhile to fetch. However, the more information you ask for, the less likely it is that the user will sign up for your service:</p><div class="informalexample"><pre class="programlisting">var userSchema = new mongoose.Schema({
  id: String,
  username: String,
  password: String
});

var userDb = mongoose.model('users', userSchema);</pre></div><p>We'll encrypt all <a class="indexterm" id="id505"/>passwords stored in the database with AES 256-bit encryption. This is a very strong form of security (and is in fact the same as the TLS/SSL encryption used for secure communication on the Internet):</p><div class="informalexample"><pre class="programlisting">var crypto = require('crypto'),
  algorithm = 'aes-256-ctr',
  password = '2vdbhs4Gttb2';</pre></div><p>Refer to the following lines of code:</p><div class="informalexample"><pre class="programlisting">function encrypt(text) {
  var cipher = crypto.createCipher(algorithm,password)
  var crypted = cipher.update(text,'utf8','hex')
  crypted += cipher.final('hex');
  return crypted;
}

function decrypt(text) {
  var decipher = crypto.createDecipher(algorithm,password)
  var dec = decipher.update(text,'hex','utf8')
  dec += decipher.final('utf8');
  return dec;
}</pre></div><p>These are the functions we'll use to encrypt and decrypt user passwords. We'll accept user password as text, then encrypt it and check whether the encrypted version exists in our database. Now check this out:</p><div class="informalexample"><pre class="programlisting">var routes = function (app) {
  app.use(bodyparser.json());

  app.get('/',
    function (req, res) {
      res.json(({"message":"The current version of this API is v1.
        Please access by sending a POST request to /v1/login."}));
    });

  app.get('/login',
   passport.authenticate('bearer', {session: false}),
    function (req, res) {
        res.json(({"message":
          "GET is not allowed. Please POST request with username
          and password."}));
    });</pre></div><p>This API needs <code class="literal">POST</code> data, so<a class="indexterm" id="id506"/> we'll display helpful information to anyone trying to access this via <code class="literal">GET</code>, since it isn't possible to fetch any data with the <code class="literal">GET</code> method.</p><p>We'll look for usernames and passwords and make sure we lowercase them because we don't support variable case strings:</p><div class="informalexample"><pre class="programlisting">  app.post('/login',
  passport.authenticate('bearer', {session: false}),
  function (req, res) {
    var username = req.body.username.toLowerCase();
    var password = req.body.password.toLowerCase();

    userDb.find({login: username,
      password: encrypt(password)},
      {password:0},
      function (err, data) {
        res.json(data);
      });
    });
}</pre></div><p>Moreover, we'll also specify that the password should not be a part of the resulting result set by setting the field to <code class="literal">0</code> or <code class="literal">false</code>.</p><p>We'll then search our database for a user that has the requested username and the provided password (but we need to make sure to look for the encrypted version). This way, we never know what the user's real password is. The API will use <code class="literal">/v1</code> as the route prefix:</p><div class="informalexample"><pre class="programlisting">var router = express.Router();
routes(router);
app.use('/v1', router);</pre></div><p>Note that you could alternately use an <code class="literal">accept</code> header to separate between versions of your API:</p><div class="informalexample"><pre class="programlisting">var port = 5000;
app.listen(process.env.PORT || port, function () {
  console.log('server listening on port ' + (process.env.PORT || port));
});</pre></div><p>Finally, we can start the API. When we try to send a <code class="literal">GET</code> request, we get the anticipated error response, and when we send a valid body with the correct username and password, the API delivers the data it <a class="indexterm" id="id507"/>has. Let's take a look at the following screenshot:</p><div class="mediaobject"><img alt="The Login API" src="graphics/B04943_06_03.jpg"/></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec31"/>Summary</h1></div></div></div><p>Congratulations! With this, you've just completed the advanced ReactJS chapter.</p><p>You've learned the difference between Browserify and Webpack and made a new basic setup with Webpack and hot module replacement that provides you with a fantastic developer experience.</p><p>You've also learned how to create React components using JavaScript 2016 classes and how to add the popular state management library: Redux. Furthermore, you wrote another API, this time the one used for logging in users with a username and password.</p><p>Pat yourself on the back, because this was a very heavy chapter.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>The finished project can be viewed online at <a class="ulink" href="https://reactjsblueprints-chapter6.herokuapp.com">https://reactjsblueprints-chapter6.herokuapp.com</a>.</p></div></div><p>In the next chapter, we'll use what we've learned in the last couple of chapters to write a web app that relies heavily on web APIs and the Webpack/Redux setup from this chapter. Roll up your sleeves because we're going to make a social network based around snapping images.</p></div></body></html>