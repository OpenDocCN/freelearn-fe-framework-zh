- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: 'Improving Backend Integrations: the Interceptor Pattern'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进后端集成：拦截器模式
- en: In a `Service`. However, many side tasks are common to all communications with
    the backend, such as header processing, authentication, and loading.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 `Service` 中。然而，许多辅助任务对所有与后端的通信都是通用的，例如头部处理、身份验证和加载。
- en: We could do this sides task on a service-by-service basis, but in addition to
    being an unproductive activity, the team might not be able to implement some control
    on the request due to the carelessness or ignorance of a new member of the team.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按服务逐个执行这个辅助任务，但除了这是一个低效的活动外，团队可能由于新成员的疏忽或无知而无法对请求实施一些控制。
- en: 'In order to simplify the development of side tasks for communicating with the
    backend, the Angular framework implements the interceptor design pattern, which
    we will explore in this chapter. Here, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化与后端通信的辅助任务开发，Angular 框架实现了拦截器设计模式，我们将在本章中探讨这一模式。在此，我们将涵盖以下主题：
- en: Attaching the token to the request with an interceptor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用拦截器将令牌附加到请求
- en: Changing the request route
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改请求路由
- en: Creating a loader
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个加载器
- en: Notifying success
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知成功
- en: Measuring the performance of a request
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量请求的性能
- en: By the end of this chapter, you will be able to create interceptors capable
    of implicitly performing tasks necessary for your backend communication.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够创建能够隐式执行后端通信所需任务的拦截器。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the instructions in this chapter, you’ll need the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的说明，你需要以下内容：
- en: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
- en: Node.js 18 or higher ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 18 或更高版本 ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch8](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch8).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可在 [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch8](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch8)
    找到。
- en: While following this chapter, remember to run the backend of the application
    found in the `gym-diary-backend` folder with the `npm` `start` command.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章时，请记住使用 `npm start` 命令运行位于 `gym-diary-backend` 文件夹中的应用程序的后端。
- en: Attaching the token to the request with an interceptor
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用拦截器将令牌附加到请求
- en: 'So far, our backend doesn’t have any kind of authentication control, which
    doesn’t happen (or at least it shouldn’t happen) in the real world. The backend
    was modified to perform authentication, but this was reflected in the frontend
    because, if we tried to log in, the following error would occur:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的后端没有任何形式的身份验证控制，这在现实世界中不会发生（或者至少不应该发生）。后端被修改以执行身份验证，但这也反映在前端，因为如果我们尝试登录，就会发生以下错误：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This error means that our request was rejected by the server because it was
    not authorized. That’s because our server implements a very common form of security
    that consists of asking for an authorization token in every request.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误意味着我们的请求被服务器拒绝，因为它没有得到授权。这是因为我们的服务器实现了一种非常常见的安全形式，即在每次请求中都要求提供授权令牌。
- en: This token is created when the user logs in to the application and it must be
    passed in the header of the HTTP request.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个令牌是在用户登录应用程序时创建的，并且它必须在 HTTP 请求的头部传递。
- en: 'We’ll fix this problem first by making a change to the `AuthService` service:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过更改 `AuthService` 服务来解决这个问题：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, we change the access mode of the `token` attribute. We are using the
    `#` symbol, which is the way to declare a `private` attribute in standard JavaScript.
    We want the token to be read by the other `component` but never overwritten, and
    using the token ensures that this happens even if the consumer class forces manipulation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们更改 `token` 属性的访问模式。我们使用 `#` 符号，这是在标准 JavaScript 中声明 `private` 属性的方式。我们希望令牌只能被其他
    `component` 读取，但永远不会被覆盖，使用令牌可以确保即使消费者类强制修改也能实现这一点。
- en: We change the class to the new attribute name and, at the end, we create the
    `token()` accessor method to return the token stored by the service.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将类名更改为新的属性名，并在最后创建一个 `token()` 访问器方法来返回服务存储的令牌。
- en: 'We’ll refactor the `ExerciseSetsService` service to send the token in the request
    that returns the diary items:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重构`ExerciseSetsService`服务，以便在返回日记条目的请求中发送令牌：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we create a header using the accessory class of Angular, `HttpHeaders`,
    passing the token in the `Authorization` attribute. Then, we pass this header
    in the `get` method of Angular’s `HttpClient` service.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用Angular的辅助类`HttpHeaders`创建一个头，通过`Authorization`属性传递令牌。然后，我们将此头传递给Angular的`HttpClient`服务的`get`方法。
- en: 'When we run our application again, it works again (`mario`, and `1234`):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次运行应用程序时，它再次工作（`mario`，和`1234`）：
- en: '![Figure 8.1 – Gym diary home page](img/B19562_08_1.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 健身日记主页](img/B19562_08_1.jpg)'
- en: Figure 8.1 – Gym diary home page
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 健身日记主页
- en: This approach has a problem, as we would need to replicate this operation for
    all of the service’s methods, and as our application grows, we would need to remember
    to do this token handling.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法存在一个问题，因为我们需要为所有服务的方法复制此操作，并且随着应用程序的增长，我们需要记住执行此令牌处理。
- en: A good software architecture should think about new team members with different
    backgrounds and even the creation of new teams as the project grows. Therefore,
    this type of transversal requirement of our system must be treated in a more intelligent
    way.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的软件架构应该考虑随着项目的增长，新团队成员的不同背景甚至新团队的创建。因此，我们系统的此类横向要求必须以更智能的方式处理。
- en: Enter **Angular Interceptor**, which is a service of a specific type to handle
    the HTTP request flow. This component is based on the design pattern of the same
    name, which aims to change a processing cycle.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 进入**Angular拦截器**，这是一个特定类型的服务，用于处理HTTP请求流程。该组件基于同名的设计模式，旨在改变处理周期。
- en: 'Let’s illustrate this pattern with the following diagram:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下图表来说明此模式：
- en: '![](img/B19562_08_2.jpg)![Figure 8.2 – Interceptor design pattern](img/B19562_08_3.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19562_08_2.jpg)![图8.2 – 拦截器设计模式](img/B19562_08_3.jpg)'
- en: Figure 8.2 – Interceptor design pattern
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 拦截器设计模式
- en: In this diagram, we have the Angular application that makes an HTTP request
    to the backend; in the interceptor pattern, we have an Angular service in the
    middle of the request that can change both the request and the return from the
    backend.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图表中，我们有发出HTTP请求到后端的Angular应用程序；在拦截器模式中，我们有一个位于请求中间的Angular服务，可以更改请求和后端的返回。
- en: 'We will refactor our previous solution to see this pattern in practice. We’ll
    clean up the `ExerciseSetsService` service by removing the handling from the `Authorization`
    header:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重构我们的前一个解决方案，以看到此模式在实际中的应用。我们将通过从`Authorization`头中删除处理来清理`ExerciseSetsService`服务：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To create the interceptor, we are going to use the Angular CLI for Angular
    to create the entire boilerplate of the service:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建拦截器，我们将使用Angular CLI为Angular创建整个服务的模板：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With the `AuthInterceptor` service created, let’s create our logic to attach
    the `Authorization` header:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了`AuthInterceptor`服务后，让我们创建我们的逻辑来附加`Authorization`头：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first thing we can notice is that the interceptor is a common Angular service,
    so it has the `@Injectable` notation; for more details about Angular services,
    see [*Chapter 5*](B19562_05.xhtml#_idTextAnchor163)*,* *Angular Services and the*
    *Singleton Pattern*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先可以注意到，拦截器是一个常见的Angular服务，因此它具有`@Injectable`注解；有关Angular服务的更多详细信息，请参阅[*第5章*](B19562_05.xhtml#_idTextAnchor163)*，*
    *Angular服务和单例模式*。
- en: This service implements the `HttpInterceptor` interface, which requires the
    class to have the `inject` method. This method receives the request we want to
    handle and expects an observable as a return. This signature indicates the characteristic
    of the interceptor because this class is always in the middle of a flow between
    the component making the request and the backend.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务实现了`HttpInterceptor`接口，要求类必须具有`inject`方法。此方法接收我们想要处理的请求，并期望返回一个可观察对象。此签名表明了拦截器的特征，因为此类始终位于发出请求的组件和后端之间的流程中间。
- en: Therefore, the service receives information from the flow and must return the
    flow represented by the observable. In our case, we use the `AuthService` service
    to get the token. The service cannot attach the token to the login endpoint because
    that is where we will get the token, so we make an `if` statement by analyzing
    which URL the request is using.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，服务从流程中接收信息，并必须返回由可观察对象表示的流程。在我们的案例中，我们使用`AuthService`服务来获取令牌。服务不能将令牌附加到登录端点，因为那里我们将获取令牌，所以我们通过分析请求使用的URL来创建一个`if`语句。
- en: If we have a token, we clone the request, but this time, we inform the header
    with the token. The reason we need to use the `clone` method to get a new object
    is that the request object is immutable – that is, it is not possible to change
    it; we need to create a new one, identical to the old one, but this time, we put
    the header.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有令牌，我们克隆请求，但这次，我们使用令牌来设置头信息。我们需要使用`clone`方法来获取新对象的原因是请求对象是不可变的——也就是说，它不能被更改；我们需要创建一个新的，与旧的完全相同，但这次，我们添加了头信息。
- en: 'Finally, the flow is returned but, this time, with the new request object.
    To configure the interceptor, we need to change the `AppModule` module:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，流程被返回，但这次，带有新的请求对象。为了配置拦截器，我们需要更改`AppModule`模块：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We’re including the `AuthInterceptor` service in the `HTTP_INTERCEPTORS` token.
    This tells the framework to call the service whenever a component uses Angular’s
    `HttpClient` service. The `multi` attribute informs the framework that we can
    have more than one interceptor because, by default, Angular adds only one.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`AuthInterceptor`服务包含在`HTTP_INTERCEPTORS`令牌中。这告诉框架每当组件使用Angular的`HttpClient`服务时调用该服务。`multi`属性通知框架我们可以有多个拦截器，因为默认情况下，Angular只添加一个。
- en: Running the application again, we can see that it is working now with the addition
    that all the resources are attaching the header, but implicitly, without the need
    to change each `HttpClient` call.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序，我们可以看到它现在正在工作，新增的是所有资源都在附加头信息，但隐式地，不需要更改每个`HttpClient`调用。
- en: Let’s explore this feature further with a very common task in our project, which
    is URL routing in the API call.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨这个功能，通过我们项目中的一个非常常见的任务，即在API调用中的URL路由。
- en: Changing the request route
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改请求路由
- en: In our project so far, we have two services that make requests to the backend.
    If we analyze them, we see that they both point directly to the backend URL. This
    is not a good practice since, as the project scales and grows in complexity, errors
    can occur by pointing to the wrong URL. In addition to the need to change the
    host, we will need to change numerous files.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们到目前为止的项目中，我们有两个服务会向后端发送请求。如果我们分析它们，我们会看到它们都直接指向后端URL。这不是一个好的做法，因为随着项目的规模和复杂性的增长，指向错误的URL可能会导致错误。除了需要更改主机之外，我们还需要更改许多文件。
- en: 'There are a few ways to handle this problem, but a very useful tool for this
    is the Angular interceptor. Let’s see it in practice starting with the Angular
    CLI, where we are going to create the new interceptor:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的方法有很多，但在这个问题中一个非常有用的工具是Angular拦截器。让我们从Angular CLI开始，我们将创建新的拦截器：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With the generated file, let’s create the `intercept` function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成的文件，让我们创建`intercept`函数：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this function, we have the URL of the backend and, in the `resource` variable,
    we receive the original URL of the request that we want to intercept and modify.
    We use an `if` statement next because we want to avoid errors in case some service
    needs to call another API directly.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们有后端的URL，在`resource`变量中，我们接收我们想要拦截和修改的原始请求URL。我们使用`if`语句是因为我们想要避免错误，以防某些服务需要直接调用另一个API。
- en: 'Finally, we create a new request object (this time, with the URL changed) and
    we pass this new object to the request flow. For this interceptor to be triggered
    by Angular, we need to add it to the `providers` array of the `AppModule` module:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个新的请求对象（这次，URL已更改）并将这个新对象传递给请求流程。为了让这个拦截器被Angular触发，我们需要将其添加到`AppModule`模块的`providers`数组中：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will refactor our service to only care about the features they need, starting
    with the `ExerciseSetsService` service:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重构我们的服务，使其只关注它们需要的特性，从`ExerciseSetsService`服务开始：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We follow this with the `Authentication` service:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`Authentication`服务：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can see that if we needed new services or changed the URL, the HTTP requests
    would not need to be refactored, as we created an interceptor to work on that.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，如果我们需要新的服务或更改URL，HTTP请求就不需要重构，因为我们创建了一个拦截器来处理这个问题。
- en: Next, we’ll learn how to give our users a better experience if a request takes
    too long.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何让用户在请求耗时过长时获得更好的体验。
- en: Creating a loader
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个加载器
- en: In a frontend project, performance is not only about having faster requests
    but also improving the user’s perception of the application. A blank screen without
    any feedback signals to the user that the page did not load, that their internet
    is having a problem, or any other type of negative perception.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端项目中，性能不仅关乎拥有更快的请求，还关乎提高用户对应用程序的感知。没有任何反馈信号的空白屏幕会向用户传达页面没有加载，他们的互联网有问题，或其他任何负面感知。
- en: 'That’s why we always need to signal that the action the user expects is being
    performed. One way to show this is a loading indicator, and that’s what we’re
    going to do in this session. In the command line of our operating system, we will
    use the Angular CLI:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们始终需要向用户发出信号，表明他们期望的操作正在执行。展示这一点的其中一种方式是加载指示器，这正是我们在这个会话中将要做的。在我们的操作系统命令行中，我们将使用
    Angular CLI：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With that, we created the `overlay` component, the service that will control
    the loading state, and the interceptor that will control the beginning and end
    of the loading based on HTTP requests.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们创建了`overlay`组件，控制加载状态的服务，以及根据HTTP请求控制加载开始和结束的拦截器。
- en: 'Let’s create the loading overlay screen in the HTML template of the `LoadingOverlayComponent`
    component:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`LoadingOverlayComponent`组件的HTML模板中创建加载覆盖屏幕：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will implement the `LoadService` service, which will maintain and control
    the loading state:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现`LoadService`服务，它将维护和控制加载状态：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We create two methods to turn the loading state on and off and a property to
    expose this state.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个方法来开启和关闭加载状态，以及一个属性来公开此状态。
- en: 'In the load interceptor, we will implement the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载拦截器中，我们将实现以下功能：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `intercept` method starts by turning on the loading state and returning
    requests without modifying anything in them.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`intercept`方法首先开启加载状态，并返回未修改的请求。'
- en: However, in the flow of the request, we placed the `finalize` operator from
    RxJs, which has the characteristic of executing a function when an observable
    arrives in the complete state – here, turning off the loading state. For more
    details about RxJS, read [*Chapter 9*](B19562_09.xhtml#_idTextAnchor242), *Exploring
    Reactivity* *with RxJS*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在请求流程中，我们放置了RxJs的`finalize`操作符，它具有在可观察者到达完成状态时执行函数的特征 – 在这里，关闭加载状态。有关RxJS的更多详细信息，请参阅[*第9章*](B19562_09.xhtml#_idTextAnchor242)，*使用RxJS探索反应性*。
- en: 'To activate the interceptor, we will add it to `AppModule`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活拦截器，我们将将其添加到`AppModule`：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We want the overlay to be executed in the application as a whole, so we will
    include the `overlay` component in the `AppComponent` component:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望覆盖层在整个应用程序中执行，因此我们将`overlay`组件包含在`AppComponent`组件中：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We just need to inject the `LoadService` service because that’s where we’ll
    have the loading state.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要注入`LoadService`服务，因为那里我们将拥有加载状态。
- en: 'Finally, let’s place the `overlay` component in the HTML template:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将`overlay`组件放置在HTML模板中：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Running our application, as we are running it with a backend on our machine,
    we may not notice the loading screen. However, for these cases, we can use a Chrome
    feature that simulates a slow 3G network.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的应用程序，因为我们是在机器上运行带有后端的程序，我们可能不会注意到加载屏幕。然而，对于这些情况，我们可以使用Chrome的一个功能来模拟慢速3G网络。
- en: 'Open **Chrome DevTools** and, in the **Network** tab, use the throttling option,
    as shown in the following figure:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**Chrome开发者工具**，在**网络**标签页中，使用如下所示的节流选项：
- en: '![Figure 8.3 – Simulation of a slow 3G network to notice the loading screen](img/B19562_08_4.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 模拟慢速3G网络以注意加载屏幕](img/B19562_08_4.jpg)'
- en: Figure 8.3 – Simulation of a slow 3G network to notice the loading screen
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 模拟慢速3G网络以注意加载屏幕
- en: In the next section, we will learn how to notify the success of a backend request
    to the user.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何通知用户后端请求的成功。
- en: Notifying success
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通知成功
- en: In addition to the loading screen to inform the user that the system is looking
    for the information they want, it is important to notify the user after processing
    an item. We can handle this notification directly from the service or component,
    but we can also implement it generically and implicitly using interceptors.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通知用户系统正在寻找他们所需的信息的加载屏幕外，在处理完一个项目后通知用户也同样重要。我们可以直接从服务或组件中处理此通知，但也可以通过拦截器以通用和隐式的方式实现它。
- en: 'We will refactor our application to add this treatment. But first, let’s install
    a library to show the `toaster` component on the screen with an animation. In
    the command line of our operating system, we will use the following command in
    the `main` folder of our frontend project:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重构我们的应用程序以添加这种处理。但首先，让我们安装一个库，在屏幕上使用动画显示`toaster`组件。在我们的操作系统命令行中，我们将在前端项目的`main`文件夹中使用以下命令：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In order for the package to work, we need to add our CSS to our project by
    editing the `angular.json` file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使包正常工作，我们需要通过编辑`angular.json`文件将我们的CSS添加到项目中：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For the toaster animations to work, we need to change the `AppModule` module:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使toaster动画工作，我们需要更改`AppModule`模块：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the `main` module of our application, we are adding the `ToastrModule` module
    from the library and changing `BrowserModule` to `BrowserAnimationsModule`, which
    adds Angular animation services used by the library.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用程序的`main`模块中，我们正在添加来自库的`ToastrModule`模块，并将`BrowserModule`更改为`BrowserAnimationsModule`，这为库添加了Angular动画服务。
- en: 'With the new package configured, we can proceed with creating the new interceptor
    using the Angular CLI:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 配置了新包后，我们可以使用Angular CLI创建新的拦截器：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With the interceptor created, we will change the file with the treatment for
    the notification:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 创建拦截器后，我们将更改通知的处理文件：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As in the *Creating a loader* section, we are using the fact that the request
    is treated as a flow to use RxJS and its observables to verify the request’s characteristics.
    We are using the `tap` operator, which aims to perform side effects on the request
    without changing it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在*创建加载器*部分中，我们正在利用请求被视为流的事实，使用RxJS及其可观察对象来验证请求的特征。我们使用`tap`操作符，该操作符旨在对请求执行副作用而不改变它。
- en: This operator will execute an anonymous function that will check the HTTP event,
    which brings us to an interesting point. As we are interested in the return of
    the request, we only select the event of type `HttpResponse` and the event code
    is `201-Created`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作符将执行一个匿名函数，该函数将检查HTTP事件，这带我们到一个有趣的观点。由于我们对请求的返回感兴趣，我们只选择类型为`HttpResponse`的事件，事件代码为`201-Created`。
- en: When we develop an interceptor, we have to remember that it is called in the
    request and the response, so it is important to use conditionals to execute what
    we need when we need it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发拦截器时，我们必须记住它在请求和响应时被调用，因此使用条件执行我们需要的操作是很重要的。
- en: 'The last point we need to configure is the main `AppModule` module:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要配置的最后一点是主要的`AppModule`模块：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Running our project and creating an entry, we notice that the toast appears
    on the screen with the configured message.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的项目并创建一个条目，我们注意到配置的消息在屏幕上显示为toast。
- en: '![Figure 8.4 – Success notification](img/B19562_08_5.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 成功通知](img/B19562_08_5.jpg)'
- en: Figure 8.4 – Success notification
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 成功通知
- en: Another use for interceptors is to instrument our application to measure performance
    and stability, which we’ll learn about in the next section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器的一个用途是测量我们的应用程序的性能和稳定性，我们将在下一节中了解。
- en: Measuring the performance of a request
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量请求的性能
- en: As a development team, we must always seek to offer the best experience for
    our users, and, in addition to developing quality products, we must allow the
    application to be monitored to maintain quality during production.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一支开发团队，我们必须始终寻求为用户提供最佳体验，除了开发高质量的产品外，我们还必须允许应用程序在生产过程中被监控以维持质量。
- en: There are several tools available on the market, and many of them need some
    level of instrumentation to accurately measure the user experience. We will develop
    a simpler telemetry example, but it can be applied to the monitoring tool your
    team uses.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 市面上有几种工具可供选择，其中许多需要一定程度的仪器来准确测量用户体验。我们将开发一个更简单的遥测示例，但它可以应用于你们团队使用的监控工具。
- en: 'Using the Angular CLI, we will create a new interceptor:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Angular CLI，我们将创建一个新的拦截器：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the file generated by the Angular CLI, we will develop our interceptor:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在由Angular CLI生成的文件中，我们将开发我们的拦截器：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To illustrate the ability to customize an interceptor, we agree that telemetry
    will only be used if the request made has a custom header called `X-TELEMETRY`,
    and right at the beginning of the function, we do this verification.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明自定义拦截器的能力，我们同意只有当请求带有名为`X-TELEMETRY`的自定义头时，才会使用遥测，并在函数的开始处进行此验证。
- en: As we did in the loader example, we used the `finalize` operator to measure
    the performance of the request in a simplified way and presented it in `console.log`.
    You could put your telemetry provider call or even your custom backend here.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在加载器示例中做的那样，我们使用了`finalize`运算符以简化的方式测量请求的性能，并在`console.log`中展示。你可以在这里放置你的遥测提供者调用，甚至你的自定义后端。
- en: 'To exemplify, we use `console.log` to show the information. As in the other
    sections, we need to configure the interceptor in the main `AppModule` module:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，我们使用`console.log`来展示信息。就像在其他部分一样，我们需要在主`AppModule`模块中配置拦截器：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, in the `ExerciseSetsService` service, we will send the customized
    header to carry out the telemetry of this request only:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`ExerciseSetsService`服务中，我们将发送定制的头以执行此请求的遥测：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Header passing is a way to configure an interceptor to behave differently depending
    on the situation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 头部传递是配置拦截器以根据不同情况表现不同的方式。
- en: 'Running our project, we can see the messages in the browser log:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的项目，我们可以在浏览器日志中看到消息：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this development, HTTP requests with the configured header will be logged
    in `console.log`. You can replace this interceptor with an integration to a telemetry
    service, improving the monitoring of your application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次开发，配置了头的HTTP请求将在`console.log`中记录。你可以用集成到遥测服务的拦截器替换这个拦截器，从而提高你应用程序的监控能力。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the interceptor feature in Angular and the possibilities
    that this feature can give our team. We learned how to attach the authentication
    token to the requests without having to change all the services in our project.
    We also worked on changing the URL of the request, making our project more flexible
    to its execution environment.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Angular中的拦截器功能以及这个功能可以为我们的团队带来的可能性。我们学习了如何在不改变我们项目中所有服务的情况下将身份验证令牌附加到请求中。我们还致力于更改请求的URL，使我们的项目对执行环境更加灵活。
- en: We also improved our users’ experience by creating a loader in case their internet
    is slow and notifying them on the screen when a new entry is registered in their
    gym diary. Finally, we created a simple example of telemetry using a custom header
    to give the team the ability to select which requests are telemetry capable.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过创建一个加载器来改善用户的体验，以防他们的网络速度慢，并在他们的健身房日记中注册新条目时在屏幕上通知他们。最后，我们使用自定义头创建了一个简单的遥测示例，以便团队能够选择哪些请求具有遥测能力。
- en: In the next chapter, we’ll explore RxJS, the most powerful library in the Angular
    utility belt.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索RxJS，这是Angular工具包中最强大的库。
