- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Local Weather App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can build a small app, we can add a bit more complexity. In this
    case, we’ll take a look at including another browser API and combining it with
    an external data source for our app. We will build a small weather app that returns
    the current weather.
  prefs: []
  type: TYPE_NORMAL
- en: We will start applying a different means of styling, using Tailwind as our CSS
    framework of choice, and in order to provide some additional robustness, we will
    also take a look at including some tests in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with external data coming from different types of APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to handle asynchronous data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying Tailwind to quickly style any application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring stability by adding unit tests for features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see what requirements we have to fulfil to get our application up and
    running.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we are going to use a third-party API to provide us with actual
    data. We need to register an account at [https://www.weatherapi.com/](https://www.weatherapi.com/)
    and retrieve the API keys for usage in our app.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll add Tailwind CSS to apply styling to our app. The [https://tailwindcss.com/](https://tailwindcss.com/)
    website offers extensive documentation as well as an installation guide.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our unit test, we’ll use the Vitest framework: [https://vitest.dev/](https://vitest.dev/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the source code here: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/03.weather](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/03.weather).'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s begin by starting with a slightly different configuration for the Vue.js
    CLI starter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Hit `y` to proceed, choose `vue-local-weather` as the project name, and select
    the options shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The setup configuration for the local weather app](img/B19563_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – The setup configuration for the local weather app
  prefs: []
  type: TYPE_NORMAL
- en: After following the instructions to install the dependencies and cleaning up
    the default files, we can get to work!
  prefs: []
  type: TYPE_NORMAL
- en: Working with different types of APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to retrieve local weather, we need a way to retrieve a location. The
    weather service we will be using accepts different sorts of location data, but
    we’ll go with latitude and longitude for this example.
  prefs: []
  type: TYPE_NORMAL
- en: It’s convenient that the browser’s geolocation API can provide us with just
    that! Let’s start by building a component that requests this information and displays
    it to the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a file in the `components` folder, called `GetLocation.vue`. We’ll
    start in the `script` tag by importing the utilities from Vue.js and define the
    data that’s expected to be available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, we’re saying that we will expect the reactive property `coords` to contain
    a latitude and longitude. Nothing fancy. Let’s write a function that retrieves
    the data from the geolocation API ([https://developer.mozilla.org/en-US/docs/Web/API/Navigator/geolocation](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/geolocation)).
    Now, bear in mind that a user can deny access to this API, so we need a fallback
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll add a reactive Boolean property, `geolocationBlockedByUser`, to keep
    track of the success of calling the API and a function that does the actual calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There’s a couple of things going on here. The `getGeolocation` function is being
    defined and, because it is dependent on user input, it is an asynchronous function
    by default. The promise it returns is empty because we use `successCallback` to
    update our reactive property.
  prefs: []
  type: TYPE_NORMAL
- en: That bit is empty right now, but we’ll add it in the next step. The `errorCallback`
    function only gets called if the geolocation cannot be retrieved, and for now,
    we’ll just assume that the user declined usage. So, we set the `geolocationBlockedByUser`
    value to true and log the error to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the documentation ([https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API/Using_the_Geolocation_API#getting_the_current_position](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API/Using_the_Geolocation_API#getting_the_current_position)),
    we see that `getCurrentPosition` returns an object (position) that holds latitude
    and longitude on a `coords` property. Since our `coords` reactive property expects
    a latitude and longitude, we process the data from the API as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This all works now, but the function hasn’t been executed yet. Like in the
    previous chapter, we’ll use the `onMounted` hook to execute the function once
    the component gets mounted on the DOM. The entire `script` tag should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s quickly add a template block that renders the output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the component to `App.vue` is a matter of importing the component and
    rendering it on the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Start our development server with `npm run dev`. Now, if you open the app in
    the browser, you should expect to see a browser popup asking for permission to
    share your location. If you grant access, you should see coordinates that your
    browser determined as your location (results may vary). If you have denied access,
    you should see the message stating that you did.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you inspect the console closely, you may notice a warning: **Only request
    geolocation information in response to a user gesture**. It is typically considered
    an anti-pattern or rude to immediately attempt to gather geo information. Not
    all browsers will always show a confirmation dialog and that could lead to users
    disclosing information without them knowing!'
  prefs: []
  type: TYPE_NORMAL
- en: The correct approach would be to add a button to the template that executes
    the `getGeolocation` function using the `onClick` directive. That way, a user
    actively initiates the request for geolocation.
  prefs: []
  type: TYPE_NORMAL
- en: Handling data from a third-party API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our coordinates, we can start to request localized weather
    data. For this example, we’ll make use of a public weather API ([https://www.weatherapi.com/](https://www.weatherapi.com/)).
    In order to make use of the service, we’ll need to request an API key. If you
    sign up for an account, the free tier will allow you to make 1,000,000 requests
    per month, which should be more than enough!
  prefs: []
  type: TYPE_NORMAL
- en: It is common practice to store these sorts of access keys or secrets in a local
    environment variables file. This practice allows our build processes to detach
    local development operations from our production environments. It keeps those
    variables in one place, rather than being spread throughout your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we’ll store the API key in a file at the root of your project called
    `.env`, with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `VITE_APP_` prefix makes sure that Vite automatically exposes the variable
    to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: With a client-based web application, the key will be exposed by default, since
    it will be attached to API calls that you can inspect via your browser’s network
    requests. For our purposes, this is fine. In a production-like environment, you
    would likely proxy the request via your own backend to obfuscate any secrets from
    the public.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the API call
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having our token on hand, we can start to make the call. Let’s discover how
    we need to construct the endpoint address to retrieve our relevant data.
  prefs: []
  type: TYPE_NORMAL
- en: Using the API explorer ([https://www.weatherapi.com/api-explorer.aspx](https://www.weatherapi.com/api-explorer.aspx)),
    we see that we can fetch data from the service using a location. While the explorer
    shows a place name, if we dig into the request parameters ([https://www.weatherapi.com/docs/#intro-request](https://www.weatherapi.com/docs/#intro-request)),
    we see that the `q` parameter also accepts a latitude and longitude in decimal
    degrees, such as `q=48.8567,2.3508`. This is something we can use!
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the docs, we need something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can manually call this by pasting this endpoint as a URL in the browser,
    replacing the variables with our actual data. You should see a formatted JSON
    object with weather data for your location! Now that we’re assured that everything
    works, we can move the logic to a Vue component to include it in our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a component called `WeatherReport.vue` in the `component` folder.
    We’ll start with the `script` block, and start by describing two types that we
    will be working with and defining the props that this component needs (`coords`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For the `WeatherData` type, I’ve taken a look at what the API returns to us,
    only describing the properties that we’re interested in. Feel free to pick metric
    or imperial units when implementing! The `Coords` type is as simple as holding
    numerical values for latitude and longitude and we can reuse that type within
    our `script` block, for instance, to describe the `coords` component property.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to use the response from the endpoint, we need to make it reactive.
    We can do this using `ref` and we’ll map it to a data constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we’re ready to define the caller function, using the fetch
    API. In the function, we’ll take in a parameter representing the coordinates for
    our request. We’ll return the data so we can later map it to the `data` property
    we’ve just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we’re describing a `fetchWeather` function that returns a promise
    in the shape of the `WeatherData` type. We use the `coords` parameter to construct
    the URL, combining it with the secret key. On fulfilling the request with a response,
    we transform it to JSON and return the value.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to our `GetLocation` component, we want to fetch the data immediately,
    so we’ve used the `onMount` hook in a similar fashion. We’ve passed the component
    props to the `fetchWeather` function and mapped the response to the reactive data
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our data, we can mark up the template to show the information!
    We’re dealing with asynchronous data, so we have a UI state where data is still
    loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with adding the two states to the `WeatherReport.vue` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Provided you have a quick response from the server, the data should show up
    almost instantly.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s take a look at how we can build our interface with style!
  prefs: []
  type: TYPE_NORMAL
- en: Styling with Tailwind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Tailwind CSS** is a popular utility-based CSS framework that we can use to
    build and style user interfaces by using and combining predefined classes. Tailwind
    is very scalable due to abstracting the writing of CSS rules, which provides consistency
    and maintainability where it’s used. Let’s take a look at how we can apply Tailwind
    CSS to our little application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation guide ([https://tailwindcss.com/docs/guides/vite](https://tailwindcss.com/docs/guides/vite))
    covers all of the steps we need to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will have to add the dependencies to the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’re installing Tailwind, but also the tooling to allow Vite to process the
    stylesheet using PostCSS. PostCSS is a powerful JS tool for transforming CSS using
    JavaScript ([https://postcss.org/](https://postcss.org/)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we’ll initialize the default configuration for Tailwind:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `style.css` file in the `./src` folder and add the following lines
    to import Tailwind CSS utility classes in your development and build steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, open the `./src/main.ts` file to import the CSS file into the
    app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Bear in mind that an imported CSS file differs from how you would traditionally
    link a CSS stylesheet to an HTML file. By importing it, the CSS file will be part
    of the development and build pipelines, which allows us to perform advanced operations
    on the styles before they are output.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we’re importing references to Tailwind CSS, adding browser-specific
    prefixes, and removing unused classes from the stylesheet. Having this amount
    of control and power is very convenient for building advanced apps!
  prefs: []
  type: TYPE_NORMAL
- en: With our setup in place, we can start to apply Tailwind CSS to our application.
    Tailwind uses utility classes to define the styling of an element.
  prefs: []
  type: TYPE_NORMAL
- en: Utility classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The approach of utility-class-based CSS frameworks is built around the notion
    of having CSS tightly coupled with a user interface while abstracting underlying
    rules and definitions. Instead of adding a class name to an element and then applying
    CSS styles within that class, you now add multiple class names to an element that
    describe the CSS behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Having a tightly coupled relationship between an element and how it’s styled
    has the benefit of it being very maintainable, with few hidden rules or side effects
    that affect how an element will be rendered. The base CSS file remains the same
    size; it’s just the list of all utility classes.
  prefs: []
  type: TYPE_NORMAL
- en: We can even remove unused styles since we know what classes we’re using in the
    markup. This has a higher level of predictability than more traditional CSS, where
    the relation between a style definition and the element that depended on the style
    is a lot less clear. Especially for rapid prototyping, the utility-based approach
    really shines, so let’s put it into practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make a small change to the `index.html` file to see Tailwind CSS in action.
    We’re going to add a list of classes to the `<div/>` element where our app is
    mounted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the strengths of Tailwind CSS is its readability. From the markup, we
    can visualize how the component will render in the browser. In this case, a multi-colored
    gradient as a background and the content at the horizontal and vertical center
    of the page. To learn more about the available Tailwind utility classes, the official
    docs provide a comprehensive list of all available classes: [https://tailwindcss.com/docs](https://tailwindcss.com/docs).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the application in the browser now, we can see the result of this
    change. Combining more of the utility classes, we’ll stylize the data we get from
    the weather API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go over to `WeatherReport.vue` and add some styling and HTML elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is already looking good! See how we’re combining Tailwind classes to determine
    how an element should be styled? You can experiment with all sorts of different
    ways of presenting the data.
  prefs: []
  type: TYPE_NORMAL
- en: We have a couple of predefined properties not yet mapped to the template. Let’s
    take a look at them because they require some extra attention.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at the timestamp from the service. We’re receiving it as
    a `datetime` string. We can format it to show up as a bit more readable information.
    We can just use a formatting function to format any date string into something
    we like. We’ll create the function in the `<script>` block of the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re using the browser’s built-in `Intl` namespace ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl))
    to interpret date information and returning it to the user based on the browser’s
    settings. Now we can simply call the method from the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Vue.js interprets the information between the brackets as an expression, so
    it will just evaluate the output of the `formatDate` method as the rendered information.
  prefs: []
  type: TYPE_NORMAL
- en: Custom style use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we’re left with information regarding wind: speed and direction. Representing
    the wind speed is straightforward: either pick the metric value or the imperial
    value and render it in the template. Representing the wind direction, we can make
    it a bit more user-friendly by indicating direction using an arrow that points
    in a certain direction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For such a specialized operation, it is best to create a new component. Let’s
    create one called `WindDirection.vue` for the moment. It will receive a numerical
    property called `degrees`. We will use the property to create a dynamic (computed)
    style, depending on the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the file, there are two interesting things going on. For starters, the `degrees`
    property gets used to create a computed value called `windStyle`. That value holds
    a dynamic CSS property and thus will be responsive to any prop it will get. We
    apply the style by binding it to the `:style` property of the `<span>` element,
    which simply holds an arrow.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing to point out is the `<span>` element with the `sr-only` class.
    This is a technique to make the content more accessible and it is something you
    should always consider. The arrow and its rotation only make sense when you can
    see the component being rendered. Not everybody can rely on sight when using the
    web. Some people use tools such as screen readers to process information on a
    given page.
  prefs: []
  type: TYPE_NORMAL
- en: Tailwind offers a special class utility to mark content for screen readers only,
    which means its contents are hidden by default browser behavior. A screen reader
    will likely read out the contents of the element. In this case, we’re describing
    the meaning of the arrow with its rotation.
  prefs: []
  type: TYPE_NORMAL
- en: Please be mindful of providing tools to make any website or application accessible
    for all by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now add this component to our application to wrap it all up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: That’s it! That’s our weather app! You can style it any way you want. If you
    want to add or remove properties, please finish the last part first, because it
    will help you maintain stability throughout your changes.
  prefs: []
  type: TYPE_NORMAL
- en: In our next section, we’ll add unit tests for specific features of the app.
    Unit tests take in small bits (units) of the code and validate that these parts
    have the same output when given certain conditions. Let’s see how that works.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring stability with Vitest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a working app, adding or removing a property can be done with
    ease. Just update the file and you’re ready. This is, however, not always a desirable
    situation. Having the ability to remove properties that easily could result in
    unwanted bugs in your application!
  prefs: []
  type: TYPE_NORMAL
- en: We can add more control to our code by describing its behavior using tests.
    In this part, we’ll take a look at adding unit tests with Vitest and Vue Test
    Utils, to demonstrate where unit tests can help you (and where they cannot).
  prefs: []
  type: TYPE_NORMAL
- en: Vue Test Utils
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The official testing library for Vue.js projects is **Vue Test Utils** ([https://test-utils.vuejs.org/](https://test-utils.vuejs.org/)).
    A testing framework is a series of tools and functions that you can use to create
    isolated instances of a component and manipulate it to assert certain behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of unit testing is to validate that each unit (or component) of
    the software is working as expected and meets the specified requirements. In our
    case, we could write tests for our Vue components, but also for JavaScript files
    that just export functions.
  prefs: []
  type: TYPE_NORMAL
- en: With our selected preset, we’ve already included the test tooling in our app.
    It even added a test script as part of the `package.json` file to run our tests
    with, so we can get started with writing some tests. There are several ways of
    organizing and structuring code. I prefer to have tests next to the component
    that they are testing. Test files are identified by a `.spec.ts` suffix in the
    filename, so you can always spot them with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of things to consider when it comes to writing good unit
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to test each functionality in isolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each unit test should be independent of all other tests, and not rely on the
    state of other tests or functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests support your documentation, so use logical and descriptive names to help
    understand what a test covers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll discover what I mean while we are writing different sets of tests or both
    Vue components as plain JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with something simple. Our entry point of the application is the
    `./src/app.vue` component. Let’s quickly open the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, in terms of functionality, little can go wrong. It imports the `GetLocation`
    component and mounts it to the template. If we consider this from a documentation
    point of view, you could describe the functionality of the component as *it should
    render the GetLocation component*. We can assert this, and this is exactly how
    we will write our first test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `App.spec.ts` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we import some tools to write our tests and assertions from
    Vitest. We also import a method to mount a component in our test and import the
    `GetLocation` and `App` components. You can execute the unit tests with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This command will execute all of the recognized test files and keep a watcher
    running to rerun any changed tests. The script automatically generates a report
    of the tests in the console.
  prefs: []
  type: TYPE_NORMAL
- en: A (shallow) mounted component will behave just as it would when being rendered
    by a browser, but we run this in isolation. With Vue Test Utils, you can either
    `mount` or `shallowMount` a component, with the difference being that a mount
    also attempts to render any children. A `shallowMount` function creates stubs
    for any children, which reduces side effects and focuses directly on the component
    itself. As a rule of thumb, I tend to always use `shallowMount` unless I need
    to assert specific parent-child behavior.
  prefs: []
  type: TYPE_NORMAL
- en: We scope the test with a `describe` block and make sure that we describe what
    the subject of our test is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we write our test: *it renders the GetLocation component*. This simply
    mounts the `App` component and then asserts whether the stub of the `GetLocation`
    component was found in the render tree.'
  prefs: []
  type: TYPE_NORMAL
- en: Global test functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use three functions in all our tests to create our test assertions.
    These functions are used to create clear and organized testing code, with the
    `describe` function used to group tests into logical test suites, the `it` function
    used to define individual test cases, and the `expect` function used to define
    the expected behavior of the code being tested.
  prefs: []
  type: TYPE_NORMAL
- en: We can make a small modification in our project files that removes the need
    for manually importing those much used functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `vite.config.ts` file and look for the `test` property. If we add
    a new property called `globals` with the value `true` as a child of the `test`
    property, you should end up with something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use the functions, but our IDE is not aware of those functions,
    so we need to configure some additional settings. First, we need to install some
    types by running the following command in the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll update the `tsconfig.vitest.json` file with the following addition to
    `types`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now our IDE is perfectly okay with directly using the `describe`, `it`, and
    `expect` functions. And that’s all you need to do in order to register them as
    globally available functions. You can remove that line from our first test file
    if you like.
  prefs: []
  type: TYPE_NORMAL
- en: A simple component test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s work our way on to more complex components now. Let’s start with the `WindDirection`
    component. We can assert a couple of things here that the component renders, but
    also that it adds the correct style to the direction indicator and that the screen
    reader text reflects the same value.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll create the `WindDirection.spec.ts` file, with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This only asserts that the component should not error when provided with the
    minimum requirement of properties. `toBeTruthy` is a loose assertion that asserts
    if the value is any expression or value that evaluates to true.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we take into consideration that we want to isolate tests as much as possible,
    we can add a test for rendering the wind direction arrow with the appropriate
    style. For that, we want to retrieve an element – the `span` element the computed
    style is applied to. It is common practice in these cases to add a specific attribute
    called `data-testid` to the element. Modify the `span` element to add the `data-testid`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have something to have our tests point at. The benefit of adding a specific
    attribute for testing over targeting by class name or hierarchical structure is
    that this is far less likely to be subject to changes over time, which makes your
    tests more robust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we localized the element using the `[data-testid=direction]`
    query and then asserted its style. By mapping it to the contents (a downward-pointing
    arrow), the combination of rotation with the arrow provides meaningful context.
    If we were to replace the downward-facing arrow with any other content, the component
    would lose its meaning and the test would rightfully fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add the final assertion, aimed at screen reader usage. First, we’ll
    add another `data-testid` attribute to the component. In this case, to the screen-reader-related
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This value has to be unique in order for us to target it from the test file,
    which now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In terms of isolation, we are executing this test on a new instance of the mounted
    component, and we are only looking at the contents of the `direction-sr` attributed
    component. We do this because, if a test fails, we should be able to immediately
    see what the cause and effect is.
  prefs: []
  type: TYPE_NORMAL
- en: We could add the `expect` lines to the previous test block, but if any assertion
    failed, we would not be able to see the direct cause. In small code bases, it
    wouldn’t be a big concern, but you can imagine the complexity when you’re dealing
    with a code base made up of hundreds of components with their unit tests. That
    is why isolation and simplicity are key.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking external sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous component only dealt with its own state. But we’ve also incorporated
    external sources in our application. We can’t test what we can’t control, so we
    don’t have to test those external sources. We do have to test the way that our
    component interacts with external sources. To make that more predictable, we can
    use mocks to control the output.
  prefs: []
  type: TYPE_NORMAL
- en: A good example is the browser API we’re using to retrieve the geolocation of
    a user. Let’s create our `GetLocation.spec.ts` file to test the component!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run our test now, it will fail. We need to fix two things here, to be
    honest. First of all, the test is an asynchronous test, since the retrieval of
    geolocation is a promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this still doesn’t work. This is because the tests are not executed
    in an actual browser, but in `jsdom`, which is a JavaScript-based browser environment.
    It doesn’t support (all of the) native browser APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component tries to access the `navigator.geolocation.getCurrentPosition`
    API, but it doesn’t exist! We need to mock it to allow our component to render.
    Mocking can be a bit abstract, but it is really about controlling the environment
    that affects our components. In our case, we can use a very straightforward implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we’re simply providing a method called `getCurrentPosition` so
    that it exists in the *browser* when we’re executing our test. This service doesn’t
    return any valid or useful information, but that’s not what we’re interested in
    here. We just want our component to be able to render.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also bear in mind that this test highlights a flaw in our application: it needs
    `navigator.geolocation.getCurrentPosition` to be present; otherwise, it will fail!'
  prefs: []
  type: TYPE_NORMAL
- en: Mocking for success
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To extend our testing scenario, we need to assert that our component is able
    to return a successfully resolved geolocation. We are going to create a new test
    case, because of isolation, and improve upon our mocked navigator API. We’ll use
    Vitest,s `vi.fn()` function for this.
  prefs: []
  type: TYPE_NORMAL
- en: The `vi.fn()` function ([https://vitest.dev/api/vi.html#vi-fn](https://vitest.dev/api/vi.html#vi-fn))
    is a Vitest function that creates a spy on the function. This means it stores
    all call arguments, returns, and instances. By storing it in `mockGeoLocation`,
    we can assert its properties more easily. The function takes in an argument, which
    is a callable mock instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the test file, we’ll import the `vi` function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s have a look at the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this case, instead of just having an empty function on the `navigator.geolocation.getCurrentPostition`
    method, we’ve created a mock of what a successful resolution would look like.
    We can find out the specifications of the `getCurrentPosition` API ([https://w3c.github.io/geolocation-api/#dom-geolocation-getcurrentposition](https://w3c.github.io/geolocation-api/#dom-geolocation-getcurrentposition))
    in order to have our mock match the expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: We’re providing a `successCallback` function, which returns coordinates just
    as the browser API would, and we’re immediately invoking it to simulate a user
    granting access to the geolocation data.
  prefs: []
  type: TYPE_NORMAL
- en: Having a successful resolution, we can assert that the component received the
    same `coords` object that came from the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Unhappy path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having tested a successful resolution, the last thing to test is what would
    happen if the user declined access to the location data. We will use a very similar
    approach, but instead of the successful callback, we will provide a secondary
    callback for failure. Again, this is according to the specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in this case, we’re completely ignoring `successCallback` and
    instead defining and invoking `errorCallback`. As the component dictates, the
    reactive `geolocationBlockedByUser` property will be set to true and we will show
    an error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete test file now looks like this, where we assert that the component
    renders, and it can resolve a successful query and handle a denied request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/03.weather/.notes/2.1-GetLocation.spec.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/03.weather/.notes/2.1-GetLocation.spec.ts)'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve made sure we’ve tested both the happy and the unhappy path. Let’s see
    how we can apply testing to components dealing with external data from an endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our final component also has an external dependency. This is not much different
    from mocking a browser API, as we will discover in this section. If we look at
    our component, it has the following features: shows the loading state when no
    data is retrieved and displays the response from the service in a nicely formatted
    way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with assessing that the component can render in a file called `WeatherRepost.spec.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you see that instead of mocking a `navigator` property, we’re
    mocking a global `fetch` property. We don’t need to return anything, so we’re
    keeping this test as simple as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'On to testing the loading state. In fact, we’re actually cheating a little
    bit here. There is simply a state of not having data or having data. We’re treating
    not having data as a loading state for the sake of simplicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: For this test, we’re just resolving the data as nothing. That means there’s
    no data available to render, which will keep the component in its loading state.
    We can assert that without data, the **Loading…** text stays visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also assert the situation when we did receive data from the service.
    This involves a similar approach, with the difference that instead of resolving
    nothing, we resolve with a mock weather report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We assert that the `mockData` properties are being mapped to the wrapper. There
    is a problem, though: the assertions are failing! We have two problems, in fact.
    The `shallowMount` function is flattening the HTML structure a bit and we have
    to wait for the promises to be resolved.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, Vue Test Utils has a useful utility for dealing with the promises:
    `flushPromises` is a utility function that makes sure all pending promises are
    resolved. We can import it at the top of our file together with our `mount` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If we rerun our test, it will succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s one final check since we have a formatter for our timestamp. Let’s
    add a `data-testid` attribute to the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: it('displays formats the datetime to a locale format', async () => {  const
    mockData = {
  prefs: []
  type: TYPE_NORMAL
- en: 'location: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'localtime: new Date(),'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: 'current: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'condition: {},'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: global.fetch = vi.fn(() => Promise.resolve({
  prefs: []
  type: TYPE_NORMAL
- en: 'json: () => Promise.resolve(mockData)'
  prefs: []
  type: TYPE_NORMAL
- en: '})) as any'
  prefs: []
  type: TYPE_NORMAL
- en: const wrapper = mount(WeatherReport, {
  prefs: []
  type: TYPE_NORMAL
- en: 'props: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'coords: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'latitude: 0,'
  prefs: []
  type: TYPE_NORMAL
- en: 'longitude: 0'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '})'
  prefs: []
  type: TYPE_NORMAL
- en: await flushPromises();
  prefs: []
  type: TYPE_NORMAL
- en: const localtime = wrapper.find("[data-testid=localtime]");
  prefs: []
  type: TYPE_NORMAL
- en: expect(localtime.text()).toEqual('January 31, 2001 at 11:45 AM')
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: it('displays formats the datetime to a locale format', async () => {  const
    mockDateTime = new Date(2000, 12, 31, 11, 45, 0, 0)
  prefs: []
  type: TYPE_NORMAL
- en: vi.setSystemTime(mockDateTime)
  prefs: []
  type: TYPE_NORMAL
- en: const mockData = {
  prefs: []
  type: TYPE_NORMAL
- en: 'location: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'localtime: new Date(),'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: 'current: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'condition: {},'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: global.fetch = vi.fn(() => Promise.resolve({
  prefs: []
  type: TYPE_NORMAL
- en: 'json: () => Promise.resolve(mockData)'
  prefs: []
  type: TYPE_NORMAL
- en: '})) as any'
  prefs: []
  type: TYPE_NORMAL
- en: const wrapper = mount(WeatherReport, {
  prefs: []
  type: TYPE_NORMAL
- en: 'props: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'coords: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'latitude: 0,'
  prefs: []
  type: TYPE_NORMAL
- en: 'longitude: 0'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '})'
  prefs: []
  type: TYPE_NORMAL
- en: await flushPromises();
  prefs: []
  type: TYPE_NORMAL
- en: const localtime = wrapper.find("[data-testid=localtime]");
  prefs: []
  type: TYPE_NORMAL
- en: expect(localtime.text()).toEqual('January 31, 2001 at 11:45 AM')
  prefs: []
  type: TYPE_NORMAL
- en: vi.useRealTimers()
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
