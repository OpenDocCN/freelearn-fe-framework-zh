- en: Component-Based Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Routing is an integral part of today''s frontend applications. In general,
    a router serves three main purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: It makes your application navigable so that users can use their browser's back
    button and store and share links within the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It offloads parts of the application composition so that the router takes responsibility
    for composing your application, based on routes and route parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It stores part of your application state within the URL of your browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The router that comes with Angular supports many different use-cases, and it
    comes with an easy-to-use API. It supports child routes that are similar to the
    Angular UI-Router nested states, Ember.js nested routes or child routers in the
    Durandal framework. Tied to the component tree, the router also makes use of its
    own tree structure to store states and to resolve requested URLs.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will refactor our code to use the component-based router
    of Angular. We will look into the core elements of the router and how to use them
    to enable routing in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducting to the Angular router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The router, container, and pure components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of the refactoring needed to enable the router in our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a route configuration file and look into different route configuration
    possibilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `RouterOutlet` directive to create insertion points that are controlled
    by the router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `RouterLink` directive and the router DSL to create navigation links
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using reactive router properties to obtain route parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using both the `RouterActive` directive as well as the programmatic router API
    for reacting to activated route paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmatically navigate using the router API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a route guard for the project container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to the Angular router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The router in Angular is closely coupled to our component tree. The design of
    the Angular router is built on the assumption that a component tree is directly
    related to our URL structure. This is certainly true for most of the cases. If
    we have a component **B**, which is nested within a component **A**, the URL to
    represent our location would very likely be `/a/b`.
  prefs: []
  type: TYPE_NORMAL
- en: To specify the location in our template where we'd like to enable the router
    to instantiate components, we can use so-called `outlets`. Simply by including
    a `<router-outlet>` element, we can mark the location in our template, where the
    Angular router will instantiate components.
  prefs: []
  type: TYPE_NORMAL
- en: Based on some route configuration that we can provide in our main module, the
    router then decides which components need to be instantiated and placed into the
    corresponding router outlets. Routes can also be parameterized, and we can access
    these parameters within the instantiated components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our component tree and the router configuration, we can build a hierarchical
    routing and decouple child routes from their parent routes. Such nested routes
    make it possible to compose our application layout on a meta level and reuse parent
    components for multiple child routes. By using the router we can add another layer
    of composition to our application. Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b7e177b-427c-4de1-b47c-ab9676a0e55f.png)'
  prefs: []
  type: TYPE_IMG
- en: Router hierarchy established through a component tree and router outlet
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the elements of the router again in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Route configuration**: The route configuration is done while importing the
    router into our application module. By configuring child routes, we can build
    decoupled nested routes easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Router outlets**: Outlets are the locations of components that will be managed
    by the router. Instantiated components that are based on the route configuration
    will be placed into these outlets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Router link**: These are links built with a DSL style notation that enable
    the developer to build complex links through the routing tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within this chapter, we'll go through these different concepts of the Angular
    router and refactor our application to implement proper routing.
  prefs: []
  type: TYPE_NORMAL
- en: Composition using the router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have achieved composition by including subcomponents in component
    templates directly. However, we'd now like to give the control to the router to
    compose our main application layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram provides an overview of the component architecture of
    our application, which we''re going to enable for the router:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4a7e86b-2a32-45c7-bf63-26d0fb34d6a3.png)'
  prefs: []
  type: TYPE_IMG
- en: A component tree displaying routed container components (solid line) and components
    included via router outlets
  prefs: []
  type: TYPE_NORMAL
- en: After the changes that we're going to implement, the project container component
    is not directly included in our app component anymore. Instead, we use a router
    outlet in the template of our app component. This way, we can give control to
    the router and let it decide which component should be placed into the outlet.
    Currently, we only have the project component as a first-level route, but this
    will change in later chapters when we add more features to our application.
  prefs: []
  type: TYPE_NORMAL
- en: The project component will contain another router outlet, which enables us to
    do nested child routing. There, we'll be able to create child routings that enable
    us to switch between the different project detail views.
  prefs: []
  type: TYPE_NORMAL
- en: Routing with container components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The composition that we've dealt with so far was purely based on instantiation
    via template inclusion. We used input and output properties to decouple and encapsulate
    components and followed nice reusable patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Using the router, which instantiates components dynamically, we can't use template
    bindings on routed components anymore. While we previously relied on input and
    output properties to connect our components together, we're losing this possibility
    by using the router and we can't bind to inputs or outputs any longer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, we already know about the concept of container components. Container
    components connect our state and data to our user interface components. They should
    not have any input or output properties and act as top-level components. They
    are by definition the perfect candidates for routed components:'
  prefs: []
  type: TYPE_NORMAL
- en: Since container components don't rely on input or output properties, they will
    work out-of-the-box when instantiated by the router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can simply consider the router as a different source for state and pass down
    information from the URL state into our UI components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Router configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular uses tree data structures to represent the router state. You can imagine
    that every navigation in your application activates a branch in this tree. Let's
    look at the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have an application that consists of four possible routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/`: This is the root route of the application, which is handled in a component
    called **A**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/b/:id`: This is the route where we can access the `b` detail view, which
    is handled in a component called **B**. In the URL, we can pass an `id` parameter
    (that is, `/b/100`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/b/:id/c`: This is the route where the `b` detail view has another navigation
    possibility, which reveals more specific details that we call `c`. This is handled
    in a **C** component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/b/:id/d`: This is the route where we can also navigate to a `d` view in the
    `b` detail view. This is handled by a component called **D**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/85ced9be-72d3-499c-988e-7493576774b9.png)'
  prefs: []
  type: TYPE_IMG
- en: A route tree consisting of an active branch of route segments for the activated
    route /b/100/d
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that we activate a route in our example by navigating the URL,
    `/b/100/d`. In this case, we'd activate a route that reflects the state that is
    outlined in the preceding diagram. Note that the route segment **B** actually
    consists of two URL segments. The reason for this is that we've specified that
    our route **B** actually consists of the `b` identifier and an `:id` route parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Using this tree data structure, we have a perfect abstraction to deal with navigation
    trees. We can compare trees, check whether certain segments exist in a tree, and
    extract parameters present on activated routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within each routed component, we have the possibility to inject the activated
    route of that level. Let''s assume we''d want to access the `:id` parameter from
    the URL within component **B**. We can inject the `ActivatedRoute` into the constructor
    of our component and extract the route parameter from there by using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Angular router reuses component instances by default. This means that if
    the router is activating the same component again but with different parameters,
    Angular is not destroying the previous component instance. It re-uses the previous
    instance and provides the updated parameters to our component. That's the reason
    why the `params` property on the `ActivatedRoute` object is an observable stream.
    We can simply subscribe to this observable, which allows us to react on route
    parameter changes.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the router API is quite flexible, and it allows us to inspect
    route activity on a very fine granularity. The tree structures that are used in
    the router make it possible to compare complex router states in our application
    without bothering about the underlying complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Back to the routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All right, now it''s time to implement routing for our application! In the
    upcoming topics, we''ll create the following routes for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Route path** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `/projects/:projectId` | This route will activate the project container component
    in the outlet of our root application component. This consists of the `projects`
    URL segment as well as the `:projectId` URL segment to specify the project ID.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/projects/:projectId/tasks` | This route will activate the `TaskListContainer`
    component inside of our project component. While we''re currently rendering the
    task list directly within the template of the project component, we will make
    use of an other router outlet instead. |'
  prefs: []
  type: TYPE_TB
- en: '| `/projects/:projectId/comments` | This route will activate the `ProjectCommentsContainer`
    component inside of our project component. The same router outlet within the project
    component is used to instantiate the project comments container component. |'
  prefs: []
  type: TYPE_TB
- en: You can directly relate the preceding route configuration to the composition
    illustrated within the diagram of the previous topic, *Composition using the router*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the router of Angular, the first thing that we need to do is to create
    a route configuration. Let''s create a new file on the path `src/app/routes.ts`
    and add our initial route configuration, using this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For the moment we'll only configure the route for projects and add the child
    routes to project comments and tasks later.
  prefs: []
  type: TYPE_NORMAL
- en: The `path` property within our route configuration objects is used as a pattern
    to match against the URL in the browser. The router will observe URL changes in
    the browser and then try to match each path in our configuration against the new
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular router will always match with a "first match wins" strategy. This
    means that you can have configuration scenarios where more than one configuration
    results in a match. However, only the first matching configuration within the
    list will be activated.
  prefs: []
  type: TYPE_NORMAL
- en: With the component property in our route configuration, we can tell Angular
    which component should be instantiated when a specific route is activated.
  prefs: []
  type: TYPE_NORMAL
- en: For our project route, we're also using a parameter segment to pass the ID of
    the project we want to display.
  prefs: []
  type: TYPE_NORMAL
- en: The second route in our configuration is a special route that will redirect
    users to the first project within our project list when they enter our app on
    the root URL (`http://localhost:4200/` in the case of our development server).
  prefs: []
  type: TYPE_NORMAL
- en: In redirect route configurations we can omit the `component` property but specify
    a `redirectTo` property to tell Angular that we'd like to redirect the user to
    a different URL. Within redirect routes, you always need to specify how you want
    to match the URL path. By default, Angular matches using a prefix match strategy.
    However, in many situations, you want to match the whole URL and not only a prefix.
    You can use the `pathMatch` property and set it to the value `'full'` for this
    purpose.
  prefs: []
  type: TYPE_NORMAL
- en: By specifying an empty path pattern, we can tell Angular to activate a route
    when there's an empty path segment within the browser's URL. However, when using
    the default prefix match strategy, this pattern will always result in a match.
    It's only when we set the `pathMatch` property to `'full'`, that we can cause
    a match when the user navigates to the root URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s move on and include the router within our application. We can
    use the router configuration that we''ve just created to initialize the Angular
    router. Let''s open up our main module located on the path `src/app/app.module.ts`
    and apply the following changes. Irrelevant code parts that did not change are
    hidden from the code excerpt and are marked with an ellipsis character. The effective
    changes within the code are marked in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code's changes to our main model, we're simply importing the
    routes configuration we've prepared and the Angular router module from `@angular/router`.
    By calling the module factory function `RouterModule.forRoot` we can pass our
    route configuration to the router and import the resulting router module into
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: That was easy! You've successfully created your first route configuration and
    included the router in your application. When you preview your changes and reload
    your browser, you should already see the redirect configuration kicking in. Your
    browser URL should be relocated to `http://localhost:4200/projects/0`. However,
    we don't leverage the compositional features of the router yet and our project
    navigation needs to be changed too.
  prefs: []
  type: TYPE_NORMAL
- en: Composing projects using the router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already prepared the route configuration for navigating our projects.
    The next step is to enable the router to handle the composition of projects correctly
    based on user navigation. Together, we''ll execute the following three steps to
    achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `<router-outlet>` element within our root component to allow the router
    to place instantiated components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the router link directives to make our project navigation work with the
    router.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting rid of the selected project state in our project service and instead
    rely on the URL state, which now includes the project ID of the navigated project.
    We can then refactor our project container component to make use of this route
    parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start with the template of our root component. Currently, we're including
    the project container component within the template directly. Since we'd want
    to give control to the router to determine which component will be visible to
    the user, we need to change that and include a `<router-outlet>` in the template
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the template of our root component, which is located in `src/app/app.component.html`,
    and apply the following changes. Again, the ellipsis symbol indicates irrelevant
    code parts that remain the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have removed the static inclusion of the project container component and
    added a router outlet element. This way the Angular router knows that it should
    instantiate activated components at this location within our template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing on our list is to use the router link directives in order to
    enable project navigation. Luckily we''re already in the right place to perform
    this change. The project navigation is part of the root component template and
    we need to add the router link directives there. Within the template `src/app/app.component.html`,
    we perform the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The router link directive allows us to make any element act like a link, which
    activates a given route. By using the router DSL, we can specify a route as individual
    segment elements within an array. Since we're iterating over all projects to render
    navigation item components, we can use the project ID to construct links that
    activate our previously configured route path, `/projects/:projectId`.
  prefs: []
  type: TYPE_NORMAL
- en: The second change is to use the `routerLinkActive` directive on our navigation
    items. This directive is a simple helper that adds a CSS class to any element
    where a router link directive is present. If the configured router link URL matches
    the URL in the browser, then the CSS class will be added. You can specify the
    CSS class name within the `routerLinkActive` attribute value. This helps us to
    style the active navigation item so that the user always sees which project is
    currently navigated.
  prefs: []
  type: TYPE_NORMAL
- en: Great! You have successfully updated the navigation within our root component
    to use the Angular router directives. While previewing the changes, you can already
    see that the URL in your browser is updated when you're navigating between the
    different projects within the project navigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'While so far we''ve been relying on our project service to tell us which project
    is currently selected, we''re now leveraging the URL state of the router to store
    this information. Let''s remove the `selectedProject` member and the call to the
    project service from our root component located in `src/app/app.component.ts`.
    We can also get rid of the `selectProject` method since the router is now in charge
    of selecting projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There's still one step missing to complete the switch to the router for our
    project composition. If you have been previewing the changes we've performed so
    far, you've noticed that we're already changing the URL and that the project navigation
    items get activated correctly. However, we always see the first project title
    and description within the project component. The project container component
    is currently still relying on the project service to obtain the selected project.
    We need to change that so that we use the state from the router.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the changes in the container component `src/app/container/project-container/project-container.component.ts`
    in order to obtain the project ID parameter from the activated route and display
    the correct project after navigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We're still using a member `selectedProject` which is of type `Observable<Project>`
    to represent the currently selected project. However, we're no longer obtaining
    this observable from the project service directly. Instead, we're using the `combineLatest`
    RxJS helper to combine two observable streams together in order to produce an
    output stream that emits the selected project.
  prefs: []
  type: TYPE_NORMAL
- en: We are combining the observable route parameters from the activated route with
    the project list from our project service. We can then use the `map` operator
    to find the right project within the project list using the ID obtained from the
    route parameters. The resulting observable stream will emit the selected project
    and re-emit whenever the route parameter or the project list changes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, go ahead and preview the changes in your browser again. You should now
    see that the router navigation using the project navigation on the left should
    also cause an update on our project component. It should always display the correct
    project information depending on what project ID is present within the browser's
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: Child routes for project details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within this section, we''re going to use the router for navigating the detail
    views on our projects. We currently have two detail views on our projects:'
  prefs: []
  type: TYPE_NORMAL
- en: Project tasks view using the task list container component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project comments view using the project comments container component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also need to make sure that we're able to activate the sub-views using our
    tabbed interface on projects. Our current solution is to store the activated tab
    within the project container component. Based on that, we're deciding which detail
    view to show within the template of our project component. There, we're using
    a simple `ngIf` directive in order to determine which of the two child container
    components to show.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with our refactoring by including child route configurations for
    both our detail views. Open up the router configuration file on the path `src/app/routes.ts`
    and perform the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using the `children` property on route configurations, we can configure nested
    routes. It allows us to tell Angular that somewhere below the routed parent component,
    there will be another router outlet that can be used to instantiate components
    activated by child routes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say a user is navigating to the path `/projects/1/tasks` with our new
    configuration. This would activate a path in our route configuration. The project
    container component is activated and instantiated into the router outlet within
    our root component. Additionally, the route parameter `:projectId` is set to the
    value `1`. Since we've configured a matching child route with the path `tasks`,
    this child route will also be activated. The Angular router is now searching for
    a nested router outlet below the project container component so that it can instantiate
    the task list container component there.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the diagram in the previous section, *Composition using
    the router* of this chapter again. This figure reflects our end goal in terms
    of composition using router outlets and instantiated components and illustrates
    where we need to add our nested router outlet element.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38bed4ac-6ebe-4c1d-87a0-1c3e536ad730.png)'
  prefs: []
  type: TYPE_IMG
- en: A component tree displaying routed container components (solid line) and components
    included via router outlets
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now apply some changes to our project components in order to make our
    child routes work. There are three changes involved:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the static inclusion of the task view and the comments view within the
    project component and use a nested router outlet instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the project container component to obtain the active tab from the child
    route name. Again, we're using the router to store the state for which tab is
    currently active.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update both the project comments container components as well as the task list
    container component to obtain the selected project from the router instead of
    the project service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start with the first step, which is quite a simple one. Let''s open
    up the file `src/app/project/project/project.component.ts` and replace the static
    inclusion of the detail views with a router outlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Okay, now the router is in control of instantiating the right project details
    component within our nested router outlet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second change we''re going to apply is concerning the tabbed interface
    component within our project component. Since our tabbed component is a pure component,
    it relies on the project container component to provide the active tab. Also,
    when we activate a tab, the project container component is implementing what should
    happen on an activation. Until now, the state for which of the tabs is currently
    active has been stored within the project container component directly. Now, we
    want to change this behaviour so that we use the router to store this state. An
    activation of a tab should then also trigger a route change. Let''s open the file
    `src/app/container/project-container/project-container.component.ts` and implement
    the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The tabs component is a pure component and this time we don't want to use the
    router link directives in order to make our project detail tabs navigable. Keeping
    things pure and not polluting your UI components with context-specific router
    link configurations can pay off when scaling your application. Instead, we want
    to use the router programmatically within our container component to cause navigation.
    We'd also like to have a way of telling which tab should be currently active according
    to the router state.
  prefs: []
  type: TYPE_NORMAL
- en: Within the preceding code changes, we're injecting the router instance within
    our component constructor. Additionally, we've changed the `activeTab` property
    to be of type `Observable<Tab>`. Now we need a way to react on router URL changes
    and figure out what of the tabs is active after the URL change. The observable
    behind `router.url` is exactly what we're looking for to start our reactive pipeline.
    On every navigation that causes the router to change the browser URL, this observable
    will emit an item. However, we're also going to need a reference to the currently
    selected project to figure out which tab is currently activated. For this purpose,
    we're combining the URL changes observables together with our `selectedProject`
    observable. Now, we have a stream that emits on URL changes and on changes of
    the selected project. Within a `map` operator, we're then using the `router.isActive`
    method in order to figure out which of the tabs is currently active. We can pass
    a URL string to the `isActive` method, and it tells us if that URL string is currently
    active within the router. We use the project ID of the selected project as well
    as the IDs of the individual tabs to construct this test URL string. At the end
    of our operator chain, the observable spits out the active tab object or null
    if none of the tabs is active.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, we''re almost there! The last change we need to apply to make our tabs
    work again is to refactor the `activateTab` method within the project container
    component class. Instead of updating a local state to represent the active tab,
    we now need to trigger a router navigation programmatically by using this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In order to navigate to a new URL programmatically, we can use the method `router.navigate`
    and use the router DSL to construct the URL segments of the desired route. Besides
    the ID of the activated tab, we also need the ID of the selected project to construct
    the target URL. Because the selected project is represented as an observable stream,
    we can transform using the take operator and subscribe to the output stream in
    order to get hold of the currently selected project object. Now, within the subscription,
    we have everything at hand to execute the programmatic navigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re now using an observable to represent the active tab, we need to
    modify our template on the path `src/app/container/project-container/project-container.component.html`
    and use the async pipe to subscribe to the observable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You've successfully refactored our tabs to work with the router and our configured
    child routes. If you preview your changes within the browser, you should be able
    to navigate between tabs again, and the browser URL should be updated while doing
    so. You can also try to reload your browser with a specific URL that directly
    navigates to a specific tab—the same scenario that would apply to a user using
    a bookmark to a specific tab on a project. Try, for example, to navigate to `http://localhost:4200/projects/2/comments`
    and see whether you're ending up where you'd expect to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last of the three steps to complete our child route refactoring is still
    outstanding. Currently, both of the detail views are still relying on the project
    service to determine the selected project. We need to change both of them to use
    the router instead and extract the selected project ID from the route, similarly
    as we do within the project container component already. Let''s start with the
    task list container component within the file `src/app/container/task-list-container/task-list-container.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Instead of obtaining the selected project observable from the project service,
    we're combining the project list observable, together with the route parameters,
    to find the selected project. This should look very familiar since we're using
    almost the same code as within the project container component. The only difference
    is that we need to access the parent route first. By calling `route.parent.params`,
    we can access the parent route and obtain the params from there. This is required
    since we're using nested routes and the task list container is a sub-view of the
    project container where the `:projectId` parameter is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s apply the same change to our project comments container component. Open
    up the file `src/app/container/project-comments-container/project-comments-container.component.ts`
    and update the code with the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Congratulations! We''ve successfully implemented all changes necessary to provide
    a fully navigable project structure including child routes. We are no longer relying
    on the project service to store the selected project within our application. As
    the last step, we can remove the unnecessary code from the project service, since
    none of our components rely on it anymore. Let''s open up the file `src/app/project/project.service.ts`
    and remove all code related to selecting projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Nothing feels better than removing abandoned code, right? It's like a reward
    for our hard work refactoring and cleaning up our code. Let's preview our changes
    within the browser and test our newly added router features. You should now be
    able to use the application the same way as before our refactoring. However, we
    now store the selected project and the active project detail tab within the browser's
    URL. Navigate across the different views and also try to use the back and forward
    buttons within your browser. It just feels so much better to be able to navigate
    like this.
  prefs: []
  type: TYPE_NORMAL
- en: Guarding our projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it's a good idea to prevent certain routes from being navigated,
    and to provide a fallback navigation for those scenarios. This is especially true
    when your routes include dynamic route parameters, which can change over time,
    meaning users may still have outdated bookmarks to those old URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Guards are the perfect helper for preventing these navigation errors. While
    guards help you to prevent access to certain routes and redirect accordingly,
    you should never rely on them to provide any kind of security for your application.
    Security always needs to come from a server. Using guards, you can just provide
    the necessary usability of a user accessing an area where he would be confronted
    with errors, maybe because of missing permissions to call a backend web service,
    or simply because a navigated detail view by an item ID no longer exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within this section, we''re going to create a guard to prevent navigation to
    a non-existing project. We haven''t used the Angular CLI for a while now. Let''s
    give it a long deserved spin and use it to create the stub of our project container
    guard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate a stub guard and include it into our main app module in
    the provider section. Let''s open up the guard file located at `src/app/guards/project-container.guard.ts`
    and change its content to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Within this simple project guard, we're implementing the `CanActivate` interface,
    which comes from the router module. By implementing this interface we can write
    a guard that allows us to control if a user can navigate a certain route. As the
    first argument of the `canActivate` method, we're receiving the activated route
    snapshot object of the target route. The method should return an observable of
    type `Observable<boolean>`. If we'd like to prevent the navigation, we can emit
    false through the observable stream that is returned.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we're using the project list observable obtained from the project
    service as an input observable. We then map the observable in order to determine
    if the project with the ID, extracted from the target route snapshot params, is
    existing. We're using the variable `projectExists` to store this information,
    which we return as the result of our mapping function. Additionally, if the project
    with the navigated ID does not exist, we're redirecting to the first project in
    the project list. We can do that by using the `router.navigate` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the only thing left to activate our guard is to include it in our router
    configuration. Let''s open the file `src/app/routes.ts` and add the following
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Every route configuration supports a `canActivate` property, which can be set
    to a list of guards that implement the `CanActivate` interface. All we need to
    do is add our guard to the project route configuration.
  prefs: []
  type: TYPE_NORMAL
- en: That's it! We have guarded our project container component and it's no longer
    possible to cause errors because of navigations to projects that don't exist.
    You can preview your changes in the browser and try to navigate to a non-existing
    project. Just try to navigate to `http://localhost:4200/projects/100` for example.
    You should be redirected to the first project overview.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the basic concepts of the router in Angular.
    We looked at how we can use the existing component tree to configure child routes
    in nested-router scenarios. We have learned about the router outlet element and
    the basic router link directive.
  prefs: []
  type: TYPE_NORMAL
- en: We have refactored our existing navigation elements, such as the project navigation
    and the tabbed interface on the project view. We've used router links and programmatic
    navigation to fulfil different navigation scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: We looked into some common route configuration specifics and the basics of the
    router link DSL. We've also learned about route matching patterns as well as parameter
    placeholders and how to access these parameters in activated routes.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, we've created a simple guard which prevents our users from
    accessing project details with invalid project IDs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about SVG and how to use this web standard
    in order to draw graphics in our Angular applications. We will visualize an activity
    log of our application activities using SVG and see how Angular makes this technology
    even greater by enabling composability.
  prefs: []
  type: TYPE_NORMAL
