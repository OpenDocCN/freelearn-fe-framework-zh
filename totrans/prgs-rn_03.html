<html><head></head><body>
		<div id="_idContainer017">
			<h1 id="_idParaDest-47" class="chapter-number"><a id="_idTextAnchor061"/>3</h1>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor062"/>Hello React Native</h1>
			<p>After you learned the basics of React and React Native in <a href="B16694_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">What Is React Native?</em>, and the fundamentals of JavaScript and TypeScript in <a href="B16694_02.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding the Essentials of JavaScript and TypeScript</em>, it is now time to dive deeper into the React Native world. </p>
			<p>One of the best things about React Native is that it is very flexible when it comes to how you use it. You can choose <strong class="bold">Expo</strong>, which handles all the native part for you and allows you to complete your first app in hours. It also makes it possible to build iOS apps without having a Mac. But you also can go with a bare React Native workflow, which gives you a lot of options in terms of how you integrate your React Native app into your whole development landscape.</p>
			<p>You can also integrate or even write your own (native) libraries. While this flexibility is one of the biggest strengths of React Native, it needs you to really understand what’s going on in the different scenarios to make the right choice for your project and your company. </p>
			<p>This chapter will enable you to do so. You will truly understand the different approaches, how to leverage them, and when to use each approach. </p>
			<p>You will learn the following things in the sections of this chapter:</p>
			<ul>
				<li>Understanding how React Native works on an example app</li>
				<li>Passing properties</li>
				<li>Understanding class components, function components, and Hooks</li>
				<li>Connecting different platforms to JavaScript</li>
				<li>Introducing the new React Native Architecture</li>
			</ul>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor063"/>Technical requirements</h1>
			<p>To be able to run the code in this chapter, you have to set up the following things: </p>
			<ul>
				<li>A working React Native environment (<a href="https://reactnative.dev/docs/environment-setup">https://reactnative.dev/docs/environment-setup</a>—<strong class="bold">React Native command-line interface</strong> (<strong class="bold">CLI</strong>) quickstart guide) </li>
				<li>While most of this chapter should also work on Windows, I would recommend working on a Mac</li>
			</ul>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor064"/>Understanding how React Native works on an  example app</h1>
			<p>There is no better <a id="_idIndexMarker128"/>way to understand a technology than by working<a id="_idIndexMarker129"/> with it. This section contains a simple example app that will show information<a id="_idIndexMarker130"/> about movies based on a static <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) file. The app will be further developed in the next chapters. For now, it should contain the following views:</p>
			<ul>
				<li>A home view to show a list of movie categories</li>
				<li>A category detail page with information about the category as well as the most popular movies of the category, with title and poster </li>
				<li>A movie detail page with information about the movie, including title, poster, rating, release date, and description</li>
			</ul>
			<p>While this is a very simple example, we’ll use it to focus a lot on understanding what’s going on under the hood. But let’s start with creating the app. We’ll use a React Native bare workflow to be complete in control while not having any overhead. That means we are using the official React Native CLI to initialize our project. This is done with the following command: </p>
			<p class="source-code">npx react-native init videoexample </p>
			<p class="source-code">    --template react-native-template-typescript</p>
			<p>We are using a TypeScript template to directly<a id="_idIndexMarker131"/> set up our project as a TypeScript project. This includes the <strong class="bold">TypeScript compiler</strong> (<strong class="bold">tsc</strong>) as well as the correct file extensions. You<a id="_idIndexMarker132"/> will learn more about templates<a id="_idIndexMarker133"/> and other options to start a React Native project in <a href="B16694_09.xhtml#_idTextAnchor282"><em class="italic">Chapter 9</em></a>, <em class="italic">Essential Tools for Improving React Native Development</em>.</p>
			<p>The preceding command creates a <strong class="source-inline">videoexample</strong> folder that contains the new React Native project. If you have set up everything correctly, you can start your example app on your iOS simulator with <strong class="source-inline">cd videoexample &amp;&amp; npx react-native run-ios</strong> (iOS simulators only work on iOS; on Windows, you can use <strong class="source-inline">cd videoexample &amp;&amp; npx react-native run-android</strong> to start an Android simulator).</p>
			<p>When you have successfully started your simulator, you should see the React Native default app running. It should look like this: </p>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B16694_03_01.jpg" alt="Figure 3.1 – React Native default app&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – React Native default app</p>
			<p>When you open the <strong class="source-inline">videoexample</strong> folder in your <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>), you will see that the React Native<a id="_idIndexMarker134"/> CLI has created a lot of files for you. In the following subsection, you’ll learn what they are and what they do. </p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor065"/>Understanding the React Native example project</h2>
			<p>The example project<a id="_idIndexMarker135"/> has only one screen, but technically it is a complete Android and iOS app. This means it contains the following things:</p>
			<ul>
				<li><strong class="source-inline">android</strong>: This folder contains the native<a id="_idIndexMarker136"/> Android project. You can open this folder with Android Studio and work with it like a native Android app. It uses Gradle as the build system, which also is integrated very nicely into Android Studio. The most important files you may have to touch on at some point in time are the following ones:<ul><li><strong class="source-inline">android/app/src/main/AndroidManifest.xml</strong>: The Android manifest contains essential information about the app. You may have to edit this file when adding certain functionality to your app that needs user permission or starting the app from push notifications.</li><li><strong class="source-inline">android/app/src/main/java/com/&lt;youridentifier&gt;/MainApplication.java &amp; android/app/src/main/java/com/&lt;youridentifier&gt;/MainApplication.java</strong>: These are the main files of your application. Normally you don’t have to touch these, but some libraries need some extra configuration here to work correctly. </li><li><strong class="source-inline">android/app/build.gradle</strong>: This file defines the Android build process for your app. In most cases, React Native handles this automatically, even if you install third-party libraries with native parts. But in some cases, you can have conflicts between these libraries, or you have to do some additional configuration. In these cases, this is the file to look at. There is also another build file in <strong class="source-inline">android/build.gradle</strong>, where you can add configurations for all sub-projects/modules.</li></ul></li>
				<li><strong class="source-inline">iOS</strong>: This folder contains the native iOS<a id="_idIndexMarker137"/> project. It consists of your app<a id="_idIndexMarker138"/> project, and something called <strong class="bold">pods</strong>. These pods are third-party projects that get bundled in your app to provide native functionality to React Native and all third-party libraries. The following files and folders are good to know about: <ul><li><strong class="source-inline">&lt;youridentifier&gt;.xcodeproj</strong>: This is your app’s project file. It contains only your project. Don’t use this in Xcode because it won’t work!</li><li><strong class="source-inline">&lt;youridentifier&gt;.xcworkspace</strong>: This is the file to work with. It contains your project as well as the pods’ projects. This is the file to work with in Xcode. </li><li><strong class="source-inline">Podfile</strong>: In this file, you can<a id="_idIndexMarker139"/> define dependencies for other projects. These dependencies are fetched via <strong class="source-inline">cocoapods</strong>. You can think of <strong class="source-inline">cocoapods</strong> like the <strong class="source-inline">npm</strong> or <strong class="source-inline">yarn</strong> package for native dependencies. In most cases, all dependencies are handled automatically by React Native, but sometimes, you must adapt the dependencies (at the time of writing—for example—on an M1 Mac). If you must do so, the Podfile is the file to<a id="_idTextAnchor066"/> <a id="_idTextAnchor067"/>look at. </li></ul></li>
			</ul>
			<p class="callout-heading">Note on cocoapods</p>
			<p class="callout"><strong class="source-inline">cocoapods</strong> is a very popular dependency management tool for iOS development. Nevertheless, it is not an official tool provided by Apple but an open source solution. The <strong class="source-inline">cocoapods</strong> team has no information about upcoming releases of Xcode or macOS, so it can sometimes take some time for <strong class="source-inline">cocoapods</strong> to work well with the latest releases.</p>
			<ul>
				<li><strong class="source-inline">node_modules</strong>: This folder is completely autogenerated<a id="_idIndexMarker140"/> during the dependency installation process with <strong class="source-inline">npm install</strong> or <strong class="source-inline">yarn</strong>. You don’t have to change anything here unless you want to patch third-party libraries.</li>
			</ul>
			<p class="callout-heading">Hint on patching libraries</p>
			<p class="callout">Sometimes, it can be useful to patch<a id="_idIndexMarker141"/> an existing library to fix a bug or add certain functionality. In these cases, you can either maintain your own fork of this library (which is very time-consuming) or you can use <strong class="source-inline">patch-package</strong>. <strong class="source-inline">patch-package</strong> is a small tool<a id="_idIndexMarker142"/> that creates patches for certain <strong class="source-inline">npm</strong> dependencies. You can read more on this in <a href="B16694_10.xhtml#_idTextAnchor347"><em class="italic">Chapter 10</em></a><em class="italic">, Structuring Large-Scale, Multi-Platform Projects</em>.</p>
			<ul>
				<li><strong class="source-inline">.eslintrc.js</strong>/<strong class="source-inline">.prettierrc.js</strong>: A fresh React Native project comes with built-in ESLint and Prettier support. These files contain the configurations for ESLint and Prettier. For more information on these tools, please read <a href="B16694_09.xhtml#_idTextAnchor282"><em class="italic">Chapter 9</em></a>, <em class="italic">Essential Tools for Improving React Native Development</em>.</li>
				<li><strong class="source-inline">.watchmanconfig</strong>: React Native uses a tool called <strong class="source-inline">watchman</strong> to watch projects’ files and trigger actions when they change. This is important for hot reloading during development. In most cases, this file is just an empty object. </li>
				<li><strong class="source-inline">app.json</strong>: This file contains<a id="_idIndexMarker143"/> information about your app, such as the app name.</li>
				<li><strong class="source-inline">babel.config.js</strong>/<strong class="source-inline">tsconfig.json</strong>: These files contain information, standards, and rules for the Babel and TypeScript compiler. In most cases, you don’t have to edit these. </li>
				<li><strong class="source-inline">metro.config.js</strong>: React Native uses a bundler called Metro<a id="_idIndexMarker144"/> to create your JavaScript bundle during development. This bundler runs on your Mac or PC, recreates your app’s JavaScript bundle after you have made changes, and pushes it to your device or simulator. This file contains the configuration of the <strong class="source-inline">metro</strong> bundler. In most cases, you don’t have to edit it. If you want to learn more about Metro, please visit the official page here: <a href="https://facebook.github.io/metro/">https://facebook.github.io/metro/</a>.</li>
				<li><strong class="source-inline">Index.js</strong>: This is the entry point of your JavaScript bundle. If you have a look at the code, it does nothing but bind it from <strong class="source-inline">./App</strong> to the native app via React Native <strong class="source-inline">AppRegistry.registerComponent</strong>.</li>
				<li><strong class="source-inline">App.tsx</strong>: This is the React Native default app. You can make changes here and see them directly in your simulator. This file will be replaced by our example application later on. </li>
			</ul>
			<p>By getting to know all these files, you already<a id="_idIndexMarker145"/> learned a lot about React Native. You saw that it contains real native projects with real native dependencies, uses a lot of useful tools, and has a single entry point. </p>
			<p>The next step for our example application is to set up a working folder structure. </p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor068"/>Structuring the example application</h2>
			<p>First, I always recommend<a id="_idIndexMarker146"/> creating an <strong class="source-inline">src</strong> folder for all of your JavaScript/TypeScript code. It is always a good idea to have all the code that belongs together in one place.</p>
			<p>For our example app, we create the following three subfolders in<a id="_idTextAnchor069"/> <a id="_idTextAnchor070"/>the <strong class="source-inline">src</strong> folder: </p>
			<ul>
				<li><strong class="source-inline">@types</strong>: In this folder, you place your TypeScript type declarations.</li>
				<li><strong class="source-inline">components</strong>: This folder contains all reusable components.</li>
				<li><strong class="source-inline">containers</strong>: Here, you have <a id="_idIndexMarker147"/>containers that are used to define the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) structure of your views. Typically, you put things such as <strong class="source-inline">ScrollView</strong> containers with custom animations here. These containers are used to hold the content of your views.</li>
				<li><strong class="source-inline">services</strong>: In this folder, we’ll create our services to connect to the movies. In this example, it will use the static JSON file <a id="_idIndexMarker148"/>as the source; later, we’ll connect to an external <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>).</li>
				<li><strong class="source-inline">views</strong>: This folder contains whole-page views. In our case, it is the three views defined before.</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">There are other approaches to how to structure a React Native project. Especially for large-scale projects, with multiple repositories, there can be ones that work better in some cases. You’ll learn about some of them in <a href="B16694_10.xhtml#_idTextAnchor347"><em class="italic">Chapter 10</em></a>, <em class="italic">Structuring Large-Scale, Multi-Platform Projects</em>. For our example project, this structure is absolutely fine.</p>
			<p>To get a deeper understanding of what’s going on, we try to do the first version of our example project<a id="_idIndexMarker149"/> completely without any third-party libraries. This is only for learning purposes and is not recommended in real-world projects. </p>
			<p>The first thing we must decide on is the general architecture of the app. It can be very helpful to visualize the different parts of the application in a diagram, like the one you can see here:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B16694_03_02.jpg" alt="Figure 3.2 – Example app architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Example app architecture</p>
			<p>As you can see in <em class="italic">Figure 3.2</em>, we will create three views (<strong class="source-inline">Home.tsx</strong>, <strong class="source-inline">Genre.tsx</strong>, and <strong class="source-inline">Movie.tsx</strong>). Since we are not using any navigation library, we must use the state of <strong class="source-inline">App.tsx</strong> to switch between these views. All three views use the <strong class="source-inline">ScrollContainer</strong> container to correctly place the views’ content. They also share some reusable components. </p>
			<p>The result is a very simple app that lets us navigate our movie content. In the following screenshot, you can see what it looks like:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B16694_03_03.jpg" alt="Figure 3.3 – Example app screenshot&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Example app screenshot</p>
			<p>You can see a list of movie genres on the first page, a list of movies of a single genre on the second page, and movie details on the third page. </p>
			<p>Now you’ve learned about<a id="_idIndexMarker150"/> the architecture and seen a high-level overview, it’s now time to dive deeper into the code. We’ll focus on the most interesting parts, but if you want to see the whole code, please go to the GitHub repository mentioned in the <em class="italic">Technical requirements</em> section. Let’s start with the <strong class="source-inline">App.tsx</strong> file.</p>
			<h3>Creating a root view</h3>
			<p>The <strong class="source-inline">App.tsx</strong> file serves as the root<a id="_idIndexMarker151"/> component of our project. It decides which view should be mounted and holds the global application state. Please have a look at the following code:</p>
			<pre class="source-code">
const App = () =&gt; {
  const [page, setPage] = useState&lt;number&gt;(PAGES.HOME);
  const [genre, setGenre] = useState&lt;IGenre | 
      undefined&gt;(undefined);
  const [movie, setMovie] = useState&lt;IMovie | 
      undefined&gt;(undefined);
  const chooseGenre = (lGenre: IGenre) =&gt; {
    setGenre(lGenre);
    setPage(PAGES.GENRE);
  };
  const chooseMovie = (lMovie: IMovie) =&gt; {
    setMovie(lMovie);
    setPage(PAGES.MOVIE);
  };
  const backToGenres = () =&gt; {
    setMovie(undefined);
    setPage(PAGES.GENRE);
  };
  const backToHome = () =&gt; {
    setMovie(undefined);
    setGenre(undefined);
    setPage(PAGES.HOME);
  };
  switch (page) {
    case PAGES.HOME:
      return &lt;Home chooseGenre={chooseGenre} /&gt;;
    case PAGES.GENRE:
      return (
        &lt;Genre
          backToHome={backToHome}
          genre={genre}
          chooseMovie={chooseMovie}
        /&gt;
      );
    case PAGES.MOVIE:
      return &lt;Movie backToGenres={backToGenres} 
          movie={movie} /&gt;;
  }
};</pre>
			<p>As you can see here, the <strong class="source-inline">App.tsx</strong> file has three state<a id="_idIndexMarker152"/> variables. This state can be seen as a global state because the <strong class="source-inline">App.tsx</strong> file is the root component of the app and can be passed down to the other components. It must contain a page that defines which view should be visible, and it can hold a genre and a movie.</p>
			<p>At the end of the file, you can find a <strong class="source-inline">switch</strong>/<strong class="source-inline">case</strong> statement. Based on the page state, this <strong class="source-inline">switch/case</strong> decides which view should be mounted. Also, the <strong class="source-inline">App.tsx</strong> file provides some functions to navigate through the application (<strong class="source-inline">chooseGenre</strong>, <strong class="source-inline">chooseMovie</strong>, <strong class="source-inline">backToGenres</strong>, <strong class="source-inline">backToHome</strong>) and passes them down to the views.</p>
			<p class="callout-heading">Important hint</p>
			<p class="callout">As you can see, the direct setter functions of the state variables (<strong class="source-inline">setPage</strong>, <strong class="source-inline">setGenre</strong>, <strong class="source-inline">setMovie</strong>) aren’t passed down to any view. Instead, we created functions that call these setter functions. This is best practice because it guarantees that our state is mutated in a predictable way. You should never allow your state to get mutated directly from outside your component. You will learn more about this in <a href="B16694_05.xhtml#_idTextAnchor110"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing States and Connecting Backends</em>.</p>
			<p>Next, let’s have<a id="_idIndexMarker153"/> a look at the views. These are pages that display content. </p>
			<h3>Displaying content based on a state</h3>
			<p>The <strong class="source-inline">Home</strong> view is the first page<a id="_idIndexMarker154"/> the user sees when opening the app. Please have a look at the following code:</p>
			<pre class="source-code">
import {getGenres} from '../../services/movieService';
interface HomeProps {
  chooseGenre: (genre: IGenre) =&gt; void;
}
const Home = (props: HomeProps) =&gt; {
  const [genres, setGenres] = useState&lt;IGenre[]&gt;([]);
  useEffect(() =&gt; {
    setGenres(getGenres());
  }, []);
  return (
    &lt;ScrollContainer&gt;
      &lt;Header text="Movie Genres" /&gt;
      {genres.map(genre =&gt; {
        return (
          &lt;Pressable onPress={() =&gt; 
               props.chooseGenre(genre)}&gt;
               &lt;Text style={styles.genreTitle}&gt;{genre.name}
                   &lt;/Text&gt;
          &lt;/Pressable&gt;
        );
      })}
    &lt;/ScrollContainer&gt;
  );
};</pre>
			<p>Here, you can see multiple things. At the top of the code block, you can see that we defined an <strong class="source-inline">interface</strong> for the <strong class="source-inline">props</strong> component. This is the TypeScript declaration of what should be passed down to this component from the parent component (in this case, the <strong class="source-inline">App.tsx</strong> file). Next, we have a list of genres as state variables.</p>
			<p>This is a local state or component<a id="_idIndexMarker155"/> state because it is only used inside this component. In the next line, we use the <strong class="source-inline">useEffect</strong> hook to call the <strong class="source-inline">getGenres</strong> method of our <strong class="source-inline">movieService</strong> to fetch the genres and set them to the local state.</p>
			<p>You will learn more about the <strong class="source-inline">useState</strong> and <strong class="source-inline">useEffect</strong> hooks in the <em class="italic">Understanding class components, function components, and Hooks</em> section of this chapter, but for now, it is only important that <strong class="source-inline">useEffect</strong> with an empty array as the second argument is called once when the component gets mounted.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When working with React, the terms <em class="italic">mounting</em> and <em class="italic">unmounting</em> are used a lot. <strong class="bold">Mounting</strong> means adding components<a id="_idIndexMarker156"/> to the render tree that weren’t there before. A newly mounted component can trigger its lifecycle functions (class components) or hooks (function components). <strong class="bold">Unmounting</strong> means removing components<a id="_idIndexMarker157"/> from the render tree. This can also trigger lifecycle functions (class components) or Hook cleanups (function components).</p>
			<p>After the <strong class="source-inline">useEffect</strong> Hook, you can see the <strong class="source-inline">return</strong> statement, which contains the <strong class="bold">JavaScript XML</strong> (<strong class="bold">JSX</strong>) that describes the UI. We<a id="_idIndexMarker158"/> use our <strong class="source-inline">ScrollContainer</strong> container, which contains the <strong class="source-inline">Header</strong> component and a list of <strong class="source-inline">Pressable</strong> instances,  one for each genre. This list is created with the <strong class="source-inline">.map</strong> command.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">This mixing of declarative UI and JavaScript data processing is one of the biggest strengths of React and React Native, and you will see it a lot. But whenever you do it, keep in mind that this is processed and recalculated every time the component is re-rendered. This means no expensive data processing operations should be done here.</p>
			<p>After looking at the <strong class="source-inline">Home</strong> view, we should<a id="_idIndexMarker159"/> also have a look at the <strong class="source-inline">Genre</strong> view. It basically works the same way, but with one big difference. The <strong class="source-inline">Genre</strong> view fetches its data based on a property that is passed from the <strong class="source-inline">App.tsx</strong> file. Look at the <strong class="source-inline">useEffect</strong> hook of the <strong class="source-inline">Genre.tsx</strong> file here:</p>
			<pre class="source-code">
  useEffect(() =&gt; {
    if (typeof props.genre !== 'undefined') {
      setMovies(getMoviesByGenreId(props.genre.id));
    }
  }, [props.genre]);</pre>
			<p>You can see that the <strong class="source-inline">getMoviesByGenreId</strong> method of <strong class="source-inline">movieService</strong> needs a genre <strong class="bold">identifier</strong> (<strong class="bold">ID</strong>). This is taken from the genre<a id="_idIndexMarker160"/> that is passed down to the <strong class="source-inline">Genre.tsx</strong> file from the <strong class="source-inline">App.tsx</strong> file.</p>
			<p>The whole process works as follows: </p>
			<ol>
				<li value="1">The <strong class="source-inline">App.tsx</strong> file passes down a <strong class="source-inline">chooseGenre</strong> function to the <strong class="source-inline">Home.tsx</strong> file.</li>
				<li>The user clicks on a genre and triggers the <strong class="source-inline">chooseGenre</strong> function, which sets the genre to the <strong class="source-inline">App.tsx</strong> state and also sets the page to <strong class="source-inline">GENRE</strong> in the <strong class="source-inline">App.tsx</strong> file, which unmounts <strong class="source-inline">Home.tsx</strong> and mounts <strong class="source-inline">Genre.tsx</strong>.</li>
				<li>The <strong class="source-inline">App.tsx</strong> file passes down the genre to the <strong class="source-inline">Genre.tsx</strong> file.</li>
				<li>The <strong class="source-inline">Genre.tsx</strong> file fetches the genre’s movies based on the genre ID. </li>
			</ol>
			<p>The same pattern is used to set the movie and navigate to the <strong class="source-inline">Movie.tsx</strong> view.</p>
			<p>The <strong class="source-inline">Movie.tsx</strong> page does<a id="_idIndexMarker161"/> not fetch any data on its own in this example. It gets passed down the movie data it displays from the <strong class="source-inline">App.tsx</strong> file and needs no other information. </p>
			<p>After understanding the views, we’ll now have a look at the components.</p>
			<h3>Using reusable components</h3>
			<p>It is very important<a id="_idIndexMarker162"/> to move UI code that you use in different places to components, at least when the project grows—this is crucial to prevent duplicate code and an inconsistent UI. But even in a smaller project, using reusable components is always a good idea and speeds up development a lot. In this simple example, we created a <strong class="source-inline">Header</strong> component:</p>
			<pre class="source-code">
interface HeaderProps {
  text: string;
}
const Header = (props: HeaderProps) =&gt; {
  return &lt;Text style={styles.title}&gt;{props.text}&lt;/Text&gt;;
};
const styles = StyleSheet.create({
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 16,
  },
});</pre>
			<p>As you can see, this is a very simple component. It takes a string and renders the string in a predefined way, but even this simple component saves us quite some time and prevents duplicated code. Instead of having to style the header text in <strong class="source-inline">Home.tsx</strong>, <strong class="source-inline">Genre.tsx</strong>, and <strong class="source-inline">Movie.tsx</strong>, we can just use the <strong class="source-inline">Header</strong> component and get our header text styled in a consistent way.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Use reusable components wherever you can. They ensure a consistent UI and make changes easily adaptable throughout the whole application.</p>
			<p>After looking<a id="_idIndexMarker163"/> at the components, we’ll turn our attention to the services next. </p>
			<h3>Using services to fetch data</h3>
			<p>You should always abstract<a id="_idIndexMarker164"/> the data fetching from the rest of the application. This is not only for logical reasons, but also if you have to change anything here (because of an API change), you don’t want to touch your views or components.</p>
			<p>In this example, we use two JSON files as the data source. You can find them in the repository under <strong class="source-inline">assets/data</strong>. The services use the files to filter or list the data and provide it to the views. Please have a look at the following code:</p>
			<pre class="source-code">
const genres: IGenre[] = require('../../assets/data/genres.json');
const movies: IMovie[] = require('../../assets/data/movies.json');
const getGenres = (): Array&lt;IGenre&gt; =&gt; {
  return genres;
};
const getMovies = (): Array&lt;IMovie&gt; =&gt; {
  return movies;
};
const getMovieByGenreId = (genreId: number): 
    Array&lt;IMovie&gt; =&gt; {
        return movies.filter(movie =&gt; 
            movie.genre_ids.indexOf(genreId) &gt; -1);
};
export {getGenres, getMovies, getMovieByGenreId };</pre>
			<p>As you can see here, we require the two JSON files in the first two lines. The <strong class="source-inline">getGenres</strong> and <strong class="source-inline">getMovies</strong> functions just return the content of the files, without any filtering. <strong class="source-inline">getMovieByGenreId</strong> takes a numeric genre ID and filters the movies for this ID in the <strong class="source-inline">genre_ids</strong> of the movie. It then returns the filtered <strong class="source-inline">movies</strong> array. </p>
			<p>In the last line, we export the functions<a id="_idIndexMarker165"/> to be importable in our views. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">In larger projects, it is very common to start working with dummy data such as our JSON files here. This is because the frontend part is often developed in parallel to the API, and with the dummy data, the frontend team exactly knows what the data will look like. When the API is ready and the data service is well abstracted, it is no problem to replace the dummy data with the real-world API data fetching. We’ll also do this in <a href="B16694_05.xhtml#_idTextAnchor110"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing States and Connecting Backends</em>.</p>
			<p>At last, we’ll have a look at the containers.</p>
			<h3>Using containers for page styling</h3>
			<p>In our example, we only<a id="_idIndexMarker166"/> have one container, <strong class="source-inline">ScrollContainer</strong>. It has a very similar purpose to the components, but while components are mainly parts that are used as parts of a view, containers are used to define the (outer) layout of a view. Please have a look at the code of our <strong class="source-inline">ScrollContainer</strong> container here:</p>
			<pre class="source-code">
interface ScrollContainerProps {
  children: React.ReactNode;
}
const ScrollContainer = (props: ScrollContainerProps) =&gt; {
  return (
    &lt;SafeAreaView style={styles.backgroundStyle}&gt;
      &lt;ScrollView
        contentInsetAdjustmentBehavior="automatic"
        contentContainerStyle={styles.contentContainer}
        style={styles.backgroundStyle}&gt;
        {props.children}
      &lt;/ScrollView&gt;
    &lt;/SafeAreaView&gt;
  );
};</pre>
			<p>As you can see <a id="_idIndexMarker167"/>in the interface definition, our <strong class="source-inline">ScrollContainer</strong> container takes only one property called <strong class="source-inline">children</strong>, which is defined as <strong class="source-inline">React.ReactNode</strong>. This means you can pass components to <strong class="source-inline">ScrollContainer</strong>. Also, the <strong class="source-inline">children</strong> property of a React component makes it possible to use this component with opening and closing tags while passing all JSX between the tags down to the component as a <strong class="source-inline">children</strong> property. This is exactly what we have done in all our views. </p>
			<p>Our <strong class="source-inline">ScrollContainer</strong> container also uses a component called <strong class="source-inline">SafeAreaView</strong>. This is provided by React Native and handles all the different devices with notches (iPhone, Samsung), virtual back buttons (Android), and more. </p>
			<p>Now that you’ve had a look at all the different parts of our first example application, it’s time for a short wrap-up. Up to now, you’ve learned how to structure an application, why it is important to abstract the different layers, and how to create reusable UI. </p>
			<p>You’ve also learned that React and React Native components always consist of two parts: preparing the data in state/props and displaying the data with JSX. Maybe you also have realized that all our components are sorted in such a way that the data preparation is at the top of the component while the displaying of the data is at the bottom. I prefer this way of structuring a component because it makes it much more readable.</p>
			<p>You also already know<a id="_idIndexMarker168"/> a way to pass properties between components. Because this is a very important topic, we’ll focus on that in more detail in the next section.</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor071"/>Passing properties</h1>
			<p>As you have already <a id="_idIndexMarker169"/>seen in the example application, there are multiple ways to pass data around in an application. Some best practices have been established that you should definitely stick to; otherwise, your application can get very hard to debug and maintain. We list these here:</p>
			<ul>
				<li><strong class="bold">Never modify a component state in an unpredictable way from outside the component</strong>: I know—I repeat myself; we had this in the previous section, but this is very important. Modifying your state in an unpredictable way from outside the component can lead to bad errors, especially when you are working on a large project with a team of developers. But let’s have a look in detail. </li>
			</ul>
			<p><em class="italic">Unpredictable</em> in this scenario means that you pass the setter function of your state directly to other components. </p>
			<p>Why is this so bad? Because other components and maybe other developers can decide what to put in the state of your component. It is very likely that sooner or later, one of them decides to put something in there that your component can’t handle in some edge cases. </p>
			<p>What is the solution? There are multiple scenarios where you have to modify a component state from outside the component, but if you have to, do it in a predictable way by passing predefined functions. These functions should then verify the data and handle the state modification. </p>
			<ul>
				<li><strong class="bold">Always use type declarations for your props</strong>: You should always use any kind of type declaration for your component props so that other developers know what kind of data your component expects. I recommend using TypeScript, but if you use plain JavaScript, there is a library called <strong class="source-inline">PropTypes</strong> you can use. For more<a id="_idIndexMarker170"/> information, please look at this link: <a href="https://www.npmjs.com/package/prop-types">https://www.npmjs.com/package/prop-types</a>.</li>
				<li><strong class="bold">Limit the number of props you pass</strong>: The more properties you pass, the harder your code will get to read and maintain, so think twice if it is necessary to pass a property. Also, it’s better to pass objects rather than multiple primitives.</li>
			</ul>
			<p>After these best practices<a id="_idIndexMarker171"/> for passing properties, we’ll have a deeper look at different component types and hooks in the next section.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor072"/>Understanding class components, function components, and Hooks</h1>
			<p>React and React Native provide<a id="_idIndexMarker172"/> two different ways to write components: class components<a id="_idIndexMarker173"/> and function components. Nowadays, you can<a id="_idIndexMarker174"/> use both variants interchangeably. Both ways are supported, and there is no sign that one of them won’t be supported in the future. So, why do two different ways exist? This is due to historical reasons. Before hooks were introduced in 2019 (React 16.8), function components couldn’t have a state or use any lifecycle methods, which meant that any component that needed to fetch and store data had to be a class component. But because function components require less code to write, they were often used for displaying data that was passed as props.</p>
			<p>The limitation of function components changed with the introduction of Hooks. <strong class="bold">Hooks</strong> are functions provided by React that make it possible to use functionality, which was limited to class components, also in function components.</p>
			<p>Today, it depends a lot on your preferences as to whether you work with function components and hooks or class components and lifecycle methods. Again, function components are less code to write, but developers with experience in <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) languages might prefer to work<a id="_idIndexMarker175"/> with class components. Both ways are totally fine and don’t differ in terms of performance. Only the app size will be a little larger when working with class components. </p>
			<p>In the next subsections, we’ll have<a id="_idIndexMarker176"/> a look at the different syntax <a id="_idIndexMarker177"/>and how to work<a id="_idIndexMarker178"/> with the different component types. We’ll start with class components.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor073"/>Working with class components and lifecycle methods</h2>
			<p>As already mentioned, class components<a id="_idIndexMarker179"/> were always able to hold dynamic data<a id="_idIndexMarker180"/> in a changeable state. This state can be changed due to either user interaction or an action triggered in a lifecycle method. Lifecycle methods are methods that are provided by React and are called at a specific time of the component execution.</p>
			<p>One of the most important lifecycle methods is <strong class="source-inline">componentDidMount</strong>. This method is called directly after a component was mounted and is often used for data fetching. The following code example shows a very basic example of a class component:</p>
			<pre class="source-code">
class App extends React.Component {
  constructor() {
    super();
    this.state = {
        num: Math.random() * 100
    };
  }
  render() {
    return &lt;Text&gt;This is a random number:  
        {this.state.num}&lt;/Text&gt;;
  }
}</pre>
			<p>The class component has one <strong class="source-inline">state</strong> property that is initialized in the constructor of the class. This <strong class="source-inline">state</strong> variable can hold multiple objects. In this case, it only contains a <strong class="source-inline">num</strong> property that gets initialized with a random number between <strong class="source-inline">0</strong> and <strong class="source-inline">100</strong>. The component always has to have a <strong class="source-inline">render</strong> function. This function contains the JSX of the component. In this example, it’s only a <strong class="source-inline">Text</strong> component that displays a random number to the user. </p>
			<p>To bring some<a id="_idIndexMarker181"/> life to this example, we can start an interval to regenerate<a id="_idIndexMarker182"/> the random number every second. This is where lifecycle functions come into play. We would use the <strong class="source-inline">componentDidMount</strong> lifecycle function to start the interval and <strong class="source-inline">componentWillUnmount</strong> to clean it up. Please have a look at the following code snippet: </p>
			<pre class="source-code">
  componentDidMount = () =&gt; {
    this.interval = setInterval(() =&gt; {
      this.setState({ num: Math.random() * 100 });
    }, 1000);
  };
  componentWillUnmount = () =&gt; {
    clearInterval(this.interval);
  };</pre>
			<p>In <strong class="source-inline">componentDidMount</strong>, we create an interval that updates the <strong class="source-inline">num</strong> state every second. As you can see, we are not setting the state directly, but we are using the <strong class="source-inline">setState</strong> method. Remember—setting the state directly is only allowed for initialization in the constructor. </p>
			<p>We also store the interval’s handle to <strong class="source-inline">this.interval</strong>. In <strong class="source-inline">componentWillUnmount</strong>, we clear <strong class="source-inline">this.interval</strong> so that we don’t have code running infinitely when we are navigating away from the component. </p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">componentDidMount</strong> is the right place to fetch data that is used in the component. </p>
			<p>If you want to see a running<a id="_idIndexMarker183"/> version of this example, please have a look at the following CodeSandbox instance: <a href="https://codesandbox.io/s/class-component-basic-nz9cy?file=/src/index.js">https://codesandbox.io/s/class-component-basic-nz9cy?file=/src/index.js</a>.</p>
			<p>After this simple<a id="_idIndexMarker184"/> example, it’s time<a id="_idIndexMarker185"/> to look at lifecycle methods a little closer. You’ll now get to know the most used ones, as listed here:</p>
			<ul>
				<li><strong class="source-inline">componentDidMount()</strong>: This method is called directly after<a id="_idIndexMarker186"/> a component is mounted. It is called only once during the whole lifecycle of a component. It can be used for data fetching, adding handlers, or populating the state in any other way.</li>
				<li><strong class="source-inline">componentWillUnmount()</strong>: This method is called directly before<a id="_idIndexMarker187"/> a component gets unmounted. It is called only once during the whole lifecycle of a component. It should be used for cleaning up handlers, intervals, timeouts, or any other executing code. </li>
				<li><strong class="source-inline">componentDidUpdate(prevProps)</strong>: This method is called every time a component gets updated<a id="_idIndexMarker188"/> and re-rendered. It can be called multiple times (a lot of times) during the whole lifecycle of a component. <strong class="source-inline">componentDidUpdate</strong> gets the previous props passed as a parameter so that you can compare them to the current props to check what changed. It can be used for refetching data based on changed parameters of the component. Please be informed that any <strong class="source-inline">setState</strong> method in the <strong class="source-inline">componentDidUpdate</strong> method has to be wrapped in a condition. This is for preventing infinite loops.</li>
				<li><strong class="source-inline">shouldComponentUpdate(nextProps, nextState)</strong>: This method is called every time before a re-render<a id="_idIndexMarker189"/> will take place. It can be called multiple times (a lot of times) during the whole lifecycle of a component. It exists only for performance reasons, because in some scenarios, you only want to re-render a component when specific parts of props or state are changing. This can be especially useful when working with large applications or large lists of data. </li>
			</ul>
			<p>There are some more lifecycle methods that aren’t used that often. If you want to check them out, please have a look<a id="_idIndexMarker190"/> at the official documentation here: <a href="https://reactjs.org/docs/react-component.html">https://reactjs.org/docs/react-component.html</a>.</p>
			<p>In this subsection, you learned<a id="_idIndexMarker191"/> the syntax of class components and how to work<a id="_idIndexMarker192"/> with lifecycle methods. To have a direct comparison, we’ll write the same example for function components with Hooks in the next subsection. </p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor074"/>Working with function components and Hooks</h2>
			<p>You should already<a id="_idIndexMarker193"/> be familiar with the function component syntax<a id="_idIndexMarker194"/> since we were using it for the example app in the first section of this chapter. Nevertheless, we’ll have a look at a code example, as we did in the previous subsection about class components, as follows: </p>
			<pre class="source-code">
const App = () =&gt; {
  const [num, setNum] = useState(Math.random() * 100);
  return &lt;Text&gt;This is a random number: {num}&lt;/Text&gt;;
};</pre>
			<p>As you can see, even in this small example, the code is much shorter. A function component is basically nothing else than a function that runs on every re-render. But with Hooks, especially the <strong class="source-inline">useState</strong> hook, function components provide a way of storing data between re-renders.</p>
			<p>We use the <strong class="source-inline">useState</strong> hook to store our <strong class="source-inline">num</strong> variable in the component state. Function components have to return what should be rendered. You can think of the component as a direct <strong class="source-inline">render</strong> function. We can then use the <strong class="source-inline">num</strong> variable to print the random number.</p>
			<p class="callout-heading">Important hint</p>
			<p class="callout">All code that you put in a function component without using Hooks or similar mechanisms runs on every re-render. It is basically the same as putting code in the <strong class="source-inline">render</strong> function of a class component. This means you should only put your declarative UI and cheap data processing operations there. All other operations should be wrapped with Hooks, to prevent performance issues.</p>
			<p>Next, we’ll start an interval<a id="_idIndexMarker195"/> to change the random number every<a id="_idIndexMarker196"/> second. We did the same in the example with the class component. The following code does exactly this in a function component:</p>
			<pre class="source-code">
  useEffect(() =&gt; {
    const interval = setInterval(() =&gt; {
      setNum(Math.random() * 100);
      }, 1000);
    return () =&gt; clearInterval(interval);
  }, []);</pre>
			<p>We use the <strong class="source-inline">useEffect</strong> Hook to start the interval. The <strong class="source-inline">useEffect</strong> interval takes two arguments. The first one is a function that defines the effect that should be run. The second argument is an array, and it defines when the effect should be run. It is optional, and if you don’t provide it, your effect will run on every re-render.</p>
			<p>You can put state variables, other functions, and much more in there. If you do so, the effect will run every time one of the variables in this array changes. In our case, we want the effect to only run once when the component is mounted. To achieve this, we’ll use an empty array as a second argument. </p>
			<p>We also return an anonymous function that clears the interval in the effect. This is a cleanup function. This cleanup function runs when the component unmounts and before running the effect the next time. Since we only run the effect on mount, the cleanup function only runs on unmount.</p>
			<p>If you want to run this example, please<a id="_idIndexMarker197"/> have a look at the following CodeSandbox instance: <a href="https://codesandbox.io/s/function-component-basic-yhsrlo">https://codesandbox.io/s/function-component-basic-yhsrlo</a>.</p>
			<p>After this simple<a id="_idIndexMarker198"/> example, it’s time to take a deeper look at the most<a id="_idIndexMarker199"/> important Hooks. We already used two of them, which are by far the most important ones.</p>
			<h3>Working with stateless function components with useState</h3>
			<p>The <strong class="source-inline">useState</strong> Hook makes it possible<a id="_idIndexMarker200"/> to store information between<a id="_idIndexMarker201"/> re-renders. and create stateful function components. It returns an array with two entries. The first one is the state variable, while the second one is the setter function for the state variable. In most cases, you will use array destructuring to access both entries in one line, as in the following code example: </p>
			<pre class="source-code">
const [example, setExample] = useState(exampleDefaultValue)</pre>
			<p>The <strong class="source-inline">useState</strong> function also takes one argument that you can use to define the default value of the state variable. This is the value it gets initialized with. </p>
			<p>To change the value of the state, you always have to use the setter function. Never set the value directly since this won’t trigger any re-renders or other React internals. </p>
			<p>To change the value and trigger a re-render, you can simply call the setter function with a fixed value. This is how it looks:</p>
			<pre class="source-code">
setExample(newValue)</pre>
			<p>This is what you’ll do most of the time, but you also can pass an update function. This can be very useful when you have to do state updates based on the old state, like this:</p>
			<pre class="source-code">
setExample(prevValue =&gt; prevValue + 1)</pre>
			<p>In this example, we’ll pass a function that takes the previous value as a single argument. We can now use this value to return the new value, which will then be used in the setter. This is especially useful when incrementing or decrementing values. </p>
			<p>Now that we are<a id="_idIndexMarker202"/> able to store data between<a id="_idIndexMarker203"/> re-renders, we’ll want to run some functions after certain events.</p>
			<h3>Using effects with useEffect</h3>
			<p>The <strong class="source-inline">useEffect</strong> Hook is used to run code<a id="_idIndexMarker204"/> after certain events. These events can be the mounting<a id="_idIndexMarker205"/> of a component or an update of a component. The first argument of the <strong class="source-inline">useEffect</strong> Hook has to be a function that will be run when the effect is triggered.</p>
			<p>The second argument is an array that can be used to limit the events the effect should trigger on. It is optional, and when you don’t provide it, the effect runs on mount and on every update that triggers a re-render. If you provide it as an empty array, the effect runs only on mount. If you provide values in the array, the effect is limited to running only if one of the provided values changes. </p>
			<p>There is one very important thing to mention here. If you use references to variables and functions that can change between re-renders inside your <strong class="source-inline">useEffect</strong> Hook, you have to include them in the dependencies. This is because otherwise, you could have a reference to stale data in your <strong class="source-inline">useEffect</strong> Hook. Please have a look at the following diagram for an illustration of this:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B16694_03_04.jpg" alt="Figure 3.4 – References in useEffect&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – References in useEffect</p>
			<p>On the left side, you<a id="_idIndexMarker206"/> see what happens when you don’t include a state<a id="_idIndexMarker207"/> variable—which you access inside your <strong class="source-inline">useEffect</strong> Hook—in the dependencies. In this case, the state variable changes and triggers a re-render, but since your <strong class="source-inline">useEffect</strong> Hook has no connection to the state variable, it does not know that there was a change.</p>
			<p>When the effect runs the next time—for example, triggered by a change in another dependency—you’ll access the stale (old) version of your state variable. This is very important to know because it can lead to very serious and hard-to-find bugs. </p>
			<p>On the right side of the diagram, you see what happens when you include the state variable in the dependencies of the <strong class="source-inline">useEffect</strong> Hook. The <strong class="source-inline">useEffect</strong> Hook now knows when the state variable changes and updates the reference.</p>
			<p>This is the same for functions that you write in your component. Please always keep in mind that every function that you write inside your function component that is not wrapped by a Hook will be recreated on every re-render.</p>
			<p>That means if you want to access functions inside an <strong class="source-inline">useEffect</strong> Hook, you also have to add them to the dependencies. Otherwise, you’ll potentially reference stale versions of these functions. But this leads to another problem. Since the functions are recreated on every re-render, it would trigger your effect on every re-render, and this is something we don’t want most of the time. </p>
			<p>This is where two other<a id="_idIndexMarker208"/> Hooks come into play. It is possible to memoize values<a id="_idIndexMarker209"/> and functions between re-renders, which not only solves our <strong class="source-inline">useEffect</strong> triggering problem but also improves performance significantly.</p>
			<h3>Improving performance with useCallback and useMemo</h3>
			<p>Both <strong class="source-inline">useCallback</strong> and <strong class="source-inline">useMemo</strong> are Hooks<a id="_idIndexMarker210"/> to memoize things between<a id="_idIndexMarker211"/> re-renders. While <strong class="source-inline">useCallback</strong> is provided to memoize a function, <strong class="source-inline">useMemo</strong> is provided to memoize a value. The API of both Hooks is very similar. You provide a function and an array of dependencies. The <strong class="source-inline">useCallback</strong> Hook memoizes the function without executing it, while the <strong class="source-inline">useMemo</strong> Hook executes the function and memoizes the return value of the function. </p>
			<p>Always keep in mind that these hooks are for performance optimization. Especially regarding <strong class="source-inline">useMemo</strong>, the React documentation explicitly state that there is no semantic guarantee that memoization works in every case. This means you have to write your code in a way that works even without memoization. </p>
			<p>You now know the most common Hooks. You’ll get to know some more in <a href="B16694_05.xhtml#_idTextAnchor110"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing States and Connecting Backends</em>. If you want to get a deeper understanding, I can recommend<a id="_idIndexMarker212"/> the official Hooks tutorial in the React documentation: <a href="https://reactjs.org/docs/hooks-reference.html">https://reactjs.org/docs/hooks-reference.html</a>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Besides the Hooks that are provided by React, you can write your own Hooks to share logic between function components. You can call all React Hooks inside your custom Hook. Please stick to the naming convention and always start your custom Hooks with <strong class="source-inline">use</strong>.</p>
			<p>After this extensive look at components, Hooks, and how the React part of React Native works, it’s now time to have a deeper look at the native part. As you learned in <a href="B16694_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">What Is React Native?</em>, React Native has a JavaScript part and a native part.</p>
			<p>As you learned<a id="_idIndexMarker213"/> in the first section of this chapter, React Native<a id="_idIndexMarker214"/> ships with a complete Android project and a complete iOS project. It’s time to have a look at how everything is tied together. </p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor075"/>Connecting different platforms to JavaScript</h1>
			<p>In the first subsection<a id="_idIndexMarker215"/> of this section, we’ll focus on Android and iOS because these are the most common platforms. At the end of this section, we’ll also have a look at how to deploy to the web, Mac, Windows, and even other platforms. </p>
			<p>First, it is important to understand that React Native provides a way of communication between JavaScript and Native. Most of the time, you don’t need to change anything on the native side because the framework itself or some community libraries cover most of the native functionalities, but nevertheless, it is important to understand how it works.</p>
			<p>Let’s start with the UI. When you write your UI in JavaScript, React Native maps your JSX components such as <strong class="source-inline">View</strong> and <strong class="source-inline">Text</strong> to native components such as <strong class="source-inline">UIView</strong> and <strong class="source-inline">NSAttributedString</strong> on iOS or <strong class="source-inline">android.view</strong> and <strong class="source-inline">SpannableString</strong> on Android. The styling<a id="_idIndexMarker216"/> of these native components is done using a layout engine called Yoga. </p>
			<p>While React Native provides a lot of components for Android and iOS, there are some scenarios that don’t<a id="_idIndexMarker217"/> work out of the box. A good example of this is <strong class="bold">Scalable Vector Graphics</strong> (<strong class="bold">SVG</strong>). React Native itself does not provide SVG support but React Native provides the logic it uses to connect JavaScript and native components so that everyone can create their own mappings and components.</p>
			<p>And here comes the large React Native community into play. Nearly every feature is covered by an open source library that provides these mappings, at least for Android and iOS. That’s also the case for SVG support. There is a well-maintained library called <strong class="source-inline">react-native-svg</strong>, which you can find here: <a href="https://github.com/react-native-svg/react-native-svg">https://github.com/react-native-svg/react-native-svg</a>.</p>
			<p>This library provides a <strong class="source-inline">&lt;SVG /&gt;</strong> JavaScript component that under the hood maps to the native SVG implementations on Android and iOS. </p>
			<p>After understanding how UI mapping works, it’s time to have a look at other communication between JavaScript and Native. The second very common use case is the transfer of data such as information about user gestures, sensor information, or other data that can be created on one side and has to be transferred to the other side.</p>
			<p>This is done through connected methods. React Native provides a way to call native methods from JavaScript, pass callback functions to Native, and call these callbacks from Native. This is how data can be transferred in both directions. </p>
			<p>While Android and iOS support comes out of the box, React Native is not limited to these platforms. Microsoft created open source projects called <strong class="source-inline">react-native-windows</strong> and <strong class="source-inline">react-native-macos</strong>. There are a lot of features supported by these projects to bring your app to Windows and macOS.</p>
			<p>There is also a very useful project called <strong class="source-inline">react-native-web</strong> that adds web support to React Native. One important thing to understand is that even if you could use the same code base for all platforms, you might want to adapt it to best practices for the particular platform.</p>
			<p>For example, if you are targeting the web, you might want to optimize your project for search engines, something that is not necessary for Android and iOS apps. There are multiple approaches to handling these platform-specific adjustments. The most common ones will be explained in <a href="B16694_10.xhtml#_idTextAnchor347"><em class="italic">Chapter 10</em></a><em class="italic">, Structuring Large-Scale, Multi-Platform Projects</em>.</p>
			<p>While you can use Android, iOS, Windows, macOS, and the web quite easily, you are not limited to them. Basically, you could use React Native to create apps for any platform, and you would only have to write the native part on your own. </p>
			<p>For a long time, all communication between JavaScript and Native was done asynchronously via JSON over the so-called bridge. While this<a id="_idIndexMarker218"/> works fine for most cases, it can lead to performance issues in some cases.</p>
			<p>Therefore, the React Native<a id="_idIndexMarker219"/> core team at Facebook decided to completely rewrite the React Native Architecture. It took a couple of years, but at the time of writing this book, the new architecture is rolled out at the main Facebook app, and it also landed in the React Native open source repository to be publicly available. You will learn more about the new architecture in the next section.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor076"/>Introducing the new React Native Architecture</h1>
			<p>In the last section, you learned how the connection<a id="_idIndexMarker220"/> between JavaScript and Native works in general. While this general idea does not change, the underlying implementation changes completely. Please have a look at the following diagram:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/B16694_03_05.jpg" alt="Figure 3.5 – The new React Native Architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – The new React Native Architecture</p>
			<p>The core of<a id="_idIndexMarker221"/> the new React Native Architecture is something called <strong class="bold">JavaScript Interface</strong> (<strong class="bold">JSI</strong>). It replaces the old way of communication via the bridge. While communication over the bridge was done with serialized JSON in an asynchronous way, JSI makes it possible for <em class="italic">JavaScript to hold references to C++ host objects and invoke methods on them</em>.</p>
			<p>This means the JavaScript object and the C++ host object connected via JSI will be really aware of each other, which makes synchronous communication possible and makes the need for JSON serialization obsolete. This results in a huge performance boost for all React Native apps.</p>
			<p>Another part of the<a id="_idIndexMarker222"/> rearchitecture is a new renderer called Fabric, which reduces the number of steps done to create a native UI. Also, using JSI, a shadow tree that determines what will be rendered is created directly in C++, while JavaScript also has a reference to it. This means JavaScript and Native can both interact with the shadow tree, which massively improves the responsiveness of the UI.</p>
			<p>The second part<a id="_idIndexMarker223"/> of the rearchitecture that benefits from JSI is called <strong class="bold">Turbo Modules</strong>. It replaces Native Modules, which was the way to connect native modules and JavaScript modules. While the old Native Modules all had to be initialized at startup because JavaScript had no information about the state of the native module, JSI makes it possible to delay the initialization of the module until it is needed.</p>
			<p>Since JavaScript can now hold a direct reference, there is also no need to work with serialized JSON. This results in a significant boost in the startup time for React Native apps.</p>
			<p>There is also<a id="_idIndexMarker224"/> a new developer tool called <strong class="bold">CodeGen</strong> that gets introduced with the new architecture. It uses typed JavaScript to generate corresponding native interface files, to ensure compatibility between JavaScript and the native side. This is very useful when writing own libraries with native code. You will learn more about this in <a href="B16694_10.xhtml#_idTextAnchor347"><em class="italic">Chapter 10</em></a><em class="italic">, Structuring Large-Scale, Multi-Platform Projects</em>, in the Creating Own Libraries section.</p>
			<p>All in all, the new architecture<a id="_idIndexMarker225"/> will bring a huge performance boost on all levels for every React Native app. It will take some time to switch an existing app to the new architecture, and it also will take some time until all common open source libraries have done the switch. But it will happen sooner or later, and it will definitely be worth the work.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor077"/>Summary</h1>
			<p>To end this chapter, let’s have a short summary of what this chapter was about. You learned about what the project structure of a simple React Native app looks like and what the different files are for. You also know about class components and function components, and you understand the most important lifecycle methods and Hooks. Based on this, you can use component states and trigger code execution in both class components and function components. </p>
			<p>You also learned how JavaScript and Native are connected in React Native apps, what the problems are with the current (old) React Native Architecture, and what the new architecture is. </p>
			<p>Now that you have a good overview of how React Native works in general, let’s dive deeper into components, styling, storage, and navigation in the next chapter.</p>
		</div>
	

		<div id="_idContainer018" class="Content">
			<h1 id="_idParaDest-60"><a id="_idTextAnchor078"/>Part 2: Building World-Class Apps with React Native</h1>
			<p>In this part, we will focus on not only creating apps but creating first-class apps with React Native. You will learn what you must pay attention to when working with React Native to create apps with native performance and a world-class user experience.</p>
			<p>The following chapters are in this section:</p>
			<ul>
				<li><a href="B16694_04.xhtml#_idTextAnchor079"><em class="italic">Chapter 4</em></a>, <em class="italic">Styling, Storage, and Navigation in React Native</em> </li>
				<li><a href="B16694_05.xhtml#_idTextAnchor110"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing States and Connecting Backends</em> </li>
				<li><a href="B16694_06.xhtml#_idTextAnchor130"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with Animations </em></li>
				<li><a href="B16694_07.xhtml#_idTextAnchor236"><em class="italic">Chapter 7</em></a>, <em class="italic">Handling Gestures in React Native</em></li>
				<li><a href="B16694_08.xhtml#_idTextAnchor268"><em class="italic">Chapter 8</em></a>, <em class="italic">JavaScript Engines and Hermes </em></li>
				<li><a href="B16694_09.xhtml#_idTextAnchor282"><em class="italic">Chapter 9</em></a>, <em class="italic">Essential Tools for Improving React Native Development </em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer019">
			</div>
		</div>
	</body></html>