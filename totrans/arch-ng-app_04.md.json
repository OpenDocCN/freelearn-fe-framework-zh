["```js\nlet sum = 0;\n\nfunction updateSum(records) {\n  for( let i = 0; i< records.length; i++ ) {\n    sum += records[i]; \n  }\n}\n\nupdateSum([1,2,3,4]);\n```", "```js\n// content of table 'orderitem'\n-------------------\nid  price productId\n-------------------\n1     100   1\n1      50  11  \n\nSELECT \n  SUM(price) as total \nFROM orderitem\n\n// result of the query\n150\n```", "```js\nfunction project(obj, fn) {\n  return fn(obj);\n}\n\nproject( { name : 'chris', age: 37 }, (obj) => obj['name'] ); // 'chris'\nproject({ name : 'chris', age: 37 }, (obj) => obj['age'] ) // 37 \n```", "```js\nfunction notAPureFunction(filePath) {\n  const fileContent = fs.readFileSync(filePath);\n  const rows = fileContent.split(',');\n  let sum = 0;\n  rows.forEach(row => { sum += row; });\n  return sum;\n}\n```", "```js\nfunction calculateSum(rows) {  // now it's pure\n  let sum = 0;\n  rows.forEach(row => { sum += row; });\n  return sum;\n}\n\nfunction getRows(filePath) {  // still not pure, but some things needs to perform side-effects\n  const fileContent = fs.readFileSync(filePath);\n  const rows = fileContent.split(',');\n}\n```", "```js\nfunction something() {\n  statement;\n  statement;\n  if(condition) {\n    something();\n  }\n  return someValue;\n}\n```", "```js\nclass Node {\n  constructor(\n    public left, \n    public value\n  ) {}\n}\n```", "```js\nconst head = new Node(null, 1);\nconst firstNode = new Node(head, 2);\nconst secondNode = new Node(firstNode, 3);\n```", "```js\n// demo of how to find the head node, imperative style\n\nconst head = new Node(null, 1);\nconst firstNode = new Node(head, 2);\nconst secondNode = new Node(firstNode, 3); \n\nfunction findHeadImperative (startNode)  {\n  while (startNode.left !== null) {\n    startNode = startNode.left;\n  }\n  return startNode;\n}\n\nconst foundImp = findHeadImperative(secondNode);\nconsole.log('found', foundImp);\nconsole.log(foundImp === head);\n\n```", "```js\n// demo of how to find head node, declarative style using recursion\n\nconst head = new Node(null, 1);\nconst firstNode = new Node(head, 2);\nconst secondNode = new Node(firstNode, 3); \n\nfunction findHeadRecursive(startNode) {\n  if(startNode.left !== null) {\n    return findHeadRecursive(startNode.left);\n  } else {\n    return startNode;\n  }\n}\n\nconst found = findHeadRecursive(secondNode);\nconsole.log('found', found);\nconsole.log(found === head);\n\n```", "```js\n// demo of printing an array, imperative style\n\nlet array = [1, 2, 3, 4, 5];\n\nfunction print(arr) {\n  for(var i = 0, i < arr.length; i++) {\n    console.log(arr[i]); \n  }\n}\n\nprint(arr);\n```", "```js\n// print.js, printing an array using recursion\n\nlet array = [1, 2, 3, 4, 5];\n\nfunction print(arr, pos, len) {\n  if (pos < len) {\n    console.log(arr[pos]);\n    print(arr, pos + 1, len);\n  }\n  return;\n}\n\nprint(array, 0, array.length);\n```", "```js\nclass NodeClass {\n  constructor(left, right, value) {\n    this.left = left;\n    this.right = right;\n    this.value = value;\n  }\n}\n```", "```js\n// tree.js\n\nclass NodeClass {\n  constructor(left, right, value) {\n    this.left = left;\n    this.right = right;\n    this.value = value;\n  }\n}\n\nconst leftLeftLeftChild = new NodeClass(null, null, 7);\nconst leftLeftChild = new NodeClass(leftLeftLeftChild, null, 1);\nconst leftRightChild = new NodeClass(null, null, 2);\nconst rightLeftChild = new NodeClass(null, null, 4);\nconst rightRightChild = new NodeClass(null, null, 2);\nconst left = new NodeClass(leftLeftChild, leftRightChild, 3);\nconst right = new NodeClass(rightLeftChild, rightRightChild, 5);\nconst root = new NodeClass(left, right, 2);\n\nmodule.exports = root;\n\n```", "```js\n// tree-sum.js\n\nconst root = require('./tree');\n\nfunction summarise(node) {\n  return node.value + node.left.value + node.right.value;\n}\n\nconsole.log(summarise(root)) // 10\n```", "```js\n// example of a non recursive code\n\nfunction summarise(node) {\n  return node.value + \n    node.left.value + \n    node.right.value +\n    node.right.left.value +\n    node.right.right.value + \n    node.left.left.value + \n    node.left.right.value;\n}\n\nconsole.log(summarise(root)) // 19\n```", "```js\nfunction summarise(node) {\n  if(node === null) {\n    return 0;\n  }\n  return node.value + summarise(node.left) + summarise(left.right);\n}\n```", "```js\n// tree.js\n\nclass NodeClass {\n  constructor(left, right, value) {\n    this.left = left;\n    this.right = right;\n    this.value = value;\n  }\n}\n\nconst leftLeftLeftChild = new NodeClass(null, null, 7);\nconst leftLeftChild = new NodeClass(leftLeftLeftChild, null, 1);\nconst leftRightChild = new NodeClass(null, null, 2);\nconst rightLeftChild = new NodeClass(null, null, 4);\nconst rightRightChild = new NodeClass(null, null, 2);\nconst left = new NodeClass(leftLeftChild, leftRightChild, 3);\nconst right = new NodeClass(rightLeftChild, rightRightChild, 5);\nconst root = new NodeClass(left, right, 2);\n\nmodule.exports = root;\n\n// tree-sum.js\n\nconst root = require(\"./tree\");\n\nfunction sum(node) {\n  if (node === null) {\n    return 0;\n  }\n  return node.value + sum(node.left) + sum(node.right);\n}\n\nconsole.log(\"sum\", sum(root));\n```", "```js\n//tree-count.js\n\nconst root = require(\"./tree\");\n\nfunction count(node) {\n  if (node === null) {\n    return 0;\n  } else {\n    return 1 + count(node.left) + count(node.right);\n  }\n}\n\nconsole.log(\"count\", count(root));\n```", "```js\n// tree-width.js\n\nconst root = require(\"./tree\");\n\nfunction calc(node, direction) {\n  if (node === null) {\n    return 0;\n  } else {\n    return (\n      1 + (direction === \"left\" ? \n      calc(node.left, direction) : \n      calc(node.right, direction))\n    );\n  }\n}\n\nfunction calcWidth(node) {\n  return calc(node.left, \"left\") + calc(node.right, \"right\");\n}\n\nconsole.log(\"width\", calcWidth(root));\n```", "```js\nlet newList = list.map(value => value + 1)\n```", "```js\nlet array = [1,2,3];\nlet filtered = array.filter(data => data % 2 === 0);\n```"]