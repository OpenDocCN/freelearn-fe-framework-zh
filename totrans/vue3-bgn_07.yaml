- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Handling API Data and Managing Async Components with Vue.js
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vue.js处理API数据和异步组件管理
- en: In [*Chapter 6*](B21130_06.xhtml#_idTextAnchor074), we focused on how components
    can communicate with each other with the use of properties, which are used for
    parent-to-child communications and events to handle messages sent from a child
    to a parent.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B21130_06.xhtml#_idTextAnchor074)中，我们关注了组件如何通过使用属性进行相互通信，这些属性用于父到子通信，以及事件来处理从子组件发送给父组件的消息。
- en: In this chapter, we will stay on the topic of communication by showing how to
    communicate with an external source, such as an API. External communication is
    a very common method when developing a dynamic website that cannot make use of
    static data, and learning how to manage asynchronous operations will not only
    result in a clean user experience but also help keep the application performant.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续探讨通信的话题，展示如何与外部资源，如API进行通信。在外部通信是开发无法使用静态数据的动态网站时，这是一个非常常见的方法。学习如何管理异步操作不仅会导致干净的用户体验，而且有助于保持应用程序的性能。
- en: Loading data from an external source such as an API makes data handling more
    complicated. In fact, when the data is hardcoded, we do not have to worry about
    anything, as the information is immediately available, while when working with
    data that comes from an external source, we need to not only think about the empty
    state that the app will be while the data is loaded but also consider the possibility
    of the data failing to load.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部源，如API加载数据使得数据处理更加复杂。实际上，当数据是硬编码时，我们不需要担心任何事情，因为信息是立即可用的。而当我们处理来自外部源的数据时，我们不仅需要考虑数据加载期间应用程序的空状态，还要考虑数据加载失败的可能性。
- en: We will start the chapter by removing the hardcoded posts and loading them dynamically;
    we will then do the same with the comments by making the data on-demand. We will
    then enhance our application to automatically load more posts, using `watch`.
    Finally, we will learn how to define and use asynchronous components using `<Suspense>`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先移除硬编码的帖子并动态加载它们；然后我们将对评论做同样的处理，通过按需加载数据。然后我们将增强我们的应用程序，使其能够自动使用`watch`加载更多帖子。最后，我们将学习如何使用`<Suspense>`定义和使用异步组件。
- en: 'The chapter will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Loading data from an API using the Vue.js life cycle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vue.js生命周期从API加载数据
- en: Watching for changes in components using `watch` functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`watch`函数监视组件中的变化
- en: Handling asynchronous components with Suspense
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Suspense处理异步组件
- en: By the end of the chapter, you will have learned how to load data and components
    dynamically. You will know how to create components that load data on demand and
    what benefits this brings to our application. You will also be able to handle
    side effects using `watch` and, finally, define and take care of asynchronous
    components to ensure your application is rendered correctly.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何动态加载数据和组件。你将知道如何创建按需加载数据的组件，以及这给我们的应用程序带来的好处。你还将能够使用`watch`处理副作用，最后定义并处理异步组件以确保应用程序正确渲染。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, the branch is called `CH07`. To pull this branch, run the
    following command or use your GUI of choice to support you in this operation:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，分支被称作`CH07`。要拉取这个分支，运行以下命令或使用您选择的GUI来支持此操作：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As part of this chapter, we are also going to use an external resource called
    Dummyapi.io. This website will provide a dummy API that we will use to load our
    post dynamically. To be able to use the API, you need to register and generate
    an **APP ID**. Creating an **APP ID** is completely free and can be obtained by
    creating an account on the following link ([https://dummyapi.io/sign-in](https://dummyapi.io/sign-in)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的一部分，我们还将使用一个名为Dummyapi.io的外部资源。这个网站将提供一个模拟API，我们将用它来动态加载我们的帖子。要使用API，您需要注册并生成一个**APP
    ID**。创建**APP ID**是完全免费的，您可以通过以下链接创建账户来获取：[https://dummyapi.io/sign-in](https://dummyapi.io/sign-in)。
- en: This new branch, `CH07`, includes just a couple of style changes and the replacement
    of the native button with the custom button component that we created in the last
    chapter, `TheButton.vue`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新分支，`CH07`，仅包含一些样式更改以及用我们在上一章`TheButton.vue`中创建的自定义按钮组件替换了原生按钮。
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该章节的代码文件可以在[https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners)找到。
- en: Loading data from an API using the Vue.js life cycle
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vue.js生命周期从API加载数据
- en: It is common for most of the applications that are built for the web to expose
    a level of dynamic content. Providing the ability to load information on the fly
    has been one of the most important factors that led to the growth of JavaScript
    frameworks, such as Vue.js.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数为网络构建的应用来说，暴露一定程度的动态内容是很常见的。提供即时加载数据的能力是JavaScript框架（如Vue.js）增长的最重要因素之一。
- en: Until now, the Companion App has been built using static data that is loaded
    directly within the components. Hardcoded values are not very common in real applications,
    and the posts and comments used within the application were just a stopgap to
    help us focus on the basic features of Vue.js, but it is now time to learn how
    to load data dynamically.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，伴随应用一直是使用直接在组件中加载的静态数据构建的。在真实应用中，硬编码的值并不常见，应用中使用的帖子评论只是权宜之计，帮助我们专注于Vue.js的基本功能，但现在是我们学习如何动态加载数据的时候了。
- en: Being able to successfully handle asynchronous data load is very important.
    No matter how big or small your next application will be, it is very likely that
    you will be required to handle external data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 能够成功处理异步数据加载非常重要。无论你的下一个应用有多大或多小，你很可能需要处理外部数据。
- en: In this section, we are going to update two parts of our application. First,
    we are going to update `SocialPosts.vue` to load the post from an external source,
    and then we are going to change `SocialPostComments.vue` to also load comments
    dynamically but with a little twist, as we will implement something called “loading
    data on demand.” We will then briefly discuss the implications that dynamic loading
    can have on performance and the user experience of our application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更新我们应用的两个部分。首先，我们将更新`SocialPosts.vue`以从外部源加载帖子，然后我们将更改`SocialPostComments.vue`以动态加载评论，但会有一个小变化，因为我们将会实现一个叫做“按需加载数据”的功能。然后我们将简要讨论动态加载可能对我们应用性能和用户体验产生的影响。
- en: Loading social posts from an API
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从API加载数据的社会帖子
- en: Until now, the posts that our application displayed were always the same due
    to the hardcoded array of `posts` defined in `SocialPosts.vue`. In this section,
    we are going to use a public API offered by **DummyAPI** ([https://dummyapi.io/](https://dummyapi.io/))
    to make our post dynamic.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应用显示的帖子总是相同的，这是由于在`SocialPosts.vue`中定义的`posts`数组是硬编码的。在本节中，我们将使用**DummyAPI**提供的公共API（[https://dummyapi.io/](https://dummyapi.io/))来使我们的帖子动态化。
- en: Services such as **DummyAPI** are very useful to develop application scaffolding
    and to help you practice your skills. There are plenty of free services like this
    one available on the internet, and they can easily be found using a search engine.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**DummyAPI**等服务对于开发应用框架和帮助你练习技能非常有用。互联网上有许多这样的免费服务，并且可以通过搜索引擎轻松找到。'
- en: Research is part of development
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 研究是开发的一部分
- en: Spend a couple of minutes navigating through the **DummyAPI** website and try
    to understand how we will use the API and what endpoints we will use. Learning
    external resources is a very important part of web development.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 花几分钟时间浏览**DummyAPI**网站，尝试理解我们将如何使用API以及我们将使用哪些端点。学习外部资源是网络开发中非常重要的一个部分。
- en: 'Loading external data will be achieved using Vue.js methods, the native Fetch
    API, and Vue.js life cycles. First, we are going to remove the old, hardcoded
    data from `SocialPosts.vue`. This file can be found in the `molecules` folder,
    as it is a component that renders a big section of our Companion App homepage:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vue.js方法、原生的Fetch API和Vue.js生命周期将实现外部数据的加载。首先，我们将从`SocialPosts.vue`中移除旧的、硬编码的数据。这个文件可以在`molecules`文件夹中找到，因为它是一个渲染我们伴随应用主页大部分内容的组件：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, in the same file, we are going to create a method that calls the external
    API to fetch our new posts:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在同一文件中，我们将创建一个调用外部API以获取新帖子的方法：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code uses the native JavaScript `fetch` method ([https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API))
    to send a `GET` request to the [dummyapi.io](http://dummyapi.io) API. Due to the
    API requirements, we need to pass `app-id` with the request. This can be obtained
    for free, as mentioned in the *Technical* *requirements* section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用原生的JavaScript `fetch`方法([https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API))向[dummyapi.io](http://dummyapi.io)
    API发送`GET`请求。由于API的要求，我们需要在请求中传递`app-id`。正如*技术要求*部分所述，这可以免费获得。
- en: We then fetch the result in the `json` format using `response.json()` and, finally,
    append the returned data to the post’s `Reactive` property.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用`response.json()`以`json`格式获取结果，最后将返回的数据追加到帖子的`Reactive`属性中。
- en: After the method has been defined, it is time to “call” it. When triggering
    an `async` request like in this case, we take advantage of the Vue.js life cycle
    to ensure that our request is triggered at the correct time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义方法之后，是时候“调用”它了。在这种情况下，当触发一个`async`请求时，我们利用Vue.js的生命周期来确保我们的请求在正确的时间被触发。
- en: 'In [*Chapter 2*](B21130_02.xhtml#_idTextAnchor028), we introduced the different
    life cycles and mentioned that the `created` life cycle is the correct one for
    asynchronous data. Our description of it was as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B21130_02.xhtml#_idTextAnchor028)中，我们介绍了不同的生命周期，并提到`created`生命周期是异步数据的正确选择。我们对它的描述如下：
- en: “[The `created` life cycle] is the perfect stage to trigger asynchronous calls
    to gather some data. Triggering slow requests now will help us save some time,
    as this request will continue behind the scenes while our component is being rendered.”
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: “[`created`生命周期]是触发异步调用来收集数据的完美阶段。现在触发慢速请求将帮助我们节省时间，因为这个请求将在组件渲染的同时在幕后继续。”
- en: 'Let’s go and call our newly created method, `fetchPosts`, during the created
    life cycle. In contrast to other life cycles such as `mounted`, `created` does
    not need to be explicitly defined. The explanation from the official documentation
    is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去调用我们新创建的方法`fetchPosts`，在`created`生命周期中。与`mounted`等其他生命周期不同，`created`不需要显式定义。官方文档的解释如下：
- en: “Because `setup` is run around the `beforeCreate` and `created` lifecycle hooks,
    you do not need to explicitly define them. In other words, any code that would
    be written inside those hooks should be written directly in the `setup` function.”
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: “因为`setup`是在`beforeCreate`和`created`生命周期钩子周围运行的，所以你不需要显式地定义它们。换句话说，任何应该写入这些钩子内部的代码都应该直接写在`setup`函数中。”
- en: 'This simplifies our requirement, meaning that all we need to do is call the
    method after it is defined within the body of our component’s JavaScript logic:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这简化了我们的需求，意味着我们只需要在我们的组件JavaScript逻辑体中定义方法后调用它：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At this stage, our posts should be dynamically loaded from the API, but the
    work is not done yet; in fact, the application displays the posts incorrectly:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们的帖子应该从API动态加载，但工作还没有完成；事实上，应用程序显示的帖子是错误的：
- en: '![Figure 7.1: The Companion App displaying a broken UI](img/B21130_07_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：显示损坏UI的伴侣应用](img/B21130_07_01.jpg)'
- en: 'Figure 7.1: The Companion App displaying a broken UI'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：显示损坏UI的伴侣应用
- en: What caused the preceding error?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上述错误是由什么引起的？
- en: Before reading the answer, why don’t you try to investigate what could have
    caused the issue with the rendering displayed in *Figure 7**.1*? How would you
    go about fixing it?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读答案之前，你为什么不尝试调查一下是什么导致了*图7.1*中显示的渲染问题呢？你会如何着手修复它？
- en: The data fetched by the API is loaded and applied to our “posts” successfully,
    but the structure of the data does not match the one that we previously had set.
    This problem is related to the advanced properties settings that we just learned
    about in the previous chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: API获取的数据已成功加载并应用于我们的“posts”，但数据的结构并不符合我们之前设置的。这个问题与我们之前章节中学到的高级属性设置有关。
- en: Fixing the SocialPost.vue properties’ misalignment
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复SocialPost.vue属性的不匹配
- en: Misaligned props are something that is very common in real applications, but
    they can be avoided. In fact, the reason why the app is rendering a broken UI
    is that we have not specified which properties are expected to be “required” in
    `SocialPost.vue`, and as a result, Vue.js tries to render the app with the data
    it has, resulting in the missing data being set as `null`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，属性不匹配是非常常见的问题，但这是可以避免的。事实上，应用渲染出破碎的用户界面是因为我们没有指定在`SocialPost.vue`中哪些属性是期望的“必需”属性，因此Vue.js试图使用它拥有的数据来渲染应用，导致缺失的数据被设置为`null`。
- en: 'Let’s compare the previous hardcoded structure of the posts array with the
    new structure received by the API to see how the two structures compare and what
    changes are required to ensure the Companion App can correctly render the post
    information:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较帖子数组之前的硬编码结构与通过API接收的新结构，看看这两个结构如何比较以及确保伴侣应用可以正确渲染帖子信息所需进行的更改：
- en: '![Figure 7.2: The transition between the previous structure of posts and the
    new one provided by the API](img/B21130_07_02_BW.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2：帖子之前结构与新API提供结构的过渡](img/B21130_07_02_BW.jpg)'
- en: 'Figure 7.2: The transition between the previous structure of posts and the
    new one provided by the API'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：帖子之前结构与新API提供结构的过渡
- en: '*Figure 7**.2* displays the changes we are going to make in our application
    to align with the new data. Some of the fields need to change to match the new
    object properties, and comments and retweets have been removed altogether. Calling
    the `<SocialPost>` component will now be changed to the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.2* 显示了我们将要对我们应用进行的更改以适应新的数据。一些字段需要更改以匹配新的对象属性，评论和转发已被完全移除。调用`<SocialPost>`组件现在将更改为以下内容：'
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding highlighted code shows the difference between the old and new
    component instances. Note that we had to replace `userId` with just `id`, which
    will be required later. It is now time to modify the child component to make sure
    it can function with the new data. This will involve a couple of steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上述突出显示的代码显示了旧组件实例与新组件实例之间的差异。请注意，我们必须将`userId`替换为仅`id`，这将在以后是必需的。现在，是时候修改子组件以确保它可以与新数据一起工作。这将涉及几个步骤：
- en: 'Remove `UserId` from the UI, as it is too long:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从UI中移除`UserId`，因为它太长了：
- en: '[PRE5]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Remove `comments` and `retweets` from the `props` declaration:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`props`声明中移除`comments`和`retweets`：
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Refactor `interactions` and `commentsNumber` from the UI and replace them with
    just `likes`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将UI中的`interactions`和`commentsNumber`重构为仅`likes`：
- en: '[PRE17]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Remove the logic associated with `interactions` and `commentsNumber`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除与`interactions`和`commentsNumber`相关的逻辑：
- en: '[PRE23]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: <TheButton
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <TheButton
- en: '[PRE31]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: v-show="hasComments"
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: v-show="hasComments"
- en: '[PRE32]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '@click="onShowCommentClick"'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@click="onShowCommentClick"'
- en: '[PRE33]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: value="Show comment"
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: value="显示评论"
- en: '[PRE34]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: width="auto"
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: width="auto"
- en: '[PRE35]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: theme="dark"
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: theme="dark"
- en: '[PRE36]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: />
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: />
- en: '[PRE37]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding changes may seem quite complicated when reading them out, but
    they follow a logical pattern. They are all connected to each other, a modification
    in one component may result in a change in another and so on. For example, removing
    the `retweet` props in the parent would then result in the props being removed
    from the child component within `defineProps`, and consequently, the removal of
    any code logic attached to those props, and finally, any use of the props in the
    component template.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当阅读这些更改时，它们可能看起来相当复杂，但它们遵循一个逻辑模式。它们都是相互关联的，一个组件的修改可能会导致另一个组件的变化，依此类推。例如，从父组件中移除`retweet`属性会导致在`defineProps`中的子组件属性被移除，进而导致与这些属性相关联的任何代码逻辑被移除，最终，组件模板中任何对这些属性的引用也会被移除。
- en: As you get more familiar with the framework, the preceding changes will feel
    trivial, but I have added them here and covered them step by step on purpose to
    give you some idea of how to logically think about a component and its data flow.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对框架越来越熟悉，上述更改将显得微不足道，但我故意在这里添加它们并逐步介绍，是为了给你一些关于如何逻辑思考组件及其数据流的思路。
- en: 'At this stage, the application should render correctly, and the home page should
    display posts coming from the dummy API we have implemented:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，应用应该可以正确渲染，主页应该显示来自我们已实现的虚拟API的帖子：
- en: '![Figure 7.3: The Companion App displaying posts from the external API](img/B21130_07_03.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3：显示来自外部API的帖子伴侣应用](img/B21130_07_03.jpg)'
- en: 'Figure 7.3: The Companion App displaying posts from the external API'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：显示来自外部API的帖子伴侣应用
- en: The Companion App displays the post correctly again, but something is still
    missing. The logic that was used to display the comment does not work correctly
    anymore.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随应用程序正确地显示了帖子，但仍然缺少一些东西。用于显示评论的逻辑现在不再正确工作。
- en: Before we move forward, you should improve the component that we just made to
    make it more reliable, by improving its properties.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，你应该通过改进其属性来提高我们刚刚制作的组件的可靠性。
- en: Your turn – improve the properties set in SocialPost.vue
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务 - 改进 `SocialPost.vue` 中的属性
- en: Spend a few minutes to enhance the props set in `SocialPost.vue`. Look at each
    props and decide if they should be required, by using the `required` attribute
    on props or if they could be set to optional by defining a `default` value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 花几分钟时间来增强 `SocialPost.vue` 中设置的属性。查看每个属性，并决定是否应该使用 `required` 属性将其设置为必需的，或者是否可以通过定义
    `default` 值将其设置为可选的。
- en: Load comments on demand
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按需加载评论
- en: When the `posts` data was hardcoded, the comments associated with the individual
    post were available on the first render, and we were able to pass them immediately
    between the parent and child components. But now that the information is loaded
    dynamically, we can change our logic to just load the comments on demand.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `posts` 数据是硬编码时，与单个帖子相关联的评论在第一次渲染时是可用的，并且我们可以立即在父组件和子组件之间传递它们。但现在信息是动态加载的，我们可以改变我们的逻辑，只按需加载评论。
- en: Imagine an application where all the data is loaded on the main page and has
    to be passed around between tens of components. No matter how hard you would work,
    the code would be quite hard to maintain. Passing properties through many layers
    of components is known in the industry as “props drilling.”
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个应用程序，其中所有数据都在主页上加载，并且需要在数十个组件之间传递。无论你多么努力工作，代码都很难维护。在组件多层之间传递属性在业界被称为“属性钻取”。
- en: 'Props drilling can be avoided using two techniques:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用两种技术来避免属性钻取：
- en: Loading data on demand
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按需加载数据
- en: Using state management
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态管理
- en: In this chapter, we are going to cover the first technique, loading data on
    demand, while state management will be covered later in [*Chapter 11*](B21130_11.xhtml#_idTextAnchor153).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍第一种技术，按需加载数据，而状态管理将在[*第11章*](B21130_11.xhtml#_idTextAnchor153)中稍后介绍。
- en: Making a change like the one we just performed prevents some data from being
    loaded immediately, with it just being fetched on demand. This is a very good
    practice to improve both performance and code structure.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才执行的改变防止了一些数据立即加载，而是按需获取。这是一个非常好的实践，可以提高性能和代码结构。
- en: When analyzing how comments behave in our application, we can see that it would
    be quite wasteful to load all comments associated with the posts immediately,
    when we know that the application will just display them on user interaction (a
    button click).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当分析评论在我们应用程序中的行为时，我们可以看到，当我们知道应用程序将仅在用户交互（按钮点击）时显示它们时，立即加载与帖子相关联的所有评论将是相当浪费的。
- en: We are going to work on two files. First, we are going to replace the `comments`
    property from `SocialPost.vue` with the post ID. Then, we will create the functionality
    required to load the comments on demand in `SocialPostComments.vue`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理两个文件。首先，我们将用帖子 ID 替换 `SocialPost.vue` 中的 `comments` 属性。然后，我们将在 `SocialPostComments.vue`
    中创建按需加载评论所需的功能。
- en: 'At this point, you should have enough knowledge to remove the `comments` property
    from the component and replace it with another property, called `post-id`. This
    will be used later to request the correct comments from the dummy API, and the
    code changes should be the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该有足够的知识来从组件中移除 `comments` 属性，并用另一个名为 `post-id` 的属性替换它。这将在稍后用于从模拟API请求正确的评论，代码更改应如下所示：
- en: '[PRE38]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Because the `comments` property was already removed from `defineProps` in the
    previous section of this chapter, all that was left to do was to ensure that we
    removed the prop from the `<SocialPostComments>` component declaration and replaced
    it with one called `post-id`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在上一节中，`comments` 属性已经被从 `defineProps` 中移除，所以剩下的工作就是确保我们从 `<SocialPostComments>`
    组件声明中移除该属性，并用一个名为 `post-id` 的属性替换它。
- en: 'The next step requires us to rewrite the logic that handles the load of the
    comments. We will start by modifying the properties, by removing the `comments`
    one and replacing it with the newly passed `post-id`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步需要我们重写处理评论加载的逻辑。我们将从修改属性开始，移除 `comments` 并用新传递的 `post-id` 替换它：
- en: '[PRE39]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The ID of the post is required for us to be able to fetch the correct comments
    from the API. It is very common when passing IDs around to prefix them with the
    actual context. So, in our case, instead of naming our prop ID, we named it `postId.`
    Small improvements such as this can really help keep your code clean and readable.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要帖子 ID 才能从 API 获取正确的评论。在传递 ID 时，通常会在其前面加上实际上下文作为前缀。因此，在我们的情况下，我们不是将我们的 prop
    ID 命名为 `postId`，而是将其命名为 `postId.` 这样的小改进真的可以帮助保持你的代码整洁和可读。
- en: Defining multiword props using kebab case
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用短横线命名法定义多词属性
- en: Did you notice that the property we just defined is called `postId` in the component
    declaration but is passed in the component using kebab case, `post-id`? HTML is
    not case-sensitive, so using `postId` would just mean the same as `postid`. Therefore,
    to ensure that we better define the multiword props, we use kebab case – that
    is, “word-word.”
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到我们刚刚定义的属性在组件声明中被称为 `postId`，但在组件中使用时使用的是短横线命名法，`post-id`？HTML 不区分大小写，所以使用
    `postId` 就等同于 `postid`。因此，为了更好地定义多词属性，我们使用短横线命名法——即“单词-单词。”
- en: It is now time to make the necessary changes to ensure that `SocialPostComments.vue`
    works correctly with the new posts structure and create the logic required to
    load the comments on demand.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候进行必要的更改，以确保 `SocialPostComments.vue` 能够正确地与新的帖子结构一起工作，并创建加载评论所需的逻辑。
- en: We are going to use the following path from the API, `/post/{postId}/comment`.
    This is going to return us the comment from a given `postId`, where `postId` is
    the actual ID of the post selected.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下 API 路径，`/post/{postId}/comment`。这将返回给定 `postId` 的评论，其中 `postId` 是所选帖子的实际
    ID。
- en: 'Let’s break down all the changes required:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解所有需要进行的更改：
- en: 'First, we import `reactive`from `vue` and use it to define a new array for
    `comments`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们从 `vue` 中导入 `reactive` 并使用它来定义一个新的 `comments` 数组：
- en: '[PRE40]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Second, we create a new method called `fetchComments` that accepts a parameter
    of `postId`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二，我们创建了一个名为 `fetchComments` 的新方法，它接受一个名为 `postId` 的参数：
- en: '[PRE45]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we create a fetch request in the body of the newly created method and
    use `postId` to create the correct request URL. Just like before, we make sure
    to pass the correct `app-id`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在新创建的方法体中创建一个获取请求，并使用 `postId` 创建正确的请求 URL。就像之前一样，我们确保传递正确的 `app-id`：
- en: '[PRE46]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, we fetch the response JSON and assign it to the `comments` reactive:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们获取响应的 JSON 并将其分配给 `comments` 响应式：
- en: '[PRE55]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, we call this function when the component loads. As mentioned before,
    calling a function within the script setup body is equivalent to calling it on
    the created life cycle. The function will receive the `postId` property as its
    argument:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在组件加载时调用此函数。如前所述，在脚本设置体中调用函数等同于在创建生命周期中调用它。该函数将接收 `postId` 属性作为其参数：
- en: '[PRE60]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'At this stage, our Companion App will render the `comments` body that is currently
    received from the API request:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们的伴侣应用将渲染从 API 请求中接收到的 `comments` 内容：
- en: '![Figure 7.4: The comments body displayed in the Companion App](img/B21130_07_04.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4：在伴侣应用中显示的评论正文](img/B21130_07_04.jpg)'
- en: 'Figure 7.4: The comments body displayed in the Companion App'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：在伴侣应用中显示的评论正文
- en: 'From the screenshot displayed in *Figure 7**.4*, we can deduce that there are
    two main changes that we need to implement in the component:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从显示在 *图 7.4** 中的截图，我们可以推断出我们需要在组件中实施的两个主要更改：
- en: Improve the UI when no comments are available
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当没有评论可用时改进 UI
- en: Format the body of the comments to just show the author’s name and the message,
    instead of the raw object received by the API
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化评论的正文，只显示作者的名字和消息，而不是 API 接收到的原始对象
- en: 'To improve the user experience and show a different message if there is a post
    with no comments, we can use the built-in `v-if` and `v-else` directives:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高用户体验，并在没有评论的帖子中显示不同的消息，我们可以使用内置的 `v-if` 和 `v-else` 指令：
- en: '[PRE64]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Just like a simple `if`/`else` statement, when a Vue.js component receives elements
    that include a `v-if` and `v-else` directives, it will just render one of the
    two, depending on the condition received. In our case, the first block will be
    rendered if the comments array is empty and has a length of zero, while the second
    block will render if comments are available.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 就像简单的 `if`/`else` 语句一样，当一个 Vue.js 组件接收到包含 `v-if` 和 `v-else` 指令的元素时，它将只渲染两个中的一个，具体取决于接收到的条件。在我们的例子中，如果评论数组为空且长度为零，则将渲染第一个块，而如果存在评论，则将渲染第二个块。
- en: Use <template> to avoid unused HTML elements
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `<template>` 避免未使用的 HTML 元素
- en: You may have noticed that we used an element called `<template>` when introducing
    the `v-if`/`v-else` code block. The `<template>` element is a special Vue.js element
    that allows you to add logic without the need to add an HTML element. In fact,
    if the template element was not available, we would have had to add `<span>` or
    `<div>` just to allow us to add our logic. Every time you use the `<template>`
    element, it will disappear and will not render anything within the DOM. It is
    very useful in logic that uses `v-if`, `v-else`, `v-if-else`, or `v-for`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在介绍`v-if`/`v-else`代码块时，我们使用了名为`<template>`的元素。`<template>`元素是一个特殊的Vue.js元素，它允许您在不添加HTML元素的情况下添加逻辑。实际上，如果模板元素不可用，我们就必须添加`<span>`或`<div>`来仅允许我们添加逻辑。每次您使用`<template>`元素时，它都会消失，并且不会在DOM中渲染任何内容。它在使用`v-if`、`v-else`、`v-if-else`或`v-for`的逻辑中非常有用。
- en: Let’s fill in the code blocks that we just created with the correct HTML. The
    first block will just show a static message for the empty state, while for the
    second, we need to analyze the object received by the API and understand what
    we want to display.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用正确的HTML填充我们刚刚创建的代码块。第一个块将仅显示一个静态消息用于空状态，而对于第二个，我们需要分析API接收到的对象，并理解我们想要显示的内容。
- en: 'It is now time to focus on the structure of the comments. The `comment` object
    seems to include multiple properties, but the only ones we should use are the
    name of the user and the message, therefore `owner.firstName` and `message`, respectively:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候关注注释的结构了。`comment`对象似乎包含多个属性，但我们应该使用的只有用户名和消息，因此分别是`owner.firstName`和`message`：
- en: '[PRE65]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `v-if` statement includes a simple static message, while `v-else` contains
    a loop created using the `v-for` directives, `<div v-for="{owner, message} in
    comments" class="comment">`, that includes two mustache templates to format our
    string, `<p>{{ owner.firstName }}: <strong>{{` `message }}</strong></p>`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-if`语句包含一个简单的静态消息，而`v-else`包含一个使用`v-for`指令创建的循环，`<div v-for="{owner, message}
    in comments" class="comment">`，它包括两个mustache模板来格式化我们的字符串，`<p>{{ owner.firstName
    }}: <strong>{{ message }}</strong></p>`。'
- en: After the latest modification, our Companion App should display a nicely formatted
    layout for our comments.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 经过最新的修改后，我们的Companion App应该会显示一个格式良好的布局来展示我们的注释。
- en: '![Figure 7.5: The Companion App’s formatted comments](img/B21130_07_05.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5：Companion App的格式化注释](img/B21130_07_05.jpg)'
- en: 'Figure 7.5: The Companion App’s formatted comments'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：Companion App的格式化注释
- en: In this section, we learned how to load information asynchronously using an
    external API; we then walked through the changes necessary to ensure our application
    can work with the new dynamic data. The section also included a few tips to help
    you improve your Vue.js skills, such as the use of `<template>` to keep the HTML
    clean, the need to declare multi-word properties with kebab case, and the defining
    good properties to ensure that our components will not render incorrectly if any
    of the values are missing.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用外部API异步加载数据；然后我们探讨了确保我们的应用程序能够与新动态数据一起工作的必要更改。本节还包含了一些有助于提高您Vue.js技能的技巧，例如使用`<template>`来保持HTML的整洁，需要用短横线命名法声明多词属性，以及定义良好的属性以确保我们的组件在值缺失时不会渲染错误。
- en: In the next section, we are going to learn how to trigger side effects, such
    as API requests, when watching for components’ data changes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在监视组件数据变化时触发副作用，例如API请求。
- en: Watching for changes in components using watch
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用watch监视组件的变化
- en: In the previous section, we learned how to load our data dynamically by triggering
    an API request during the component rendering cycle. In this section, we will
    see another aspect of asynchronous data loading by describing how to handle API
    requests, triggered as a side effect when watching for data changes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们学习了如何在组件渲染周期中触发API请求来动态加载数据。在本节中，我们将通过描述如何处理作为监视数据变化副作用触发的API请求来展示异步数据加载的另一个方面。
- en: As we learned in [*Chapter 5*](B21130_05.xhtml#_idTextAnchor060)*,* computed
    properties are a great asset to watch other properties and internal data to create
    new variables, but they are not handy when we need to trigger a side effect, such
    as a DOM change or an API call.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第五章*](B21130_05.xhtml#_idTextAnchor060)*中学习的那样，计算属性是监视其他属性和内部数据以创建新变量的绝佳工具，但当我们需要触发副作用时，例如DOM更改或API调用，它们就不太方便了。
- en: This is where a Vue.js feature called `watch` comes to the rescue. `watch`,
    just like `computed`, allows you to listen to any changes that occur to properties,
    reactive data, or another computed property, but it also provides you the ability
    to trigger a callback when data changes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Vue.js的一个功能`watch`发挥作用的地方。`watch`就像`computed`一样，允许你监听任何属性、响应式数据或另一个计算属性的变化，但它还提供了在数据变化时触发回调的能力。
- en: watch is just for edge cases, not everyday use
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`watch`仅用于边缘情况，而不是日常使用'
- en: If you find yourself using `watch` often during your development, it means that
    you are using `methods` and `computed` incorrectly. It is very common for inexperienced
    Vue.js developers to overuse `watch`. I have personally used it just a handful
    of times in years of development.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现在开发过程中经常使用`watch`，这意味着你使用`methods`和`computed`的方式不正确。对于经验不足的Vue.js开发者来说，过度使用`watch`是非常常见的。我个人在多年的开发中只使用了它几次。
- en: We are going to change our application to automatically load more posts if there
    are fewer than four posts shown on screen. As mentioned previously, we are going
    to watch for a component variable (in our case, the `posts` array), and we are
    then going to trigger a side effect (in our case, another API call) when a certain
    condition is met.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改我们的应用程序，使其在屏幕上显示的帖子少于四个时自动加载更多帖子。如前所述，我们将监视一个组件变量（在我们的例子中，是`posts`数组），然后在满足一定条件时触发副作用（在我们的例子中，是另一个API调用）。
- en: 'Let’s develop this together. First, we need to update our `fetch` method to
    accept a page parameter to ensure that we fetch new posts and not always the same
    ones:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起来开发这个功能。首先，我们需要更新我们的`fetch`方法，使其接受一个页面参数，以确保我们获取新的帖子而不是总是相同的帖子：
- en: '[PRE66]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `fetchPosts` method now accepts a parameter of `page` and appends it to
    the request query parameter, `` `${baseUrl}/post?limit=5&page=${page}` ``.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchPosts`方法现在接受一个名为`page`的参数，并将其附加到请求查询参数中，``${baseUrl}/post?limit=5&page=${page}``。'
- en: 'We are then going to create a new ref called `page` that will hold the current
    page value. To accomplish this, we are going to import `ref` from Vue.js:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个新的`ref`名为`page`，它将保存当前页面的值。为了实现这一点，我们将从Vue.js导入`ref`：
- en: '[PRE67]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, we define and initialize the variable. Because the first page of the
    posts is going to be 0, we are going to use this number as the initialization
    value:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义并初始化变量。因为帖子列表的第一页将是0，我们将使用这个数字作为初始化值：
- en: '[PRE68]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Lastly, we are going to pass this `ref` when calling `fetchPosts`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在调用`fetchPosts`时传递这个`ref`：
- en: '[PRE69]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Remember that because we used `ref` to define our page variable, we need to
    use the `.value` notation to access its value.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，因为我们使用了`ref`来定义我们的页面变量，所以我们需要使用`.value`表示法来访问它的值。
- en: 'Now, it is time to create our `watch`. Just like `computed`, `watch` will depend
    on one or more other reactive values, like `Ref` and `Reactive`, and will include
    a callback value. The syntax is `watch( dependentData, callback(newValue, oldValue))`.
    So, in our case, the code would look like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候创建我们的`watch`了。就像`computed`一样，`watch`将依赖于一个或多个其他响应式值，如`Ref`和`Reactive`，并将包含一个回调值。语法是`watch(依赖数据,
    回调函数(新值, 旧值))`。所以，在我们的情况下，代码将看起来像这样：
- en: '[PRE70]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`watch` is meant to observe variable changes and trigger a callback. In our
    example, the application observes the variable called `posts` and triggers a callback
    that will change the `page` variable and fetch new posts, using our API. The callback
    triggered by `watch` offers two values; the first is the new value that the observed
    variable has received, and the second is the old value.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`watch`是用来观察变量变化并触发回调的。在我们的例子中，应用程序会观察名为`posts`的变量，并在触发回调时更改`page`变量并获取新的帖子，使用我们的API。由`watch`触发的回调提供两个值；第一个是观察变量接收的新值，第二个是旧值。'
- en: Most of the time, you will probably just use the first value (therefore, the
    new value of the observed data), but having access to both values is very useful
    when the effect triggered is dependent on the “change” of the variable. For example,
    this may be needed if you have an animation that shows different effects, depending
    on whether the value increases or decreases. This would only be possible if you
    have both the old and the new values to compare.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你可能只会使用第一个值（因此，观察数据的新值），但是当触发的效果依赖于变量的“变化”时，访问这两个值非常有用。例如，如果你有一个根据值增加或减少显示不同效果的动画，这可能就是必要的。这只有在你有旧值和新值进行比较的情况下才可能实现。
- en: Our Companion App should now be ready to be tested. To test our new functionality,
    delete a couple of posts by clicking the delete icon next to them, and then see
    the new posts load dynamically.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的伴侣应用现在应该准备好进行测试了。为了测试我们的新功能，点击它们旁边的删除图标删除几篇帖子，然后查看新帖子动态加载。
- en: There are a few more options available with `watch`, such as the ability to
    trigger it after the effect has taken place in the DOM, or the possibility to
    trigger it immediately when the component renders. However, these are out of the
    scope of this book, as they are for more advanced use and would just be confusing
    at this stage.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`watch`还有一些其他选项可用，例如在DOM中副作用发生后触发它，或者组件渲染时立即触发它的可能性。然而，这些内容超出了本书的范围，因为它们适用于更高级的使用，在这个阶段可能会造成混淆。'
- en: Remember that using `watch` has a cost. In fact, there is a cost to be paid
    for an application observing a value, but there is an even greater performance
    cost in triggering a callback on every change of a value. For this reason, it
    is recommended to use `watch` only when needed and to ensure that the body of
    the callback is not too resource-intensive.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 记住使用`watch`是有代价的。事实上，观察一个值是有代价的，但在每次值变化时触发回调的性能成本更大。因此，建议仅在需要时使用`watch`，并确保回调体的资源消耗不是太密集。
- en: Use computed to minimize watch callbacks
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计算属性最小化`watch`回调
- en: If you are observing a variable that changes too often and want to try and improve
    on performance, you can use `computed` to create a new variable. This new computer
    property can then be watched instead. Because computed properties are cached,
    this approach is more performant.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在观察一个变化过于频繁的变量，并想尝试提高性能，你可以使用`computed`创建一个新的变量。然后可以监视这个新的计算属性。由于计算属性是缓存的，这种方法性能更优。
- en: That completes our introduction to `watch`. This is a useful feature that, when
    used correctly, can help you create clean and readable components.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对`watch`的介绍。这是一个有用的功能，当正确使用时，可以帮助你创建干净且易于阅读的组件。
- en: In this section, we learned what `watch` is and how using it improves our component,
    giving us a chance to trigger side effects from our application, such as an API
    request or DOM modification. We then made changes in the Companion App to better
    understand this topic. Finally, we explained the drawbacks of using `watch` and
    discussed when and how to use it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了什么是`watch`以及如何使用它来改进我们的组件，给我们机会从应用程序中触发副作用，例如API请求或DOM修改。然后我们在伴侣应用中进行了更改，以更好地理解这个主题。最后，我们解释了使用`watch`的缺点，并讨论了何时以及如何使用它。
- en: In the next section, we are going to introduce a built-in component called `<Suspense>`.
    This feature simplifies how we handle the loading state of asynchronous components.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍一个名为`<Suspense>`的内置组件。这个功能简化了我们处理异步组件加载状态的方式。
- en: Handling asynchronous components with <Suspense>
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`<Suspense>`处理异步组件
- en: Handling dynamic data loading is never easy. In fact, when data is static and
    hardcoded, displaying the information takes no effort, as the data is available
    on first render, but when the data needs to come from an outside source, such
    as a database or a third-party API, then the complexity increases. When loading
    information asynchronously, the data is not available on the first load, forcing
    us to handle a “loading state” until the data is available, or having to display
    an error state if the loading event has failed to complete.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 处理动态数据加载从来都不容易。事实上，当数据是静态且硬编码时，显示信息不需要任何努力，因为数据在首次渲染时即可获得，但当你需要从外部来源获取数据，例如数据库或第三方API时，复杂性就会增加。在异步加载数据时，数据在第一次加载时不可用，迫使我们处理“加载状态”直到数据可用，或者在加载事件未能完成时显示错误状态。
- en: To prevent having to handle state changes in multiple components and code duplication,
    Vue.js introduced a globally available built-in component called `<Suspense>`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止需要在多个组件中处理状态变化和代码重复，Vue.js引入了一个全局可用的内置组件，称为`<Suspense>`。
- en: With `<Suspense>`, we can orchestrate all loading states at once with very clean
    syntax. In the following section, we are going to first understand what makes
    a component asynchronous and then understand how this can be used to simplify
    our code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`<Suspense>`，我们可以一次性以非常干净的语法编排所有加载状态。在接下来的章节中，我们将首先了解是什么使组件异步，然后了解如何使用它来简化我们的代码。
- en: An experimental feature
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实验性功能
- en: At the time of writing, `<Suspense>` is still an experimental feature, and there
    is no set date on when and if it will become a core part of the Vue.js framework.
    The team is fixing a few bugs with it and more importantly, developing server-side
    support before it is turned into a full feature.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`<Suspense>` 仍然是一个实验性功能，没有确定的时间表，也不知道它何时以及是否会成为 Vue.js 框架的核心部分。团队正在修复一些与之相关的错误，更重要的是，在将其转变为完整功能之前，正在开发服务器端支持。
- en: Understanding asynchronous components
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解异步组件
- en: In the preceding introduction, we discussed an async component by using the
    example of a component that needs to load data dynamically, but that is not the
    actual definition of an async component.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的介绍中，我们通过一个需要动态加载数据的组件的例子来讨论了异步组件，但这并不是异步组件的实际定义。
- en: An async component is “*a component that requires an asynchronous function to
    be performed and completed before the rendering can* *be initialized*.”
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 异步组件是“*一个组件在渲染初始化之前需要执行并完成异步函数*”。
- en: The important takeaway from the preceding definition is the words `async` operation
    and the need for it to be completed are requirements for a component to be defined
    as an asynchronous component.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的定义中，我们可以得出的重要结论是“异步操作”和“需要它完成”是定义组件为异步组件的要求。
- en: In fact, if we look at our current application, we can see that we already have
    dynamic data that is loaded in `SocialPosts.vue`, but this does not make it an
    async component, as the component is rendered immediately and does not wait for
    the `fetch` operation to be completed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果我们看看我们的当前应用程序，我们可以看到我们已经有动态数据被加载到 `SocialPosts.vue` 中，但这并不使它成为一个异步组件，因为组件是立即渲染的，并不等待
    `fetch` 操作完成。
- en: An asynchronous component is characterized by the presence of a top-level `<script
    setup>` code block.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 异步组件的特点是存在一个顶级的 `<script setup>` 代码块。
- en: An asynchronous component affects the page rendering
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 异步组件会影响页面渲染
- en: An asynchronous component will stop the rendering itself and all of its children
    until the data is fully loaded. This should just be used if the component has
    no reason to render without the data being available.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 异步组件将停止自身及其所有子组件的渲染，直到数据完全加载。这仅应在组件没有理由在没有数据的情况下渲染时使用。
- en: Let’s look at our Companion App and try to find a good candidate to turn into
    an async component. Currently, only two components have asynchronous operations
    between them, `SocialPosts.vue` and `SocialPostComments.vue`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的伴侣应用程序，并尝试找到一个好的候选者来转换为异步组件。目前，只有两个组件之间存在异步操作，即 `SocialPosts.vue` 和
    `SocialPostComments.vue`。
- en: If we look at the logic within the `SocialPostComments.vue`, we can see that
    the component does not currently function properly. The current component logic
    displays a message when the comments array is empty, `"<p>There are no comments
    for this post!</p>"`, but this message is also displayed when the component first
    renders. This is because the component renders immediately, even if the `fetch`
    request is still active.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看看 `SocialPostComments.vue` 中的逻辑，我们可以看到该组件目前没有正常工作。当前组件逻辑在评论数组为空时显示一条消息，“`<p>此帖子没有评论！</p>`”，但这条消息也会在组件首次渲染时显示。这是因为组件立即渲染，即使
    `fetch` 请求仍在进行中。
- en: This is a very good candidate to be turned into an async component. In fact,
    this component has both an “async operation” and the “need for it to be completed,”
    as mentioned in the definition of an async component.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常适合转换为异步组件的候选者。事实上，这个组件既有“异步操作”，也有“需要它完成”的需求，正如异步组件的定义中提到的。
- en: Turning a component into an asynchronous component
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将组件转换为异步组件
- en: Vue.js provides a very simple way to define a component as an asynchronous component.
    In fact, all we need to do is ensure that the component includes one or more `await`
    functions within its body.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 提供了一种非常简单的方式来定义一个异步组件。实际上，我们只需要确保组件在其主体中包含一个或多个 `await` 函数。
- en: When the Vue.js framework sees an await function, it automatically defines the
    component as async.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Vue.js 框架看到 `await` 函数时，它会自动将该组件定义为异步。
- en: 'Let’s modify `SocialPostComments.vue` to await the `fetch` method:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改 `SocialPostComments.vue`，使其等待 `fetch` 方法：
- en: '[PRE71]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Our component logic required just two small changes to turn the component into
    a dynamic one. First, we made sure that our `fetchComments` method returned a
    promise by adding `return` before the `fetch` method. Then, we added `await` when
    calling the method. These two changes were all that was needed to ensure the component
    would turn into an async component.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件逻辑只需要进行两个小的更改，就可以将组件转换为动态组件。首先，我们确保我们的`fetchComments`方法通过在`fetch`方法之前添加`return`来返回一个promise。然后，在调用方法时添加`await`。这两个更改就是确保组件转换为异步组件所需的所有内容。
- en: 'All that is left to do now is learn how to use asynchronous components. In
    fact, at this stage, the Companion App is unable to load comments, and clicking
    on the “Load comment” button would log the following error:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是学习如何使用异步组件了。实际上，在这个阶段，Companion App无法加载评论，点击“加载评论”按钮会记录以下错误：
- en: '![Figure 7.6: An error message triggered by Vue.js when trying to incorrectly
    load an async component](img/B21130_07_06.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6：Vue.js在尝试错误地加载异步组件时触发的错误信息](img/B21130_07_06.jpg)'
- en: 'Figure 7.6: An error message triggered by Vue.js when trying to incorrectly
    load an async component'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：Vue.js在尝试错误地加载异步组件时触发的错误信息
- en: The error message mentions the need for the async component to be nested in
    `<Suspense>` in order to be rendered. Let’s learn what this `<Supense>` is and
    how it can be used to load async components.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息提到，异步组件需要嵌套在`<Suspense>`中以进行渲染。让我们了解这个`<Suspense>`是什么，以及它是如何被用来加载异步组件的。
- en: Rendering async components
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染异步组件
- en: In the previous section, we made the `SocialPostComments.vue` file asynchronous,
    and it is now time to learn how to handle this component to ensure that it is
    loaded correctly.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个部分，我们将`SocialPostComments.vue`文件转换为异步的，现在是时候学习如何处理这个组件以确保它被正确加载。
- en: As we previously mentioned, when a component is turned into an asynchronous
    one, it then requires us to handle its loading state. Loading this component normally,
    as we are currently doing in the application, would not work, as the component
    is not immediately available, so we need to find a way to handle its load gracefully.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，当一个组件被转换为异步组件时，我们就需要处理它的加载状态。以我们目前在应用程序中做的方式正常加载这个组件是不行的，因为这个组件不是立即可用的，所以我们需要找到一种优雅地处理其加载的方法。
- en: As always, the Vue.js core team has worked hard to provide us with all the tools
    we need to quickly accomplish complex operations.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，Vue.js核心团队努力为我们提供所有快速完成复杂操作所需的工具。
- en: 'The component is defined on the official Vue.js documentation as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件在官方Vue.js文档中的定义如下：
- en: “`<Suspense>` is a built-in component for orchestrating async dependencies in
    a component tree. It can render a loading state while waiting for multiple nested
    async dependencies down the component tree to be resolved.”
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: “`<Suspense>`是一个用于在组件树中编排异步依赖的内置组件。它可以在等待多个嵌套的异步依赖在组件树中解决时渲染加载状态。”
- en: Wrapping one or multiple components within `<Suspense>` prevents them from rendering
    until all the async operations are completed. Furthermore, `<Suspense>` also allows
    you to display a “loading” component while the async operations are completed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个或多个组件包裹在`<Suspense>`中可以防止它们在所有异步操作完成之前渲染。此外，`<Suspense>`还允许你在异步操作完成时显示一个“加载中”组件。
- en: '`<Suspense>` is already preloaded in the application, and it does not need
    to be imported. Let’s open `SocialPost.vue` and change our code to correctly load
    our async component:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`<Suspense>`已经在应用程序中预加载，不需要导入。让我们打开`SocialPost.vue`并更改我们的代码，以正确加载我们的异步组件：'
- en: '[PRE72]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The use of this built-in component is very simple. In fact, all we need to do
    is wrap `SocialPostComments` within `<Suspense>`, as highlighted in the previous
    code block, and move the `v-if` directive, `v-if="showComments"`, from `SocialPostComments`
    to the built-in `Suspense` component. After these changes, `SocialPostComments`
    will simply render after the async operation within the component resolves.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个内置组件非常简单。实际上，我们只需要将`SocialPostComments`包裹在`<Suspense>`中，就像前一个代码块中突出显示的那样，并将`v-if`指令`v-if="showComments"`从`SocialPostComments`移动到内置的`Suspense`组件。经过这些更改后，`SocialPostComments`将在组件内的异步操作解决后简单地渲染。
- en: There are cases in which you may be required to display a loading indicator
    while the async operation completes. `<Suspense>` provides a named slot called
    **fallback** that can handle this. Let’s learn how to use this feature by adding
    a fallback message while the post comments load.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能需要在异步操作完成时显示一个加载指示器。`<Suspense>` 提供了一个名为 **fallback** 的命名插槽，可以处理这种情况。让我们通过在帖子评论加载时添加回退消息来学习如何使用这个功能。
- en: 'To implement a fallback message, our code would require the following modifications:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现回退消息，我们的代码需要进行以下修改：
- en: '[PRE73]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'To add a message while the comments are fetched, we use the `SocialPostComments`.
    This slot is going to be defined using the `<template #fallback>` syntax. The
    content of this slot will just be displayed while the async operation within `SocialPostComments`
    is run, and it will disappear as soon as the component is rendered.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '要在获取评论时添加消息，我们使用 `SocialPostComments`。这个插槽将使用 `<template #fallback>` 语法定义。这个插槽的内容将在
    `SocialPostComments` 内部的异步操作运行时显示，一旦组件渲染完毕，它就会消失。'
- en: Custom error handling
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义错误处理
- en: At this stage, error handling is not handled by `<Suspense>`, and this needs
    to be handled manually using `onErrorCapture()` hooks. Explaining this is beyond
    the scope of this book.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，错误处理不是由 `<Suspense>` 处理的，需要手动使用 `onErrorCapture()` 钩子来处理。解释这一点超出了本书的范围。
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We have now completed everything we had to learn about async data and component
    loading. We started the chapter by removing the hardcoded `posts` and replacing
    them with dummy data that is loaded dynamically. We then fixed the property mismatch
    caused by the data change, learning how to prevent this in the future by improving
    the use of property typing and validations.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了关于异步数据和组件加载的所有学习内容。我们通过移除硬编码的 `posts` 并用动态加载的虚拟数据替换它们来开始本章。然后我们修复了由于数据变化引起的属性不匹配问题，并学习了如何通过改进属性类型和验证来防止未来发生这种情况。
- en: Then, we learned how to change our data flow to load comments on demand and
    defined when this should be used, as well as the performance and user experience
    benefits that this brings. We then introduced another feature related to async
    operations, `watch`. We used this feature to trigger a side effect and automatically
    load more posts when the number of posts reaches a certain number.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了如何将我们的数据流改为按需加载评论，并定义了何时应该使用它，以及它带来的性能和用户体验优势。然后我们介绍了与异步操作相关的另一个功能，`watch`。我们使用这个功能来触发副作用，并在帖子数量达到一定数量时自动加载更多帖子。
- en: Lastly, we learned how to create and handle asynchronous components. We described
    what makes an async component and changed our Companion App to ensure our comments
    were fetched before loading the component. We concluded the chapter by introducing
    the `<Suspense>` built-in component, using it to correctly load our asynchronous
    component, and we also examined a fallback feature that shows text while the component
    loads.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何创建和处理异步组件。我们描述了异步组件的特点，并将我们的伴侣应用修改为在加载组件之前先获取评论。通过介绍内置的 `<Suspense>`
    组件，我们正确地加载了异步组件，并检查了在组件加载期间显示文本的回退功能。
- en: At this stage, you should be able to fully handle asynchronous data loading,
    side effects, and components that require JavaScript promises to be fulfilled
    before being displayed.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你应该能够完全处理异步数据加载、副作用以及需要在显示之前满足JavaScript承诺的组件。
- en: In the next chapter, we are going to move our focus away from Vue.js and focus
    on testing our application. We will learn the basics of end-to-end testing with
    **Cypress** and unit testing with **Vitest**.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把重点从Vue.js转移到测试我们的应用。我们将学习使用 **Cypress** 进行端到端测试和 **Vitest** 进行单元测试的基础知识。
- en: 'Part 3: Expanding Your Knowledge with Vue.js and Its Core Libraries'
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：通过Vue.js及其核心库扩展您的知识
- en: At this stage in our journey, it is time to introduce the external libraries
    that are part of the Vue.js ecosystem that are required to build production-ready
    applications.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的学习旅程的这个阶段，是时候介绍Vue.js生态系统中的外部库了，这些库是构建生产就绪应用所必需的。
- en: 'This part contains the following chapters:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 8*](B21130_08.xhtml#_idTextAnchor103)*, Testing Your App with Vitest
    and Cypress*'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B21130_08.xhtml#_idTextAnchor103)*，使用Vitest和Cypress测试您的应用*'
- en: '[*Chapter 9*](B21130_09.xhtml#_idTextAnchor120)*, Introduction to Advanced
    Vue.js Techniques – Slots, Lifecycle, and* *Template Refs*'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B21130_09.xhtml#_idTextAnchor120)*，高级Vue.js技术介绍 – 插槽、生命周期和模板引用*'
- en: '[*Chapter 10*](B21130_10.xhtml#_idTextAnchor135)*, Handling Routing with* *Vue
    Router*'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B21130_10.xhtml#_idTextAnchor135)*，使用* *Vue Router*处理路由'
- en: '[*Chapter 11*](B21130_11.xhtml#_idTextAnchor153)*, Managing Your Application’s
    State with Pinia*'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B21130_11.xhtml#_idTextAnchor153)*，使用Pinia管理你的应用程序状态'
- en: '[*Chapter 12*](B21130_12.xhtml#_idTextAnchor163)*, Achieving Client-Side Validation
    with VeeValidate*'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B21130_12.xhtml#_idTextAnchor163)*，使用VeeValidate实现客户端验证'
