- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Building an Interactive Quiz App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个交互式问答应用
- en: We’ll be stepping up the complexity in this chapter by creating a quiz app that
    has an admin panel and a real-time connection among multiple clients through the
    use of WebSockets. WebSockets differ from our usual endpoints by keeping the connection
    open, allowing for continuous updates to be sent from a central socket server
    to one or more clients. Using these features, we’ll build a small-scale Kahoot
    clone.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建一个具有管理面板和通过WebSockets在多个客户端之间实现实时连接的问答应用来提高本章的复杂性。WebSockets与我们的常规端点不同，它保持连接打开，允许从中央socket服务器向一个或多个客户端发送连续更新。使用这些功能，我们将构建一个小型Kahoot克隆。
- en: For the admin panel, we’ll use Nuxt ([https://nuxt.com/](https://nuxt.com/)).
    Nuxt is a framework that was built as an extension of the Vue philosophy but extended
    with server capabilities. Save for the Electron app in [*Chapter 7*](B19563_07.xhtml#_idTextAnchor204),
    all of our code can run in the browser of the client. Nuxt allows Vue code to
    be executed on a server. On top of that, it has a lot of extra capabilities that
    drastically improve the **developer experience** (**DX**). We’ll encounter these
    capabilities as we progress through this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于管理面板，我们将使用Nuxt ([https://nuxt.com/](https://nuxt.com/))。Nuxt是一个作为Vue哲学扩展而构建的框架，但增加了服务器功能。除了第7章中的Electron应用[*第7章*](B19563_07.xhtml#_idTextAnchor204)之外，我们所有的代码都可以在客户端的浏览器中运行。Nuxt允许Vue代码在服务器上执行。除此之外，它还具有许多额外的功能，这些功能极大地改善了**开发者体验**（**DX**）。随着本章的进展，我们将遇到这些功能。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Familiarizing yourself with Nuxt and server-side rendering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉Nuxt和服务器端渲染
- en: Understanding the difference between the REST API and WebSockets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解REST API和WebSockets之间的区别
- en: Client experience and server roles in complex application architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂应用架构中的客户端体验和服务器角色
- en: Structuring application logic
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用逻辑的结构化
- en: Using Node.js scripts in development environments
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发环境中使用Node.js脚本
- en: We’re going to build three different applications that need to communicate with
    each other to form an interactive quiz.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建三个不同的应用，这些应用需要相互通信以形成一个交互式问答。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: At the heart of our setup lies the **Server Quiz App** (**SQA**), which is scaffolded
    around Nuxt ([https://nuxt.com/](https://nuxt.com/)), Pinia for state management
    ([https://pinia.vuejs.org/](https://pinia.vuejs.org/)), Supabase for managing
    quiz data ([https://supabase.com/](https://supabase.com/)), and Vuetify ([https://vuetifyjs.com/](https://vuetifyjs.com/))
    for rendering a management interface.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的设置中，核心是**服务器问答应用**（**SQA**），它围绕Nuxt ([https://nuxt.com/](https://nuxt.com/))、Pinia
    ([https://pinia.vuejs.org/](https://pinia.vuejs.org/))进行状态管理、Supabase ([https://supabase.com/](https://supabase.com/))管理问答数据以及Vuetify
    ([https://vuetifyjs.com/](https://vuetifyjs.com/))渲染管理界面而构建。
- en: We’ll build a standalone `socket.io` server ([https://socket.io/](https://socket.io/))
    to maintain a real-time connection between clients.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个独立的`socket.io`服务器 ([https://socket.io/](https://socket.io/))，以在客户端之间保持实时连接。
- en: Lastly, our **Client Quiz App** (**CQA**) will use Vuetify to render the quiz
    elements ([https://vuetifyjs.com/](https://vuetifyjs.com/)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的**客户端问答应用**（**CQA**）将使用Vuetify来渲染问答元素 ([https://vuetifyjs.com/](https://vuetifyjs.com/))。
- en: 'You can find the code complete code for this chapter here: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/08.quiz](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/08.quiz).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的完整代码：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/08.quiz](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/08.quiz).
- en: Entities in the quiz app setup
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问答应用设置中的实体
- en: 'To give you an idea of how our elements will work together, let’s quickly take
    a look at the following figure:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您了解我们的元素将如何协同工作，让我们快速看一下以下图示：
- en: '![Figure 8.1 – Overview of the entities in the quiz app setup](img/B19563_08_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 问答应用设置中的实体概览](img/B19563_08_01.jpg)'
- en: Figure 8.1 – Overview of the entities in the quiz app setup
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 问答应用设置中的实体概览
- en: The big change concerning our previous projects is that our client (CQA) is
    not directly communicating with the Supabase database anymore. Instead, it connects
    via the SQS, where it retrieves questions and scores and sends its answers back
    to the SQS. The SQS, in turn, communicates with the SQA to retrieve relevant quiz
    information and centralizes the session of a current active quiz between its clients
    (CQAs).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的项目相比，一个重大变化是，我们的客户端（CQA）不再直接与 Supabase 数据库通信。相反，它通过 SQS 连接，从中检索问题和分数，并将其答案发送回
    SQS。SQS 然后，与 SQA 通信以检索相关的测验信息，并在其客户端（CQAs）之间集中当前活动的测验会话。
- en: The SQA is used to manage the contents of quizzes and interact with the database.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: SQA 用于管理测验内容和与数据库交互。
- en: A word beforehand
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 事先说一句
- en: Since the setup is fairly complex, this chapter will not focus on, and instead
    leave out, security measures. It is good to realize the limitations of the project
    and don’t treat this as production-ready code. Where possible, we’ll mention implications
    or possible solutions briefly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设置相当复杂，本章将不会关注，并且将省略安全措施。了解项目的局限性，不要将其视为生产就绪代码是很好的。在可能的情况下，我们将简要提及影响或可能的解决方案。
- en: Let’s dive in by setting up the database.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过设置数据库来深入了解。
- en: Setting up the database
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置数据库
- en: As with previous chapters, we’ll start this chapter by setting up our database.
    We’ll create another project called `quiz`, set a strong database password, and
    select a geographically close region.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，我们将从设置我们的数据库开始。我们将创建另一个名为 `quiz` 的项目，设置一个强大的数据库密码，并选择一个地理位置相近的区域。
- en: Remember to note the **Project URL** and **API** **Key** values!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 记得记录**项目 URL**和**API 密钥**值！
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The intent of this chapter is not to focus on database management and the following
    settings should not be considered a best practice for a production app!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是不专注于数据库管理，以下设置不应被视为生产应用程序的最佳实践！
- en: 'Follow these steps to set up the database:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤设置数据库：
- en: Go to `quiz`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `quiz`。
- en: Uncheck **Enable Row Level Security (RLS)** and confirm the dialog after reading
    its warning.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选择**启用行级安全（RLS）**，并在阅读其警告后确认对话框。
- en: In the **Columns** section, change the type of the **id** field to **uuid**.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**列**部分，将**id**字段的类型更改为**uuid**。
- en: That’s enough for this table, so click **Save**.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个表格就足够了，所以点击**保存**。
- en: We will only use this table as a grouping mechanism for questions, so we’re
    keeping it as simple as possible.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将仅使用此表作为问题分组机制，因此我们将尽可能保持其简单。
- en: Now, return to `questions`.*   Again, uncheck `quiz` table and check that the
    **id** column is automatically entered.*   Click **Save** to close the foreign
    key property.*   Create a column called **question** and set its type to **text**.*   Create
    four columns called **answer_1** through **answer_4** with their type set to **text**.*   Create
    a column called **correct** with its type set to **int2**.*   Click **Save** to
    create the table.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，返回到 `questions`。再次取消选择 `quiz` 表，并确认**id**列是自动输入的。点击**保存**以关闭外键属性。创建一个名为**question**的列，并将其类型设置为**text**。创建四个名为**answer_1**至**answer_4**的列，并将它们的类型设置为**text**。创建一个名为**correct**的列，并将其类型设置为**int2**。点击**保存**以创建表。
- en: We’re not going to import any preset data since we’ll use our SQA to handle
    insertions for us! Let’s get started by building our first application in this
    project.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会导入任何预设数据，因为我们将使用我们的 SQA 来处理插入操作！让我们从这个项目中构建我们的第一个应用程序开始。
- en: The SQA
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The SQA
- en: 'To organize all our applications, we’ll create subfolders for every project
    in our chapters’ root folder. Since this app will run on Nuxt, we can use the
    `Nuxi` CLI to install our project for us. From the root of our project, we’ll
    run the following command in the command line:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了组织我们所有的应用程序，我们将在章节根文件夹中为每个项目创建子文件夹。由于此应用程序将在 Nuxt 上运行，我们可以使用 `Nuxi` CLI 来为我们安装项目。从我们项目的根目录，我们将在命令行中运行以下命令：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We’ll simply pick `npm` as our package manager. Once the installation is done,
    navigate to the `server` folder and run `npm run dev` to start the application.
    By default, it will run on port `3000`. Upon opening the URL in your browser,
    you should see something like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简单地选择 `npm` 作为我们的包管理器。一旦安装完成，导航到 `server` 文件夹并运行 `npm run dev` 以启动应用程序。默认情况下，它将在端口
    `3000` 上运行。在浏览器中打开 URL 后，你应该会看到如下内容：
- en: '![Figure 8.2 – The welcome screen of a fresh Nuxt installation](img/B19563_08_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 新鲜 Nuxt 安装的欢迎屏幕](img/B19563_08_02.jpg)'
- en: Figure 8.2 – The welcome screen of a fresh Nuxt installation
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 新鲜 Nuxt 安装的欢迎屏幕
- en: While this may not look like much, please inspect the source of this page. Instead
    of rendering a virtual DOM to a `<div id="app" />` element, Nuxt runs as a Node.js
    process, which (among other things) means that it supports server-side rendering
    of Vue components! This can be very beneficial since you don’t have to rely on
    JavaScript being executed in the browser, which positively impacts search engine
    optimization, crawling support, rendering performance, and browser memory usage.
    For more information, please visit the Nuxt official docs ([https://vuejs.org/guide/scaling-up/ssr.html#server-side-rendering-ssr](https://vuejs.org/guide/scaling-up/ssr.html#server-side-rendering-ssr)).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来可能不多，但请检查这个页面的源代码。Nuxt不是将虚拟DOM渲染到`<div id="app" />`元素中，而是作为一个Node.js进程运行，这意味着它支持Vue组件的服务端渲染！这可以非常有益，因为你不必依赖于JavaScript在浏览器中执行，这有利于搜索引擎优化、爬虫支持、渲染性能和浏览器内存使用。更多信息，请访问Nuxt官方文档([https://vuejs.org/guide/scaling-up/ssr.html#server-side-rendering-ssr](https://vuejs.org/guide/scaling-up/ssr.html#server-side-rendering-ssr))。
- en: With our foundation in place, let’s add some extra capabilities using the Nuxt
    module system.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的基础搭建好之后，让我们使用Nuxt模块系统添加一些额外的功能。
- en: Modules and auto-imports
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块和自动导入
- en: 'We’ll start by adding Vuetify to our project. Nuxt has a solid community that
    contributes to certain modules for everyone to use. In our case, we’ll use the
    *Nuxt Vuetify Module* ([https://nuxt.com/modules/nuxt-vuetify](https://nuxt.com/modules/nuxt-vuetify)).
    In our `server` folder, run the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将Vuetify添加到我们的项目中。Nuxt有一个稳固的社区，为每个人贡献了一些模块。在我们的案例中，我们将使用*Nuxt Vuetify模块*([https://nuxt.com/modules/nuxt-vuetify](https://nuxt.com/modules/nuxt-vuetify))。在我们的`server`文件夹中，运行以下命令：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Nuxt modules can be registered and configured via the `nuxt.config.ts` file
    by changing its contents, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt模块可以通过修改`nuxt.config.ts`文件来注册和配置，如下所示：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the `modules` property, we register the module we want to use, and, optionally,
    on the (in this case) `vuetify` property, we configure how the module should behave.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`modules`属性中，我们注册我们想要使用的模块，并且可选地（在这种情况下）在`vuetify`属性中配置模块应该如何行为。
- en: That’s all we need! We can now use the Vuetify templates in our application.
    Nuxt supports a concept called auto-importing, which means that for commonly used
    scripts, we don’t need to explicitly write the import statement in our script
    block. Nuxt can figure out the required file at runtime! As you will see when
    we start to write our code, this will make our files very clean and readable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！我们现在可以在我们的应用程序中使用Vuetify模板。Nuxt支持一个称为自动导入的概念，这意味着对于常用脚本，我们不需要在脚本块中显式编写导入语句。Nuxt可以在运行时确定所需的文件！当您开始编写代码时，这将使我们的文件非常干净和易于阅读。
- en: File-based routing
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于文件的路由
- en: Similar to the automated imports, Nuxt uses our familiar `vue-router` by default,
    and it’s configured to create routes for you, based on a certain file structure
    ([https://nuxt.com/docs/getting-started/routing#routing](https://nuxt.com/docs/getting-started/routing#routing)).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与自动导入类似，Nuxt默认使用我们熟悉的`vue-router`，并且配置为根据一定的文件结构为你创建路由。[https://nuxt.com/docs/getting-started/routing#routing](https://nuxt.com/docs/getting-started/routing#routing)。
- en: 'We’ll start with a default layout by creating a `default.vue` file in the `layouts`
    folder: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.1-default.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.1-default.vue).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个默认布局开始，通过在`layouts`文件夹中创建一个`default.vue`文件来实现：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.1-default.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.1-default.vue).
- en: 'As you can see, we’re depending on Vuetify components to create a simple layout
    for us. You can already identify a couple of routes. We’ll create them in the
    next section. For now, we can use the default layout in our app by updating the
    `app.vue` file in the SQA root folder with the following contents:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们依赖于Vuetify组件为我们创建一个简单的布局。您已经可以识别出几个路由。我们将在下一节中创建它们。现在，我们可以通过更新SQA根文件夹中的`app.vue`文件来使用默认布局，内容如下：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see in the menu, we need a couple of routes: a home route, a route
    to manage quizzes, and a route where we can share a quiz.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如菜单所示，我们需要几个路由：一个主页路由，一个管理测验的路由，以及一个可以分享测验的路由。
- en: 'We’ll start with the home route by creating a `pages` folder in the root of
    the SQA folder and adding an `index.vue` file with the following contents:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从主页路由开始，在 SQA 文件夹的根目录下创建一个 `pages` 文件夹，并添加一个包含以下内容的 `index.vue` 文件：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, if we flip back to the `app.vue` file and replace the `<NuxtWelcome />`
    component with the `<NuxtPage />` component (notice that we don’t need to import
    these components in our script block to use them?) while the development server
    is active, our home route now opens the contents of `./pages/index.vue` in our
    app!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们切换回 `app.vue` 文件，并在开发服务器激活时用 `<NuxtPage />` 组件替换 `<NuxtWelcome />` 组件（注意，我们不需要在我们的脚本块中导入这些组件就可以使用它们？），那么我们的主页现在会在我们的应用中打开
    `./pages/index.vue` 的内容！
- en: So, what’s happening here? The `NuxtPage` component has some logic built in
    that can read the `pages` folder and dynamically create routes on the vue router
    instance that’s initialized as a default part of Nuxt. Neat!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里发生了什么？`NuxtPage` 组件内置了一些逻辑，可以读取 `pages` 文件夹，并在初始化为 Nuxt 默认部分的 vue 路由实例上动态创建路由。真不错！
- en: Now, if we want to route to a certain path, we can simply create a new folder
    in the `./pages` folder with a name that matches the route. In our case, we’ll
    create a `quiz` subfolder and add another `index.vue` file in that folder.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要路由到某个路径，我们只需在 `./pages` 文件夹中创建一个与路由名称匹配的新文件夹。在我们的例子中，我们将创建一个 `quiz`
    子文件夹，并在该文件夹中添加另一个 `index.vue` 文件。
- en: Note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Technically, you could also opt to create a file called `quiz.vue` in the `./pages`
    folder. However, since we will add multiple routes that are part of the `quiz`
    domain, it’s a better practice to group them in their dedicated folder.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，你还可以选择在 `./pages` 文件夹中创建一个名为 `quiz.vue` 的文件。然而，由于我们将添加多个属于 `quiz` 域的路由，将它们分组在专门的文件夹中是一个更好的做法。
- en: 'We’ll begin with a basic file as part of `./pages/quiz/index.vue`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `./pages/quiz/index.vue` 中的一个基本文件开始：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, when navigating to `http://localhost:3000/quiz` in your browser (or using
    the **Manage Quizzes** button in the navigation drawer), you should see the following
    page:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你在浏览器中导航到 `http://localhost:3000/quiz`（或使用导航抽屉中的 **管理测验** 按钮）时，你应该看到以下页面：
- en: '![Figure 8.3 – File-based routing in action](img/B19563_08_03.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 基于文件的路由在实际中的应用](img/B19563_08_03.jpg)'
- en: Figure 8.3 – File-based routing in action
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 基于文件的路由在实际中的应用
- en: Our static page doesn’t help us that much, so we’ll focus on establishing the
    connection and data from our database in the next section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的静态页面对我们帮助不大，所以我们将专注于在下一节中建立与数据库的连接和数据。
- en: Reintroducing two familiar friends
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新介绍两位熟悉的朋友
- en: As we did in *Chapters 6* and *7*, we’ll depend on the Supabase JS client and
    Pinia. Let’s see how that works.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 6 章和第 7 章中所做的那样，我们将依赖于 Supabase JS 客户端和 Pinia。让我们看看它是如何工作的。
- en: 'First, we’ll install the Supabase JS Client ([https://www.npmjs.com/package/@supabase/supabase-js](https://www.npmjs.com/package/@supabase/supabase-js))
    with the `npm` command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用 `npm` 命令安装 Supabase JS 客户端（[https://www.npmjs.com/package/@supabase/supabase-js](https://www.npmjs.com/package/@supabase/supabase-js)）：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We’ll also create a `./composables` folder with a `supabase.ts` file that has
    the following contents:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个包含 `supabase.ts` 文件的 `./composables` 文件夹，其内容如下：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Nuxt is set up to scan the `./composables` folder and extract the exports so
    that it supports auto imports for composables as well! There’s one caveat: it
    only scans one level and excludes nested folders.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt 已经设置为扫描 `./composables` 文件夹并提取导出，以便它支持对可组合组件的自动导入！有一个注意事项：它只扫描一个层级，并排除嵌套文件夹。
- en: 'As you can see, we need to set up a `.env` file in the root of our SQA folder
    with the URL and API key that we received when we created our database. The `.env`
    file has the same setup as in *Chapters 6* and *7*:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们需要在我们的 SQA 文件夹的根目录中设置一个 `.env` 文件，其中包含我们在创建数据库时收到的 URL 和 API 密钥。`.env`
    文件与第 6 章和第 7 章中的设置相同：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With our client in place, we can add Pinia – this time, as a Nuxt module. Run
    the following command in the terminal to install the packages:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的客户端就绪后，我们可以添加 Pinia – 这次，作为一个 Nuxt 模块。在终端中运行以下命令来安装包：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you run into an `ERESOLVE` error during installation, please look at the
    tip provided in the installation guide ([https://pinia.vuejs.org/ssr/nuxt.html#Installation](https://pinia.vuejs.org/ssr/nuxt.html#Installation)).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你安装过程中遇到 `ERESOLVE` 错误，请查看安装指南中提供的提示（[https://pinia.vuejs.org/ssr/nuxt.html#Installation](https://pinia.vuejs.org/ssr/nuxt.html#Installation)）。
- en: 'We’ll add the module to the `modules` array on the `nuxt.config.ts` property:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把模块添加到 `nuxt.config.ts` 属性的 `modules` 数组中：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For an even better coding experience, we can define the auto imports for Pinia
    functions as well by adding the following property to the Nuxt config:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更好的编码体验，我们还可以通过在 Nuxt 配置中添加以下属性来定义 Pinia 函数的自动导入：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `nuxt.config.ts` file will look like this: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.2-nuxt.config.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.2-nuxt.config.ts).
    With Supabase and Pinia now in place, we can create our quiz store!'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`nuxt.config.ts` 文件将看起来像这样：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.2-nuxt.config.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.2-nuxt.config.ts)。随着
    Supabase 和 Pinia 的部署就绪，我们可以创建我们的测验存储库了！'
- en: 'For our stores, we’ll create the `./stores` folder with a `quiz.ts` file that
    has the following contents: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.3-quiz.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.3-quiz.ts).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的存储库，我们将在 `./pages` 文件夹中创建一个 `./stores` 文件夹，并包含一个 `quiz.ts` 文件，其内容如下：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.3-quiz.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.3-quiz.ts)。
- en: If you compare this store to, for instance, the *User Store* from [*Chapter
    6*](B19563_06.xhtml#_idTextAnchor162), you’ll notice that a lot of imports are
    missing. That’s because they’re being handled by Nuxt! Let’s quickly summarize
    the functionalities of the *Quiz Store* since we’re not going to go in depth.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个存储库与，例如，[*第 6 章*](B19563_06.xhtml#_idTextAnchor162)中的 *用户存储库* 进行比较，你会注意到缺少了很多导入。这是因为它们由
    Nuxt 处理！既然我们不会深入探讨，让我们快速总结一下 *测验存储库* 的功能。
- en: Our store exposes a list of all quizzes (*line 7*) and the method for retrieving
    that data from Supabase (*lines 11–30*). Our store also exposes the properties
    of a single quiz (*line 8*) and the accompanying method of retrieving quiz data
    from the database (*lines 62–82*). For both the quiz and answers to the quiz,
    we expose methods to upsert data and remove data. That’s the basic management
    we need to continue with.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的存储库公开了一个所有测验的列表（*第 7 行*）以及从 Supabase 获取该数据的方法（*第 11-30 行*）。我们的存储库还公开了单个测验的属性（*第
    8 行*）以及从数据库获取测验数据的相关方法（*第 62-82 行*）。对于测验及其答案，我们公开了更新和删除数据的方法。这就是我们需要继续的基本管理。
- en: 'We’ll revisit our `./pages/quiz/index.vue` file to add management at the quiz
    level: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.4-index.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.4-index.vue).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新访问 `./pages/quiz/index.vue` 文件，以在测验级别添加管理：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.4-index.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.4-index.vue)。
- en: 'When you run the development server, you should be able to add a couple of
    new quizzes and have them show up in this overview, as shown in the following
    screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行开发服务器时，你应该能够添加几个新的测验，并且它们将显示在这个概览中，如下面的截图所示：
- en: "![Figure 8.4 – Our application connected to the database via a Pin\uFEFFia\
    \ store](img/B19563_08_04.jpg)"
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – 我们的应用程序通过 Pinia 存储连接到数据库](img/B19563_08_04.jpg)'
- en: Figure 8.4 – Our application connected to the database via a Pinia store
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 我们的应用程序通过 Pinia 存储连接到数据库
- en: 'We can now build a similar overview of quizzes for the `/share` route with
    ease by creating a `./share` subfolder in the `./pages` folder, creating an `index.vue`
    file, and pasting the following contents in that file: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.5-index.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.5-index.vue).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `./pages` 文件夹中创建一个 `./share` 子文件夹，创建一个 `index.vue` 文件，并将以下内容粘贴到该文件中，我们可以轻松地构建一个用于
    `/share` 路由的类似测验概览：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.5-index.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.5-index.vue)。
- en: We’re getting there! If you noticed the `<nuxt-link />` component in both pages
    we created, you may have noticed its similarities to `<router-link />`. The `<nuxt-link
    />` component is a wrapper for it but also helps Nuxt in determining a map of
    all possible routes. Together with file-based routing, these occurrences and configuration
    of the `<nuxt-link />` components help in determining the configuration of the
    `vue-router` implementation. You may have also noticed that both components link
    to a dynamic route as a child of `/quiz` and `/share`, respectively. Let’s fix
    those!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在接近目标！如果你注意到了我们创建的两个页面中的 `<nuxt-link />` 组件，你可能已经注意到了它与 `<router-link />`
    的相似之处。`<nuxt-link />` 组件是它的包装器，同时也帮助 Nuxt 确定所有可能的路由映射。与基于文件的路由一起，这些 `<nuxt-link
    />` 组件的出现和配置有助于确定 `vue-router` 实现的配置。你可能也注意到了，这两个组件分别链接到 `/quiz` 和 `/share` 的动态路由。让我们来修复这些问题！
- en: Dynamic file-based routes
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态基于文件的路由
- en: 'We’ll start with the `./share` route. As you can see by the markup of the link
    component, we’re targeting a route with a parameter:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `./share` 路由开始。正如你通过链接组件的标记所看到的，我们正在针对一个带有参数的路由：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Normally, we’d configure our Vue router configuration with something like the
    following example entry:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会用以下示例配置我们的 Vue 路由配置：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using Nuxt, passing a parameter is as simple as marking it in the filename.
    Next to the `index.vue` file, we’ll create a file called `[quiz_id].vue`. This
    is the equivalent result of defining the parameter in a route file. It tells Nuxt
    to instruct the router to create a route with a parameter of `quiz_id`. In the
    file, we can read the parameter by utilizing the `useRoute` composable and accessing
    the `params.quiz_id` property!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Nuxt，传递参数就像在文件名中标记它一样简单。在 `index.vue` 文件旁边，我们将创建一个名为 `[quiz_id].vue` 的文件。这是在路由文件中定义参数的等效结果。它告诉
    Nuxt 指示路由器创建一个带有 `quiz_id` 参数的路由。在文件中，我们可以通过使用 `useRoute` 可组合函数并访问 `params.quiz_id`
    属性来读取参数！
- en: 'In the `[quiz_id].vue` file, we’ll add the following contents: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.6-%5Bquiz_id%5D.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.6-%5Bquiz_id%5D.vue).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `[quiz_id].vue` 文件中，我们将添加以下内容：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.6-%5Bquiz_id%5D.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.6-%5Bquiz_id%5D.vue).
- en: 'The page itself is nothing fancy: it just generates an anchor link element
    that points to a URL that we will need to build an app for in the final section
    of this chapter!'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 页面本身并没有什么特别之处：它只是生成一个指向 URL 的锚点链接元素，这个 URL 我们将在本章的最后部分构建一个应用！
- en: 'To complete the management interface, we’ll create a page for editing questions
    in a certain quiz. First, as a requirement, we’ll create a `./components` folder
    with a `FormQuestion.vue` file that has the following contents: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.7-FormQuestion.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.7-FormQuestion.vue).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成管理界面的构建，我们将为某个测验中的问题编辑创建一个页面。首先，作为一个要求，我们将创建一个 `./components` 文件夹，并包含一个
    `FormQuestion.vue` 文件，其内容如下：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.7-FormQuestion.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.7-FormQuestion.vue).
- en: In the file, we’re directly mapping a form to the columns in our database. It’s
    pretty straightforward to set up, although I’d like to point out the repeating
    setup for the answers (*lines 33–48*) where we use a `v-for` directive to generate
    the four answer fields and map each field’s `v-model` using dynamic object keys
    (*line 36*).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中，我们直接将表单映射到我们数据库中的列。设置起来相当直接，尽管我想指出重复设置答案（*第 33-48 行*）的地方，我们使用 `v-for` 指令生成四个答案字段，并使用动态对象键映射每个字段的
    `v-model`（*第 36 行*）。
- en: 'Now, we’ll create a dynamic route as a descendant of the `quiz` route by creating
    a `[quiz_id].vue` file in the `./pages/quiz` folder: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.8-%5Bquiz_id%5D.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.8-%5Bquiz_id%5D.vue).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过在`./pages/quiz`文件夹中创建一个`[quiz_id].vue`文件，作为`quiz`路由的后代来创建一个动态路由：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.8-%5Bquiz_id%5D.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.8-%5Bquiz_id%5D.vue).
- en: With these pages finished, you should be able to create one or two small quizzes
    with multiple-choice questions. Before we continue, we need to have at least one,
    but preferably more quizzes in the database, with a couple of multiple-choice
    questions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些页面后，你应该能够创建一个或两个包含多项选择题的小测验。在我们继续之前，我们需要至少有一个，但最好是更多的测验在数据库中，附带几个多项选择题。
- en: Why don’t you try and create a quiz about the Vue ecosystem?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你为什么不尝试创建一个关于Vue生态系统的测验呢？
- en: Setting up the SQS
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置SQS
- en: Our next order of business is setting up the server that handles the requests
    from one or more clients. This will be a small standalone application and it will
    get its data from our Nuxt server since that already has a connection with the
    database instance. Creating an endpoint in Nuxt is something we haven’t built
    yet because our Nuxt application is only capable of presenting a management app!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是设置处理一个或多个客户端请求的服务器。这将是一个小型独立应用程序，并且它将从我们的Nuxt服务器获取数据，因为那已经与数据库实例建立了连接。在Nuxt中创建一个端点是我们在还没有构建的，因为我们的Nuxt应用程序只能展示管理应用程序！
- en: Nuxt API routes
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nuxt API路由
- en: As I mentioned previously, the Nuxt app runs as a Node process. When we request
    pages, it acts as a web server that interprets the Vue components and routes to
    return an HTML response. In addition to that, it can also act as a server at the
    same time! Nuxt uses the Nitro server engine ([https://nuxt.com/docs/guide/directory-structure/server](https://nuxt.com/docs/guide/directory-structure/server))
    to process requests on scripts in the `./server` folder. It also supports file-based
    routing and parameters, similar to the `./``pages` folder.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，Nuxt应用程序作为Node进程运行。当我们请求页面时，它充当一个解析Vue组件和路由以返回HTML响应的Web服务器。除此之外，它还可以同时充当服务器！Nuxt使用Nitro服务器引擎([https://nuxt.com/docs/guide/directory-structure/server](https://nuxt.com/docs/guide/directory-structure/server))来处理`./server`文件夹中的脚本请求。它还支持基于文件的路由和参数，类似于`./pages`文件夹。
- en: 'To server our quizzes as part of a RESTful API, we’ll create the `./server/api/quiz`
    structure in our Nuxt project. In the `quiz` folder, we’ll create an `index.ts`
    file. This will be available on `/api/quiz` requests to the Nuxt URL:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将测验作为RESTful API的一部分来提供，我们将在我们的Nuxt项目中创建`./server/api/quiz`结构。在`quiz`文件夹中，我们将创建一个`index.ts`文件。这将通过Nuxt
    URL的`/api/quiz`请求可用：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Nothing special is going on here. We’ve added `console.log` with a 📦 emoji,
    which will help us analyze the application flow once it’s been created. If your
    development server is running (a restart might be required when adding new files),
    you should be able to request the quiz information via this URL: [http://localhost:3000/api/quiz](http://localhost:3000/api/quiz)`.`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有发生什么特别的事情。我们添加了带有📦表情符号的`console.log`，这有助于我们分析创建后的应用程序流程。如果你的开发服务器正在运行（添加新文件时可能需要重启），你应该能够通过此URL请求测验信息：[http://localhost:3000/api/quiz](http://localhost:3000/api/quiz)。
- en: 'If we’ve set up our endpoint correctly, we should see something like this in
    the browser. This is the contents of our quiz table in JSON format:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正确设置了端点，我们应该在浏览器中看到类似这样的内容。这是我们的测验表内容的JSON格式：
- en: '![Figure 8.5 – Example of the quiz API server from Nuxt](img/B19563_08_05.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – Nuxt的测验API服务器示例](img/B19563_08_05.jpg)'
- en: Figure 8.5 – Example of the quiz API server from Nuxt
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – Nuxt的测验API服务器示例
- en: 'We’ll add another entry point using the parameterized file notation. We’ll
    create a `[id].ts` file next to the `index.ts` file: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.9-%5Bid%5D.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.9-%5Bid%5D.ts).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用参数化文件表示法添加另一个入口点。我们将在`index.ts`文件旁边创建一个`[id].ts`文件：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.9-%5Bid%5D.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.9-%5Bid%5D.ts).
- en: 'We’re using this endpoint to quickly retrieve all questions and answers and
    the correct answer to be used in our setup. Now that we’re able to retrieve quizzes
    and their details, we can finally build the next part of our setup: the SQS.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个端点来快速检索所有问题和答案以及用于我们设置的正确答案。现在我们能够检索到测验及其详细信息，我们终于可以构建设置的下一步：SQS。
- en: Setting up a basic Node project
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置基本的Node项目
- en: 'In this section, we won’t be using any Vue-related software. This part will
    depend mainly on Express ([https://expressjs.com/](https://expressjs.com/)) and
    Socket.io ([https://socket.io/](https://socket.io/)). This means we can’t rely
    on helpful CLI tools to create our project for us. Luckily, it’s not hard. Navigating
    back to the root of our project, we’ll create a new folder called `./sockets`.
    Via the CLI, we’ll run the `npm init` command to define our project, where we’ll
    simply accept all the defaults. Once done, we’ll install Express and Socket.io
    and some TypeScript tooling packages via the CLI:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们不会使用任何与Vue相关的软件。这部分主要依赖于Express ([https://expressjs.com/](https://expressjs.com/))
    和Socket.io ([https://socket.io/](https://socket.io/))。这意味着我们不能依赖有用的CLI工具来为我们创建项目。幸运的是，这并不难。返回到我们项目的根目录，我们将创建一个名为`./sockets`的新文件夹。通过CLI，我们将运行`npm
    init`命令来定义我们的项目，我们将简单地接受所有默认设置。一旦完成，我们将通过CLI安装Express、Socket.io和一些TypeScript工具包：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We’ll also create a `tsconfig.json` file in the `./sockets` folder that contains
    the following configuration:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在`./sockets`文件夹中创建一个`tsconfig.json`文件，其中包含以下配置：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For the game mechanics, I’ve provided a `Quiz` class that we can implement
    without going into any details. Create a `quiz.ts` file with the following contents:
    [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.10-quiz.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.10-quiz.ts).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于游戏机制，我提供了一个`Quiz`类，我们可以实现它而不必深入了解细节。创建一个名为`quiz.ts`的文件，其内容如下：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.10-quiz.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.10-quiz.ts)。
- en: 'Next, we can work on the socket connection. We’ll create an `index.ts` file
    in the `./sockets` folder with the following contents:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以处理套接字连接。我们将在`./sockets`文件夹中创建一个名为`index.ts`的文件，其内容如下：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This code scaffolds a blank server. As you can see, we’ve imported the `Quiz`
    class and used it to instantiate a game on the server. `clientAppUrl` is important:
    when using sockets, the **Cross-Origin Resource Sharing** (**CORS**; [https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS))
    policy will block incoming traffic coming from localhost, unless its origins are
    provided to the server.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码构建了一个空白服务器。正如你所见，我们已经导入了`Quiz`类，并使用它来在服务器上实例化一个游戏。`clientAppUrl`很重要：当使用套接字时，**跨源资源共享**（**CORS**；[https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)）策略将阻止来自localhost的传入流量，除非其来源被提供给服务器。
- en: 'We do have another problem now, though: the `Quiz` class expects data that
    comes from our Nuxt server, remember? We need to have the Nuxt server running
    in tandem with the SQS. We can do this manually, in separate terminal windows,
    but we can also script the boot process for more convenience. After all, once
    our work on the SQS is done, we need to be able to run another app to act as a
    client!'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们现在又遇到了另一个问题：`Quiz`类期望从我们的Nuxt服务器获取数据，记得吗？我们需要让Nuxt服务器与SQS同时运行。我们可以手动在单独的终端窗口中这样做，但也可以编写脚本来自动化启动过程，以便更方便。毕竟，一旦我们完成对SQS的工作，我们需要能够运行另一个应用程序来充当客户端！
- en: Executing scripts in parallel
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行执行脚本
- en: 'In this section, we’ll focus on the root folder of our project, from where
    we’ll trigger the scripts in sub-folders. We’ll navigate to the root with the
    terminal and set up another Node project using `npm init`, accepting the defaults.
    Once we’re done, we’ll install some helper packages:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将关注我们项目的根目录，从这里我们将触发子目录中的脚本。我们将使用终端导航到根目录，并使用`npm init`设置另一个Node项目，接受默认设置。一旦完成，我们将安装一些辅助包：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We’ll also create a file called `open.mjs` with the following contents:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个名为`open.mjs`的文件，其内容如下：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this file, we’re using the `open` package to automatically open a browser
    window. To make the status more recognizable in the console, we use `chalk` to
    add color to certain parts of the logs. Now, when we open `package.json`, we can
    change the `scripts` property so that it matches the following sample:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们使用 `open` 包来自动打开浏览器窗口。为了使控制台中的状态更易于识别，我们使用 `chalk` 为日志的某些部分添加颜色。现在，当我们打开
    `package.json` 时，我们可以更改 `scripts` 属性，使其与以下示例匹配：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So, what’s happening here? The `npm-run-all` command triggers multiple commands
    in parallel mode – in our case, all scripts that are prefixed with `dev`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里发生了什么？`npm-run-all` 命令以并行模式触发多个命令——在我们的情况下，所有以 `dev` 为前缀的脚本：
- en: The `dev:sockets` script uses `nodemon` to run and watch for file changes in
    our socket project folder
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev:sockets` 脚本使用 `nodemon` 在我们的套接字项目文件夹中运行并监视文件更改'
- en: The `dev:server` script opens the Nuxt server from its folder
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev:server` 脚本从其文件夹中打开 Nuxt 服务器'
- en: The `dev:open` script executes the `open.mjs` script, which, in turn, opens
    a browser window on the predefined URL for the SQA
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev:open` 脚本执行 `open.mjs` 脚本，该脚本反过来会在预定义的 SQA URL 上打开浏览器窗口'
- en: If you don’t want the SQA to open every time you start the script, you could
    remove the `dev:open` script or remove the entry from the `urls` constant in the
    `open.mjs` file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想每次启动脚本时都打开 SQA，你可以删除 `dev:open` 脚本，或者从 `open.mjs` 文件中的 `urls` 常量中删除条目。
- en: At least we can now control the execution of multiple scripts with a single
    command. If we run `npm run dev` from the root of the project, it will automatically
    start the Nuxt server as well as the SQS!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 至少我们现在可以用一个命令控制多个脚本的执行。如果我们从项目的根目录运行 `npm run dev`，它将自动启动 Nuxt 服务器以及 SQS！
- en: Let’s take a step back and explain why a regular endpoint is not sufficient,
    as well as why we’re building a complete socket server as a layer between the
    server and the client(s).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，解释为什么常规端点不足以满足需求，以及为什么我们正在构建一个完整的套接字服务器作为服务器和客户端之间的层。
- en: Why sockets?
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用套接字？
- en: We’re using a socket server to act as the host of our quiz app. Sockets have
    the advantage over RESTful connections in that data transmission is bidirectional
    by default and a socket connection is stateful and persistent. This makes sockets
    ideal for applications that depend on instant updates, such as chat applications
    or, as in our case, online games (especially those that support collaboration
    or competition).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用套接字服务器作为我们的测验应用程序的主机。与 RESTful 连接相比，套接字的优势在于数据传输默认是双向的，套接字连接是有状态的和持久的。这使得套接字非常适合依赖于即时更新的应用程序，例如聊天应用程序，或者在我们的情况下，在线游戏（尤其是那些支持协作或竞争的游戏）。
- en: We’re starting a socket server where clients can connect to. A handshake takes
    place between the server and client on connecting, which establishes the agreements
    and protocol between the two. This handshake allows the server to identify the
    client, which is useful when we’re dealing with multiple clients but want to target
    individuals.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在启动一个客户端可以连接的套接字服务器。在连接时，服务器和客户端之间进行握手，这建立了两者之间的协议和约定。这个握手允许服务器识别客户端，这在处理多个客户端但想要针对个体时非常有用。
- en: Once the connection has been established, both the client and server can send
    events with context. The server can broadcast to all clients or an individual.
    The clients only send events to the server. Depending on the event and the context,
    we can process the event.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了连接，客户端和服务器都可以发送带有上下文的事件。服务器可以向所有客户端或单个客户端广播。客户端只向服务器发送事件。根据事件和上下文，我们可以处理事件。
- en: Using Sockets.io, we can broadcast events using `io.emit('event', context)`
    and listen to events using `io.on('event')`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Sockets.io，我们可以使用 `io.emit('event', context)` 广播事件，并使用 `io.on('event')` 监听事件。
- en: 'In our application, we’re going to see both methods in action on both the server
    and the client: the server handles the information being sent to clients and receives
    answers given by a client – we’ll even use it to control the navigational state
    of the client app! From the client’s side, we’ll listen to the sent events and
    use the sockets to send answers to our quiz’s answers.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将看到服务器和客户端上两种方法的实际应用：服务器处理发送给客户端的信息，并接收客户端给出的答案——我们甚至会用它来控制客户端应用程序的导航状态！从客户端方面来看，我们将监听发送的事件，并使用套接字向我们的测验答案发送回复。
- en: Completing the SQS
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成SQS
- en: 'We can finalize the SQS by replacing the contents of the `./index.ts` file
    in the `./sockets` folder with the following: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.11-index.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.11-index.ts).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`./sockets`文件夹中的`./index.ts`文件的内容替换为以下内容来最终确定SQS：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.11-index.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.11-index.ts).
- en: 'We’ve added the mechanics for communication now. The socket server gets initialized
    on *lines 27–76*. In the socket connection event, we have defined all the events
    the server needs to listen to:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了通信的机制。套接字服务器在*第27-76行*初始化。在套接字连接事件中，我们定义了服务器需要监听的所有事件：
- en: When a player has joined (*line 17*), the server signals other players with
    the current status (*lines 32,* *130 –133*)
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家加入时（*第17行*），服务器通过当前状态通知其他玩家（*第32行，第130-133行*）
- en: When a player is ready to start playing (*lines 37–41*), a player is added to
    the current game (*line 38*), and the other players are notified
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家准备好开始游戏时（*第37-41行*），玩家被添加到当前游戏中（*第38行*），并且通知其他玩家
- en: If a player answers a question during a game (*lines 43–50*), the answer is
    processed and, if needed, the player’s score is updated
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家在游戏过程中回答问题（*第43-50行*），则处理答案，并在需要时更新玩家的分数
- en: When a player selects a quiz (*lines 55–60*), the server queries the Nuxt server
    for the questions and updates it to the current game (*line 59*)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家选择测验时（*第55-60行*），服务器查询Nuxt服务器以获取问题，并将其更新到当前游戏中（*第59行*）
- en: When the quiz is started (*lines 62–66*), the current question is set to the
    first of the collection and the question is sent to the player (*lines 65,* *82–88*)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当测验开始时（*第62-66行*），当前问题被设置为集合中的第一个，并将问题发送给玩家（*第65行，第82-88行*）
- en: 'We have some options to send players to certain views:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些选项可以将玩家发送到特定的视图：
- en: There’s a method to send a question to the players (*lines 82–88*)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一种方法可以向玩家发送问题（*第82-88行*）
- en: In between every third question, we can show the current score (*lines 114–118*)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每第三个问题之间，我们可以显示当前得分（*第114-118行*）
- en: Once the quiz has ended, we direct players to the final score (*lines 120–125*)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦测验结束，我们将玩家引导到最终得分（*第120-125行*）
- en: As part of the game mechanics, answering the questions is time-based. The timer
    runs internally as part of the game, but we emit events once a timer has started
    (*lines 138–145*) or when it has ended (*lines 147–150*).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 作为游戏机制的一部分，回答问题是基于时间的。计时器作为游戏的一部分内部运行，但我们会在计时器开始时（*第138-145行*）或结束时（*第147-150行*）发出事件。
- en: With all of this, we have the basic needs for an interactive quiz. It’s not
    very robust, mind you, but it functions well enough to get our point across.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过所有这些，我们有了交互式测验的基本需求。请注意，它并不非常健壮，但足以有效地传达我们的观点。
- en: In the final section, we’re going to create an app to complete this whole quiz
    application platform!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们将创建一个应用程序来完成整个测验应用平台！
- en: Creating the CQA
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建CQA
- en: 'To wrap it all up, we’re going to create the client app as a Vuetify project
    in our projects’ root folder. Let’s navigate to the root folder by using the terminal
    and typing `npm create vuetify` to begin the installation. We’ll use the following
    settings:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结所有内容，我们将在项目的根目录下创建客户端应用程序作为Vuetify项目。让我们通过终端导航到根目录，并输入`npm create vuetify`以开始安装。我们将使用以下设置：
- en: '`app` as the project’s name'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app`作为项目的名称'
- en: For the preset, we’ll choose the default of `Base (``Vuetify, VueRouter)`
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于预设，我们将选择默认的`Base (Vuetify, VueRouter)`
- en: We’ll select TypeScript
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将选择TypeScript
- en: To install dependencies, we’ll select `npm`
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装依赖项时，我们将选择`npm`
- en: Once the installation completes, we can open the folder in our IDE to start
    editing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以打开文件夹并在我们的IDE中开始编辑。
- en: First, we’ll make some changes to the `vite.config.ts` file, which helps our
    app to work in our multi-app environment. We’ll add a new property called `clearScreen`
    with a value of `false`. This will prevent the process from clearing the logs
    (which will also contain our servers’ logs). We can simply add it at the bottom
    of the file.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将对`vite.config.ts`文件进行一些修改，这有助于我们的应用程序在多应用环境中工作。我们将添加一个名为`clearScreen`的新属性，其值为`false`。这将防止进程清除日志（其中也将包含我们的服务器日志）。我们只需在文件底部简单添加即可。
- en: 'Next, we’ll locate the `server` and `port` properties and change `port` to
    the new value – that is, `5173` (this corresponds to the CORS setting of our socket
    server). This prevents the Vuetify application from trying to occupy the same
    port as our Nuxt application! The bottom of the `vite.config.ts` file should resemble
    the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定位`server`和`port`属性，并将`port`更改为新值——即`5173`（这对应于我们的socket服务器的CORS设置）。这防止了Vuetify应用程序尝试占用与我们的Nuxt应用程序相同的端口！`vite.config.ts`文件的底部应该类似于以下代码：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Before we continue working on the app, we will add our client app to our main
    development script. Let’s open the `package.json` file from our project’s root
    and add a script to run our Vuetify development script:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续对应用程序进行工作之前，我们将把我们的客户端应用程序添加到我们的主要开发脚本中。让我们从项目根目录打开`package.json`文件并添加一个运行Vuetify开发脚本的脚本：
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Regarding the `open.mjs` file, we will add a URL that will automatically open
    the browser as well. We’ll give it a timeout of `5000` milliseconds because it
    needs to wait for Nuxt and the socket server to have been initialized:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`open.mjs`文件，我们将添加一个URL，该URL将自动打开浏览器。我们将给它一个`5000`毫秒的超时时间，因为它需要等待Nuxt和socket服务器初始化完成：
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, we can boot the app from the projects’ root by using the `npm run dev:client`
    command. We can also start up all of our scripts at once using the `npm run dev`
    command from the root of the project. This is very handy when working on features
    of the app since the app by itself is very reliant on the other entities running.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过使用`npm run dev:client`命令从项目的根目录启动应用程序。我们也可以通过在项目根目录使用`npm run dev`命令一次性启动所有脚本。当我们在应用程序的功能上工作时，这非常方便，因为应用程序本身非常依赖于其他正在运行的实体。
- en: Setting up the app
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置应用程序
- en: 'We’ll begin by setting up the routes and views for our app. We’ll move back
    to our app folder to make some changes to the `./src/router/index.ts` file: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.12-index.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.12-index.ts).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先设置应用程序的路由和视图。我们将回到应用程序文件夹，对`./src/router/index.ts`文件进行一些修改：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.12-index.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.12-index.ts)。
- en: 'Now, for all those routes, we’ll add a separate view Vue component in the `./src/views`
    folder. We’ll use the following template as a basis (replace the title in the
    template with a corresponding one for that view):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于所有这些路由，我们将在`./src/views`文件夹中添加一个单独的视图Vue组件。我们将使用以下模板作为基础（将模板中的标题替换为相应视图的标题）：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the end, you’ll end up with the following views:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将得到以下视图：
- en: '![Figure 8.6 – Newly created views to match our routes](img/B19563_08_06.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – 与我们的路由匹配的新创建的视图](img/B19563_08_06.jpg)'
- en: Figure 8.6 – Newly created views to match our routes
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 与我们的路由匹配的新创建的视图
- en: 'We’ll also simplify the layout by replacing the contents of `./src/layouts/default.vue`
    with the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将通过用以下内容替换`./src/layouts/default.vue`中的内容来简化布局：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can delete the `AppBar.vue` and `View.vue` files from the folder as well.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从文件夹中删除`AppBar.vue`和`View.vue`文件。
- en: In the next step, we’ll work on adding a connection to our server.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将着手添加到我们的服务器的连接。
- en: Adding the socket client
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加socket客户端
- en: 'At this point, it’s time to add the socket client to our app project. In the
    `./app` root folder, install the package by typing the following command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，是时候将socket客户端添加到我们的应用程序项目中了。在`./app`根文件夹中，通过输入以下命令安装包：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To use Socket.io in our app, we’ll create a file called `sockets.ts` in the
    `./src` folder with the following contents: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.13-sockets.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.13-sockets.ts).'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中使用Socket.io，我们将在`./src`文件夹中创建一个名为`sockets.ts`的文件，并包含以下内容：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.13-sockets.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.13-sockets.ts)。
- en: This file will handle the connection from the socket server and export the connection
    as a constant (*line 6*). In this file, we’ll also store and expose the data we’re
    receiving in a single object (*lines 18–29*). Since the object has multiple levels,
    we’ll use `reactive` over `ref` because of its deep reactive model ([https://vuejs.org/api/reactivity-core.html#reactive](https://vuejs.org/api/reactivity-core.html#reactive)).
    This `state` will propagate any changes it receives wherever it’s being used in
    our app.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件将处理来自套接字服务器的连接并将连接作为常量导出（*第6行*）。在此文件中，我们还将存储并公开我们接收到的数据，作为一个单一的对象（*第18-29行*）。由于对象具有多个层级，我们将使用`reactive`而不是`ref`，因为它的深度响应模型（[https://vuejs.org/api/reactivity-core.html#reactive](https://vuejs.org/api/reactivity-core.html#reactive)）。此`state`将传播它在我们的应用程序中使用的任何更改。
- en: Listening to socket events
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监听套接字事件
- en: 'Now, let’s create a feature where we can start to open a quiz. We expect users
    to enter the app via a link that contains the ID of a quiz. For that, we’ll update
    the `./src/views/Start.vue` file and completely replace its contents with the
    following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个功能，使我们能够开始打开一个测验。我们期望用户通过包含测验ID的链接进入应用程序。为此，我们将更新`./src/views/Start.vue`文件，并完全替换其内容如下：
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, we don’t even need any template here! The component grabs the
    `id` value from the router parameters. The code uses the socket to emit the `quiz:select`
    event and then redirects the user to the `/``lobby` route.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们甚至不需要任何模板！组件从路由参数中获取`id`值。代码使用套接字来发出`quiz:select`事件，然后将用户重定向到`/lobby`路由。
- en: Automated route changes
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动路由更改
- en: 'Before we continue to the lobby, we’ll modify the `./src/App.vue` file too
    so that it listens to specific state changes in the quiz and redirects to certain
    routes:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进入大厅之前，我们还将修改`./src/App.vue`文件，使其能够监听测验中的特定状态变化并重定向到某些路由：
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we’re importing `quizStatus` and watching for changes. Once an updated
    value matches one of our routes, we’ll programmatically update the router with
    the corresponding view. Now, let’s enter the lobby!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在导入`quizStatus`并监视其变化。一旦更新的值匹配我们的其中一个路由，我们将程序化地更新路由器以显示相应的视图。现在，让我们进入大厅！
- en: Player management in the lobby
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大厅中的玩家管理
- en: 'In the lobby, we want to be able to add ourselves as a player, but we also
    want to see an overview of all currently connected players. To add a player, we’ll
    create a new component in the `./src/components` folder called `PlayerAdd.vue`:
    [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.14-PlayerAdd.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.14-PlayerAdd.vue).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在大厅中，我们希望能够将自己添加为玩家，同时也想查看所有当前连接的玩家的概览。为了添加玩家，我们将在`./src/components`文件夹中创建一个新的组件，名为`PlayerAdd.vue`：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.14-PlayerAdd.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.14-PlayerAdd.vue)。
- en: In this case, we will use the socket connection to emit events (*lines 9–11,
    25 –27*) but we also read from the state to, for instance, only allow a player
    to connect once.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，我们将使用套接字连接来发出事件（*第9-11行，第25-27行*），但我们也会从状态中读取，例如，只允许玩家连接一次。
- en: 'Our next component in the folder, called `PlayersOverview.vue`, will complement
    the lobby: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.15-PlayersOverview.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.15-PlayersOverview.vue).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件夹中的下一个组件，名为`PlayersOverview.vue`，将补充大厅：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.15-PlayersOverview.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.15-PlayersOverview.vue)。
- en: This component only reads from the state and presents the overview in a nicely
    formatted way, with means for a user to identify themselves in the lobby view.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件仅从状态中读取，并以良好的格式展示概览，使用户能够在大厅视图中识别自己。
- en: 'We can now add these two components to the `./src/views/Lobby.vue` file to
    complete this feature:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将这两个组件添加到`./src/views/Lobby.vue`文件中，以完成此功能：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is our first opportunity to see our sockets in action! So, let’s have
    a look. Once we’ve run the development script, all three of our applications will
    run in parallel. To enter the lobby, we need to access the CQA via the local development
    URL and provide an ID as a parameter to the `/start` route. Remember our admin
    panel? It has a section called `/start/{QUIZ_ID}` route, to the lobby:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次看到我们的socket实际运作的机会！所以，让我们看看。一旦我们运行了开发脚本，我们的三个应用程序将并行运行。要进入大厅，我们需要通过本地开发URL访问CQA，并将ID作为参数提供给`/start`路由。还记得我们的管理员面板吗？它有一个名为`/start/{QUIZ_ID}`的路由，用于大厅：
- en: '![Figure 8.7 – A player has been added to the lobby](img/B19563_08_07.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7 – 已将玩家添加到大厅](img/B19563_08_07.jpg)'
- en: Figure 8.7 – A player has been added to the lobby
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 已将玩家添加到大厅
- en: Now, without closing the existing browser window on the lobby, flip back to
    the admin panel and open the same link in a new browser window. You should, again,
    be redirected to the lobby. But in this case, you will enter as a new player.
    You should see the player we added previously in the overview, ready to play!
    If you add a new player name, the new player will be added to both browser windows
    in real time via the socket server!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在不关闭现有大厅浏览器窗口的情况下，切换回管理员面板，并在新浏览器窗口中打开相同的链接。你将被再次重定向到大厅。但在这个情况下，你将以新玩家的身份进入。你应该在概览中看到我们之前添加的玩家，准备开始游戏！如果你添加一个新的玩家名称，新玩家将通过socket服务器实时添加到两个浏览器窗口中！
- en: 'Have a look at the console of our terminal. You will see messages indicating
    that the state of the players has changed:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们的终端控制台。你会看到显示玩家状态已更改的消息：
- en: '![Figure 8.8 – The console indicates the state of the players from the socket
    server](img/B19563_08_08.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8 – 控制台显示来自socket服务器的玩家状态](img/B19563_08_08.jpg)'
- en: Figure 8.8 – The console indicates the state of the players from the socket
    server
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – 控制台显示来自socket服务器的玩家状态
- en: Since we’ve already connected our views and routes, we can trigger the start
    of a quiz. If one of the players hits **Start**, the quiz will automatically iterate
    over all of the questions and eventually end up at the **Final Score** view. Feel
    free to try it out. You will notice that the quiz gets processed by both browser
    windows at the same time!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经连接了视图和路由，我们可以触发测验的开始。如果玩家之一点击**开始**，测验将自动遍历所有问题，并最终结束在**最终得分**视图。请随意尝试。你会注意到测验同时由两个浏览器窗口处理！
- en: We need some answers
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们需要一些答案
- en: 'Alright – it’s time to build on the core of our app: the answering mechanism.
    For this and upcoming sections, I recommend preparing a quiz that has four questions.
    That way, we can test all of the mechanics for a reasonable duration.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 好的——现在是时候构建我们应用程序的核心：回答机制了。对于这个和接下来的部分，我建议准备一个包含四个问题的测验。这样，我们可以在合理的时间内测试所有机制。
- en: 'We’re going to create a new component in the `./components` folder called `QuestionForm.vue`:
    [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.16-QuestionForm.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.16-QuestionForm.vue).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`./components`文件夹中创建一个新的组件，名为`QuestionForm.vue`：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.16-QuestionForm.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.16-QuestionForm.vue)。
- en: Similar to how we are adding and showing players, we are using the socket connection
    to emit our users’ input (*line 12*), while also reading the actual state and
    presenting it in the UI (*lines 15–17*).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们添加和显示玩家的方式类似，我们使用socket连接来发射用户的输入（*第12行*），同时读取实际状态并在UI中展示（*第15-17行*）。
- en: 'In the `./src/views/Question.vue`), we’ll import and display this component
    next to showing the current question as the title of the view:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在`./src/views/Question.vue`中，我们将导入并显示此组件，作为当前问题的标题显示在视图旁边：
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'By adding this component to the view, our users can each try and answer the
    question. And how about we show the user the results as well? Let’s create a new
    component called `AnswerResult.vue`: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.17-AnswerResult.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.17-AnswerResult.vue).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将此组件添加到视图中，我们的用户可以尝试并回答问题。我们是否也向用户展示结果呢？让我们创建一个新的组件，名为 `AnswerResult.vue`：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.17-AnswerResult.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.17-AnswerResult.vue).
- en: In the preceding file, we’re using the state of the quiz coming from the socket
    server to display whether the individual user has answered correctly. As you can
    see, we can perfectly track which user is which and show them a customized interface.
    In this case, we’re doing the filtering on the client app.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的文件中，我们正在使用来自socket服务器的测验状态来显示单个用户是否回答正确。如您所见，我们可以完美地追踪哪个用户是哪个，并向他们展示定制的界面。在这种情况下，我们是在客户端应用程序中进行过滤。
- en: 'Again, we can add this `AnswerResult` component to the correct view – in this
    case, the `Answer.vue` file:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以将此 `AnswerResult` 组件添加到正确的视图中——在这种情况下，是 `Answer.vue` 文件：
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'At this point, the client application already starts to closely resemble the
    result we’re going for:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，客户端应用程序已经开始非常接近我们想要的结果：
- en: '![Figure 8.9 – Example of the quiz’s state when answered correctly!](img/B19563_08_09.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – 测验回答正确时的状态示例！](img/B19563_08_09.jpg)'
- en: Figure 8.9 – Example of the quiz’s state when answered correctly!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – 测验回答正确时的状态示例！
- en: At this point, our work is getting a bit repetitive, so let’s finalize our app
    by showing intermediate results and the final score!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的工作开始变得有些重复，所以让我们通过显示中间结果和最终得分来完善我们的应用！
- en: Keeping and showing the score
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保留和显示得分
- en: 'For our scoreboard, we’ll create another component called `ScoreBoard.vue`
    in the components folder: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.18-ScoreBoard.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.18-ScoreBoard.vue).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的得分板，我们将在组件文件夹中创建另一个名为 `ScoreBoard.vue` 的组件：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.18-ScoreBoard.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.18-ScoreBoard.vue).
- en: 'We’ll add the component to the **ScoreBoard** view:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将组件添加到 `ScoreBoard` 视图中：
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For the final score, we want to do something extra fun for the winner. We’ll
    install the *Vue Confetti Explosion* component ([https://github.com/valgeirb/vue-confetti-explosion](https://github.com/valgeirb/vue-confetti-explosion))
    by running the following command in the `./app` folder’s terminal:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最终得分，我们希望为赢家做一些额外有趣的事情。我们将在 `./app` 文件夹的终端中运行以下命令来安装 *Vue Confetti Explosion*
    组件（[https://github.com/valgeirb/vue-confetti-explosion](https://github.com/valgeirb/vue-confetti-explosion)）：
- en: '[PRE33]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And for our grand finale, we’ll make sure to include confetti for the quiz
    winner by creating the following contents in a component called `FinalScoreBoard.vue`:
    [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.19-FinalScoreBoard.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.19-FinalScoreBoard.vue).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的盛大结局，我们将确保在名为 `FinalScoreBoard.vue` 的组件中为测验赢家添加彩带，创建以下内容：[https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.19-FinalScoreBoard.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/08.quiz/.notes/8.19-FinalScoreBoard.vue).
- en: The important bit here is that we identify which user is the winner and shower
    that user with confetti (*lines 6,* *22–24, 53–55*)!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是我们要识别哪个用户是赢家，并向该用户展示彩带（*第 6 行、* *第 22-24 行、第 53-55 行*）！
- en: 'The `FinalScoreBoard` component also needs to be added to its corresponding
    view file (`./src/views/FinalScore.vue`):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`FinalScoreBoard` 组件也需要添加到其相应的视图文件（`./src/views/FinalScore.vue`）中：'
- en: '[PRE34]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And with that, our app is complete! You should now be able to complete the
    quiz with one or more players at the same time:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们的应用就完成了！你现在应该能够同时让一个或多个玩家完成测验：
- en: '![Figure 8.10 – There can be only one winner in this game](img/B19563_08_10.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.10 – 这场比赛只能有一个赢家](img/B19563_08_10.jpg)'
- en: Figure 8.10 – There can be only one winner in this game
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 – 这场比赛只能有一个赢家
- en: I think it’s brilliant that our client apps have almost no state worth mentioning.
    All of it is handled by the central socket server!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们的客户端应用程序几乎没有值得提及的状态。所有这些都由中央网络套接字服务器处理！
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was quite a lengthy chapter that covered three different apps. I hope the
    distinct roles of the individual apps are clear. I also hope you appreciate the
    differences between a socket server setup and a RESTful server. We’ve used both
    in this chapter, each with its strengths.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章节相当长，涵盖了三个不同的应用程序。我希望各个应用程序的独立角色是清晰的。我也希望你能欣赏套接字服务器设置和RESTful服务器之间的差异。在这一章节中，我们使用了两者，各自都有其优势。
- en: Also, with the amount of code we’ve written in this chapter, it should be clear
    that this code is not at the level of sturdiness nor as secure as you would realistically
    want it to be when it’s production-ready. I want to stress that this wasn’t the
    focus of this chapter!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，考虑到我们在这一章节中编写的代码量，应该很清楚，这些代码在稳健性和安全性方面并不如你期望的生产就绪版本那样。我想强调，这并不是本章的重点！
- en: One of the new concepts that was introduced in this chapter was Nuxt. As you
    may have noticed, it has very powerful capabilities that enhance both the final
    product and the developer experience. You could consider Nuxt a default extension
    of any Vue application. I can get behind the philosophy of making it easy to do
    things right while making it hard to do things wrong. The opinionated setup that
    Nuxt encourages makes it easy to get started with.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章节中引入的新概念之一是Nuxt。正如你可能已经注意到的，它具有非常强大的功能，可以提升最终产品和开发者的体验。你可以将Nuxt视为任何Vue应用的默认扩展。我支持使其易于正确做事，同时使错误做事变得困难的理念。Nuxt鼓励的具有偏见的设置使其容易上手。
- en: The socket server is sort of an odd one between all of our projects. But as
    we can see from the implementation on the client side, its real-time updates fit
    very well with the reactivity model of Vue applications.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 网络套接字服务器在我们的所有项目中算是一个有点特别的存在。但正如我们从客户端的实现中可以看到的那样，它的实时更新与Vue应用的响应式模型非常契合。
- en: As a closing remark, we’ve also made some small quality-of-life improvements
    in our development workflow by creating scripts that automate repetitive tasks
    for us. You can consider it as a sort of stepping stone toward workspaces or monorepo
    setups, which expand even further upon managing projects that depend on each other.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 作为结束语，我们还通过创建自动化重复性任务的脚本，在我们的开发工作流程中做了一些小的质量提升。你可以将其视为一种迈向工作空间或单仓库设置的垫脚石，这进一步扩展了相互依赖的项目管理。
- en: In the next chapter, we’ll scope down on the number of applications and build
    something fun too by using artificial intelligence and object recognition in a
    Vue app!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将缩小应用程序的数量，并通过在Vue应用中使用人工智能和对象识别来构建一些有趣的东西！
