- en: Testing Personal Trainer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unless you are a superhero who codes perfectly, you need to test what you build.
    Also, unless you have loads of free time to test your application again and again,
    you need some test automation.
  prefs: []
  type: TYPE_NORMAL
- en: When we say Angular was built with testability in mind, we really mean it. It
    has a strong **Dependency Injection** (**DI**) framework, some good mock constructs,
    and awesome tools that make testing in an Angular app a fruitful endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is all about testing and is dedicated to testing what we have built
    over the course of this book. We test everything from components to pipes, services,
    and our app directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we cover in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding the big picture**: We will try to understand how testing fits
    into the overall context of Angular app development. We will also discuss the
    types of testing Angular supports, including unit and **end-to-end** (**E2E**)
    testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overview of tools and frameworks**: We will cover the tools and frameworks
    that help in both unit and end-to-end testing with Angular. These include **Karma**
    and **Protractor**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Writing unit tests**: You will learn how to do unit testing with Angular
    using **Jasmine** and **Karma** inside a browser. We will unit test what we have
    built in the last few chapters. This section also teaches us how to unit-test
    various Angular constructs, including pipes, components, services, and directives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating end-to-end tests**: Automated end-to-end tests work by mimicking
    the behavior of the actual user through browser automation. You will learn how
    to use Protractor combined with WebDriver to perform end-to-end testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let the testing begin!
  prefs: []
  type: TYPE_NORMAL
- en: 'As you start reading this chapter, we suggest that you download the code for
    `checkpoint 7.1`. It is available on GitHub ([https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample))
    for everyone to download. Checkpoints are implemented as branches in GitHub. If
    you are not using Git, download the snapshot of `checkpoint7.1` (a ZIP file) from
    this GitHub location: [https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  prefs: []
  type: TYPE_NORMAL
- en: This checkpoint contains the tests that were generated by the Angular CLI as
    we created components, services, pipes, and directives in the earlier chapters.
    We have made minor changes in these tests so that they all pass. For the most
    part these are basic "Hello World" tests that confirm the creation of a component
    or other Angular construct. We will not be covering these tests in this chapter,
    but encourage you to review them.
  prefs: []
  type: TYPE_NORMAL
- en: The need for automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The size and complexity of apps being built for the web are growing with each
    passing day. The plethora of options that we now have to build web apps is just
    mind-boggling. Add to this the fact that the release cycles for products/apps
    have shrunk drastically from months to days, or even multiple releases per day!
    This puts a lot of burden on software testing. There is too much to be tested.
    Multiple browsers, multiple clients and screen sizes (desktop and mobile), multiple
    resolution, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: To be effective in such a diverse landscape, automation is the key. *Automate
    everything that can be automated* should be our mantra.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Angular team realized the importance of testability and hence created a
    framework that allowed easy testing (automated) for apps built on it. The design
    choice of using DI constructs to inject dependencies everywhere has helped. This
    will become clear as the chapter progresses and we build a number of tests for
    our apps. However, before that, let's understand the types of testing that we
    target when building apps on this platform.
  prefs: []
  type: TYPE_NORMAL
- en: Types of testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are broadly two forms of testing that we do for a typical Angular app:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing**: Unit testing is all about testing a component in isolation
    to verify the correctness of its behavior. Most of the dependencies of the component
    under test need to be replaced with mock implementations to make sure that the
    unit tests do not fail due to failure in a dependent component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**End-to-end testing**: This type of testing is all about executing the application
    like a real end user and verifying the behavior of the application. Unlike unit
    testing, components are not tested in isolation. Tests are done against a running
    system in real browsers, and assertions are done based on the state of the user
    interface and the content displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing is the first line of defense against bugs, and we should be able
    to iron out most issues with code during unit testing. But unless E2E is done,
    we cannot confirm that the software is working correctly. Only when all the components
    within a system interact in the desired manner can we confirm that the software
    works; hence, E2E testing becomes a necessity.
  prefs: []
  type: TYPE_NORMAL
- en: You can view these two types of testing like a pyramid with E2E testing on the
    top and unit testing on the bottom. The pyramid indicates that the number of unit
    tests you write should substantially exceed the number of E2E tests. The reason
    is that with unit tests you are breaking your application down into small testable
    units, whereas with integration tests you are spanning multiple components from
    the UI through to the backend. Also setting up E2E tests tends to be more complicated
    than unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Who writes unit and E2E tests and when are they written are important questions
    to answer.
  prefs: []
  type: TYPE_NORMAL
- en: Testing – who does it and when?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, E2E testing was done by the **Quality Assurance** (**QA**) team
    and developers were responsible for unit-testing their code before submitting.
    Developers did some amount of E2E testing too, but overall the E2E testing process
    was manual.
  prefs: []
  type: TYPE_NORMAL
- en: With the changing landscape, modern testing tools, especially on the web front,
    have allowed developers to write automated E2E tests themselves and execute them
    against any deployment setup (such as development/stage/production). Tools such
    as Selenium, together with WebDrivers, allow easy browser automation, thus making
    it easy to write and execute E2E tests against real web browsers.
  prefs: []
  type: TYPE_NORMAL
- en: A good time to write E2E scenario tests is when the development is complete
    and ready to be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to unit testing, there are different schools of thought around
    when a test should be written. A *Test Driven Developer* writes tests before the
    functionality is implemented. Others write tests when the implementation is complete
    to confirm the behavior. Some write while developing the component itself. Choose
    a style that suits you, keeping in mind that the earlier you write your tests,
    the better.
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to give any recommendations, nor are we going to get into an
    argument over which one is better. Any amount of unit tests is better than nothing.
    Our personal preference is to use the *middle approach*. With TDD, we feel that
    the test creation effort at times is lost as the specifications/requirements change.
    Tests written at the start are prone to constant fixes as the requirement changes.
    The problem with writing unit tests at the end is that our target is to create
    tests that pass according to the current implementation. The tests that are written
    are retrofitted to test the implementation where they should test the specifications.
    Adding tests somewhere in the middle works best for us.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now try to understand the tooling and technology landscape available for
    Angular testing.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular testing ecosystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Look at the following diagram to understand the tools and frameworks that support
    Angular testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The tools and frameworks that support Angular testing
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, we write our tests using unit testing libraries such as **Jasmine**
    or **Mocha**.
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, the Angular testing library works by default with *Jasmine*.
    However, the Angular team has indicated that they have made the framework more
    generic so that you can use other testing libraries such as Mocha with it. The
    Angular documentation has not yet been updated to include how to do this. For
    a discussion of using Mocha with the Angular CLI testing commands see [https://github.com/angular/angular-cli/issues/4071](https://github.com/angular/angular-cli/issues/4071).
  prefs: []
  type: TYPE_NORMAL
- en: These tests are executed by either Karma or Protractor depending on whether
    we are writing unit or integration tests. These test runners in turn run our tests
    in a browser such as Chrome, Firefox, IE, or headless browsers such as PhantomJS.
    It is important to highlight that not only E2E, but also unit tests are executed
    in a real browser.
  prefs: []
  type: TYPE_NORMAL
- en: All the tests in this chapter are written using Jasmine (both unit and integration
    tests). Karma will be our test runner for unit tests and Protractor for E2E tests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ultimate aim of unit testing is to test a specific piece of code/component
    in isolation to make sure that the components work according to the specification.
    This reduces the chances of failures/bugs in the component when integrated with
    other parts of the software. Before we start writing tests, there are some guidelines
    that can help us write good and maintainable tests:'
  prefs: []
  type: TYPE_NORMAL
- en: One unit should test one behavior. For obvious reasons, testing one behavior
    per unit test makes sense. A failing unit test should clearly highlight the problem
    area. If multiple behaviors are tested together, a failed test requires more probing
    to assert what behavior was violated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies in a unit test should be mocked away using test doubles such as
    fakes, mocks, or st. Unit testing, as the name suggests, should test the unit
    and not its dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests should not change the state of the component being tested permanently.
    If it does happen, other tests may get affected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of execution of unit tests should be immaterial. One unit test should
    not be dependent on another unit test to execute before it. This is a sign of
    a brittle unit test. It may also mean that the dependencies are not mocked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests should be fast. If they are not fast enough, developers will not
    run them. This is a good reason to mock all dependencies such as database access,
    remote web service call, and others in a unit test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unit tests should try to cover all code paths. Code coverage is a metric that
    can help us assess the effectiveness of unit tests. If we have covered all positive
    and negative scenarios during testing, the coverage will indeed be higher. A word
    of caution here: high code coverage does not imply that the code is bug-free,
    but low coverage clearly highlights a lack of areas covered in unit tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests should test both positive and negative scenarios. Just don't concentrate
    on positive test cases; all software can fail, and hence unit testing failure
    scenarios are as important to test as success scenarios.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These guidelines are not framework-specific, but give us enough ammunition for
    writing good tests. Let's begin the process of unit testing by setting up the
    components required for it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Karma and Jasmine for unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we created our project using the Angular CLI, the CLI configured the setup
    for unit testing our code with Karma and Jasmine. It did so by adding several
    Karma and Jasmine modules to our project. It also added a Karma configuration
    file—`karma.config.js`—to the root directory of our application—`trainer/`—and
    a file called `tests.ts` in the `trainer/src` directory. The CLI makes use of
    these files at runtime to create the configuration for executing our tests. This
    means that we can run our tests by simply using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: And the CLI will also watch our tests for changes and automatically rerun them.
  prefs: []
  type: TYPE_NORMAL
- en: We will not be covering the configuration files in detail here. The out-of-the-box
    settings will be fine for our purposes. Refer to the Karma documentation ([http://karma-runner.github.io/1.0/config/configuration-file.html](http://karma-runner.github.io/1.0/config/configuration-file.html))
    to understand more about the various Karma configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: Organization and naming of our test files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To unit test our app, we should have one test (such as `workout-runner.spec.ts`)
    file for each TypeScript file that we plan to test in our project. And this is
    what the Angular CLI does for us. When we create a component, service, pipe, or
    directive using the CLI, the CLI will generate a corresponding test and place
    it in the same file directory.
  prefs: []
  type: TYPE_NORMAL
- en: Naming the test files with the name of the file under test plus `.spec` is a
    convention that is used by developers who test with Jasmine. It is also used to
    facilitate the mapping of files to tests in the configuration steps that we outlined
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'This test file contains the unit test specification for the corresponding component,
    as shown in the following screenshot (taken in the Karma debugger when running
    our unit tests):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Unit-testing Angular applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of this book, we have built components that cover every construct
    available in Angular. We have built components, pipes, a few services, and finally
    some directives too. All of these are testable in unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: The code for the rest of this chapter can be found in `checkpoint 7.2`. It is
    available on GitHub ([https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample))
    for everyone to download. Checkpoints are implemented as branches in GitHub. If
    you are not using Git, download the snapshot of `checkpoint7.2` (a ZIP file) from
    this GitHub location: [https://github.com/chandermani/angular2byexample/archive/checkpoint7.2.zip](https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to get the hang of unit testing with Jasmine, let''s test the smallest
    and easiest component first: the pipe.'
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pipes are the easiest to test as they have minimum or zero dependencies on other
    constructs. The `SecondsToTimePipe` that we created for *Workout Runner* (the
    *7 Minute Workout* app) has no dependencies and can be easily unit-tested.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the Jasmine framework documentation to understand how to write unit
    tests using Jasmine. The CLI is using Jasmine 2.6 for our unit tests ([http://jasmine.github.io/2.6/introduction.html](http://jasmine.github.io/2.0/introduction.html)).
    Jasmine has some of the best documentations available and the overall framework
    is very intuitive to use. We strongly recommend that you head over to the Jasmine
    site and get yourself familiar with the framework before you proceed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the  `seconds-to-time.pipe.spec.ts` file in the `trainer/src/app/shared `
    folder and update the unit test in there as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at what we are doing here in our test file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not surprisingly, we import `SecondsToTimePipe`, which we are going to test.
    This is just like the imports we have used elsewhere in our TypeScript classes.
    Notice that we use a relative path to the file in which it is located `''./seconds-to-time.pipe''`.
    In Angular, this means to look for the component to test in the same directory
    as the test itself. As you recall, this is the way we set up our file structure:
    putting our tests in the same directory as the file under test.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next line, we start using Jasmine syntax. First, we wrap the test in
    a `describe` function that identifies the test. The first parameter of this function
    is a user-friendly description of the test; in this case, it is `SecondsToTimePipe`.
    For the second parameter, we pass a lambda (fat arrow) function that will contain
    our test. After setting up a local variable to hold the pipe, we call Jasmine's
    `beforeEach` function and use this to inject an instance of our pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `beforeEach` function runs before every test that is in our `describe` function,
    we can use it for common code that will run in each of our tests. In this case,
    it is not strictly necessary since there is only one test in our `describe` function.
    But it is a good idea to get into the habit of using it for common setup scenarios,
    as we will see going forward.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call Jasmine's `it` function and pass it a title, along with three
    calls to Jasmine's `expect` function (Jasmine's name for assertions). These are
    all self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: It is not necessary to explicitly import these Jasmine functions in our test.
  prefs: []
  type: TYPE_NORMAL
- en: Running our test files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it''s time to run our tests using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The Angular CLI will transpile our TypeScript files to JavaScript and then watch
    for changes in these files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should then see this output in the Terminal window (the total number of
    tests may be different for you):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The last line shows that our test passed successfully (along with all our other
    tests).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also view the test results in the browser window that Karma will launch
    when it runs our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You'll notice here that Karma displays the `describe` statement (SecondsToTimePipe)
    that is used for our pipe tests and nests under it under the `it` statement (should
    convert integer to time format) for the test we have created in order to show
    us the expected results for our test. Reading the results as they are displayed
    makes it very easy to understand the outcome of our test.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure that it is reporting the correct pass/fail results, let''s make
    a change in the test to cause one of the expectations to fail. Change the time
    in the first expectation to six seconds rather than five, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What's nice about this error message is that it combines the `describe` and
    `it` descriptions into a complete sentence that provides a clear summary of the
    error. This shows how Jasmine allows us to write readable tests so that someone
    who is new to our code can quickly understand any problems that may arise in it.
    The next line shows us which expectation was not met, what was expected, and what
    the actual results were that did not meet this expectation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also get a stack trace below this message and a final line that shows the
    overall results of our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And in the browser, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: One thing you'll notice is that when we make the change to our test, we do not
    have to rerun Karma. Instead, it watches for any changes in our files and related
    tests and immediately reports success or failure whenever we make a change.
  prefs: []
  type: TYPE_NORMAL
- en: Pretty cool! Let's undo the last change that we made and put the test back into
    a passing state.
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing Angular components is more complicated than testing simple pipes or
    services. That is because Angular components are associated with views and also
    usually have more dependencies than services, filters, or directives.
  prefs: []
  type: TYPE_NORMAL
- en: Angular testing utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because of their complexity, Angular has introduced utilities that enable us
    to test our components more easily. These testing utilities include the `TestBed`
    class (which we previously used to initialize our tests) and several helper functions
    in `@angular/core/testing`.
  prefs: []
  type: TYPE_NORMAL
- en: '`TestBed` has a `createComponent` method that returns a `ComponentFixture`
    containing several members and methods, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '`debugElement`: For debugging a component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentInstance`: For accessing the component properties and methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nativeElement`: For accessing the view''s markup and other DOM elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`detectChanges`: For triggering the component''s change detection cycle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ComnponentFixture` also contains methods for overriding the view, directives,
    bindings, and providers of a component. Going forward, we will be using `TestBed`
    throughout the rest of our tests.'
  prefs: []
  type: TYPE_NORMAL
- en: '`TestBed` has a method called `configureTestingModule` that we can use to set
    up our testing as its own module. This means we can bypass the initial bootstrap
    process and compile our components under test within our test files. We can also
    use `TestBed` to specify additional dependencies and identify the providers that
    we will need.'
  prefs: []
  type: TYPE_NORMAL
- en: According to the Angular documentation (https://angular.io/guide/testing#testbed-class-summary),
    it is important to *call TestBed methods within a* `beforeEach`*to ensure a fresh
    start before each individual test*.
  prefs: []
  type: TYPE_NORMAL
- en: Managing dependencies in our tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components in Angular integrate the view with everything else. Due to this,
    components normally have more dependencies compared to any of the services, filters,
    or directives.
  prefs: []
  type: TYPE_NORMAL
- en: Notwithstanding the fact that our unit tests focus on the code within the component
    itself, we still need to account for these dependencies in our tests or else the
    tests will fail (we skipped the dependency setup for pipe testing as it did not
    have external dependencies).
  prefs: []
  type: TYPE_NORMAL
- en: 'Two approaches exist for handling these dependencies: inject them into our
    component or create a mock or fake for them that we can use in our tests. If a
    dependency is simple enough, we can just inject an instance of it into our test
    class. However, if the dependency is significantly complicated, especially if
    it has dependencies of its own and/or makes remote server calls, then we should
    be mocking it. The Angular testing library provides the tools for us to do that.'
  prefs: []
  type: TYPE_NORMAL
- en: The component that we plan to test in this section is the `WorkoutRunner` component.
    Located inside `trainer/src/components/workout-runner/`, this is the component
    that runs a specific workout.
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing WorkoutRunnerComponent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this background, let's get started with unit testing `WorkoutRunnerComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open `workout-runner-component.spec.ts` and update the imports to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: These imports identify the test utilities (and things such as `Router` and `of`
    from `RxJS`) that we will be using in our tests along with the types and dependencies
    that our component requires. We'll discuss these dependencies in a moment. One
    import that looks different from the others is the one that imports `NO_ERRORS_SCHEMA`
    from `@angular/core`. We will use this import to ignore elements in the component
    that we will not be testing. Again, we will discuss that further in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: One more thing to note with the imports is that `@angular/core/testing` is a
    part of the core module and not in a separate testing module. This is a common
    pattern with imports for Angular testing. For example, when we get to testing
    HTTP, you will see that we are importing from `@angular/http/testing`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up component dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we need to establish our component''s dependencies and determine whether
    we need to inject or mock them. If we look at the code for the `WorkoutRunner`
    component, we see that there are three dependencies being injected into our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkoutHistoryTracker`: This is a component that has some behavior attached
    to it. So we definitely want to mock it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Router`: We''ll have to mock this too in order to isolate `WorkoutRunner`
    from the rest of the application and prevent our test from trying to navigate
    away from the `WorkoutRunner` view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WorkoutService:` This is a service that we will use to make an HTTP call to
    retrieve our workouts. We will mock this service as well since we don''t want
    to be making a call to an external system within our test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking dependencies - workout history tracker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular allows us to mock our dependencies in a straightforward manner using
    simple classes. Let''s start with mocking `WorkoutHistoryTracker`. To do that,
    add the following class just after the imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We do not need to mock the entire `WorkoutHistoryTracker` class, but only the
    methods that `WorkoutRunner` will be calling. In this case, those methods are
    `startTracking()`, `endTracking()`, and `exerciseComplete()`. We have made these
    methods empty because we do not need anything returned from them in order to test
    `WorkoutRunner`. Now we can inject this dummy implementation into `WorkoutRunner` wherever
    it is looking for `WorkoutHistoryTracker`.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking dependencies – workout service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Chapter 5, *Supporting Server Data Persistence*, we extended the workout
    service to make a remote call to retrieve the data that populates a workout. For
    unit testing the workout runner, we will want to replace that call with a mock
    implementation that returns some static data that we can use to run the test.
    So we will add a third mock class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `getWorkout` method is returning an `Observable`, as indicated
    by the use of the `of` operator. Otherwise the class is self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking dependencies - router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with `WorkoutHistoryTracker` and `WorkoutService`, we also will be using
    mocking to handle the dependency that we have on the Angular router. But here
    we will be taking a slightly different approach. We will assign a Jasmine spy
    to a `navigate` method on our mock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will be sufficient for our purposes because we only want to make sure that
    the router's `navigate` method is being called with the appropriate route (`finished`)
    as a parameter. The Jasmine spy will allow us to do that as we will see later.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring our test using TestBed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our imports and dependencies out of the way, let''s get started
    with the tests themselves. We begin by adding a Jasmine `describe` function that
    will wrap our tests, followed by setting two local variables using `let`: one
    for `fixture` and the other for `runner`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we''ll add a `beforeEach` function that sets up our test configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `beforeEach` method executes before each test, which means that we will
    only have to set this up once in our test file. Inside `beforeEach`, we add an
    `async` call. This is required because of the asynchronous `compileComponents`
    method that we are calling.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular documentation indicates that the `async` function arranges for the
    tester's code to run in a special `async` test zone that hides the mechanics of
    asynchronous execution, just as it does when passed to an `it` test. For more
    information refer to `https://angular.io/docs/ts/latest/guide/testing.html#!#async-in-before-each`.
    We'll discuss this in more detail shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go through each method call in the order that they are executed. The first
    method, `configureTestingModule`, allows us to build on the base configuration
    of the testing module and add things such as imports, declarations (of the components,
    directives, and pipes we will be using in our test), and providers. In the case
    of our test, we are first adding declarations for the workout runner, our component
    under test, and the `SecondsToTimePipe:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add three providers for our `Router`, `WorkoutHistoryTracker`, and
    `WorkoutService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For each of these providers, we set the `useClass` property to our mocks instead
    of the actual components. Now, anywhere in our test, when the `WorkoutRunner`
    requires any of these components, the mock will be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next configuration may seem a bit mysterious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This setting allows us to bypass the errors we would otherwise get regarding
    the custom elements associated with two components that we are using in the component's
    template: `ExerciseDescriptionComponent` and `VideoPlayerComponent`. At this point,
    we don't want to be testing these components within the test for the `WorkoutRunnerComponent`.
    Instead, we should be testing them separately. One thing to be aware of, however,
    when you use this setting is that it will suppress all schema errors related to
    elements and attributes in the template of the component under test; so it may
    hide other errors that you do want to see.
  prefs: []
  type: TYPE_NORMAL
- en: When you set up a test using `NO_ERRORS_SCHEMA`, you are creating what is called
    a shallow test, one that does not go deeper than the component you are testing.
    Shallow tests allow you to reduce complexities in the templates within the component
    you are testing and reduce the need for mocking dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final steps in the configuration of our test are to compile and instantiate
    our components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned previously, we are using an `async` function in our `beforeEach`
    method because this is required when we call the `compileComponents` method. This
    method call is asynchronous and we need to use it here because our component has
    an external template that is specified in a `templateUrl`. This method compiles
    that external template and then inlines it so that it can be used by the `createComponent`
    method (which is synchronous) to create our component fixture. This component
    fixture in turn contains a `componentInstance`-`WorkoutRunner`. We then assign
    both the `fixture` and the `componentInstance` to local variables.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, the `async` function we are using creates a special
    `async` test zone in which our tests will run. You'll notice that this function
    is simplified from normal `async` programming and lets us do things such as using
    the `.then` operator without returning a promise.
  prefs: []
  type: TYPE_NORMAL
- en: You can also compile and instantiate test components inside individual test
    methods. But the `beforeEach` method allows us to do it once for all our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have configured our test, let's move on to unit-testing `WorkoutRunner`.
  prefs: []
  type: TYPE_NORMAL
- en: Starting unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting from the loading of workout data to transitioning of exercises, pausing
    workouts, and running exercise videos, there are a number of aspects of the `WorkoutRunner`
    that we can test. The `workout.spec.ts` file (available in the `components/workout-runner`
    folder under `trainer/src`) contains a number of unit tests that cover the preceding
    scenarios. We will pick up some of those tests and work through them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, let''s add a test case that verifies that the workout starts
    running once the component is loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This test asserts that the total duration of the workout is correct and the
    workout is in the running state (that is, not paused).
  prefs: []
  type: TYPE_NORMAL
- en: So let's execute the test. It fails (check the Karma console). Strange! All
    the dependencies have been set up correctly, but still the second `expect` function
    of the `it` block fails as it is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: We need to debug this test.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging unit tests in Karma
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging unit tests in Karma is easy as the tests are run in the browser. We
    debug tests as we debug the standard JavaScript code. And since our Karma configuration
    has added mappings from our TypeScript files to our JavaScript files, we can debug
    directly in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: When Karma starts, it opens a specific browser window to run the tests. To debug
    any test in Karma, we just need to click on the Debug button available at the
    top of the browser window.
  prefs: []
  type: TYPE_NORMAL
- en: There is one window opened by Karma and one when we click on Debug; we can use
    the original window for testing too, but the original window is connected to Karma
    and does a live reload. Also, the script files in the original window are timestamped,
    which changes whenever we update the test and hence requires us to put in a breakpoint
    again to test.
  prefs: []
  type: TYPE_NORMAL
- en: Once we click on Debug, a new tab/window opens with all the tests and other
    app scripts loaded for testing. These are scripts that were defined during the
    Karma configuration setup in the `karma.conf.js` files section.
  prefs: []
  type: TYPE_NORMAL
- en: To debug the preceding failure, we need to add breakpoints at two locations.
    One should be added inside the test itself and the second one inside  `WorkoutComponent`,
    where it loads the workout and assigns the data to the appropriate local variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to add a breakpoint in Google Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Karma debug window/tab by clicking on the Debug button on the window
    loaded by Karma when it started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the F12 key to open the developer console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the Sources tab and the TypeScript files for your application will be
    located in the `source` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can now put breakpoints at the required locations just by clicking on the
    line number. This is the standard mechanism to debug any script. Add breakpoints
    at the locations highlighted here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We refresh the Debug page (the one we opened when we clicked on the Debug button).
    The breakpoint in `workout-runner.ts` is never hit, causing the test to fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What we overlooked is that the code that we were trying to reach is within
    the `start` method of `workout-runner`, and the `start` method is not being called
    in the constructor. Instead it is called in `ngDoCheck` after the data for the
    workout has been loaded through a call to the `getWorkout` method in `ngOnInit`.
    Add calls to `ngOnInit` and `ngDoCheck` in your test, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Save the change and Karma will run the test again. This time it will pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the number of tests grows, unit testing may require us to concentrate on
    a specific test or a specific suite of tests. Karma allows us to target one or
    more tests by prepending `f` to the existing `it` block; that is, `it` becomes
    `fit`. If Karma finds tests with `fit`, it only executes those tests. Similarly,
    a specific test suite can be targeted by prepending `f` to the existing `describe`
    block: `fdescribe`. Also, if you prepend `x` to an `it` block, making it `xit`,
    then that block will be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue unit-testing the component!
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing WorkoutRunner continued...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What other interesting things can we test? We can test whether the first exercise
    has started. We add this test to `workout.spec.ts` after the one we just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The second `expect` function in this test is interesting. It uses a Jasmine
    feature: spies. Spies can be used to verify method invocations and dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Jasmine spies to verify method invocations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A spy is an object that intercepts every call to the function it is spying on.
    Once the call is intercepted, it can either return fixed data or pass the call
    to the actual function being invoked. It also records the call invocation details
    that can be used later in `expect` as we did in the preceding test.
  prefs: []
  type: TYPE_NORMAL
- en: Spies are very powerful and can be used in a number of ways during unit testing.
    Look at the documentation on spies at [http://jasmine.github.io/2.0/introduction.html#section-Spies](http://jasmine.github.io/2.0/introduction.html#section-Spies)
    to learn more about them.
  prefs: []
  type: TYPE_NORMAL
- en: The second `expect` function verifies that the `startExercise` method was called
    when the workout started (`toHaveBeenCalledWith`). It is also asserting the correctness
    of the parameters passed to the function. The second `expect` statement asserts
    the behavior using a spy, but we first need to set up the spy to make this assert
    work.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are using the spy to mock a call to the `startExercise` method.
    We can use the spy to determine whether the method has been called and with what
    parameters, using Jasmine's `toHaveBeenCalledWith` function.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the Jasmine documentation for the `toHaveBeenCalled` and `toHaveBeenCalledWith`
    functions to learn more about these assert functions.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the method is being called with the current `Exercise` as a parameter.
    Since the previous `expect` confirms that this is the first exercise, this `expect`
    confirms that a call to start that first exercise was executed.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of things to note here. First, you have to be careful to
    put the setup for `spyOn` prior to calling `ngOnInit`. Otherwise, the spy will
    not be *spying* when the `startExercise` method is called and the method invocation
    will not be captured.
  prefs: []
  type: TYPE_NORMAL
- en: Second, since the spy is a mock, we will normally not be able to verify anything
    within the `startExercise` method. This is because the method itself is being
    mocked. This means that we cannot actually verify that the `currentExercise` property
    has been set, since that is being done inside the mocked method. However, Jasmine
    allows us to chain the spy with `and.callThrough`, which will mean that in addition
    to tracking the calls to the method, it will delegate to the actual implementation.
    This then allows us to test that the `currentExercise` has also been set correctly
    inside the `startExercise` method.
  prefs: []
  type: TYPE_NORMAL
- en: Using Jasmine spies to verify dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we just used a spy to verify the call to a method within our class, Jasmine
    spies are also useful in mocking calls to external dependencies. But why test
    calls to our external dependencies at all? After all, we are trying to limit our
    testing to the component itself!
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that we mock a dependency to make sure that the dependency does
    not adversely affect the component under test. From a unit testing perspective,
    we still need to make sure that these dependencies are called by the component
    being tested at the right time with the correct input. In the Jasmine world, spies
    help us assert whether dependencies were invoked correctly.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the `WorkoutRunner` implementation, we emit a message with the
    details of the workout whenever the workout starts. An external dependency, `WorkoutHistoryTracker`,
    subscribes to this message/event. So let's create a spy and confirm that `WorkoutHistoryTracker`
    started when the workout started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this `it` block after the preceding one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Within the `it` block, we add a spy on the `tracker`, a local instance of the
    `WorkoutHistoryTracker`. Then we use the spy to verify that the `startTracking`
    method of that dependency has been called. Simple and expressive!
  prefs: []
  type: TYPE_NORMAL
- en: You may recall that we are using `MockHistoryWorkoutTracker` here; it contains
    a mock, a `startTracking` method that is empty and returns nothing. That is fine
    because we are not testing the `WorkoutHistoryTracker` itself, but just the method
    invocation on it being made by the `WorkoutRunner`. This test shows how useful
    it is to be able to combine mocks with spies to fully test the inner workings
    of the `WorkoutRunner`, separately and apart from its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Testing event emitters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Examining the code for the `WorkoutRunner`, we see that it sets up several
    event emitters that look like the following one for `workoutStarted`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The Angular documentation describes an event emitter as an output property that
    fires events to which we can subscribe with an event binding. In Chapter 2, *Building
    Our First App - 7 Minute Workout*, we described in detail how event emitters are
    used in Workout Runner. So we have a good understanding of what they do. But how
    do we unit-test our event emitters and determine that they are firing events in
    the way we expect?
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s actually pretty easy to do. If we remember that an event emitter is an
    Observable Subject to which we can subscribe, we realize that we can simply subscribe
    to it in our unit test. Let''s revisit our test that verifies that a workout is
    starting and add the highlighted code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We injected the `WorkoutService` and added a subscription to the `WorkoutStarted`
    event emitter and an expectation that checks to see whether the property is emitting
    a `WorkoutPlan` when the event is triggered. The subscription is placed before
    `ngOnInit` because that is the method that results in the `workoutStarted` event
    being triggered, and we need to have our subscription in place before that happens.
  prefs: []
  type: TYPE_NORMAL
- en: Testing interval and timeout implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the interesting challenges for us is to verify that the workout progresses
    as time elapses. The `Workout` component uses `setInterval` to move things forward
    with time. How can we simulate time without actually waiting?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is the Angular testing library's `fakeAsync` function, which allows
    us to run otherwise asynchronous code synchronously. It does this by wrapping
    the function to be executed in a `fakeAsync` zone. It then supports using synchronous
    timers within that zone and also allows us to simulate the asynchronous passage
    of time with `tick()`.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about `fakeAsync`, see the Angular documentation at [https://angular.io/guide/testing#async-test-with-fakeasync.](https://angular.io/guide/testing#async-test-with-fakeasync)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can use the `fakeAsync` function to test the timeout and
    interval implementations in our code. Add the following test to `workout-runner.spec.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In addition to injecting `WorkoutRunner`, we first wrap the test in `fakeAsync`.
    Then we add a call to the `WorkoutRunner`'s `ngOnit()` method. This kicks off
    the timers for the exercises within `WorkoutRunner`. Then within the test, we
    use the `tick()` function set at various durations to test the operation of the
    timer for an exercise, and make sure that it continues running for the duration
    that we expected it to run. Using `tick()` allows us to fast forward through the
    code and avoid having to wait for the exercise to complete over several seconds
    as it would if we ran the code asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: At the end, we call `discardPeriodicTasks()` . This method is one of the Angular
    testing utilities and it can be used with  `fakeAsync` to clear any pending timers
    that may be in the task queue.
  prefs: []
  type: TYPE_NORMAL
- en: More information about these and other Angular testing utilities can be found
    at [https://angular.io/guide/testing#testing-utility-apis](https://angular.io/guide/testing#testing-utility-apis)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try another similar test. We want to make sure that the `WorkoutRunner`
    is correctly transitioning from one exercise to the next. Add the following test
    to `workout-runner.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Again we wrap the test in `fakeAsync` and call `runner.ngOnInit` to start the
    timer. Then we grab the duration of the first exercise and use the `tick()` function
    within the following `TestHelper` method to advance the timer one second beyond
    the duration of that exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Next, we test the expectation that we are now in the `rest` exercise and thus
    have transitioned from the first exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Testing workout pause and resume
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we pause a workout, it should stop and the time counter should not lapse.
    To check this, add the following time test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The test starts with verifying the state of the workout as not paused, advances
    the time for one second, pauses it, and then verifies that the time of `workoutTimeRemaining`
    does not change after the pause.
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing of services is not much different from unit-testing components.
    Once we get the hang of how to set up a component and its dependencies (mostly
    using mocks), it becomes a routine affair to apply that learning to testing services.
    More often than not, the challenge is to set up the dependencies for the services
    so that testing can be done effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Things are a little different for services that make remote requests (using
    either `http` or `jsonp`). There is some setup required before we can test such
    services in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: We will target `WorkoutService` and write some unit tests for it. Since this
    service makes remote requests to load workout data, we will explore how to test
    such a service with a mock HTTP backend. Angular provides us with the `HttpTestingController` for doing
    that.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking HTTP request/response with HttpTestingController
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When testing services (or, as a matter of fact, any other Angular construct)
    that make remote requests, we obviously do not want to make actual requests to
    a backend to check the behavior. That does not even qualify for a unit test. The
    backend interaction just needs to be mocked away. Angular provides for precisely
    that. Using `HttpTestingController`, we intercept HTTP requests, mock actual responses
    from the server, and assert endpoints invocation too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `workout-service.spec.ts`  and add the following import statements at
    the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the imports from the `core/testing` module, we are importing
    both `HttpClientTestingModule`  and  `HttpTestingController` from the `http/testing`
     module. We are also importing `WorkoutService` and `WorkoutPlan` that we will
    be testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the imports in place, we will begin creating the test with the
    Jasmine `describe`  statement that wraps our tests, and will set several local
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In addition to creating local variables for `HttpClient`, `HttpTestingController`,
    and `WorkoutService`, you'll also notice that we are setting local variables for
    our Mongo connection. To be clear, we are not setting these variables in order
    to make a remote call to Mongo, but instead to test that the connection properties
    are being set properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is set up the providers and dependency injection for our tests.
    To handle the providers, add the following to the test file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: First, we call `TestBed.configureTestingModule`  to import the `HttpClientTestingModule`
    and add the `WorkoutService`. According to the Angular documentation ([https://angular.io/api/common/http/testing/HttpClientTestingModule](https://angular.io/api/common/http/testing/HttpClientTestingModule)), `HttpClientTestingModule`
    sets up `HttpClient` to use `HttpClientTestingBackend` as `HttpBackend`. The nice
    thing here is that this setup is completely hidden from our test setup, so we
    don't have to write code to wire this up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we use the `TestBed.get` method to populate our local variables—`httpClient`,
    `httpTestingController`, and `workoutService`. We''ll also add the following `afterEach`
    method to make sure that after every test completes there are no more pending
    requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With this setup in place, we are now in a position to create tests for `WorkoutService`
    that avoid us making a remote call. We''ll start with a simple test that makes
    sure that `workoutService` loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: While this test may seem trivial, it is important to place it here because it
    acts as a check to make sure that we have set up our configuration correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll add the following test to make sure that we are able to inject `HttpClient`
    when we instantiate `WorkoutService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll move to testing several of the methods in the workout-service.
    First, we will make sure that it returns all workouts when the `getWorkouts` method
    is called. To do that, add the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We'll start by declaring two arrays of `WorkoutPlans`—`expectedWorkouts` and
    `actualWorkouts`. We'll then populate `expectedWorkouts` with four  `WorkoutPlans`.
    Because we are testing retrieval of the `WorkoutPlans` and not their content,
    we have made these minimal workouts.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `Http` module returns `RxJS` Observables, we next use the pattern
    of subscribing to those Observables. You should be used to seeing this pattern
    from our coverage of Observables in Chapter 5, *Supporting Server Data Persistence*.
    Notice that we use `fail` as the second parameter, which will cause the test to
    fail if there is an issue with subscribing to the Observable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we call a method on the `HttpTestingController` named `expectOne` passing
    our request URL. According to the Angular documentation ([https://angular.io/api/common/http/testing/HttpTestingController#expectone](https://angular.io/api/common/http/testing/HttpTestingController#expectone)),
    this method does two things: it expectsthat a request has been made that matches
    the URL provided in the method call and it returns a mock request. In the next
    line we make sure that the mock request is an HTTP GET. Finally, we flush the
    request with the `expectedWorkouts` and confirm that the `actualWorkouts` equal
    the `expectedWorkouts`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll follow the same pattern to build additional tests that confirm that
    we are able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Return a `workout` plan with a specific name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map `exercises` correctly within the `getWorkout` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can review these tests in the code for `checkpoint 7.2`. But one thing
    to note is that in both these tests we are testing two HTTP calls. For example,
    here is the code in the second of these two tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This may seem a little confusing at first until we realize that with the `getWorkout`
    method we are actually making two `Http` calls: one to retrieve a  `workout` and
    one to retrieve all  `exercises`. As you recall from Chapter 5, *Supporting Server
    Data Persistence*, we are doing that in order to create a fuller description of
    each `exercise` that is included within `workout`.'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we are finished with testing our service.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to learn how to test directives. The next section is dedicated
    to understanding the challenges in directive testing and how to overcome them.
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No other Angular constructs that we have tested so far do not involve any UI
    interaction. But directives, as we know, are a different beast. Directives are
    all about enhancing a component's view and extending the behavior of HTML elements.
    While testing directives, we cannot ignore the UI connections, and hence directive
    testing may not strictly qualify as unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good thing about directive testing is that its setup process is not as
    elaborate as that for services or components. The pattern to follow while unit-testing
    directives is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Take an HTML fragment containing the directive markup
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and link it to a mock component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the generated HTML has the required attributes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify if the changes that the directive created changes the state
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The TestBed class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, Angular provides the `TestBed` class to facilitate
    this kind of UI testing. We can use it to dig into the markup in a component's
    view and check for DOM changes that are triggered by events. Armed with this tool,
    let's get started with the testing of our directives. In this section, we are
    going to test `remoteValidator`.
  prefs: []
  type: TYPE_NORMAL
- en: This will be a good time to revisit the directives that we built in the previous
    chapter. Also, keep the code handy for the tests that we will create in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Testing remote validator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with unit-testing `remoteValidatorDirective`. Just to refresh our
    memory, `remoteValidatorDirective` validates an input against remote rules. It
    does so by calling a component method that returns a promise. If the promise is
    resolved with success, the validation passes; otherwise, the validation fails.
    The `[validateFunction]` attribute provides the link between the DOM and the component's
    method that checks for the duplication.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to our other test files, we have a `remote-validator.directive.spec.ts`
    file in the shared folder. Refer to the file in `checkpoint 7.2` for the imports,
    which we will not cover at this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just below the import statements, add the following component definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This component looks a lot like the components that we set up in our other tests
    to mock dependencies. Here, however, it is serving a slightly different purpose;
    it is acting as a host container for the directive that we will be testing. Using
    this minimal component, lets us avoid having to load the actual host for this
    directive, which is the `Workout` component.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to notice here is that we have set up a method for `validateWorkoutName`
    that will be called by our directive. It is essentially a stub that just returns
    a resolved `Promise` of `false`. Remember that we are not concerned with how this
    method handles its validation, but with verifying that the directive calls it
    and returns the correct result, either `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we set up the `describe` statement for our test suite by adding the following
    code, which injects  `RemoteValidatorDirective` into our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are setting up local variables for  `fixture`, its `componentInstance`,
    and `debugElement`. We are also using `by.css` (which we will see more of in our
    end-to-end tests) along with the query method on  `debugElement` to extract the
    `workoutName` input from our component. We'll be using these to delve into the
    rendered HTML in our directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to write our individual tests. First, we''ll write a test
    to confirm that we have been able to load  `RemoteValidatorDirective`. So add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s interesting about this test is that using the `debugElement`, we have
    been able to drill-down into the attributes of the input tag in our host component
    and find our validator, confirming that it has indeed been loaded. Also notice
    the use of `fakeAsync`, which we discussed in connection with unit testing. Using
    it makes it possible for us to write our tests in a synchronous fashion and avoid
    the complications that would otherwise exist with trying to manage the asynchronous
    rendering of our host component. Next, we''ll write two tests to confirm that
    our validator is working properly. The first test will make sure that an error
    is created if remote validation fails (that is, a workout with the same name as
    the one we are using is found). Add the following code for that test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we are using `fakeAsync` to eliminate the challenges that we would otherwise
    have with the async behavior associated with the rendering and execution of our
    `remoteValidatorDirective`. Next, we add a spy to track the invocation of the
    `validateWorkoutName` method. We also set the spy to call through to our method,
    because in this case, we are expecting it to return false. The spy is being used
    to verify that our method has indeed been invoked. Next, we set `fixture.detectChanges`,
    which triggers a change detection cycle. We then set the value of our input and
    call tick, which will, we hope, trigger the response we are expecting from our
    remote validator. We then grab the form encapsulating our input tag using the
    injector that is available from the child element array of the debug element.
    From there, we extract the form control for our input box. Then we run several
    expectations that confirm that an error has been added both to our control and
    to the form and that both are now in an invalid state. The next test is the mirror
    opposite of this test and it checks for a positive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Other than changing the expectations, the only change we are making from the
    previous test is setting up our spy to return a value of `true`. Unit-testing
    our `remoteValidatorDirective` shows how powerful the `TestBed` utilities are
    in testing our UI and the elements and behaviors associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with E2E testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated **E2E** testing is an invaluable asset if the underlying framework
    supports it. As the size of an app grows, automated E2E testing can save a lot
    of manual effort.
  prefs: []
  type: TYPE_NORMAL
- en: Without automation, it's just a never-ending battle to make sure that the app
    is functional. However, remember that in an E2E setup, not everything can be automated;
    automation may require a lot of effort. With due diligence, we can offload a sizable
    amount of manual effort, but not everything.
  prefs: []
  type: TYPE_NORMAL
- en: The process of E2E testing of a web-based application is about running the application
    in a real browser and asserting the behavior of the application based on the user
    interface state. This is how an actual user does testing.
  prefs: []
  type: TYPE_NORMAL
- en: Browser automation holds the key here, and modern browsers have become smarter
    and more capable in terms of supporting automation. Selenium tools for browser
    automation are the most popular option out there. Selenium has the WebDriver ([https://www.w3.org/TR/webdriver/](https://www.w3.org/TR/webdriver/))
    API that allows us to control the browser through the automation API that modern
    browsers natively support.
  prefs: []
  type: TYPE_NORMAL
- en: The reason behind bringing up Selenium WebDriver is that the Angular E2E testing
    framework/runner **Protractor** also uses **WebDriverJS**, which is a JavaScript
    binding of WebDriver on Node. These language bindings (like the preceding JavaScript
    binding) allow us to use the automation API in the language of our choice.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss Protractor before we start writing some integration tests for
    our app.
  prefs: []
  type: TYPE_NORMAL
- en: Introducting Protractor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Protractor** is the de facto test runner for E2E testing in Angular. Protractor
    uses Selenium WebDriver to control a browser and simulate user actions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical Protractor setup has the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: A test runner (Protractor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Selenium server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We write our test in Jasmine and use some objects exposed by Protractors (which
    is a wrapper over WebDriverJS) to control the browser.
  prefs: []
  type: TYPE_NORMAL
- en: When these tests run, Protractor sends commands to the Selenium server. This
    interaction happens mostly over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: The Selenium server, in turn, communicates with the browser using the *WebDriver
    Wire Protocol*, and internally the browser interprets the action commands using
    the browser driver (such as *ChromeDriver* in the case of Chrome).
  prefs: []
  type: TYPE_NORMAL
- en: It is not that important to understand the technicalities of this communication,
    but we should be aware of the E2E testing setup. Check out the article from the
    Protractor documentation at [http://angular.github.io/protractor/#/infrastructure](http://angular.github.io/protractor/#/infrastructure)
    to learn more about this flow.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to realize when using Protractor is that the overall
    interaction with the browser or the browser control flow is asynchronous in nature
    and promise-based. Any HTML element action, whether `sendKeys`, `getText`, `click`,
    `submit`, or any other, does not execute at the time of invocation; instead the
    action is queued up in a control flow queue. For this precise reason, the return
    value of every action statement is a promise that gets resolved when the action
    completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle this asynchronicity in Jasmine tests, Protractor patches Jasmine,
    and therefore assertions like these work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: They work despite the `getText` function returning a promise and not the element
    content.
  prefs: []
  type: TYPE_NORMAL
- en: With this basic understanding of how Protractor works, let's set up Protractor
    for end-to-end testing.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Protractor for E2E testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Angular CLI has already set up our project to allow us to use Protractor.
    The configurations for that setup can be found in the `protractor.config.js` file
    in the `trainer` folder. For the most part, you should be able to use those configurations
    without change to run your end-to-end tests. We did, however, make one change
    in that configuration file. We did extend the `defaultTimeoutInterval` in that
    file to 60000 milliseconds in order to give our tests that are running the workouts
    more time to finish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The configuration file documentation on the Protractor website ([https://github.com/angular/protractor/blob/master/lib/config.ts](https://github.com/angular/protractor/blob/master/lib/config.ts))
    contains details on other supported configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is enough to start testing with Protractor. In order to run our tests
    we simply execute the following command in the `trainer` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's get started with writing some end-to-end tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing E2E tests for the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start in a simple manner and test our app start page (`#/start`). This
    page has some static content, a workout listing section with search capabilities,
    and the ability to start a workout by clicking on any workout file.
  prefs: []
  type: TYPE_NORMAL
- en: All our E2E tests will be added to the `e2e` folder under `trainer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file called `app.e2e-spec.ts` to the `e2e` folder under `trainer`,
    which contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Let's walk through this simple test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first interesting piece is the import at the top of the page—`import {
    AppPage } from ''./app.po'';`. This is referring to a file in the same directory
    that contains what is called a page object.  This page object contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The use of the page object allows us to simplify the code in our test so that
    it is more readable. So instead of directly calling `browser.get ('/')` in our
    test, we call the `navigateTo()` method from our page object.
  prefs: []
  type: TYPE_NORMAL
- en: The browser object referred to in our page object is a global object exposed
    by Protractor and it is used to control the browser-level actions. Underneath,
    it is just a wrapper around WebDriver. The `browser.get("")` method navigates
    the browser to start the app page, every time, before the start of the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same for the `getParagraphText()` method—it allows us to call that method
    in our test and look for some text on the screen without having to identify the
    exact location on the page where that will appear. We''ll discuss page objects
    in more detail as we get into more complicated end-to-end testing. The `getParagraphText()` in
    our page object also employs two new globals, `element` and `by`, which are made
    available by Protractor:'
  prefs: []
  type: TYPE_NORMAL
- en: '`element`: This function returns an `ElementFinder` object. The primary job
    of `ElementFinder` is to interact with the selected element. We will be using
    the `element` function to select `ElementFinder` extensively in our tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the documentation at `http://www.protractortest.org/#/locators#actions`
    to learn more about element manipulation API support. Functions such as `getText()`
    are actually defined on `WebElement`, but are always accessed using `ElementFinder`.
    As the documentation suggests, `ElementFinder` can be treated as `WebElement`
    for most purposes. For more information, you can refer to `http://www.protractortest.org/#/locators#behind-the-scenes-elementfinders-versus-webelements`.
  prefs: []
  type: TYPE_NORMAL
- en: '`by`: This object is there to locate elements. It has functions that create
    `locators`. In the preceding test, a locator is created to search for elements
    with a css tag equal to `abe-root h1` If you are familiar with CSS selectors,
    you will know that this identifies what we are looking for as an `h1` tag inside
    the custom element `abe-root`. There are a number of locators that can be used
    to search for a specific element. These include by class, by ID, and by css. Refer
    to the Protractor documentation on locators at [http://angular.github.io/protractor/#/locators](http://angular.github.io/protractor/#/locators)
    to learn about the supported locators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just to reiterate what we discussed earlier, `getText()` in the page object
    does not return the actual text, but a Promise; we can still assert on the text
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Getting back to the actual test, it uses the methods in the page object to verify
    that some content ("Ready for a Workout?") is present on the page.
  prefs: []
  type: TYPE_NORMAL
- en: This simple test highlights another salient feature of Protractor. It automatically
    detects when the Angular app is loaded and when data is available for testing.
    There are no ugly hacks to delay testing (using `timeouts`) that may otherwise
    be required in standard E2E testing scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, this is an *SPA*; full-page browser refresh does not happen, so it
    is not that simple to determine when the page is loaded and when the data that
    is rendered for AJAX calls is available. Protractor makes it all possible.
  prefs: []
  type: TYPE_NORMAL
- en: Protractor may still time out while trying to assess whether the page is available
    for testing. If you are hitting timeout errors with Protractor, this article from
    the Protractor documentation can be really helpful ([http://www.protractortest.org/#/timeouts](http://www.protractortest.org/#/timeouts))
    for debugging such issues.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up backend data for E2E testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up backend data for E2E testing is a challenge, irrespective of the
    E2E framework that we employ for testing. The ultimate aim is to assert the behavior
    of an application against some data, and unless the data is fixed, we cannot verify
    the behavior that involves getting or setting data.
  prefs: []
  type: TYPE_NORMAL
- en: One approach to setting up data for E2E tests is to create a test data store
    specifically for E2E tests with some seed data. Once the E2E tests are over, the
    data store can be reset to its original state for future testing. For *Personal
    Trainer*, we can create a new database in MongoLab dedicated exclusively to E2E
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: This may seem a lot of effort, but it is necessary. Who said E2E testing is
    easy! In fact, this challenge is there even if we do manual testing. For a real
    app, we always have to set up data stores/databases for every environment, whether *dev*,
    *test*, or *production*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we will continue to use our existing backend, but go ahead and
    add another workout that we will use for testing. Name this workout `1minworkout`
    and give it a title of `1 Minute Workout`. Add two exercises to the workout: Jumping
    Jacks and Wall Sit. Set the duration of each exercise to 15 seconds and the rest
    time to one second.'
  prefs: []
  type: TYPE_NORMAL
- en: We have deliberately kept our new workout short so that we can complete our
    end-to-end testing of this workout within the normal timeouts provided by Protractor.
  prefs: []
  type: TYPE_NORMAL
- en: More E2E tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get back to testing the workout search features on the start page. With
    the addition of *1 Minute Workout*, we now have two workouts and we can assert
    search behaviors against these.
  prefs: []
  type: TYPE_NORMAL
- en: If you have added other workouts to the backend, just adjust the numbers in
    this test accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this test after the existing test in `workout-runner.spec.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The test uses `ElementFinder` and `Locator API` to look for elements on the
    page. Check the second line of the test. We are using the `element.all` function
    together with the `by.css` locator to do a multi-element match on all elements
    on the screen that are using the `.workout.tile` CSS class. This gives us a list
    of workouts against which the next line asserts the element count of 3.
  prefs: []
  type: TYPE_NORMAL
- en: The test then gets hold of the search input using the `element` function along
    with the `by.css` locator to do a single element match for an element using the
    `.form-contol` CSS class. We then use the `sendKeys` function to simulate data
    entry in the search input.
  prefs: []
  type: TYPE_NORMAL
- en: The last two expect operations check for the count of elements in our list,
    which after the search should be 1\. Also, they check whether the correct workout
    is filtered based on a `div` tag using the `title` CSS class that is a child of
    the element that contains our workout. This last expect statement highlights how
    we can chain element filtering and get hold of child elements in HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more test associated with the start page that we should add. It
    tests the navigation from the start page to the workout runner screen. Add this
    code for that test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This test uses the `click`  function to simulate clicking on a workout tile,
    and then we use the `browser.getCurrentUrl` function to confirm that the navigation
    is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Run the test again (`protractor tests/protractor.conf.js`) and once again observe
    the magic of browser automation as the tests run one after another.
  prefs: []
  type: TYPE_NORMAL
- en: Can we automate E2E testing for *Workout Runner*? Well, we can try.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Workout Runner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the major challenges with testing Workout Runner is that everything is
    time-dependent. With unit testing, at least we were able to mock the interval,
    but not anymore. Testing exercise transitions and workout completion is definitely
    difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before we tackle this problem or try to find an acceptable workaround,
    let''s digress and learn about an important technique to manage E2E testing: page
    objects!'
  prefs: []
  type: TYPE_NORMAL
- en: Using page objects to manage E2E testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We touched on page objects earlier. The concept of page objects is simple. We
    encapsulate the representation of page elements into an object so that we do not
    have to litter our E2E test code with `ElementFinder` and `locators`. If any page
    element moves, we just need to fix the page object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we can represent our Workout Runner page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This page object now encapsulates many of the elements that we want to test.
    By organizing the element selection code in one place, we increase the readability
    and hence the maintainability of E2E tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the Workout Runner page object to the top of the test file. We''ll
    use it in a test for the workout runner. Add the following new describe block
    containing the first of our workout runner tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The test verifies that the workout is loaded and the correct data is shown.
    We make full use of the page object that we defined earlier. Run the test and
    verify that it passes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get back to the challenge of testing code based on `interval` or `timeout`.
    Let''s add a test that confirms a click event on the screen, when the pause button
    is pushed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: What is interesting here is that we use the `browser.sleep` function within
    a promise to verify that the exercise time remaining is the same before and after
    the button is clicked. We are again using our `WorkoutRunner` page object to make
    the test more readable and understandable.
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to wrap up the chapter and summarize our learning.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We do not need to reiterate how important unit- and E2E-testing are for any
    application. The way the Angular framework has been designed makes testing the
    Angular app easy. In this chapter, we covered how to write unit tests and E2E
    tests using libraries and frameworks that target Angular.
  prefs: []
  type: TYPE_NORMAL
- en: For unit testing, we used Jasmine to write our tests and Karma to execute them.
    We tested pipes, components, services, and directives from *Personal Trainer*.
    In the process, we learned about the challenges and the techniques used to effectively
    test these types.
  prefs: []
  type: TYPE_NORMAL
- en: For E2E testing, the framework of choice was Protractor. We still wrote out
    tests in Jasmine, but the test runner this time was Protractor. We learned how
    Protractor automates E2E testing using Selenium WebDriver, as we did some scenario
    testing for the *Start* and *Workout Runner* pages.
  prefs: []
  type: TYPE_NORMAL
- en: If you have reached this point, you are getting closer to becoming a proficient
    Angular developer. The next chapter reinforces this with more practical scenarios
    and implementations built using Angular. We will touch upon important concepts
    in the last chapter of this book; these include multilingual support, authentication
    and authorization, communication patterns, performance optimizations, and a few
    others. You certainly do not want to miss them!
  prefs: []
  type: TYPE_NORMAL
