- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: The Foundation of Vue.js
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue.js 的基础
- en: If you are reading this book, chances are that you have decided to use Vue.js
    as your framework of choice and there is very little reason to try to convince
    you not to use it. We are going to use this chapter to begin sharing details of
    what makes Vue.js unique and why it has become so successful.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读这本书，那么你很可能已经决定将 Vue.js 作为你的首选框架，而且几乎没有理由试图说服你不要使用它。我们将利用这一章来开始分享 Vue.js
    独特之处及其成功的原因。
- en: We are first going to learn what makes Vue.js different from other frameworks;
    we will then move on to study Vue.js’ reactivity and its lifecycles. Finally,
    we will learn about the component structure of Vue.js.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将学习是什么让 Vue.js 与其他框架不同；然后我们将继续研究 Vue.js 的响应性和其生命周期。最后，我们将了解 Vue.js 的组件结构。
- en: 'In this chapter, we will learn the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Vue.js’ reactivity fundamentals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue.js 的响应式基础
- en: Understanding the Vue.js lifecycle and hooks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Vue.js 的生命周期和钩子
- en: Vue.js’ component structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue.js 的组件结构
- en: The goal of this chapter is to provide you with information regarding Vue.js
    that will become the foundation of your future learning. Understanding Vue.js’
    reactivity will help differentiate Vue.js from other frontend frameworks and libraries,
    and you will learn the complete lifecycle of a Vue.js component to help you make
    the correct technical decisions. Finally, understanding the different ways to
    define a Vue.js component will prepare you for the chapters to come.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是提供有关 Vue.js 的信息，这将成为你未来学习的基石。理解 Vue.js 的响应性将帮助你区分 Vue.js 与其他前端框架和库，你将学习
    Vue.js 组件的完整生命周期，以帮助你做出正确的技术决策。最后，了解定义 Vue.js 组件的不同方式将为你准备接下来的章节。
- en: Vue.js reactivity fundamentals
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue.js 的响应式基础
- en: Vue.js has been around for some time; the framework’s first release dates back
    to 2014, when its creator, Evan You, a former Google developer, informed the world
    of its creation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 已经存在一段时间了；该框架的第一个版本可以追溯到 2014 年，当时其创造者、前谷歌开发者 Evang You 通知了全世界其创建的消息。
- en: 'Evan’s previous experience with Angular at Google gave him the knowledge necessary
    to build a great framework. In an interview for *Between the Wires* shortly after
    making the framework public, Evan said the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 埃文在谷歌的 Angular 经验为他构建一个优秀的框架提供了必要的知识。在框架公开后不久，埃文在接受 *Between the Wires* 采访时说了以下内容：
- en: I figured, what if I could just extract the part that I really liked about Angular
    and build something really lightweight.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我想，如果我能提取我真正喜欢 Angular 的部分并构建一个真正轻量级的框架会怎样。
- en: Evan did not just create a lightweight framework, but he also managed to build
    an amazing community around it, making it one of the most loved frameworks by
    developers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 埃文不仅创建了一个轻量级的框架，而且还成功构建了一个围绕它的令人惊叹的社区，使其成为开发者最喜爱的框架之一。
- en: Vue.js has had just three major releases until now, with the latest one being
    a full rewrite that made Vue.js faster, smaller, and even easier to use.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Vue.js 只发布了三个主要版本，最新的一个版本是完全重写，使 Vue.js 更快、更小，甚至更容易使用。
- en: Two main aspects made Vue.js so successful. The first is that its growth and
    adoption are driven by the community for the community. Vue.js is one of the few
    major frameworks not to be backed by a big company. It is fully funded by people’s
    donations to the core team and its development is mainly driven by the community.
    This is shown by the focus on the development experience that is always present
    within the Vue.js ecosystem.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 两个主要方面使 Vue.js 非常成功。第一个方面是它的增长和采用是由社区为社区所驱动的。Vue.js 是少数几个没有大公司支持的顶级框架之一。它完全由对核心团队的捐赠者资助，其发展主要是由社区推动的。这从
    Vue.js 生态系统内始终存在的关注开发体验中可以看出。
- en: The second aspect that makes it unique is its reactivity system. The Vue.js
    core engine has been built to be reactive behind the scenes, making handling states
    with Vue.js simple and intuitive.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个使其独特的方面是其响应式系统。Vue.js 的核心引擎被构建为在幕后具有响应性，这使得使用 Vue.js 处理状态变得简单直观。
- en: 'When we talk about reactivity in development, we refer to the ability of certain
    variables to automatically update when a change occurs. A simple example of reactivity
    outside of the developing world is offered by Excel and Google Sheets. Setting
    up a calculation, such as a sum of a column, will result in the total number being
    “reactive” to any chance that happens in the summed cells:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论开发中的响应式时，我们指的是某些变量在发生变化时自动更新的能力。一个简单的响应式例子是Excel和Google Sheets，设置一个计算，比如一列的总和，会导致总和“响应”任何在求和单元格中发生的变化：
- en: '![Figure 2.1: Google Sheet example showing how the value of cells updates automatically](img/B21130_02_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1：Google表格示例，展示单元格值如何自动更新](img/B21130_02_01.jpg)'
- en: 'Figure 2.1: Google Sheet example showing how the value of cells updates automatically'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：Google表格示例，展示单元格值如何自动更新
- en: Like Excel, reactivity in web development, particularly in Vue.js, allows your
    variables to be dynamic and automatically change when a value it depends on changes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与Excel类似，在Web开发中，尤其是在Vue.js中，响应式允许你的变量在依赖的值发生变化时动态更新。
- en: Let’s see a real example to understand how reactivity plays a big part in the
    UI framework. Let’s start by seeing the behavior of vanilla JS and then see how
    this translates into Vue.js.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个真实示例来了解响应式在UI框架中扮演的重要角色。让我们先看看纯JavaScript的行为，然后看看这如何转化为Vue.js。
- en: 'In the following code, we are going to create two variables, `firstName` and
    `lastName`, and then we will try to create a reactive variable called `fullName`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将创建两个变量`firstName`和`lastName`，然后我们将尝试创建一个名为`fullName`的响应式变量：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code snippets, the full name that is printed in the console
    is equal to the `firstName` and `secondName` variables that we have created. What
    would happen if we now change the `firstName` variable to a different value? What
    would the value of `fullName` be?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码片段中，控制台打印的全名等于我们创建的`firstName`和`secondName`变量。如果我们现在将`firstName`变量更改为不同的值，会发生什么？`fullName`的值会是什么？
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see from the preceding code, the variable that is supposed to print
    the full name has output the incorrect value, as it has not “reacted” to the change
    in the `firstName` variable.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，本应打印全名的变量输出了错误值，因为它没有对`firstName`变量的变化做出“响应”。
- en: This is perfectly normal behavior; you do not want all variables to automatically
    react in JavaScript, as this will complicate its usage, but when it comes to the
    UI, having values that are updated is the expected behavior.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是完全可以理解的；你不想在JavaScript中让所有变量都自动响应，因为这会使它的使用变得复杂，但当涉及到UI时，有更新的值是预期的行为。
- en: Say, for example, you are filling up a basket and you want the total number
    of items to change if you add one more item to your basket, or you would like
    the word count to update if you type in a limited textbox, and so on.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在装满一个篮子，并且当你向篮子里再放一个物品时，你希望物品的总数发生变化，或者当你在一个受限的文本框中输入时，你希望字数统计更新，等等。
- en: 'Let’s replicate the preceding example using Vue.js:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Vue.js复制前述示例：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At this stage, your understanding of Vue.js is still limited to what experience
    you had before reading this book, so you are not expected to understand the preceding
    code yet. What we need to focus our attention on is the output that the code produces
    when compared to the one produced by plain JavaScript.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你对Vue.js的理解仍然局限于你在阅读这本书之前的经验，所以你还不期望理解前述代码。我们需要关注的是代码产生的输出与纯JavaScript产生的输出之间的比较。
- en: As the preceding code shows, the `fullName` variable changes automatically as
    soon as any of its dependent variables (`firstName` and `secondName`) change.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，`fullName`变量在其依赖变量（`firstName`和`secondName`）发生变化时，会自动更新。
- en: Understanding how the reactivity system works behind the scenes is out of the
    scope of this book, but this does not prevent us from understanding the technicalities
    that take place behind the scenes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 理解响应式系统背后的工作原理超出了本书的范围，但这并不妨碍我们理解幕后发生的细节。
- en: 'The following diagram shows what happens behind the scenes and how the reactivity
    actually takes place:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图解展示了幕后发生的事情以及响应式实际上是如何发生的：
- en: '![Figure 2.2: Diagram explaining the Vue.js reactivity system](img/B21130_02_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2：解释Vue.js响应式系统的图解](img/B21130_02_02.jpg)'
- en: 'Figure 2.2: Diagram explaining the Vue.js reactivity system'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：解释Vue.js响应式系统的图解
- en: 'This illustration is a simplified version of what happens within the Vue.js
    reactivity core system to make our variables dynamic. Let’s break down what is
    happening:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这幅插图是 Vue.js 响应性核心系统中发生的事情的简化版本，以使我们的变量动态化。让我们分析一下正在发生的事情：
- en: We defined reactive variables, such as `FirstName`. Vue.js watches this variable
    for any change event.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了响应式变量，例如 `FirstName`。Vue.js 会监视这个变量的任何变更事件。
- en: We declared a complex variable that is dependent on other reactive variables
    (e.g., `fullName`).
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明了一个依赖于其他响应式变量的复杂变量（例如，`fullName`）。
- en: Vue.js tracks a dependency tree. It creates a list of what depends on what.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Vue.js 跟踪一个依赖树。它创建了一个列表，列出了什么依赖于什么。
- en: When a change takes place in a reactive variable, the reactivity engine will
    trigger `onDependenciesChange`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一个响应式变量发生变化时，响应性引擎将触发 `onDependenciesChange`。
- en: Vue.js evaluates which values depend on the value that was just changed and
    triggers an update *only* if the value is part of their dependencies.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Vue.js 评估哪些值依赖于刚刚更改的值，并且只有在该值是它们的依赖项之一时才会触发更新。
- en: While reading the preceding process, you probably thought that it sounded quite
    familiar, and you would be correct, as the reactivity system follows the same
    principles offered by HTML elements such as input fields. Elements such as `<input>`,
    `<select>`, and many more have the ability to hold values and react when they
    are changed by triggering an `onChange` or similar event.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读前面的过程时，您可能认为这听起来很熟悉，您是对的，因为响应性系统遵循与 HTML 元素（如输入字段）提供的相同原则。例如 `<input>`、`<select>`
    以及许多其他元素都有能力持有值，并在它们被更改时通过触发 `onChange` 或类似事件来做出响应。
- en: As shown in the preceding example, listening to a change event to handle data
    reactivity is not something unique. So, what makes the Vue.js reactivity system
    special? Vue.js reactivity stands out for the way it handles the dependencies
    tree and automatically updates variables behind the scenes. The reactivity system
    of Vue.js is non-obstructive and it is completely unseen by developers. Vue.js
    manages all the dependencies behind the scenes as part of its **lifecycles** and
    acts upon changes with speed and high performance.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，监听一个变更事件来处理数据响应性并不是什么独特的事情。那么，是什么让 Vue.js 的响应性系统变得特别？Vue.js 的响应性在处理依赖树和自动更新后台变量方面脱颖而出。Vue.js
    的响应性系统是非侵入性的，并且对开发者来说完全不可见。Vue.js 在其 **生命周期** 中管理所有后台依赖，并以高速和高性能对变化做出反应。
- en: This section introduced you to the Vue.js reactivity system, explaining how
    it plays a vital role in the success of the framework. We then explained, with
    the help of some examples, how the engine works behind the scenes. It is now time
    to understand how the Vue.js core engine works by taking a closer look at its
    lifecycles and understanding how they can be used within our application development.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 本节向您介绍了 Vue.js 的响应性系统，解释了它在框架成功中扮演的重要角色。然后，我们通过一些示例解释了后台引擎的工作原理。现在，我们需要通过更仔细地查看其生命周期并了解它们如何在我们的应用程序开发中使用来理解
    Vue.js 核心引擎的工作方式。
- en: Understanding the Vue.js lifecycle and hooks
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Vue.js 的生命周期和钩子
- en: As we progress into the book, our knowledge of Vue.js continues to expand. In
    this section, we are going to discuss the Vue.js lifecycle.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们深入本书，我们对 Vue.js 的了解不断扩展。在本节中，我们将讨论 Vue.js 的生命周期。
- en: When we use Vue.js, the application goes through a defined list of steps, from
    creating the component HTML to gathering all the dynamic values, as well as displaying
    these values in the DOM. Each of these is part of what we call the **lifecycle**,
    and in this section, we are going to define them all and learn when and how to
    use them during the course of our development careers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Vue.js 时，应用程序会经过一系列定义的步骤，从创建组件 HTML 到收集所有动态值，以及将这些值显示在 DOM 中。这些都是我们所说的
    **生命周期** 的一部分，在本节中，我们将定义它们所有，并学习在开发生涯中何时以及如何使用它们。
- en: 'If you have ever tried to learn Vue.js in the past, you have probably already
    been exposed to the following diagram, which is available in the main Vue.js documentation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前尝试学习过 Vue.js，您可能已经接触到了以下图表，该图表可在 Vue.js 的主要文档中找到：
- en: '![Figure 2.3: Vue.js lifecycle diagram (from www.vuejs.org)](img/B21130_02_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3：Vue.js 生命周期图（来自 www.vuejs.org）](img/B21130_02_03.jpg)'
- en: 'Figure 2.3: Vue.js lifecycle diagram (from www.vuejs.org)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：Vue.js 生命周期图（来自 www.vuejs.org）
- en: No matter how long you have been using Vue.js, the preceding diagram will repeatedly
    appear in your browser history, and it will slowly be imprinted in your memory,
    as it is the foundation of Vue.js and a must-know in order to write clean and
    performant code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用Vue.js有多长时间，前面的图表都会反复出现在你的浏览器历史记录中，并且它会慢慢地印在你的记忆中，因为它是Vue.js的基础，并且为了编写干净和高效的代码，这是必须了解的。
- en: As you progress in the course of this book, you will be asked to revisit different
    parts of the lifecycle, and you will be asked to revisit the diagram.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你在这本书的学习过程中不断进步，你将被要求回顾生命周期的不同部分，并且你将被要求回顾这个图表。
- en: In the next section, we are going to review the diagram step by step and understand
    what it means and how this knowledge can be applied during development.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐步回顾这个图表，并理解它的含义以及如何在开发过程中应用这些知识。
- en: We are going to start explaining it from the top down, but we will be starting
    with **beforeCreate**. We are purposely leaving **setup** for later, as it is
    easier to understand after all the lifecycles have been introduced, even if it
    is the first part of the list.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从顶部开始解释，但我们将从**beforeCreate**开始。我们故意将**setup**留到后面，因为介绍完所有生命周期后，它更容易理解，即使它是列表的第一部分。
- en: The following lifecycles are progressive; this means that the end state of one
    of them is the beginning of the next.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的生命周期是逐步的；这意味着其中一个生命周期的结束状态是下一个生命周期的开始。
- en: beforeCreate
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: beforeCreate
- en: This lifecycle is created as soon as a component is initialized. At this stage,
    our component does not exist at all. The Vue.js framework has just been instructed
    to create it and it is triggering this hook to inform us that the component is
    on its way.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生命周期在组件初始化时创建。在这个阶段，我们的组件根本不存在。Vue.js框架刚刚被指示创建它，并且正在触发这个钩子来通知我们组件正在创建中。
- en: At this stage, nothing of the component is available, no HTML is being created,
    and no internal variables are set yet.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，组件没有任何可用内容，没有创建HTML，也没有设置任何内部变量。
- en: Usually, this lifecycle is used to trigger analytics logs or long async tasks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这个生命周期用于触发分析日志或长时间异步任务。
- en: created
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: created
- en: At this stage, Vue.js knows about your component, and it has loaded its JavaScript
    logic, but it has not yet rendered or mounted any HTML.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，Vue.js已经知道你的组件，并且已经加载了其JavaScript逻辑，但它还没有渲染或挂载任何HTML。
- en: This is the perfect stage to trigger async calls to gather some data. Triggering
    a slow request now will help us save some time, as this request will continue
    behind the scenes while our component is being rendered.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是触发异步调用以收集数据的完美阶段。现在触发一个慢速请求将帮助我们节省一些时间，因为这个请求将在我们的组件渲染的同时在幕后继续进行。
- en: beforeMount
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: beforeMount
- en: This lifecycle is triggered right before the HTML is appended to the DOM. There
    are very limited use cases for this lifecycle, as most of the pre-render actions
    are triggered within the **created** lifecycle.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生命周期在HTML被附加到DOM之前触发。这个生命周期的用例非常有限，因为大多数预渲染操作都是在**created**生命周期中触发的。
- en: mounted
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mounted
- en: At this stage, the component has been fully rendered, and its HTML has been
    attached to the DOM. If you need to complete any operation that requires you to
    access the DOM, this is the correct lifecycle, as the HTML is ready to be read
    and modified.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，组件已经被完全渲染，其HTML已经被附加到DOM上。如果你需要执行任何需要访问DOM的操作，这就是正确的生命周期，因为HTML已经准备好被读取和修改。
- en: If you come from a non-framework background, you may think that most of the
    logic of your component will probably be included in this lifecycle, but you will
    quickly learn that due to the way Vue.js components are specified, you will rarely
    need access to the DOM.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自非框架背景，你可能认为你组件的大部分逻辑可能都包含在这个生命周期中，但你很快就会学到，由于Vue.js组件的指定方式，你很少需要访问DOM。
- en: beforeUpdate and update
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: beforeUpdate 和 update
- en: '**beforeUpdate** and **update** form a recursive circle that happens any time
    the component data or dependencies change. We already introduced this step in
    the previous section when we spoke about the reactivity system.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**beforeUpdate**和**update**形成一个递归循环，每当组件数据或依赖发生变化时都会发生。我们已经在上一节中介绍了这一步骤，当时我们讨论了响应式系统。'
- en: '**beforeUpdate** is triggered as soon as Vue.js realizes that a reactive value
    on which the component depends has changed.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**beforeUpdate**在Vue.js意识到组件依赖的响应式值发生变化时触发。'
- en: On the other hand, **update** is triggered when the value has been fully changed,
    and its value has been assigned to the correct DOM node and is ready in the DOM.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**update** 在值完全改变并被分配到正确的 DOM 节点并准备就绪时触发。
- en: You will very rarely have to use these two lifecycles directly, as Vue.js provides
    other features, such as computed properties and watchers, to be able to handle
    individual changes within the component data.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你很少需要直接使用这两个生命周期，因为 Vue.js 提供了其他功能，例如计算属性和观察者，以便能够处理组件数据中的单个更改。
- en: beforeUnmount and unmount
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: beforeUnmount 和 unmount
- en: At this stage, our component is no longer needed, and Vue.js is ready to remove
    it from the DOM. This could be due to the user navigating to a different page
    or any other event that would require the component to be removed from the UI.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们的组件不再需要，Vue.js 准备将其从 DOM 中移除。这可能是由于用户导航到不同的页面或任何其他需要从 UI 中移除组件的事件。
- en: There is very little difference in usage between **beforeUnmount** and **unmount**.
    This lifecycle is very useful for unsubscribing to events, such as “click” and
    “observers,” that will result in a drop in performance if left active.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**beforeUnmount** 和 **unmount** 在使用上几乎没有区别。这个生命周期对于取消订阅事件非常有用，例如“点击”和“观察者”，如果保持激活状态，可能会导致性能下降。'
- en: setup
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: setup
- en: As promised at the start of this section, we left **setup** for last, as it
    is easier to explain it after all lifecycles were covered. **setup** is not a
    lifecycle in itself, but it is the entry point used by the CompositionAPI (something
    that you will learn about a bit later in this chapter). When using **setup**,
    you have the ability to call and access all the lifecycles (**mounted**, **updated**,
    **unmounted**, and so on). You can think of **setup** as a wrapper for the Vue.js
    lifecycle, a single method that includes all lifecycle hooks. Composition API
    is going to be what we use in this book, and we are going to explain the **setup**
    function in much more detail at a later stage.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节开头所承诺的，我们将 **setup** 放在最后，因为所有生命周期都被介绍之后，它更容易解释。**setup** 本身不是一个生命周期，但它是由
    CompositionAPI（你将在本章稍后了解一些）使用的入口点。当使用 **setup** 时，你可以调用和访问所有生命周期（**mounted**、**updated**、**unmounted**
    等）。你可以将 **setup** 视为 Vue.js 生命周期的包装器，一个包含所有生命周期钩子（hooks）的单个方法。Composition API
    将是我们在这本书中使用的，我们将在稍后的阶段更详细地解释 **setup** 函数。
- en: In this section, we have learned the basic flow of Vue.js, introducing all its
    lifecycles. At this stage, we should know when Vue.js component is rendered, updated,
    or destroyed. This knowledge will drive our development and allow us to make the
    correct choices to make our application performant. In the next section, we are
    going to see how to introduce Vue.js component syntax, and we will also learn
    how to make use of the preceding lifecycles.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了 Vue.js 的基本流程，介绍了所有其生命周期。在这个阶段，我们应该知道 Vue.js 组件何时渲染、更新或销毁。这些知识将推动我们的开发，并允许我们做出正确的选择，使我们的应用程序性能更优。在下一节中，我们将看到如何引入
    Vue.js 组件语法，我们还将学习如何利用前面的生命周期。
- en: Vue.js component structure
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue.js 组件结构
- en: Components are the basis of the Vue.js framework. They are the building blocks
    required to create an application using this framework. As was previously explained,
    a component can be as small as a simple button or as large as a full page.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是 Vue.js 框架的基础。它们是使用此框架创建应用程序所需的构建块。正如之前所解释的，组件可以小到简单的按钮，也可以大到整个页面。
- en: No matter their size, all components are built using the same syntax and structure.
    In this section, we are going to learn the different forms of syntax available
    to write components and learn about the different sections that make up a Vue.js
    **single-file** **component** (**SFC**).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 无论大小如何，所有组件都使用相同的语法和结构构建。在本节中，我们将学习编写组件的不同语法形式，并了解构成 Vue.js **单文件** **组件**（**SFC**）的不同部分。
- en: Single-file components
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单文件组件
- en: 'SFCs are specific to Vue.js and can be found in Vue.js projects with the extension
    `.vue`. These files are composed of three main sections: **template**, **script**,
    and **style**:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: SFCs 是 Vue.js 特有的，可以在具有 `.vue` 扩展名的 Vue.js 项目中找到。这些文件由三个主要部分组成：**template**、**script**
    和 **style**：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The Vue.js compiler takes the preceding three sections and splits them up into
    individual chunks during build time. We are now going to explain each of them
    in this section. We will cover the SFC section in the following order:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 编译器在构建时将前面的三个部分拆分成单独的块。我们现在将在这个部分中解释每个部分。我们将按照以下顺序介绍 SFC 部分：
- en: Template
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板
- en: Style
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 样式
- en: Script
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本
- en: The <template> tag
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`<template>`标签'
- en: 'The first section is `<template>`. This section includes the HTML hosted by
    our component. So, if we take an example of an extremely simple button, the template
    will look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个部分是`<template>`。这个部分包括我们组件托管HTML。所以，如果我们以一个极其简单的按钮为例，模板将看起来像这样：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In contrast to React, the HTML of a Vue.js component is plain **HTML** and not
    **JSX**. As we will learn in the course of the book, Vue.js provides some handy
    tools to simplify the content of our HTML.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与React不同，Vue.js组件的HTML是纯**HTML**，而不是**JSX**。正如我们在本书的学习过程中将要了解到的，Vue.js提供了一些实用的工具来简化我们的HTML内容。
- en: Important note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As for template writing styles, it is possible to write your HTML with different
    methods, such as render functions, or by writing it in JSX (with the correct loader),
    but these two methods are for specific uses and are not expected within the Vue.js
    ecosystem.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 至于模板编写样式，可以使用不同的方法来编写HTML，例如使用渲染函数，或者通过在JSX（使用正确的加载器）中编写它，但这些两种方法仅适用于特定用途，并且不期望在Vue.js生态系统中使用。
- en: The <style> tag
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`<style>`标签'
- en: The next section available is `<style>`. This section will include the styles
    associated with our component using plain `<style>` tag in a component does not
    *scope* the style to that specific component.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个可用的部分是`<style>`。这个部分将包括与我们的组件相关的样式，使用组件中的普通`<style>`标签不会将样式**作用域化**到特定的组件。
- en: Before we move on, let’s explain what it actually means for styles to be scoped
    and how to achieve this in our Vue.js application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们解释一下样式作用域的实际含义以及如何在我们的Vue.js应用中实现这一点。
- en: 'When we use a simple `<style>` tag, as shown in the preceding example, our
    style will leak to the rest of the application. Anything we declare in the tag
    will be global unless we scope it with CSS:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用简单的`<style>`标签，如前例所示，我们的样式将泄漏到应用的其余部分。除非我们使用CSS进行作用域化，否则我们在标签中声明的任何内容都将全局有效：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Writing the preceding style in Vue.js is permitted and is even suggested for
    performance and maintainability reasons. The problem is that the preceding declaration
    will change the color of our paragraph to red in the whole application and not
    just in the component in which it has been written.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue.js中编写前面的样式是允许的，并且出于性能和可维护性的原因甚至被建议。问题是前面的声明将改变整个应用中段落的颜色为红色，而不仅仅是它被编写的组件中的颜色。
- en: 'Luckily for us, Vue.js has a handy tool to use in the case where we would like
    our component to be fully scoped, making sure that no style bleeds and breaks
    the rest of the app. To do so, we need to add an attribute called `scoped` to
    our `<``style>` tag:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Vue.js有一个实用的工具可以在我们希望我们的组件完全作用域化时使用，确保没有样式泄漏并破坏应用的其余部分。要做到这一点，我们需要在我们的`<style>`标签中添加一个名为`scoped`的属性：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this new attribute, our styles will be locked to the component in which
    they are defined, and they will not affect the rest of the application. We are
    going to learn more about when it is best to use these two methods when building
    our Companion App.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新属性，我们的样式将被锁定到定义它们的组件中，并且不会影响应用的其余部分。我们将学习在构建我们的伴侣应用时何时最好使用这两种方法。
- en: The <script> tag
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`<script>`标签'
- en: The next section available within an SFC is the `<script>` tag. This tag will
    include the component JavaScript logic, from the properties that are accepted
    for the component to the private data used to define the component logic, all
    the way to the actual methods needed for the component to function properly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在SFC中可用的下一个部分是`<script>`标签。这个标签将包含组件的JavaScript逻辑，从组件接受的属性到用于定义组件逻辑的私有数据，再到组件正常工作所需的实际方法。
- en: Just a few years ago, when Vue.js’ major version was still 2, components were
    mostly defined using a syntax called **Options API**. Even though other methodologies
    were available, this was the main way to write a Vue.js component.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 只是在几年前，当Vue.js的主要版本仍然是2时，组件大多使用一种称为**选项API**的语法来定义。尽管有其他方法可用，但这仍然是编写Vue.js组件的主要方式。
- en: With the release of Vue.js 3, a new method of writing components was created.
    This is offered alongside the existing Options API, and it offers better TypeScript
    support, improved techniques to reuse logic, and flexible code organization. This
    method is called **Composition API**.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Vue.js 3的发布，创建组件的新方法被引入。这种方法与现有的选项API并存，并提供了更好的TypeScript支持，改进了逻辑复用的技术，以及灵活的代码组织。这种方法被称为**组合API**。
- en: Important note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Composition API is also referred to as **Script Setup**.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 组合API也被称为**脚本设置**。
- en: 'At this moment in time, neither of the two methods is officially preferred
    over the other; this is also emphasized by the Vue.js official documentation,
    which currently showcases all its tutorials and examples using both methodologies,
    offering the option to switch between the methods:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前这个时间点，两种方法都没有被官方明确地推荐为优于另一种；这一点也被Vue.js官方文档所强调，它目前展示了所有使用这两种方法的教程和示例，并提供了在方法之间切换的选项：
- en: '![Figure 2.4: Vue.js official documentation for API preference switch](img/B21130_02_04.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4：Vue.js官方文档中的API偏好切换](img/B21130_02_04.jpg)'
- en: 'Figure 2.4: Vue.js official documentation for API preference switch'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4：Vue.js官方文档中的API偏好切换](img/B21130_02_04.jpg)'
- en: 'The content of this book and its Companion App are going to be written using
    Composition API. This decision was made for two main reasons:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本书及其配套应用的内容将使用Composition API编写。这个决定基于两个主要原因：
- en: Due to Vue.js 2’s history, the web is full of resources that focus on Options
    API but less so on the new Composition API syntax
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Vue.js 2的历史原因，网络上充斥着专注于Options API的资源，而对新的Composition API语法的关注较少
- en: Evan You (the creator of Vue.js) has predicted (more than once) that, in the
    long run, Composition API will take over and become the standard
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Evan You（Vue.js的创造者）已经（不止一次）预测，从长远来看，Composition API将接管并成为标准
- en: Because I am a strong believer that extra knowledge does no harm, in this section,
    we are going to learn how to define the component in both syntaxes, including
    Options API. Knowing both methods can help you build a strong foundation to support
    your learning of the Vue.js framework.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我是坚信额外知识无害的强烈支持者，所以在本节中，我们将学习如何使用两种语法定义组件，包括Options API。了解这两种方法可以帮助你建立一个强大的基础，以支持你对Vue.js框架的学习。
- en: Options API versus Composition API – Two sides of the same coin
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Options API与Composition API——同一枚硬币的两面
- en: Under the hood, both methods are actually going to produce a very similar output,
    with Composition API producing slightly more performant code. Nevertheless, the
    syntax differences and benefits that these methods bring are quite different and
    can make a big change depending on your habits.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，这两种方法实际上会产生非常相似的结果，Composition API生成的代码性能略高。尽管如此，这些方法带来的语法差异和好处是相当不同的，并且会根据你的习惯产生重大变化。
- en: The first and main difference between Composition API and Options API is in
    the way the `<script>` section of your code is broken down. As I mentioned before,
    both syntaxes will offer the same features, so this means that we can declare
    props data, compute, and methods, as well as access all the lifecycles in both
    methods, but the way we do so differs.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Composition API与Options API之间的第一个和主要区别在于代码中`<script>`部分的分解方式。正如我之前提到的，这两种语法将提供相同的功能，这意味着我们可以声明props数据、计算和函数，以及访问两种方法中的所有生命周期，但我们实现的方式不同。
- en: 'The differences are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 差异如下：
- en: '**Composition API**: Code broken down by functionality'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Composition API**：按功能分解的代码'
- en: '**Options API**: Code broken down by Vue.js options'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Options API**：按Vue.js选项分解的代码'
- en: Let’s look at an example to clearly define the difference between both methods.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来清楚地定义这两种方法之间的差异。
- en: '![Figure 2.5: Comparison between Composition API and Options API for breaking
    down code](img/B21130_02_05_v2.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5：分解代码的Composition API与Options API比较](img/B21130_02_05_v2.jpg)'
- en: 'Figure 2.5: Comparison between Composition API and Options API for breaking
    down code'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5：分解代码的Composition API与Options API比较](img/B21130_02_05_v2.jpg)'
- en: 'As shown in the preceding diagram, in Options API, the code does not take into
    consideration the actual component requirements and logic, but it is sliced vertically
    using Vue.js options: **Props**, **Data**, **Methods**, **Computed**, **mounted**,
    and so on.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，在Options API中，代码并没有考虑实际的组件需求和逻辑，而是通过Vue.js选项：**Props**、**Data**、**Methods**、**Computed**、**mounted**等垂直切割。
- en: On the other hand, Composition API takes a different approach by breaking down
    the component by its technical output. This allows us to create a section for
    Feature 1, a section for Feature 2, and so on.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Composition API通过按组件的技术输出分解组件，采取不同的方法。这允许我们为功能1创建一个部分，为功能2创建一个部分，依此类推。
- en: The second difference is associated with TypeScript support. This is the main
    reason that led the Vue.js core team to decide to create The Composition API during
    the Vue.js 3 rewrite. Options API offers very basic TypeScript support, and this
    has prevented many developers from joining the Vue.js ecosystem.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区别与TypeScript支持有关。这是Vue.js核心团队决定在Vue.js 3重写期间创建组合API的主要原因。Options API提供了非常基本的TypeScript支持，这阻止了许多开发者加入Vue.js生态系统。
- en: We have reached the end of this section, and it is time to clearly say which
    method is better, but, unfortunately, the answer is that it depends.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了这个部分的结尾，现在是时候清楚地说明哪种方法更好了，但不幸的是，答案是这取决于。
- en: Because both syntactic sugars compile in the same code, the decision really
    goes back to coding preferences. Options API provides more structure, and it can,
    therefore, be more helpful at the start of your career when your experience in
    creating a component is still limited, while Composition API, with the added TypeScript
    support and greater flexibility in code partitioning, can be a very strong tool
    to improve code readability in big applications.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两种语法糖都在相同的代码中编译，所以这个决定实际上回到了编码偏好。Options API提供了更多的结构，因此在你创建组件的经验仍然有限时，它可以在你的职业生涯初期提供更多帮助，而组合API，由于增加了TypeScript支持和代码分区更大的灵活性，可以成为提高大型应用程序代码可读性的强大工具。
- en: Sample components
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样本组件
- en: At this stage, we have learned enough about the foundations of Vue.js to be
    ready to introduce some sample components and see the framework in action.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经对Vue.js的基础知识有了足够的了解，可以准备介绍一些样本组件并看到框架的实际应用。
- en: 'We are going to look at an example of an Atom. In our case, it is a simple
    icon component. This sample component is going to exhibit the following features:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一个原子的例子。在我们的情况下，它是一个简单的图标组件。这个样本组件将展示以下功能：
- en: It is going to accept a couple of properties (`size` and `name`)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将接受几个属性（`size`和`name`）
- en: It is going to include some style
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将包含一些样式
- en: It is going to dynamically load the icon
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将动态加载图标
- en: 'The component will be called using the following HTML:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件将使用以下HTML调用：
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As previously mentioned, in this section, I am going to show the components
    utilizing both writing methods; however, later in the book, we will just write
    components using Script Setup (Composition API).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在这个部分，我将展示使用两种编写方法的组件；然而，在本书的后面，我们只会使用脚本设置（组合API）编写组件。
- en: Important note
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Please note that we will cover all of this again in more detail later in the
    book. This is just a quick introduction to Vue.js components.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将在本书的后面更详细地介绍所有这些内容。这只是一个对Vue.js组件的快速介绍。
- en: An Atom component using Options API
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Options API的原子组件
- en: 'Let’s first see how this component looks as a Vue.js component using Options
    API:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看这个组件作为Vue.js组件使用Options API时的样子：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now let’s break down all the sections, starting with `<template>`, which hosts
    the HTML for our component; in this case, this is a native `<img>` element. This
    component has a few attributes being passed to it. The first two are native attributes:
    `src` and `class`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来分解所有部分，从`<template>`开始，它包含我们组件的HTML；在这种情况下，这是一个原生的`<img>`元素。这个组件有几个属性传递给它。前两个是原生属性：`src`和`class`：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These attributes are declared a little bit differently than you are used to
    in HTML, as they are preceded by `:`. When an attribute has this syntax, it means
    that its value is dynamic and that the values (in our case, `iconPath` and `sizeClass`)
    are going to be evaluated as a JavaScript variable and not actual strings.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性与你在HTML中习惯的声明方式略有不同，因为它们前面有一个`:`。当一个属性有这种语法时，这意味着它的值是动态的，并且值（在我们的情况下，`iconPath`和`sizeClass`）将被评估为JavaScript变量，而不是实际的字符串。
- en: Important note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Please note that you can write plain HTML in Vue.js, and using the dynamic variables
    is not a requirement for the framework but just a feature to make the attributes
    dynamic.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可以在Vue.js中编写纯HTML，使用动态变量不是框架的要求，而只是一个特性，使属性动态化。
- en: 'Next up, let’s move to the logical part of the application, the `<script>`
    section. Here, we start by declaring the name of our component:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们转向应用程序的逻辑部分，即`<script>`部分。在这里，我们首先声明我们组件的名称：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Important note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is good practice for all Vue.js components to be formed of two words. This
    will ensure that the component does not clash with native HTML elements.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有Vue.js组件来说，由两个单词组成是一个好的实践。这将确保组件不会与原生HTML元素冲突。
- en: 'Next, it is time to declare the properties. Properties are values that are
    accepted by our component when it is initialized. This is an existing concept
    in development, as all HTML elements accept attributes such as `class`, `id`,
    and `value`. These properties make our components reusable and flexible. In our
    example, we declared two different properties: `name` and `size`. These will be
    passed down when the component is called, just as if they were native HTML attributes:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example shows a basic configuration for a property, in which we just define
    its type, but, as we will later see in the course of the book, `props` can have
    different configurations, such as validation, default values, and requirements
    rules, to state whether they are required or not.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'The next piece of code is where we declare our dynamic properties. For our
    component to function correctly, we need a path and a class defined as `iconPath`
    and `sizeClass`. These values are going to be dynamic due to the fact that they
    include the dynamic properties and will be declared using something called computed
    properties:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The computed properties allow us to declare values that are reactive (remember
    the reactivity chapter earlier on in the book) and can make use of our entire
    component logic; in this case, we just used the props, but we could have used
    a collection of values and external logic to create a new value.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Please note that when using Options API, you have to use the `this` keyword
    to be able to access variables within the component, such as `props` and `computed`.
    In our example, we used it to access properties by using `this.name` and `this.size`;.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Our last section is `<style>`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is quite simple because this example does not include anything different
    than you would normally see in plain CSS. As mentioned in a previous chapter,
    we can add the attribute scoped to our style to ensure that their style does not
    bleed from our component.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, you can see (in practice) how Options API divides
    our component into sections. In our case, we have `props`, `name`, `computed`,
    and `methods`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: An Atom component using Script Setup
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is now time to look at the same component but written using the `<script`
    `setup>` syntax:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can clearly see, the preceding example omits the `<template>` and `<style>`
    tags. These have been omitted because they are identical to the Options API counterpart.
    In fact, as we have already mentioned, the difference between these two methods
    only affects the logical part of the component, which is `<script>`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line of our component is `import`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In contrast to Options API, where all the options were already available to
    us when using `<script setup>`, we have to import each individual Vue.js method
    from `'vue'`, just as we did in the previous code for `computed`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we are going to see how properties are defined in Composition API:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Properties are one of the few options to have a verbose declaration while using
    `<script setup>`. In fact, to be able to declare them, we need to make use of
    a compiler macro called `defineProps`. Macros do not need to be imported, as they
    are just going to be used by the compiler and removed from the code. If you have
    ever used TypeScript, you will be familiar with this approach.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we have `computed`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Declaring the properties of `computed` is very similar to Options API but with
    two small differences:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The logic of the properties of `computed` need to be passed as a callback to
    the computed method imported from `'vue'`
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `this` keyword is not available anymore, and we can access variables directly
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is as far as we will go in terms of explaining the differences between
    Options API and Composition API for now. We will cover Script Setup (Composition
    API) in more detail later in the book. If you are extremely new to Vue.js, this
    section probably included lots of new syntax, and it was a little hard to grasp,
    but as soon as we start to build our Companion App, as you gain knowledge with
    Vue.js and its syntax, things will quickly make more sense to you.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have started to learn how Vue.js components are defined
    and the different sections that form an SFC. We then concluded the section by
    covering a sample component in both syntactic sugars in detail.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now reached the end of this fairly theory-heavy chapter, and this was
    required for us to get started with our app-building process. In this chapter,
    we have learned what makes Vue.js different from the other frameworks by analyzing
    its reactivity system. We then broke down the composition of a Vue.js SFC, also
    known as a `.vue` file, and we walked through a Vue.js component’s lifecycle by
    analyzing all the different lifecycle hooks available within the framework.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the chapter, we learned the main differences between Composition
    API and Options API by exploring them using sample components.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start to learn Vue.js by starting to build our
    Companion App. This will be the beginning of your long journey from being a complete
    beginner to an experienced Vue.js developer.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Understanding the Core Features of Vue.js'
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Part 2 of this book focuses on Vue.js and its core features. We will build the
    core of the Companion App one step at a time, while continuing to expand our knowledge
    of the Vue.js framework.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B21130_03.xhtml#_idTextAnchor039)*, Making Our HTML Dynamic*'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B21130_04.xhtml#_idTextAnchor049)*, Utilizing Vue’s Built-in
    Directives for Effortless Development*'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B21130_05.xhtml#_idTextAnchor060)*, Leveraging Computed Properties
    and Methods in Vue.js*'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B21130_06.xhtml#_idTextAnchor074)*,* *Event and Data Handling
    in Vue.js*'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B21130_07.xhtml#_idTextAnchor088)*,* *Handling API Data and Managing
    Async Components with Vue.js*'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B21130_07.xhtml#_idTextAnchor088)*,* 使用Vue.js处理API数据和异步组件管理'
