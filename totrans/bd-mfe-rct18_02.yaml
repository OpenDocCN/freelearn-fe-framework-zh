- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introducing Microfrontends
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微前端介绍
- en: We are coming full circle with microfrontends! During the Web 1.0 era, websites
    primarily comprised single pages built in ASP, JSP, or PHP, where we could make
    changes to each individual page and upload it to a server via FTP and it was immediately
    available to consumers. Then came the Web 2.0 era and the notion of web apps and
    **Single-Page Apps** (**SPAs**), where we compile, transpile, and deploy large
    monolithic apps. Now, we seem to be going back to working with smaller apps and
    pages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在微前端上又回到了起点！在Web 1.0时代，网站主要由ASP、JSP或PHP构建的单页组成，我们可以对每个单独的页面进行更改，并通过FTP上传到服务器，然后立即对消费者可用。然后是Web
    2.0时代和Web应用以及**单页应用**（**SPAs**）的概念，我们编译、转译和部署大型单体应用。现在，我们似乎又回到了处理更小应用和页面的工作方式。
- en: The early 2000s brought in the era of Web 2.0 and the notion of web apps. A
    few years later, JavaScript frameworks allowed you to build SPAs that updated
    instantly and didn’t reload a new page each time the user clicked on a link or
    a button. SPAs were indeed fast for small to medium-sized apps, but as teams went
    full throttle with building large-scale SPAs, and as applications and teams grew,
    the velocity and speed of development dropped significantly. Teams seemed to be
    debating about folder structures, state management, and breaking each other’s
    code, due to centrally managed libraries and so on. These large SPAs also started
    becoming less performant due to the large bundle sizes of these apps. More importantly,
    the high execution time required to parse these JavaScript bundles made the apps
    even more sluggish on low-end devices and mobile phones. That’s when developers
    and architects started looking for solutions to these problems. Thankfully, they
    didn’t have to look too far.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 2000年代初迎来了Web 2.0时代和Web应用的概念。几年后，JavaScript框架允许你构建即时更新且每次用户点击链接或按钮时不会重新加载新页面的单页应用（SPAs）。对于小型到中型应用，SPAs确实很快，但随着团队全力以赴构建大规模的SPAs，以及应用和团队的成长，开发速度和速度显著下降。由于集中管理的库等原因，团队似乎在争论文件夹结构、状态管理和破坏彼此的代码。这些大型SPAs也因为这些应用的大包体积而开始变得性能不佳。更重要的是，解析这些JavaScript包所需的高执行时间使得低端设备和手机上的应用更加缓慢。正是在这个时候，开发人员和架构师开始寻找解决这些问题的方案。幸运的是，他们不需要走得太远。
- en: You see, the backend teams went through the exact same problems with the large
    backend monoliths a few decades back and moved toward the microservices architecture
    pattern in order to solve their performance and scaling challenges. The frontend
    teams now look to apply the same principles of microservices to their frontend
    apps, which are being referred to as **microfrontends**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，后端团队在几十年前就遇到了与大型后端单体相同的问题，并转向微服务架构模式来解决它们的性能和扩展挑战。现在，前端团队正试图将微服务的相同原则应用于他们的前端应用，这些应用被称为**微前端**。
- en: The journey for backend teams toward microservices has been a very long one,
    spanning multiple decades, and many teams still struggle with it. However, thanks
    to a lot of debates, discussions, thoughts, leadership, and sharing learning from
    various microservice implementations, there is an overall maturity to and consensus
    around microservices architecture.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 后端团队走向微服务的过程非常漫长，跨越了多个十年，许多团队仍在为此而努力。然而，得益于许多辩论、讨论、思考、领导和从各种微服务实现中学习到的经验，微服务架构已经达到了一个整体成熟度和共识。
- en: Frontend teams are just waking up to the notion of microfrontends, and there
    are multiple schools of thought on what defines a microfrontend, including, in
    fact, whether microfrontends are even a good thing or not. It will take a couple
    of years, if not a decade, before there is some consensus around microfrontends.
    The good thing, however, is that we can learn a lot from the journey of microservices,
    as a lot of principles and architecture patterns of microservices also apply to
    microfrontends.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 前端团队刚刚开始意识到微前端的概念，关于什么是微前端，存在多种观点，包括实际上微前端是否是一件好事。可能需要几年甚至十年，才能在微前端上达成一些共识。然而，好事是，我们可以从微服务的发展历程中学到很多东西，因为许多微服务的原则和架构模式也适用于微前端。
- en: In this chapter, we’ll start by understanding the need for microfrontends. We
    will cover the definition of microfrontends, and then the different patterns of
    microfrontends. We will also look into the parameters that will help us choose
    which pattern to go with for designing your apps. Finally, we will create our
    very first microfrontend.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先了解微前端的需求。我们将涵盖微前端的定义，然后讨论微前端的不同模式。我们还将探讨有助于我们选择设计应用时采用哪种模式的参数。最后，我们将创建我们自己的第一个微前端。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Defining Microfrontends
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义微前端
- en: Understanding Microfrontend patterns
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解微前端模式
- en: Choosing a suitable pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的模式
- en: Hello World with Microfrontends
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用微前端实现Hello World
- en: By the end of this chapter, you will have a better understanding of two of the
    most common patterns for building microfrontends and a guide to help you decide
    which one would be most suitable for you.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将更好地理解构建微前端最常用的两种模式，以及帮助您决定哪种模式最适合您的指南。
- en: Toward the end of this chapter, we will build out a simple multi-SPA microfrontend
    example and get a feel for how we navigate between the the different SPAs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的结尾，我们将构建一个简单的多SPA微前端示例，并了解如何在不同的SPA之间导航。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As you go through the code examples in this chapter, you will need the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在您浏览本章的代码示例时，您需要以下内容：
- en: A PC, Mac, or Linux desktop/laptop with at least 8 GB of RAM (16 GB preferred)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少8 GB RAM的PC、Mac或Linux桌面/笔记本电脑（16 GB更佳）
- en: An Intel chipset i5+, AMD, or an Apple M1 + chipset
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英特尔i5+芯片组、AMD或苹果M1+芯片组
- en: At least 256 GB of free hard disk storage
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少256 GB的空闲硬盘存储空间
- en: 'You will also need the following software installed on your computer:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要在您的计算机上安装以下软件：
- en: Node.js version 16+ (use **nvm** to manage different versions of Node.js if
    you have to).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js版本16+（如果您必须管理不同版本的Node.js，请使用**nvm**）。
- en: 'Terminal: A modern shell such as **zsh**, iTerm2 with **oh-my-zsh** for Mac
    (you will thank me later), or Hyper for Windows ([https://hyper.is/](https://hyper.is/)).'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端：一个现代的shell，例如**zsh**，Mac上的iTerm2配合**oh-my-zsh**（您稍后会感谢我的），或者Windows上的Hyper（[https://hyper.is/](https://hyper.is/)）。
- en: 'IDE: We recommend VS Code.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成开发环境（IDE）：我们推荐VS Code。
- en: '**npm**, **yarn**, or pnpm. We recommend PNPM because it’s fast and storage
    efficient.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**npm**、**yarn**或**pnpm**。我们推荐PNPM，因为它速度快且存储效率高。'
- en: 'Browser: Chrome/Microsoft Edge, Brave, or Firefox (I use Firefox).'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器：Chrome/Microsoft Edge、Brave或Firefox（我使用Firefox）。
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Building-Micro-Frontends-with-React](https://github.com/PacktPublishing/Building-Micro-Frontends-with-React).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/Building-Micro-Frontends-with-React](https://github.com/PacktPublishing/Building-Micro-Frontends-with-React)。
- en: Defining Microfrontends
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义微前端
- en: In this section, we will focus on defining what microfrontends and their key
    benefits are, and also become aware of the initial upfront investments associated
    with setting up microfrontends.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于定义微前端及其关键优势，并了解设置微前端所涉及的相关初始投资。
- en: The currently accepted definition of a microfrontend is as follows.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当前接受的微前端定义如下。
- en: “Microfrontends are a composition of micro apps that can be **independently
    deployed** and are owned by **independent teams** responsible for delivering business
    value of a focused area of the overall application”.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: “微前端是由可以**独立部署**的微应用组成的，由**独立团队**拥有，这些团队负责交付整个应用中某个特定领域的业务价值”。
- en: The keywords in this definition are independently deployed and independent teams.
    If at least one of these terms doesn’t apply to you or your team, then you probably
    don’t need a microfrontend. A regular SPA would work out to be more efficient
    and productive. As we will see later, microfrontends come with a bit of upfront
    complexity and may not be worth it unless you have a large application, where
    sections of the app are managed by individual teams.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义中的关键词是独立部署的，并且由独立团队负责。如果您或您的团队中至少有一个这些术语不适用，那么您可能不需要微前端。一个常规的单页应用（SPA）会更有效率且更富有生产力。正如我们稍后将要看到的，微前端带来了一些初始的复杂性，除非您有一个大型应用，其中应用的部分由个别团队管理，否则可能不值得。
- en: We’ve noticed that some teams that are on their journey to implementing microfrontends
    misinterpret the *micro* part of microfrontends and believe an application doesn’t
    follow a microfrontend architecture unless it’s broken down to its smallest level.
    They break down their apps into really small apps, which adds a lot of unnecessary
    complexity. In fact, it negates all the benefits that microfrontends are supposed
    to deliver.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，一些正在实施微前端的团队误解了微前端中的“微”部分，并认为除非应用程序被分解到最小级别，否则它不遵循微前端架构。他们将应用程序分解成非常小的应用程序，这增加了许多不必要的复杂性。实际上，这抵消了微前端本应带来的所有优势。
- en: In our opinion, it actually works the other way around. When breaking down an
    application into micro apps, the teams should ideally look to identify the largest
    possible micro app or micro apps that a scrum team can independently manage and
    deploy to production without impacting other micro apps.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看来，实际上情况正好相反。当将应用程序分解为微应用时，团队应理想地寻找识别最大的可能微应用或微应用，这些微应用可以由敏捷团队独立管理并部署到生产环境中，而不会影响其他微应用。
- en: The key takeaway from this is not to be swayed by the term “micro” but instead
    identify the largest possible app that can be independently deployed by a single
    scrum team.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个要点中，关键不是被“微”这个术语所左右，而是要确定可以由单个敏捷团队独立部署的最大应用程序。
- en: Before we go deeper into the wonderful world of microfrontends, it is important
    to remember that every application doesn’t need to be a microfrontend. Let’s learn
    more about this in the following section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨微前端奇妙世界之前，重要的是要记住，并非每个应用程序都需要是微前端。让我们在下一节中了解更多。
- en: Understanding the Microfrontend Premium
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解微前端溢价
- en: '*Martin Fowler* talks about the microservice premium. This refers to the fact
    that microservices come with a bit of overhead and complexity, mainly in terms
    of the initial setup and the communication channels between the services. Martin
    goes on to say that the benefits of a microservices architecture only start showing
    when size and complexity boosters kick in. To understand this, let’s look at the
    following diagram:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*马丁·福勒* 讨论了微服务溢价。这指的是微服务带来了一些开销和复杂性，主要是在初始设置和服务之间的通信渠道方面。马丁接着说，微服务架构的优势只有在规模和复杂性提升器启动时才开始显现。为了理解这一点，让我们看看以下图表：'
- en: '![Figure 1.1 – The microservice premium graph (source: https://martinfowler.com/bliki/MicroservicePremium.html)](img/Figure_1.01_B18987.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 微服务溢价图（来源：https://martinfowler.com/bliki/MicroservicePremium.html)](img/Figure_1.01_B18987.jpg)'
- en: 'Figure 1.1 – The microservice premium graph (source: [https://martinfowler.com/bliki/MicroservicePremium.html](https://martinfowler.com/bliki/MicroservicePremium.html))'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 微服务溢价图（来源：[https://martinfowler.com/bliki/MicroservicePremium.html](https://martinfowler.com/bliki/MicroservicePremium.html))
- en: The preceding diagram is a graph of the productivity versus the complexity of
    an application and depicts the drop in productivity for a monolith SPA and microfrontend
    as complexity grows.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表是应用程序生产力和复杂性的图表，描述了随着复杂性的增长，单体SPA和微前端生产力的下降。
- en: The same holds true for the microfrontend architecture. The whole process of
    decoupling the various parts of components, routing, and templates and delegating
    them to different systems can become an unnecessary overhead for small or medium-scale
    apps.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微前端架构来说，也是如此。将组件的各个部分、路由和模板解耦并将它们委托给不同的系统，对于小型或中型应用程序来说，整个过程可能成为不必要的开销。
- en: The benefits of microfrontends kick in only when your project starts reaching
    the size and complexity thresholds shown in *Figure 1**.1*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端的优势只有在项目开始达到*图1.1*中所示的大小和复杂性阈值时才会显现。
- en: Exploring the benefits of Microfrontends
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索微前端的优势
- en: All the benefits of a microfrontend architecture are linked to size and scale.
    Having said that, the following benefits of microfrontends hold true only for
    apps that are built and supported by teams with over 15 people.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端架构的所有优势都与规模和范围相关。话虽如此，以下微前端的优势仅适用于由超过15人团队构建和支持的应用程序。
- en: In the following sections, we will learn about the benefits that teams can expect
    when they implement a microfrontend architecture, all of which are directly linked
    to improved productivity and better developer experience for team members.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将了解团队在实施微前端架构时可以期待的好处，所有这些好处都与提高生产力和改善团队成员的开发体验直接相关。
- en: Faster development and deployments
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更快的开发和部署
- en: One of the main drawbacks of monolithic Single Page Apps is that as the application
    and team sizes grow, feature development and deployments come to a crawl. We notice
    the team spending a lot more time where one team is waiting on the other team
    to finish something before the application can be deployed. With a microfrontend
    architecture, every scrum team works independently on their micro app, building
    and releasing features without having to worry a lot about what other teams are
    doing.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用的主要缺点之一是，随着应用和团队规模的扩大，功能开发和部署速度会变得非常缓慢。我们注意到团队花费了更多的时间在一个团队等待另一个团队完成某些工作，然后才能部署应用。在微前端架构中，每个敏捷团队独立工作于他们的微应用，构建和发布功能，无需过多担心其他团队正在做什么。
- en: Easier to scale as the application grows
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随着应用的增长更容易扩展
- en: A microfrontend architecture is all about composing smaller micro apps, so as
    the application grows in size, it’s just a question of adding additional micro
    apps and having a scrum team own it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端架构完全是关于组合更小的微应用，因此随着应用规模的扩大，这只是添加额外的微应用并由敏捷团队负责的问题。
- en: Now, since each team deals with a smaller micro app, their team members need
    to spend less time understanding the code base and should not get overwhelmed
    or worried about how their code changes will impact other teams.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于每个团队处理的是更小的微应用，团队成员需要花费更少的时间来理解代码库，并且不应该因为担心他们的代码更改会影响其他团队而感到不知所措或担忧。
- en: Microfrontends allow one to scale up very quickly, with scrum teams working
    in parallel once the base microfrontend framework is set up.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端允许快速扩展，一旦设置了基本微前端框架，敏捷团队就可以并行工作。
- en: Improved Developer Experience
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进的开发者体验
- en: With isolated, independent micro apps, the time required for each team to compile,
    build, and run automated unit tests for their part of the micro apps is greatly
    reduced. This allows teams to build and deliver features a lot faster.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用隔离的、独立的微应用，每个团队编译、构建和运行自动化单元测试所需的时间大大减少。这使得团队能够更快地构建和交付功能。
- en: '*While teams run isolated unit and automation tests for their micro apps more
    frequently, we recommend running full regression suites of end-to-end tests on
    demand or before committing the code* *to Git.*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然团队更频繁地为他们的微应用运行隔离的单元和自动化测试，但我们建议在需要时或在提交代码到Git之前运行完整的回归测试套件* *进行端到端测试*。'
- en: Progressive upgrades
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渐进式升级
- en: The frontend ecosystem is the fastest-evolving ecosystem. Every few months,
    a new framework or library springs up that is better and faster than the previous
    one. Having said that, there is always an urge to rewrite your existing application
    using the latest framework.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前端生态系统是发展最快的生态系统。每隔几个月，就会出现一个比之前更好的新框架或库。话虽如此，总是有一种冲动想要使用最新的框架重写现有的应用。
- en: With large applications, it’s not possible to easily upgrade or introduce a
    new framework without rewriting the entire application. The cost of rewriting
    the application and the associated risks of introducing bugs due to the rewrite
    are far too high. Teams keep deprioritizing the upgrade and within a few years,
    they find themselves working on an outdated framework.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型应用来说，没有重写整个应用就难以轻松升级或引入新框架。重写应用的成本以及由于重写而引入错误的关联风险都太高了。团队不断推迟升级，几年后，他们发现自己正在使用过时的框架。
- en: With microfrontends, it is easier to pick up one small micro app and upgrade
    it or rewrite it and then gradually roll it out to other micro apps. This also
    allows teams to experience the benefits of the new change and learn and course-correct
    as they migrate the new framework to the other micro apps.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微前端，更容易选择一个小型微应用进行升级或重写，然后逐步将其推广到其他微应用。这也使得团队能够体验新变化的好处，并在迁移新框架到其他微应用时学习和纠正方向。
- en: 'As we move on to the next section, let’s quickly recap some of the key points
    that we’ve learned so far:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节之前，让我们快速回顾一下我们迄今为止学到的关键点：
- en: Microfrontends are suited for building large-scale apps where teams are set
    up as full-stack teams, where the backend developers, frontend developers, product
    owners, and so on are within the same scrum team.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微前端适合构建大型应用，其中团队被设置为全栈团队，后端开发者、前端开发者、产品负责人等都在同一个敏捷团队中。
- en: Microfrontends have numerous benefits, such as team independence, features launched
    with improved velocity, and better developer experience. However, these benefits
    will start becoming visible once you have overcome the initial phase of complexity
    associated with the “microfrontend premium.”
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Microfrontend patterns
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to microfrontends, there are way too many interpretations. These
    are still early days for microfrontends, and there is no right or wrong way of
    building them. The answer to any technical/architectural question is “It depends….”
    In this section, we will focus on two of the most common patterns that teams adopt
    while building microfrontends. We will see what key factors to consider when deciding
    which pattern may be right for you. We will end this section by building a really
    basic microfrontend to get the ball rolling.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: At a very high level, there are two primary patterns for microfrontends. Both
    of these patterns can be applied irrespective of whether you are building a **Server-Side-Rendered**
    (**SSR**) app or a **Client-Side-Rendered** (**CSR**) app. To better illustrate
    these patterns, we will take the use case of an e-commerce application such as
    Amazon.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: In the following subsections, we will look at these two patterns and how they
    differ from each other.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: The Multi-SPA Pattern
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first pattern that we will discuss is the **multi-SPA** pattern. As the
    name suggests, the application is built up of multiple SPAs. Here, the app is
    broken down into 2-3 distinct SPAs and each app is rendered at its own URL. When
    the user navigates from one SPA to another, they are redirected via a browser
    reload. In the case of an e-commerce application, we could look at the search,
    product listing, and product details as one SPA, and the cart and checkout as
    the other SPA. Similarly, the **My Accounts** section, which includes the login,
    registration, and profile information, would form the third SPA.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows an illustration of a multi-SPA pattern microfrontend
    for an e-commerce app:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Multi-SPA pattern microfrontend for an e-commerce app](img/Figure_1.02_B18987.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Multi-SPA pattern microfrontend for an e-commerce app
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the preceding figure, our e-commerce application consists
    of three SPAs: the Catalog SPA, the Checkout SPA, and the Accounts SPA.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: In the simplest form of this pattern, each app behaves as an independent SPA
    that sits within its own unique global URL.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Each SPA is deployed at a unique global route. For example, the catalog app
    would be deployed at a URL such as `mysite.com/catalog/*` and all subsequent secondary
    routes within the catalog app will load up as an SPA within the `/``catalog/*`
    route.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the accounts app would live in the global route of `mysite.com/accounts/`
    and the different pages within the account’s app login, signup, and profile would
    be available at URLs such as `mysite.com/accounts/login` or `mysite.com/accounts/register`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, when the user moves from one macro app to another, there
    will be a reload of the page in the browser. This is because we usually use the
    HTML `href` tags to navigate between the apps. This browser refresh is perfectly
    fine. I’ve seen teams go to great lengths, complicating their architecture, to
    try to achieve a single-page experience. The truth, however, is that users don’t
    really care if your app is an SPA or a **Multi-Page App** (**MPA**). As long as
    the experience is fast and non-janky, they are happy.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: At times, the browser reload may work in your favor as it will reduce the risks
    of memory bloat due to either memory leaks or too much data being put into a data
    store.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: However, if you really want to nail that SPA experience, then you can always
    create a thin app shell that hosts the global routes and data store, such that
    each app is called within this app shell. *We will be going into more detail of
    this pattern in the* *upcoming chapters.*
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: In this pattern, the routing is generally split into two parts, the global or
    primary routes, which reside within the app shell, and the secondary routes, which
    reside within the respective apps.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows an example of a multi-SPA with an app shell:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1.\uFEFF3 – A multi-SPA pattern with an app shell to give an SPA experience](img/Figure_1.03_B18987.jpg)"
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – A multi-SPA pattern with an app shell to give an SPA experience
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Here, you will notice that we have introduced the notion of an app shell, which
    incorporates the header component, and the different SPAs load within the content
    slot. This pattern gives a true SPA experience as the header component doesn’t
    refresh when transitioning from one SPA to the other.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The Micro Apps Pattern
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The other pattern for building microfrontends is what we call the **micro apps**
    pattern. The reason we call it the micro apps pattern is that this is a more granular
    breakdown of the application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 1**.4*, the web page is composed of different components
    where each component is an independent micro app that can exist in isolation and
    work in tandem with other micro apps as part of the same page.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1.\uFEFF4 – Micro app architecture with product images and recommended\
    \ products co-existing as different micro apps](img/Figure_1.04_B18987.png)"
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Micro app architecture with product images and recommended products
    co-existing as different micro apps
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: You will notice the preceding diagram is a more granular version of *Figure
    1**.3*, where we further break down the central content slot into smaller micro
    apps. Notice how the central content area now consists of two micro apps, namely
    the product details and recommended products micro apps.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The micro apps pattern is a lot more complex than the multi-SPA pattern and
    it is recommended mainly for very large web applications, where there are multiple
    teams that own different elements on a single page.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 1**.4*, we would assume that there is a dedicated team that manages
    the product description component of the page, and another team that manages the
    product recommendations component on the same page.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: We would also assume that the frequencies at which these components get updated
    with feature enhancements would be different; for example, the recommendations
    micro app would constantly undergo A/B tests, and hence would need to be deployed
    more frequently than the product image and description micro app, which may not
    change as often.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: In this pattern, all the routes, both primary and secondary, are managed by
    the app shell. Here, in addition to managing the routing and global states, the
    app shell also needs to store/retrieve information about the page layout for each
    of the routes and the different micro apps that need to be loaded within each
    of the pages.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, such large apps usually have a **Content Management System**
    (**CMS**) in place or a templating engine where the layout and the component tree
    are stored and served to the frontend.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, as we come to the end of this section, we saw two primary patterns
    for building microfrontends, the multi-SPA pattern and the micro apps pattern.
    These patterns primarily differ in the level of granularity at which you break
    down your application, and how routing is managed within the microfrontend architecture.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at the guidelines that will help you choose
    the right pattern.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a suitable pattern
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a broad understanding of the two patterns of microfrontends,
    let’s spend some time on some of the key considerations that will help you decide
    which pattern to go with.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: While there may be numerous points of view on what is right, how far to think
    into the future, and how to future-proof your app and architecture, we believe
    there are two primary factors that will help you decide on which of the two patterns
    to go with for your microfrontend architecture. Let’s look at them in detail in
    the following sections.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Team Composition
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For teams that build applications on microservices and microfrontends, it is
    a common practice that they are vertically sliced based on business functionality.
    In the e-commerce example, we may have a team that focuses on the browsing journey
    and another team that focuses on the checkout journey. If one scrum team owns
    the entire browser journey and one scrum team owns the entire checkout journey,
    then it is recommended that you go for the multi-SPA pattern. However, if you
    have numerous small teams that own different entities of the business domain,
    such as, say, search, product recommendations, and promotions, then it would be
    wise to go for the micro apps pattern. As mentioned earlier, the rule of thumb
    is for each scrum team to ideally own a single micro app.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Frequency of Deployments
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another factor that would come into play when deciding how to break down your
    microfrontend would be the frequency of deployments. If there are specific sections
    of the app that change more than others, then those sections can be separated
    into its own microfrontend, which can be separately deployed without affecting
    the other sections of the app. This reduces the amount of testing that needs to
    be done because now we need to test only the micro app that is being changed and
    not the entire application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the decision on whether you should go for a multi-SPA pattern
    or the micro apps pattern boils down to the two key factors of team composition
    and deployment frequency, and this is directly related to the two keywords from
    the definition of microfrontend, namely, independent teams and independent deployments.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Hello World with Microfrontends
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OK, it’s time to get our hands dirty writing some code. We are going to start
    simple by building a basic multi-SPA pattern app. In this example, we will use
    Next.js, which is currently the most popular tool for building performant React
    applications. Follow these steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of this chapter, we assume you are using **pnpm** as the package
    manager. If not, replace **pnpm** with **npm** in the respective commands.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a root folder for our app. We’ll call it **my-store**.
    Run the following command in your terminal:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let’s **cd** into **my-store** and create our two Next.js apps, namely,
    **home** and **catalog**, by typing the following commands in our terminal:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or, we can type the following:'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When it prompts you to add a project name, call it **home**. It will then go
    through the various steps and complete the installation.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The interesting thing about create-next-app is even through you define the
    version as @12, it will nevertheless pull the latest version of Next.js, hence
    to ensure consistency with the rest of this chapter we will update the version
    of next in package.json as follows:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now delete the **node_modules** folder and the package lock file and run the
    pnpm i command
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: While you can always use **yarn** or **npx** to run the CLI, we recommend using
    **pnpm** as it is 2-3 times faster than **npm** or **yarn**.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Once it’s done with the setup, go ahead and create another app repeating steps
    2-5\. Let’s call this project **catalog**.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once complete, your folder structure would look as follows:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let’s run the **home** app by typing the following commands:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Your app should now be served on port **3000**. Verify it by visiting **http://localhost:3000**
    on your browser.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s get rid of the boilerplate code and add simple navigation. Locate and
    open up the file located at **home/pages/index.js** and replace everything within
    the **<main></main>** tags with the following:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that we’ve added basic navigation to navigate between the home and catalog
    pages. Your home app that is running on `localthost:3000` should now look as follows:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: "![Figure 1.\uFEFF5 – Screenshot of the home app with two navigation links for\
    \ Home and Catalog](img/Figure_1.05_B18987.jpg)"
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Screenshot of the home app with two navigation links for Home and
    Catalog
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s move on to the catalog app. Navigate to the index page, located
    at **/catalog/pages/index.js**, and again, let’s get rid of the boilerplate code
    and replace the contents within the **<main>** tag with the following code:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, since we already have the home page being served on port `3000`, we will
    run our catalog app on port `3001`.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We do this by adding the port flag for the **dev** command within the **scripts**
    section of the **catalog/package.json** file, as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, running **pnpm run dev** from within the catalog app should run the catalog
    app on **http://localhost:3001**. You can see this in the following screenshot:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 1.\uFEFF6 – Screenshot of the catalog app running on port 3001](img/Figure_1.06_B18987.jpg)"
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – Screenshot of the catalog app running on port 3001
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to wire these up such that when the user hits `localhost:3000`,
    it directs them to the home app, and when the user hits `localhost:3000/catalog`,
    they are redirected to the catalog app. This is to ensure that both apps feel
    as if they are part of the same app, even though they are running on different
    ports.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'We do this by setting the **rewrites** rule in the **home/next.config.js**
    file, as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see from the preceding code, we simply tell Next.js that if the source
    URL is `/catalog`, then load the app from `localhost:3001/catalog`.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before we test it out, there is another small change needed to the catalog
    app. As you can see, the catalog app will be served on the root of port **3001**,
    but what we would like is for it to be served at **:3000/catalog**. This is because
    with the rewrite we did earlier, Next.js will expect the catalog apps and its
    assets to be available at **/catalog/***. We can do this by setting the **basePath**
    variable in the **catalog/next.config.js** file as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, to test that this is working fine, we will run up both of the apps in two
    different terminal windows by navigating to the home and catalog apps and running
    the **pnpm run** **dev** command.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up **http://localhost:3000** in your browser and verify that the home app
    is loaded. Click on the **Catalog** link and verify that the catalog page does
    load up at **http://localhost:3000/catalog**. Notice that the app catalog that’s
    running individually on port **3001** is sort of “proxied” to load up within a
    unique URL of the parent/host app. This is one of the key principles of microfrontends,
    where apps running on different ports and different locations are “stitched” together
    to make it look like they are a part of the same application.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that, we come to the end of creating our very first microfrontend with
    the multi-SPA pattern. We will look at the micro apps pattern in more detail in
    the upcoming chapters. This pattern meets the majority of the use cases for building
    microfrontends and checks all the key principles of microfrontends, which we are
    going to see in the next chapter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s a wrap for this chapter. We started off by learning how microfrontends
    (when executed correctly) help teams to continue to release new features at a
    consistent pace even as the app size and complexity grow. Then, we learned that
    there are two primary patterns for implementing microfrontends, the multi-SPA
    pattern and the micro apps pattern. We saw that the multi-SPA pattern is easier
    to implement and would suit the majority of use cases. The micro apps pattern
    would be more suitable when different elements of a given page are owned by different
    scrum teams. Finally, we learned how to build our very own microfrontend application
    and saw how we can navigate between the two apps while still giving the user the
    illusion that they are both part of a single app.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at some of the key principles to strictly
    adhere to when designing your microfrontend architecture. We will also look at
    some of the key components of microfrontend and the various ways they can be implemented.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
