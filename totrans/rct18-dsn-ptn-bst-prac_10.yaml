- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React 18 New Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React 18, the latest version of the popular JavaScript library for building
    user interfaces, introduces a host of new features and enhancements that aim to
    improve performance and enhance the developer experience. As a part of the ever-evolving
    React ecosystem, it is crucial to stay up to date with these advancements. In
    this chapter, we will provide a succinct overview of the most notable additions
    in React 18, followed by a brief explanation of the latest features in Node.js
    19.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new features in React 18 include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automatic Batching of State Updates**: React 18 automatically batches multiple
    state updates into a single update, which results in improved performance and
    smoother animations. This automatic batching eliminates the need for manual batching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrent Rendering**: This feature enables React to prioritize the rendering
    of certain components, leading to faster load times, smoother animations, and
    better user experiences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Suspense for Data Fetching**: Suspense enables developers to suspend the
    rendering of a component until the required data is loaded, providing a seamless
    user experience and improved error handling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved Error Handling**: React 18 simplifies error handling by offering
    more information about errors such as the component and code location where the
    error occurred, streamlining the debugging process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**New Component Types**: React 18 introduces two new component types – portals
    and components with side effects. Portals enable rendering components outside
    of their parent components, while components with side effects allow performing
    side effects without a separate function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No Support for Internet Explorer 11**: To leverage modern web standards and
    enhance performance, React 18 no longer supports Internet Explorer 11\. Developers
    must ensure their users employ a modern, supported browser like Google Chrome,
    Mozilla Firefox, Apple Safari, or Microsoft Edge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic batching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suspense on the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strict mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js latest features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React **concurrent mode** is a set of new features in React 18 that enable faster
    and more responsive user interfaces by allowing React to work on multiple tasks
    simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: In traditional React, the rendering process is synchronous, which means that
    React updates the user interface in a single pass. This can sometimes lead to
    performance issues, especially when rendering large, complex applications or handling
    real-time updates.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent mode allows React to split the rendering process into smaller units
    of work that can be executed independently and in parallel. This means that React
    can prioritize certain tasks, such as updating the user interface, while still
    allowing other tasks to run in the background, such as handling user input or
    fetching data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the key features of React concurrent mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time slicing**: Time slicing is a technique that allows React to break up
    large chunks of work into smaller pieces and prioritize the most important tasks
    first. This can help to reduce the perceived latency of an application and make
    it feel more responsive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Suspense**: Suspense is a new feature in React that allows developers to
    suspend the rendering of a component until the necessary data has been loaded.
    This can help to improve the perceived performance of an application and provide
    a better user experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrent rendering**: Concurrent rendering is a new rendering mode in React
    that allows React to update the user interface more frequently, resulting in smoother
    animations and transitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Overall, React concurrent mode is a powerful new set of features that can help
    developers create faster and more responsive user interfaces. While it may require
    some adjustments to existing code, adopting concurrent mode can help to improve
    the user experience of your applications and keep them competitive in a fast-paced
    digital landscape. Here’s an example that demonstrates the use of time slicing
    and concurrent rendering in React 18:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Automatic batching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automatic batching is a new feature in React 18 that improves the performance
    of updates by automatically batching multiple updates into a single render pass.
    In traditional React, updates to the user interface are typically processed synchronously,
    which means that each update triggers a new render pass.
  prefs: []
  type: TYPE_NORMAL
- en: This can be inefficient, especially when multiple updates occur in rapid succession.
    Automatic batching solves this problem by grouping multiple updates together and
    processing them in a single render pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example to illustrate how automatic batching works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a `MyComponent` component that uses the `useState`
    hook to manage a `count` state variable. When the user clicks the `Increment`
    button, we call the `setCount` function three times in rapid succession, each
    time incrementing the count by 1.
  prefs: []
  type: TYPE_NORMAL
- en: In traditional React, each call to `setCount` would trigger a new render pass,
    resulting in three separate updates to the user interface. However, with automatic
    batching in React 18, these updates are automatically grouped together and processed
    in a single render pass. This can result in significant performance improvements,
    especially when handling user input or real-time updates.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, automatic batching is a powerful new feature in React 18 that can help
    to improve the performance and responsiveness of your applications. By automatically
    batching multiple updates together, React can optimize the rendering process and
    reduce unnecessary render passes, resulting in faster and more efficient updates
    to the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React 18 introduces a new feature called **transitions** that allows developers
    to create smooth, declarative animations and transitions in their applications.
  prefs: []
  type: TYPE_NORMAL
- en: Transitions build on the existing capabilities of React’s declarative programming
    model to provide a simple and intuitive way to animate elements and components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple example to illustrate how transitions work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use the `Transition` component from the `react-transition-group`
    library to animate the appearance and disappearance of a `p` element. The `Transitio`n
    component takes an `in` prop that determines whether the element should be shown
    or hidden, and a `timeout` prop that specifies the duration of the transition
    in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `Transition` component, we define a function that takes a state argument
    and returns the contents of the transitioned element. The state argument is a
    string that represents the current state of the transition, which can be one of
    `entering`, `entered`, `exiting`, or `exited`.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we use the state argument to set the opacity of the `div` element
    based on the current state of the transition. When the state is `entered`, we
    set the opacity to `1` to make the element fully visible. When the state is `exiting`
    or `exited`, we set the opacity to `0` to make the element fade out smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: By using the `Transition` component and the state argument, we can create a
    smooth, declarative animation that responds to changes in the application state.
    This can be a powerful way to create engaging and dynamic user interfaces that
    feel alive and responsive.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, transitions are a powerful new feature in React 18 that allow developers
    to create declarative animations and transitions with ease. By leveraging the
    power of React’s declarative programming model, developers can create complex
    animations and transitions with a few lines of code, making it easier than ever
    to create engaging and dynamic user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Suspense on the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React 18 introduces some improvements to **server-side rendering** (**SSR**)
    with **Suspense** that allow developers to create more efficient and scalable
    server-rendered applications.
  prefs: []
  type: TYPE_NORMAL
- en: Before React 18, Suspense was primarily used in client-side rendering to manage
    asynchronous data loading and code splitting. However, with React 18, Suspense
    can also be used on the server to optimize the rendering of server-rendered components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a high-level overview of how Suspense works on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: During the initial render of a server-rendered component, any Suspense boundaries
    are registered, and their fallback content is rendered instead of the main content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When data loading or code splitting is required, the server can return a “placeholder”
    HTML response that contains the fallback content for the Suspense boundaries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the asynchronous data or code has loaded, the client can hydrate the Suspense
    boundaries with the actual content, replacing the fallback content with the final
    content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach allows the server to avoid the expensive rendering of component
    trees that may be blocked by data loading or code splitting. Instead, the server
    can return a simple HTML response with fallback content, which can be quickly
    and easily rendered by the client. This can significantly improve the performance
    and scalability of server-rendered applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example to illustrate how Suspense can be used on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a `MyComponent` component that fetches user data from
    an API and renders it alongside a `UserProfile` component that requires additional
    data loading. By wrapping the `UserProfile` component in a `Suspense` boundary,
    we can ensure that the fallback content is displayed until the additional data
    has been loaded.
  prefs: []
  type: TYPE_NORMAL
- en: When rendering on the server, the server can return a simple HTML response with
    the fallback content for the Suspense boundary, allowing the client to render
    the fallback content quickly and easily. Once the data has been loaded, the client
    can hydrate the Suspense boundary with the actual content, replacing the fallback
    content with the final content.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the improvements to SSR with Suspense in React 18 can help to improve
    the performance and scalability of server-rendered applications, making it easier
    to create fast and responsive web experiences for users.
  prefs: []
  type: TYPE_NORMAL
- en: New APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React 18 has introduced a variety of new APIs that are focused on enhancing
    the user interface, improving application performance, and providing a better
    developer experience. Notably, significant additions include `createRoot`, `hydrateRoot`,
    and `renderToPipeableStream`.
  prefs: []
  type: TYPE_NORMAL
- en: createRoot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React 18 introduces a new API called `createRoot`, which provides a simpler
    and more explicit way to render React components into the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, when rendering a React application into the DOM, you would use
    the `ReactDOM.render` method to specify the root element and the React component
    to render into it. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With `createRoot`, you can create a root element that can be used to **render
    multiple components**, instead of specifying the root element for each component.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first create a root element using `createRoot`, passing
    in the DOM element that we want to render our React application into. We then
    use the `render` method on the `root` element to specify the React component to
    render.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `createRoot` API also supports concurrent mode, which allows React to update
    the UI in a more efficient and responsive way by breaking up large updates into
    smaller chunks. To use concurrent mode with `createRoot`, you can pass a `mode`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we pass the `mod`e option with a value of `'concurrent'`, indicating
    that we want to use concurrent mode when rendering our React components.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the `createRoot` API provides a simpler and more flexible way to render
    React components into the DOM and supports the new features introduced in React
    18, such as concurrent mode and the improved server-side rendering with Suspense.
  prefs: []
  type: TYPE_NORMAL
- en: hydrateRoot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`hydrateRoot` is another new API introduced in React 18 that works in conjunction
    with `createRoot`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the traditional React rendering model, the server would render a static HTML
    document and send it to the client, which would then create a new React root and
    render the app on the client side. However, with SSR, React can render the initial
    HTML on the server and send it to the client, which can then “hydrate” the HTML
    into a fully functional React app.
  prefs: []
  type: TYPE_NORMAL
- en: '`hydrateRoot` is used for this process of hydrating the initial HTML sent by
    the server into a React component tree. It allows React to reuse the server-rendered
    markup so that the initial page load is faster and there’s less work for the client
    to do.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how you can use `hydrateRoot` to hydrate the initial HTML
    on the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first create a root element using `createRoot` as we did
    in the previous example. We then check if the root is already mounted by calling
    `root.isMounted()`. If it is, we use `hydrateRoot` to hydrate the existing HTML
    on the page. If not, we use `root.render` to render the React component as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you need to ensure that the server and client render the same HTML
    structure, otherwise, hydration may fail, and you may end up with a mismatch between
    the server-rendered markup and the hydrated React component tree. To avoid this,
    you can use the Suspense component to handle asynchronous rendering and data fetching
    on both the server and client and ensure that the HTML structure remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: renderToPipeableStream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`renderToPipeableStream` is another new API introduced in React 18 that allows
    you to render a React component tree to a **Node.js** stream. This can be useful
    for server-side rendering in scenarios where you need to send the rendered content
    over a network or to a file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how you can use `renderToPipeableStream` to render a React
    component to a stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first create a simple React component called `App`. We then
    create a Node.js HTTP server using the `createServer` method. When a request is
    made to the server, we use `renderToPipeableStream` to render the `App` component
    to a Node.js stream. We then pipe the stream to the response object using the
    `pipe` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `renderToPipeableStream` returns a Node.js stream that you can pipe
    to other streams or write to a file. This allows you to easily generate server-rendered
    content and send it over a network or save it to disk without having to buffer
    the entire HTML in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that `renderToPipeableStream` is asynchronous, so it returns a Promise
    that resolves to the stream. This means that you can use it with `await` to wait
    for the rendering to complete before sending the response.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, `renderToPipeableStream` is a useful API for SSR in Node.js environments
    and can help improve the performance and scalability of your server-rendered applications.
  prefs: []
  type: TYPE_NORMAL
- en: New Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In React 18, a set of innovative hooks has been introduced, which provide enhanced
    techniques for managing IDs, transitions, and optimizing performance. These hooks
    include `useId`, `useTransition`, `useDeferredValue`, and `useInsertionEffect`.
  prefs: []
  type: TYPE_NORMAL
- en: useId
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`useId` is a new built-in hook in React 18 that can be used to generate a unique
    ID. This can be useful in scenarios where you need to generate unique identifiers
    for elements in a React component, for example, when building forms.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how you can use `useId` to generate a unique ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use the `useId` hook to generate a unique ID, which we then
    use as the `id` attribute of a `<div>` element.
  prefs: []
  type: TYPE_NORMAL
- en: '`useId` generates a unique ID that is guaranteed to be different on each render.
    It takes an optional parameter that can be used to specify a prefix for the generated
    ID, which can be useful for naming elements in a consistent way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how you can use the `prefix` parameter to specify a prefix
    for the generated ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use the `useId` hook with the `'my-prefix'` prefix, which
    generates an ID that starts with the string `'my-prefix'`. This can be useful
    for naming elements in a way that is consistent with your application’s naming
    conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, `useId` is a useful addition to React 18 and can simplify the process
    of generating unique identifiers for elements in a React component.
  prefs: []
  type: TYPE_NORMAL
- en: Although the `useId` hook in React 18 offers unique benefits, it’s essential
    to be aware of certain caveats to avoid potential issues. Firstly, it’s not recommended
    to use `useId` for generating keys in a list. The preferred approach is to derive
    keys directly from your data. Secondly, the `useId` Hook requires a perfect match
    between the component trees on the server and the client side during server rendering.
    Any discrepancies between the server and client-rendered trees could lead to inconsistent
    IDs.
  prefs: []
  type: TYPE_NORMAL
- en: useTransition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`useTransition` is a new built-in hook in React 18 that allows you to add smooth
    transitions to your application. It’s part of the new concurrent mode feature
    and is designed to work with Suspense to create loading states and fallbacks for
    data fetching.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how you can use `useTransition` to add a loading spinner
    while data is being fetched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use `useState` to store the fetched data and `useTransition`
    to handle the loading state while the data is being fetched. When the **Fetch
    Data** button is clicked, the `startTransition` function is called with a callback
    that fetches the data and updates the state. The `isPending` value returned from
    `useTransition` is used to conditionally render a loading spinner.
  prefs: []
  type: TYPE_NORMAL
- en: '`useTransition` takes an optional configuration object with a `timeoutMs` property
    that specifies the maximum amount of time to spend in the pending state before
    showing the loading spinner. If the data is fetched before the timeout expires,
    the loading spinner is not displayed.'
  prefs: []
  type: TYPE_NORMAL
- en: Overall, `useTransition` is a powerful new feature in React 18 that can help
    you create smoother, more responsive applications with better user experiences.
  prefs: []
  type: TYPE_NORMAL
- en: useDeferredValue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`useDeferredValue` is a new built-in hook in React 18 that allows you to defer
    updates to a value until the next frame. This can be useful when working with
    performance-intensive operations like animations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how you can use `useDeferredValue` to animate a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use `useState` to store the current position of the component,
    and `useDeferredValue` to defer updates to the position until the next frame.
    When the component is clicked, the position is updated using `setX`. The deferred
    value is used to render the component with a transition effect using CSS transforms.
  prefs: []
  type: TYPE_NORMAL
- en: '`useDeferredValue` takes two arguments: the value to defer and an optional
    configuration object. The configuration object can be used to specify a `timeoutMs`
    property that determines the maximum time to defer updates. By default, updates
    are deferred until the next frame.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that `useDeferredValue` only works in conjunction with the `useTransition`
    hook, which provides the timing information necessary to defer updates to the
    next frame.
  prefs: []
  type: TYPE_NORMAL
- en: useInsertionEffect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`useInsertionEffect` is a variation of the existing `useEffect` hook that allows
    you to perform actions after a DOM node has been inserted into the page. This
    can be useful for integrating with third-party libraries or for performing actions
    that require the presence of a DOM node.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how to use `useInsertionEffect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use `useInsertionEffect` to create a new `canvas` element
    and add it to the DOM when the component is mounted. The cleanup function returned
    by the hook removes the canvas element when the component is unmounted.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the second argument to `useInsertionEffect` is an empty array. This
    is because we only want to perform the insertion action once the component is
    mounted. If we included any dependencies in the array, the insertion action would
    be performed every time those dependencies changed.
  prefs: []
  type: TYPE_NORMAL
- en: Strict mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React 18 introduces a new feature called **Strict Mode,** which allows you to
    opt in to a stricter set of checks and warnings for your React application. The
    goal of Strict Mode is to catch potential problems early in development and to
    encourage best practices that make your code more performant and easier to debug.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how to use Strict Mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we wrap our component tree with the `React.StrictMode` component.
    This enables several additional checks and warnings during development, such as
    detecting unsafe lifecycle methods, identifying potential side effects, and highlighting
    potential performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: Strict Mode does not affect the behavior of your application in production and
    should only be used during development. Once you are confident that your code
    is free of any issues highlighted by Strict Mode, you can remove the `React.StrictMode`
    component from your code.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that while Strict Mode can be useful for catching potential
    issues early in development, it is not a replacement for thorough testing and
    debugging. Always test your code thoroughly before deploying to production and
    use tools like React’s built-in debugging tools to identify and fix any issues
    that arise.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js latest features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some relevant new features in the latest versions of Node (18 and
    19); let’s see what is new in those versions.
  prefs: []
  type: TYPE_NORMAL
- en: Experimental Fetch API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js 18 (also in version 19) includes an experimental global **Fetch API**
    that is now available by default. The API’s implementation is inspired by **node-fetch**,
    which is originally based on **undici-fetch** and comes from **undici**. The API’s
    developers aim to make it as close to the specification as possible, but some
    features require a browser environment and are thus omitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that hits the Pokémon API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This addition to Node.js 18 (also included in version 19) makes the following
    global variables available: `fetch`, `FormData`, `Headers`, `Request`, and `Response`.
    Users can disable the API by specifying the `--no-experimental-fetch` command-line
    flag.'
  prefs: []
  type: TYPE_NORMAL
- en: Experimental test runner module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s important to note that the test runner module is still in its experimental
    phase. To write unit tests and generate reports in **Test Anything Protocol**
    (**TAP**) format, we can import the `node:test` module. In this section, we’ll
    provide a few examples to illustrate how it works. This testing approach bears
    some similarity to Jest, a widely used JavaScript testing framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `node:test` module simplifies the process of writing JavaScript tests that
    generate reports in **TAP** format. To access it, simply use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To provide an example, here’s a demonstration of a parent test with two subtests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything works fine, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_10_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Experimental test runner module'
  prefs: []
  type: TYPE_NORMAL
- en: Experimental node watch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Node --watch` was introduced as a direct competitor to `nodemon`, and is a
    popular tool used for watching anything, although it has primarily been used for
    Node.js projects. However, with the code snippet provided below, you can now use
    it more easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This code will automatically detect any changes made to the specified file or
    directory and restart the server or script accordingly. This feature is available
    in versions 19.0.0 and 18.11.0+ of Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Node 18 is now Long-Term Support (LTS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following the release of Node.js 19, Node.js 18 became a **LTS** version on
    October 25, 2022, with the codename *Hydrogen*. This transition marks the end
    of the active development phase of Node.js 18.x.
  prefs: []
  type: TYPE_NORMAL
- en: The current Node.js 18.x release has moved to **Active LTS** status and will
    remain so until October 2023\. After that, it will enter the **Maintenance** phase
    and continue to receive necessary security fixes and updates until the end of
    April 2025.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In React 18, a wide array of new features and enhancements are introduced, which
    simplify the development of high-quality and interactive applications. These include
    automatic batching of state updates, concurrent rendering, the inclusion of Suspense
    for data fetching, improved error handling, and the addition of new component
    types. As a result, developers now have the ability to create more responsive
    and engaging user interfaces. For React developers, considering an upgrade to
    React 18 holds significant value. Additionally, we have also explored key features
    in Node.js 18 and 19, which are crucial for enhancing our web projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to handle data properly by using React
    Context API, React Suspense, and **stale-while-revalidate** (**SWR**).
  prefs: []
  type: TYPE_NORMAL
