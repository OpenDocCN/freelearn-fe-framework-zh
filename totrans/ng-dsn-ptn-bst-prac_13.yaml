- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Angular Renaissance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our applications need to continually evolve, and to meet this need, the Angular
    framework and its ecosystem also continue to evolve.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the latest features of Angular. While many
    of them are still in the developer preview phase, it is important for us to get
    a glimpse of what the future holds for this incredible framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Updating your project with the Angular CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a new way to create templates – control flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the user experience using the `defer` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating transitions between pages – view transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying application states – Angular Signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to stay up to date with
    future versions of the framework and how to update your project.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the instructions in this chapter, you’ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js 18 or higher ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch13](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch13).
  prefs: []
  type: TYPE_NORMAL
- en: During the course of this chapter, remember to run the backend of the application
    found in the `gym-diary-backend` folder with the `npm` `start` command.
  prefs: []
  type: TYPE_NORMAL
- en: Updating your project with the Angular CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Angular framework is continually evolving with new features and optimizations,
    but to help communities and developers keep organized and their applications up
    to date, the Angular team uses semantic versioning to number their releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'A semantic version number is composed of three parts and each part has the
    following representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Major**: A number that is increased every time there is a change in the framework,
    which in turn requires us to change something in our application so that it continues
    to work, also known as a **breaking change**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minor**: A number that is increased when the new version has a new functionality
    that we can use, but if we don’t use it, we don’t need to change our application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Patch**: A number that is increased when there is a correction to the framework
    and we do not need to change our code; this is widely used for versions that have
    security corrections'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we are working with version 16.2.0 of Angular, and the next version
    will be 17.0.0, which will bring new functionality and also some breaking changes.
    While the the term “breaking changes” is used, we should note that the Angular
    team has taken more and more care with these changes and currently, they only
    affect very specific cases that the vast majority of applications are not affected
    by.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to rigorous versioning, the Angular team takes care to release
    major releases every six months, allowing the team to plan application updates.
    You may ask, should I always update the Angular version of my application? The
    answer is yes, and here are some reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Every new version brings internal improvements to the framework that improve
    the rendering engines, which can make your application faster and the build time
    and the bundle size smaller and more optimized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New features give you more possibilities to create better experiences for your
    users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides security updates and framework vulnerability fixes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to highlight that the Angular team is committed to making corrections
    (long-term support) for up to two major versions before the current one, which
    means that using old versions of Angular can leave your application vulnerable
    to new security breaches. However, the task of updating the Angular version of
    an application is not that complex as the Angular CLI helps to automate the entire
    process. Let’s update our project to version 17 of Angular to use the new features
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'On your operating system’s command line, in the `gym-diary` project folder,
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With this command, the Angular CLI will update all Angular packages from the
    `package.json` file. Furthermore, it will analyze all your code in search of situations
    where it needs to be changed due to a breaking change. Also, if possible, it will
    update your code for you. If this is not possible, it will indicate what type
    of correction should be made, but again this only happens in very specific corner
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: After the update is complete, to ensure that the application continues to work
    after the process, we can run unit tests and end-to-end tests. For more details
    about the tests, see [*Chapter 10*](B19562_10.xhtml#_idTextAnchor264), *Design
    for Tests:* *Best Practices*.
  prefs: []
  type: TYPE_NORMAL
- en: With our updated project, we can explore the new syntax for HTML templates,
    which we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using a new way to create templates – control flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since version 2 of the framework, the HTML template syntax has remained relatively
    stable and without much evolution. By using custom properties, we can evaluate
    conditions and iterate over lists and other forms of flow control to create visualization
    logic in components. The `*ngIf`, `*ngFor`, and `*ngSwitch` directives are used
    to improve the developer experience, internally generating the elements in the
    HTML. You can read more about this in [*Chapter 4*](B19562_04.xhtml#_idTextAnchor141),
    *Components* *and Pages*.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with version 17, the Angular team introduced a new form of control
    flow in HTML. The syntax in this version is in developer preview, which means
    that it is stable for production but may have changes in future versions. Let’s
    refactor our code to use the syntax and see the difference in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `app.component.html` file, we will change the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can notice the first new structure of the new control flow, `if`. Using
    the command in the HTML template with the `@` symbol, we apply the conditional
    statement as in TypeScript, evaluating whether the function or variable is true
    or false.
  prefs: []
  type: TYPE_NORMAL
- en: The novelty of the syntax is that we now have the `@else` instruction facilitating
    the chaining of conditionals, without the need to use the `ng-template` directive
    for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will refactor the `list-entries.component.html` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are using the `@for` instruction to replace the `*ngFor`
    directive. We provide the name of the variable that will receive the list iteration,
    in this case, `item`, and the list itself, in this component, named `exerciseList`.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B19562_04.xhtml#_idTextAnchor141), *Components and Pages*,
    we learned the good practice of using the `trackBy` property of the `*ngFor` directive
    to improve list rendering performance. This good practice is now mandatory in
    the new `@for` syntax, and in this case, it is even simpler as we can simply pass
    the attribute that Angular should check.
  prefs: []
  type: TYPE_NORMAL
- en: A new element is the `@empty` instruction, which indicates what should be shown
    if the list in question is empty.
  prefs: []
  type: TYPE_NORMAL
- en: The new `@for` instruction, in addition to improving the development experience,
    is also 90% faster, according to the Angular team, when rendering lists than the
    previous solution. That’s because control statements aren’t just sugar syntax
    for directives; the template engine has been redesigned and the instructions manipulate
    Angular’s internal DOM rendering elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s refactor the `new-entry-form-reactive.component.html` file as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we are replacing the conditionals that evaluate form errors with
    the `@if` statement. For the `@for` instruction that we use to render the list
    of exercises, we can notice that the use of the `async` pipe remains very similar
    to the `*ngFor` directive, and we added `track` to further improve the rendering
    of the list. Finally, we are using the `@else if` command to chain two conditionals.
  prefs: []
  type: TYPE_NORMAL
- en: We can note that we do not need to perform any additional configuration to use
    the flow control syntax because this functionality is fully compatible with the
    previous mechanics and they can coexist in the same project and even in the same
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular team even created a migration command in the Angular CLI, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will see a new possibility that this template refactoring
    provides to our application, the option of lazy loading components in our HTML
    templates.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the user experience using the defer command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main intention behind the new HTML template flow control syntax was to have
    a new basis for building new possibilities in the framework’s templates. The first
    new feature made possible by the syntax is the `defer` instruction, with which
    it is possible to lazy load components directly from the HTML template.
  prefs: []
  type: TYPE_NORMAL
- en: We learned in [*Chapter 2*](B19562_02.xhtml#_idTextAnchor081), *Organizing Your
    Application*, that the best practice is to separate your application into functionality
    modules and configure Angular to load these modules in a lazy way. This means
    that the module and its components would only be loaded if the user accessed a
    certain route, resulting in smaller bundles and better performance of your application,
    especially if your user does not have a good internet connection (such as 3G).
  prefs: []
  type: TYPE_NORMAL
- en: The `defer` command has the same purpose but instead of working for modules,
    it works for `standalone` components. We studied `standalone` components in [*Chapter
    11*](B19562_11.xhtml#_idTextAnchor285), *Micro Frontend with* *Angular Elements*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start our refactoring by transforming the exercise list components
    into a `standalone` component. In the `diary.component.ts` file, make the following
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have included the `standalone` attribute set to `true`
    and added the components it depends on directly using the `imports` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will do the same procedure in the `EntryItemComponent` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this component, in addition to the `standalone` property, we need to add
    the dependency so that the date pipe works. It is necessary to note that the standalone
    component needs to have its dependencies declaratively in the `imports` attribute,
    since it is not linked to any Angular module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To lazy load the template, we will also convert the `NewItemButtonComponent`
    component into a standalone one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The last component to be converted into a standalone component is `ListEntriesComponent`,
    changing it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we added the `EntryItemComponent` dependency to the `import`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The unit tests were also adjusted to consider the component dependencies in
    the `TestBed` definition, and you can find the test code in the GitHub repository
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last adjustment must be made in the `DiaryModule` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we will dynamically load the components that were converted to standalone,
    we have to remove these components from the `declarations` attribute of the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this preparation, we can use the `defer` command in the `diary.component.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To use the `defer` command, we must create a block that includes the components
    that we want to lazy load.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run our application and analyze the **Networks** tab, we will notice
    that specific bundles are loaded when the screen is rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Lazy-loaded bundle](img/B19562_13_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Lazy-loaded bundle
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that the effect is similar to the lazy loading of a route module,
    but `defer` has other interesting options. Let’s see this in practice by changing
    our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `on hover(trigger)` condition, the list is loaded when we hover over
    the `defer` command opens up a range of opportunities for fine-tuning the user
    experience. The `defer` command has the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`on immediate`: The component will be loaded the moment the screen is rendered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on idle`: The component will be loaded on the first call to the browser `requestIdleCallback`
    API. This API allows non-blocking processing in the browser and is the default
    behavior of the `defer` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on hover(target)`: We can define another interface component and loading will
    occur when the user hovers over this component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on timer(time)`: Allows us to define in milliseconds when the component will
    be loaded after the interface is rendered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on viewport(target)`: When the target component is in the browser’s viewport,
    the child components will be loaded. This behavior is ideal for loading a component
    that is located after the user has scrolled to the end of the page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on interaction(target)`: It has a similar behavior to *on hover*, but it will
    be triggered by some interaction, such as a click.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`when (condition)`: Allows us to control the loading of the component imperatively,
    through a Boolean attribute, or a function that returns a Boolean.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Complementing the `defer` command, we have other commands that we can use.
    Returning to our code, we will change it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'These complementary commands have the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@loading`: Presents the content of the block while the components of the `defer`
    block are loaded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@placeholder`: Displays the content of the block, while the components of
    the `defer` block do not start loading, for example, if the user does not hover
    over the given target'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@error`: Displays the content of the block if an error occurs when loading
    the components of the `defer` block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many possibilities that we have with this `defer` command in our templates,
    and we should explore them to improve our users’ experience. But note that we
    should not lazy load all the components of a screen. We need to use the `defer`
    command on large components or components that are not essential for the page
    we are building.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore how to improve the experience of transitions
    between routes in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating transitions between pages – view transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As frontend developers, we need to worry about the technical performance of
    our applications. Small UI details, such as the loading screen that we created
    in [*Chapter 8*](B19562_08.xhtml#_idTextAnchor225), *Improving Backend Integrations:
    the Interceptor Pattern*, improve our users’ perception of the application’s performance.
    One of these UI details is the transition between pages of our application. Instead
    of dry loading from one route to another, we can create an animation that smooths
    this transition, making the user experience more pleasant.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Until version 17 of Angular, it was possible to make this animation using the
    standard Angular Animation package that we used earlier in the book, in the toaster
    animation created in [*Chapter 8*](B19562_08.xhtml#_idTextAnchor225), *Improving
    Backend Integrations: the Interceptor Pattern*. The way to create this animation
    is specific to Angular and is not very simple for designers specializing in CSS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As of version 17 of Angular, there is support for the `app-routing.module.ts`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We are configuring Angular so that the route mechanisms will use view transitions
    written in CSS with the `enableViewTransitions` property. With just this change,
    we can notice in our application that the transition between pages has a pleasant
    fade-in and fade-out animation. This default animation was created by the Angular
    team to make developers’ lives easier. But we can also customize this animation
    with a little CSS. In the `styles.css` file, we will create the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For CSS animations, we need to define an initial and final state that we want
    the element to be in, in this case, the entire screen. For our example, we define
    a state where the screen goes to the right in the `slide-right` keyframe and goes
    to the left in the `slide-left` keyframe. Finally, we define the keyframes for
    the fade-in and fade-out effects.
  prefs: []
  type: TYPE_NORMAL
- en: Note that when we define the transition animation, we completely replace Angular’s
    default transition animation, so we are defining the fade-in and fade-out keyframes
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up the animation, let’s add the following to the `styles.css` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The View Transitions API creates pseudo-elements in the CSS where we define
    the exit animation of the old page (`::view-transition-old`) and the entrance
    animation of the new page (`::view- transition-old`). In this case, we define
    that the old screen will fade out and move to the left and the new page will fade
    in and slide in from the right.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The View Transitions API was created in 2023 and is being gradually adopted
    by browsers. Go to [https://caniuse.com/](https://caniuse.com/) and check whether
    the browsers your users will use have support for this API.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore Angular Signals and how we can use it to
    simplify state control in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying application states – Angular Signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Controlling the state of a frontend application is one of the biggest challenges
    for a developer, as by nature, the interface is dynamic and needs to react to
    various user actions. Angular, with its *stacks included* philosophy, already
    had tools suitable for this task, and we studied in *Chapters 5*, *Angular Services
    and the Singleton Pattern*, and [*Chapter 9*](B19562_09.xhtml#_idTextAnchor242),
    *Exploring Reactivity with RxJS*, how to use these tools. However, despite being
    effective, the Angular community and team recognize that they are a bit complex
    for new developers and for simple cases of reactivity in frontend projects. To
    fill this gap, the Angular team introduced, from version 17 onward, a new element
    to the framework, called Signals.
  prefs: []
  type: TYPE_NORMAL
- en: According to the Angular documentation, a signal is a wrapper around a value
    that notifies consumers when that value changes. An analogy that you can associate
    with a signal is a cell in a spreadsheet. It can contain a value and we can create
    formulas in other cells that use its value to create other values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before refactoring our application, let’s illustrate this with a simpler example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To create a signal, we use the `signal` function, where we define what type
    of value it will store and declare an initial value for it. A signal can be writable
    or read-only; in this case, the variables `a` and `b` are writable. The variable
    `c` is also a signal but of a specific type, called computed. The computed type
    is, in our analogy of a spreadsheet, a cell that contains a formula where you
    can read the values of other cells to determine its value. Finally, we are reading
    the value of the signal by simply calling it as a function. The result of this
    code snippet is the value `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now change the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this change, we are updating the value of signal `a` using the `set` method.
    When reading the `sum` signal, we can notice that the value was updated to `12`.
    Notice that the calculation reacts in real time just like it would in a spreadsheet..
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to update the value of a writable signal is by using the `update`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `update` method allows you to update the signal based on the last value
    contained there.
  prefs: []
  type: TYPE_NORMAL
- en: Despite being simple, `signal` allows many possibilities as it can contain any
    type of value, from primitive ones such as numeric, string, and Boolean to complex
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will refactor our project to use signals, starting with the `LoadService`
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are exchanging the `isLoading` attribute for the `isLoading` signal,
    simplifying the service. We will change the `AppComponent` component template
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To read the contents of the signal, we call it as if it were a function. Normally,
    it is not a good practice to call a function in a template, due to unnecessary
    processing. However, the signal was created and optimized to be read in the template,
    so in this case, there is no problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next task will be to refactor the list of journal entries so that we no
    longer manage the list but leave everything to the `ExerciseSetsService` service.
    We’ll start by changing the `ExerciseSetsService` service as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we created the `exerciseList` signal by declaring
    it to contain `ExerciseSetList` and initializing it with an empty list. Then,
    we changed the `getInitialList` method toupdate the `exerciseList` signal based
    on the API return. We also changed the `delete` method to update the signal after
    deleting the diary entry.
  prefs: []
  type: TYPE_NORMAL
- en: As we are changing the behavior of the function, we also need to exclude the
    `diaryResolver` function as now, the service will manage the query in the API
    and the component will consume the created signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ListEntriesComponent` component, we will refactor to consume the signal
    list we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we replace the component’s `input` with the `ExerciseSetsService`
    service and receive the `exerciseList` signal from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will change the `ListEntriesComponent` component template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `@for` command is prepared to read the content of a signal, including checking
    the type of value contained in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish this refactoring, we will change the template of the `''``DiaryComponent''`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We removed the exercise list from the `app-list-entries` component as it will
    manage the state itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'After changing the template, we can change the `DiaryComponent` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As the state is now managed by the `ExerciseSetsService` service, we are simplifying
    the component by just calling the service’s methods, without having to manage
    subscriptions to observables.
  prefs: []
  type: TYPE_NORMAL
- en: With the state managed by Signals, we can add a new feature here on this screen.
    Let’s assume that we need to inform the total training volume in the diary, that
    is, the total amount of exercise performed.
  prefs: []
  type: TYPE_NORMAL
- en: To have this information and react to events such as the deletion or inclusion
    of an entry, we can use Angular Signals!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `DiaryComponent` component, we will make the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We create a new computed signal called `'volume'` and perform the calculation
    in it based on the value contained in the `'``exerciseList'` signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this new signal, let’s change the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We are consuming the `volume` signal by calling the signal directly in the template.
    By running our project, we can notice that this `volume` signal reacts to the
    changes we make in our list of exercises.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Lazy-loaded bundle](img/B19562_13_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Lazy-loaded bundle
  prefs: []
  type: TYPE_NORMAL
- en: Signals are elements that will be increasingly improved by the Angular team,
    giving more control over the reactivity of our applications. An important point
    that we need to pay attention to is that Signals will not replace RxJS; in fact,
    they complement each other as we still need observables to control asynchronous
    flows and more complex flows, as we studied in [*Chapter 9*](B19562_09.xhtml#_idTextAnchor242),
    *Exploring Reactivity* *with RxJS*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the possibilities that the future of the Angular
    framework can offer us. We learned how to update our project to new versions of
    Angular, an ongoing activity as the framework continues to evolve. We understood
    how Angular versioning works and the importance of continually updating our project,
    from the point of view of security, performance, and new features. Then, we changed
    our application to use the new template expressions, which, in addition to simplifying,
    can, depending on the case, improve the performance of our applications. With
    this improvement in template expressions, we looked at the `defer` expression,
    which allows for the lazy loading of components within templates, giving us new
    options for optimizing interfaces with complex components. We also learned how
    to use the View Transactions API to improve our users’ experience with animations
    between page changes. Finally, we explored Angular Signals and simplified the
    state management of our application with this new element that complements RxJs.
    Angular is a framework that never stops evolving, as our users never stop demanding
    new features. In this chapter, we learned how to stay up to date with Angular.
  prefs: []
  type: TYPE_NORMAL
