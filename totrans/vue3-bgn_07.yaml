- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Handling API Data and Managing Async Components with Vue.js
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vue.js处理API数据和异步组件管理
- en: In [*Chapter 6*](B21130_06.xhtml#_idTextAnchor074), we focused on how components
    can communicate with each other with the use of properties, which are used for
    parent-to-child communications and events to handle messages sent from a child
    to a parent.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B21130_06.xhtml#_idTextAnchor074)中，我们关注了组件如何通过使用属性进行相互通信，这些属性用于父到子通信，以及事件来处理从子组件发送给父组件的消息。
- en: In this chapter, we will stay on the topic of communication by showing how to
    communicate with an external source, such as an API. External communication is
    a very common method when developing a dynamic website that cannot make use of
    static data, and learning how to manage asynchronous operations will not only
    result in a clean user experience but also help keep the application performant.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续探讨通信的话题，展示如何与外部资源，如API进行通信。在外部通信是开发无法使用静态数据的动态网站时，这是一个非常常见的方法。学习如何管理异步操作不仅会导致干净的用户体验，而且有助于保持应用程序的性能。
- en: Loading data from an external source such as an API makes data handling more
    complicated. In fact, when the data is hardcoded, we do not have to worry about
    anything, as the information is immediately available, while when working with
    data that comes from an external source, we need to not only think about the empty
    state that the app will be while the data is loaded but also consider the possibility
    of the data failing to load.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部源，如API加载数据使得数据处理更加复杂。实际上，当数据是硬编码时，我们不需要担心任何事情，因为信息是立即可用的。而当我们处理来自外部源的数据时，我们不仅需要考虑数据加载期间应用程序的空状态，还要考虑数据加载失败的可能性。
- en: We will start the chapter by removing the hardcoded posts and loading them dynamically;
    we will then do the same with the comments by making the data on-demand. We will
    then enhance our application to automatically load more posts, using `watch`.
    Finally, we will learn how to define and use asynchronous components using `<Suspense>`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先移除硬编码的帖子并动态加载它们；然后我们将对评论做同样的处理，通过按需加载数据。然后我们将增强我们的应用程序，使其能够自动使用`watch`加载更多帖子。最后，我们将学习如何使用`<Suspense>`定义和使用异步组件。
- en: 'The chapter will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Loading data from an API using the Vue.js life cycle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vue.js生命周期从API加载数据
- en: Watching for changes in components using `watch` functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`watch`函数监视组件中的变化
- en: Handling asynchronous components with Suspense
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Suspense处理异步组件
- en: By the end of the chapter, you will have learned how to load data and components
    dynamically. You will know how to create components that load data on demand and
    what benefits this brings to our application. You will also be able to handle
    side effects using `watch` and, finally, define and take care of asynchronous
    components to ensure your application is rendered correctly.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何动态加载数据和组件。你将知道如何创建按需加载数据的组件，以及这给我们的应用程序带来的好处。你还将能够使用`watch`处理副作用，最后定义并处理异步组件以确保应用程序正确渲染。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, the branch is called `CH07`. To pull this branch, run the
    following command or use your GUI of choice to support you in this operation:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，分支被称作`CH07`。要拉取这个分支，运行以下命令或使用您选择的GUI来支持此操作：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As part of this chapter, we are also going to use an external resource called
    Dummyapi.io. This website will provide a dummy API that we will use to load our
    post dynamically. To be able to use the API, you need to register and generate
    an **APP ID**. Creating an **APP ID** is completely free and can be obtained by
    creating an account on the following link ([https://dummyapi.io/sign-in](https://dummyapi.io/sign-in)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的一部分，我们还将使用一个名为Dummyapi.io的外部资源。这个网站将提供一个模拟API，我们将用它来动态加载我们的帖子。要使用API，您需要注册并生成一个**APP
    ID**。创建**APP ID**是完全免费的，您可以通过以下链接创建账户来获取：[https://dummyapi.io/sign-in](https://dummyapi.io/sign-in)。
- en: This new branch, `CH07`, includes just a couple of style changes and the replacement
    of the native button with the custom button component that we created in the last
    chapter, `TheButton.vue`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新分支，`CH07`，仅包含一些样式更改以及用我们在上一章`TheButton.vue`中创建的自定义按钮组件替换了原生按钮。
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该章节的代码文件可以在[https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners)找到。
- en: Loading data from an API using the Vue.js life cycle
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vue.js生命周期从API加载数据
- en: It is common for most of the applications that are built for the web to expose
    a level of dynamic content. Providing the ability to load information on the fly
    has been one of the most important factors that led to the growth of JavaScript
    frameworks, such as Vue.js.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数为网络构建的应用来说，暴露一定程度的动态内容是很常见的。提供即时加载数据的能力是JavaScript框架（如Vue.js）增长的最重要因素之一。
- en: Until now, the Companion App has been built using static data that is loaded
    directly within the components. Hardcoded values are not very common in real applications,
    and the posts and comments used within the application were just a stopgap to
    help us focus on the basic features of Vue.js, but it is now time to learn how
    to load data dynamically.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，伴随应用一直是使用直接在组件中加载的静态数据构建的。在真实应用中，硬编码的值并不常见，应用中使用的帖子评论只是权宜之计，帮助我们专注于Vue.js的基本功能，但现在是我们学习如何动态加载数据的时候了。
- en: Being able to successfully handle asynchronous data load is very important.
    No matter how big or small your next application will be, it is very likely that
    you will be required to handle external data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 能够成功处理异步数据加载非常重要。无论你的下一个应用有多大或多小，你很可能需要处理外部数据。
- en: In this section, we are going to update two parts of our application. First,
    we are going to update `SocialPosts.vue` to load the post from an external source,
    and then we are going to change `SocialPostComments.vue` to also load comments
    dynamically but with a little twist, as we will implement something called “loading
    data on demand.” We will then briefly discuss the implications that dynamic loading
    can have on performance and the user experience of our application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更新我们应用的两个部分。首先，我们将更新`SocialPosts.vue`以从外部源加载帖子，然后我们将更改`SocialPostComments.vue`以动态加载评论，但会有一个小变化，因为我们将会实现一个叫做“按需加载数据”的功能。然后我们将简要讨论动态加载可能对我们应用性能和用户体验产生的影响。
- en: Loading social posts from an API
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从API加载数据的社会帖子
- en: Until now, the posts that our application displayed were always the same due
    to the hardcoded array of `posts` defined in `SocialPosts.vue`. In this section,
    we are going to use a public API offered by **DummyAPI** ([https://dummyapi.io/](https://dummyapi.io/))
    to make our post dynamic.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应用显示的帖子总是相同的，这是由于在`SocialPosts.vue`中定义的`posts`数组是硬编码的。在本节中，我们将使用**DummyAPI**提供的公共API（[https://dummyapi.io/](https://dummyapi.io/))来使我们的帖子动态化。
- en: Services such as **DummyAPI** are very useful to develop application scaffolding
    and to help you practice your skills. There are plenty of free services like this
    one available on the internet, and they can easily be found using a search engine.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**DummyAPI**等服务对于开发应用框架和帮助你练习技能非常有用。互联网上有许多这样的免费服务，并且可以通过搜索引擎轻松找到。'
- en: Research is part of development
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 研究是开发的一部分
- en: Spend a couple of minutes navigating through the **DummyAPI** website and try
    to understand how we will use the API and what endpoints we will use. Learning
    external resources is a very important part of web development.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 花几分钟时间浏览**DummyAPI**网站，尝试理解我们将如何使用API以及我们将使用哪些端点。学习外部资源是网络开发中非常重要的一个部分。
- en: 'Loading external data will be achieved using Vue.js methods, the native Fetch
    API, and Vue.js life cycles. First, we are going to remove the old, hardcoded
    data from `SocialPosts.vue`. This file can be found in the `molecules` folder,
    as it is a component that renders a big section of our Companion App homepage:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vue.js方法、原生的Fetch API和Vue.js生命周期将实现外部数据的加载。首先，我们将从`SocialPosts.vue`中移除旧的、硬编码的数据。这个文件可以在`molecules`文件夹中找到，因为它是一个渲染我们伴随应用主页大部分内容的组件：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, in the same file, we are going to create a method that calls the external
    API to fetch our new posts:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在同一文件中，我们将创建一个调用外部API以获取新帖子的方法：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code uses the native JavaScript `fetch` method ([https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API))
    to send a `GET` request to the [dummyapi.io](http://dummyapi.io) API. Due to the
    API requirements, we need to pass `app-id` with the request. This can be obtained
    for free, as mentioned in the *Technical* *requirements* section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用原生的JavaScript `fetch`方法([https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API))向[dummyapi.io](http://dummyapi.io)
    API发送`GET`请求。由于API的要求，我们需要在请求中传递`app-id`。正如*技术要求*部分所述，这可以免费获得。
- en: We then fetch the result in the `json` format using `response.json()` and, finally,
    append the returned data to the post’s `Reactive` property.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用`response.json()`以`json`格式获取结果，最后将返回的数据追加到帖子的`Reactive`属性中。
- en: After the method has been defined, it is time to “call” it. When triggering
    an `async` request like in this case, we take advantage of the Vue.js life cycle
    to ensure that our request is triggered at the correct time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义方法之后，是时候“调用”它了。在这种情况下，当触发一个`async`请求时，我们利用Vue.js的生命周期来确保我们的请求在正确的时间被触发。
- en: 'In [*Chapter 2*](B21130_02.xhtml#_idTextAnchor028), we introduced the different
    life cycles and mentioned that the `created` life cycle is the correct one for
    asynchronous data. Our description of it was as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B21130_02.xhtml#_idTextAnchor028)中，我们介绍了不同的生命周期，并提到`created`生命周期是异步数据的正确选择。我们对它的描述如下：
- en: “[The `created` life cycle] is the perfect stage to trigger asynchronous calls
    to gather some data. Triggering slow requests now will help us save some time,
    as this request will continue behind the scenes while our component is being rendered.”
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: “[`created`生命周期]是触发异步调用来收集数据的完美阶段。现在触发慢速请求将帮助我们节省时间，因为这个请求将在组件渲染的同时在幕后继续。”
- en: 'Let’s go and call our newly created method, `fetchPosts`, during the created
    life cycle. In contrast to other life cycles such as `mounted`, `created` does
    not need to be explicitly defined. The explanation from the official documentation
    is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去调用我们新创建的方法`fetchPosts`，在`created`生命周期中。与`mounted`等其他生命周期不同，`created`不需要显式定义。官方文档的解释如下：
- en: “Because `setup` is run around the `beforeCreate` and `created` lifecycle hooks,
    you do not need to explicitly define them. In other words, any code that would
    be written inside those hooks should be written directly in the `setup` function.”
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: “因为`setup`是在`beforeCreate`和`created`生命周期钩子周围运行的，所以你不需要显式地定义它们。换句话说，任何应该写入这些钩子内部的代码都应该直接写在`setup`函数中。”
- en: 'This simplifies our requirement, meaning that all we need to do is call the
    method after it is defined within the body of our component’s JavaScript logic:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这简化了我们的需求，意味着我们只需要在我们的组件JavaScript逻辑体中定义方法后调用它：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At this stage, our posts should be dynamically loaded from the API, but the
    work is not done yet; in fact, the application displays the posts incorrectly:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们的帖子应该从API动态加载，但工作还没有完成；事实上，应用程序显示的帖子是错误的：
- en: '![Figure 7.1: The Companion App displaying a broken UI](img/B21130_07_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：显示损坏UI的伴侣应用](img/B21130_07_01.jpg)'
- en: 'Figure 7.1: The Companion App displaying a broken UI'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：显示损坏UI的伴侣应用
- en: What caused the preceding error?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上述错误是由什么引起的？
- en: Before reading the answer, why don’t you try to investigate what could have
    caused the issue with the rendering displayed in *Figure 7**.1*? How would you
    go about fixing it?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读答案之前，你为什么不尝试调查一下是什么导致了*图7.1*中显示的渲染问题呢？你会如何着手修复它？
- en: The data fetched by the API is loaded and applied to our “posts” successfully,
    but the structure of the data does not match the one that we previously had set.
    This problem is related to the advanced properties settings that we just learned
    about in the previous chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: API获取的数据已成功加载并应用于我们的“posts”，但数据的结构并不符合我们之前设置的。这个问题与我们之前章节中学到的高级属性设置有关。
- en: Fixing the SocialPost.vue properties’ misalignment
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复SocialPost.vue属性的不匹配
- en: Misaligned props are something that is very common in real applications, but
    they can be avoided. In fact, the reason why the app is rendering a broken UI
    is that we have not specified which properties are expected to be “required” in
    `SocialPost.vue`, and as a result, Vue.js tries to render the app with the data
    it has, resulting in the missing data being set as `null`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s compare the previous hardcoded structure of the posts array with the
    new structure received by the API to see how the two structures compare and what
    changes are required to ensure the Companion App can correctly render the post
    information:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: The transition between the previous structure of posts and the
    new one provided by the API](img/B21130_07_02_BW.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: The transition between the previous structure of posts and the
    new one provided by the API'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.2* displays the changes we are going to make in our application
    to align with the new data. Some of the fields need to change to match the new
    object properties, and comments and retweets have been removed altogether. Calling
    the `<SocialPost>` component will now be changed to the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding highlighted code shows the difference between the old and new
    component instances. Note that we had to replace `userId` with just `id`, which
    will be required later. It is now time to modify the child component to make sure
    it can function with the new data. This will involve a couple of steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove `UserId` from the UI, as it is too long:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Remove `comments` and `retweets` from the `props` declaration:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Refactor `interactions` and `commentsNumber` from the UI and replace them with
    just `likes`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Remove the logic associated with `interactions` and `commentsNumber`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: <TheButton
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: v-show="hasComments"
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '@click="onShowCommentClick"'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: value="Show comment"
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: width="auto"
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: theme="dark"
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: />
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding changes may seem quite complicated when reading them out, but
    they follow a logical pattern. They are all connected to each other, a modification
    in one component may result in a change in another and so on. For example, removing
    the `retweet` props in the parent would then result in the props being removed
    from the child component within `defineProps`, and consequently, the removal of
    any code logic attached to those props, and finally, any use of the props in the
    component template.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: As you get more familiar with the framework, the preceding changes will feel
    trivial, but I have added them here and covered them step by step on purpose to
    give you some idea of how to logically think about a component and its data flow.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, the application should render correctly, and the home page should
    display posts coming from the dummy API we have implemented:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: The Companion App displaying posts from the external API](img/B21130_07_03.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: The Companion App displaying posts from the external API'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The Companion App displays the post correctly again, but something is still
    missing. The logic that was used to display the comment does not work correctly
    anymore.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Before we move forward, you should improve the component that we just made to
    make it more reliable, by improving its properties.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Your turn – improve the properties set in SocialPost.vue
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Spend a few minutes to enhance the props set in `SocialPost.vue`. Look at each
    props and decide if they should be required, by using the `required` attribute
    on props or if they could be set to optional by defining a `default` value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Load comments on demand
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the `posts` data was hardcoded, the comments associated with the individual
    post were available on the first render, and we were able to pass them immediately
    between the parent and child components. But now that the information is loaded
    dynamically, we can change our logic to just load the comments on demand.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Imagine an application where all the data is loaded on the main page and has
    to be passed around between tens of components. No matter how hard you would work,
    the code would be quite hard to maintain. Passing properties through many layers
    of components is known in the industry as “props drilling.”
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Props drilling can be avoided using two techniques:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Loading data on demand
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using state management
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are going to cover the first technique, loading data on
    demand, while state management will be covered later in [*Chapter 11*](B21130_11.xhtml#_idTextAnchor153).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Making a change like the one we just performed prevents some data from being
    loaded immediately, with it just being fetched on demand. This is a very good
    practice to improve both performance and code structure.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: When analyzing how comments behave in our application, we can see that it would
    be quite wasteful to load all comments associated with the posts immediately,
    when we know that the application will just display them on user interaction (a
    button click).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: We are going to work on two files. First, we are going to replace the `comments`
    property from `SocialPost.vue` with the post ID. Then, we will create the functionality
    required to load the comments on demand in `SocialPostComments.vue`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you should have enough knowledge to remove the `comments` property
    from the component and replace it with another property, called `post-id`. This
    will be used later to request the correct comments from the dummy API, and the
    code changes should be the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Because the `comments` property was already removed from `defineProps` in the
    previous section of this chapter, all that was left to do was to ensure that we
    removed the prop from the `<SocialPostComments>` component declaration and replaced
    it with one called `post-id`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step requires us to rewrite the logic that handles the load of the
    comments. We will start by modifying the properties, by removing the `comments`
    one and replacing it with the newly passed `post-id`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The ID of the post is required for us to be able to fetch the correct comments
    from the API. It is very common when passing IDs around to prefix them with the
    actual context. So, in our case, instead of naming our prop ID, we named it `postId.`
    Small improvements such as this can really help keep your code clean and readable.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Defining multiword props using kebab case
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice that the property we just defined is called `postId` in the component
    declaration but is passed in the component using kebab case, `post-id`? HTML is
    not case-sensitive, so using `postId` would just mean the same as `postid`. Therefore,
    to ensure that we better define the multiword props, we use kebab case – that
    is, “word-word.”
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: It is now time to make the necessary changes to ensure that `SocialPostComments.vue`
    works correctly with the new posts structure and create the logic required to
    load the comments on demand.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use the following path from the API, `/post/{postId}/comment`.
    This is going to return us the comment from a given `postId`, where `postId` is
    the actual ID of the post selected.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down all the changes required:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import `reactive`from `vue` and use it to define a new array for
    `comments`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Second, we create a new method called `fetchComments` that accepts a parameter
    of `postId`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we create a fetch request in the body of the newly created method and
    use `postId` to create the correct request URL. Just like before, we make sure
    to pass the correct `app-id`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, we fetch the response JSON and assign it to the `comments` reactive:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, we call this function when the component loads. As mentioned before,
    calling a function within the script setup body is equivalent to calling it on
    the created life cycle. The function will receive the `postId` property as its
    argument:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'At this stage, our Companion App will render the `comments` body that is currently
    received from the API request:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: The comments body displayed in the Companion App](img/B21130_07_04.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: The comments body displayed in the Companion App'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'From the screenshot displayed in *Figure 7**.4*, we can deduce that there are
    two main changes that we need to implement in the component:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Improve the UI when no comments are available
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Format the body of the comments to just show the author’s name and the message,
    instead of the raw object received by the API
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To improve the user experience and show a different message if there is a post
    with no comments, we can use the built-in `v-if` and `v-else` directives:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Just like a simple `if`/`else` statement, when a Vue.js component receives elements
    that include a `v-if` and `v-else` directives, it will just render one of the
    two, depending on the condition received. In our case, the first block will be
    rendered if the comments array is empty and has a length of zero, while the second
    block will render if comments are available.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Use <template> to avoid unused HTML elements
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we used an element called `<template>` when introducing
    the `v-if`/`v-else` code block. The `<template>` element is a special Vue.js element
    that allows you to add logic without the need to add an HTML element. In fact,
    if the template element was not available, we would have had to add `<span>` or
    `<div>` just to allow us to add our logic. Every time you use the `<template>`
    element, it will disappear and will not render anything within the DOM. It is
    very useful in logic that uses `v-if`, `v-else`, `v-if-else`, or `v-for`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Let’s fill in the code blocks that we just created with the correct HTML. The
    first block will just show a static message for the empty state, while for the
    second, we need to analyze the object received by the API and understand what
    we want to display.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'It is now time to focus on the structure of the comments. The `comment` object
    seems to include multiple properties, but the only ones we should use are the
    name of the user and the message, therefore `owner.firstName` and `message`, respectively:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `v-if` statement includes a simple static message, while `v-else` contains
    a loop created using the `v-for` directives, `<div v-for="{owner, message} in
    comments" class="comment">`, that includes two mustache templates to format our
    string, `<p>{{ owner.firstName }}: <strong>{{` `message }}</strong></p>`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: After the latest modification, our Companion App should display a nicely formatted
    layout for our comments.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: The Companion App’s formatted comments](img/B21130_07_05.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: The Companion App’s formatted comments'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to load information asynchronously using an
    external API; we then walked through the changes necessary to ensure our application
    can work with the new dynamic data. The section also included a few tips to help
    you improve your Vue.js skills, such as the use of `<template>` to keep the HTML
    clean, the need to declare multi-word properties with kebab case, and the defining
    good properties to ensure that our components will not render incorrectly if any
    of the values are missing.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to learn how to trigger side effects, such
    as API requests, when watching for components’ data changes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Watching for changes in components using watch
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to load our data dynamically by triggering
    an API request during the component rendering cycle. In this section, we will
    see another aspect of asynchronous data loading by describing how to handle API
    requests, triggered as a side effect when watching for data changes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: As we learned in [*Chapter 5*](B21130_05.xhtml#_idTextAnchor060)*,* computed
    properties are a great asset to watch other properties and internal data to create
    new variables, but they are not handy when we need to trigger a side effect, such
    as a DOM change or an API call.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: This is where a Vue.js feature called `watch` comes to the rescue. `watch`,
    just like `computed`, allows you to listen to any changes that occur to properties,
    reactive data, or another computed property, but it also provides you the ability
    to trigger a callback when data changes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: watch is just for edge cases, not everyday use
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself using `watch` often during your development, it means that
    you are using `methods` and `computed` incorrectly. It is very common for inexperienced
    Vue.js developers to overuse `watch`. I have personally used it just a handful
    of times in years of development.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: We are going to change our application to automatically load more posts if there
    are fewer than four posts shown on screen. As mentioned previously, we are going
    to watch for a component variable (in our case, the `posts` array), and we are
    then going to trigger a side effect (in our case, another API call) when a certain
    condition is met.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s develop this together. First, we need to update our `fetch` method to
    accept a page parameter to ensure that we fetch new posts and not always the same
    ones:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `fetchPosts` method now accepts a parameter of `page` and appends it to
    the request query parameter, `` `${baseUrl}/post?limit=5&page=${page}` ``.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'We are then going to create a new ref called `page` that will hold the current
    page value. To accomplish this, we are going to import `ref` from Vue.js:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, we define and initialize the variable. Because the first page of the
    posts is going to be 0, we are going to use this number as the initialization
    value:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Lastly, we are going to pass this `ref` when calling `fetchPosts`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Remember that because we used `ref` to define our page variable, we need to
    use the `.value` notation to access its value.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is time to create our `watch`. Just like `computed`, `watch` will depend
    on one or more other reactive values, like `Ref` and `Reactive`, and will include
    a callback value. The syntax is `watch( dependentData, callback(newValue, oldValue))`.
    So, in our case, the code would look like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`watch` is meant to observe variable changes and trigger a callback. In our
    example, the application observes the variable called `posts` and triggers a callback
    that will change the `page` variable and fetch new posts, using our API. The callback
    triggered by `watch` offers two values; the first is the new value that the observed
    variable has received, and the second is the old value.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, you will probably just use the first value (therefore, the
    new value of the observed data), but having access to both values is very useful
    when the effect triggered is dependent on the “change” of the variable. For example,
    this may be needed if you have an animation that shows different effects, depending
    on whether the value increases or decreases. This would only be possible if you
    have both the old and the new values to compare.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Our Companion App should now be ready to be tested. To test our new functionality,
    delete a couple of posts by clicking the delete icon next to them, and then see
    the new posts load dynamically.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: There are a few more options available with `watch`, such as the ability to
    trigger it after the effect has taken place in the DOM, or the possibility to
    trigger it immediately when the component renders. However, these are out of the
    scope of this book, as they are for more advanced use and would just be confusing
    at this stage.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Remember that using `watch` has a cost. In fact, there is a cost to be paid
    for an application observing a value, but there is an even greater performance
    cost in triggering a callback on every change of a value. For this reason, it
    is recommended to use `watch` only when needed and to ensure that the body of
    the callback is not too resource-intensive.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Use computed to minimize watch callbacks
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: If you are observing a variable that changes too often and want to try and improve
    on performance, you can use `computed` to create a new variable. This new computer
    property can then be watched instead. Because computed properties are cached,
    this approach is more performant.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: That completes our introduction to `watch`. This is a useful feature that, when
    used correctly, can help you create clean and readable components.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned what `watch` is and how using it improves our component,
    giving us a chance to trigger side effects from our application, such as an API
    request or DOM modification. We then made changes in the Companion App to better
    understand this topic. Finally, we explained the drawbacks of using `watch` and
    discussed when and how to use it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to introduce a built-in component called `<Suspense>`.
    This feature simplifies how we handle the loading state of asynchronous components.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Handling asynchronous components with <Suspense>
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling dynamic data loading is never easy. In fact, when data is static and
    hardcoded, displaying the information takes no effort, as the data is available
    on first render, but when the data needs to come from an outside source, such
    as a database or a third-party API, then the complexity increases. When loading
    information asynchronously, the data is not available on the first load, forcing
    us to handle a “loading state” until the data is available, or having to display
    an error state if the loading event has failed to complete.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: To prevent having to handle state changes in multiple components and code duplication,
    Vue.js introduced a globally available built-in component called `<Suspense>`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: With `<Suspense>`, we can orchestrate all loading states at once with very clean
    syntax. In the following section, we are going to first understand what makes
    a component asynchronous and then understand how this can be used to simplify
    our code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: An experimental feature
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, `<Suspense>` is still an experimental feature, and there
    is no set date on when and if it will become a core part of the Vue.js framework.
    The team is fixing a few bugs with it and more importantly, developing server-side
    support before it is turned into a full feature.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Understanding asynchronous components
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding introduction, we discussed an async component by using the
    example of a component that needs to load data dynamically, but that is not the
    actual definition of an async component.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: An async component is “*a component that requires an asynchronous function to
    be performed and completed before the rendering can* *be initialized*.”
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The important takeaway from the preceding definition is the words `async` operation
    and the need for it to be completed are requirements for a component to be defined
    as an asynchronous component.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: In fact, if we look at our current application, we can see that we already have
    dynamic data that is loaded in `SocialPosts.vue`, but this does not make it an
    async component, as the component is rendered immediately and does not wait for
    the `fetch` operation to be completed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: An asynchronous component is characterized by the presence of a top-level `<script
    setup>` code block.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: An asynchronous component affects the page rendering
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: An asynchronous component will stop the rendering itself and all of its children
    until the data is fully loaded. This should just be used if the component has
    no reason to render without the data being available.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at our Companion App and try to find a good candidate to turn into
    an async component. Currently, only two components have asynchronous operations
    between them, `SocialPosts.vue` and `SocialPostComments.vue`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the logic within the `SocialPostComments.vue`, we can see that
    the component does not currently function properly. The current component logic
    displays a message when the comments array is empty, `"<p>There are no comments
    for this post!</p>"`, but this message is also displayed when the component first
    renders. This is because the component renders immediately, even if the `fetch`
    request is still active.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: This is a very good candidate to be turned into an async component. In fact,
    this component has both an “async operation” and the “need for it to be completed,”
    as mentioned in the definition of an async component.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Turning a component into an asynchronous component
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vue.js provides a very simple way to define a component as an asynchronous component.
    In fact, all we need to do is ensure that the component includes one or more `await`
    functions within its body.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: When the Vue.js framework sees an await function, it automatically defines the
    component as async.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify `SocialPostComments.vue` to await the `fetch` method:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Our component logic required just two small changes to turn the component into
    a dynamic one. First, we made sure that our `fetchComments` method returned a
    promise by adding `return` before the `fetch` method. Then, we added `await` when
    calling the method. These two changes were all that was needed to ensure the component
    would turn into an async component.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'All that is left to do now is learn how to use asynchronous components. In
    fact, at this stage, the Companion App is unable to load comments, and clicking
    on the “Load comment” button would log the following error:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: An error message triggered by Vue.js when trying to incorrectly
    load an async component](img/B21130_07_06.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: An error message triggered by Vue.js when trying to incorrectly
    load an async component'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The error message mentions the need for the async component to be nested in
    `<Suspense>` in order to be rendered. Let’s learn what this `<Supense>` is and
    how it can be used to load async components.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Rendering async components
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we made the `SocialPostComments.vue` file asynchronous,
    and it is now time to learn how to handle this component to ensure that it is
    loaded correctly.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: As we previously mentioned, when a component is turned into an asynchronous
    one, it then requires us to handle its loading state. Loading this component normally,
    as we are currently doing in the application, would not work, as the component
    is not immediately available, so we need to find a way to handle its load gracefully.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: As always, the Vue.js core team has worked hard to provide us with all the tools
    we need to quickly accomplish complex operations.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'The component is defined on the official Vue.js documentation as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: “`<Suspense>` is a built-in component for orchestrating async dependencies in
    a component tree. It can render a loading state while waiting for multiple nested
    async dependencies down the component tree to be resolved.”
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping one or multiple components within `<Suspense>` prevents them from rendering
    until all the async operations are completed. Furthermore, `<Suspense>` also allows
    you to display a “loading” component while the async operations are completed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '`<Suspense>` is already preloaded in the application, and it does not need
    to be imported. Let’s open `SocialPost.vue` and change our code to correctly load
    our async component:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The use of this built-in component is very simple. In fact, all we need to do
    is wrap `SocialPostComments` within `<Suspense>`, as highlighted in the previous
    code block, and move the `v-if` directive, `v-if="showComments"`, from `SocialPostComments`
    to the built-in `Suspense` component. After these changes, `SocialPostComments`
    will simply render after the async operation within the component resolves.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: There are cases in which you may be required to display a loading indicator
    while the async operation completes. `<Suspense>` provides a named slot called
    **fallback** that can handle this. Let’s learn how to use this feature by adding
    a fallback message while the post comments load.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement a fallback message, our code would require the following modifications:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'To add a message while the comments are fetched, we use the `SocialPostComments`.
    This slot is going to be defined using the `<template #fallback>` syntax. The
    content of this slot will just be displayed while the async operation within `SocialPostComments`
    is run, and it will disappear as soon as the component is rendered.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Custom error handling
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, error handling is not handled by `<Suspense>`, and this needs
    to be handled manually using `onErrorCapture()` hooks. Explaining this is beyond
    the scope of this book.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now completed everything we had to learn about async data and component
    loading. We started the chapter by removing the hardcoded `posts` and replacing
    them with dummy data that is loaded dynamically. We then fixed the property mismatch
    caused by the data change, learning how to prevent this in the future by improving
    the use of property typing and validations.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Then, we learned how to change our data flow to load comments on demand and
    defined when this should be used, as well as the performance and user experience
    benefits that this brings. We then introduced another feature related to async
    operations, `watch`. We used this feature to trigger a side effect and automatically
    load more posts when the number of posts reaches a certain number.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we learned how to create and handle asynchronous components. We described
    what makes an async component and changed our Companion App to ensure our comments
    were fetched before loading the component. We concluded the chapter by introducing
    the `<Suspense>` built-in component, using it to correctly load our asynchronous
    component, and we also examined a fallback feature that shows text while the component
    loads.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, you should be able to fully handle asynchronous data loading,
    side effects, and components that require JavaScript promises to be fulfilled
    before being displayed.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to move our focus away from Vue.js and focus
    on testing our application. We will learn the basics of end-to-end testing with
    **Cypress** and unit testing with **Vitest**.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Expanding Your Knowledge with Vue.js and Its Core Libraries'
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this stage in our journey, it is time to introduce the external libraries
    that are part of the Vue.js ecosystem that are required to build production-ready
    applications.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B21130_08.xhtml#_idTextAnchor103)*, Testing Your App with Vitest
    and Cypress*'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B21130_09.xhtml#_idTextAnchor120)*, Introduction to Advanced
    Vue.js Techniques – Slots, Lifecycle, and* *Template Refs*'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B21130_10.xhtml#_idTextAnchor135)*, Handling Routing with* *Vue
    Router*'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B21130_11.xhtml#_idTextAnchor153)*, Managing Your Application’s
    State with Pinia*'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B21130_12.xhtml#_idTextAnchor163)*, Achieving Client-Side Validation
    with VeeValidate*'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
