- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Filtering and Searching Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll continue applying the techniques we’ve already learned
    to another, more complex use case.
  prefs: []
  type: TYPE_NORMAL
- en: As we work through the chapter, we’ll learn how to adjust a component’s design
    using tests to show us where the design is lacking. Test-driven development really
    helps highlight design issues when the tests get knarly. Luckily, the tests we’ve
    already written give us the confidence to change course and completely reinvent
    our design. With each change, we simply run `npm test` and have our new implementation
    verified in a matter of seconds.
  prefs: []
  type: TYPE_NORMAL
- en: In the current workflow, users start by adding a new customer and then immediately
    book an appointment for that customer. Now, we’ll expand on that by allowing them
    to choose an existing customer before adding an appointment.
  prefs: []
  type: TYPE_NORMAL
- en: We want users to be able to quickly search through customers. There could be
    hundreds, maybe thousands, of customers registered with this salon. So, we’ll
    build a `CustomerSearch` search component that will allow our users to search
    for customers by name and to page through the returned results.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying tabular data fetched from an endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paging through a large dataset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing actions with render props
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the new component will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – The new CustomerSearch component ](img/Figure_10.01_B18423.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – The new CustomerSearch component
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you’ll have built a relatively complex component
    using all the techniques you’ve learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter10)'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying tabular data fetched from an endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll get the basic form of the table in place, with an initial
    set of data retrieved from the server when the component is mounted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server `GET` requests to `/customers`. There is a `searchTerm` parameter
    that takes the string the user is searching for. There is also an `after` parameter
    that is used to retrieve the next page of results. The response is an array of
    customers, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Sending a request to `/customers` with no parameters will return the first 10
    of our customers, in alphabetical order by first name.
  prefs: []
  type: TYPE_NORMAL
- en: This gives us a good place to start. When the component mounts, we’ll perform
    this basic search and display the results in a table.
  prefs: []
  type: TYPE_NORMAL
- en: Skipping the starting point
  prefs: []
  type: TYPE_NORMAL
- en: If you’re following along using the GitHub repository, be aware that this chapter
    starts with a barebones `CustomerSearch` component already implemented, and it
    has already been hooked up to the `App` component. The component is displayed
    by clicking on the **Search appointments** button in the top menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with our first test for the new `CustomerSearch` component. Follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `test/CustomerSearch.test.js` and add the first test. It checks that a
    table has been rendered with the four headings that we want to see. The code is
    illustrated in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That test should be simple to pass with the following definition for `CustomerSearch`
    in `src/CustomerSearch.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to display data, the component will need to make a `GET` request.
    Write out this next test, which specifies that behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, add a `useEffect` hook to the component that performs the
    search. We need to use the same `useEffect` ceremony that we’ve seen before, using
    an inline function to ensure we don’t return a value and passing an empty array
    to the dependency list, which ensures the effect only runs when the component
    is first mounted. The code is illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, it’s time to code what happens depending on the data returned. We’ll start
    by figuring out the display of a single row of data. Add a definition of `oneCustomer`
    at the top of the file, above the `describe` block, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make use of that definition in the next test, shown in the following code snippet,
    which verifies that the component displays all the customer data for a single
    customer row:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this pass, we’ll need to use component state to pass data back from
    the `useEffect` hook into the next render cycle. Create a new state variable,
    `customers`, which has an initial value of the empty array (`[]`), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the results of the search into `customers` by modifying the definition
    of `useEffect`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’re ready to display the data. We’ll do that with a new `CustomerRow` component
    that is responsible for displaying a single row of customer information. Add its
    implementation above the definition of `CustomerSearch`. Notice here how the final
    column is blank; it will hold action buttons that perform various operations on
    the specific customer record. We’ll use a separate test later to fill out that
    functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All that’s left is to make use of this new component in `CustomerSearch`. Add
    the following `tbody` element, which renders `CustomerRow` for the first customer,
    if it exists. After adding this code, your test should now be passing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the final test in this section, let’s add a test to show that this works
    for multiple customers. For that, we need a new result set: `twoCustomers`. This
    can be placed at the top of the file, after `oneCustomer`, as shown in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add a test that makes use of this and checks that two rows are rendered,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Making this pass is a one-liner; change the JSX to map over each customer,
    instead of pulling out just the first customer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This gives us a great base to build on for the remaining functionality we’ll
    build in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll introduce the ability to move between multiple pages
    of search results.
  prefs: []
  type: TYPE_NORMAL
- en: Paging through a large dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, our endpoint returns 10 records. To get the next 10 records, we
    can page through the result set by using the `after` parameter, which represents
    the last customer identifier seen. The server will skip through results until
    it finds that ID and returns results from the next customer onward.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll add `after` parameter to the next search request.
  prefs: []
  type: TYPE_NORMAL
- en: To support `after` IDs that we can pop each time the user clicks **Previous**.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a button to move to the next page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with the `buttonWithLabel` helper that will match a button with
    that label. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `test/reactTestExtensions.js`, add the following new helper function at
    the bottom of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back in `test/CustomerSearch.test.js`, update the import statement to include
    this new helper function, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the following test, which will let us get a **Next** button onto the
    page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `SearchButtons` component that renders the `menu` element, just as
    we did in `App`. We’ll be expanding this menu bar with more buttons in subsequent
    tests. The code is illustrated here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, render that in `CustomerSearch`, above the table, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the button is clicked, we want to take the last customer ID already displayed
    and send that back to the server. To make that choice obvious in our tests, we’ll
    use a new return value named `tenCustomers`, which mimics the default number of
    records coming back from the server API. Place this definition of `tenCustomers`
    at the top of the file, next to your other customer definitions, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Making good use of Array.from
  prefs: []
  type: TYPE_NORMAL
- en: This definition uses a “clever” version of the `Array.from` function that takes
    each character of the string and creates an object using that character as input.
    We end up with 10 objects, each with an `id` property ranging from `0` to `9`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next test checks that when the `GET` request with the last seen customer
    ID. Given our previous definition of `tenCustomers`, that is the customer with
    ID `9`. Notice in the following code snippet how `toHaveBeenLastCalledWith` is
    needed since this will be the second call to `global.fetch`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Avoiding unnecessary fields to highlight important implications
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tenCustomers` value is only a partial definition for each customer: only
    the `id` property is included. That’s not lazy: it’s intentional. Because the
    logic of taking the last ID is non-obvious, it’s important to highlight the `id`
    property as the key feature of this flow. We won’t worry about the other fields
    because our previous tests check their correct usage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this pass, define a handler for the `fetch` request. It calculates
    the `after` request parameter by taking the last customer in the `customers` state
    variable, as illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Give `SearchButtons` a `handleNext` prop and set that as the `onClick` handler
    on the button, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Hook the handler up to `SearchButtons`, as follows. After this change, your
    test should be passing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Continue by adding the following test. It sets up two `fetch` responses using
    a sequence of `mockResolvedValueOnce` followed by `mockResolvedValue`. The second
    response only contains one record. The test asserts that this record is displayed
    after pressing the **Next** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this pass, modify `handleNext` to save its response into the `customers`
    state variable, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s it for our **Next** button. Before we move on to the **Previous** button,
    we need to correct a design issue.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look here at the similarities between the `handleNext` and `fetchData` functions.
    They are almost identical; the only place they differ is in the first parameter
    to the `fetch` call. The `handleNext` function has an `after` parameter; `fetchData`
    has no parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We will be adding a `useEffect` hook’s ability to rerun when the state changes.
  prefs: []
  type: TYPE_NORMAL
- en: We will introduce a new state variable, `queryString`, which `handleNext` will
    update and `useEffect` will listen for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do that now. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add that new variable now at the top of the `CustomerSearch` component, as
    shown in the following code snippet. Its initial value is the empty string, which
    is important:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace `handleNext` with the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `useEffect` with the following definition, appending `queryString` to
    the **Uniform Resource Locator** (**URL**). Your tests should still be passing
    at this point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That’s it for the **Next** button: you’ve seen how to write elegant tests for
    a complex piece of API orchestration logic, and we’ve refactored our production
    code to be elegant, too.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a button to move to the previous page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s move on to the **Previous** button:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write out the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make that pass by modifying `SearchButtons` to include the following button,
    just before the **Next** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next test mounts the component, clicks **Next**, and then clicks **Previous**.
    It expects another call to the endpoint to have been made, but this time identical
    to the initial page—in other words, with no query string. The code is illustrated
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this pass, start by defining a `handlePrevious` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify `SearchButtons` to take a new `handlePrevious` prop, and set that as
    the `onClick` handler on the new button, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Hook up the handler to `SearchButtons`, like so. After this, your test should
    be passing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next test is one that’ll require us to do some thinking. It simulates clicking
    `anotherTenCustomers` just after the definition of `tenCustomers`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the next test, which checks that the **Previous** button still works
    after navigating to two more pages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll make this pass by maintaining a record of the query strings that were
    passed to the endpoint. For this specific test, we only need to know what the
    *previous* query string was. Add a new state variable to record that, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Forcing design issues
  prefs: []
  type: TYPE_NORMAL
- en: 'You may recognize this as an overly complicated design. Let’s just go with
    it for now: we will simplify this again with another test.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change `handleNext` to save the previous query string, making sure that this
    happens before the call to `setQueryString`. Include `queryString` in the array
    passed to the second parameter of `useCallback` so that this callback is regenerated
    each time the value of `queryString` changes. The code is illustrated in the following
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, `handlePrevious` can use this value as the query string to pass to `fetchData`,
    as illustrated here. Your test should be passing at this point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s it for a basic **Previous** button implementation. However, what happens
    when we want to go back two or more pages? Our current design only has a “depth”
    of two additional pages. What if we want to support any number of pages?
  prefs: []
  type: TYPE_NORMAL
- en: Forcing design changes using tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use a test to force the design issue. The process of TDD helps us to
    ensure that we always take time to think about the simplest solution that solves
    all tests. So, if we add one more test that highlights the limits of the current
    design, that test becomes a trigger for us to stop, think, and reimplement.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we can use a stack of previous query strings to remember the history
    of pages. We’ll replace our two state variables, `queryString` and `previousQueryString`,
    with a single state variable, `queryStrings`, which is a stack of all previous
    query strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started with the test. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this test, which asserts that the **Previous** button works for multiple
    presses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For this to pass, start by adding a new `queryStrings` state variable, deleting
    `queryString` and `previousQueryStrings`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change `fetchData` as follows. If there are entries in the `queryStrings` array,
    it sets `queryString` to the last entry, and that value is then passed to the
    `fetch` call. If there’s nothing in the array, then `queryString` will be an empty
    string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change `handleNext` as follows. It now *appends* the current query string to
    the previous query strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change `handlePrevious` as follows. The last value is *popped off* the query
    string stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You now have a relatively complete implementation for the **Next** and **Previous**
    buttons. You’ve also seen how tests can help you alter your design as you encounter
    issues with it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll continue building out our integration with the `searchTerm` parameter
    of the `/customers` HTTP endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll add a textbox that the user can use to filter names.
    Each character that the user types into the search field will cause a new `fetch`
    request to be made to the server. That request will contain the new search term
    as provided by the search box.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `/customers` endpoint supports a parameter named `searchTerm` that filters
    search results using those terms, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s start by adding a text field into which the user can input a search term,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test to the `CustomerSearch` test suite, just below the last
    test. It simply checks for a new field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `CustomerSearch`, update your JSX to add that input element at the top of
    the component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we want to check that the `placeholder` attribute for that field is set.
    We can do this by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, add the placeholder to the input element in your JSX, like
    so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want to hook this up to the DOM change event: we’ll make an `async` fetch
    request every time the value changes. For that, we’ll need a new helper. In `test/reactTestExtensions.js`,
    add the following definition for `changeAndWait`, just below the definition of
    `change`. This allows us to run effects when the DOM change event occurs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the new helper at the top of `test/CustomerSearch.test.js`, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Each time a new character is entered into the search box, we should perform
    a new search with whatever text is entered in the textbox. Add the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a new `searchTerm` variable, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new handler, `handleSearchTextChanged`, as follows. It stores the search
    term in the state because we’ll need to pull it back when moving between pages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Hook it up to the input element, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can use the `searchTerm` variable in `fetchData` to fetch the updated
    set of customers from the server, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to modify `useEffect` by adding `searchTerm` to the dependency
    list, as follows. After this, the test should be passing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to ensure that hitting the **Next** button will maintain our search
    term. Right now, it won’t. We can use the following test to fix that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this pass, let’s force the behavior into `fetchData` with an addition
    to the `if` statement, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve made this test pass... but this is a mess! Any `if` statement with so
    many moving parts (variables, operators, conditions, and so on) is a signal that
    the design isn’t as good as it can be. Let’s fix it.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring to simplify the component design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The issue is the `queryString` data structure and its historical counterpart,
    the `queryStrings` state variable. The construction is complex.
  prefs: []
  type: TYPE_NORMAL
- en: How about we just store the *original data* instead—the ID of the customer in
    the last table row? Then, we can construct the `queryString` data structure immediately
    before fetching, since in reality, `queryString` is an input to the `fetch` request
    only. Keeping the raw data seems like it will be simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s plan out our refactor. At each of the following stages, our tests should
    still be passing, giving us confidence that we’re still on the right path:'
  prefs: []
  type: TYPE_NORMAL
- en: First, move the query string building logic from `handleNext` into `fetchData`,
    changing the values that are stored in `queryStrings` from query strings to customer
    IDs in the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, change the names of those variables, using your editor’s search and replace
    facility.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, simplify the logic in `fetchData`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Doesn’t sound so hard, does it? Let’s begin, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the component, replace the `queryStrings` variable with this
    new one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use your editor’s search and replace facility to change all occurrences of `queryStrings`
    to `lastRowIds`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Likewise, change the call to `setQueryStrings` to a call to `setLastRowIds`.
    Your tests should still be passing at this point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Delete the following line from `handleNext`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the line below that, change the call to `fetchData` to pass in `after` instead
    of the now deleted `newQueryString`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the same function, rename `after` `currentLastRowId`. Your tests should still
    be passing at this point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It’s time to simplify the logic within `fetchData`. Create a `searchParams`
    function that will generate the search parameters for us, given values for `after`
    and `searchTerm`. This can be defined outside of your component. The code is illustrated
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, update `fetchData` to use this new function in place of the existing
    query string logic, as shown here. At this point, your tests should be passing,
    with a vastly simpler and easier-to-understand implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You’ve now built a functional search component. You introduced a new helper,
    `changeAndWait`, and extracted out a `searchParams` function that could be reused
    in other places.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll add a final mechanism to the `CustomerSearch` component.
  prefs: []
  type: TYPE_NORMAL
- en: Performing actions with render props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each row of the table will hold a `AppointmentForm` component, creating an appointment
    for that customer.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll display these actions by using a `CustomerSearch`. The parent component—in
    our case, `App`—uses this to insert its own rendering logic into the child component.
    `App` will pass a function that displays a button that causes a view transition
    in `App` itself.
  prefs: []
  type: TYPE_NORMAL
- en: Render props are useful if the child component should be unaware of the context
    it’s operating in, such as the workflow that `App` provides.
  prefs: []
  type: TYPE_NORMAL
- en: Unnecessarily complex code alert!
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation you’re about to see could be considered more complex than
    it needs to be. There are other approaches to solving this problem: you could
    simply have `CustomerSearch` render `AppointmentFormLoader` directly, or you could
    allow `CustomerSearch` to render the button and then invoke a callback such as
    `onSelect(customer)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Render props are probably more useful to library authors than to any application
    authors since library components can’t account for the context they run within.
  prefs: []
  type: TYPE_NORMAL
- en: The testing techniques we need for render props are much more complex than anything
    we’ve seen so far, which you can take as another sign that there are “better”
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, we’ll add the `renderCustomerActions` prop to `CustomerSearch`
    and render it in a new table cell. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `test/CustomerSearch.test.js`, write the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set a default `renderCustomerActions` prop so that our existing tests won’t
    start failing when we begin using the new prop, as follows. This goes at the bottom
    of `src/CustomerSearch.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Destructure that prop in the top line of the `CustomerSearch` component, like
    so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pass it through to `CustomerRow`, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `CustomerRow`, update the fourth `td` cell to call this new prop, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the next test, we want to check that this render prop receives the specific
    customer record that applies to that row. Here’s how we can do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this pass, all you have to do is update the JSX call that you just
    wrote to include the customer as a parameter, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s all there is to invoking the render prop inside the `CustomerSearch`
    component. Where it gets difficult is test-driving the implementation of the render
    prop itself, in the `App` component.
  prefs: []
  type: TYPE_NORMAL
- en: Testing render props in additional render contexts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that the `App` component has a `view` state variable that determines
    which component the user is currently viewing on the screen. If they are searching
    for customers, then `view` will be set to `searchCustomers`.
  prefs: []
  type: TYPE_NORMAL
- en: Pressing the `CustomerSearch` component should have the effect of setting `view`
    to `addAppointment`, causing the user’s screen to hide the `CustomerSearch` component
    and show the `AppointmentForm` component.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to set the `App` component’s `customer` state variable to the customer
    that the user just selected in the `CustomerSearch` component.
  prefs: []
  type: TYPE_NORMAL
- en: All of this will be done in the render prop that `App` passes to `customer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The big question is: how do we test-drive the implementation of this render
    prop?'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few different ways we could do it:'
  prefs: []
  type: TYPE_NORMAL
- en: You could render an actual `CustomerSearch` component within your `App` components,
    navigate to a customer, and click the `App` tests have a module-level mock for
    `CustomerSearch`, you’d need to create a new test suite for those tests, which
    increases maintenance overhead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could modify the `CustomerSearch` mock to have some mechanism to trigger
    a render prop. This involves making the mock definition more complex than the
    standard form. That is an immediate red flag for me, for the reasons stated in
    [*Chapter 7*](B18423_07.xhtml#_idTextAnchor125), *Testing useEffect and Mocking
    Components*. This solution moves to the back of the pile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could pull out the render prop from your `CustomerSearch` component, render
    it, then find the **Create appointment** button and click it. This is the approach
    we’ll continue with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we use our `render` and `renderAndWait` functions to render this additional
    prop, it will replace the rendered `App` component. We would then click the button
    and we’d observe nothing happening because `App` has gone.
  prefs: []
  type: TYPE_NORMAL
- en: What we need is a second React root that can be used to just render that *additional*
    piece of the DOM. Our test can simply pretend that *it* is the `CustomerSearch`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need a new render component that we’ll call `renderAdditional`.
    Let’s add that now and then write our test, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `test/reactTestExtensions.js`, add the following function definition, just
    below the definition of `renderAndWait`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `test/App.test.js`, update the `import` statement to pull in this new extension,
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Locate the `search customers` nested `describe` block and add a `searchFor`
    helper function that calls the render prop for the supplied customer, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the test. This renders the prop and checks that a button has been
    rendered, as illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `src/App.js`, add the following function just above the returned JSX:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the prop on `CustomerSearch`, as follows. Your test should pass after this
    change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back in `test/CustomerSearch.test.js`, add the next test, as follows. This
    uses the same helper function, but this time clicks the button and verifies that
    `AppointmentFormLoader` was shown with the correct customer ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make that pass, update `searchActions` in `src/App.js` to use the customer
    parameter that will be passed to it by `CustomerSearch`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That’s all there is to it: you’ve now used `renderAdditional` to trigger your
    render props and check that it works as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: This technique can be very handy when working with third-party libraries that
    expect you to pass render props.
  prefs: []
  type: TYPE_NORMAL
- en: That completes this feature; go ahead and manually test if you’d like to see
    it all in action.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has explored building out a component with some complex user interactions
    between the user interface and an API. You’ve created a new table component and
    integrated it into the existing application workflow.
  prefs: []
  type: TYPE_NORMAL
- en: You have seen how to make large changes to your component’s implementation,
    using your tests as a safety mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: You have also seen how to test render props using an additional render root—a
    technique that I hope you don’t have to use too often!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll use tests to integrate React Router into our application.
    We’ll continue with the `CustomerSearch` component by adding the ability to use
    the browser location bar to specify search criteria. That will set us up nicely
    for introducing Redux and GraphQL later on.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Disable the **Previous** button if the user is on the first page and disable
    the **Next** button if the current listing has fewer than 10 records on display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the `searchParams` function into a separate module that handles any
    number of parameters and uses the `encodeURIComponent` JavaScript function to
    ensure the values are encoded correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `/customers` endpoint supports a `limit` parameter that allows you to specify
    the maximum number of records that are returned. Provide a mechanism for the user
    to change the limit on each page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
