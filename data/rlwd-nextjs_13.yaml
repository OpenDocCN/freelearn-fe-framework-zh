- en: '*Chapter 11*: Different Deployment Platforms'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：不同的部署平台'
- en: 'In the previous chapters, we saw how Next.js works, how to optimize it for
    SEO, how to deal with performance, how to adopt UI frameworks, and how to fetch
    data on both the client and server sides, eventually being able to create a fantastic
    web application. But then, we have a problem: how should we ship it to production?
    There are many different hosting providers, cloud platforms, and even **Platform
    as a Service** (**PaaS**) solutions out there; how do we pick one?'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了Next.js是如何工作的，如何为SEO优化它，如何处理性能，如何采用UI框架，以及如何在客户端和服务器端获取数据，最终能够创建一个出色的Web应用程序。但是，我们遇到了一个问题：我们应该如何将其部署到生产环境中？有许多不同的托管提供商、云平台，甚至**平台即服务**（**PaaS**）解决方案；我们应该如何选择？
- en: In this chapter, we will see how to choose the right deployment platform.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解如何选择正确的部署平台。
- en: 'We will look at the following in detail:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细探讨以下内容：
- en: How choosing the right deployment platform could affect performance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择正确的部署平台如何影响性能
- en: How to decide between different cloud solutions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在不同的云解决方案之间做出选择
- en: What are the most popular alternatives for hosting a Next.js app?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最受欢迎的Next.js应用程序托管替代方案有哪些？
- en: By the end of this chapter, you'll be able to deploy any Next.js application
    to any host, knowing how to choose the right provider from the most popular hosting
    solutions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够将任何Next.js应用程序部署到任何主机，并了解如何从最受欢迎的托管解决方案中选择正确的提供商。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run the code examples in this chapter, you need to have both Node.js and
    npm installed on your local machine.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码示例，您需要在您的本地机器上安装Node.js和npm。
- en: 'If you prefer, you can use an online IDE, such as [https://repl.it](https://repl.it)
    or [https://codesandbox.io](https://codesandbox.io); they both support Next.js,
    and you don''t need to install any dependency on your computer. As with the other
    chapters, you can find the code base for this chapter on GitHub: https://github.com/PacktPublishing/Real-World-Next.js.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，可以使用在线IDE，例如[https://repl.it](https://repl.it)或[https://codesandbox.io](https://codesandbox.io)；它们都支持Next.js，您不需要在您的电脑上安装任何依赖。与其他章节一样，您可以在GitHub上找到本章的代码库：https://github.com/PacktPublishing/Real-World-Next.js。
- en: A brief introduction to different deployment platforms
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同部署平台的简要介绍
- en: While thinking about a new web application, we have many things to consider.
    For example, how do we want to render its pages, which styling method do we want
    to adopt, where does data come from, how do we manage the application state, and
    where do we want to deploy the application itself?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在考虑一个新的Web应用程序时，有许多事情需要考虑。例如，我们希望如何渲染其页面，我们希望采用哪种样式方法，数据从哪里来，我们如何管理应用程序状态，以及我们希望将应用程序部署在哪里？
- en: 'Focusing on that last part, we could split one problem into two: *where* do
    we want to deploy our application and *how* do we want to do it?'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于最后一部分，我们可以将一个问题分为两个：我们希望在哪里部署我们的应用程序，以及我们希望如何进行部署？
- en: In fact, most of the time, choosing a deployment platform also means selecting
    a slightly different deployment method. There are specific cloud platforms, such
    as Vercel, Netlify, and Heroku, where the deployment process is standardized and
    incredibly simplified to be accessible for everyone. With other cloud providers,
    such as AWS, Azure, and DigitalOcean, you have complete control over the whole
    deployment process. Unfortunately, in many cases, you have to implement this process
    on your own or use third-party software.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，大多数时候，选择一个部署平台也意味着选择一种略微不同的部署方法。有一些特定的云平台，如Vercel、Netlify和Heroku，它们的部署过程是标准化的，并且极大地简化，以便让每个人都能使用。对于其他云提供商，如AWS、Azure和DigitalOcean，您对整个部署过程有完全的控制权。不幸的是，在许多情况下，您必须自己实现这个过程或使用第三方软件。
- en: The number of cloud infrastructures has drastically increased over the last
    few years, and the competition has brought some great innovation to this sector.
    Even though there are many alternatives, we will be focusing on the most popular
    ones, as we're more likely to find more documentation and support for them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，云基础设施的数量急剧增加，竞争也带来了这个领域的一些重大创新。尽管有许多替代方案，但我们将专注于最受欢迎的方案，因为我们更有可能找到更多关于它们的文档和支持。
- en: 'In the next section, we will discuss the most prominent platform to deploy
    a Next.js application to: *Vercel*.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论将Next.js应用程序部署到最突出的平台：*Vercel*。
- en: Deploying to the Vercel platform
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到Vercel平台
- en: '*Develop, preview, ship* is not just a motto. It''s the perfect description
    of the company that developed Next.js (alongside many other open source libraries)
    and an excellent cloud infrastructure for deploying and serving web applications.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*开发、预览、发布*不仅仅是一个口号。它完美地描述了开发Next.js（以及许多其他开源库）的公司，以及一个优秀的云基础设施，用于部署和托管Web应用程序。'
- en: With Vercel, you almost don't need to configure anything. You can deploy your
    web application from the command line using their CLI tool, or create an automatic
    deployment after a push to the main Git branch.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vercel，你几乎不需要进行任何配置。你可以通过他们的CLI工具从命令行部署你的Web应用程序，或者在你将代码推送到主Git分支后创建自动部署。
- en: One thing to know before getting started with Vercel is that the platform is
    built specifically for static sites and frontend frameworks. Unfortunately, that
    means that *custom Node.js servers are not supported*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用Vercel之前，有一件事需要知道的是，该平台是专门为静态网站和前端框架构建的。不幸的是，这意味着*不支持自定义Node.js服务器*。
- en: But at this point, you might be wondering whether only statically generated
    or client-side-rendered Next.js websites are supported. The short answer is *no*.
    In fact, Vercel supports server-side-rendered pages by serving them via *serverless
    functions*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这个时候，你可能想知道是否只支持静态生成或客户端渲染的Next.js网站。简短的回答是*不*。实际上，Vercel通过提供*无服务器函数*来支持服务器端渲染的页面。
- en: What Does "Serverless Function" Mean?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: “无服务器函数”是什么意思？
- en: 'When talking about "serverless functions," we refer to a single function (written
    in any programming language) that gets invoked on a managed infrastructure. In
    fact, it''s called "serverless" because we just have to write the function without
    really thinking about the server executing it. Unlike traditional servers, where
    we typically pay an hourly rate (for example, we could pay $1 for every hour,
    even when the server is not processing any data), serverless functions have a
    different pricing model: we pay them a fraction of a cent for each execution,
    depending on the execution duration, memory usage, and other similar metrics.
    For example, at the time of writing, AWS Lambda (the most popular serverless environment)
    costs *$0.20 for every million requests* and $0.0000000021 for every millisecond
    of duration (when allocated 128 MB of memory). As you can imagine, this pricing
    model can be really attractive compared to more traditional alternatives, as you
    only pay for what you actually use.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到“无服务器函数”时，我们指的是一个单独的函数（用任何编程语言编写），它在托管的基础设施上被调用。实际上，它被称为“无服务器”，因为我们只需要编写函数，而不必真正考虑执行它的服务器。与传统的服务器不同，我们通常按小时付费（例如，即使服务器没有处理任何数据，我们可能每小时支付1美元），无服务器函数有一个不同的定价模型：我们根据执行时间、内存使用和其他类似指标，为每次执行支付几分之一的美分。例如，在撰写本文时，AWS
    Lambda（最受欢迎的无服务器环境）每百万请求收费*0.20美元*，每毫秒收费*0.0000000021美元*（当分配128MB内存时）。正如你可以想象的那样，这种定价模型与更传统的替代方案相比非常有吸引力，因为你只需为实际使用的部分付费。
- en: Vercel does an incredible job of setting up serverless functions for us when
    deploying a Next.js application, so we don't have to worry about them; we just
    have to concentrate on the web application we're building.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Vercel在部署Next.js应用程序时为我们设置无服务器函数做得非常出色，所以我们不必担心它们；我们只需专注于我们正在构建的Web应用程序。
- en: 'Deploying an application to Vercel is pretty straightforward. We can proceed
    in two different ways:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序部署到Vercel相当直接。我们可以以两种不同的方式操作：
- en: '*By linking our GitHub, GitLab, or Bitbucket repository to Vercel*. Every time
    we create a pull request, Vercel will deploy a preview application to test the
    features we just developed before publishing them to production. Once we merge
    or push to our main branch, Vercel will automatically deploy the application to
    production.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过将我们的GitHub、GitLab或Bitbucket仓库链接到Vercel*。每次我们创建一个拉取请求时，Vercel都会部署一个预览应用程序来测试我们刚刚开发的功能，在它们发布到生产之前。一旦我们合并或推送到我们的主分支，Vercel将自动将应用程序部署到生产环境。'
- en: '*We can do everything manually from the command line*. For example, we can
    decide to create a preview application, preview it locally, or publish it to production
    directly from our terminal using the Vercel CLI tool, where typing `vercel --prod`
    is enough to promote the app to production.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我们可以从命令行手动完成所有操作*。例如，我们可以决定创建一个预览应用程序，在本地预览它，或者直接从我们的终端使用Vercel CLI工具将其发布到生产，只需输入`vercel
    --prod`就足以将应用程序提升到生产状态。'
- en: Either way, the developer experience is outstanding, so feel free to test both
    deployment strategies and find your favorite one.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，开发者的体验都是出色的，所以请随意测试这两种部署策略，找到您最喜欢的一种。
- en: Among all the possible alternatives for deploying and serving Next.js applications,
    Vercel is probably one of the easiest ones. Also, it allows you to gain access
    to the analytics module (do you remember we talked about it in [*Chapter 10*](B16985_10_Final_SB_epub.xhtml#_idTextAnchor102),
    *Working with SEO and Managing Performance?*), which can be incredibly useful
    to measure frontend performances over time. That will help us keep an eye on frontend
    optimization, which other platforms don't do (also, it's something fundamental!).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有可能的Next.js应用程序部署和托管替代方案中，Vercel可能是其中最容易的一个。此外，它还允许您访问分析模块（您还记得我们在[*第10章*](B16985_10_Final_SB_epub.xhtml#_idTextAnchor102)，*与SEO合作和管理性能？*）中提到的内容，这对于测量前端性能随时间的变化非常有用。这将帮助我们关注前端优化，而其他平台并不提供（这也是一项基本功能！）。
- en: If you're looking for something comparable to Vercel, a good alternative you
    may consider is Netlify. The whole deployment workflow is quite similar to Vercel's
    one, and the developer experience is just as phenomenal. However, I'd encourage
    you to consider the pricing model differences before deciding on either platform.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在寻找与Vercel相当的东西，您可以考虑的一个很好的替代方案是Netlify。整个部署工作流程与Vercel的非常相似，开发者的体验同样出色。然而，我鼓励您在决定选择哪个平台之前，考虑一下定价模型的不同。
- en: Both Vercel and Netlify also work incredibly well when deploying a static website.
    But there, the competition with other platforms will grow; we'll see some alternatives
    in the next section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Vercel和Netlify在部署静态网站时也表现出色。但在那里，与其他平台的竞争将会加剧；我们将在下一节中看到一些替代方案。
- en: Deploying a static site to a CDN
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将静态网站部署到CDN
- en: When talking about a **CDN** (short for **content delivery network**), we refer
    to a geographically distributed network of data centers used to achieve high availability
    and performance when serving content to users in any part of the world.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论**CDN**（即**内容分发网络**）时，我们指的是一个地理分布式的数据中心网络，用于在向世界任何地区的用户提供内容时实现高可用性和高性能。
- en: To keep it simple, let's give an example. I currently live near Milan, Italy,
    and I want my web application to be used in potentially any part of the world.
    So, where should I host it from a geographical point of view?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，让我们举一个例子。我目前住在意大利米兰附近，我希望我的Web应用程序能够在世界任何地方使用。那么，从地理角度来看，我应该在哪里托管它呢？
- en: Certain providers, such as Amazon AWS, DigitalOcean, and Microsoft Azure (and
    many more), will let you choose a specific data center to serve your application
    from. For example, I could select AWS *eu-south-1* (Milan, Italy), *ap-northeast-2*
    (Seoul, South Korea), or *sa-east-1* (São Paulo, Brazil). If I choose to serve
    my web application from Milan, Italian users will notice a very low latency when
    trying to reach the web application; it is geographically located very close to
    them. The same could happen for French, Swiss, and German users, but for people
    living in Asia, Africa, or the Americas, it will be the opposite. The further
    you are from the data center, the greater the latency, leading to lousy performance,
    poor client-to-server request latency, and so on. If we think of static assets,
    such as images, CSS, or JavaScript files, this will be even clearer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 某些提供商，如Amazon AWS、DigitalOcean和Microsoft Azure（以及许多其他提供商），允许您选择一个特定的数据中心来托管您的应用程序。例如，我可以选择AWS
    *eu-south-1*（意大利米兰），*ap-northeast-2*（韩国首尔），或*sa-east-1*（巴西圣保罗）。如果我选择从米兰托管我的Web应用程序，意大利用户在尝试访问Web应用程序时将注意到非常低的延迟；它在地理位置上非常接近他们。对于法国、瑞士和德国用户来说，情况可能相同，但对于生活在亚洲、非洲或美洲的人来说，情况则相反。您离数据中心越远，延迟就越大，导致性能不佳、客户端到服务器请求延迟较差，等等。如果我们考虑静态资源，如图像、CSS或JavaScript文件，这一点将更加明显。
- en: Heavy file size + data center distance = bad download performance. It's quite
    easy, isn't it?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 大文件大小 + 数据中心距离 = 下载性能差。这很简单，不是吗？
- en: CDNs solve this specific problem by providing a whole infrastructure distributed
    in (almost) every continent. Once you deploy your static asset to a CDN, it will
    be replicated across all the regions in the network, making it available closer
    to your users in any part of the world.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: CDN通过在（几乎）每个大陆上提供整个基础设施来解决这个特定问题。一旦您将静态资产部署到CDN，它将在网络的所有区域中复制，使得它在世界任何地方的用户的附近都可用。
- en: If you look at Next.js' statically generated websites, you will quickly notice
    that there is no need for a server to render the pages at request time. Instead,
    the website is entirely generated and statically rendered at build time, so we
    eventually end up with a collection of static HTML, CSS, and JavaScript files
    that can be deployed to a CDN.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看Next.js的静态生成网站，你会很快注意到在请求时间不需要服务器来渲染页面。相反，网站在构建时完全生成并静态渲染，所以我们最终会得到一组可以部署到CDN的静态HTML、CSS和JavaScript文件。
- en: If we're in that situation, then we're in luck. We're about to achieve the best
    possible performances by serving static HTML pages from a CDN. But which CDN should
    I choose? We'll find it out in the next section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处于那种情况，那么我们就很幸运了。我们即将通过从CDN提供静态HTML页面来实现最佳性能。但我应该选择哪个CDN呢？我们将在下一节中找到答案。
- en: Choosing a CDN
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择CDN
- en: When looking for a CDN to deploy our web application, we will find many different
    alternatives. Prominent players in this area are (but are not limited to) *Amazon
    AWS*, *Microsoft Azure CDN*, and *Cloudflare*. Of course, there are many other
    alternatives, but these are the ones I've tried and had great experiences with,
    so I feel confident recommending them to you.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在寻找CDN来部署我们的Web应用时，我们会发现许多不同的选择。该领域的知名玩家包括（但不限于）*Amazon AWS*、*Microsoft Azure
    CDN*和*Cloudflare*。当然，还有很多其他的选择，但这些是我尝试过并且有良好体验的，所以我自信地向你推荐它们。
- en: The CDN deployment adds some configuration steps, but spending a bit more time
    to achieve the best possible performance might be worth it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: CDN部署增加了几个配置步骤，但花点额外的时间以实现最佳性能可能值得。
- en: Talking about AWS, for instance, the procedure won't be as straightforward as
    the Vercel one. We would need to build a pipeline (with either GitHub Actions
    or GitLab Pipelines, and so on) to statically generate the web application, then
    to push it to **AWS S3** (a service used for storing static assets), and eventually
    use a **CloudFront** (AWS CDN) distribution to let users reach these static assets
    over HTTP requests. We would also need to link our CloudFront distribution to
    a domain name, and we can do that using **AWS Route 53** (an AWS proprietary DNS
    service).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以AWS为例，流程不会像Vercel那样直接。我们需要构建一个管道（使用GitHub Actions或GitLab Pipelines等），以静态生成Web应用，然后将其推送到**AWS
    S3**（一个用于存储静态资源的服务），最终使用**CloudFront**（AWS CDN）分发，让用户通过HTTP请求访问这些静态资源。我们还需要将我们的CloudFront分发链接到一个域名，我们可以使用**AWS
    Route 53**（一个AWS专有的DNS服务）来实现这一点。
- en: Cloudflare, in comparison, makes things a bit easier. It has a more straightforward
    UI, called Cloudflare Pages, that can help us link our project to a Git repository
    and automatically deploy a new website version every time we push new code to
    any branch. Of course, every time we push some code to the main branch, it will
    be published in production; if we want to preview some features living on feature
    branches, we can just push our code there and wait for Cloudflare to publish a
    preview deployment, just like Vercel does.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相比，Cloudflare使事情变得简单一些。它有一个更直观的UI，称为Cloudflare Pages，可以帮助我们将项目链接到Git仓库，并且每次我们向任何分支推送新代码时，都会自动部署一个新的网站版本。当然，每次我们将代码推送到主分支时，它都会在生产环境中发布；如果我们想预览位于功能分支上的某些功能，我们只需将代码推送到那里，然后等待Cloudflare发布预览部署，就像Vercel做的那样。
- en: Microsoft Azure provides another exciting approach. We can enter the Azure portal
    (the Azure administration dashboard), create a new resource, select "static web
    app" as the resource type, and enter the required data to configure it. After
    that, we can link our GitHub account, making automatic deployments available just
    like we did on Cloudflare and Vercel. Azure will create a GitHub workflow file
    for us so the build phase will run on GitHub and push the content to Azure as
    soon as it succeeds.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Azure提供了另一种令人兴奋的方法。我们可以进入Azure门户（Azure管理仪表板），创建一个新的资源，选择“静态Web应用”作为资源类型，并输入所需的数据来配置它。之后，我们可以链接我们的GitHub账户，就像我们在Cloudflare和Vercel上做的那样，实现自动部署。Azure会为我们创建一个GitHub工作流文件，这样构建阶段就会在GitHub上运行，一旦成功就会将内容推送到Azure。
- en: Now, you might be wondering how to choose the best CDN among the ones listed
    previously. Well, they're all excellent, but there's a way to determine which
    one best suits our needs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想知道如何从之前列出的CDN中选择最好的一个。好吧，它们都很优秀，但有一种方法可以确定哪个最适合我们的需求。
- en: AWS, for instance, might look like the most complicated one. But if we already
    have an AWS infrastructure, it would make things easier for us to set up a deployment
    there. The same applies to Microsoft Azure, where we might already have existing
    projects running on this platform, and we don't want to move just one web application
    outside of it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以 AWS 为例，可能看起来是最复杂的。但如果我们已经拥有 AWS 基础设施，那么在那里设置部署会更容易。同样适用于 Microsoft Azure，我们可能已经在该平台上运行了现有的项目，并且我们不希望将单个
    Web 应用程序移出该平台。
- en: Cloudflare, instead, can be the perfect solution for all static websites that
    don't need to rely on other services, except for serverless functions (Cloudflare
    offers a serverless function service called Cloudflare Workers) and other similar
    services that you can find at https://developers.cloudflare.com.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Cloudflare 可以是所有不需要依赖其他服务（除了无服务器函数（Cloudflare 提供名为 Cloudflare Workers 的无服务器函数服务）和其他类似服务，您可以在
    https://developers.cloudflare.com 找到这些服务）的静态网站的完美解决方案。
- en: Even though there are ways to execute serverless functions decoupled from the
    static website (by using AWS Lambda, Azure Functions, Cloudflare Workers, and
    so on), there are times when we need to create dozens or even hundreds of serverless
    functions. Organizing such deployments can be challenging, especially if we're
    working in a small team without support from someone who's really into DevOps.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有方法在不脱离静态网站的情况下执行无服务器函数（通过使用 AWS Lambda、Azure Functions、Cloudflare Workers
    等），但有时我们需要创建数十个甚至数百个无服务器函数。组织这样的部署可能具有挑战性，尤其是如果我们是在一个没有 DevOps 人员支持的小团队中工作。
- en: Other times, we just need server-side rendering alongside statically generated
    pages, and we need to deploy an application where we can use Node.js code at runtime.
    One interesting approach is to deploy the website in a completely serverless fashion.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们只需要服务器端渲染与静态生成的页面一起，并且需要在运行时使用 Node.js 代码的应用程序进行部署。一个有趣的方法是将网站完全以无服务器的方式部署。
- en: 'There is an open source project called **serverless-next.js** ([https://github.com/serverless-nextjs/serverless-next.js](https://github.com/serverless-nextjs/serverless-next.js))
    that can help us achieve that result. It works as a "*Serverless component*" (in
    that case, *Serverless* is the name of an npm library used to deploy code to any
    serverless platform) that will configure a deployment on AWS by adapting it to
    the following rules:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 **serverless-next.js** 的开源项目（[https://github.com/serverless-nextjs/serverless-next.js](https://github.com/serverless-nextjs/serverless-next.js)）可以帮助我们实现这一结果。它作为一个
    "*无服务器组件*"（在这种情况下，*无服务器* 是一个 npm 库的名称，用于将代码部署到任何无服务器平台）来配置 AWS 上的部署，通过适应以下规则：
- en: SSR pages and API routes will be deployed and served by AWS Lambda (serverless
    functions).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSR 页面和 API 路由将由 AWS Lambda（无服务器函数）部署和提供服务。
- en: Static pages, client assets, and public files will be deployed to S3 and automatically
    served by CloudFront.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态页面、客户端资源和公共文件将部署到 S3，并由 CloudFront 自动提供服务。
- en: This approach will lead to a kind of hybrid deployment where we always try to
    achieve the best possible performances of each type of request. SSR and API pages
    (which need a Node.js runtime) will be served by a serverless function, everything
    else from a CDN.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将导致一种混合部署，我们总是试图实现每种类型请求的最佳性能。SSR 和 API 页面（需要 Node.js 运行时）将由无服务器函数提供服务，其余的由
    CDN 提供。
- en: Don't worry if that sounds complex because it isn't. But if you feel like it
    would be an over-engineered part of your application life cycle (and you still
    need server-side rendering and API routes), you may want to consider other approaches.
    We will discuss how to deploy an SSR Next.js application to any platform correctly
    in the next section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心这听起来很复杂，因为它并不复杂。但如果您觉得这将是应用程序生命周期中过度工程化的部分（并且您仍然需要服务器端渲染和 API 路由），您可能希望考虑其他方法。我们将在下一节讨论如何正确地将
    SSR Next.js 应用程序部署到任何平台。
- en: Deploying Next.js on any server
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在任何服务器上部署 Next.js
- en: So far, we've seen some alternatives for deploying our Next.js application to
    CDNs and managed infrastructures, such as Vercel and Netlify. Still, there is
    another alternative that we haven't considered yet; what if we want to deploy
    our application to our private server?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了一些将我们的 Next.js 应用程序部署到 CDN 和托管基础设施的替代方案，例如 Vercel 和 Netlify。然而，还有一个我们尚未考虑的替代方案；如果我们想将我们的应用程序部署到我们的私有服务器上怎么办？
- en: Even though this is a common situation, it is also the most complex one by far.
    While platforms such as Vercel, Netlify, and Heroku manage the server for us,
    sometimes we may want to host our application on a private server where we have
    to control everything independently.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个常见的情况，但它也是迄今为止最复杂的情况。虽然平台如 Vercel、Netlify 和 Heroku 为我们管理服务器，但有时我们可能希望将我们的应用程序托管在私有服务器上，在那里我们必须独立控制一切。
- en: 'Let''s have a quick recap of what the previously mentioned managed platforms
    can do for us:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下之前提到的托管平台能为我们做什么：
- en: Automatic deployments
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动部署
- en: Rollback to previous deployments
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回滚到之前的部署
- en: Automatic deployments for feature branches
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性分支的自动部署
- en: Automatic server configuration (Node.js runtime, reverse proxy, and so on)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动服务器配置（Node.js 运行时、反向代理等）
- en: Built-in scaling capabilities
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置缩放功能
- en: By choosing a custom server, we have to implement all these features on our
    own. But is it worth it? Well, it depends. When working in a large company that
    already has a significant infrastructure up and running on a given cloud provider
    (be it Amazon AWS, Google Cloud, Microsoft Azure, and so on), it might make sense
    for us to identify the best solution for deploying our Next.js application in
    the same infrastructure.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择自定义服务器，我们必须自己实现所有这些功能。但这值得吗？嗯，这取决于。当在一个大型公司工作，该公司已经在特定的云服务提供商上运行着显著的基础设施（无论是亚马逊
    AWS、谷歌云、微软 Azure 等等）时，对于我们来说，在相同的基础设施中确定部署我们的 Next.js 应用程序的最佳解决方案可能是有意义的。
- en: If we're working on a side project or a small business website or starting a
    new web application from scratch, we could consider alternatives, such as managed
    platforms or CDNs, but we've already talked about that.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在进行一个副项目或小型商业网站，或者从头开始创建一个新的网络应用程序，我们可以考虑替代方案，如托管平台或 CDN，但我们已经讨论过这一点。
- en: Let's pretend for a moment that the choice has been made, and we have to deploy
    our application to either Amazon AWS, Google Cloud, or Microsoft Azure. How do
    we approach deployment and hosting from there?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时假设选择已经做出，我们必须将我们的应用程序部署到亚马逊 AWS、谷歌云或微软 Azure 之一。那么我们如何从那里开始部署和托管呢？
- en: 'The first thing to consider is how we want to serve our application. Starting
    with an empty server means that we have to manually set up a bunch of stuff to
    make it ready to serve a Node.js application. That includes (but is not limited
    to) the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要考虑的是我们希望如何提供我们的应用程序。从一个空服务器开始意味着我们必须手动设置一堆东西来使其准备好提供 Node.js 应用程序。这包括（但不限于）以下内容：
- en: '*The Node.js runtime*: Node.js is not pre-installed on every operating system,
    so we''ll need to install it to serve API and server-side-rendered pages.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Node.js 运行时*：Node.js 并非预安装在每一个操作系统上，因此我们需要安装它来提供 API 和服务器端渲染的页面。'
- en: '*A process manager*: If you have already worked with Node.js in the past, you
    may know that if the main process crashes, the entire application will stay down
    until we manually restart it. That is due to the Node.js single-threaded architecture,
    and it''s unlikely to change in the future, so we need to be prepared for this
    possibility. A popular approach to solving that problem is using a process manager
    such as PM2 ([https://github.com/Unitech/pm2](https://github.com/Unitech/pm2)),
    which monitors the Node.js processes and manages them to keep the application
    up and running. It also provides many other additional features for handling any
    Node.js program, so if you''re interested in that, I''d recommend you read the
    official documentation at [https://pm2.keymetrics.io](https://pm2.keymetrics.io).'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*进程管理器*：如果你以前已经使用过 Node.js，你可能知道如果主进程崩溃，整个应用程序将保持关闭状态，直到我们手动重新启动它。这是由于 Node.js
    的单线程架构，并且未来不太可能改变，因此我们需要为此可能性做好准备。解决该问题的流行方法之一是使用进程管理器，如 PM2 ([https://github.com/Unitech/pm2](https://github.com/Unitech/pm2))，它监控
    Node.js 进程并管理它们以保持应用程序运行。它还提供了许多其他附加功能来处理任何 Node.js 程序，所以如果你对此感兴趣，我建议你阅读官方文档在
    [https://pm2.keymetrics.io](https://pm2.keymetrics.io)。'
- en: '*A reverse proxy*: Even though we could easily set up any Node.js application
    to manage incoming HTTP requests, it is a best practice to put it behind a reverse
    proxy such as NGINX, Caddy, or Envoy. This adds an extra layer of security, other
    than valuable features we don''t want to compromise on, but also means we have
    to maintain a reverse proxy on our server.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*反向代理*：尽管我们可以轻松设置任何 Node.js 应用程序来管理传入的 HTTP 请求，但将它们放在 NGINX、Caddy 或 Envoy 等反向代理之后是一种最佳实践。这除了增加了额外的安全层之外，还意味着我们必须在我们的服务器上维护一个反向代理。'
- en: '*Setting up firewall rules*: We need to open the firewall to accept incoming
    HTTP requests to the `:443` and `:80` ports.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置防火墙规则*：我们需要打开防火墙以接受对 `:443` 和 `:80` 端口的入站 HTTP 请求。'
- en: '*Setting up an efficient deployment pipeline*: We could use Jenkins, CircleCI,
    or even GitHub Actions. But this is another thing to take care of.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置高效的部署管道*：我们可以使用 Jenkins、CircleCI，甚至 GitHub Actions。但这又是另一件需要注意的事情。'
- en: 'Once we''re done setting up the whole environment, we should also consider
    that we may need to replicate that same environment on another server as soon
    as we need to scale our infrastructure to accept more and more incoming requests.
    It might be pretty easy to replicate it on a new server, but what if we need to
    scale on dozens of new machines? And what if we need to upgrade the Node.js runtime
    or the reverse proxy on all of them? Things are getting more complicated and time-consuming,
    so we may want to look for an alternative approach, and that''s what we''re going
    to talk about in the next section: how to deploy our Next.js application to any
    server by using Docker.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了整个环境的设置，我们也应该考虑，当我们需要扩展我们的基础设施以接受越来越多的入站请求时，我们可能需要尽快在另一台服务器上复制相同的设置。在新的服务器上复制它可能相当容易，但如果我们需要在数十台新机器上进行扩展怎么办？如果我们需要升级所有机器上的
    Node.js 运行时或反向代理怎么办？事情变得越来越复杂和耗时，所以我们可能想要寻找另一种方法，这就是我们将在下一节中讨论的内容：如何通过 Docker
    将我们的 Next.js 应用程序部署到任何服务器。
- en: Running Next.js in a Docker container
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Docker 容器中运行 Next.js
- en: Docker, and virtualization in general, has changed forever the way we build
    and deploy our applications. It provides a set of useful utilities, commands,
    and configurations to make our build reproducible on any server, making our application
    available on almost every operating system by creating a virtual machine running
    our program (or web application).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Docker，以及一般意义上的虚拟化，已经永远改变了我们构建和部署应用程序的方式。它提供了一套有用的实用工具、命令和配置，使我们的构建在任何服务器上都具有可重复性，通过创建运行我们程序（或网络应用程序）的虚拟机，使我们的应用程序几乎可以在任何操作系统上运行。
- en: In Case You Are New to Docker
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始接触 Docker
- en: Docker is an important tool to consider when building and deploying any computer
    program (a web application, database, or anything else). If you're new to this
    technology, I highly recommend reading the official Docker documentation at [https://www.docker.com](https://www.docker.com)
    before starting to use it. If you're interested in a hands-on approach to learning
    Docker, I'd also recommend you read *Mastering Docker – Fourth Edition* by Russ
    McKendrick ([https://www.packtpub.com/product/mastering-docker-fourth-edition/9781839216572](https://www.packtpub.com/product/mastering-docker-fourth-edition/9781839216572));
    it provides a complete guide to getting started and understanding Docker.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是构建和部署任何计算机程序（网络应用程序、数据库或其他任何东西）时需要考虑的重要工具。如果你对这个技术还不太熟悉，我强烈建议你在开始使用它之前阅读官方的
    Docker 文档[https://www.docker.com](https://www.docker.com)。如果你对通过实践学习 Docker 感兴趣，我也建议你阅读
    Russ McKendrick 的《Mastering Docker – 第四版》([https://www.packtpub.com/product/mastering-docker-fourth-edition/9781839216572](https://www.packtpub.com/product/mastering-docker-fourth-edition/9781839216572))；它提供了完整的入门和了解
    Docker 的指南。
- en: 'Running Next.js in Docker is relatively straightforward. A very basic Dockerfile
    is composed of the following commands:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 中运行 Next.js 相对直接。一个非常基本的 Dockerfile 包含以下命令：
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It''s almost effortless, isn''t it? Let''s break it down into small steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎不费吹灰之力，不是吗？让我们将其分解成小步骤：
- en: First, declare which image we want to run our server in. In this case, we're
    choosing `node:14-alpine`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，声明我们想要在哪个镜像中运行我们的服务器。在这种情况下，我们选择 `node:14-alpine`。
- en: It is a best practice to create a new working directory, so as a first step,
    create it and name it `/app`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的工作目录是一个最佳实践，因此作为第一步，创建它并命名为 `/app`。
- en: Choose `/app` as our working directory.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `/app` 作为我们的工作目录。
- en: Copy all the content of our local directory into the Docker working directory.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们本地目录的所有内容复制到 Docker 的工作目录中。
- en: Install all the required dependencies.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装所有必需的依赖项。
- en: Build Next.js inside the container's working directory.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器的工作目录内构建 Next.js。
- en: Expose port `3000` to be reached from outside the container.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将端口 `3000` 暴露给容器外部。
- en: Run the start script for booting the Next.js built-in server.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行启动脚本以启动 Next.js 内置服务器。
- en: 'We can test the previous Dockerfile by creating a new, empty Next.js app running
    the following command in a new directory:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个新的、空的 Next.js 应用程序并在新目录中运行以下命令来测试之前的 Dockerfile：
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s create a Dockerfile with the content we just discussed. We should also
    create a `.dockerignore` file containing `node_modules` and the Next.js output
    directory so that we won''t be copying them into the container:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含我们刚刚讨论内容的Dockerfile。我们还应该创建一个包含`node_modules`和Next.js输出目录的`.dockerignore`文件，这样我们就不会将它们复制到容器中：
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can now proceed by building the Docker container:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续构建Docker容器：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We're tagging it with a custom name, in this case, `my-first-dockerized-nextjs-app`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个自定义名称标记它，在这个例子中，是`my-first-dockerized-nextjs-app`。
- en: 'Once the build succeeds, we can run the container as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建成功，我们可以按照以下方式运行容器：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are finally able to reach our web application at http://localhost:3000!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终能够通过http://localhost:3000访问我们的Web应用！
- en: Starting from that simple configuration, we will be able to deploy our application
    to any managed container service (such as AWS ECS or Google Cloud Run), any Kubernetes
    cluster, or any machine with Docker installed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个简单的配置开始，我们将能够将我们的应用部署到任何托管容器服务（如AWS ECS或Google Cloud Run）、任何Kubernetes集群或任何安装了Docker的机器。
- en: Using containers in production has many benefits, as we only need a very simple
    configuration file for setting up the virtualization of a Linux machine to run
    our application in. Whenever we need to duplicate, scale, or reproduce our build,
    we can simply do that by sharing the Dockerfile and executing it, making the whole
    process incredibly straightforward, scalable, and easy to maintain.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中使用容器有许多好处，因为我们只需要一个非常简单的配置文件来设置Linux机器的虚拟化，以便运行我们的应用。无论何时我们需要复制、扩展或重新生成我们的构建，我们都可以通过共享Dockerfile并执行它来简单地做到这一点，使整个过程变得极其简单、可扩展且易于维护。
- en: That said, do we always need Docker? Let's discuss this in the summary for this
    chapter, right in the next section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们是否总是需要Docker？让我们在下一节的总结中讨论这个问题。
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've seen different deployment platforms for our Next.js application.
    There's no perfect solution for building and deploying Next.js apps, as it depends
    on the specific use case and challenges that every project brings.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了Next.js应用的多种部署平台。在构建和部署Next.js应用方面，没有完美的解决方案，因为它取决于每个项目带来的特定用例和挑战。
- en: Vercel, Netlify, and Heroku (just to quote some) are all excellent alternatives
    for quickly deploying a Next.js application to production. On the other hand,
    Cloudflare Pages, AWS S3 and AWS CloudFront, and Microsoft Azure CDN can really
    provide excellent performance for our static sites, which competes with all the
    other great solutions we've seen in this chapter when it comes to serving a statically
    generated website.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Vercel、Netlify和Heroku（仅举几个例子）都是快速将Next.js应用部署到生产的优秀替代方案。另一方面，Cloudflare Pages、AWS
    S3和AWS CloudFront以及Microsoft Azure CDN确实可以为我们的静态网站提供出色的性能，在提供静态生成网站方面，与我们在本章中看到的所有其他优秀解决方案竞争。
- en: Docker is probably one of the most flexible solutions. It allows us to deploy
    our application everywhere, making it easy to replicate the production environment
    on every machine.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Docker可能是最灵活的解决方案之一。它允许我们在任何地方部署我们的应用，使得在每台机器上复制生产环境变得容易。
- en: Again, there's no "perfect" solution for deploying a Next.js application, as
    the competition in this field is extremely strong, and many companies provide
    excellent solutions to simplify our lives as developers and make our browsing
    experience always better as users.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，对于部署Next.js应用来说，并没有一个“完美”的解决方案，因为这个领域的竞争非常激烈，许多公司提供了优秀的解决方案来简化我们的开发生活，并使用户的浏览体验始终如一地更好。
- en: 'The best suggestion I can give when deciding where to deploy a Next.js application
    is to consider the following aspect: how big is the team I''m working in? While
    solutions such as Vercel, Netlify, Heroku, and Cloudflare are well suited for
    both little and big teams, there are other providers where the required knowledge,
    skillset, and capacity are way higher. Setting up an AWS EC2 instance or a custom
    machine on DigitalOcean or Google Cloud gives us much more control over the whole
    application life cycle, but the cost (in terms of configuration, setup, and required
    time) is considerable.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定在哪里部署Next.js应用时，我能给出的最好建议是考虑以下方面：我所在的团队有多大？虽然Vercel、Netlify、Heroku和Cloudflare等解决方案非常适合小型和大型团队，但还有其他提供者，所需的知识、技能集和容量要高得多。在AWS
    EC2实例或DigitalOcean或Google Cloud上的自定义机器上设置，给我们提供了对整个应用生命周期的更多控制，但成本（在配置、设置和所需时间方面）是相当可观的。
- en: On the other hand, when working in big companies where there's a dedicated DevOps
    team that can take care of the release process for the application, they might
    prefer to adopt custom solutions where they have more and more control.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当在大公司工作，那里有一个专门的DevOps团队可以负责应用程序的发布流程时，他们可能会更倾向于采用自定义解决方案，这样他们就有越来越多的控制权。
- en: But even if we're working alone, we can choose to deploy our applications to
    a custom cloud infrastructure. If we're doing that, we should make sure we're
    not unintentionally reinventing the wheel by recreating infrastructures that Vercel,
    Netlify, Cloudflare, and so on can provide even on a free plan.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在单独工作，我们也可以选择将我们的应用程序部署到自定义云基础设施。如果我们这么做，我们应该确保我们没有无意中重新发明轮子，即重新创建Vercel、Netlify、Cloudflare等甚至免费计划就能提供的基础设施。
- en: We've made some significant progress so far. We learned the basics of the framework
    and how to integrate it with different libraries and data sources, and now we
    also know how to choose a deployment platform for any need.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止已经取得了一些显著的进步。我们学习了框架的基础知识以及如何将其与不同的库和数据源集成，现在我们也知道了如何为任何需求选择部署平台。
- en: Starting from the next chapter, we will build some real-world applications that
    will allow us to understand the real-world challenges we will face when creating
    production-ready web applications in Next.js.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一章开始，我们将构建一些实际的应用程序，这将使我们能够理解在Next.js中创建生产就绪的Web应用程序时我们将面临的现实世界挑战。
