- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing Authentication and Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing a high-quality authentication and authorization system without frustrating
    the end user is a difficult problem to solve. Authentication is the act of verifying
    the identity of a user, and authorization specifies the privileges that a user
    must have to access a resource. Both processes, auth for short, must seamlessly
    work in tandem to address the needs of users with varying roles, needs, and job
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: On today's web, users have a high baseline level of expectations from any auth
    system they encounter through the browser, so this is an important part of your
    application to get absolutely right the first time. The user should always be
    aware of what they can and can't do in your application. If there are errors,
    failures, or mistakes, the user should be clearly informed about why they occurred.
    As your application grows, it will be easy to miss all the ways that an error
    condition could be triggered. Your implementation should be easy to extend or
    maintain, otherwise this basic backbone of your application will require a lot
    of maintenance. In this chapter, we will walk through the various challenges of
    creating a great auth UX and implement a solid baseline experience.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue the router-first approach to designing SPAs by implementing
    the auth experience of LemonMart. In *Chapter 7*, *Creating a Router-First Line-of-Business
    App*, we defined user roles, finished our build-out of all major routing, and
    completed a rough walking-skeleton navigation experience of LemonMart. This means
    that we are well prepared to implement a role-based conditional navigation experience
    that captures the nuances of a seamless auth experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will implement a token-based auth scheme around the User
    entity that we defined in the last chapter. For a robust and maintainable implementation,
    we will deep dive into **object-oriented programming** (**OOP**) with abstraction,
    inheritance, and factories, along with implementing a cache service, a UI service,
    and two different auth schemes: an in-memory fake auth service for educational
    purposes and a Google Firebase auth service that you can leverage in real-world
    applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing an auth workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript operators for safe data handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusable services leveraging OOP concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic UI components and navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role-based routing using guards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firebase authentication recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a service using a factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the linked repository that follows. The repository contains the final and completed
    state of the code. You can verify your progress at the end of this chapter by
    looking for the end-of-chapter snapshot of code under the `projects` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'For *Chapter 8*:'
  prefs: []
  type: TYPE_NORMAL
- en: Clone the repository [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart
    )
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm install` on the root folder to install dependencies
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code sample for this chapter is under the sub-folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To run the Angular application for this chapter, execute
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To run the Angular unit tests for this chapter, execute
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To run Angular e2e tests for this chapter, execute
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To build a production-ready Angular application for this chapter, execute
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `dist/ch8` folder at the root of the repository will contain the
    compiled result.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that the source code in the book or on GitHub may not always match
    the code generated by Angular CLI. There may also be slight differences in implementation
    between the code in the book and what's on GitHub because the ecosystem is ever-evolving.
    It is natural for the sample code to change over time. Also, on GitHub, expect
    to find corrections, fixes to support newer versions of libraries, or side-by-side
    implementations of multiple techniques for you to observe. You are only expected
    to implement the ideal solution recommended in the book. If you find errors or
    have questions, please create an issue or submit a pull request on GitHub for
    the benefit of all readers.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with going over how a token-based auth workflow functions.
  prefs: []
  type: TYPE_NORMAL
- en: Designing an auth workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A well-designed authentication workflow is stateless so that there's no concept
    of an expiring session. Users are free to interact with your stateless REST APIs
    from as many devices and tabs as they wish, simultaneously or over time. **JSON
    Web Token** (**JWT**) implements distributed claims-based authentication that
    can be digitally signed or integration that is protected and/or encrypted using
    a **Message Authentication Code** (**MAC**). This means that once a user's identity
    is authenticated (that is, a password challenge on a login form), they receive
    an encoded claim ticket or a token, which can then be used to make future requests
    to the system without having to reauthenticate the identity of the user.
  prefs: []
  type: TYPE_NORMAL
- en: The server can independently verify the validity of this claim and process the
    requests without requiring any prior knowledge of having interacted with this
    user. Thus, we don't have to store session information regarding a user, making
    our solution stateless and easy to scale. Each token will expire after a predefined
    period and due to their distributed nature, they can't be remotely or individually
    revoked; however, we can bolster real-time security by interjecting custom account
    and user role status checks to ensure that the authenticated user is authorized
    to access server-side resources.
  prefs: []
  type: TYPE_NORMAL
- en: JWTs implement the **Internet Engineering Task Force** (**IETF**) industry standard
    RFC 7519, found at [https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519).
  prefs: []
  type: TYPE_NORMAL
- en: A good authorization workflow enables conditional navigation based on a user's
    role so that users are automatically taken to the optimal landing screen; they
    are not shown routes or elements that are not suitable for their roles and if,
    by mistake, they try to access a restricted path, they are prevented from doing
    so. You must remember that any client-side role-based navigation is merely a convenience
    and is not meant for security. This means that every call made to the server should
    contain the necessary header information, with the secure token, so that the user
    can be reauthenticated by the server and their role independently verified. Only
    then will they be allowed to retrieve secured data. Client-side authentication
    can't be trusted, which is why password reset screens must be built with a server-side
    rendering technology so that both the user and the server can verify that the
    intended user is interacting with the system.
  prefs: []
  type: TYPE_NORMAL
- en: JWT life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JWTs complement a stateless REST API architecture with an encrypted token mechanism
    that allows convenient, distributed, and high-performance authentication and authorization
    of requests sent by clients. There are three main components of a token-based
    authentication scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-side**: Captures login information and hides disallowed actions for
    a good UX'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server-side**: Validates that every request is both authenticated and has
    the proper authorization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auth service**: Generates and validates encrypted tokens, and independently
    verifies the auth status of user requests from a data store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A secure system presumes that data sent/received between clients (applications
    and browsers), systems (servers and services), and databases is encrypted using
    **transport layer security** (**TLS**), which is essentially a newer version of
    **secure sockets layer** (**SSL**). This means that your REST API must be hosted
    with a properly configured SSL certificate, serving all API calls over HTTPS,
    so that user credentials are never exposed between the client and the server.
    Similarly, any database or third-party service call should happen over TLS. This
    ensures the security of the data in transit.
  prefs: []
  type: TYPE_NORMAL
- en: At-rest (when the data is sitting in the database) passwords should be stored
    using a secure one-way hashing algorithm with good salting practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Did all the talk of hashing and salting make you think of breakfast? Unfortunately,
    they''re cryptography-related terms. If you''re interested in learning more, check
    out this article: [https://crackstation.net/hashing-security.htm](https://crackstation.net/hashing-security.htm).'
  prefs: []
  type: TYPE_NORMAL
- en: Sensitive user information, such as **personally identifiable information**
    (**PII**), should be encrypted at rest with a secure two-way encryption algorithm,
    unlike passwords. Passwords are hashed, so we verify that the user is providing
    the same password without the system knowing what the password is. With PII, we
    must be able to decrypt the data so that we can display it to the user. But since
    the data is encrypted at rest, if the database is compromised then the hacked
    data is worthless.
  prefs: []
  type: TYPE_NORMAL
- en: Following a layered approach to security is critical, because attackers will
    need to accomplish the unlikely feat of compromising all layers of your security
    at the same time to cause meaningful harm to your business.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fun fact**: When you hear about massive data breaches from major corporations,
    most of the time the root cause is a lack of proper implementation of in-transit
    or at-rest security. Sometimes this is because it is too computationally expensive
    to continually encrypt/decrypt data, so engineers rely on being behind firewalls.
    In that case, once the outer perimeter is breached, as they say, the fox has access
    to the hen house.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following sequence diagram, which highlights the life cycle of
    JWT-based authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_08_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: The life cycle of JWT-based authentication'
  prefs: []
  type: TYPE_NORMAL
- en: Initially, a user logs in by providing their username and password. Once validated,
    the user's authentication status and role are encrypted in a JWT with an expiration
    date and time, and it is sent back to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Our Angular (or any other) application can cache this token in local or session
    storage securely so that the user isn't forced to log in with every request. This
    way, we don't resort to insecure practices like storing user credentials in cookies
    to provide a good UX.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will get a better understanding of the JWT life cycle when you implement
    your own auth service later in this chapter. In the following sections, we will
    design a fully featured auth workflow around the **User** data entity, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_08_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: The User entity'
  prefs: []
  type: TYPE_NORMAL
- en: The User entity described is slightly different to our initial entity model.
    The entity model reflects how data is stored in the database. The entity is a
    flattened (or simplified) representation of the user record. Even a flattened
    entity has complex objects, like **name**, which has properties for first, middle,
    and last. Furthermore, not all properties are required. Additionally, when interacting
    with auth systems and other APIs, we may receive incomplete, incorrect, or maliciously
    formed data, so our code will have to effectively deal with `null` and `undefined`
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's see how we can leverage TypeScript operators to effectively deal
    with unexpected data.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript operators for safe data handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is a dynamically typed language. At runtime, the JavaScript engine
    executing our code, like Chrome's V8, doesn't know the type of the variable we're
    using. As a result, the engine must infer the type. We can have basic types like
    `boolean`, `number`, `array`, or `string`, or we can have a complex type, which
    is essentially a JSON object. In addition, variables can be `null` or `undefined`.
    In broad terms, `undefined` represents something that hasn't been initialized
    and `null` represents something that isn't currently available.
  prefs: []
  type: TYPE_NORMAL
- en: In strongly typed languages, the concept of `undefined` doesn't exist. Basic
    types have default values, like a `number` is a zero or a `string` is an empty
    string. However, complex types can be `null`. A `null` reference means that the
    variable is defined, but there's no value behind it.
  prefs: []
  type: TYPE_NORMAL
- en: The inventor of the `null` reference, Tony Hoare, called it his "billion-dollar
    mistake."
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript brings the concepts of strongly typed languages to JavaScript, so
    it must bridge the gap between the two worlds. As a result, TypeScript defines
    types like `null`, `undefined`, `any`, and `never` to make sense of JavaScript's
    type semantics. I've added links to relevant TypeScript documentation in the *Further
    reading* section for a deeper dive into TypeScript types.
  prefs: []
  type: TYPE_NORMAL
- en: As the TypeScript documentation puts it, TypeScript treats `null` and `undefined`
    differently in order to match the JavaScript semantics. For example, the union
    type `string | null` is a different type than `string | undefined` and `string
    | undefined | null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s another nuance: checking to see whether a value equals `null` using
    `==` versus `===`. Using the double equals operator, checking that `foo != null`
    means that `foo` is defined and not `null`. However, using the triple equals operator,
    `foo !== null` means that `foo` is not `null`, but could be `undefined`. However,
    these two operators don''t consider the truthiness of the variable, which includes
    the case of an empty string.'
  prefs: []
  type: TYPE_NORMAL
- en: These subtle differences have a great impact on how you write code, especially
    when using the strict TypeScript rules that are applied when you create your Angular
    application using the `--strict` option. It is important to remember that TypeScript
    is a development time tool and not a runtime tool. At runtime, we're still dealing
    with the realities of a dynamically typed language. Just because we declared a
    type to be a string, it doesn't mean that we will receive a string.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's see how we can deal with issues related to working with unexpected
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Null and undefined checking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with other libraries or dealing with information sent or received
    outside of your application, you must deal with the fact that the variable you
    receive might be `null` or `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: Outside of your application means dealing with user input, reading from a cookie
    or `localStorage`, URL parameters from the router, or an API call over HTTP, to
    name a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our code, we mostly care about the truthiness of a variable. This means
    that a variable is defined, not null, and if it''s a basic type, it has a non-default
    value. Given a `string`, we can check whether the `string` is truthy with a simple
    `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If `foo` is `null`, `undefined`, or an empty string, the variable will be evaluated
    as `falsy`. For certain situations, you may want to use the conditional or ternary
    operator instead of `if-else`.
  prefs: []
  type: TYPE_NORMAL
- en: The conditional or ternary operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The conditional or ternary operator has the `?:` syntax. On the left-hand side
    of the question mark, the operator takes a conditional statement. On the right-hand
    side, we provide the outcomes for true and false around the colon: `conditional
    ? true-outcome : false-outcome`. The conditional or ternary operator is a compact
    way to represent `if-else` conditions, and can be very useful for increasing the
    readability of your code base. This operator is not a replacement for an `if-else`
    block, but it is great when you''re using the output of the `if-else` condition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `if-else` block can be re-written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the conditional or ternary operator makes the code more compact
    and easier to understand at a glance. Another common scenario is returning a default
    value, where the variable is `falsy`.
  prefs: []
  type: TYPE_NORMAL
- en: We will consider the null coalescing operator next.
  prefs: []
  type: TYPE_NORMAL
- en: The null coalescing operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The null coalescing operator is `||`. This operator saves us from repetition,
    when the truthy result of the conditional is the same as the conditional itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the example where if `foo` is defined, we would like to use the value
    of `foo`, but if it is `undefined`, we need a default value of `''bar''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `foo` is repeated twice. We can avoid the duplication by using
    the null coalescing operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So, if `foo` is `undefined`, `null` or an empty string, `bar` will be output.
    Otherwise, the value of `foo` will be used. But in some cases, we need to only
    use the default value if the value is `undefined` or `null`. We will consider
    the nullish coalescing operator next.
  prefs: []
  type: TYPE_NORMAL
- en: The nullish coalescing operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The nullish coalescing operator is `??`. This operator is like the null coalescing
    operator, with one crucial difference. Checking the truthiness of a variable is
    not enough when dealing with data received from an API or user input, where an
    empty string may be a valid value. As we covered earlier in this section, checking
    for `null` and `undefined` is not as straightforward as it seems. But we know
    that by using the double equals operator, we can ensure that `foo` is defined
    and not null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding case, if `foo` is an empty string or another value, we will
    get the value of `foo` output. If it is `null` or `undefined`, we will get `''bar''`.
    A more compact way to do this is by using the nullish coalescing operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will yield the same result as the previous example. However,
    when dealing with complex objects, we need to consider whether their properties
    are `null` or `undefined` as well. For this, we will consider the optional chaining
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: Optional chaining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The optional chaining operator is `?`. It is like Angular's safe navigation
    operator, which was covered in *Chapter 3*, *Creating a Basic Angular App*. Optional
    chaining ensures that a variable or property is defined and not `null` before
    attempting to access a child property or invoke a function. So the statement `foo?.bar?.callMe()`
    executes without throwing an error, even if `foo` or `bar` is `null` or `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the **User** entity, which has a `name` object with properties for
    `first`, `middle`, and `last`. Let''s see what it would take to safely provide
    a default value of an empty string for a middle name using the nullish coalescing
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we need to check whether a parent object is truthy before accessing
    a child property. If `middle` is `null`, an empty string is output. Optional chaining
    makes this task simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using optional chaining and the nullish coalescing operator together, we can
    eliminate repetition and deliver robust code that can effectively deal with the
    realities of JavaScript's dynamic runtime.
  prefs: []
  type: TYPE_NORMAL
- en: So, when designing your code, you have to make decisions on whether to introduce
    the concept of null to your logic or work with default values like empty strings.
    In the next section, as we implement the User entity, you will see how these choices
    play out. So far, we have only used interfaces to define the shape of our data.
    Next, let's build the User entity, leveraging OOP concepts like classes, enums,
    and abstraction to implement it, along with an auth service.
  prefs: []
  type: TYPE_NORMAL
- en: Reusable services leveraging OOP concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned, we have only worked with interfaces to represent data. We still
    want to continue using interfaces when passing data around various components
    and services. Interfaces are great for describing the kind of properties or functions
    an implementation has, but they suggest nothing about the behavior of these properties
    or functions.
  prefs: []
  type: TYPE_NORMAL
- en: With ES2015 (ES6), JavaScript gained native support for classes, which is a
    crucial concept of the OOP paradigm. Classes are actual implementations of behavior.
    As opposed to just having a collection of functions in a file, a class can properly
    encapsulate behavior. A class can then be instantiated as an object using the
    new keyword.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript takes the ES2015 (and beyond) implementation of classes and introduces
    necessary concepts like abstract classes, private, protected, and public properties,
    and interfaces to make it possible to implement OOP patterns.
  prefs: []
  type: TYPE_NORMAL
- en: OOP is an imperative programming style, compared to the reactive programming
    style that RxJS enables. Classes form the bedrock of OOP, whereas observables
    do the same for reactive programming using RxJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'I encourage you to become familiar with OOP terminology. Please see the *Further
    reading* section for some useful resources. You should become familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes versus objects
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Composition (interfaces)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encapsulation (private, protected, and public properties, and property getters
    and setters)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Polymorphism (inheritance, abstract classes, and method overriding)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you know, Angular uses OOP patterns to implement components and services.
    For example, interfaces are used to implement life cycle hooks such as `OnInit`.
    Let's see how these patterns are implemented within the context of JavaScript
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, I will demonstrate how you can use classes in your own code
    design to define and encapsulate the behavior of your models, such as the `User`
    class. Later in this chapter, you will see examples of class inheritance with
    abstract base classes, which allows us to standardize our implementation and reuse
    base functionality in a clean and easy-to-maintain manner.
  prefs: []
  type: TYPE_NORMAL
- en: I must point out that OOP has very useful patterns that can increase the quality
    of your code; however, if you overuse it then you will start losing the benefits
    of the dynamic, flexible, and functional nature of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes all you need are a bunch of functions in a file, and you'll see examples
    of that throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: A great way to demonstrate the value of classes would be to standardize the
    creation of a default `User` object. We need this because a `BehaviorSubject`
    object needs to be initialized with a default object. It is best to do this in
    one place, rather than copy-paste the same implementation in multiple places.
    It makes a lot of sense for the `User` object to own this functionality instead
    of an Angular service creating default `User` objects. So, let's implement a `User`
    class to achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by defining our interfaces and enums:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define user roles as an `enum` at the location `src/app/auth/auth.enum.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a `user.ts` file under the `src/app/user/user` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a new interface named `IUser` in the `user.ts` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that every complex property that is defined on the interface can also be
    represented as a `string`. In transit, all objects are converted to strings using
    `JSON.stringify()`. No type information is included. We also leverage interfaces
    to represent `Class` objects in-memory, which can have complex types. So, our
    interface properties must reflect both cases using union types. For example, `role`
    can either be of type `Role` or `string`. Similarly, `dateOfBirth` can be a `Date`
    or a `string`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We define `address` as an inline type, because we don't use the concept of an
    address outside of this class. In contrast, we define `IName` as its own interface,
    because in *Chapter 11*, *Recipes – Reusability, Routing, and Caching*, we will
    implement a separate component for names. We also define a separate interface
    for phones, because they are represented as an array. When developing a form,
    we need to be able to address individual array elements, like `IPhone`, in the
    template code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is the norm to insert a capital `I` in front of interface names so they are
    easy to identify. Don't worry, there are no compatibility issues with using the
    `IPhone` interface on Android phones!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `user.ts`, define the `IName` and `IPhone` interfaces, and implement the
    `PhoneType` enum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that in the `PhoneType` enum, we explicitly defined `string` values. By
    default, `enum` values are converted into strings as they're typed, which can
    lead to issues with values stored in a database falling out of sync with how a
    developer chooses to spell a variable name. With explicit and all lowercase values,
    we reduce the risk of bugs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, define the `User` class, which implements the `IUser` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that by defining all properties with default values in the constructors
    as `public` properties, we hit two birds with one stone; otherwise, we would need
    to define properties and initialize them separately. This way, we achieve a concise
    implementation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using a static `Build` function, we can quickly hydrate the object with data
    received from the server. We can also implement the `toJSON()` function to customize
    the serialization behavior of our object before sending the data up to the server.
    But before that, let's add a calculated property.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can use calculated properties in templates or in toast messages to conveniently
    display values assembled from multiple parts. A great example is extracting a
    full name from the `name` object as a property in the `User` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A calculated property for assembling a full name encapsulates the logic for
    combining a first, middle, and last name, so you don't have to rewrite this logic
    in multiple places, adhering to the DRY principle!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement a `fullName` property getter in the `User` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `fullName` `IUser` as `readonly` and an optional property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can now use the `fullName` property through the `IUser` interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the `toJSON` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that when serializing the object, we delete the `_id` and `fullName` fields.
    These are values that we don't want to be stored in the database. The `fullName`
    field is a calculated property, so it doesn't need to be stored. The `_id` is
    normally passed as a parameter in a `GET` or a `PUT` call to locate the record.
    This avoids mistakes that may result in overwriting the `id` fields of existing
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the `User data` entity implemented, next let's implement the
    auth service.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction and inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We aim to design a flexible auth service that can implement multiple auth providers.
    In this chapter, we will implement an in-memory provider and a Google Firebase
    provider. In *Chapter 10*, *RESTful APIs and Full-Stack Implementation*, we will
    implement a custom provider to interact with our backend.
  prefs: []
  type: TYPE_NORMAL
- en: By declaring an abstract base class, we can describe the common login and logout
    behavior of our application, so when we implement another auth provider, we don't
    have to re-engineer our application.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we can declare abstract functions, which the implementors of our
    base class would have to implement, enforcing our design. Any class that implements
    the base class would also get the benefit of the code implemented in the base
    class, so we wouldn't need to repeat the same logic in two different places.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class diagram reflects the architecture and inheritance hierarchy
    of our abstract `AuthService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_08_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: The AuthService inheritance structure'
  prefs: []
  type: TYPE_NORMAL
- en: '`AuthService` implements the interface `IAuthService`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The interface reflects the public properties that the service exposes. The service
    provides the authentication status as the `authStatus$` observable and the current
    user as `currentUser$`, and it provides three functions to `login`, `logout`,
    and `getToken`.
  prefs: []
  type: TYPE_NORMAL
- en: '`AuthService` inherits caching functionality from another abstract class called
    `CacheService`. Since `AuthService` is an abstract class, it can''t be used on
    its own, so we implement three auth providers, `InMemoryAuthService`, `FirebaseAuthService`,
    and `CustomAuthService`, as seen at the bottom of the diagram.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that all three auth services implement all abstract functions. In addition,
    the `FirebaseAuthService` overrides the base `logout` function to implement its
    own behavior. All three classes inherit from the same abstract class and expose
    the same public interface. All three will execute the same auth workflow against
    different auth servers.
  prefs: []
  type: TYPE_NORMAL
- en: The in-memory auth service doesn't communicate with a server. The service is
    for demonstration purposes only. It implements fake JWT encoding, so we can demonstrate
    how the JWT life cycle works.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating the auth service.
  prefs: []
  type: TYPE_NORMAL
- en: Create the auth service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will start by creating the abstract auth service and the in-memory service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an auth service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Rename `in-memory-auth.service.ts` to `auth.inmemory.service.ts` so the different
    auth providers visually group together in File Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the config object `{ providedIn: ''root'' }` from the `@Injectable()`
    decorator of `auth.service.ts` and `auth.inmemory.service.ts`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that `authService` is provided in `app.module.ts`, but the `InMemoryAuthService`
    is actually used and not the abstract class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating a separate folder for the service organizes various components related
    to auth, such as the `enum` definition for the user role. Additionally, we will
    be able to add an `authService` fake to the same folder for automated testing.
  prefs: []
  type: TYPE_NORMAL
- en: Implement an abstract auth service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, let's build an abstract auth service that will orchestrate logins and logouts,
    while encapsulating the logic of how to manage JWTs, auth status, and information
    regarding the current user. By leveraging the abstract class, we should be able
    to implement our own auth service against any auth provider without modifying
    the internal behavior of our application.
  prefs: []
  type: TYPE_NORMAL
- en: The abstract auth service that is being demonstrated enables rich and intricate
    workflows. It is a solution that you can drop into your applications without modifying
    the internal logic. As a result, it is a complicated solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'This auth service will enable us to demonstrate logging in with an email and
    password, caching, and conditional navigation concepts based on authentication
    status and a user''s role:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by installing a JWT decoding library, and, for faking authentication,
    a JWT encoding library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement an `IAuthStatus` interface to store decoded user information, a helper
    interface, and the secure by default `defaultAuthStatus`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`IAuthStatus` is an interface that represents the shape of a typical JWT that
    you may receive from your authentication service. It contains minimal information
    about the user and the user''s role. The auth status object can be attached to
    the header of every REST call to APIs to verify the user''s identity. The auth
    status can be optionally cached in `localStorage` to remember the user''s login
    state; otherwise, they would have to re-enter their password with every page refresh.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the preceding implementation, we're assuming the default role of `None`,
    as defined in the `Role` enum. By not giving any role to the user by default,
    we're following a least-privileged access model. The user's correct role will
    be set after they log in successfully with the information received from the auth
    API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the `IAuthService` interface in `auth.service.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make `AuthService` an `abstract` class, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the interface, `IAuthService`, using VS Code''s quick fix functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `authStatus$` and `currentUser$` properties as `readonly` and initialize
    our data anchors with their default values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we removed the type definitions of the properties. Instead, we're
    letting TypeScript infer the type from the initialization.
  prefs: []
  type: TYPE_NORMAL
- en: You must always declare your data anchors as `readonly`, so you don't accidentally
    overwrite the data stream by re-initializing a data anchor as a new `BehaviorSubject`.
    Doing so would render any prior subscribers orphaned, leading to memory leaks,
    and have many unintended consequences.
  prefs: []
  type: TYPE_NORMAL
- en: All implementors of `IAuthService` need to be able to log the user in, transform
    the token we get back from the server so we can read it and store it, support
    access to the current user, and the auth status, and provide a way to log the
    user out. We have successfully put in the functions for our public methods and
    implemented default values for our data anchors to create hooks for the rest of
    our application to use. But so far, we have only defined what our service can
    do, and not how it can do it.
  prefs: []
  type: TYPE_NORMAL
- en: As always, the devil is in the details, and the hard part is the "how." Abstract
    functions can help us to complete the implementation of a workflow in a service
    within our application, while leaving the portions of the service that must implement
    external APIs undefined.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Auth services that implement the abstract class should be able to support any
    kind of auth provider, and any kind of token transformation, while being able
    to modify behaviors like user retrieval logic. We must be able to implement login,
    logout, token, and auth status management without implementing calls to specific
    services.
  prefs: []
  type: TYPE_NORMAL
- en: By defining abstract functions, we can declare a series of methods that must
    implement a given set of inputs and outputs—a signature without an implementation.
    We can then use these abstract functions to orchestrate the implementation of
    our auth workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Our design goal here is driven by the Open/Closed principle. The `AuthService`
    will be open to extension through its ability to be extended to work with any
    kind of token-based auth provider, but closed to modification. Once we're done
    implementing the `AuthService`, we won't need to modify its code to add additional
    auth providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to define the abstract functions that our auth providers must implement,
    as shown in *Figure 8.3* from earlier in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`authProvider(email, password)`: `Observable<IServerAuthResponse>` can log
    us in via a provider and return a standardized `IServerAuthResponse`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transformJwtToken(token)`: `IAuthStatus` can normalize the token a provider
    returns to the interface of `IAuthStatus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getCurrentUser()`: `Observable<User>` can retrieve the user profile of the logged-in
    user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can then use these functions in our `login`, `logout`, and `getToken` methods
    to implement the auth workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the abstract methods that the derived classes should implement as protected
    properties, so they''re accessible in the derived class, but not publicly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Leveraging these stubbed out methods, we can now implement a `login` method
    that performs a login and retrieves the currently logged-in user, making sure
    to update the `authStatus$` and `currentUser$` data streams.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before we move on, implement a `transformError` function to handle errors of
    different types like `HttpErrorResponse` and `string`, providing them in an observable
    stream. In a new file named `common.ts` under `src/app/common` create the `transformError`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `auth.service.ts`, implement the `login` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `login` method encapsulates the correct order of operations by calling the
    `authProvider` with the `email` and `password` information, then decoding the
    received JWT, transforming it, and updating `authStatus$`. Then `getCurrentUser()`
    is called only if `status.isAuthenticated` is `true`. Later, `currentUser$` is
    updated and, finally, we catch any errors using our custom `transformError` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We activate the observable stream by calling `subscribe` on it. In the case
    of an error, we call `logout()` to maintain the correct status of our application
    and bubble up errors to consumers of `login` by re-throwing the error using `throwError`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, the corresponding `logout` function needs to be implemented. Logout is
    triggered by the **Logout** button from the application toolbar in the case of
    a failed login attempt, as shown earlier, or if an unauthorized access attempt
    is detected. We can detect unauthorized access attempts by using a router auth
    guard as the user is navigating the application, which is a topic covered later
    in the chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the `logout` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We log out by pushing out the `defaultAuthStatus` as the next value in the `authStatus$`
    stream. Note the use of `setTimeout`, which allows us to avoid timing issues when
    core elements of the application are all changing statuses at once.
  prefs: []
  type: TYPE_NORMAL
- en: Think about how the `login` method adheres to the Open/Closed principle. The
    method is open to extension through the abstract functions `authProvider`, `transformJwtToken`,
    and `getCurrentUser`. By implementing these functions in a derived class, we maintain
    the ability to externally supply different auth providers without having to modify
    the `login` method. As a result, the implementation of the method remains closed
    to modification, thus adhering to the Open/Closed principle.
  prefs: []
  type: TYPE_NORMAL
- en: The true value of creating abstract classes is the ability to encapsulate common
    functionality in an extensible way.
  prefs: []
  type: TYPE_NORMAL
- en: You may ignore the `getToken` function for now, as we are not yet caching our
    JWT. Without caching, the user would have to log in with every page refresh. Let's
    implement caching next.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract caching service using localStorage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We must be able to cache the authentication status of the logged-in user. As
    mentioned, otherwise, with every page refresh, the user will have to go through
    the login routine. We need to update `AuthService` so that it persists the auth
    status.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main ways to store data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cookie`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localStorage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sessionStorage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cookies should not be used to store secure data because they can be sniffed
    or stolen by bad actors. In addition, cookies can store only 4 KB of data and
    can be set to expire.
  prefs: []
  type: TYPE_NORMAL
- en: '`localStorage` and `sessionStorage` are similar to each other. They are protected
    and isolated browser-side stores that allow the storage of larger amounts of data
    for your application. Unlike cookies, you can''t set an expiration date-time on
    values stored in either store. Values stored in either store survive page reloads
    and restores, making them better candidates than cookies for caching information.'
  prefs: []
  type: TYPE_NORMAL
- en: The major difference between `localStorage` and `sessionStorage` is that the
    values are removed when the browser window is closed. In most cases, user logins
    are cached anywhere from minutes to a month or more depending on your business,
    so relying on whether the user closes the browser window isn't very useful. Through this
    process of elimination, I prefer `localStorage` because of the isolation it provides
    and long-term storage capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: JWTs can be encrypted and include a timestamp for expiration. In theory, this
    counters the weaknesses of both cookies and `localStorage`. If implemented correctly,
    either option should be secure for use with JWTs, but `localStorage` is still
    preferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by implementing a caching service that can abstract away our method
    of caching. We can then derive from this service to cache our authentication information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating an abstract `cacheService` that encapsulates the method of caching:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This cache service base class can be used to give caching capabilities to any
    service. It is not the same as creating a centralized cache service that you inject
    into another service. By avoiding a centralized value store, we avoid interdependencies
    between various services.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update `AuthService` to extend the `CacheService`, which will enable us to
    implement caching of the JWT in the next section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we must call the constructor of the base class from the derived class's
    constructor using the `super` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go over an example of how to use the base class''s functionality by
    caching the value of the `authStatus` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The technique demonstrated in the example leverages RxJS observable streams
    to update the cache whenever the value of `authStatus$` changes. You can use this
    pattern to persist any kind of data without having to litter your business logic
    with caching code. In this case, we wouldn't need to update the `login` function
    to call `setItem`, because it already calls `this.authStatus.next`, and we can
    just tap into the data stream. This helps with staying stateless and avoiding
    side effects by decoupling functions from each other.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we also initialize the `BehaviorSubject` using the `getItem` function.
    Using the nullish coalescing operator, we only use cached data if it is not `undefined`
    or `null`. Otherwise, we provide the default value.
  prefs: []
  type: TYPE_NORMAL
- en: You can implement your own custom cache expiration scheme in the `setItem` and
    `getItem` functions, or leverage a service created by a third party.
  prefs: []
  type: TYPE_NORMAL
- en: However, for an additional layer of security, we won't cache the `authStatus`
    object. Instead, we will only cache the encoded JWT, which contains just enough
    information, so we can authenticate requests sent to the server. It is important
    to understand how token-based authentication works to avoid revealing compromising
    secrets. Review the JWT life cycle from earlier in this chapter to improve your
    understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's cache the token.
  prefs: []
  type: TYPE_NORMAL
- en: Caching the JWT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's update the authentication service so that it can cache the token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `AuthService` to be able to set, get, and clear the token, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call `clearToken` and `setToken` during `login`, and `clearToken` during `logout`,
    as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Every subsequent request will contain the JWT in the request header. You should
    secure every API to check for and validate the token received. For example, if
    a user wants to access their profile, the `AuthService` will validate the token
    to check whether the user is authenticated or not; however, a further database
    call will still be required to check whether the user is also authorized to view
    the data. This ensures an independent confirmation of the user's access to the
    system and prevents any abuse of an unexpired token.
  prefs: []
  type: TYPE_NORMAL
- en: If an authenticated user makes a call to an API where they don't have the proper
    authorization, say if a clerk wants to get access to a list of all users, then
    the `AuthService` will return a `falsy` status, and the client will receive a
    **403 Forbidden** response, which will be displayed as an error message to the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: A user can make a request with an expired token; when this happens, a **401
    Unauthorized** response is sent to the client. As a good UX practice, we should
    automatically prompt the user to log in again and let them resume their workflow
    without any data loss.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, true security is achieved with robust server-side implementation.
    Any client-side implementation is largely there to enable a good UX around good
    security practices.
  prefs: []
  type: TYPE_NORMAL
- en: Implement an in-memory auth service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s implement a concrete version of the auth service that we can actually
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by installing a JWT decoding library and, for faking authentication,
    a JWT encoding library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Extend the abstract `AuthService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement a fake `authProvider` function that simulates the authentication
    process, including creating a fake JWT on the fly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `authProvider` implements what would otherwise be a server-side method right
    in the service, so we can conveniently experiment with the code while fine-tuning
    our auth workflow. The provider creates and signs a JWT with the temporary `fake-jwt-sign`
    library so that I can also demonstrate how to handle a properly formed JWT.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Do not ship your Angular application with the `fake-jwt-sign` dependency, since
    it is meant to be server-side code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In contrast, a real auth provider would include a `POST` call to a server.
    See the example code that follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is pretty straightforward, since the hard work is done on the server side.
    This call can also be made to a third-party auth provider, which I cover in the
    Firebase authentication recipe later in this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the API version, `v1`, in the URL path is defined at the service and
    not as part of the `baseUrl`. This is because each API can change versions independently.
    Login may remain `v1` for a long time, while other APIs may be upgraded to `v2`,
    `v3`, and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implementing `transformJwtToken` will be trivial, because the login function
    provides us with a token that adheres to `IAuthStatus`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, implement `getCurrentUser`, which should return some default user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, provide a `defaultUser` as a private property to the class; what follows
    is one that I've created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a private `defaultUser` property to the `InMemoryAuthService` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Congratulations, you've implemented a concrete, but still fake, auth service.
    Now that you have the in-memory auth service in place, be sure to run your Angular
    application and ensure that there are no errors.
  prefs: []
  type: TYPE_NORMAL
- en: Let's test our auth service by implementing a simple login and logout functionality
    accessible through the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Simple login
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we implement a fully-featured `login` component, let's wire up pre-baked
    login behavior to the **Login as manager** button we have in the `HomeComponent`.
    We can test the behavior of our auth service before getting into the details of
    delivering a rich UI component.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to simulate logging in as a manager. To accomplish this, we need
    to hard code an e mail address and a password to log in, and upon successful login,
    maintain the functionality of navigating to the `/manager` route.
  prefs: []
  type: TYPE_NORMAL
- en: Note that on GitHub the code sample for this section resides in a file named
    `home.component.simple.ts` under the folder structure of `projects/ch8`. The alternate
    file exists for reference purposes only, since the code from this section dramatically
    changes later in the chapter. Ignore the file name difference, as it will not
    impact your coding for this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement a simple login mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `HomeComponent`, implement a `login` function that uses the `AuthService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the template to remove the `routerLink` and instead call the `login`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On successful login, we need to navigate to the `/manager` route. We can verify
    that we're successfully logged in by listening to the `authStatus$` and `currentUser$`
    observables exposed by the `AuthService`. If `authStatus$.isAuthenticated` is
    `true` and `currentUser$._id` is a non-empty string, that means that we have a
    valid login. We can listen to both observables by using RxJS's `combineLatest`
    operator. Given a valid login condition, we can then use the `filter` operator
    to reactively navigate to the `/manager` route.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `login()` function to implement the login conditional and upon success,
    navigate to the `/manager` route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we subscribe to the `combineLatest` operator at the end, which is
    critical in activating the observable streams. Otherwise, our login action will
    remain dormant unless some other component subscribes to the stream. You only
    need to activate a stream once.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now test out the new `login` functionality. Verify that the JWT is created and
    stored in `localStorage` using the **Chrome DevTools| Application** tab, as shown
    here:![](img/B14094_08_04.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.4: DevTools showing Application Local Storage'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can view **Local Storage** under the **Application** tab. Make sure that
    the URL of your application is highlighted. In step 3, you can see that we have
    a key named `jwt` with a valid-looking token.
  prefs: []
  type: TYPE_NORMAL
- en: Note steps 4 and 5 highlighting two warnings, which advise us not to use the
    `InMemoryAuthService` and the `fake-jwt-sign` package in production code.
  prefs: []
  type: TYPE_NORMAL
- en: Use breakpoints to debug and step through the code to get a more concrete understanding
    of how `HomeComponent`, `InMemoryAuthService`, and `AuthService` work together
    to log the user in.
  prefs: []
  type: TYPE_NORMAL
- en: When you refresh the page, note that you're still logged in, because we're caching
    the token in local storage.
  prefs: []
  type: TYPE_NORMAL
- en: Since we're caching the login status, we also need to implement a logout experience
    to complete the auth workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Logout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The logout button on the application toolbar is already wired up to navigate
    to the `logout` component we created before. Let''s update this component so it
    can log the user out when navigated to:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `logout` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we are explicitly clearing the JWT by passing in `true` to the `logout`
    function. After we call `logout`, we navigate the user back to the home page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Test out the `logout` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that local storage is cleared after logout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have nailed a solid login and logout implementation. However, we're not yet
    done with the fundamentals of our auth workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to consider the expiration status of our JWT.
  prefs: []
  type: TYPE_NORMAL
- en: Resuming a JWT session
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It wouldn't be a great UX if you had to log in to Gmail or Amazon every single
    time you visited the site. This is why we cache the JWT, but it would be an equally
    bad UX to keep you logged in forever. A JWT has an expiration date policy, where
    the provider can select a number of minutes or even months to allow your token
    to be valid for depending on security needs. The in-memory service creates tokens
    that expire in one hour, so if a user refreshes their browser window within that
    frame, we should honor the valid token and let the user continue using the application
    without asking them to log back in.
  prefs: []
  type: TYPE_NORMAL
- en: On the flip side, if the token is expired, we should automatically navigate
    the user to the login screen for a smooth UX.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `AuthService` class to implement a function named `hasExpiredToken`
    to check whether the token is expired, and a helper function named `getAuthStatusFromToken`
    to decode the token, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Keep your code DRY! Update the `login()` function to use `getAuthStatusFromToken()`
    instead.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the constructor of `AuthService` to check the status of the token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the token has expired, we log the user out and clear the token from `localStorage`.
    Otherwise, we decode the token and push the auth status to the data stream.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A corner case to consider here is to also trigger the reloading of the current
    user in the event of a resumption. We can do this by implementing a new pipe that
    reloads the current user if activated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, let''s refactor the existing user update logic in the `login()` function
    to a private property named `getAndUpdateUserIfAuthenticated` so we can reuse
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `AuthService`, define an observable property named `resumeCurrentUser$`
    as a fork of `authStatus$`, and use the `getAndUpdateUserIfAuthenticated` logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once `resumeCurrentUser$` is activated and `status.isAuthenticated` is `true`,
    then `this.getCurrentUser()` will be invoked and `currentUser$` will be updated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the constructor of `AuthService` to activate the pipeline if the token
    is unexpired:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the preceding technique, we can retrieve the latest user profile data
    without having to deal with caching issues.
  prefs: []
  type: TYPE_NORMAL
- en: To experiment with token expiration, I recommend that you create a faster-expiring
    token in `InMemoryAuthService`.
  prefs: []
  type: TYPE_NORMAL
- en: As demonstrated earlier in the caching section, it is possible to cache the
    user profile data using `this.setItem` and the profile data from cache on first
    launch. This would provide a faster UX and cover cases where users may be offline.
    After the application launches, you could then asynchronously fetch fresh user
    data and update `currentUser$` when new data comes in. You would need to add additional
    caching and tweak the `getCurrentUser()` logic to get such functionality working.
    Oh, and you would need a whole lot of testing! It takes a lot of testing to create
    a high-quality auth experience.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, we're done implementing a robust auth workflow! Next, we need
    to integrate auth with Angular's HTTP client so we can attach the token to the
    HTTP header of every request.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP interceptor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implement an HTTP interceptor to inject the JWT into the header of every request
    sent to the user and gracefully handle authentication failures by asking the user
    to log back in:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `AuthHttpInterceptor` under `auth`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that `AuthService` is leveraged to retrieve the token, and the `redirectUrl`
    is set for the `login` component after a `401` error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update `app.module.ts` to provide the interceptor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ensure that the interceptor is adding the token to requests. To do this, open
    the **Chrome DevTools | Network** tab, log in, and then refresh the page:![](img/B14094_08_05.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.5: The request header for lemon.svg'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In step **4**, you can now observe the interceptor in action. The request for
    the `lemon.svg` file has the bearer token in the request header.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our auth mechanisms in place, let's take advantage of all the
    supporting code we have written with dynamic UI components and a conditional navigation
    system for a role-based UX.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic UI components and navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`AuthService` provides asynchronous auth status and user information, including
    a user''s name and role. We can use all this information to create a friendly
    and personalized experience for users. In this next section, we will implement
    the `LoginComponent` so that users can enter their username and password information
    and attempt a login.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the login component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `login` component leverages the `AuthService` that we just created and implements
    validation errors using reactive forms.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that in `app.module.ts` we provided `AuthService` using the class `InMemoryAuthService`.
    So, during run time, when `AuthService` is injected into the `login` component,
    the in-memory service will be the one in use.
  prefs: []
  type: TYPE_NORMAL
- en: The `login` component should be designed to be rendered independently of any
    other component, because during a routing event, if we discover that the user
    is not properly authenticated or authorized, we will navigate them to this component.
    We can capture this origination URL as a `redirectUrl` so that once a user logs
    in successfully, we can navigate them back to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the `SubSink` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new component named `login` in the root of your application with inline
    styles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start with implementing the routes to the `login` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember that the `'**'` path must be the last one defined.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using a similar `login` logic to the one we implemented in `HomeComponent`,
    now implement the `LoginComponent` with some styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don't forget to import the requisite dependent modules into your Angular application
    for the upcoming steps. This is intentionally left as an exercise for you to locate
    and import the missing modules.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are using `SubSink` to manage our subscriptions. We ensure that we are logged
    out when `ngOnInit` is called. We build the reactive form in a standard manner.
    Finally, the `login` method calls `this.authService.login` to initiate the login
    process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We listen to the `authStatus$` and `currentUser$` data streams simultaneously
    using `combineLatest`. Every time there's a change in each stream, our pipe gets
    executed. We filter out unsuccessful login attempts. As the result of a successful
    login attempt, we leverage the router to navigate an authenticated user to their
    profile. In the case of an error sent from the server via the service, we assign
    that error to `loginError`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here''s an implementation for a login form to capture and validate a user''s
    `email` and `password`, and if there are any server errors, display them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don't forget to import `ReactiveFormsModule` in `app.modules.ts`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The **Login** button is disabled until the email and password meet client site
    validation rules. Additionally, `<mat-form-field>` will only display one `mat-error`
    at a time, unless you create more space for more errors, so be sure to place your
    error conditions in the correct order.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you're done implementing the `login` component, you can now update the
    home screen to conditionally display or hide the new component we created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `HomeComponent` to clean up the code we added previously, so we
    can display the `LoginComponent` when users land on the home page of the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your application should look similar to this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_08_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: LemonMart with login'
  prefs: []
  type: TYPE_NORMAL
- en: There's still some work to be done in terms of implementing and showing/hiding
    the `sidenav` menu, profile, and logout icons given the user's authentication
    status.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conditional navigation is necessary for creating a frustration-free UX. By selectively
    showing the elements that the user has access to and hiding the ones they don't
    have access to, we allow the user to confidently navigate through the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by hiding the `login` component after a user logs in to the application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the `HomeComponent`, inject the `AuthService` into the constructor as a
    `public` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove the local variable `displayLogin`, because we can directly tap into the
    auth status in the template using the `async` pipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement a new template using the `ngIf; else` syntax, along with the `async`
    pipe, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the `async` pipe avoids errors like `Error: ExpressionChangedAfterItHasBeenCheckedError:
    Expression has changed after it was checked`. Whenever you see this error, stop
    using local variables and instead use the `async` pipe. It is the reactive thing
    to do!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'On the `AppComponent`, we will follow a similar pattern by injecting `AuthService`
    as a `public` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `mat-toolbar` in the template, so that we monitor both `authStatus$`
    and `currentUser$` using the `async` pipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `*ngIf` to hide all buttons meant for logged-in users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, when a user is logged out, your toolbar should look all clean, with no
    buttons, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B14094_08_07.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.7: The LemonMart toolbar before a user logs in'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can also swap out the generic `account_circle` icon in the `profile` button
    if the user has a picture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now have a highly functional toolbar that reacts to the auth status of the
    application and is additionally able to display information that belongs to the
    logged-in user.
  prefs: []
  type: TYPE_NORMAL
- en: Common validations for forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we move on, we need to refactor the validations for `LoginComponent`.
    As we implement more forms in *Chapter 11*, *Recipes – Reusability, Routing, and
    Caching*, you will realize that it gets tedious, fast, to repeatedly type out
    form validations in either template or reactive forms. Part of the allure of reactive
    forms is that they are driven by code, so we can easily extract the validations
    to a shared class, unit test, and reuse them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `validations.ts` file under the `common` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement email and password validations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Depending on your password validation needs, you can use a `RegEx` pattern with
    the `Validations.pattern()` function to enforce password complexity rules or leverage
    the OWASP npm package, `owasp-password-strength-test`, to enable pass-phrases,
    as well as set more flexible password requirements. See the link to the OWASP
    authentication general guidelines in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `login` component with the new validations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's encapsulate some common UI behavior in an Angular service.
  prefs: []
  type: TYPE_NORMAL
- en: UI service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we start dealing with complicated workflows, such as the auth workflow, it
    is important to be able to programmatically display a toast notification for the
    user. In other cases, we may want to ask for a confirmation before executing a
    destructive action with a more intrusive pop-up notification.
  prefs: []
  type: TYPE_NORMAL
- en: No matter what component library you use, it gets tedious to recode the same
    boilerplate just to display a quick notification. A UI service can neatly encapsulate
    a default implementation that can also be customized as needed.
  prefs: []
  type: TYPE_NORMAL
- en: In the UI service, we will implement a `showToast` and a `showDialog` function
    that can trigger notifications or prompt users for a decision, in such a manner
    that we can use it within the code that implements our business logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new service named `ui` under `common`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement a `showToast` function using `MatSnackBar`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check out the documentation for `MatSnackBar` at [https://material.angular.io](https://material.angular.io).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Don't forget to update `app.module.ts` and `material.module.ts` with the various
    dependencies as they are introduced.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For a `showDialog` function using `MatDialog`, we must implement a basic `dialog`
    component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Check out the documentation for `MatDialog` at [https://material.angular.io](https://material.angular.io).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a new component named `simpleDialog` under the `common` folder provided
    in `app.module.ts` with inline templates and styling, skip testing, and a flat
    folder structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that `SimpleDialogComponent` should not have an application selector like
    `selector: ''app-simple-dialog''` since we only plan to use it with `UiService`.
    Remove this property from your component.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, implement a `showDialog` function using `MatDialog` to display the `SimpleDialogComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ShowDialog` returns an `Observable<boolean>`, so you can implement a follow-on
    action, depending on what selection the user makes. Clicking on **OK** will return
    `true`, and **Cancel** will return `false`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In `SimpleDialogComponent`, using `@Inject`, we're able to use all variables
    sent by `showDialog` to customize the content of the dialog.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `app.module.ts`, declare `SimpleDialogComponent` as an `entry` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that with the Ivy rendering engine, `entryComponents` should be unnecessary
    and is deprecated in Angular 9\. However, at the time of publishing, it is still
    required to declare this component as an `entry` component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `login()` function on the `LoginComponent` to display a toast message
    after login:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, a toast message will appear after a user logs in, as shown:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B14094_08_08.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 8.8: Material snackbar'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `snackBar` will either take up the full width of the screen or a portion,
    depending on the size of the browser.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Experiment with displaying a dialog instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that you've verified that both `showToast` and `showDialog` work, which
    one do you prefer? My rule of thumb is that unless the user is about to take an
    irreversible action, you should choose toast messages over dialogs, so you don't
    interrupt the user's workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's implement an application-wide side navigation experience as an alternative
    to the toolbar-based navigation we already have, so that users can switch between
    modules with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Side navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enable mobile-first workflows and provide an easy navigation mechanism to quickly
    jump to the desired functionality. Using the authentication service, given a user''s
    current role, only display the links for features they can access. We will be
    implementing the side navigation mock-up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_08_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: Side navigation mock-up'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the code for the side navigation as a separate component,
    so that it is easier to maintain:'
  prefs: []
  type: TYPE_NORMAL
- en: In the root of the application, create a component named `NavigationMenu` with
    inline templates and styles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The side navigation isn't technically required until after a user is logged
    in. However, in order to be able to launch the side navigation menu from the toolbar,
    we need to be able to trigger it from `AppComponent`. Since this component will
    be simple, we will eagerly load it. To do this lazily, Angular does have a Dynamic
    Component Loader pattern, which has a high implementation overhead that will only
    make sense if multi-hundred kilobyte savings are made.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SideNav` will be triggered from the toolbar, and it comes with a `<mat-sidenav-container>`
    parent container that hosts the `SideNav` itself and the content of the application.
    So, we will need to render all application content by placing the `<router-outlet>`
    inside `<mat-sidenav-content>`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `AppComponent`, define some styles that will ensure that the web application
    will expand to fill the entire page and remain properly scrollable for desktop
    and mobile scenarios:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inject the `MediaObserver` service from Angular Flex Layout in `AppComponent`.
    Also, implement `OnInit` and `OnDestory`, initialize `SubSink`, and add a Boolean
    property named `opened`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To automatically determine the open/closed status of the side navigation, we
    need to monitor the media observer and the auth status. When the user logs in,
    we would like to show the side navigation, and hide it when the user logs out.
    We can do this with settings `opened` to the value of `authStatus$.isAuthenticated`.
    However, if we only consider `isAuthenticated`, and the user is on a mobile device,
    we will create a less than ideal UX. Watching for the media observer's `mediaValue`,
    we can check to see whether the screen size is set to extra small, or `xs`; if
    so, we can keep the side navigation closed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update `ngOnInit` to implement the dynamic side navigation open/closed logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By monitoring both the media and `authStatus$` streams, we can consider unauthenticated
    scenarios where the side navigation should not be opened even if there's enough
    screen space.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the template with a responsive `SideNav` that will slide over the content
    in mobile or push the content aside in desktop scenarios:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding template leverages the Angular Flex Layout media observer that
    was injected earlier for a responsive implementation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can use the `// prettier-ignore` directive above your template to prevent
    Prettier from breaking up your template into too many lines, which can hurt readability
    in certain conditions similar to this one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will implement navigational links in `NavigationMenuComponent`. The number
    of links in our application will likely grow over time and be subject to various
    role-based business rules. Therefore, if we were to implement these links in `app.component.ts`,
    we would risk that file getting too large. In addition, we don't want `app.component.ts`
    to change very often, since changes made there can impact the entire application.
    It is a good practice to implement the links in a separate component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement navigational links in `NavigationMenuComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`<mat-nav-list>` is functionally equivalent to `<mat-list>`, so you can use
    the documentation of `MatList` for layout purposes. Observe the `subheaders` for
    **Manager**, **Inventory**, and **Clerk** here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_08_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: The Manager dashboard showing Receipt Lookup on desktop'
  prefs: []
  type: TYPE_NORMAL
- en: '`routerLinkActive="active-link"` highlights the selected **Receipts** route,
    as shown in the preceding screenshot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you can see the difference in appearance and behavior on mobile
    devices as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_08_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: The Manager dashboard showing Receipt Lookup on mobile'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's implement role-based routing.
  prefs: []
  type: TYPE_NORMAL
- en: Role-based routing using guards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the most elemental and important part of your application. With lazy
    loading, we have ensured that only the bare minimum number of assets will be loaded
    to enable a user to log in.
  prefs: []
  type: TYPE_NORMAL
- en: Once a user logs in, they should be routed to the appropriate landing screen
    as per their user role, so they're not guessing how they need to use the application.
    For example, a cashier needs to only access the point of sale (POS) to check out
    customers, so they can automatically be routed to that screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a mock-up of the POS screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_08_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.12: A POS screen mock-up'
  prefs: []
  type: TYPE_NORMAL
- en: Let's ensure that users get routed to the appropriate page after logging in
    by updating the `LoginComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `login` logic to route per role in the function named `homeRoutePerRole`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, clerks and managers are routed to their landing screens to access
    the features they need to accomplish their tasks, as shown earlier. Since we have
    implemented a default manager role, the corresponding landing experience will
    be launched automatically. The other side of the coin is intentional and unintentional
    attempts to access routes that a user isn't meant to have access to. In the next
    section, you will learn about router guards that can help to check authentication
    and even load requisite data before the form is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Router guards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Router guards enable the further decoupling and reuse of logic, and greater
    control over the component life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the four major guards you will most likely use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CanActivate` and `CanActivateChild`: Used for checking auth access to a route'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CanDeactivate`: Used to ask permission before navigating away from a route'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Resolve`: Allows the pre-fetching of data from route parameters'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CanLoad`: Allows custom logic to execute before loading feature module assets'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to the following sections to discover how to leverage `CanActivate` and
    `CanLoad`. The `Resolve` guard will be covered in *Chapter 11*, *Recipes – Reusability,
    Routing, and Caching*.
  prefs: []
  type: TYPE_NORMAL
- en: Auth guards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Auth guards enable a good UX by allowing or disallowing accidental navigation
    to a feature module or a component before the module has loaded or before any
    improper data requests have been made to the server. For example, when a manager
    logs in, they're automatically routed to the `/manager/home` path. The browser
    will cache this URL, and it would be completely plausible for a clerk to accidentally
    navigate to the same URL. Angular doesn't know whether a particular route is accessible
    to a user or not and, without an `AuthGuard`, it will happily render the manager's
    home page and trigger server requests that will end up failing.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the robustness of your frontend implementation, every REST API
    you implement should be properly secured server-side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the router so that `ProfileComponent` can''t be activated without
    an authenticated user and the `ManagerModule` won''t load unless a manager is
    logging in using an `AuthGuard`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement an `AuthGuard` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `CanLoad` guard to prevent the loading of a lazily loaded module, such
    as the manager''s module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this instance, when the `ManagerModule` is being loaded, `AuthGuard` will
    be activated during the `canLoad` event, and the `checkLogin` function will verify
    the authentication status of the user. If the guard returns `false`, the module
    will not be loaded. At this point, we don't have the metadata to check the role
    of the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the `CanActivate` guard to prevent the activation of individual components,
    such as the user''s `profile`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the case of `user-routing.module.ts`, `AuthGuard` is activated during the
    `canActivate` event, and the `checkLogin` function controls where this route can
    be navigated to. Since the user is viewing their own profile, there's no need
    to check the user's role here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `CanActivate` or `CanActivateChild` with an `expectedRole` property to
    prevent the activation of components by other users, such as `ManagerHomeComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside `ManagerModule`, we can verify whether the user is authorized to access
    a particular route. We can do this by defining some metadata in the route definition,
    like `expectedRole`, which will be passed into the `checkLogin` function by the
    `canActivate` event. If a user is authenticated but their role doesn't match `Role.Manager`,
    `AuthGuard` will return `false` and the navigation will be prevented.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will go over some techniques to get our tests passing.
  prefs: []
  type: TYPE_NORMAL
- en: Auth service fake and common testing providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to provide mocked versions of services like `AuthService` or `UiService`
    using the `commonTestingProviders` function in `common.testing.ts`, using a pattern
    similar to `commonTestingModules`, which was mentioned in *Chapter 7*, *Creating
    a Router-First Line-of-Business App*. This way, we won't have to mock the same
    objects over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the spy objects using the `autoSpyObj` function from `angular-unit-test-helper`
    and go over some less obvious changes we need to implement to get our tests passing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `commonTestingProviders` in `common.testing.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Observe the fake being provided for the `MediaObserver` in `app.component.spec.ts`
    and update it to use `commonTestingModules`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See how the `commonTestingProviders` array is being concatenated with fakes
    that are specific to `app.component.ts`; our new mocks should apply automatically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the spec file for `LoginComponent` to leverage `commonTestingModules`
    and `commonTestingProviders`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go ahead and apply this technique to all spec files that have a dependency on
    `AuthService` and `UiService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The notable exception is services, as in `auth.service.spec.ts`, where you
    do *not* want to use a test double. Since `AuthService` is the class under test,
    make sure it is configured as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update `ui.service.spec.ts` with similar considerations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember, don't move on until all your tests are passed!
  prefs: []
  type: TYPE_NORMAL
- en: Firebase authentication recipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can leverage our current authentication setup and integrate it with a real
    authentication service. For this section, you need a free Google and Firebase
    account. Firebase is Google''s comprehensive mobile development platform: [https://firebase.google.com](https://firebase.google.com).
    You can create a free account to host your application and leverage the Firebase
    authentication system.'
  prefs: []
  type: TYPE_NORMAL
- en: The Firebase console, found at [https://console.firebase.google.com](https://console.firebase.google.com),
    allows you to manage users and send a password reset email without having to implement
    a backend for your application. Later on, you can leverage Firebase functions
    to implement APIs in a serverless manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding your project to Firebase using the Firebase console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_08_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.13: The Firebase console'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Add project**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide your project name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable Google Analytics for your project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It helps to create a Google Analytics account before attempting this, but it
    should still work. Once your project is created, you should see your project dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_08_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.14: The Firebase project overview'
  prefs: []
  type: TYPE_NORMAL
- en: On the left-hand side, marked with step **1**, you can see a menu of tools and
    services that you can add to your project. At the top, marked with step **2**,
    you can quickly jump between your projects. First, you need to add an application
    to your project.
  prefs: []
  type: TYPE_NORMAL
- en: Add an application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your project can include multiple distributions of your application, like web,
    iOS, and Android versions. In this chapter, we're only interested in adding a
    web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: On your project dashboard, click on the web application button to add an application,
    which is marked with step **3** in *Figure 8.14*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide an application nickname
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the option to set up **Firebase Hosting**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue by hitting the **Register app** button
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Skip over the **Add Firebase SDK** section
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the Firebase CLI as instructed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sign in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure your current directory is your project's root folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Initialize your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Select the **Hosting** option; don't worry, you can add more features later
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the project you created as the default, that is, **lemon-mart-007**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the public directory enter `dist/lemon-mart` or the `outputPath` defined
    in your `angular.json` file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Say **yes** to configure it as a single-page application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will create two new files: `firebase.json` and `.firebaserc`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Build your project for production:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: or
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you can deploy your Angular application by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your website should be available on a URL similar to [https://lemon-mart-007.firebaseapp.com](https://lemon-mart-007.firebaseapp.com),
    as shown in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Add the `.firebase` folder to `.gitignore` so you don't check in your cache
    files. The other two files, `firebase.json` and `.firebaserc`, are safe to commit.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, connect a custom domain name that you own to the account using the
    Firebase console.
  prefs: []
  type: TYPE_NORMAL
- en: Configure authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's configure authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Firebase console:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Authentication** from the side navigation:![](img/B14094_08_15.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.15: The Firebase Authentication page'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **Email/Password** as the provider
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not enable the email link
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your configuration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can now see the user management console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_08_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.16: The Firebase user management console'
  prefs: []
  type: TYPE_NORMAL
- en: It is fairly straightforward and intuitive to operate, so I will leave the configuration
    of it as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: Implement Firebase authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by adding Angular Fire, the official Firebase library for Angular,
    to our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Follow Angular Fire's quickstart guide to finish setting up the library with
    your Angular project, which you can find linked from the readme file on GitHub
    at [https://github.com/angular/angularfire2](https://github.com/angular/angularfire2).
  prefs: []
  type: TYPE_NORMAL
- en: Ensure Firebase modules are provided in `app.module.ts` as per the documentation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure your Firebase config object is in all your `environment.ts` files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that any information provided in `environment.ts` is public information.
    So, when you place your Firebase API key in this file, it will be publicly available.
    There''s a small chance that another developer could abuse your API key and run
    up your bill. To protect yourself from any such attack, check out this blog post
    by paachu: *How to secure your Firebase project even when your API key is publicly
    available* at [https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843](https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new `FirebaseAuthService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Rename the service file to `auth.firebase.service.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Be sure to remove `{ providedIn: ''root'' }`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement Firebase auth by extending the abstract auth service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we only had to implement the delta between our already established
    authentication code and Firebase's authentication methods. We didn't have to duplicate
    any code and we even transformed a Firebase `user` object into our application's
    internal user object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To use Firebase authentication instead of in-memory authentication, update
    the `AuthService` provider in `app.module.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once you've completed the steps, add a new user from the Firebase authentication
    console and you should be able to log in using real authentication.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Always make sure that you're using HTTPS when transmitting any kind of **personally
    identifiable information** (**PII**) or sensitive information (like passwords)
    over the Internet. Otherwise, your information will get logged on third-party
    servers or captured by bad actors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once again, be sure to update your unit tests before moving on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Stop! Remove the `fake-jwt-sign` package from your project before deploying
    a real authentication method.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, your application is integrated with Firebase! Next, let's cover
    service factories, which can help you to switch the providers of your abstract
    classes dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Providing a service using a factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can dynamically choose providers during load time, so instead of having
    to change code to switch between authentication methods, you can parametrize environment
    variables, so different kinds of builds can have different authentication methods.
    This is especially useful when writing automated UI tests against your application,
    where real authentication can be difficult, if not impossible, to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create an `enum` in `environment.ts` to help define our options,
    and then we will use that `enum` to choose an auth provider during our application's
    bootstrap process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `enum` called `AuthMode`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `authMode` property in `environment.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `authFactory` function in a new file under `auth/auth.factory.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the factory has to import any dependent service.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `AuthService` provider in `app.module.ts` to use the factory instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that you can remove imports of `InMemoryAuthService` and `FirebaseAuthService`
    from `AppModule`.
  prefs: []
  type: TYPE_NORMAL
- en: With this configuration in place, whenever you build your application for local
    development, you will be using the in-memory auth service and production (or prod)
    builds will use the Firebase auth service.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now be familiar with how to create high-quality auth experiences.
    In this chapter, we defined a User object that we can hydrate from or serialize
    to JSON objects, applying object-oriented class design and TypeScript operators
    for safe data handling.
  prefs: []
  type: TYPE_NORMAL
- en: We leveraged OOP design principals, using inheritance and abstract classes to
    implement a base auth service that demonstrates the Open/Closed principle.
  prefs: []
  type: TYPE_NORMAL
- en: We covered the fundamentals of token-based authentication and JWTs so that you
    don't leak any critical user information. You learned that caching and HTTP interceptors
    are necessary so that users don't have to input their login information with every
    request. Following that, we implemented two distinct auth providers, one in-memory
    and one with Firebase.
  prefs: []
  type: TYPE_NORMAL
- en: We then designed a great conditional navigation experience that you can use
    in your own applications by copying the base elements to your project and implementing
    your own auth provider. We created a reusable UI service so that you can conveniently
    inject alerts into the flow-control logic of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we covered router guards to prevent users from stumbling onto screens
    they are not authorized to use, and we reaffirmed the point that the real security
    of your application should be implemented on the server side. You saw how you
    can use a factory to dynamically provide different auth providers for different
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will shift gears a bit and learn about containerization
    using Docker. Docker allows powerful workflows that can greatly improve development
    experiences, while allowing you to implement your server configuration as code,
    putting a final nail in the coffin of the developer''s favorite excuse when their
    software breaks: "But it works on my machine!"'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Salted Password Hashing - Doing it Right, Defuse Security*, 2019, [https://crackstation.net/hashing-security.htm](https://crackstation.net/hashing-security.htm).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Object-oriented programming*, [https://en.wikipedia.org/wiki/Object-oriented_programming](https://en.wikipedia.org/wiki/Object-oriented_programming).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TypeScript Classes*, [https://www.typescriptlang.org/docs/handbook/classes.html](https://www.typescriptlang.org/docs/handbook/classes.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TypeScript Basic Types*, [https://www.typescriptlang.org/docs/handbook/basic-types.html](https://www.typescriptlang.org/docs/handbook/basic-types.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TypeScript Advanced Types*, [https://www.typescriptlang.org/docs/handbook/advanced-types.html](https://www.typescriptlang.org/docs/handbook/advanced-types.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TypeScript 3.7 Features*, [https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Angular NgIf Directive*, [https://angular.io/api/common/NgIf](https://angular.io/api/common/NgIf).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Authentication General Guidelines*, [https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How to secure your Firebase project even when your API key is publicly available*,
    paachu, 2019, [https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843](https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Answer the following questions as best as you can to ensure that you've understood
    the key concepts from this chapter without Googling. Do you need help answering
    the questions? See *Appendix D*, *Self-Assessment Answers* online at [https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf)
    or visit [https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment).
  prefs: []
  type: TYPE_NORMAL
- en: What's in-transit and at-rest security?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between authentication and authorization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain inheritance and polymorphism.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an abstract class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an abstract method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain how the `AuthService` adheres to the Open/Closed principle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does JWT verify your identity?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between RxJS's `combineLatest` and `merge` operators?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a router guard?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does a service factory allow you to do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
