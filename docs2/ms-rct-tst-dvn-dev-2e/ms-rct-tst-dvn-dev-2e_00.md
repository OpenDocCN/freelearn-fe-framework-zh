# 前言

这是一本关于教条的书籍。**我的**教条。它是一套原则、实践和仪式，我发现它们在构建 React 应用程序时极为有益。我试图在我的日常工作中应用这些想法，并且我非常相信它们，以至于我抓住每一个机会向他人传授它们。这就是我写这本书的原因：向你展示那些帮助我在自己的职业生涯中取得成功的想法。

正如任何教条一样，你有权自己做出判断。有些人会不喜欢这本书的每一部分。有些人会喜欢这本书的每一部分。还有更多的人会吸收一些内容而忘记其他内容。这些都很好。我唯一要求的是，你在跟随的同时保持开放的心态，并准备好挑战你自己的教条。

**测试驱动开发**（**TDD**）并非起源于 JavaScript 社区。然而，完全有可能用 TDD 来测试 JavaScript 代码。尽管 TDD 在 React 社区中并不常见，但没有任何理由它不应该被采用。事实上，React 作为一个用户界面平台，由于其优雅的函数组件和状态模型，非常适合 TDD。

那么，TDD 是什么，为什么你应该使用它呢？TDD 是一种编写软件的过程，它涉及在编写任何代码之前编写测试或规范。其从业者遵循它，因为他们相信它有助于他们以更低的成本构建和设计更高品质、寿命更长的软件。他们认为它提供了一种关于设计和规范沟通的机制，同时也是一个坚如磐石的回归测试套件。目前没有多少经验数据可以**证明**这些说法的真实性，所以你能做的最好的事情就是亲自尝试，并自己做出判断。

对我来说，也许最重要的是，我发现 TDD 消除了对修改我的软件的**恐惧**，使我的工作日比以前轻松得多。我不担心在我的工作中引入错误或回归，因为测试保护了我。

TDD 通常用玩具示例来教授：待办事项列表、温度转换器、井字棋等等。这本书教授两个真实世界的应用。通常，测试会变得复杂。我们将遇到许多具有挑战性的场景，并为所有这些场景找到解决方案。这本书中包含超过 500 个测试，每个测试都会教你一些东西。

在我们开始之前，有一些建议要提。

这是一本关于**第一性原理**的书。我相信学习 TDD（测试驱动开发）就是深入了解这个过程。因此，我们将**不会**使用 React Testing Library。相反，我们将构建自己的测试助手。我并不是建议你在日常工作中避免使用这些工具——我自己也在使用它们——但我建议，在学习过程中不使用它们是一次值得的冒险。这样做的好处是，能更深入地理解和意识到这些测试库为你做了什么。

JavaScript 和 React 的景观变化如此之快，以至于我无法保证这本书会保持很长时间的时效性。这也是我使用第一性原理方法的原因之一。我的希望是，当事情真的发生变化时，你仍然可以使用这本书，并将你学到的知识应用到那些新场景中。

这本书的另一个主题是**系统重构**，这可能看起来相当费时，但它是 TDD 和其他良好设计实践的基础。我在这些页面中提供了许多这样的例子，但为了简洁起见，我有时会直接跳到最终的、重构后的解决方案。例如，我有时会选择在编写之前提取方法，而在现实世界中，我通常会内联编写方法，只有在包含的方法（或测试）变得过长时才提取。

另一个主题是**作弊**，这在许多 TDD 书籍中是找不到的。这是对 TDD 工作流程的一种认可，即你可以围绕它建立自己的规则。一旦你学习并实践了一段时间的严格 TDD 版本，你就可以了解哪些作弊技巧可以用来节省时间。哪些测试在长期来看不会提供太多价值？你如何加快重复性测试？所以，一个**作弊**几乎就像是在别人明天来看你的代码时，你以一种不会很明显的方式走捷径。例如，你可能一次实现三个测试，而不是一个接一个地实现。

在这本书的第二版中，我加大了对 TDD 而不是 React 特性的教学力度。除了更新代码示例以与 React 18 兼容外，几乎没有使用新的 React 特性。相反，测试已经得到了大幅改进；它们更简单、更小，并利用自定义的 Jest 匹配器（这些匹配器本身也是通过测试驱动的）。第一版的读者会注意到，我改变了组件模拟的方法；这一版依赖于`jest.mock`函数的模块模拟。这本书不再教授浅渲染。还有一些其他的小改动，比如避免使用`ReactTestUtils.Simulate`模块。章节组织也得到了改善，一些早期的章节被拆分并简化了。我希望你会同意，这一版比第一版好得多。

# 这本书面向的对象

如果你是一名 React 程序员，这本书就是为你准备的。我的目标是向你展示 TDD 如何提高你的工作效率。

如果你已经对 TDD 有所了解，我希望你还能从比较你自己的流程和我的流程中学到很多东西。

如果你还不了解 React，你将受益于花些时间在 React 网站上运行*入门指南*。话虽如此，TDD 是一个解释新技术的绝佳平台，而且完全有可能你只需通过这本书就能掌握 React。

# 这本书涵盖的内容

*第一章*, *测试驱动开发的第一步*，介绍了 Jest 和 TDD 周期。

*第二章*, *渲染列表和详情视图*，使用 TDD 周期构建一个简单的页面，显示客户信息。

*第三章*, *重构测试套件*，介绍了你可以简化测试的一些基本方法。

*第四章*, *使用 React 测试驱动数据输入*，涵盖了使用 React 组件状态来管理文本输入字段的显示和保存。

*第五章*, *添加复杂表单交互*，探讨了带有下拉菜单和单选按钮的更复杂表单设置。

*第六章*, *探索测试替身*，介绍了测试协作对象所需的各种测试替身类型，以及如何使用它们来测试驱动表单提交。

*第七章*, *测试 useEffect 和模拟组件*，探讨了在组件挂载时使用测试替身获取数据，以及如何在测试父组件时使用模块模拟来阻止该行为。

*第八章*, *构建应用程序组件*，通过一个“根”组件将用户旅程串联起来，将所有内容结合起来。

*第九章*, *表单验证*，继续通过添加客户端和服务器端验证以及添加一个指示器来显示数据正在提交，来构建表单。

*第十章*, *过滤和搜索数据*，展示了如何构建一个具有一些复杂交互要求的搜索组件，以及复杂的 fetch 请求要求。

*第十一章*, *测试驱动 React Router*，介绍了 React Router 库，用于简化用户旅程内的导航。

*第十二章*, *测试驱动 Redux*，介绍了 Redux 到我们的应用程序。

*第十三章*, *测试驱动 GraphQL*，介绍了 Relay 库，用于与我们的应用程序后端提供的 GraphQL 端点进行通信。

*第十四章*, *构建 Logo 解释器*，介绍了一个有趣的应用程序，我们将通过构建 React 组件和 Redux 中间件的功能来开始探索：撤销/重做、使用`LocalStorage` API 跨浏览器会话持久化状态，以及程序化管理字段焦点。

*第十五章*, *添加动画*，涵盖了使用浏览器的`requestAnimationFrame` API 添加动画到我们的应用程序，所有这些都是在测试驱动的方法下完成的。

*第十六章*, *使用 WebSocket*，为我们的应用程序后端添加了对 WebSocket 通信的支持。

*第十七章*，*编写你的第一个 Cucumber 测试*，介绍了 Cucumber 和 Puppeteer，我们将使用它们来为现有功能构建 BDD 测试。

*第十八章*，*由 Cucumber 测试引导的功能添加*，通过首先使用 Cucumber 构建 BDD 测试，然后下降到单元测试，将验收测试集成到我们的开发过程中。

*第十九章*，*在更广泛的测试领域中理解 TDD*，通过查看你所学的知识如何与其他测试和质量实践相结合来结束本书。

# 为了充分利用这本书

阅读这本书有两种方法。

第一种是当你面临特定的测试挑战时将其作为参考。使用索引找到你想要的内容，然后转到那一页。

第二种，也是我建议你开始的方法，是逐步跟随教程，在过程中构建你自己的代码库。配套的 GitHub 仓库为每个章节（如 `Chapter01`）都有一个目录，然后在该目录下，有三个目录：

+   `Start`，这是章节的起点，如果你在跟随学习，你应该从这里开始。

+   `Exercises`，这是章节末尾开始练习的点。如果你正在尝试每个章节的练习，你应该从这里开始。（注意，并非每个章节都有练习。）

+   `Complete`，其中包含所有练习的完整解决方案。

你至少需要稍微熟悉 `branch`、`checkout`、`clone`、`commit`、`diff` 和 `merge` 命令，这些命令应该是足够的。

查看 GitHub 仓库中的 `README.md` 文件以获取更多信息和工作与代码库的说明。

**如果你使用这本书的数字版，我们建议你亲自输入代码或从书的 GitHub 仓库（下一节中有一个链接）获取代码。这样做将帮助你避免与代码复制粘贴相关的任何潜在错误。**

# 下载示例代码文件

你可以从 GitHub 下载这本书的示例代码文件：[`github.com/packtPublishing/Mastering-React-Test-Driven-Development-Second-Edition/`](http://github.com/packtPublishing/Mastering-React-Test-Driven-Development-Second-Edition/)。如果代码有更新，它将在 GitHub 仓库中更新。

我们还有其他来自我们丰富的图书和视频目录的代码包，可在 [`github.com/PacktPublishing/`](https://github.com/PacktPublishing/) 获取。查看它们吧！

# 下载彩色图像

我们还提供了一个包含本书中使用的截图和图表的彩色图像的 PDF 文件。你可以从这里下载：[`packt.link/5dqQx`](https://packt.link/5dqQx)。

# 使用的约定

在这本书中使用了多种文本约定。

`文本中的代码`: 表示文本中的代码单词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 昵称。以下是一个示例：“在第一个测试中，将单词`appendChild`更改为`replaceChildren`。”

**粗体**: 表示新术语、重要单词或屏幕上看到的单词。例如，菜单或对话框中的单词会以粗体显示。以下是一个示例：“演示者点击了**开始共享**按钮。”

小贴士或重要提示

它们看起来像这样。

## 代码片段约定

代码块设置如下：

```js
it("renders the customer first name", () => {  const customer = { firstName: "Ashley" };  render(<Appointment customer={customer} />);  expect(document.body.textContent).toContain("Ashley");});
```

关于本书中出现的代码片段，有两件重要的事情需要了解。

第一点是，一些代码示例展示了现有代码段落的修改。当这种情况发生时，更改的行会以粗体显示，而其他行只是简单地提供上下文：

```js
export const Appointment = ({ customer }) => (  <div>{customer.firstName}</div>);
```

第二点是，通常，一些代码示例会省略行以保持上下文清晰。当这种情况发生时，您会看到一条带有三个点的线进行标记：

```js
if (!anyErrors(validationResult)) {
  ...
} else {
setValidationErrors(validationResult); 
} 
```

有时，这种情况也适用于函数参数：

```js
if (!anyErrors(validationResult)) {
  setSubmitting(true);
  const result = await window.fetch(...);
setSubmitting(false); 
  ... 
}
```

任何命令行输入或输出都应如下编写：

```js
npx relay-compiler
```

## JavaScript 约定

本书几乎完全使用箭头函数来定义函数。唯一的例外是我们编写生成器函数时，必须使用标准函数的语法。如果您不熟悉箭头函数，它们看起来像这样，定义了一个名为`inc`的单参数函数：

```js
const inc = arg => arg + 1;
```

它们可以出现在一行上，也可以分成两行：

```js
const inc = arg =>
  arg + 1;
```

有多个参数的函数，其参数将被括号包围：

```js
const add = (a, b) => a + b;
```

如果一个函数有多个语句，那么函数体将被括号包围：

```js
const dailyTimeSlots = (salonOpensAt, salonClosesAt) => {
  ...
  return timeIncrements(totalSlots, startTime, increment);};
```

如果函数返回一个对象，那么该对象必须被括号包围，这样运行时就不会认为它正在执行一个代码块：

```js
setAppointment(appointment => ({  ...appointment,  [name]: value }); 
```

本书大量使用解构技术，以使代码库尽可能简洁。例如，对象解构通常发生在函数参数中：

```js
const handleSelectBoxChange = (
  { target: { value, name } }
) => {
  ...
}; 
```

这相当于说：

```js
const handleSelectBoxChange = (event) => {
  const target = event.target;
  const value = target.value;
  const name = target.name;
  ...
}; 
```

返回值也可以以相同的方式进行解构：

```js
const [customer, setCustomer] = useState({});
```

这相当于以下内容：

```js
const customerState = useState({});
const customer = customerState[0];
const setCustomer = customerState[1];
```

# 联系我们

我们欢迎读者的反馈。

**一般反馈**: 如果您对本书的任何方面有疑问，请通过 mailto:customercare@packtpub.com 给我们发邮件，并在邮件的主题中提及书名。

**勘误**: 尽管我们已经尽最大努力确保内容的准确性，但错误仍然可能发生。如果您在这本书中发现了错误，如果您能向我们报告，我们将不胜感激。请访问 [www.packtpub.com/support/errata](http://www.packtpub.com/support/errata) 并填写表格。

**盗版**: 如果您在互联网上以任何形式遇到我们作品的非法副本，如果您能提供位置地址或网站名称，我们将不胜感激。请通过 mailto:copyright@packt.com 与我们联系，并在邮件中附上材料的链接。

**如果你有兴趣成为作者**：如果你在某个领域有专业知识，并且你对撰写或参与一本书感兴趣，请访问[authors.packtpub.com](http://authors.packtpub.com)。

# 分享你的想法

一旦你阅读了《精通 React 测试驱动开发》，我们很乐意听听你的想法！请[点击此处直接访问此书的亚马逊评论页面](https://packt.link/r/1803247126)并分享你的反馈。

你的评论对我们和科技社区都很重要，并将帮助我们确保我们提供高质量的内容。

# 第一部分 – 探索 TDD 工作流程

*第一部分*介绍了你需要测试驱动 React 应用程序的所有基本技巧。随着你构建更多应用程序，你将创建一组库函数，这些函数有助于简化并加速你的测试。目标是给你提供理论和实践建议，帮助你将测试驱动开发工作流程应用到日常工作中。

本部分包括以下章节：

+   *第一章*，*测试驱动开发的初步步骤*

+   *第二章*，*渲染列表和详情视图*

+   *第三章*，*重构测试套件*

+   *第四章*，*测试驱动数据输入*

+   *第五章*，*添加复杂表单交互*

+   *第六章*，*探索测试替身*

+   *第七章*，*测试 useEffect 和模拟组件*

+   *第八章*，*构建应用程序组件*
