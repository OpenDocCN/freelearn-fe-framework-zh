<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Configuring Full-Stack with Node.js, Express.js, MongoDB, Mongoose, Falcor, and Redux</h1>
            

            <article>
                
<p class="calibre2">Welcome to <em class="calibre21">Mastering Full-Stack React Web Development</em>. In this book, you will create a universal full-stack application in JavaScript. The application that we are going to build is a publishing platform similar to those that are currently popular on the market, for example:</p>
<ul class="calibre14">
<li class="calibre15">Medium (<a href="https://medium.com/" class="calibre6"><span>https://medium.com/</span></a>)</li>
<li class="calibre15">WordPress (<a href="https://wordpress.com/" class="calibre6"><span>https://wordpress.com/</span></a>)</li>
<li class="calibre15">issuu (<a href="https://issuu.com/" class="calibre6"><span>https://issuu.com/</span></a>)</li>
</ul>
<p class="calibre2">There are many smaller publishing platforms, and, of course, our application will have fewer features than the ones listed in the aforementioned list because we will only focus on the main features, such as publishing an article, editing an article, or deleting an article (the core features that you can use to implement your own ideas). Besides that, we will focus on building a robust application that can be built on because one of the most important things about these kinds of applications is scalability. Sometimes, a single article gets much more web traffic than the whole site put together (10,000 percent times more traffic is normal in the industry because, for instance, a single article could gain insane traction through social media).</p>
<p class="calibre2">The first chapter of this book is all about setting up the project's main dependencies.</p>
<p class="calibre2">Our focus for this chapter will include the following topics:</p>
<ul class="calibre14">
<li class="calibre15">Installation of <strong class="calibre1">Node Version Manager</strong> (<strong class="calibre1">NVM</strong>) for easier Node management</li>
<li class="calibre15">Installation of Node and NPM</li>
<li class="calibre15">Preparing MongoDB in our local environment</li>
<li class="calibre15">Robomongo for Mongo's GUI</li>
<li class="calibre15">Express.js setup</li>
<li class="calibre15">Mongoose installation and configuration</li>
<li class="calibre15">Initial React Redux structure for our client-side app</li>
<li class="calibre15">Netflix Falcor on the backend and frontend as a glue and replacement for the old RESTful approach</li>
</ul>
<p class="calibre2">We will use very modern app stacks that gained a lot of traction in 2015 and 2016--I am sure that the stack that you are going to learn throughout the book will be even more popular in years to come, as we in our company, <em class="calibre21">MobileWebPro.pl</em>, see huge spikes of interest in the technologies that are listed in the previous bullets. You will gain a lot from this book, and will catch up with the newest approaches to building robust, full-stack applications.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">More about our technical stack</h1>
            

            <article>
                
<p class="calibre2">In this book, we assume that you are familiar with JavaScript (ES5 and ES6) and we will also introduce you to some mechanisms from ES7 and ES8.</p>
<p class="calibre2">For the client side, you will use React.js, which you must already be familiar with, so we won't discuss React's API in detail.</p>
<p class="calibre2">For data management on the client side, we will use Redux. We will also show you how to set up the server-side rendering with Redux.</p>
<p class="calibre2">For the database, you will learn how to use MongoDB alongside Mongoose. The second one is an object data modeling library that provides a rigorous modeling environment for your data. It enforces a structure, and at the same time it also allows you to keep the flexibility that makes MongoDB so powerful.</p>
<p class="calibre2">Node.js and Express.js are standard choices for a frontend developer to start a full-stack development. Express's framework has the best support for the innovative client backend data fetching mechanism created by <strong class="calibre1">Netflix</strong>-<strong class="calibre1">Falcor.js</strong>. We believe you will love Falcor because of its simplicity and the fact that it will save you so much time when doing full-stack development. We will explain in detail later in the book why it is so efficient to use this data fetching library instead of the standard process of building a RESTful API.</p>
<p class="calibre2">Generally, we will use an object notation (JSON) pretty much everywhere--with React as the library, JSON is heavily used for diffing the Virtual DOM (under the hood). Redux uses a JSON tree for its single state tree container as well. Netflix Falcor's library also uses an advanced concept called a virtual JSON graph (we will describe it in detail later). Finally, MongoDB is also a document-based database.</p>
<p class="calibre2">JSON everywhere--this setup will improve our productivity drastically, mainly because of Falcor, which is binding everything together.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Environment preparation</h1>
            

            <article>
                
<p class="calibre2">For starting up, you're going to need the following tools installed on your operating system:</p>
<ul class="calibre14">
<li class="calibre15">MongoDB</li>
<li class="calibre15">Node.js</li>
<li class="calibre15">NPM--installed automatically with Node.js</li>
</ul>
<p class="calibre2">We strongly recommend using either Linux or OS X for development. For Windows users, we'd recommend setting up a virtual machine and doing the development part within it. For doing so, you can either use <strong class="calibre1">Vagrant</strong> (<a href="https://www.vagrantup.com/" class="calibre6"><span>https://www.vagrantup.com/</span></a>), which creates a virtual env process in the background with development taking place almost natively on Windows, or you can use Oracle's <strong class="calibre1">VirtualBox</strong> (<a href="https://www.virtualbox.org/" class="calibre6"><span>https://www.virtualbox.org/</span></a>) directly, and work within a virtual desktop, however the performance here is significantly lower than working native.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">NVM and Node installation</h1>
            

            <article>
                
<p class="calibre2">NVM is a very handy tool for keeping different Node versions on your machine during development. Go to <a href="https://github.com/creationix/nvm" class="calibre6"><span>https://github.com/creationix/nvm</span></a> for instructions if you don't have NVM installed on your system yet.</p>
<p class="calibre2">After you have NVM on your system, you can type the following:</p>
<pre class="calibre22">
<strong class="calibre1">$ nvm list-remote</strong>
</pre>
<p class="calibre2">This command lists all possible Node versions that are available. We will use Node v4.0.0 in our case, so you need to type the following in your terminal:</p>
<pre class="calibre22">
<strong class="calibre1">$ nvm install v4.0.0</strong><br class="title-page-name"/><strong class="calibre1">$ nvm alias default v4.0.0</strong>
</pre>
<p class="calibre2">These commands will install Node version 4.0.0. and set it as default. We use NPM 2.14.23 during the book so you can check your version with the following command:</p>
<pre class="calibre22">
<strong class="calibre1">$ npm -v</strong><br class="title-page-name"/><strong class="calibre1">2.14.23</strong>
</pre>
<p class="calibre2">After you have the same versions of Node and NPM on your local machine, then we can start to set up the rest of the tools that we are going to use.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">MongoDB installation</h1>
            

            <article>
                
<p class="calibre2">You can find all the MongoDB instructions at <a href="https://docs.mongodb.org/manual/installation/" class="calibre6"><span>https://docs.mongodb.org/manual/installation/</span></a> under the <span>Tutorials</span> section.</p>
<p class="calibre2">The following is a screenshot from the MongoDB website:</p>
<div class="packt_figure"><img class="image-border" src="../images/00005.jpeg"/></div>
<p class="calibre2">The instructions and prepared packages for installing Node.js can be found at <a href="https://nodejs.org" class="calibre6"><span>https://nodejs.org</span></a>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Robomongo GUI for MongoDB</h1>
            

            <article>
                
<p class="calibre2"><strong class="calibre1">Robomongo</strong> is a cross-platform desktop client that may be compared to MySQL or PostgreSQL for SQL databases.</p>
<p class="calibre2">When developing an app, it's good to have a GUI and be able to quickly review collections in our database. This is an optional step if you feel familiar with using shell for DB management, but it's helpful if it's your first step in working with databases.</p>
<p class="calibre2">To obtain Robomongo (for all operating systems), visit <a href="https://robomongo.org/" class="calibre6"><span>https://robomongo.org/</span></a> and install one on your machine.</p>
<p class="calibre2">In our case, we will use version 0.9.0 RC4 of Robomongo.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Running MongoDB and viewing our collections in the Robomongo GUI</h1>
            

            <article>
                
<p class="calibre2">After you have installed MongoDB and Robomongo on your machine, you need to run its daemon process, which listens to connections and delegates them to the database. To run the Mongo daemon process in your terminal, use the following command:</p>
<pre class="calibre22">
<strong class="calibre1">mongod</strong>
</pre>
<p class="calibre2">Then perform the following steps:</p>
<ol class="calibre17">
<li value="1" class="calibre15">Open Robomongo's client--the following screen will appear:</li>
</ol>
<div class="packt_figure"><img class="image-border1" src="../images/00006.jpeg"/></div>
<ol start="2" class="calibre17">
<li value="2" class="calibre15">Create a connection with defaults by clicking the <span>Create</span> link:</li>
</ol>
<div class="packt_figure"><img class="image-border2" src="../images/00007.jpeg"/></div>
<ol start="3" class="calibre17">
<li value="3" class="calibre15">Pick a name for your connection and use port <kbd class="calibre11">27017</kbd>, which is the default for databases, and click on <span>Save</span>.</li>
</ol>
<p class="calibre2">At this point, you have a localhost database setup finished, and you can preview its content using the GUI client.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Importing the first example collection into the database</h1>
            

            <article>
                
<p class="calibre2">In the project's directory, create a file called <kbd class="calibre11">initData.js</kbd>:</p>
<pre class="calibre22">
<strong class="calibre1">touch initData.js</strong>
</pre>
<p class="calibre2">In our case, we are building the publishing app so it will be a list of articles. In the following code, we have an example collection of two articles in a JSON format:</p>
<pre class="calibre22">
[ <br class="title-page-name"/>    { <br class="title-page-name"/>        articleId: '987654', <br class="title-page-name"/>        articleTitle: 'Lorem ipsum - article one', <br class="title-page-name"/>        articleContent: 'Here goes the content of the article' <br class="title-page-name"/>    }, <br class="title-page-name"/>    { <br class="title-page-name"/>        articleId: '123456', <br class="title-page-name"/>        articleTitle: 'Lorem ipsum - article two', <br class="title-page-name"/>        articleContent: 'Sky is the limit, the content goes here.' <br class="title-page-name"/>    } <br class="title-page-name"/>]
</pre>
<p class="calibre2">In general, we start from a mocked collection of articles--later we will add a feature to add more articles into MongoDB's collection, but for now we will stick with only two articles for the sake of brevity.</p>
<p class="calibre2">To list your localhost databases, open the Mongo shell by typing:</p>
<pre class="calibre22">
<strong class="calibre1">$ mongo</strong>
</pre>
<p class="calibre2">While in the Mongo shell, type:</p>
<pre class="calibre22">
<strong class="calibre1">show dbs</strong>
</pre>
<p class="calibre2">See the following for a full example:</p>
<pre class="calibre22">
<strong class="calibre1">Welcome to the MongoDB shell. </strong><br class="title-page-name"/><strong class="calibre1">For interactive help, type "help". </strong><br class="title-page-name"/><strong class="calibre1">For more comprehensive documentation, see </strong><br class="title-page-name"/><strong class="calibre1">    http://docs.mongodb.org/ </strong><br class="title-page-name"/><strong class="calibre1">Questions? Try the support group </strong><br class="title-page-name"/><strong class="calibre1">    http://groups.google.com/group/mongodb-user </strong><br class="title-page-name"/><strong class="calibre1">Server has startup warnings:  </strong><br class="title-page-name"/><strong class="calibre1">2016-02-25T13:31:05.896+0100 I CONTROL  [initandlisten]  </strong><br class="title-page-name"/><strong class="calibre1">2016-02-25T13:31:05.896+0100 I CONTROL  [initandlisten] ** WARNING: soft rlimits too low. Number of files is 256, should be at least 1000 </strong><br class="title-page-name"/><strong class="calibre1">&gt; show dbs </strong><br class="title-page-name"/><strong class="calibre1">local  0.078GB </strong><br class="title-page-name"/><strong class="calibre1">&gt;</strong>
</pre>
<p class="calibre2">In our example, it shows that we have one database in the localhost called <kbd class="calibre11">local</kbd>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Importing the articles to MongoDB</h1>
            

            <article>
                
<p class="calibre2">In the following, we will use Terminal (the command prompt) in order to import the articles into the database. Alternatively, you can use Robomongo to do it via the GUI as well:</p>
<pre class="calibre22">
<strong class="calibre1">mongoimport --db local --collection articles --jsonArray initData.js --host=127.0.0.1</strong>
</pre>
<div class="packt_infobox">Remember that you need a new tab in your Terminal and <kbd class="calibre23">mongo import</kbd> will work while you are in the Mongo shell (Don't confuse it with the <kbd class="calibre23">mongod</kbd> process).</div>
<p class="calibre2">Then you shall see the following information in your terminal:</p>
<pre class="calibre22">
<strong class="calibre1">connected to: 127.0.0.1</strong><br class="title-page-name"/><strong class="calibre1">imported 2 documents</strong>
</pre>
<p class="calibre2">In case you get the error <kbd class="calibre11">Failed: error connecting to db server: no reachable servers</kbd>, then make sure you have <kbd class="calibre11">mongod</kbd> running on the given host IP (<kbd class="calibre11">127.0.0.1</kbd>).</p>
<p class="calibre2">After importing those articles via the command line, you will also see this reflected in Robomongo:</p>
<div class="packt_figure"><img class="image-border3" src="../images/00008.jpeg"/></div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Server setup with Node.js and Express.js</h1>
            

            <article>
                
<p class="calibre2">Once we have our article collection in MongoDB, we can start working on our Express.js server in order to work on the collection.</p>
<p class="calibre2">First, we need an NPM project in our directory:</p>
<pre class="calibre22">
<strong class="calibre1">npm init --yes</strong>
</pre>
<p class="calibre2">The <kbd class="calibre11">--yes</kbd> flag means that we will use the default settings for <kbd class="calibre11">package.json</kbd>.</p>
<p class="calibre2">Next, let's create an <kbd class="calibre11">index.js</kbd> file in the <kbd class="calibre11">server</kbd> directory:</p>
<pre class="calibre22">
<strong class="calibre1">mkdir server</strong><br class="title-page-name"/><strong class="calibre1">cd server</strong><br class="title-page-name"/><strong class="calibre1">touch index.js</strong>
</pre>
<p class="calibre2">In <kbd class="calibre11">index.js</kbd>, we need to add a Babel/register in order to get better coverage of the ECMAScript 2015 and 2016 specification. This will enable us to support such structures as <kbd class="calibre11">async</kbd> and <kbd class="calibre11">generator</kbd> functions, which are not available in the current version of Node.js by default.</p>
<p class="calibre2">See the following for the <kbd class="calibre11">index.js</kbd> file content (we will install Babel's <kbd class="calibre11">dev</kbd> dependencies later):</p>
<pre class="calibre22">
// babel-core and babel-polyfill to be installed later in that  <br class="title-page-name"/>//chapter <br class="title-page-name"/>require('babel-core/register'); <br class="title-page-name"/>require('babel-polyfill'); <br class="title-page-name"/>require('./server');
</pre>
<p class="calibre2">Installing <kbd class="calibre11">express</kbd> and other initial dependencies:</p>
<pre class="calibre22">
<strong class="calibre1">npm i express@4.13.4  cors@2.7.1 body-parser@1.15.0--save</strong>
</pre>
<p class="calibre2">In the command, you can see <kbd class="calibre11">@4.13.4</kbd> after <kbd class="calibre11">express</kbd> and others. These are the versions of the libraries we're going to install, and we've picked it intentionally to make sure that it works well along side Falcor, but most probably you can skip these, and newer versions should work just as well.</p>
<p class="calibre2">We also need to install <kbd class="calibre11">dev</kbd> dependencies (we have spilled all <kbd class="calibre11">npm install</kbd> commands into separate for better readability):</p>
<pre class="calibre22">
<strong class="calibre1">npm i --save-dev babel@6.5.2 <br class="title-page-name"/>npm i --save-dev babel-core@6.6.5 <br class="title-page-name"/>npm i --save-dev babel-polyfill@6.6.1 <br class="title-page-name"/>npm i --save-dev babel-loader@6.2.4 <br class="title-page-name"/>npm i --save-dev babel-preset-es2015@6.6.0 <br class="title-page-name"/>npm i --save-dev babel-preset-react@6.5.0 <br class="title-page-name"/>npm i --save-dev babel-preset-stage-0@6.5.0</strong>
</pre>
<p class="calibre2">We need the <kbd class="calibre11">babel-preset-stage-0</kbd> is for ES7 features. The <kbd class="calibre11">babel-preset-es2015</kbd> and <kbd class="calibre11">babel-preset-react</kbd> are required for JSX and ES6 support.</p>
<p class="calibre2">Also, note that we install Babel to give our Node's server the ability to use ES6 features. We need to add the <kbd class="calibre11">.babelrc</kbd> file, so create the following:</p>
<pre class="calibre22">
<strong class="calibre1">$ [[[you are in the main project's directory]]] </strong><br class="title-page-name"/><strong class="calibre1">$ touch .babelrc </strong>
</pre>
<p class="calibre2">Then open the <kbd class="calibre11">.babelrc</kbd> file and fill it with the following content:</p>
<pre class="calibre22">
{ <br class="title-page-name"/>'presets': [ <br class="title-page-name"/>'es2015', <br class="title-page-name"/>'react', <br class="title-page-name"/>'stage-0' <br class="title-page-name"/>  ] <br class="title-page-name"/>}
</pre>
<p class="calibre2">Remember that the <kbd class="calibre11">.babelrc</kbd> is a hidden file. Probably the best way to edit the <kbd class="calibre11">.babelrc</kbd> is to open the whole project in a text editor such as Sublime Text. Then you should be able to see all hidden files.</p>
<p class="calibre2">We also need the following libraries:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre11">babel</kbd> and <kbd class="calibre11">babel-core/register</kbd>: This is the library for transpiling new ECMAScript functions into the existing version</li>
<li class="calibre15"><kbd class="calibre11">cors</kbd>: This module is responsible for creating cross-origin requests to our domain in an easy way</li>
<li class="calibre15"><kbd class="calibre11">body-parser</kbd>: This is the middleware for parsing the request's body</li>
</ul>
<p class="calibre2">After this, your project's file structure should look like the following:</p>
<pre class="calibre22">
&amp;boxvr;&amp;boxh;&amp;boxh; node_modules <br class="title-page-name"/>&amp;boxv;   &amp;boxvr;&amp;boxh;&amp;boxh; *** <br class="title-page-name"/>&amp;boxvr;&amp;boxh;&amp;boxh; initData.js <br class="title-page-name"/>&amp;boxvr;&amp;boxh;&amp;boxh; package.json <br class="title-page-name"/>&amp;boxur;&amp;boxh;&amp;boxh; server <br class="title-page-name"/>    &amp;boxur;&amp;boxh;&amp;boxh; index.js
</pre>
<p class="calibre2">The <kbd class="calibre11">***</kbd> is a wildcard, which means that there are files required for our project, but we don't list them here as it would be too long.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Working on our server (server.js)</h1>
            

            <article>
                
<p class="calibre2">We will start working on the <kbd class="calibre11">server/server.js</kbd> file, which is new to our project, so we need to create it first with the following commands, in the <kbd class="calibre11">server</kbd> directory of your project:</p>
<pre class="calibre22">
<strong class="calibre1">touch server.js</strong>
</pre>
<p class="calibre2">The content for the <kbd class="calibre11">server/server.js</kbd> file is as follows:</p>
<pre class="calibre22">
import http from 'http'; <br class="title-page-name"/>import express from 'express'; <br class="title-page-name"/>import cors from 'cors'; <br class="title-page-name"/>import bodyParser from 'body-parser'; <br class="title-page-name"/><br class="title-page-name"/>const app = express(); <br class="title-page-name"/>app.server = http.createServer(app); <br class="title-page-name"/><br class="title-page-name"/>// CORS - 3rd party middleware <br class="title-page-name"/>app.use(cors()); <br class="title-page-name"/><br class="title-page-name"/>// This is required by falcor-express middleware  <br class="title-page-name"/>//to work correctly with falcor-browser <br class="title-page-name"/>app.use(bodyParser.json({extended: false})); <br class="title-page-name"/><br class="title-page-name"/>app.get('/', (req, res) =&gt; res.send('Publishing App Initial Application!')); <br class="title-page-name"/><br class="title-page-name"/>app.server.listen(process.env.PORT || 3000); <br class="title-page-name"/>console.log(&amp;grave;Started on port ${app.server.address().port}&amp;grave;); <br class="title-page-name"/>export default app;
</pre>
<p class="calibre2">These files use the <kbd class="calibre11">babel/register</kbd> library so that we can use ES6 syntax in our code. In the <kbd class="calibre11">index.js</kbd> file, we have an <kbd class="calibre11">http</kbd> module which comes from Node.js (<a href="https://nodejs.org/api/http.html#http_http" class="calibre6"><span>https://nodejs.org/api/http.html#http_http</span></a>). Next, we have <kbd class="calibre11">express</kbd>, <kbd class="calibre11">cors</kbd>, and <kbd class="calibre11">body-parser</kbd>.</p>
<p class="calibre2">Cors is middleware for dynamically or statically enabling <strong class="calibre1">cross-origin resource sharing</strong> (<strong class="calibre1">CORS</strong>) in Express applications--it will be useful in our development environment (we will delete it later for our production server).</p>
<p class="calibre2">Body-parser is middleware for HTTP's body parsing. It has some fancy settings that help us build the app faster.</p>
<p class="calibre2">This how our app looks at this stage of our development:</p>
<div class="packt_figure"><img class="image-border4" src="../images/00009.jpeg"/></div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Mongoose and Express.js</h1>
            

            <article>
                
<p class="calibre2">At the moment, we have a simple working Express.js server. Now we have to add Mongoose to our project:</p>
<pre class="calibre22">
<strong class="calibre1">npm i mongoose@4.4.5 --save</strong>
</pre>
<p class="calibre2">Once we have installed Mongoose and a running MongoDB database in the background, we can import it to our <kbd class="calibre11">server.js</kbd> file and do the coding:</p>
<pre class="calibre22">
import http from 'http'; <br class="title-page-name"/>import express from 'express'; <br class="title-page-name"/>import cors from 'cors'; <br class="title-page-name"/>import bodyParser from 'body-parser'; <br class="title-page-name"/>import mongoose from 'mongoose'; <br class="title-page-name"/><br class="title-page-name"/>mongoose.connect('mongodb://localhost/local'); <br class="title-page-name"/><br class="title-page-name"/>const articleSchema = { <br class="title-page-name"/>    articleTitle:String, <br class="title-page-name"/>    articleContent:String <br class="title-page-name"/>}; <br class="title-page-name"/><br class="title-page-name"/>const Article = mongoose.model('Article', articleSchema,  'articles');<br class="title-page-name"/>const app = express(); <br class="title-page-name"/>app.server = http.createServer(app); <br class="title-page-name"/><br class="title-page-name"/>// CORS - 3rd party middleware <br class="title-page-name"/>app.use(cors()); <br class="title-page-name"/><br class="title-page-name"/>// This is required by falcor-express middleware to work correctly  <br class="title-page-name"/>//with falcor-browser <br class="title-page-name"/>app.use(bodyParser.json({extended: false})); <br class="title-page-name"/><br class="title-page-name"/>app.use(express.static('dist')); <br class="title-page-name"/><br class="title-page-name"/>app.get('/', (req, res) =&gt; {  <br class="title-page-name"/>    Article.find( (err, articlesDocs) =&gt; { <br class="title-page-name"/>      const ourArticles = articlesDocs.map((articleItem) =&gt; { <br class="title-page-name"/>        return &amp;grave;&lt;h2&gt;${articleItem.articleTitle}&lt;/h2&gt;            <br class="title-page-name"/>        ${articleItem.articleCon tent}&amp;grave;; <br class="title-page-name"/>      }).join('&lt;br/&gt;'); <br class="title-page-name"/><br class="title-page-name"/>      res.send(&amp;grave;&lt;h1&gt;Publishing App Initial Application!&lt;/h1&gt;        <br class="title-page-name"/>      ${ourArticles}&amp;grave;); <br class="title-page-name"/>    }); <br class="title-page-name"/>}); <br class="title-page-name"/><br class="title-page-name"/>app.server.listen(process.env.PORT || 3000); <br class="title-page-name"/>console.log(&amp;grave;Started on port ${app.server.address().port}&amp;grave;); <br class="title-page-name"/>export default app;
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">A summary of how to run the project</h1>
            

            <article>
                
<p class="calibre2">Make sure that you have MongoDB running in the background on your machine using the following command:</p>
<pre class="calibre22">
<strong class="calibre1">mongod</strong>
</pre>
<p class="calibre2">After you run the <kbd class="calibre11">mongod</kbd> command in your terminal (or PowerShell on Windows), then you should see something like the following in your console:</p>
<div class="packt_figure"><img class="image-border5" src="../images/00010.jpeg"/></div>
<p class="calibre2">Before you run the server, make sure the <kbd class="calibre11">devDependencies</kbd> in your <kbd class="calibre11">package.json</kbd> file look like the following:</p>
<pre class="calibre22">
"devDependencies": { <br class="title-page-name"/>"babel": "6.5.2", <br class="title-page-name"/>"babel-core": "6.6.5", <br class="title-page-name"/>"babel-loader": "6.2.4", <br class="title-page-name"/>"babel-polyfill": "6.6.1", <br class="title-page-name"/>"babel-preset-es2015": "6.6.0", <br class="title-page-name"/>"babel-preset-react": "6.5.0", <br class="title-page-name"/>"babel-preset-stage-0": "6.5.0" <br class="title-page-name"/>  }
</pre>
<p class="calibre2">Before you run the server, make sure that the dependencies in your <kbd class="calibre11">package.json</kbd> look like the following:</p>
<pre class="calibre22">
"dependencies": { <br class="title-page-name"/>"body-parser": "1.15.0", <br class="title-page-name"/>"cors": "2.7.1", <br class="title-page-name"/>"express": "4.13.4", <br class="title-page-name"/>"mongoose": "4.4.5" <br class="title-page-name"/>  }
</pre>
<p class="calibre2">In the main directory, run Node with the following:</p>
<pre class="calibre22">
<strong class="calibre1">node server/index.js </strong>
</pre>
<p class="calibre2">After that, your terminal should show something like the following:</p>
<pre class="calibre22">
<strong class="calibre1">$ node server/index.js</strong><br class="title-page-name"/><strong class="calibre1">Started on port 3000</strong>
</pre>
<div class="packt_figure"><img class="image-border6" src="../images/00011.jpeg"/></div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Redux basic concepts</h1>
            

            <article>
                
<p class="calibre2">In this section, we will cover only the most basic concepts of Redux that will help us make our simple publishing app. The app will only be in <em class="calibre21">read-only</em> mode for this chapter; later in the book we will add more functionality such as adding/editing an article. You will discover all the important rules and principles about Redux in the later chapters.</p>
<p class="calibre2">Basic topics covered are:</p>
<ul class="calibre14">
<li class="calibre15">What is a state tree?</li>
<li class="calibre15">How immutability works in Redux</li>
<li class="calibre15">The concept and basic use of reducers</li>
</ul>
<p class="calibre2">Let's start with the basics.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The single immutable state tree</h1>
            

            <article>
                
<p class="calibre2">The most important principle of Redux is that you are going to represent the whole state of your application as a single JavaScript object.</p>
<p class="calibre2">All changes (actions) in Redux are explicit, so you can track a history of all your actions through the application with a dev tool.</p>
<div class="packt_figure"><img class="image-border7" src="../images/00012.jpeg"/></div>
<p class="calibre2">The preceding screenshot is a simple, example dev tool use case that you will use in your development environment. It will help you to track the changes of state in your app. The example shows how we have incremented the counter value in our state by <em class="calibre21">+1</em>, three times. Of course, our publishing app structure will be much more complicated than this example. You will learn more about that dev tool later in the book.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Immutability - actions and state tree are read-only</h1>
            

            <article>
                
<p class="calibre2">As Redux bases its concepts on functional programming paradigms, you cannot modify/mutate the values in your state tree in the same way that you can for Facebook's (and other) FLUX implementations.</p>
<p class="calibre2">As with other FLUX implementations, an action is a plain object that describes the change--like adding an article (in the following code we mock the payload for the sake of brevity):</p>
<pre class="calibre22">
{ <br class="title-page-name"/>    type: 'ADD_ARTICLE', <br class="title-page-name"/>    payload: '_____HERE_GOES_INFORMATION_ABOUT_THE_CHANGE_____' <br class="title-page-name"/>}
</pre>
<p class="calibre2">An action is a minimal representation of the change for our app state tree. Let's prepare actions for our publishing app.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Pure and impure functions</h1>
            

            <article>
                
<p class="calibre2">A<strong class="calibre1"> pure function</strong> is a function that doesn't have any side effects, such as for example, I/O (reading a file or an HTTP request). <strong class="calibre1">Impure functions</strong> have side effects so, for example, if you make a call to the HTTP request, it can return different values for exactly the same arguments <em class="calibre21">Y,Z (function(X,Y))</em> because an endpoint is returning us a random value, or could be down because of a server error.</p>
<p class="calibre2">Pure functions are always predictable for the same <em class="calibre21">X,Y</em> arguments. In Redux, we use only pure functions in reducers and actions (otherwise Redux's <kbd class="calibre11">lib</kbd> won't work properly).</p>
<p class="calibre2">In this book, you will learn the whole structure and where to make API calls. So if you follow the book, then you won't have to worry too much about that principle in Redux.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The reducer function</h1>
            

            <article>
                
<p class="calibre2">Reducers from Redux can be compared to a single store from Facebook's Flux. What is important is that a reducer always takes a previous state and returns a new reference to a new object (with the use of <kbd class="calibre11">Object.assign</kbd> and others like that), so we can have immutable JS helping us to build a more predictable state of our application in comparison to older Flux implementations that mutate variables in the store.</p>
<p class="calibre2">Thus, creating a new reference is optimal because Redux uses old references to values from reducers that didn't change. This means that even if each action creates a whole new object via a reducer then the values that don't change have a previous reference in the memory so we don't overuse the computation power of the machine. Everything is fast.</p>
<p class="calibre2">In our app, we will have an article reducer that will help us to list, add, edit, and delete our articles from the view layer.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">First reducer and webpack config</h1>
            

            <article>
                
<p class="calibre2">First, let's create a reducer for our publication app:</p>
<pre class="calibre22">
<strong class="calibre1">mkdir src </strong><br class="title-page-name"/><strong class="calibre1">cd src </strong><br class="title-page-name"/><strong class="calibre1">mkdir reducers </strong><br class="title-page-name"/><strong class="calibre1">cd reducers </strong><br class="title-page-name"/><strong class="calibre1">touch article.js </strong>
</pre>
<p class="calibre2">So, our first reducer's location is <kbd class="calibre11">src/reducers/article.js</kbd> and the content of our <kbd class="calibre11">reducers/article.js</kbd> is as follows:</p>
<pre class="calibre22">
const articleMock = { <br class="title-page-name"/>'987654': { <br class="title-page-name"/>        articleTitle: 'Lorem ipsum - article one', <br class="title-page-name"/>        articleContent: 'Here goes the content of the article' <br class="title-page-name"/>    }, <br class="title-page-name"/>'123456': { <br class="title-page-name"/>        articleTitle: 'Lorem ipsum - article two', <br class="title-page-name"/>        articleContent: 'Sky is the limit, the content goes here.' <br class="title-page-name"/>    } <br class="title-page-name"/>}; <br class="title-page-name"/><br class="title-page-name"/>const article = (state = articleMock, action) =&gt; { <br class="title-page-name"/>    switch (action.type) { <br class="title-page-name"/>        case 'RETURN_ALL_ARTICLES': <br class="title-page-name"/>            return Object.assign({}, state); <br class="title-page-name"/>        default: <br class="title-page-name"/>            return state; <br class="title-page-name"/>    } <br class="title-page-name"/>} <br class="title-page-name"/>export default article;
</pre>
<p class="calibre2">In the preceding code, we have our <kbd class="calibre11">articleMock</kbd> kept in the browser memory (it's the same as in <kbd class="calibre11">initData.js</kbd>)--later, we will fetch this data from our backend database.</p>
<p class="calibre2">The arrow function, <kbd class="calibre11">const article</kbd> is getting <kbd class="calibre11">action.type</kbd> which will come from constants (we will create them later) in the same way that Facebook's FLUX implementation works.</p>
<p class="calibre2">For the default <kbd class="calibre11">return</kbd> in the <kbd class="calibre11">switch</kbd> statement, we provide the state from <kbd class="calibre11">state = articleMock</kbd> (return state; part above). This will return the initial state of our publishing app at first startup before any other action occurs. To be exact, the default in our case will do exactly the same as the <kbd class="calibre11">RETURN_ALL_ARTICLES</kbd> action before we start fetching data from the backend (after the articles' fetching mechanism from backend is implemented; then the default will return an empty object).</p>
<p class="calibre2">Because of our webpack configuration (described here), we need <kbd class="calibre11">index.html</kbd> in <kbd class="calibre11">dist</kbd>. Let's create a <kbd class="calibre11">dist/index.html</kbd> file:</p>
<pre class="calibre22">
<strong class="calibre1">pwd </strong><br class="title-page-name"/><strong class="calibre1">/Users/przeor/Desktop/React-Convention-Book/src/reducers </strong><br class="title-page-name"/><strong class="calibre1">cd ../.. </strong><br class="title-page-name"/><strong class="calibre1">mkdir dist </strong><br class="title-page-name"/><strong class="calibre1">cd dist </strong><br class="title-page-name"/><strong class="calibre1">touch index.html </strong>
</pre>
<p class="calibre2">The <kbd class="calibre11">dist/index.html</kbd> file's content is as follows:</p>
<pre class="calibre22">
&lt;!doctype html&gt; <br class="title-page-name"/>&lt;html lang="en"&gt; <br class="title-page-name"/>&lt;head&gt; <br class="title-page-name"/>&lt;title&gt;Publishing App&lt;/title&gt; <br class="title-page-name"/>&lt;meta charset="utf-8"&gt; <br class="title-page-name"/><br class="title-page-name"/>&lt;/head&gt; <br class="title-page-name"/>&lt;body&gt; <br class="title-page-name"/>&lt;div id="publishingAppRoot"&gt;&lt;/div&gt; <br class="title-page-name"/><br class="title-page-name"/>&lt;script src="app.js"&gt;&lt;/script&gt; <br class="title-page-name"/>&lt;/body&gt; <br class="title-page-name"/>&lt;/html&gt;
</pre>
<p class="calibre2">We have an article <kbd class="calibre11">reducer</kbd> and <kbd class="calibre11">dist/index.html</kbd>, but before we start building our Redux's publishing app, we need to configure webpack for our built automation.</p>
<p class="calibre2">Install webpack first (you may need <kbd class="calibre11">sudo</kbd> root access for it):</p>
<pre class="calibre22">
<strong class="calibre1">npm i --save-dev webpack@1.12.14 webpack-dev-server@1.14.1 </strong>
</pre>
<p class="calibre2">Then, in the main directory next to the <kbd class="calibre11">package.json</kbd> and <kbd class="calibre11">initData.js</kbd> files, input the following:</p>
<pre class="calibre22">
<strong class="calibre1">touch webpack.config.js</strong>
</pre>
<p class="calibre2">Then create webpack configs:</p>
<pre class="calibre22">
module.exports = { <br class="title-page-name"/>    entry: ['babel-polyfill', './src/app.js'], <br class="title-page-name"/>    output: { <br class="title-page-name"/>        path: './dist', <br class="title-page-name"/>        filename: 'app.js', <br class="title-page-name"/>        publicPath: '/' <br class="title-page-name"/>    }, <br class="title-page-name"/>    devServer: { <br class="title-page-name"/>        inline: true, <br class="title-page-name"/>        port: 3000, <br class="title-page-name"/>        contentBase: './dist' <br class="title-page-name"/>    }, <br class="title-page-name"/>    module: { <br class="title-page-name"/>        loaders: [ <br class="title-page-name"/>            { <br class="title-page-name"/>                test: /.js$/, <br class="title-page-name"/>                exclude: /(node_modules|bower_components)/, <br class="title-page-name"/>                loader: 'babel', <br class="title-page-name"/>        query: { <br class="title-page-name"/>                    presets: ['es2015', 'stage-0', 'react'] <br class="title-page-name"/>                } <br class="title-page-name"/>            } <br class="title-page-name"/>        ] <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">Simply, webpack config says that the entry of the CommonJS module is at entry <kbd class="calibre11">'./src/app.js'</kbd>. webpack builds a whole app following all imports from the <kbd class="calibre11">app.js</kbd> and the final output is located at path <kbd class="calibre11">'./dist'</kbd>. Our app that is located at <kbd class="calibre11">contentBase: './dist'</kbd> will live at port <kbd class="calibre11">3000</kbd>. We also configure the use of ES2015 and React so that webpack will compile ES2015 into ES5 and React's JSX into JavaScript for us. If you are interested in webpack's configuration options, then read its documentation.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The rest of the important dependencies installation and npm dev script</h1>
            

            <article>
                
<p class="calibre2">Install the Babel tools that are used by webpack (check the config file):</p>
<pre class="calibre22">
<strong class="calibre1">npm i --save react@0.14.7 react-dom@0.14.7 react-redux@4.4.0 redux@3.3.1</strong>
</pre>
<p class="calibre2">We also need to update our <kbd class="calibre11">package.json</kbd> file (add <kbd class="calibre11">scripts</kbd>):</p>
<pre class="calibre22">
"scripts": { <br class="title-page-name"/>"dev": "webpack-dev-server" <br class="title-page-name"/>  },
</pre>
<p class="calibre2">Our complete <kbd class="calibre11">package.json</kbd> should look like the following, with all frontend dependencies:</p>
<pre class="calibre22">
01{ <br class="title-page-name"/>"name": "project", <br class="title-page-name"/>"version": "1.0.0", <br class="title-page-name"/>"description": "", <br class="title-page-name"/>"scripts": { <br class="title-page-name"/>"dev": "webpack-dev-server" <br class="title-page-name"/>  }, <br class="title-page-name"/>"dependencies": { <br class="title-page-name"/>"body-parser": "1.15.0", <br class="title-page-name"/>"cors": "2.7.1", <br class="title-page-name"/>"express": "4.13.4", <br class="title-page-name"/>"mongoose": "4.4.5", <br class="title-page-name"/>"react": "0.14.7", <br class="title-page-name"/>"react-dom": "0.14.7", <br class="title-page-name"/>"react-redux": "4.4.0", <br class="title-page-name"/>"redux": "3.3.1" <br class="title-page-name"/>  }, <br class="title-page-name"/>"devDependencies": { <br class="title-page-name"/>"babel": "6.5.2", <br class="title-page-name"/>"babel-core": "6.6.5", <br class="title-page-name"/>"babel-loader": "6.2.4", <br class="title-page-name"/>"babel-polyfill": "6.6.1", <br class="title-page-name"/>"babel-preset-es2015": "6.6.0", <br class="title-page-name"/>"babel-preset-react": "6.5.0", <br class="title-page-name"/>"babel-preset-stage-0": "6.5.0", <br class="title-page-name"/>"webpack": "1.12.14", <br class="title-page-name"/>"webpack-dev-server": "1.14.1" <br class="title-page-name"/>  } <br class="title-page-name"/>}
</pre>
<div class="packt_infobox">As you may realize, the mentioned <kbd class="calibre23">package.json</kbd> doesn't have the <kbd class="calibre23">^</kbd> signs as we want to use the exact versions of each package in order to make sure that all our packages are installed with the correct and exact version given in the package. Otherwise, you may have some difficulties, for example, if you add <kbd class="calibre23">"mongoose": "4.4.5"</kbd>, with the <kbd class="calibre23">^</kbd> then it will install a newer version that causes some additional warnings in the console. Let's stick to the versions mentioned in the book in order to avoid unnecessary problems with the app that we are building. We want to avoid NPM dependencies hell at all cost.</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Working on src/app.js and src/layouts/PublishingApp.js</h1>
            

            <article>
                
<p class="calibre2">Let's create our <kbd class="calibre11">app.js</kbd> file, where the main part of our app will live at <kbd class="calibre11">src/app.js</kbd>:</p>
<pre class="calibre22">
<strong class="calibre1">//[[your are in the main directory of the project]]<br class="title-page-name"/></strong><strong class="calibre1">cd src</strong><br class="title-page-name"/><strong class="calibre1">touch app.js</strong>
</pre>
<p class="calibre2">The content of our new <kbd class="calibre11">src/app.js</kbd> file is the following:</p>
<pre class="calibre22">
import React from 'react'; <br class="title-page-name"/>import { render } from 'react-dom'; <br class="title-page-name"/>import { Provider } from 'react-redux'; <br class="title-page-name"/>import { createStore } from 'redux'; <br class="title-page-name"/>import article from './reducers/article'; <br class="title-page-name"/>import PublishingApp from './layouts/PublishingApp'; <br class="title-page-name"/><br class="title-page-name"/>const store = createStore(article); <br class="title-page-name"/><br class="title-page-name"/>render( <br class="title-page-name"/>&lt;Provider store={store}&gt; <br class="title-page-name"/>&lt;PublishingApp /&gt; <br class="title-page-name"/>&lt;/Provider&gt;, <br class="title-page-name"/>    document.getElementById('publishingAppRoot') <br class="title-page-name"/>);
</pre>
<p class="calibre2">The new part is the <kbd class="calibre11">store = createStore(article)</kbd> part--this utility from Redux lets you keep an application state object, dispatch an action, and allows you to give a reducer as an argument that tells you how the app is updated with actions.</p>
<p class="calibre2">The <kbd class="calibre11">react-redux</kbd> is a useful binding of Redux into React (so we will write less code and be more productive):</p>
<pre class="calibre22">
&lt;Provider store&gt;
</pre>
<p class="calibre2">The <kbd class="calibre11">Provider store</kbd> helps us to make the Redux store available to the <kbd class="calibre11">connect()</kbd> calls in the child components (as shown here):</p>
<pre class="calibre22">
connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])
</pre>
<p class="calibre2"><kbd class="calibre11">connect</kbd> will be used in any component that has to listen to the reducer's changes in our app. You will see how to use it later in this chapter.</p>
<p class="calibre2">For the store, we use <kbd class="calibre11">const store = createStore(article)</kbd>--just for the sake of brevity, I will mention that there are several methods in the store that we will use in the next steps of building our app from scratch:</p>
<pre class="calibre22">
store.getState();
</pre>
<p class="calibre2">The <kbd class="calibre11">getState</kbd> function gives you the current state of the application:</p>
<pre class="calibre22">
store.dispatch({ type: 'RETURN_ALL_ARTICLES' });
</pre>
<p class="calibre2">The <kbd class="calibre11">dispatch</kbd> function can help you change the state of your app:</p>
<pre class="calibre22">
store.subscribe(() =&gt; { <br class="title-page-name"/><br class="title-page-name"/>});
</pre>
<p class="calibre2">Subscribe allows you register a callback that Redux will call each time an action has been dispatched, so the view layer can learn about the change in the application state and refresh its view.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Wrapping up React-Redux application</h1>
            

            <article>
                
<p class="calibre2">Let's finish our first React-Redux app. For a summary, let's see our current directory structure:</p>
<pre class="calibre22">
&amp;boxvr;&amp;boxh;&amp;boxh; dist <br class="title-page-name"/>&amp;boxv;   &amp;boxur;&amp;boxh;&amp;boxh; index.html <br class="title-page-name"/>&amp;boxvr;&amp;boxh;&amp;boxh; initData.js <br class="title-page-name"/>&amp;boxvr;&amp;boxh;&amp;boxh; node_modules <br class="title-page-name"/>&amp;boxv;   &amp;boxvr;&amp;boxh;&amp;boxh; ********** (A LOT OF LIBRARIES HERE) <br class="title-page-name"/>&amp;boxvr;&amp;boxh;&amp;boxh; package.json <br class="title-page-name"/>&amp;boxvr;&amp;boxh;&amp;boxh; server <br class="title-page-name"/>&amp;boxv;   &amp;boxvr;&amp;boxh;&amp;boxh; index.js <br class="title-page-name"/>&amp;boxv;   &amp;boxur;&amp;boxh;&amp;boxh; server.js <br class="title-page-name"/>&amp;boxvr;&amp;boxh;&amp;boxh; src <br class="title-page-name"/>&amp;boxv;   &amp;boxvr;&amp;boxh;&amp;boxh; app.js <br class="title-page-name"/>&amp;boxv;   &amp;boxur;&amp;boxh;&amp;boxh; reducers <br class="title-page-name"/>&amp;boxv;       &amp;boxur;&amp;boxh;&amp;boxh; article.js <br class="title-page-name"/>&amp;boxur;&amp;boxh;&amp;boxh; webpack.config.js
</pre>
<p class="calibre2">Now we need to create the main view of our app. We will put this into the layout directory in our first version:</p>
<pre class="calibre22">
<strong class="calibre1">pwd</strong><br class="title-page-name"/><strong class="calibre1">/Users/przeor/Desktop/React-Convention-Book/src</strong><br class="title-page-name"/><strong class="calibre1">mkdir layouts</strong><br class="title-page-name"/><strong class="calibre1">cd layouts</strong><br class="title-page-name"/><strong class="calibre1">touch PublishingApp.js</strong>
</pre>
<p class="calibre2">The content of <kbd class="calibre11">PublishingApp.js</kbd> is:</p>
<pre class="calibre22">
import React from 'react'; <br class="title-page-name"/>import { connect } from 'react-redux'; <br class="title-page-name"/><br class="title-page-name"/>const mapStateToProps = (state) =&gt; ({ <br class="title-page-name"/>  ...state <br class="title-page-name"/>}); <br class="title-page-name"/><br class="title-page-name"/>const mapDispatchToProps = (dispatch) =&gt; ({ <br class="title-page-name"/>}); <br class="title-page-name"/><br class="title-page-name"/>class PublishingApp extends React.Component { <br class="title-page-name"/>  constructor(props) { <br class="title-page-name"/>    super(props); <br class="title-page-name"/>  } <br class="title-page-name"/>  render () { <br class="title-page-name"/>    console.log(this.props);     <br class="title-page-name"/>    return ( <br class="title-page-name"/>&lt;div&gt; <br class="title-page-name"/>          Our publishing app <br class="title-page-name"/>&lt;/div&gt; <br class="title-page-name"/>    ); <br class="title-page-name"/>  } <br class="title-page-name"/>} <br class="title-page-name"/>export default connect(mapStateToProps, mapDispatchToProps)(PublishingApp);
</pre>
<p class="calibre2">The preceding introduces the ES7 syntax <kbd class="calibre11">...</kbd> next to <kbd class="calibre11">...</kbd>:</p>
<pre class="calibre22">
const mapStateToProps = (state) =&gt; ({ <br class="title-page-name"/>  ...state <br class="title-page-name"/>});
</pre>
<p class="calibre2"><kbd class="calibre11">...</kbd> is a spread operator that is well described in Mozilla's documentation as; <em class="calibre21">an expression to be expanded in places where multiple arguments (for function calls) or multiple elements (for array literals) are expected</em>. In our case, this  <kbd class="calibre11">...</kbd> operator spreads one object state into a second one (in our case, empty object <kbd class="calibre11">{ }</kbd>). It's written like this here because, in future, we will specify multiple reducers that have to be mapped from our app's state into the <kbd class="calibre11">this.props</kbd> component.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Finishing our first static publishing app</h1>
            

            <article>
                
<p class="calibre2">The last thing to <span>do</span> in our static app is to render the articles that come from <kbd class="calibre11">this.props</kbd>.</p>
<p class="calibre2">Thanks to Redux, the object mocked in the reducer is available, so if you check <kbd class="calibre11">console.log(this.props)</kbd> in the render function of <kbd class="calibre11">PublishingApp.js</kbd>, then you will be able to access our <kbd class="calibre11">articles</kbd> object:</p>
<pre class="calibre22">
const articleMock = { <br class="title-page-name"/>'987654': { <br class="title-page-name"/>        articleTitle: 'Lorem ipsum - article one', <br class="title-page-name"/>        articleContent: 'Here goes the content of the article' <br class="title-page-name"/>    }, <br class="title-page-name"/>"123456": { <br class="title-page-name"/>        articleTitle: 'Lorem ipsum - article two', <br class="title-page-name"/>        articleContent: 'Sky is the limit, the content goes here.' <br class="title-page-name"/>    } <br class="title-page-name"/>};
</pre>
<p class="calibre2">In our case, we need to change the React's render function, as follows (in <kbd class="calibre11">src/layouts/PublishingApp.js</kbd>):</p>
<pre class="calibre22">
 render () { <br class="title-page-name"/>    let articlesJSX = []; <br class="title-page-name"/><br class="title-page-name"/>    for(let articleKey in this.props) { <br class="title-page-name"/>        const articleDetails = this.props[articleKey]; <br class="title-page-name"/>        const currentArticleJSX = ( <br class="title-page-name"/>          &lt;div key={articleKey}&gt; <br class="title-page-name"/>          &lt;h2&gt;{articleDetails.articleTitle}&lt;/h2&gt; <br class="title-page-name"/>          &lt;h3&gt;{articleDetails.articleContent}&lt;/h3&gt; <br class="title-page-name"/>          &lt;/div&gt;); <br class="title-page-name"/><br class="title-page-name"/>        articlesJSX.push(currentArticleJSX); <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    return ( <br class="title-page-name"/>      &lt;div&gt; <br class="title-page-name"/>      &lt;h1&gt;Our publishing app&lt;/h1&gt; <br class="title-page-name"/>          {articlesJSX} <br class="title-page-name"/>      &lt;/div&gt; <br class="title-page-name"/>    ); <br class="title-page-name"/>  }
</pre>
<p class="calibre2">In the preceding code snippet, we are iterating <kbd class="calibre11">for(let articleKey in this.props)</kbd> over the article <kbd class="calibre11">Mock</kbd> object (passed from the reducer's state in <kbd class="calibre11">this.props</kbd>) and creating an array of articles (in JSX) with <kbd class="calibre11">articlesJSX.push(currentArticleJSX);</kbd>. After it is created, then we will have added the <kbd class="calibre11">articlesJSX</kbd> into the <kbd class="calibre11">return</kbd> statement:</p>
<pre class="calibre22">
&lt;div&gt; <br class="title-page-name"/>&lt;h1&gt;Our publishing app&lt;/h1&gt; <br class="title-page-name"/>          {articlesJSX} <br class="title-page-name"/>&lt;/div&gt;
</pre>
<p class="calibre2">This comment will start your project on port <kbd class="calibre11">3000</kbd>:</p>
<pre class="calibre22">
<strong class="calibre1">npm run dev</strong>
</pre>
<p class="calibre2">After you check <kbd class="calibre11">localhost:3000</kbd>, the new static Redux app should look as shown in the following screenshot:</p>
<div class="packt_figure"><img class="image-border8" src="../images/00013.jpeg"/></div>
<p class="calibre2">Great, so we have a static app in Redux! It's time to fetch data from our MongoDB database using Falcor.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Falcor's basic concepts</h1>
            

            <article>
                
<p class="calibre2">Falcor is like a glue between:</p>
<ul class="calibre14">
<li class="calibre15">Backend and its database structure (remember importing <kbd class="calibre11">initData.js</kbd> into MongoDB)</li>
<li class="calibre15">Frontend Redux single state tree container</li>
</ul>
<p class="calibre2">It glues the pieces in a way that is much more effective than building an old-fashioned REST API for a single-page application.</p>
<p class="calibre2">Like the <em class="calibre21">Redux basic concepts</em> section, in this one we will learn only the most basic concepts of Falcor and they will help us build a simple full-stack application in <em class="calibre21">read-only</em> mode. Later in the book, you will learn how to make an add/edit article with Falcor.</p>
<p class="calibre2">We will focus on the most important aspects:</p>
<ul class="calibre14">
<li class="calibre15">What is Falcor's model?</li>
<li class="calibre15">Retrieving values from Falcor (frontend and backend)</li>
<li class="calibre15">Concepts and basic use of JSON graphs</li>
<li class="calibre15">Concepts and basic use of sentinels</li>
<li class="calibre15">How to retrieve data from the backend</li>
<li class="calibre15">How to configure our first route with middleware for Express.js called<br class="title-page-name"/>
<kbd class="calibre11">falcor-router</kbd></li>
</ul>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">What is Falcor and why do we need it in our full-stack publishing app?</h1>
            

            <article>
                
<p class="calibre2">Let's first consider what the difference is between web pages and web applications:</p>
<ul class="calibre14">
<li class="calibre15">When the <strong class="calibre1">World Wide Web</strong> (<strong class="calibre1">WWW</strong>) was invented, web pages served small amounts of large resources (such as HTML, PDF, and PNG files). For example, you could request a PDF, video, or text file from a server.</li>
<li class="calibre15">Since <em class="calibre21">circa 2008</em>, the development of web apps has been getting more and more popular. Web applications serve large amounts of small resources. What does it mean for us? You have a lot of small REST API calls to the server using AJAX calls. The old approach of many API requests creates latency, which slows down the mobile/web app.</li>
</ul>
<p class="calibre2">Why do we use old REST API requests (as we did in 2005) in apps written in 2016 and later? This is where Falcor shines; it solves the problem of latency and tight coupling of backend to frontend.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Tight coupling and latency versus one model everywhere</h1>
            

            <article>
                
<p class="calibre2">If you are familiar with frontend development, you know how to make requests to an API. This old way of doing things always forces you to tight-couple the backend API with frontend API utilities. It's always like that:</p>
<ol class="calibre17">
<li value="1" class="calibre15">You make an API endpoint like <a href="https://applicationDomain.com/api/recordDetails?id=92" class="calibre6"><span>https://applicationDomain.com/api/recordDetails?id=92</span></a>.</li>
<li value="2" class="calibre15">You consume the data with HTTP API requests on the frontend:</li>
</ol>
<pre class="calibre22">
        { <br class="title-page-name"/>            id: '92', <br class="title-page-name"/>            title: 'example title', <br class="title-page-name"/>            content: 'example content' <br class="title-page-name"/>        }
</pre>
<p class="calibre2">In large applications, it's hard to maintain real DRY RESTful APIs, and this problem causes plenty of endpoints that are not optimized, so the frontend sometimes has to do many round trips in order to fetch the data required for a certain view (and sometimes it fetches much more than it needs, which causes even more latency for the end user of our application).</p>
<p class="calibre2">Imagine that you have a large application with over 50 different API endpoints. After the first version of your application is finished, your client or boss finds a better way to structure the user flow in the app. What does this mean? That you have to work on changing both frontend and backend endpoints in order to satisfy the changes in the user interface layer. This is called tight coupling between frontend and backend.</p>
<p class="calibre2">What does Falcor bring to this situation to improve on those two areas that cause the inefficiency in working with RESTful APIs? The answer is one model everywhere.</p>
<p class="calibre2">It would be super easy to build your web applications if all your data was accessible in memory, on the client.</p>
<p class="calibre2">Falcor provides utilities that help you feel that all your data is at your fingertips without coding backend API endpoints and client-side consuming utilities.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">No more tight coupling on client and server side</h1>
            

            <article>
                
<p class="calibre2">Falcor helps you represent all of your app's data as one virtual JSON model on the server.</p>
<p class="calibre2">When programming client side, Falcor makes you feel as if the whole JSON model of your application is reachable locally, and allows you to read data the same way as you would from an in-memory JSON--you will learn it very soon!</p>
<p class="calibre2">Because of Falcor's library for browsers and the <kbd class="calibre11">falcor-express</kbd> middleware, you can retrieve your data from the model on-demand, from the cloud.</p>
<p class="calibre2">Falcor transparently handles all the network communication and keeps your client-side app in sync with the server and databases.</p>
<p class="calibre2">In this chapter, we will also learn how to use <kbd class="calibre11">falcor-router</kbd>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Client-side Falcor</h1>
            

            <article>
                
<p class="calibre2">Let's install Falcor from NPM first:</p>
<pre class="calibre22">
<strong class="calibre1">pwd </strong><br class="title-page-name"/><strong class="calibre1">/Users/przeor/Desktop/React-Convention-Book </strong><br class="title-page-name"/><strong class="calibre1">npm i --save falcor@0.1. </strong><br class="title-page-name"/><strong class="calibre1">16 falcor-http-datasource@0.1.3 </strong>
</pre>
<p class="calibre2">The <kbd class="calibre11">falcor-http-datasource</kbd> helps us to retrieve data from server to client side, out-of-the-box (without worrying about HTTP API requests)--we will use this later when moving the client-side model to the backend.</p>
<p class="calibre2">Let's create our app's Falcor model on the client side:</p>
<pre class="calibre22">
<strong class="calibre1">cd src</strong><br class="title-page-name"/><strong class="calibre1">touch falcorModel.js</strong>
</pre>
<p class="calibre2">Then the content of the <kbd class="calibre11">falcorModel.js</kbd> will be as follows:</p>
<pre class="calibre22">
import falcor from 'falcor';  <br class="title-page-name"/>import FalcorDataSource from 'falcor-http-datasource'; <br class="title-page-name"/><br class="title-page-name"/>let cache = { <br class="title-page-name"/>  articles: [ <br class="title-page-name"/>    { <br class="title-page-name"/>        id: 987654, <br class="title-page-name"/>        articleTitle: 'Lorem ipsum - article one', <br class="title-page-name"/>        articleContent: 'Here goes the content of the article' <br class="title-page-name"/>    }, <br class="title-page-name"/>    { <br class="title-page-name"/>        id: 123456, <br class="title-page-name"/>        articleTitle: 'Lorem ipsum - article two from backend', <br class="title-page-name"/>        articleContent: 'Sky is the limit, the content goes here.' <br class="title-page-name"/>    } <br class="title-page-name"/>  ] <br class="title-page-name"/>}; <br class="title-page-name"/><br class="title-page-name"/>const model = new falcor.Model({ <br class="title-page-name"/>'cache': cache <br class="title-page-name"/>}); <br class="title-page-name"/>export default model;
</pre>
<p class="calibre2">In this code, you can find a well-known, brief, and readable model of our publishing application with two articles in it.</p>
<p class="calibre2">Now we will fetch that data from the frontend Falcor's model in our <kbd class="calibre11">src/layouts/PublishingApp.js</kbd> React component, we will add a new function called <kbd class="calibre11">_fetch()</kbd> which will be responsible for fetching all articles on our application start.</p>
<p class="calibre2">We need to import our Falcor model first, so at the top of the <kbd class="calibre11">PublishingApp.js</kbd> file, we need to add the following:</p>
<pre class="calibre22">
<strong class="calibre1">import falcorModel from '../falcorModel.js';</strong>
</pre>
<p class="calibre2">In our <kbd class="calibre11">PublishingApp</kbd> class, we need to add the following two functions; <kbd class="calibre11">componentWillMount</kbd> and <kbd class="calibre11">_fetch</kbd> (more explanation follows):</p>
<pre class="calibre22">
class PublishingApp extends React.Component { <br class="title-page-name"/>  constructor(props) { <br class="title-page-name"/>    super(props); <br class="title-page-name"/>  } <br class="title-page-name"/><br class="title-page-name"/>  componentWillMount() { <br class="title-page-name"/>    this._fetch(); <br class="title-page-name"/>  } <br class="title-page-name"/><br class="title-page-name"/>  async _fetch() { <br class="title-page-name"/>    const articlesLength = await falcorModel. <br class="title-page-name"/>      getValue('articles.length'). <br class="title-page-name"/>      then((length) =&gt; length ); <br class="title-page-name"/><br class="title-page-name"/>    const articles = await falcorModel. <br class="title-page-name"/>      get(['articles', {from: 0, to: articlesLength-1},  <br class="title-page-name"/>      ['id','articleTitle', 'articleContent']])  <br class="title-page-name"/>      .then((articlesResponse) =&gt; articlesResponse.json.articles); <br class="title-page-name"/>  } <br class="title-page-name"/>  // below here are next methods o the PublishingApp
</pre>
<p class="calibre2">Here, you see the asynchronous function called <kbd class="calibre11">_fetch</kbd>. This is a special syntax that allows you to use the <kbd class="calibre11">await</kbd> keyword like we do when using <kbd class="calibre11">let articlesLength = await falcorModel</kbd> and <kbd class="calibre11">let articles = await falcorModel</kbd>.</p>
<p class="calibre2">Using <kbd class="calibre11">async await</kbd> over Promises means our code is more readable and avoids callback hell situations where nesting multiple callbacks one after the other makes code very hard to read and extend.</p>
<p class="calibre2">The <kbd class="calibre11">async</kbd>/<kbd class="calibre11">await</kbd> feature is taken from ECMAScript 7 inspired by C#. It allows you to write functions that appear to be blocked at each asynchronous operation that is waiting for the result before continuing to the next operation.</p>
<p class="calibre2">In our example, the code will execute as follows:</p>
<ol class="calibre17">
<li value="1" class="calibre15">First it will call Falcor's mode for an article count with the following:</li>
</ol>
<pre class="calibre22">
        const articlesLength = await falcorModel. <br class="title-page-name"/>          getValue('articles.length'). <br class="title-page-name"/>          then( (length) =&gt;  length );
</pre>
<ol start="2" class="calibre17">
<li value="2" class="calibre15">In the article's <kbd class="calibre11">Length</kbd> variable, we will have a count of <kbd class="calibre11">articles.length</kbd> from our model (in our case it will be number two).</li>
<li value="3" class="calibre15">After we know that we have two articles in our model, then the next block of code executes the following:</li>
</ol>
<pre class="calibre22">
        let articles = await falcorModel. <br class="title-page-name"/>          get(['articles', {from: 0, to: articlesLength-1},<br class="title-page-name"/>          ['id','articleTitle', 'articleContent']]).  <br class="title-page-name"/>          then( (articlesResponse) =&gt; articlesResponse.json.articles);
</pre>
<p class="calibre2">The <kbd class="calibre11">get</kbd> method on <kbd class="calibre11">falcorModel.get(['articles', {from: 0, to: articlesLength-1}, ['id','articleTitle', 'articleContent']]).</kbd> is also an asynchronous operation (in the same way as <kbd class="calibre11">http request</kbd>). In the <kbd class="calibre11">get</kbd> method's parameter, we provide the location of our articles in our model (in <kbd class="calibre11">src/falcorModel.js</kbd>), so we are providing the following path:</p>
<pre class="calibre22">
falcorModel.get( <br class="title-page-name"/>['articles', {from: 0, to: articlesLength-1}, ['id','articleTitle', 'articleContent']] <br class="title-page-name"/>)
</pre>
<p class="calibre2">The explanation of the preceding Falcor path is based on our model. Let's call it again:</p>
<pre class="calibre22">
{ <br class="title-page-name"/>  articles: [ <br class="title-page-name"/>    { <br class="title-page-name"/>        id: 987654, <br class="title-page-name"/>        articleTitle: 'Lorem ipsum - article one', <br class="title-page-name"/>        articleContent: 'Here goes the content of the article' <br class="title-page-name"/>    }, <br class="title-page-name"/>    { <br class="title-page-name"/>        id: 123456, <br class="title-page-name"/>        articleTitle: 'Lorem ipsum - article two from backend', <br class="title-page-name"/>        articleContent: 'Sky is the limit, the content goes here.' <br class="title-page-name"/>    } <br class="title-page-name"/>  ] <br class="title-page-name"/>}
</pre>
<p class="calibre2">What we are saying to Falcor:</p>
<ol class="calibre17">
<li value="1" class="calibre15"><span>First we want to get data from <kbd class="calibre11">articles</kbd> within our object using:</span></li>
</ol>
<pre class="calibre22">
        ['articles']
</pre>
<ol start="2" class="calibre17">
<li value="2" class="calibre15">Next from <kbd class="calibre11">articles</kbd> collection select subset of all the articles it has with a range <kbd class="calibre11">{from: 0, to: articlesLength-1}</kbd> (the <kbd class="calibre11">articlesLength</kbd> we have fetched earlier) with the following path:</li>
</ol>
<pre class="calibre22">
        ['articles', {from: 0, to: articlesLength-1}]
</pre>
<ol start="3" class="calibre17">
<li value="3" class="calibre15">The last step explains to Falcor, which properties from the object you want to fetch from our model. So the complete path in that <kbd class="calibre11">falcorModel.get</kbd> query is the following:</li>
</ol>
<pre class="calibre22">
        ['articles', {from: 0, to: articlesLength-1},   <br class="title-page-name"/>        ['id','articleTitle', 'articleContent']]
</pre>
<ol start="4" class="calibre17">
<li value="4" class="calibre15">The array of <kbd class="calibre11">['id','articleTitle', 'articleContent']</kbd> says that you want those three properties out of every article.</li>
<li value="5" class="calibre15">In the end, we receive an array of article objects from Falcor:</li>
</ol>
<div class="packt_figure"><img class="image-border9" src="../images/00014.jpeg"/></div>
<p class="calibre2">After we have fetched the data from our Falcor model, we need to dispatch an action that will change the article's reducer accordingly and ultimately re-render our list of articles from our Falcor model from the <kbd class="calibre11">const articleMock</kbd> (in <kbd class="calibre11">src/reducers/article.js</kbd>) instead.</p>
<p class="calibre2">But before we will be able to dispatch an action, we need to do the following:</p>
<p class="calibre2">Create the <kbd class="calibre11">actions</kbd> directory with <kbd class="calibre11">article.js</kbd>:</p>
<pre class="calibre22">
<strong class="calibre1">pwd </strong><br class="title-page-name"/><strong class="calibre1">$ /Users/przeor/Desktop/React-Convention-Book </strong><br class="title-page-name"/><strong class="calibre1">cd src </strong><br class="title-page-name"/><strong class="calibre1">mkdir actions </strong><br class="title-page-name"/><strong class="calibre1">cd actions </strong><br class="title-page-name"/><strong class="calibre1">touch article.js </strong>
</pre>
<p class="calibre2">Create the content for our <kbd class="calibre11">src/actions/article.js</kbd> file as follows:</p>
<pre class="calibre22">
export default { <br class="title-page-name"/>  articlesList: (response) =&gt; { <br class="title-page-name"/>    return { <br class="title-page-name"/>      type: 'ARTICLES_LIST_ADD', <br class="title-page-name"/>      payload: { response: response } <br class="title-page-name"/>    } <br class="title-page-name"/>  } <br class="title-page-name"/>}
</pre>
<p class="calibre2">There isn't too much in that <kbd class="calibre11">actions/article.js</kbd> file <kbd class="calibre11">.</kbd> If you are familiar with FLUX already then it's very similar. One important rule for actions in Redux is that it has to be a pure function. For now, we will hardcode a constant called <kbd class="calibre11">ARTICLES_LIST_ADD</kbd> into <kbd class="calibre11">actions/article.js</kbd>.</p>
<p class="calibre2">In the <kbd class="calibre11">src/layouts/PublishingApp.js</kbd> file we need to add a new import code at the top of the file:</p>
<pre class="calibre22">
import {bindActionCreators} from 'redux'; <br class="title-page-name"/>import articleActions from '../actions/article.js';
</pre>
<p class="calibre2">When you have added the preceding two in our <kbd class="calibre11">PublishingApp</kbd>, then modify our existing function in the same file from the following:</p>
<pre class="calibre22">
const mapDispatchToProps = (dispatch) =&gt; ({ <br class="title-page-name"/>});
</pre>
<p class="calibre2">Add <kbd class="calibre11">articleActions: bindActionCreators(articleActions, dispatch)</kbd> so that we are able to bind the articles' actions into our <kbd class="calibre11">this.props</kbd> component:</p>
<pre class="calibre22">
const mapDispatchToProps = (dispatch) =&gt; ({ <br class="title-page-name"/>  articleActions: bindActionCreators(articleActions, dispatch) <br class="title-page-name"/>});
</pre>
<p class="calibre2">Thanks to the mentioned changes <kbd class="calibre11">(articleActions: bindActionCreators(articleActions, dispatch))</kbd> in our component, we will be able to dispatch an action from props because now, when you use <kbd class="calibre11">this.props.articleActions.articlesList(articles)</kbd> then the <kbd class="calibre11">articles</kbd> object fetched from Falcor will be available in our reducer (and from there, there is only one step to make our app fetch data work).</p>
<p class="calibre2">Now, after you are done with these changes, add an action into our component in the <kbd class="calibre11">_fetch</kbd> function:</p>
<pre class="calibre22">
this.props.articleActions.articlesList(articles);
</pre>
<p class="calibre2">Our whole function for fetching will look as follows:</p>
<pre class="calibre22">
 async _fetch() { <br class="title-page-name"/>    const articlesLength = await falcorModel. <br class="title-page-name"/>      getValue('articles.length'). <br class="title-page-name"/>      then( (length) =&gt; length); <br class="title-page-name"/><br class="title-page-name"/>    let articles = await falcorModel. <br class="title-page-name"/>      get(['articles', {from: 0, to: articlesLength-1},  <br class="title-page-name"/>      ['id','articleTitle', 'articleContent']]).  <br class="title-page-name"/>      then( (articlesResponse) =&gt; articlesResponse.json.articles); <br class="title-page-name"/><br class="title-page-name"/>    this.props.articleActions.articlesList(articles); <br class="title-page-name"/>  }
</pre>
<p class="calibre2">Also, don't forget about calling <kbd class="calibre11">_fetch</kbd> from <kbd class="calibre11">ComponentWillMount</kbd>:</p>
<pre class="calibre22">
 componentWillMount() { <br class="title-page-name"/>    this._fetch(); <br class="title-page-name"/>  }
</pre>
<p class="calibre2">At this point, we shall be able to receive an action in our Redux's reducer. Let's improve our <kbd class="calibre11">src/reducers/article.js</kbd> file:</p>
<pre class="calibre22">
const article = (state = {}, action) =&gt; { <br class="title-page-name"/>    switch (action.type) { <br class="title-page-name"/>        case 'RETURN_ALL_ARTICLES': <br class="title-page-name"/>            return Object.assign({}, state); <br class="title-page-name"/>        case 'ARTICLES_LIST_ADD': <br class="title-page-name"/>            return Object.assign({}, action.payload.response); <br class="title-page-name"/>        default: <br class="title-page-name"/>            return state; <br class="title-page-name"/>    } <br class="title-page-name"/>} <br class="title-page-name"/>export default article
</pre>
<p class="calibre2">As you can see, we don't need <kbd class="calibre11">articleMock</kbd> anymore, so we have deleted it from the <kbd class="calibre11">src/reducers/article.js</kbd>.</p>
<p class="calibre2">We have added a new case, <kbd class="calibre11">ARTICLES_LIST_ADD</kbd>:</p>
<pre class="calibre22">
   case 'ARTICLES_LIST_ADD': <br class="title-page-name"/>        let articlesList = action.payload.response; <br class="title-page-name"/>        return Object.assign({}, articlesList);
</pre>
<p class="calibre2"><a class="calibre6">It returns a new</a> <kbd class="calibre11">articlesList</kbd> object (with a new reference in the memory, thanks to <kbd class="calibre11">Object.assign</kbd>).</p>
<div class="packt_infobox">Don't confuse the two files with the same name and other locations, such as:<br class="calibre24"/>
<kbd class="calibre23">reducers/article.js<br class="calibre24"/></kbd><br class="calibre24"/>
<kbd class="calibre23">actions/article.js<br class="calibre24"/></kbd><br class="calibre24"/>
You need to make sure that you are editing the correct file, otherwise the app won't work.</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">A summary of client-side Falcor + Redux</h1>
            

            <article>
                
<p class="calibre2">If you run <kbd class="calibre11">http://localhost:3000/index.html</kbd>, you will see that, currently we have two separate applications:</p>
<ul class="calibre14">
<li class="calibre15">One at the frontend using Redux and client-side Falcor</li>
<li class="calibre15">One at the backend using MongoDB, Mongoose, and Express</li>
</ul>
<p class="calibre2">We need to stick both together so we have one source of state for our applications (that comes from MongoDB).</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Moving Falcor's model to the backend</h1>
            

            <article>
                
<p class="calibre2">We also need to update our <kbd class="calibre11">package.json</kbd> file:</p>
<pre class="calibre22">
"scripts": { <br class="title-page-name"/>  "dev": "webpack-dev-server", <br class="title-page-name"/>  "start": "npm run webpack; node server", <br class="title-page-name"/>  "webpack": "webpack --config ./webpack.config.js" <br class="title-page-name"/>},
</pre>
<p class="calibre2">Because we are starting the full-stack development part, we need to add <kbd class="calibre11">npm start</kbd> to our scripts in <kbd class="calibre11">package.json</kbd>--this will help compile client side, put them into the <kbd class="calibre11">dist</kbd> folder (generated via webpack), and create static files in <kbd class="calibre11">dist</kbd>, and then use this folder as the source of static files (check <kbd class="calibre11">server/server.js</kbd> for <kbd class="calibre11">app.use(express.static('dist'));</kbd>).</p>
<p class="calibre2">The next important thing is to install new dependencies that are required for Falcor on the backend:</p>
<pre class="calibre22">
<strong class="calibre1">npm i --save falcor-express@0.1.2 falcor-router@0.2.12</strong>
</pre>
<p class="calibre2">When you have finally installed new dependencies and configured the basic scripts for running the backend and frontend on the same port, then edit the <kbd class="calibre11">server/server.js</kbd> as follows:</p>
<ol class="calibre17">
<li value="1" class="calibre15">On top of our file, import new libraries in the <kbd class="calibre11">server/server.js</kbd>:</li>
</ol>
<pre class="calibre22">
        import falcor from 'falcor'; <br class="title-page-name"/>        import falcorExpress from 'falcor-express';
</pre>
<ol start="2" class="calibre17">
<li value="2" class="calibre15">Then between the following two:</li>
</ol>
<pre class="calibre22">
        app.use(bodyParser.json({extended: false})); <br class="title-page-name"/><span>        app.use(express.static('dist'));</span>
</pre>
<ol start="3" class="calibre17">
<li value="3" class="calibre15">Add new code for managing Falcor at the backend:</li>
</ol>
<pre class="calibre22">
        app.use(bodyParser.json({extended: false})); <br class="title-page-name"/><br class="title-page-name"/>        let cache = { <br class="title-page-name"/>          articles: [ <br class="title-page-name"/>            { <br class="title-page-name"/>                id: 987654, <br class="title-page-name"/>                articleTitle: 'Lorem ipsum - article one', <br class="title-page-name"/>                articleContent: 'Here goes the content of the article' <br class="title-page-name"/>            }, <br class="title-page-name"/>            { <br class="title-page-name"/>                id: 123456, <br class="title-page-name"/>                articleTitle: 'Lorem ipsum - article two from          <br class="title-page-name"/>                backend', <br class="title-page-name"/>                articleContent: 'Sky is the limit, the content goes          <br class="title-page-name"/>                here.' <br class="title-page-name"/>            } <br class="title-page-name"/>          ] <br class="title-page-name"/>        }; <br class="title-page-name"/><br class="title-page-name"/>        var model = new falcor.Model({ <br class="title-page-name"/>          cache: cache <br class="title-page-name"/>        }); <br class="title-page-name"/> <br class="title-page-name"/>        app.use('/model.json', falcorExpress.dataSourceRoute((req,               <br class="title-page-name"/>        res) =&gt; { <br class="title-page-name"/>            return model.asDataSource(); <br class="title-page-name"/>        })); <br class="title-page-name"/>        app.use(express.static('dist'));
</pre>
<ol start="4" class="calibre17">
<li value="4" class="calibre15">The preceding code is almost the same as the one in the <kbd class="calibre11">src/falcorModel.js</kbd> file. The only difference is that now Falcor will fetch data from the backend's mocked object, called <kbd class="calibre11">cache</kbd> in <kbd class="calibre11">server.js</kbd>.</li>
<li value="5" class="calibre15">The second part is to change our data source on the frontend, so in the <kbd class="calibre11">src/falcorModel.js</kbd> file, you change the following old code:</li>
</ol>
<pre class="calibre22">
        import falcor from 'falcor'; <br class="title-page-name"/>        import FalcorDataSource from 'falcor-http-datasource'; <br class="title-page-name"/><br class="title-page-name"/>        let cache = { <br class="title-page-name"/>          articles: [ <br class="title-page-name"/>          { <br class="title-page-name"/>            id: 987654, <br class="title-page-name"/>            articleTitle: 'Lorem ipsum - article one', <br class="title-page-name"/>            articleContent: 'Here goes the content of the article' <br class="title-page-name"/>          }, <br class="title-page-name"/>          { <br class="title-page-name"/>            id: 123456, <br class="title-page-name"/>            articleTitle: 'Lorem ipsum - article two from backend', <br class="title-page-name"/>            articleContent: 'Sky is the limit, the content goes here.' <br class="title-page-name"/>          } <br class="title-page-name"/>         ] <br class="title-page-name"/>        }; <br class="title-page-name"/><br class="title-page-name"/>        const model = new falcor.Model({ <br class="title-page-name"/>        'cache': cache <br class="title-page-name"/>        }); <br class="title-page-name"/><br class="title-page-name"/>        export default model;
</pre>
<ol start="6" class="calibre17">
<li value="6" class="calibre15">Change it to the following updated code:</li>
</ol>
<pre class="calibre22">
        import falcor from 'falcor'; <br class="title-page-name"/>        import FalcorDataSource from 'falcor-http-datasource'; <br class="title-page-name"/><br class="title-page-name"/>        const model = new falcor.Model({ <br class="title-page-name"/>          source: new FalcorDataSource('/model.json') <br class="title-page-name"/>        }); <br class="title-page-name"/><br class="title-page-name"/>        export default model;
</pre>
<ol start="7" class="calibre17">
<li value="7" class="calibre15">Run your app with the following:</li>
</ol>
<pre class="calibre22">
<strong class="calibre1">    npm start</strong>
</pre>
<ol start="8" class="calibre17">
<li value="8" class="calibre15">You will see in your browser's dev tools a new HTTP request made by Falcor--for example, in our case:</li>
</ol>
<div class="packt_figure"><img class="image-border10" src="../images/00015.jpeg"/></div>
<p class="calibre2">If you follow all the instructions correctly, then you can also make a request to your server directly from your browser by executing this:</p>
<pre class="calibre22">
<strong class="calibre1">http://localhost:3000/model.json?paths=[["articles", {"from":0,"to":1},   <br class="title-page-name"/>["articleContent","articleTitle","id"]]]&amp;method=get.</strong>
</pre>
<p class="calibre2">Then you shall see a <kbd class="calibre11">jsonGraph</kbd> in the response:</p>
<div class="packt_figure"><img class="image-border11" src="../images/00016.jpeg"/></div>
<p class="calibre2">You don't have to worry about those preceding two screenshots. They are just an example of how Falcor is communicating between the backend and frontend in Falcor's language. You don't have to worry anymore about exposing API endpoints and programming frontend to understand what data the backend is providing. Falcor is doing all of this out-of-the-box and you will learn more details while making this publishing application.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Configuring Falcor's router (Express.js)</h1>
            

            <article>
                
<p class="calibre2">Currently, our model on the backend is hardcoded, so that it stays in the RAM memory of a server. We need to add the ability to read the data from our MongoDB's articles collection--this is where the <kbd class="calibre11">falcor-router</kbd> comes in handy.</p>
<p class="calibre2">We need to create our routes definition files that will be consumed by <kbd class="calibre11">falcor-router</kbd> lib:</p>
<pre class="calibre22">
<strong class="calibre1">$ pwd </strong><br class="title-page-name"/><strong class="calibre1">/Users/przeor/Desktop/React-Convention-Book </strong><br class="title-page-name"/><strong class="calibre1">$ cd server </strong><br class="title-page-name"/><strong class="calibre1">$ touch routes.js </strong>
</pre>
<p class="calibre2">We have created the <kbd class="calibre11">server/routes.js</kbd> file; the content for that router will be as follows:</p>
<pre class="calibre22">
const PublishingAppRoutes = [{ <br class="title-page-name"/>  route: 'articles.length', <br class="title-page-name"/>  get: () =&gt; { <br class="title-page-name"/>    const articlesCountInDB = 2; // hardcoded for example <br class="title-page-name"/>    return { <br class="title-page-name"/>      path: ['articles', 'length'], <br class="title-page-name"/>      value: articlesCountInDB <br class="title-page-name"/>    }; <br class="title-page-name"/>  } <br class="title-page-name"/>}]; <br class="title-page-name"/>export default PublishingAppRoutes;
</pre>
<p class="calibre2">As you can see, we have created our first route that will match the <kbd class="calibre11">articles.length</kbd> from our <kbd class="calibre11">_fetch</kbd> function (in <kbd class="calibre11">layouts/PublishingApp.js</kbd>).</p>
<p class="calibre2">We have hardcoded the number two in <kbd class="calibre11">articlesCountInDB</kbd>, later we will make a query to our database there.</p>
<p class="calibre2">The new stuff here is <kbd class="calibre11">route: 'articles.length'</kbd>, this is simply a route for matching by Falcor.</p>
<p class="calibre2">To be more precise, the Falcor routes' paths are exactly the same stuff that you have provided in your <kbd class="calibre11">src/layouts/PublishingApp.js (_fetch function)</kbd> for example, to match this frontend call:</p>
<pre class="calibre22">
 // location of that code snippet: src/layouts/PublishingApp.js <br class="title-page-name"/> const articlesLength = await falcorModel. <br class="title-page-name"/>    getValue('articles.length'). <br class="title-page-name"/>    then((length) =&gt; length);
</pre>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre11">path: ['articles', 'length']</kbd>: This property tells us Falcor's path (it's consumed by Falcor at the backend and frontend). We need to provide that because sometimes, one route can return many different objects as server articles (you will see it in the next route we create).</li>
<li class="calibre15"><kbd class="calibre11">value: articlesCountInDB</kbd>: This is a return value. In this case, it is an integer number, but it can also be an object with several properties, as you will learn later.</li>
</ul>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Second route for returning our two articles from the backend</h1>
            

            <article>
                
<p class="calibre2">Our second route (and last one in this chapter) will be the following:</p>
<pre class="calibre22">
{ <br class="title-page-name"/>  route: 'articles[{integers}]["id","articleTitle","articleContent"]', <br class="title-page-name"/>  get: (pathSet) =&gt; { <br class="title-page-name"/>    const articlesIndex = pathSet[1]; <br class="title-page-name"/>    const articlesArrayFromDB = [{ <br class="title-page-name"/>    'articleId': '987654', <br class="title-page-name"/>    'articleTitle': 'BACKEND Lorem ipsum - article one', <br class="title-page-name"/>    'articleContent': 'BACKEND Here goes the content of the article' <br class="title-page-name"/>    }, { <br class="title-page-name"/>    'articleId': '123456', <br class="title-page-name"/>    'articleTitle': 'BACKEND Lorem ipsum - article two', <br class="title-page-name"/>    'articleContent': 'BACKEND Sky is the limit, the content goes here.' <br class="title-page-name"/>    }]; // That are our mocked articles from MongoDB <br class="title-page-name"/><br class="title-page-name"/>    let results = []; <br class="title-page-name"/>    articlesIndex.forEach((index) =&gt; { <br class="title-page-name"/>      const singleArticleObject = articlesArrayFromDB[index]; <br class="title-page-name"/>      const falcorSingleArticleResult = { <br class="title-page-name"/>        path: ['articles', index], <br class="title-page-name"/>        value: singleArticleObject <br class="title-page-name"/>      }; <br class="title-page-name"/>      results.push(falcorSingleArticleResult); <br class="title-page-name"/>    }); <br class="title-page-name"/><br class="title-page-name"/>    return results; <br class="title-page-name"/>  } <br class="title-page-name"/>}
</pre>
<p class="calibre2">The new thing in the second route is <kbd class="calibre11">pathSet</kbd>, if you log that into the console, then you will see, in our case (when trying to run our full-stack app) the following:</p>
<pre class="calibre22">
[  <br class="title-page-name"/>'articles', <br class="title-page-name"/>  [ 0, 1 ], <br class="title-page-name"/>  [ 'articleContent', 'articleTitle', 'id' ]  <br class="title-page-name"/>]
</pre>
<p class="calibre2"><kbd class="calibre11">pathSet</kbd> tells us what indexes are requested from the client side (<kbd class="calibre11">[ 0, 1 ]</kbd>, in our example).</p>
<p class="calibre2">Because, in this case, we are returning an array of articles (multiple articles), we need to create a result variable:</p>
<pre class="calibre22">
let results = [];
</pre>
<p class="calibre2">Iterate over the requested indexes:</p>
<pre class="calibre22">
articlesIndex.forEach((index) =&gt; { <br class="title-page-name"/>   const singleArticleObject = articlesArrayFromDB[index]; <br class="title-page-name"/>   const falcorSingleArticleResult = { <br class="title-page-name"/>     path: ['articles', index], <br class="title-page-name"/>     value: singleArticleObject <br class="title-page-name"/>   }; <br class="title-page-name"/>   results.push(falcorSingleArticleResult); <br class="title-page-name"/> });
</pre>
<p class="calibre2">In the preceding code snippet, we iterate over an array of requested indexes (do you remember <kbd class="calibre11">{from: 0, to: articlesLength-1}</kbd> in <kbd class="calibre11">PublishingApp.js</kbd>?). Based on the indexes <kbd class="calibre11">([0, 1])</kbd> we fetch mocked data via <kbd class="calibre11">const singleArticleObject = articlesArrayFromDB[index];</kbd>. Later we put into the <kbd class="calibre11">path</kbd> and <kbd class="calibre11">index</kbd> (<kbd class="calibre11">path: ['articles', index],</kbd>) so Falcor knows to what path in our JSON graph object, the value <kbd class="calibre11">singleArticleObject</kbd> belongs to.</p>
<p class="calibre2">Return that array of articles:</p>
<pre class="calibre22">
console.info(results) <br class="title-page-name"/> return results;
</pre>
<p class="calibre2"><kbd class="calibre11">console.info</kbd> will show us what has been returned by that path:</p>
<pre class="calibre22">
[{ <br class="title-page-name"/>  path: ['articles', 0], <br class="title-page-name"/>  value: { <br class="title-page-name"/>    articleId: '987654', <br class="title-page-name"/>    articleTitle: 'BACKEND Lorem ipsum - article one', <br class="title-page-name"/>    articleContent: 'BACKEND Here goes the content of the article' <br class="title-page-name"/>  } <br class="title-page-name"/>}, { <br class="title-page-name"/>  path: ['articles', 1], <br class="title-page-name"/>  value: { <br class="title-page-name"/>    articleId: '123456', <br class="title-page-name"/>    articleTitle: 'BACKEND Lorem ipsum - article two', <br class="title-page-name"/>    articleContent: 'BACKEND Sky is the limit, the content goes here.' <br class="title-page-name"/>  } <br class="title-page-name"/>}]
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Final touch to make full-stack Falcor run</h1>
            

            <article>
                
<p class="calibre2">Currently, we still have mocked data in our routes, but before we start making calls to MongoDB, we need to wrap up the current setup so you will be able to see it running in your browser.</p>
<p class="calibre2">Open your <kbd class="calibre11">server/server.js</kbd> and make sure you import the following two things:</p>
<pre class="calibre22">
import falcorRouter from 'falcor-router'; <br class="title-page-name"/>import routes from './routes.js';
</pre>
<p class="calibre2">Now that we have imported our <kbd class="calibre11">falcor-router</kbd> and <kbd class="calibre11">routes.js</kbd>--we need to use them, so modify this old code:</p>
<pre class="calibre22">
// This is old code, remove it and replace with new <br class="title-page-name"/>app.use('/model.json', falcorExpress.dataSourceRoute((req, res) =&gt;  { <br class="title-page-name"/>  return model.asDataSource(); <br class="title-page-name"/>}));
</pre>
<p class="calibre2">Replace the preceding code with:</p>
<pre class="calibre22">
app.use('/model.json', falcorExpress.dataSourceRoute((req, res) =&gt; { <br class="title-page-name"/> return new falcorRouter(routes); <br class="title-page-name"/>}));
</pre>
<p class="calibre2">This will work only when the <kbd class="calibre11">falcor-router</kbd> has been already installed and imported in the <kbd class="calibre11">server.js</kbd> file. This is a library for <kbd class="calibre11">DataSource</kbd> that creates a virtual JSON graph document on your app server. As you can see in <kbd class="calibre11">server.js</kbd> so far we have <kbd class="calibre11">DataSource</kbd> provided by our hardcoded model, <kbd class="calibre11">return model.asDataSource();</kbd>. The router here will make the same, but now you will be able to match routes based on your app requirements.</p>
<p class="calibre2">Also, as you can see, the new <kbd class="calibre11">falcorRouter</kbd> takes an argument of our routes <kbd class="calibre11">return new falcorRouter(routes);</kbd>.</p>
<p class="calibre2">If you have followed the instructions correctly, you will be able to run the project:</p>
<pre class="calibre22">
<strong class="calibre1">npm start</strong>
</pre>
<p class="calibre2">On port <kbd class="calibre11">3000</kbd>, you will see the following:</p>
<div class="packt_figure"><img class="image-border12" src="../images/00017.jpeg"/></div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Adding MongoDB/Mongoose calls based on Falcor's routes</h1>
            

            <article>
                
<p class="calibre2">Let's get back to our <kbd class="calibre11">server/routes.js</kbd> file. We need to move over (delete from <kbd class="calibre11">server.js</kbd> and move into <kbd class="calibre11">routes.js</kbd>) this following code:</p>
<pre class="calibre22">
// this goes to server/routes.js <br class="title-page-name"/>import mongoose from 'mongoose'; <br class="title-page-name"/><br class="title-page-name"/>mongoose.connect('mongodb://localhost/local'); <br class="title-page-name"/><br class="title-page-name"/>const articleSchema = { <br class="title-page-name"/>  articleTitle:String, <br class="title-page-name"/>  articleContent:String <br class="title-page-name"/>}; <br class="title-page-name"/>const Article = mongoose.model('Article', articleSchema, 'articles');
</pre>
<p class="calibre2">In the first route <kbd class="calibre11">articles.length</kbd>, you need to replace the mocked number two (the articles count) into Mongoose's <kbd class="calibre11">count</kbd> method:</p>
<pre class="calibre22">
 route: 'articles.length', <br class="title-page-name"/>    get: () =&gt; { <br class="title-page-name"/>    return Article.count({}, (err, count) =&gt; count) <br class="title-page-name"/>    .then ((articlesCountInDB) =&gt; { <br class="title-page-name"/>      return { <br class="title-page-name"/>        path: ['articles', 'length'], <br class="title-page-name"/>        value: articlesCountInDB <br class="title-page-name"/>      } <br class="title-page-name"/>    }) <br class="title-page-name"/>  }
</pre>
<div class="packt_infobox">We are returning a Promise in <kbd class="calibre23">get</kbd> (Mongoose, by its asynchronous nature, always returns a Promise while making any database's request, as in the example, <kbd class="calibre23">Article.count</kbd>).</div>
<p class="calibre2">The method <kbd class="calibre11">Article.count</kbd> simply retrieves the integer number of articles' count from our <em class="calibre21">Article</em> model (that was prepared at the beginning of this book in <kbd class="calibre11">MongoDB/Mongoose sub-chapter</kbd>).</p>
<p class="calibre2">The second route <kbd class="calibre11">route: 'articles[{integers}]["id","articleTitle","articleContent"]'</kbd>, has to be changed as follows:</p>
<pre class="calibre22">
{ <br class="title-page-name"/>  route: 'articles[{integers}]["id","articleTitle","articleContent"]', <br class="title-page-name"/>  get: (pathSet) =&gt; { <br class="title-page-name"/>    const articlesIndex = pathSet[1]; <br class="title-page-name"/><br class="title-page-name"/>    return Article.find({}, (err, articlesDocs) =&gt; articlesDocs) <br class="title-page-name"/>    .then ((articlesArrayFromDB) =&gt; { <br class="title-page-name"/>      let results = []; <br class="title-page-name"/>      articlesIndex.forEach((index) =&gt; { <br class="title-page-name"/>        const singleArticleObject =          <br class="title-page-name"/>        articlesArrayFromDB[index].toObject(); <br class="title-page-name"/>        const falcorSingleArticleResult = { <br class="title-page-name"/>          path: ['articles', index], <br class="title-page-name"/>          value: singleArticleObject <br class="title-page-name"/>        }; <br class="title-page-name"/>        results.push(falcorSingleArticleResult); <br class="title-page-name"/>      }); <br class="title-page-name"/>      return results; <br class="title-page-name"/>    }) <br class="title-page-name"/>  } <br class="title-page-name"/>}
</pre>
<p class="calibre2">We return a Promise again with <kbd class="calibre11">Article.find</kbd>. Also, we have deleted the mocked response from the database and instead we are using the <kbd class="calibre11">Article.find</kbd> method.</p>
<p class="calibre2">The array of articles is returned in <kbd class="calibre11">}).then ((articlesArrayFromDB) =&gt; {</kbd> and next we simply iterate and create a results array.</p>
<p class="calibre2">Note that on <kbd class="calibre11">const singleArticleObject = articlesArrayFromDB[index].toObject();</kbd> we use a method <kbd class="calibre11">.toObject</kbd>. This is very important for making this work.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Double-check with the server/routes.js and package.json</h1>
            

            <article>
                
<p class="calibre2">In order to save you time in case the app doesn't run, we can double-check that the backend's Falcor routes are prepared correctly:</p>
<pre class="calibre22">
import mongoose from 'mongoose'; <br class="title-page-name"/><br class="title-page-name"/>mongoose.connect('mongodb://localhost/local'); <br class="title-page-name"/><br class="title-page-name"/>const articleSchema = { <br class="title-page-name"/>  articleTitle:String, <br class="title-page-name"/>  articleContent:String <br class="title-page-name"/>}; <br class="title-page-name"/><br class="title-page-name"/>const Article = mongoose.model('Article', articleSchema, 'articles'); <br class="title-page-name"/><br class="title-page-name"/>const PublishingAppRoutes = [ <br class="title-page-name"/>  { <br class="title-page-name"/>    route: 'articles.length', <br class="title-page-name"/>      get: () =&gt;  Article.count({}, (err, count) =&gt; count) <br class="title-page-name"/>        .then ((articlesCountInDB) =&gt; { <br class="title-page-name"/>          return { <br class="title-page-name"/>            path: ['articles', 'length'], <br class="title-page-name"/>            value: articlesCountInDB <br class="title-page-name"/>          }; <br class="title-page-name"/>      }) <br class="title-page-name"/>  }, <br class="title-page-name"/>  { <br class="title-page-name"/>    route: 'articles[{integers}]  <br class="title-page-name"/>    ["id","articleTitle","articleContent"]', <br class="title-page-name"/>    get: (pathSet) =&gt; { <br class="title-page-name"/>      const articlesIndex = pathSet[1]; <br class="title-page-name"/><br class="title-page-name"/>      return Article.find({}, (err, articlesDocs) =&gt;         <br class="title-page-name"/>      articlesDocs); <br class="title-page-name"/>       .then ((articlesArrayFromDB) =&gt; { <br class="title-page-name"/>          let results = []; <br class="title-page-name"/><br class="title-page-name"/>          articlesIndex.forEach((index) =&gt; { <br class="title-page-name"/>            const singleArticleObject =              <br class="title-page-name"/>            articlesArrayFromDB[index].toObject(); <br class="title-page-name"/>            const falcorSingleArticleResult = { <br class="title-page-name"/>              path: ['articles', index], <br class="title-page-name"/>              value: singleArticleObject <br class="title-page-name"/>            }; <br class="title-page-name"/><br class="title-page-name"/>            results.push(falcorSingleArticleResult); <br class="title-page-name"/>          }); <br class="title-page-name"/><br class="title-page-name"/>          return results; <br class="title-page-name"/>        }) <br class="title-page-name"/>      } <br class="title-page-name"/>  } <br class="title-page-name"/>]; <br class="title-page-name"/><br class="title-page-name"/>export default PublishingAppRoutes;
</pre>
<p class="calibre2">Check that your <kbd class="calibre11">server/routes.js</kbd> file looks similar to the preceding code and the other code elements that you have used.</p>
<p class="calibre2">Also, check that your <kbd class="calibre11">package.json</kbd> look likes the following one:</p>
<pre class="calibre22">
{ <br class="title-page-name"/>"name": "project", <br class="title-page-name"/>"version": "1.0.0", <br class="title-page-name"/>"scripts": { <br class="title-page-name"/>"dev": "webpack-dev-server", <br class="title-page-name"/>"start": "npm run webpack; node server", <br class="title-page-name"/>"webpack": "webpack --config ./webpack.config.js" <br class="title-page-name"/>  }, <br class="title-page-name"/>"dependencies": { <br class="title-page-name"/>"body-parser": "^1.15.0", <br class="title-page-name"/>"cors": "^2.7.1", <br class="title-page-name"/>"express": "^4.13.4", <br class="title-page-name"/>"falcor": "^0.1.16", <br class="title-page-name"/>"falcor-express": "^0.1.2", <br class="title-page-name"/>"falcor-http-datasource": "^0.1.3", <br class="title-page-name"/>"falcor-router": "0.2.12", <br class="title-page-name"/>"mongoose": "4.4.5", <br class="title-page-name"/>"react": "^0.14.7", <br class="title-page-name"/>"react-dom": "^0.14.7", <br class="title-page-name"/>"react-redux": "^4.4.0", <br class="title-page-name"/>"redux": "^3.3.1" <br class="title-page-name"/>  }, <br class="title-page-name"/>"devDependencies": { <br class="title-page-name"/>"babel": "^6.5.2", <br class="title-page-name"/>"babel-core": "^6.6.5", <br class="title-page-name"/>"babel-loader": "^6.2.4", <br class="title-page-name"/>"babel-polyfill": "^6.6.1", <br class="title-page-name"/>"babel-preset-es2015": "^6.6.0", <br class="title-page-name"/>"babel-preset-react": "^6.5.0", <br class="title-page-name"/>"babel-preset-stage-0": "^6.5.0", <br class="title-page-name"/>"webpack": "^1.12.14", <br class="title-page-name"/>"webpack-dev-server": "^1.14.1" <br class="title-page-name"/>  } <br class="title-page-name"/>}
</pre>
<p class="calibre2">The important thing to notice about <kbd class="calibre11">package.json</kbd> is that we have removed the <kbd class="calibre11">^</kbd> from <kbd class="calibre11">"mongoose": "4.4.5"</kbd>. We did this because if NPM installs any higher version than <kbd class="calibre11">4.4.5</kbd>, then we get a warning in the bash/command line.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Our first working full-stack app</h1>
            

            <article>
                
<p class="calibre2">After that, you should have a complete full-stack version of the app working:</p>
<div class="packt_figure"><img class="image-border13" src="../images/00018.jpeg"/></div>
<p class="calibre2">At almost every step, the UI part of our app is identical. The preceding screenshot is the publishing app, which does the following:</p>
<ol class="calibre17">
<li value="1" class="calibre15">Fetches data from the DB using <kbd class="calibre11">Falcor-Express</kbd> and <kbd class="calibre11">Falcor-Router</kbd>.</li>
<li value="2" class="calibre15">The data moves from the backend (the source is MongoDB) to the frontend. We populate Redux's <kbd class="calibre11">src/reducers/article.js</kbd> state tree.</li>
<li value="3" class="calibre15">We render the DOM elements based on our single state tree.</li>
<li value="4" class="calibre15">All these steps allow us to take all of the full-stack app's data from the database, to the user's browser (so a user can see an article).</li>
</ol>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            <article>
                
<p class="calibre2">We haven't started to work on the app design, but in our book, we will use the Material Design CSS for React (<a href="http://material-ui.com" class="calibre6"><span>http://material-ui.com</span></a>). In the next chapter, we will start using it for user registration and login. After that, we will re-style the main page of our application using Material Design's components.</p>
<p class="calibre2">In order to give you a teaser of the goal (while working through the book), here is a screenshot of the app and how the publishing app will improve in the following chapters:</p>
<div class="packt_figure"><img class="image-border14" src="../images/00019.jpeg"/></div>
<p class="calibre2">In the preceding screenshot, there is an example article from our application. We are using several Material Design components in order to make our work easier and the publishing app look more professional. You will learn it later.</p>
<p class="calibre2">Are you ready to work on the full-stack login and registration for our publishing app in the next chapter? Let's continue the fun.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    </body></html>