- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular Services and the Singleton Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the great differences between a static web page and a single-page application
    is the processing capacity and interaction in the user’s browser, giving the feeling
    of an application installed on the device. In the Angular framework, the elements
    for this processing and interaction, not only with the backend but with the user,
    are the **services**.
  prefs: []
  type: TYPE_NORMAL
- en: This element is so important to Angular that the team created a dependency management
    system, which allows a simplified way of creating, composing, and using services
    in components.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore this element and learn about the design patterns
    it uses and the best practices to use in your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the dependency injection pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication between components using services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST API consumption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to create reusable and maintainable
    services, in addition to understanding practices that will improve your productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the instructions in this chapter, you’ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js 18 or higher ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch5](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch5).
  prefs: []
  type: TYPE_NORMAL
- en: Creating services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Services** in Angular are TypeScript classes that aim to implement business
    logic for our interfaces. Business logic in a frontend project can seem like a
    controversial issue because ideally, all logic and processing should take place
    on the backend, which is correct.'
  prefs: []
  type: TYPE_NORMAL
- en: Here we are using business rules; these rules are generic behaviors that do
    not depend on a visual component and can be reused in other components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of frontend business rules could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Application state control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication with the backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information validations with a fixed rule, such as the number of digits in a
    telephone number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are going to put this concept into practice, and in our gym diary application,
    we are going to create the first service. In the command line we will use the
    Angular CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the component, we can see that the element created by the Angular CLI
    is composed only of a TypeScript file (and its corresponding unit test file).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this file, we will see the boilerplate that the Angular CLI generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here we have a TypeScript class called `ExerciseSetsService` with a decorator
    called `@Injectable`. It is this decorator that characterizes a service in Angular;
    we will see more details about it later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s refactor our project and place the initial series of sets for our diary
    in this service.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll create the methods that will get the initial list and refresh
    it in the backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the service, we move the initialization and refresh of the journal component
    into the service, using the `getInitialList` and `refreshList` methods.
  prefs: []
  type: TYPE_NORMAL
- en: These methods will be improved when we see the communication with the backend,
    but here, we are already decoupling the exercise list management business rule
    from the component that renders the user interface, creating a specific service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now consider the method that adds an item to the exercise list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `setList` attribute of the service can be null, so here we use the TypeScript
    type guard concept (more details in [*Chapter 3*](B19562_03.xhtml#_idTextAnchor112),
    *TypeScript Patterns for Angular*) to manipulate the array. Here, we also use
    the concept of immutability by returning a new array after adding the new element.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `DiaryComponent` component, we will use the service we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the component, the first thing we can observe is the use of the class constructor,
    declaring an `exerciseSetsService` private attribute of type `ExerciseSetsService`.
    With this declaration, we have an object instantiated and we refactor our component,
    replacing the initialization of the list and the refresh action with service methods.
  prefs: []
  type: TYPE_NORMAL
- en: From now on, it is no longer a concern of the component how the exercise list
    is obtained and managed; this is the responsibility of the service, and we can
    now use this service in other components if necessary. In this piece of code,
    you may be wondering why we are using the `ExerciseSetsService` service if we
    did not instantiate an object of that class.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have a great feature of Angular, which is the dependency injection
    mechanism, and we will delve into this topic next.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the dependency injection pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In object-oriented software development, it is good practice to prioritize composition
    over inheritance, meaning that a class should be composed of other classes (preferably
    interfaces).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our previous example, we can see that the `service` class comprises the
    `DiaryComponent` component. Another way to use this service would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here we modify our code, leaving the creation of the service class object expressly
    in the component’s constructor method. Running our code again, we can see that
    the interface remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach, although functional, has some problems, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: High coupling between the component and the service, which means that we may
    encounter problems if we need to change the implementation of the service, for
    example, for the construction of unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the service depends on another class, as we will see with Angular’s HTTP
    request service, the `HttpClient` class, we will have to implement this dependency
    in our component, increasing its complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To simplify development and solve the problems we’ve described, Angular has
    a dependency injection mechanism. This feature allows us to compose a class just
    by declaring the object we need in its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Angular, leveraging TypeScript, will use the types defined in this declaration
    to assemble the dependency tree of the class we need and create the object we
    require.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s return to our code and analyze how this mechanism works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the code, we declare the dependency of our class in the constructor, creating
    the `exerciseSetsService` attribute. With this, we can initialize the `exerciseList`
    attribute in its declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 10*](B19562_10.xhtml#_idTextAnchor264), *Design for Tests: Best
    Practices*, we will replace the implementation of this service in the test runtime.
    All this is possible thanks to Angular’s dependency injection feature.'
  prefs: []
  type: TYPE_NORMAL
- en: From version 14 of Angular, we have an alternative for dependency injection
    that we can use, which we will see next.
  prefs: []
  type: TYPE_NORMAL
- en: Using the inject() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `inject()` function allows you to use the same dependency injection feature
    but in a simpler way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s refactor our component’s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here we remove the constructor declaration for the dependency injection and
    directly declare the `exerciseSetsService` service. For the creation of the object,
    we use the `inject` function.
  prefs: []
  type: TYPE_NORMAL
- en: A point of note is that we are using the `inject` function of the `@angular/core`
    module and not the function present in the `@angular/core/testing` module, which
    will be used for another purpose.
  prefs: []
  type: TYPE_NORMAL
- en: This method, in addition to being simpler and clearer (the service is being
    injected by the function), allows the simplification of development, if it is
    necessary to use inheritance for a specific component. Remembering that good practice
    says we should prefer composition over inheritance, but especially in libraries,
    this feature can be interesting.
  prefs: []
  type: TYPE_NORMAL
- en: A point of note for the use of the `inject` function is that it can only be
    used in the component’s construction phase, that is, in the declaration of the
    method’s property or in the class’s constructor method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any use in another context will generate the following compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now delve into another aspect of Angular services, which is the use of
    the singleton design pattern, and how we can use this capability for communication
    between components.
  prefs: []
  type: TYPE_NORMAL
- en: Communication between components using services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A characteristic that we must understand about Angular services is that, by
    default, every service instantiated by the dependency injection mechanism has
    the same reference; that is, a new object is not created, but reused.
  prefs: []
  type: TYPE_NORMAL
- en: This is because the dependency injection mechanism implements the singleton
    design pattern to create and deliver the objects. The **singleton pattern** is
    a design pattern of the creational type and allows the creation of objects whose
    access will be global in the system.
  prefs: []
  type: TYPE_NORMAL
- en: This characteristic is important for the service because, as the service deal
    with reusable business rules, we can use the same instance between components,
    without having to rebuild the entire object. In addition, we can take advantage
    of this characteristic and use services as an alternative for communication between
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our gym diary so that the `ListEntriesComponent` component receives
    the initial list by service instead of `@Input`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `DiaryComponent` component, we will remove the list from the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Running it again we can see that the list continues to appear. This is because
    the instance of the service used in both components is the same. However, this
    form of communication requires us to use RxJS to update the values with the buttons
    on the diary screen. We will go deeper into this topic in [*Chapter 9*](B19562_09.xhtml#_idTextAnchor242),
    *Exploring Reactivity* *with RxJS*.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that, by default, the services are singleton, but in Angular, it is possible
    to change this configuration for another service if you need to solve some corner
    cases in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we create a service, it has an `@Injectable` decorator, as in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `provideIn` metadata determines the scope of the service. The value `'root'`
    means that the instance of the service will be unique for every application; that’s
    why, by default, Angular services are singleton.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change this behavior, let’s first return to the `ListEntriesComponent` component
    to receive `@``Input`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s go back to inform the attribute in the `DiaryComponent` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ExerciseSetsService` service, we will remove the `provideIn` metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run our application now, the following error will occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This error happens when we inform Angular that the service should not be instantiated
    in the application scope. To resolve this error, let’s declare the use of the
    service directly in the `DiaryComponent` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So, our system works again, and the component has its own instance of the service.
  prefs: []
  type: TYPE_NORMAL
- en: This technique, however, must be used in specific cases where the component
    must have its own instance of the services it uses; it is recommended to leave
    the `provideIn` in the services.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now start exploring our application’s communication with the backend using
    Angular.
  prefs: []
  type: TYPE_NORMAL
- en: REST API consumption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main uses of Angular services is undoubtedly communication with the
    backend of the application, using the **Representational State Transfer** (**REST**)
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s learn about this feature in practice by preparing our project to consume
    its backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s upload the backend locally by accessing the `gym-diary-backend`
    folder and using the following command in your command-line prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can leave this command running and can now create the services for the consumption
    of the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'To carry out this consumption, Angular has a specialized service – `HttpClient`.
    To use it, we will first import its module into the `app.module.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Our project’s backend API returns some JSON, containing the list of exercises
    for the day. As good practice, we should create an interface to facilitate typing
    and the manipulation of the results in our frontend application. In the `exercise-set.ts`
    file, we will add the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can refactor our `ExerciseSetsService` service to use `HttpClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First, we inject the `HttpClient` service into our class using the `inject`
    function. We then create the `url` variable to contain the endpoint of this service
    that will be used in the service’s methods.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we refactor the `getInitialList` and `refreshList` methods to consume
    the project’s API. Initially, they have the same implementation, but we will improve
    this code throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: An important change was made so that the method does not return the list of
    exercises, but an Observable that contains the list of exercises. This occurs
    because the operation involving consuming a REST API happens asynchronously, and
    through the use of RxJS and its Observables, Angular handles this asynchronicity.
    We will go deeper into this topic in [*Chapter 9*](B19562_09.xhtml#_idTextAnchor242),
    *Exploring Reactivity* *with RxJS*.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `HttpClient` service to consume a *GET-type* API, we declare the return
    type represented here by the `ExerciseSetListAPI` type and the service’s `get`
    method, passing the URL of the endpoint that we are going to consume as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now add the other methods to complete our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: For the inclusion of a new set, we are using the `POST` method of the service
    that calls the API with the verb of the same name. We always pass the URL and,
    in this case, the body of the request will be a new set of exercises.
  prefs: []
  type: TYPE_NORMAL
- en: To update the set, we use the `PUT` method passing the body, and for the URL,
    we use the string interpolation to pass the `id` value that the API demands in
    your contract. Finally, to delete, we use the `DELETE` method, and also using
    interpolation, we pass the `id` value of the element we want to delete.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s tailor our `DiaryComponent` component to consume the refactored service.
    Our challenge here is to deal with the asynchrony of consuming a REST API via
    an HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s adjust the initialization of the list of exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the `DiaryComponent` class, we will implement the `OnInit` interface and
    create the `onInit` method. This method is one of the lifecycle events of Angular
    components, which means that it will be called at some point by Angular when building
    and rendering the interface.
  prefs: []
  type: TYPE_NORMAL
- en: The `onInit` method is called after building the component, but before rendering
    the component. We need to implement this method because the filling of the list
    of exercises will occur asynchronously. Implementing this initialization in the
    `onInit` method will ensure that the data will be there when Angular starts rendering
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this method, we are using the service, but as it now returns an Observable,
    we need to call the `subscribe` method and, within it, implement the initialization
    of the list. As we are using the smart and presentation component architecture,
    we can implement the button methods in the `DiaryComponent` smart component as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the `newList` method, we refactored this to fetch the list elements through
    the `refreshList` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the `addExercise`, `deleteItem`, and `newRep` methods, we refactored the
    previous logic to use the `exerciseSetsService` service.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about Angular services and how to correctly isolate
    the business rule from our applications in a simple and reusable way, as well
    as how Angular services use the singleton pattern for memory and performance optimization.
  prefs: []
  type: TYPE_NORMAL
- en: We worked with and studied Angular’s dependency injection mechanism and noticed
    how important it is to be able to organize and reuse services between components
    and other services. We also learned how to use the `inject` function for Angular
    services as an alternative to dependency injection via Angular’s constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we worked with one of the main uses of services, communication with
    the backend, and in this chapter, we began to explore the integration of our frontend
    applications with the backend.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will study the best practices for using forms, the main
    way that our users enter information into our systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Leveraging Angular’s Capabilities'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will work with more advanced aspects of Angular and see how
    you can use the features of this framework for the most common tasks in your applications.
    You will learn about best practices for forms, how to correctly use Angular’s
    routing mechanism, and finally, how to optimize API consumption using the Interceptor
    design pattern and the RxJS library.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19562_06.xhtml#_idTextAnchor186)*, Handling User Inputs: Forms*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19562_07.xhtml#_idTextAnchor207)*, Routes and Routers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19562_08.xhtml#_idTextAnchor225)*, Improving Backend Integrations:
    the Interceptor Pattern*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19562_09.xhtml#_idTextAnchor242)*, Exploring Reactivity with
    RXJS*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
