<html><head></head><body>
<div id="_idContainer077">
<h1 class="chapter-number" id="_idParaDest-159"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-160"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.2.1">Testing and Source Control</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The success of our application depends on many factors, beyond the quality of our code organization or patterns. </span><span class="koboSpan" id="kobo.3.2">Moreover, the very nature of software implies that there will be changes during and after development, changes in the requirements, the scope, and so on. </span><span class="koboSpan" id="kobo.3.3">With each feature developed, an item of complexity is introduced into the software, creating relationships and dependencies. </span><span class="koboSpan" id="kobo.3.4">New inclusions may disrupt these connections and introduce breaking changes, bugs, or even completely disable the system. </span><span class="koboSpan" id="kobo.3.5">The solution for this problem is to keep track of code changes and conduct tests on the application to identify problems and ensure as much as possible that the system complies with the desired software attributes and satisfies </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">the requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will cover </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Different approaches to testing and the concept of </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">test-driven </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.9.1">development (TDD)</span></strong></span></li>
<li><span class="koboSpan" id="kobo.10.1">Installing a test suite (Vitest) and test tools (Vue Test Utils) for </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">our project</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Creating and running tests on an existing project for synchronous and </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">asynchronous code</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Testing our components by simulating </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">user interactions</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Installing and managing our source code using Git and online repositories such as GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">or GitLab</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.18.1">The concepts in this chapter are introductions to important professional skills for a developer to ensure the delivery of good-quality software. </span><span class="koboSpan" id="kobo.18.2">Often, these tasks are left aside or relegated as an afterthought. </span><span class="koboSpan" id="kobo.18.3">However, the lack of them may lead to expensive mistakes and lengthy overwork as the software complexity grows. </span><span class="koboSpan" id="kobo.18.4">For non-trivial applications with more than one developer </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">involved, nowadays,</span></span><span class="koboSpan" id="kobo.20.1">
it is hardly possible to conceive a project that does not use some of </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">these tools.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">In this chapter, we will focus on </span><strong class="bold"><span class="koboSpan" id="kobo.23.1">unit testing</span></strong><span class="koboSpan" id="kobo.24.1"> and the tools provided by the Vue team to </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">perform it.</span></span></p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.26.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.27.1">This chapter does not have additional requirements to those of previous implementations of code examples. </span><span class="koboSpan" id="kobo.27.2">The final source code can be found in the official repository for this book </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">at </span></span><a href="https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter09"><span class="No-Break"><span class="koboSpan" id="kobo.29.1">https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter09</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.30.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">Check out the following video to see the Code in </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">Action: </span></span><a href="https://packt.link/UqRIi"><span class="No-Break"><span class="koboSpan" id="kobo.33.1">https://packt.link/UqRIi</span></span></a></p>
<h1 id="_idParaDest-162"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.34.1">What are testing and TDD</span></h1>
<p><span class="koboSpan" id="kobo.35.1">Testing is the </span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.36.1">process to verify that the software is doing what it is supposed to do, according to the requirements of the project. </span><span class="koboSpan" id="kobo.36.2">It involves the manual or automated execution of tools to evaluate and measure different properties and attributes of the software, identify errors and bugs, and provide feedback for developers to take action to correct them. </span><span class="koboSpan" id="kobo.36.3">There are many different approaches and types of tests to be performed, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.38.1">Unit testing</span></strong><span class="koboSpan" id="kobo.39.1">: This is </span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.40.1">where relevant</span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.41.1"> units of the source code are validated against a series of inputs and outputs. </span><span class="koboSpan" id="kobo.41.2">It is </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">often automated.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.43.1">Integration testing</span></strong><span class="koboSpan" id="kobo.44.1">: All the</span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.45.1"> components of a system are verified together as a group, looking for</span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.46.1"> errors and bugs in the resulting integration, communication, and </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">so on.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.48.1">End-to-end testing</span></strong><span class="koboSpan" id="kobo.49.1">: This</span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.50.1"> involves a complete validation of the application</span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.51.1"> simulating real-world use, interacting with databases, network scenarios, and so on. </span><span class="koboSpan" id="kobo.51.2">It can be performed with automated tools that simulate human interaction, and manual testing using </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">real-life users.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.53.1">These types of testing are just a small sample of this discipline, as there are hundreds of possible tests to apply to the software. </span><span class="koboSpan" id="kobo.53.2">Large companies may have entire testing teams dedicated to ensuring the quality of the software. </span><span class="koboSpan" id="kobo.53.3">Usually, the more complex the software, the more complex the testing may be. </span><span class="koboSpan" id="kobo.53.4">In practice, the testing plan can be as complex as the development plan itself. </span><span class="koboSpan" id="kobo.53.5">As mentioned in the introduction, we will focus on the official tools provided by the Vue team for </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">this task.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">Testing</span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.56.1"> can be done before, during, after, or in parallel with the development. </span><strong class="bold"><span class="koboSpan" id="kobo.57.1">TDD</span></strong><span class="koboSpan" id="kobo.58.1"> is a </span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.59.1">discipline that places the burden of testing as early in the project as possible, even before the actual coding begins, with the objective to match the requirements. </span><span class="koboSpan" id="kobo.59.2">It involves the </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.61.1">Write a test case, based on the requirements and design of the application, with key inputs and </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">expected outputs.</span></span></li>
<li><span class="koboSpan" id="kobo.63.1">Run the test, which should fail (as there is no code </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">written yet).</span></span></li>
<li><span class="koboSpan" id="kobo.65.1">Write the actual code to be tested (a function, Vue </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">component, etc.).</span></span></li>
<li><span class="koboSpan" id="kobo.67.1">Run the test against the created code. </span><span class="koboSpan" id="kobo.67.2">If it fails, refactor the code </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">or design.</span></span></li>
<li><span class="koboSpan" id="kobo.69.1">Start again with a new test case for the </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">next unit.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.71.1">This process is repeated, and it is expected to provide developers with a significant reduction of “bugs” and errors and help them focus on the requirements. </span><span class="koboSpan" id="kobo.71.2">This does incur an overhead of effort early in the project, as opposed to refactoring, when the tests are performed toward </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">the end.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">TDD has </span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.74.1">become popular in some teams and with some frameworks, and it is supposed to help developers improve their own code as they now acquire a “testing” mindset. </span><span class="koboSpan" id="kobo.74.2">However, there are no specific studies made to confirm this, but practitioners of this discipline do report that it has improved their code and design. </span><span class="koboSpan" id="kobo.74.3">This, of course, begs the question: what needs to be tested, and how can we streamline the task into our workflow? </span><span class="koboSpan" id="kobo.74.4">That is the topic we will </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">discuss next.</span></span></p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.76.1">What to test</span></h1>
<p><span class="koboSpan" id="kobo.77.1">A key</span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.78.1"> factor in the success of a good testing plan and implementation is deciding what to test. </span><span class="koboSpan" id="kobo.78.2">It is not possible to test the full universe of possibilities or 100% of the components and interactions in a project when considering internal and external factors. </span><span class="koboSpan" id="kobo.78.3">Even the attempt to fully cover all possibilities would be incredibly expensive and practically impossible. </span><span class="koboSpan" id="kobo.78.4">Instead, the focus needs to be on the real possibilities of what can be tested within our time and budget constraints, by carefully selecting the non-trivial elements that “make or break” our project requirements. </span><span class="koboSpan" id="kobo.78.5">This is often not an </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">easy task.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">When it comes to Vue applications, we need to </span><a id="_idIndexMarker698"/><span class="koboSpan" id="kobo.81.1">focus on crucial services and components that perform key operations. </span><span class="koboSpan" id="kobo.81.2">We need to test </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.83.1">Services</span></strong><span class="koboSpan" id="kobo.84.1">: Self-contained</span><a id="_idIndexMarker699"/><span class="koboSpan" id="kobo.85.1"> functions, both synchronous and asynchronous. </span><span class="koboSpan" id="kobo.85.2">Functions that don’t return a value but perform logical procedures will serve a different kind of testing than what we will see here. </span><span class="koboSpan" id="kobo.85.3">These will involve mocking network communications or database calls, application policies, and so on. </span><span class="koboSpan" id="kobo.85.4">However, the principles for testing these </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">are similar.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.87.1">Components</span></strong><span class="koboSpan" id="kobo.88.1">: We need to</span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.89.1"> test inputs (props) and outputs (events and HTML). </span><span class="koboSpan" id="kobo.89.2">Higher-level components that group other components to perform a workflow or business logic can also be tested in the same way (props, events, and HTML rendered). </span><span class="koboSpan" id="kobo.89.3">However, these also will need other types of testing, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">end-to-end testing.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.91.1">We can write our own functions and tools to perform tests, but apart from some edge cases, the obvious recommendation is to use stable test suites and tools. </span><span class="koboSpan" id="kobo.91.2">In our case, for Vue, there are official resources provided by the </span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.92.1">same team, called </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">Vitest</span></strong><span class="koboSpan" id="kobo.94.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">Vue Test Utils</span></strong><span class="koboSpan" id="kobo.96.1">. </span><span class="koboSpan" id="kobo.96.2">Using </span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.97.1">a testing suite/library has many benefits, akin to the use of a framework or library in the “regular” development of an application. </span><span class="koboSpan" id="kobo.97.2">Perhaps one of the major benefits has to do with </span><strong class="bold"><span class="koboSpan" id="kobo.98.1">DX</span></strong><span class="koboSpan" id="kobo.99.1">, or </span><strong class="bold"><span class="koboSpan" id="kobo.100.1">Developer eXperience</span></strong><span class="koboSpan" id="kobo.101.1">, as they </span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.102.1">streamline and make the development process easier or lighter in the best case. </span><span class="koboSpan" id="kobo.102.2">Let’s learn how to apply these tools in our workflow by going through an example application, which we will address in the </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">next section.</span></span></p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.104.1">Our base example application</span></h1>
<p><span class="koboSpan" id="kobo.105.1">It is </span><a id="_idIndexMarker704"/><span class="koboSpan" id="kobo.106.1">best to understand the discipline of testing and learn about the tools by applying them to a real project through practice. </span><span class="koboSpan" id="kobo.106.2">As a learning exercise, we will first take a running application based on one of the examples presented in </span><a href="B18602_02.xhtml#_idTextAnchor040"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.107.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.108.1">, </span><em class="italic"><span class="koboSpan" id="kobo.109.1">Software Design Principles and Patterns</span></em><span class="koboSpan" id="kobo.110.1">. </span><span class="koboSpan" id="kobo.110.2">We will build a </span><strong class="bold"><span class="koboSpan" id="kobo.111.1">Fibonacci calculator</span></strong><span class="koboSpan" id="kobo.112.1"> and install the Vitest test suite and Vue Testing Utils to the project. </span><span class="koboSpan" id="kobo.112.2">Later, we will explain what would change in this approach when applying the </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">TDD discipline.</span></span></p>
<p><span class="koboSpan" id="kobo.114.1">The code for this application can be found in the repository for this chapter. </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">Once downloaded,</span></span><span class="koboSpan" id="kobo.116.1">
you need to execute the following command to install </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">the dependencies:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.118.1">
$ npm install</span></pre>
<p><span class="koboSpan" id="kobo.119.1">Then, to run the application, you must run </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.121.1">
$ npm run start</span></pre>
<p><span class="koboSpan" id="kobo.122.1">When the server is ready, loading the site in your web browser should present you with an application </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<span class="koboSpan" id="kobo.124.1"><img alt="Figure 9.1 – The example application with a Fibonacci calculator" src="image/Figure_9.01_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.125.1">Figure 9.1 – The example application with a Fibonacci calculator</span></p>
<p><span class="koboSpan" id="kobo.126.1">The design of this application has been made with the purpose of learning the basics of testing functions and components, so it is very basic but sufficient. </span><span class="koboSpan" id="kobo.126.2">We are presented with one service file (</span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">/src/services/Fibonacci.js</span></strong><span class="koboSpan" id="kobo.128.1">) and three components: </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">App.vue</span></strong><span class="koboSpan" id="kobo.130.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">FibonacciInput.vue</span></strong><span class="koboSpan" id="kobo.132.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">FibonacciOutput.vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<span class="koboSpan" id="kobo.136.1"><img alt="Figure 9.2 – Components and service for the application" src="image/Figure_9.02_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.137.1">Figure 9.2 – Components and service for the application</span></p>
<p><span class="koboSpan" id="kobo.138.1">Our application-level component, </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">App.vue</span></strong><span class="koboSpan" id="kobo.140.1">, receives from </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">FibonacciInput.vue</span></strong><span class="koboSpan" id="kobo.142.1"> a positive integer number through an event, which passes as a prop input to </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">FibonacciOutput.vue</span></strong><span class="koboSpan" id="kobo.144.1">. </span><span class="koboSpan" id="kobo.144.2">This component uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">Fibonacci.js</span></strong><span class="koboSpan" id="kobo.146.1"> service to calculate the respective Fibonacci number corresponding in the series and present it to the user. </span><span class="koboSpan" id="kobo.146.2">As simple as this application sounds, it gives us basic examples to create tests for the most common </span><a id="_idIndexMarker705"/><span class="koboSpan" id="kobo.147.1">cases, which will give us a solid start. </span><span class="koboSpan" id="kobo.147.2">It is now time to install our </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">test suite.</span></span></p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.149.1">Installation and use of Vitest</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.150.1">Vitest</span></strong><span class="koboSpan" id="kobo.151.1"> (</span><a href="https://vitest.dev/"><span class="koboSpan" id="kobo.152.1">https://vitest.dev/</span></a><span class="koboSpan" id="kobo.153.1">) is a</span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.154.1"> test suite, meaning that it provides, out of the box, a set of tools and a</span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.155.1"> framework to perform tests in our code. </span><span class="koboSpan" id="kobo.155.2">Being developed by the Vue and Vite teams, it integrates seamlessly with Vite, even sharing the same configuration and respecting each other’s organization. </span><em class="italic"><span class="koboSpan" id="kobo.156.1">Vitest </span></em><span class="koboSpan" id="kobo.157.1">can be selected during the original creation of a Vue project by selecting the proper option during the creation wizard – a task that will add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">/src/__tests__</span></strong><span class="koboSpan" id="kobo.159.1"> folder, some examples, and a few extra entries in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">package.json</span></strong><span class="koboSpan" id="kobo.161.1"> file. </span><span class="koboSpan" id="kobo.161.2">But all this boilerplate can be a bit confusing </span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.162.1">unless we have previous experience in this area. </span><span class="koboSpan" id="kobo.162.2">Instead, we start from an already created project, so we will install Vitest as a development dependency – a task that will give us an insight into how it works and </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">is organized.</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">Install Vitest from the command line at the root directory of the project with </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">this command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.166.1">
$ npm install -D vitest</span></pre>
<p><span class="koboSpan" id="kobo.167.1">The package manager will take some time to include Vitest and all necessary dependencies but won’t modify our source code or organization. </span><span class="koboSpan" id="kobo.167.2">For convenience, we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">npm</span></strong><span class="koboSpan" id="kobo.169.1"> as well to run our tests, so we need to open our </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">package.json</span></strong><span class="koboSpan" id="kobo.171.1"> file, and in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">scripts</span></strong><span class="koboSpan" id="kobo.173.1"> section, enter the following lines so the section looks </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.175.1">
"scripts": {
    "start":"vite",
    "build": "vite build",
    "preview": "vite preview",
</span><strong class="bold"><span class="koboSpan" id="kobo.176.1">    "test": "vitest",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.177.1">    "test:once": "vitest run",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.178.1">    "test:coverage": "vitest run --coverage"</span></strong><span class="koboSpan" id="kobo.179.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.180.1">At this point, we can now test our </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">test suite:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.182.1">
$ npm run test</span></pre>
<p><span class="koboSpan" id="kobo.183.1">After you </span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.184.1">run that command, you will be graciously greeted with a red message explaining that the tests have failed. </span><span class="koboSpan" id="kobo.184.2">Perfect. </span><span class="koboSpan" id="kobo.184.3">This is what it should do, as we do not have any tests yet! </span><span class="koboSpan" id="kobo.184.4">So, let’s add them. </span><span class="koboSpan" id="kobo.184.5">We will start by testing our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">Fibonacci.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.186.1"> service.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">Vitest allows us to write our test functions in independent files or in-source, meaning that we place them alongside our component’s JavaScript. </span><span class="koboSpan" id="kobo.187.2">There are benefits and trade-offs with both approaches, but to start, we will place our test code in independent files, one for each service and component. </span><span class="koboSpan" id="kobo.187.3">In this way, we place these files in their own directory, which by convention can be either </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">/src/tests</span></strong><span class="koboSpan" id="kobo.189.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">/src/components/__tests__</span></strong><span class="koboSpan" id="kobo.191.1">, but they could also be placed alongside the Single File Components or with the services. </span><span class="koboSpan" id="kobo.191.2">Vitest will scan the entire source folder for the test files. </span><span class="koboSpan" id="kobo.191.3">Even though we can be very creative when placing these files, we will place them in </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">/src/test</span></strong><span class="koboSpan" id="kobo.193.1"> to keep things neat and tidy. </span><span class="koboSpan" id="kobo.193.2">There is another convention to adhere to, which is that each test file must have the same name as the file being tested, plus the </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">.spec.js</span></strong><span class="koboSpan" id="kobo.195.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">.test.js</span></strong><span class="koboSpan" id="kobo.197.1"> extension. </span><span class="koboSpan" id="kobo.197.2">Vitest uses this convention to identify and run the tests in an organized manner. </span><span class="koboSpan" id="kobo.197.3">So, in our case, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">Fibonacci.js</span></strong><span class="koboSpan" id="kobo.199.1"> service will have its testing counterpart in </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">/src/tests/Fibonacci.test.js</span></strong><span class="koboSpan" id="kobo.201.1">. </span><span class="koboSpan" id="kobo.201.2">Go ahead and create that file, and enter the </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">following lines:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.203.1">/src/tests/Fibonacci.test.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.204.1">
import { </span><strong class="bold"><span class="koboSpan" id="kobo.205.1">describe, expect, test</span></strong><span class="koboSpan" id="kobo.206.1"> } from "vitest"
import { Fibonacci, FibonacciPromise } from "../services/Fibonacci.js"</span></pre>
<p><span class="koboSpan" id="kobo.207.1">In the first line, we</span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.208.1"> import three functions from Vitest, which are the foundation of all our testing, and the ones that we will be using most often. </span><span class="koboSpan" id="kobo.208.2">Here is what each </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">one does:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">describe(String, Function)</span></strong><span class="koboSpan" id="kobo.211.1">: This function groups together a number of tests, and Vitest will report the test group by using the description given as the first parameter. </span><span class="koboSpan" id="kobo.211.2">The second parameter is a function, where we will run the tests with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">test()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.213.1"> function.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">test(String, Function)</span></strong><span class="koboSpan" id="kobo.215.1">: The first parameter is a description of the tests encompassed in the second parameter, which is a function. </span><span class="koboSpan" id="kobo.215.2">The test will “pass” if no errors are thrown within it. </span><span class="koboSpan" id="kobo.215.3">This means that we can write our own test logic and tools following this condition and throw a JavaScript error when the validation fails. </span><span class="koboSpan" id="kobo.215.4">However, there is a </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">simpler approach...</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">expect(value)</span></strong><span class="koboSpan" id="kobo.218.1">: This is the function that performs the “magic” of testing. </span><span class="koboSpan" id="kobo.218.2">It receives, as a unique argument, a single value or a function that resolves to a single value. </span><span class="koboSpan" id="kobo.218.3">The result of </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">expect()</span></strong><span class="koboSpan" id="kobo.220.1"> is a chainable object that exposes many different and almost language-natural assertions (comparisons, validations, etc.) to perform on the argument value. </span><span class="koboSpan" id="kobo.220.2">Under the hood, it uses the Chia syntax to a certain extent and is also compatible with other test suites, such as Jest – for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">expect(2).toBe(2)</span></strong><span class="koboSpan" id="kobo.222.1">. </span><span class="koboSpan" id="kobo.222.2">A full list of all the possible assertion methods can be found in the official documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">here: </span></span><a href="https://vitest.dev/api/expect.html"><span class="No-Break"><span class="koboSpan" id="kobo.224.1">https://vitest.dev/api/expect.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.225.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.226.1">In the second line of the test file, we directly import the two functions contained in the service: </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">Fibonacci()</span></strong><span class="koboSpan" id="kobo.228.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">FibonacciPromise()</span></strong><span class="koboSpan" id="kobo.230.1">. </span><span class="koboSpan" id="kobo.230.2">We need to import each function that we want to test, and then create as many test groups as necessary for each one. </span><span class="koboSpan" id="kobo.230.3">Let’s start with the self-contained </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">Fibonacci()</span></strong><span class="koboSpan" id="kobo.232.1"> function by adding the following </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">test group:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.234.1">describe</span></strong><span class="koboSpan" id="kobo.235.1">("Test the results from Fibonacci()", () =&gt; {
 </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">test</span></strong><span class="koboSpan" id="kobo.237.1">("Results according to the series definition", ()=&gt;{
    // Expected values as defined by the series
    </span><strong class="bold"><span class="koboSpan" id="kobo.238.1">expect(</span></strong><span class="koboSpan" id="kobo.239.1">Fibonacci(0)</span><strong class="bold"><span class="koboSpan" id="kobo.240.1">).toBe(0)</span></strong><span class="koboSpan" id="kobo.241.1">
    expect(Fibonacci(1)).toBe(1)
    expect(Fibonacci(2)).toBe(1)
    expect(Fibonacci(3)).toBe(2)
    // A known value defined by calculation of the series
    expect(Fibonacci(10)).toBe(55)
 })
})</span></pre>
<p><span class="koboSpan" id="kobo.242.1">We start by </span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.243.1">creating a test group with </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">describe()</span></strong><span class="koboSpan" id="kobo.245.1"> and create inside the passed function as many tests as needed. </span><span class="koboSpan" id="kobo.245.2">Inside each </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">test()</span></strong><span class="koboSpan" id="kobo.247.1"> function, we can create as many assertions as needed, but it has to have at least one. </span><span class="koboSpan" id="kobo.247.2">Notice how we are executing the function from the service with different arguments, and then asserting them to the expected value as defined in the numerical series. </span><span class="koboSpan" id="kobo.247.3">In this case, we are using </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">.toBe() </span></strong><span class="koboSpan" id="kobo.249.1">to test equality, but in the same way, we could be testing strings, objects, types, and so on, using other assertions, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">.not, .toEqual, .toBeGreaterThan</span></strong><span class="koboSpan" id="kobo.251.1">, etc. </span><span class="koboSpan" id="kobo.251.2">There are more than 50 assertion methods defined in the documentation (</span><a href="https://vitest.dev/api/expect.html"><span class="koboSpan" id="kobo.252.1">https://vitest.dev/api/expect.html</span></a><span class="koboSpan" id="kobo.253.1">). </span><span class="koboSpan" id="kobo.253.2">Take some time to review them, and remember that these are chainable, so you can make more than one assertion </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">at once.</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">After saving this file, you can run the </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">test again:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.257.1">
$ npm run test</span></pre>
<p><span class="koboSpan" id="kobo.258.1">You should receive a few messages in green, indicating the number of tests performed and whether they passed or not. </span><span class="koboSpan" id="kobo.258.2">In the case that one raises an error, it will be pointed out in red letters using the descriptive text and line where it occurred. </span><span class="koboSpan" id="kobo.258.3">That is a sign to start refactoring the code (assuming the test function and assertion were properly and correctly written; otherwise, you get a </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">false positive!).</span></span></p>
<p><span class="koboSpan" id="kobo.260.1">In the case that no assertion method works for a particular edge case, you can create inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">test()</span></strong><span class="koboSpan" id="kobo.262.1"> your own logic in plain JavaScript and throw an error when the validation fails. </span><span class="koboSpan" id="kobo.262.2">For example, these two code snippets </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">are equivalent:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.264.1">
// Using expect
expect(Fibonacci(10)).toBe(55);
// Using your own logic
let result=Fibonacci(10);
if(result!=55) throw Error("Calculation failed");</span></pre>
<p><span class="koboSpan" id="kobo.265.1">Even though this example is trivial, it is easy to see how the first case, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">expect()</span></strong><span class="koboSpan" id="kobo.267.1">, results in a </span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.268.1">better developer experience, as it is succinct, elegant, and easy </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">to read.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.270.1">Vitest is still running!</span></p>
<p class="callout"><span class="koboSpan" id="kobo.271.1">Perhaps you have noticed that running </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">npm run test</span></strong><span class="koboSpan" id="kobo.273.1"> does not end the execution of the script once the tests have terminated. </span><span class="koboSpan" id="kobo.273.2">Just like with a developer server, Vitest keeps waiting for changes to occur to the source code or test files and automatically reruns all the tests for you. </span><span class="koboSpan" id="kobo.273.3">If you want to run the tests only once, use </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">npm run test:once</span></strong><span class="koboSpan" id="kobo.275.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">vitest –-run</span></strong><span class="koboSpan" id="kobo.277.1"> to flag Vitest to run the tests only once and </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">then exit.</span></span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.279.1">Special assertion case – fail on purpose</span></h2>
<p><span class="koboSpan" id="kobo.280.1">All the</span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.281.1"> previous assertions thus far have been made using the “positive” approach that a function will return what is expected. </span><span class="koboSpan" id="kobo.281.2">Using the “negative” approach in testing is to make sure that a function will fail when it is supposed to. </span><span class="koboSpan" id="kobo.281.3">For example, the Fibonacci series is not defined for negative numbers, so any calculation should not return a value but should throw an error. </span><span class="koboSpan" id="kobo.281.4">In these cases, we need to wrap the execution of the function in another function, thus encapsulating it to test the assertion against a thrown error. </span><span class="koboSpan" id="kobo.281.5">This would be the equivalent of using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">try..catch</span></strong><span class="koboSpan" id="kobo.283.1"> block in plain JavaScript to avoid terminating the execution of the script when an error occurs. </span><span class="koboSpan" id="kobo.283.2">For example, executing </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">Fibonacci(-5)</span></strong><span class="koboSpan" id="kobo.285.1"> should throw an error, so we will write our test case </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">as this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.287.1">
test("Out of range, must fail and throw an error", ()=&gt;{
    </span><strong class="bold"><span class="koboSpan" id="kobo.288.1">expect(()=&gt;</span></strong><span class="koboSpan" id="kobo.289.1">Fibonacci(-5)</span><strong class="bold"><span class="koboSpan" id="kobo.290.1">).toThrow()</span></strong><span class="koboSpan" id="kobo.291.1">
})</span></pre>
<p><span class="koboSpan" id="kobo.292.1">The preceding</span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.293.1"> assertion will work as expected, without interrupting the </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">testing process.</span></span></p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.295.1">Special assertion case – asynchronous code</span></h2>
<p><span class="koboSpan" id="kobo.296.1">Another </span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.297.1">special case to keep in mind is asynchronous code, such as network calls, promises, and so on. </span><span class="koboSpan" id="kobo.297.2">In this case, the solution is to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">async..await</span></strong><span class="koboSpan" id="kobo.299.1">, not on the function but on </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">expect</span></strong><span class="koboSpan" id="kobo.301.1">. </span><span class="koboSpan" id="kobo.301.2">For example, to test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">FibonacciPromise()</span></strong><span class="koboSpan" id="kobo.303.1"> asynchronous function, we would write a test </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.305.1">
test("Resolve promise", </span><strong class="bold"><span class="koboSpan" id="kobo.306.1">async </span></strong><span class="koboSpan" id="kobo.307.1">()=&gt;{
</span><strong class="bold"><span class="koboSpan" id="kobo.308.1">    await </span></strong><span class="koboSpan" id="kobo.309.1">expect(FibonacciPromise(10))</span><strong class="bold"><span class="koboSpan" id="kobo.310.1">.resolves</span></strong><span class="koboSpan" id="kobo.311.1">.toBe(55)
})</span></pre>
<p><span class="koboSpan" id="kobo.312.1">Notice how we are applying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">async</span></strong><span class="koboSpan" id="kobo.314.1"> syntax to the entire test function, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">await</span></strong><span class="koboSpan" id="kobo.316.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">expect()</span></strong><span class="koboSpan" id="kobo.318.1"> function. </span><span class="koboSpan" id="kobo.318.2">We also need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">.resolves</span></strong><span class="koboSpan" id="kobo.320.1"> assertion to indicate the successful resolution for the value to validate. </span><span class="koboSpan" id="kobo.320.2">If we needed to test a </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">Promise</span></strong><span class="koboSpan" id="kobo.322.1"> rejection, we would use </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">.rejects</span></strong><span class="koboSpan" id="kobo.324.1"> instead </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">.resolves</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.328.1">With this, we have covered the majority of tools and test approaches to get us started in unit-testing our plain JavaScript functions. </span><span class="koboSpan" id="kobo.328.2">However, all these tests are executed using </span><strong class="bold"><span class="koboSpan" id="kobo.329.1">Node.js</span></strong><span class="koboSpan" id="kobo.330.1"> (the server version of JavaScript), not on the browser where our Vue components will be executed. </span><span class="koboSpan" id="kobo.330.2">In Node.js, there is no </span><strong class="bold"><span class="koboSpan" id="kobo.331.1">DOM</span></strong><span class="koboSpan" id="kobo.332.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.333.1">Windows</span></strong><span class="koboSpan" id="kobo.334.1"> object, so we don’t have any HTML... </span><span class="koboSpan" id="kobo.334.2">so how do we test our </span><strong class="bold"><span class="koboSpan" id="kobo.335.1">Single File Components</span></strong><span class="koboSpan" id="kobo.336.1">? </span></p>
<p><span class="koboSpan" id="kobo.337.1">The answer is to provide Vitest with a simulated DOM where we can mount our components and run tests as if it were a browser window. </span><span class="koboSpan" id="kobo.337.2">Here is where the Vue Test Utils tools come </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">into play.</span></span></p>
<h1 id="_idParaDest-168"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.339.1">Installation of Vue Test Utils</span></h1>
<p><span class="koboSpan" id="kobo.340.1">As of now, Vitest provides us, out of the box, with tools to test plain JavaScript functions, classes, events, and so on. </span><span class="koboSpan" id="kobo.340.2">To test our Single File Components, we need additional resources, and these are provided to us again by the official </span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.341.1">Vue team in the </span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.342.1">form of </span><strong class="bold"><span class="koboSpan" id="kobo.343.1">Vue Test Utils</span></strong><span class="koboSpan" id="kobo.344.1"> (</span><a href="https://test-utils.vuejs.org/"><span class="koboSpan" id="kobo.345.1">https://test-utils.vuejs.org/</span></a><span class="koboSpan" id="kobo.346.1">). </span><span class="koboSpan" id="kobo.346.2">To install them, run the </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.348.1">
$ npm install -D @vue/test-utils</span></pre>
<p><span class="koboSpan" id="kobo.349.1">Once the</span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.350.1"> installation has completed, we need to update our </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">vite.config.js</span></strong><span class="koboSpan" id="kobo.352.1"> file to include the environment where the components will be tested, meaning a browser context. </span><span class="koboSpan" id="kobo.352.2">Modify the configuration file so it looks </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.354.1">
export default defineConfig({
    plugins: [vue()],
    </span><strong class="bold"><span class="koboSpan" id="kobo.355.1">test:{environment:"jsdom"}</span></strong><span class="koboSpan" id="kobo.356.1">
})</span></pre>
<p><span class="koboSpan" id="kobo.357.1">Vitest and Vue Test Utils both integrate seamlessly with Vite, to the point that they share the same configuration file. </span><span class="koboSpan" id="kobo.357.2">You can now run the test suite, and Vitest will attempt to download and install any missing dependencies on the first run after these modifications. </span><span class="koboSpan" id="kobo.357.3">If for some reason the installation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">jsdom</span></strong><span class="koboSpan" id="kobo.359.1"> does not happen automatically, you can install it manually with </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">this command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.361.1">
$ npm install –D jsdom</span></pre>
<p><span class="koboSpan" id="kobo.362.1">Now, with these changes, we are ready to start our first component tests. </span><span class="koboSpan" id="kobo.362.2">Let’s start creating a file to test our </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">FibonacciOutput.vue</span></strong><span class="koboSpan" id="kobo.364.1"> component, as it is the simplest, we have in our application. </span><span class="koboSpan" id="kobo.364.2">Create the following file in the test directory with </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">this code:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.366.1">/src/tests/FibonacciOutput.test.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.367.1">
import { describe, expect, test } from "vitest"
</span><strong class="bold"><span class="koboSpan" id="kobo.368.1">import { mount } from "@vue/test-utils"</span></strong><span class="koboSpan" id="kobo.369.1">                             </span><strong class="bold"><span class="koboSpan" id="kobo.370.1">#1</span></strong><span class="koboSpan" id="kobo.371.1">
import </span><strong class="bold"><span class="koboSpan" id="kobo.372.1">FibonacciOutput </span></strong><span class="koboSpan" id="kobo.373.1">from "../components/FibonacciOutput.vue"     </span><strong class="bold"><span class="koboSpan" id="kobo.374.1">#2</span></strong><span class="koboSpan" id="kobo.375.1">
describe("Check Component props and HTML", () =&gt; {
    test("Props input and HTML output", () =&gt; {
</span><strong class="bold"><span class="koboSpan" id="kobo.376.1">        const wrapper = mount(FibonacciOutput,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.377.1">            { props: { number: 10 } })</span></strong><span class="koboSpan" id="kobo.378.1">                              </span><strong class="bold"><span class="koboSpan" id="kobo.379.1">#3</span></strong><span class="koboSpan" id="kobo.380.1">
        expect(</span><strong class="bold"><span class="koboSpan" id="kobo.381.1">wrapper.text()</span></strong><span class="koboSpan" id="kobo.382.1">).toContain(55)                        </span><strong class="bold"><span class="koboSpan" id="kobo.383.1">#4</span></strong><span class="koboSpan" id="kobo.384.1">
    })
})</span></pre>
<p><span class="koboSpan" id="kobo.385.1">The preceding code is not that different from a basic unit test as we have done before, but it does some things a bit differently. </span><span class="koboSpan" id="kobo.385.2">In line </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">#1</span></strong><span class="koboSpan" id="kobo.387.1">, we import a function from the Vue Test Utils library that allows us to “mount” our component in a test environment simulating a browser window with Vue 3. </span><span class="koboSpan" id="kobo.387.2">In line </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">#2</span></strong><span class="koboSpan" id="kobo.389.1">, we import our component in the usual way, and then proceed to write our test group as before. </span><span class="koboSpan" id="kobo.389.2">The difference here is in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">#3</span></strong><span class="koboSpan" id="kobo.391.1">. </span><span class="koboSpan" id="kobo.391.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">mount</span></strong><span class="koboSpan" id="kobo.393.1"> function to create our live component by passing it as the first argument and, as the second, we pass an object with properties that will be applied to the component. </span><span class="koboSpan" id="kobo.393.2">In this case, we are passing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">number</span></strong><span class="koboSpan" id="kobo.395.1"> prop with a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">10</span></strong><span class="koboSpan" id="kobo.397.1">. </span><span class="koboSpan" id="kobo.397.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">mount</span></strong><span class="koboSpan" id="kobo.399.1"> function will return a wrapper object representing our component, exposing an API that we access to perform our assertions. </span><span class="koboSpan" id="kobo.399.2">In this case, in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">#4</span></strong><span class="koboSpan" id="kobo.401.1">, we are checking that the plain text rendered by the component contains the value 55, which we will find to be true when the test is run. </span><span class="koboSpan" id="kobo.401.2">It is by using this wrapper object that we can access the component </span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.402.1">properties, events, slots, and rendered HTML by accessing the proper methods. </span><span class="koboSpan" id="kobo.402.2">We will only discuss a few in this chapter, but a full list is available in the official documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">at </span></span><a href="https://test-utils.vuejs.org/api/#wrapper-methods"><span class="No-Break"><span class="koboSpan" id="kobo.404.1">https://test-utils.vuejs.org/api/#wrapper-methods</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.405.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.406.1">This short example gives us a template to write our tests, but now we move to a more complex example to test our </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">input</span></strong><span class="koboSpan" id="kobo.408.1"> component. </span><span class="koboSpan" id="kobo.408.2">In the test directory, create the </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">following file:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.410.1">/src/tests/FibonacciInput.test.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.411.1">
import { describe, expect, test } from "vitest"
import { mount } from "@vue/test-utils"
import FibonacciInput from "../components/FibonacciInput.vue"
describe("Check Component action and event", ()=&gt;{
    test("Enter value and emit event on button click",()=&gt;{
</span><strong class="bold"><span class="koboSpan" id="kobo.412.1">        let wrapper=mount(FibonacciInput)</span></strong><span class="koboSpan" id="kobo.413.1">                           </span><strong class="bold"><span class="koboSpan" id="kobo.414.1">#1</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.415.1">        wrapper.find("input").setValue(10)</span></strong><span class="koboSpan" id="kobo.416.1">                          </span><strong class="bold"><span class="koboSpan" id="kobo.417.1">#2</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.418.1">        wrapper.find("button").trigger("click")</span></strong><span class="koboSpan" id="kobo.419.1">                     </span><strong class="bold"><span class="koboSpan" id="kobo.420.1">#3</span></strong><span class="koboSpan" id="kobo.421.1">
        // Capture the event parameters
</span><strong class="bold"><span class="koboSpan" id="kobo.422.1">        let inputEvents=wrapper.emitted("input")</span></strong><span class="koboSpan" id="kobo.423.1">                    </span><strong class="bold"><span class="koboSpan" id="kobo.424.1">#4</span></strong><span class="koboSpan" id="kobo.425.1">
        // Assert the event was emitted, and with the correct value
        // Each event provides an array with the arguments passed
</span><strong class="bold"><span class="koboSpan" id="kobo.426.1">        expect(inputEvents[0]).toEqual([10])</span></strong><span class="koboSpan" id="kobo.427.1">                        </span><strong class="bold"><span class="koboSpan" id="kobo.428.1">#5</span></strong><span class="koboSpan" id="kobo.429.1">
        // or
</span><strong class="bold"><span class="koboSpan" id="kobo.430.1">        expect(inputEvents[0][0]).toBe(10)</span></strong><span class="koboSpan" id="kobo.431.1">                          </span><strong class="bold"><span class="koboSpan" id="kobo.432.1">#6</span></strong><span class="koboSpan" id="kobo.433.1">
    })
})</span></pre>
<p><span class="koboSpan" id="kobo.434.1">This final</span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.435.1"> example starts in the same way as before, by importing the functions that we will use to describe the tests, mount our component, and the component itself. </span><span class="koboSpan" id="kobo.435.2">Our purpose here is to simulate to a certain degree the user interaction with the component by entering a value in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">input</span></strong><span class="koboSpan" id="kobo.437.1"> field, clicking the button, and then capturing the event and the value passed programmatically. </span><span class="koboSpan" id="kobo.437.2">We will rely on the methods just like before. </span><span class="koboSpan" id="kobo.437.3">We start in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">#1</span></strong><span class="koboSpan" id="kobo.439.1"> by mounting our component and creating the wrapper. </span><span class="koboSpan" id="kobo.439.2">Notice that, this time, we are not passing any options, as we don’t need them. </span><span class="koboSpan" id="kobo.439.3">In line </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">#2</span></strong><span class="koboSpan" id="kobo.441.1">, we use the wrapper’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">find()</span></strong><span class="koboSpan" id="kobo.443.1"> method to locate an </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">input</span></strong><span class="koboSpan" id="kobo.445.1"> element and set a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">10</span></strong><span class="koboSpan" id="kobo.447.1">. </span><span class="koboSpan" id="kobo.447.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">find()</span></strong><span class="koboSpan" id="kobo.449.1"> method retrieves elements using a string with the same syntax as </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">querySelector</span></strong><span class="koboSpan" id="kobo.451.1"> in a browser window. </span><span class="koboSpan" id="kobo.451.2">The returned object is a wrapper around the element, which again exposes methods for users to interact with it – in this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">.setValue()</span></strong><span class="koboSpan" id="kobo.453.1">. </span><span class="koboSpan" id="kobo.453.2">Using a similar logic, in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">#3</span></strong><span class="koboSpan" id="kobo.455.1">, we also locate the button and trigger the </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">click</span></strong><span class="koboSpan" id="kobo.457.1"> event, which will emit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">input</span></strong><span class="koboSpan" id="kobo.459.1"> event in our component. </span><span class="koboSpan" id="kobo.459.2">Notice how easy it is in lines </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">#2</span></strong><span class="koboSpan" id="kobo.461.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">#3</span></strong><span class="koboSpan" id="kobo.463.1"> to manipulate our component. </span><span class="koboSpan" id="kobo.463.2">In this way, we can access and interact programmatically with it, much like it could happen in an end-to-end test. </span><span class="koboSpan" id="kobo.463.3">We could, in theory, create our end-to-end tests using this tool, but there are better options, such </span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.464.1">as </span><strong class="bold"><span class="koboSpan" id="kobo.465.1">Cypress</span></strong><span class="koboSpan" id="kobo.466.1"> (</span><a href="https://www.cypress.io/"><span class="koboSpan" id="kobo.467.1">https://www.cypress.io/</span></a><span class="koboSpan" id="kobo.468.1">), which work excellently with Vitest, giving us a </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">great DX.</span></span></p>
<p><span class="koboSpan" id="kobo.470.1">In line </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">#3</span></strong><span class="koboSpan" id="kobo.472.1">, we have clicked a button, which we know should emit an event. </span><span class="koboSpan" id="kobo.472.2">In line </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">#4</span></strong><span class="koboSpan" id="kobo.474.1">, we capture all the emitted events with the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">input</span></strong><span class="koboSpan" id="kobo.476.1">. </span><span class="koboSpan" id="kobo.476.2">The result is an array of wrapped events that we can use in our assertions, by referencing each event by its ordinal index. </span><span class="koboSpan" id="kobo.476.3">In this case, we only triggered one event, so in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">#5</span></strong><span class="koboSpan" id="kobo.478.1">, we pass that to our expected function as </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">inputEvents[0]</span></strong><span class="koboSpan" id="kobo.480.1">. </span><span class="koboSpan" id="kobo.480.2">However, notice that the assertion matches the output to an array, </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">[10]</span></strong><span class="koboSpan" id="kobo.482.1">, instead of the value we entered in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">#2</span></strong><span class="koboSpan" id="kobo.484.1">. </span><span class="koboSpan" id="kobo.484.2">Why is that? </span><span class="koboSpan" id="kobo.484.3">The answer is that each</span><em class="italic"><span class="koboSpan" id="kobo.485.1"> event</span></em><span class="koboSpan" id="kobo.486.1"> has an undetermined number of arguments it could pass, so these are captured in an array. </span><span class="koboSpan" id="kobo.486.2">An equivalent notation is shown here in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">#6</span></strong><span class="koboSpan" id="kobo.488.1">, where we</span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.489.1"> pass to </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">expect()</span></strong><span class="koboSpan" id="kobo.491.1"> directly the value of the first element in the array of arguments, from the first event captured: </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">inputEvents[0][0]</span></strong><span class="koboSpan" id="kobo.493.1">. </span><span class="koboSpan" id="kobo.493.2">Then, we can directly validate the result to a value with </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">.toBe(10)</span></strong><span class="koboSpan" id="kobo.495.1">. </span><span class="koboSpan" id="kobo.495.2">Now, this approach may seem a bit convoluted and clumsy, having to refer to events and their values in such a way, but it is very powerful. </span><span class="koboSpan" id="kobo.495.3">Consider that we can, in one single line, assert a full array with a set of </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">related values!</span></span></p>
<p><span class="koboSpan" id="kobo.497.1">In these two files, we have now tested the input and output of our components and even validated the interactivity as expected. </span><span class="koboSpan" id="kobo.497.2">We have also learned how to retrieve elements rendered and access their properties. </span><span class="koboSpan" id="kobo.497.3">Any error thrown in these functions will invalidate the test and point us in the right direction, line, and comment on where to fix it. </span><span class="koboSpan" id="kobo.497.4">Placing tests in individual files is a very convenient alternative. </span><span class="koboSpan" id="kobo.497.5">However, Vitest also accepts in-source testing, which we will </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">see next.</span></span></p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.499.1">In-source testing</span></h1>
<p><span class="koboSpan" id="kobo.500.1">With in-source testing, we </span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.501.1">can indicate to Vitest to look into our JavaScript and Single Component Files for the tests to run, as opposed to specific files. </span><span class="koboSpan" id="kobo.501.2">These alternatives are not exclusive to each other, so we could have both active at the same time. </span><span class="koboSpan" id="kobo.501.3">The reason behind this is that, in some cases, a test case would benefit to be “close” to the original code that it is trying to assert. </span><span class="koboSpan" id="kobo.501.4">Such code must be placed at the end of our file following </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">this format:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.503.1">
if (</span><strong class="bold"><span class="koboSpan" id="kobo.504.1">import.meta.vitest</span></strong><span class="koboSpan" id="kobo.505.1">) {
    const { describe, test, expect } = </span><strong class="bold"><span class="koboSpan" id="kobo.506.1">import.meta.vitest</span></strong><span class="koboSpan" id="kobo.507.1">
   //... </span><span class="koboSpan" id="kobo.507.2">Test functions here
}</span></pre>
<p><span class="koboSpan" id="kobo.508.1">Then, for Vitest to find this code in our files, we also need to modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">vite.config.js</span></strong><span class="koboSpan" id="kobo.510.1"> file to include </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.512.1">
export default defineConfig({
    test: {
</span><strong class="bold"><span class="koboSpan" id="kobo.513.1">        includeSource: ['src/**/*.{js,ts}']</span></strong><span class="koboSpan" id="kobo.514.1">,
        // other configurations here...
</span><span class="koboSpan" id="kobo.514.2">    },
})</span></pre>
<p><span class="koboSpan" id="kobo.515.1">And finally, to eliminate the test code from the production build, we need to add the following before </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">the bundling:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.517.1">
export default defineConfig({
    define: { </span><strong class="bold"><span class="koboSpan" id="kobo.518.1">'import.meta.vitest': 'undefined'</span></strong><span class="koboSpan" id="kobo.519.1"> },
    // Other configurations...
</span><span class="koboSpan" id="kobo.519.2">})</span></pre>
<p><span class="koboSpan" id="kobo.520.1">With these </span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.521.1">changes, we can then include the tests at the end of our JavaScript files, with the benefits and trade-offs that this brings. </span><span class="koboSpan" id="kobo.521.2">For example, if there is an in-house service that is shared or used among projects, it could be a good idea to place the tests in the same file as opposed to duplicating them for </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">each project.</span></span></p>
<p><span class="koboSpan" id="kobo.523.1">Now that we have our tests in place, let’s see two more benefits that we get from using Vitest:</span><em class="italic"><span class="koboSpan" id="kobo.524.1"> coverage</span></em><span class="koboSpan" id="kobo.525.1"> and a live</span><em class="italic"> </em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.526.1">web UI.</span></em></span></p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.527.1">Coverage</span></h1>
<p><span class="koboSpan" id="kobo.528.1">The concept of coverage</span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.529.1"> is very simple, and it answers the question of how much of our code is covered by automated tests. </span><span class="koboSpan" id="kobo.529.2">We know that 100% coverage is only possible for small applications, as the same effort for large projects falls fast into the law of diminishing returns Vitest offers us a simple way to answer this question by running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">vitest –coverage</span></strong><span class="koboSpan" id="kobo.531.1"> command. </span><span class="koboSpan" id="kobo.531.2">In our case, we have already set this option in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">package.json</span></strong><span class="koboSpan" id="kobo.533.1"> scripts section, so we can run the </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.535.1">
$ npm run test:coverage</span></pre>
<p><span class="koboSpan" id="kobo.536.1">When the preceding command is run, if any dependency is missing, it will prompt us on whether we want to try to download and </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">install it:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<span class="koboSpan" id="kobo.538.1"><img alt="Figure 9.3 – Vitest prompts ﻿us to install missing dependencies for coverage" src="image/Figure_9.03_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.539.1">Figure 9.3 – Vitest prompts us to install missing dependencies for coverage</span></p>
<p><span class="koboSpan" id="kobo.540.1">For our chapter code example, the coverage report should look something </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<span class="koboSpan" id="kobo.542.1"><img alt="Figure 9.4 – Vitest coverage report example" src="image/Figure_9.04_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.543.1">Figure 9.4 – Vitest coverage report example</span></p>
<p><span class="koboSpan" id="kobo.544.1">It is possible to retrieve this</span><a id="_idIndexMarker726"/><span class="koboSpan" id="kobo.545.1"> information on a file (as </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">json</span></strong><span class="koboSpan" id="kobo.547.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">text</span></strong><span class="koboSpan" id="kobo.549.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">html</span></strong><span class="koboSpan" id="kobo.551.1">) if we need to. </span><span class="koboSpan" id="kobo.551.2">For that, we just need to include a new line in our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">vite.config.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.553.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.554.1">
test:{
    coverage: {reporter: ['text', 'json', 'html']},
    //...
</span><span class="koboSpan" id="kobo.554.2">}</span></pre>
<p><span class="koboSpan" id="kobo.555.1">The result of running the command again will be a website placed in a new directory called </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">coverage</span></strong><span class="koboSpan" id="kobo.557.1"> at the root of our project. </span><span class="koboSpan" id="kobo.557.2">This static website provides for navigation and drills down in </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">the report.</span></span><span class="koboSpan" id="kobo.559.1">
In our example, it looks </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<span class="koboSpan" id="kobo.561.1"><img alt="Figure 9.5 – Coverage HTML report" src="image/Figure_9.05_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.562.1">Figure 9.5 – Coverage HTML report</span></p>
<p><span class="koboSpan" id="kobo.563.1">Depending on our needs, this simple tool may provide us with insight into our project that would be hard to find otherwise. </span><span class="koboSpan" id="kobo.563.2">The export to JSON file comes also very handy if we need to integrate our project with other reporting software or format. </span><span class="koboSpan" id="kobo.563.3">There is yet another alternative that may come in handy: Vitest also provides a web UI to view and interact with the tests in the form of a dashboard. </span><span class="koboSpan" id="kobo.563.4">We will see </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">this next.</span></span></p>
<h1 id="_idParaDest-171"><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.565.1">The Vitest UI</span></h1>
<p><span class="koboSpan" id="kobo.566.1">Since Vitest is based on Vite, it does </span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.567.1">make good use of some of its features, not only for live testing but also to provide a live development server displaying the tests in real time. </span><span class="koboSpan" id="kobo.567.2">To make use of this option, we only need to install the appropriate dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.569.1">
$ npm install –D @vitests/ui</span></pre>
<p><span class="koboSpan" id="kobo.570.1">Then, for convenience, we should add the following line in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">package.json</span></strong><span class="koboSpan" id="kobo.572.1"> file so we can run the application </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">npm</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.576.1">
scripts:{
    "</span><strong class="bold"><span class="koboSpan" id="kobo.577.1">test:ui</span></strong><span class="koboSpan" id="kobo.578.1">": "</span><strong class="bold"><span class="koboSpan" id="kobo.579.1">vitest –-ui</span></strong><span class="koboSpan" id="kobo.580.1">"
    // Other settings...
</span><span class="koboSpan" id="kobo.580.2">}</span></pre>
<p><span class="koboSpan" id="kobo.581.1">We can then run the server with this </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">command line:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.583.1">
$ npm run test:ui</span></pre>
<p><span class="koboSpan" id="kobo.584.1">The development test server will start and provide us with an address to open in the browser. </span><span class="koboSpan" id="kobo.584.2">For our application, this looks </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<span class="koboSpan" id="kobo.586.1"><img alt="Figure 9.6 – Vitest UI ﻿dashboard" src="image/Figure_9.06_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.587.1">Figure 9.6 – Vitest UI dashboard</span></p>
<p><span class="koboSpan" id="kobo.588.1">The web</span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.589.1"> UI has also new possibilities to interact with the test cases, and even see the relationships between components and services in a graphical manner, all the way down to the </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">test code.</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">Now that we have cleaned up our code and run tests, it is time to look into another tool to keep track of changes, a fundamental concept for today: source control </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">with Git.</span></span></p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.593.1">What is source control... </span><span class="koboSpan" id="kobo.593.2">and why?</span></h1>
<p><span class="koboSpan" id="kobo.594.1">Software development is a “human-intensive” discipline, meaning that it depends heavily on the creativity and involvement of the developer and their know-how. </span><span class="koboSpan" id="kobo.594.2">It is common to try different approaches to the same situation and write and rewrite code. </span><span class="koboSpan" id="kobo.594.3">Even the process of refactoring after testing implies making changes in the code. </span><span class="koboSpan" id="kobo.594.4">It is not an anomaly that during this process, we need to “go back” to a previous code when a change or approach didn’t meet expectations. </span><span class="koboSpan" id="kobo.594.5">If we are constantly overwriting the same files... </span><span class="koboSpan" id="kobo.594.6">how do we keep track of what changed where? </span><span class="koboSpan" id="kobo.594.7">And by whom? </span><span class="koboSpan" id="kobo.594.8">Our own memory is not enough when time and complexity grow. </span><span class="koboSpan" id="kobo.594.9">Save files with different names? </span><span class="koboSpan" id="kobo.594.10">That would become impractical very soon. </span><span class="koboSpan" id="kobo.594.11">And what about combining source code from multiple developers? </span><span class="koboSpan" id="kobo.594.12">We can quickly see that managing the source code for non-trivial projects is a very important task </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">in itself.</span></span></p>
<p><span class="koboSpan" id="kobo.596.1">The historical solution to this early problem in computer science has been the creation of additional software in charge of keeping track of changes in the code, allowing a developer to go back on their tracks, and facilitating the chore of merging code from multiple developers to make a cohesive source code. </span><span class="koboSpan" id="kobo.596.2">The emerging discipline for this task is called </span><strong class="bold"><span class="koboSpan" id="kobo.597.1">Source Control</span></strong><span class="koboSpan" id="kobo.598.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.599.1">SC</span></strong><span class="koboSpan" id="kobo.600.1">), and the</span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.601.1"> software to implement it is</span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.602.1"> called a </span><strong class="bold"><span class="koboSpan" id="kobo.603.1">Source Control System</span></strong><span class="koboSpan" id="kobo.604.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.605.1">SCS</span></strong><span class="koboSpan" id="kobo.606.1">) or </span><strong class="bold"><span class="koboSpan" id="kobo.607.1">Source Control Management System</span></strong><span class="koboSpan" id="kobo.608.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.609.1">SCMS</span></strong><span class="koboSpan" id="kobo.610.1">). </span><span class="koboSpan" id="kobo.610.2">There </span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.611.1">have been many, and still are many, different systems in use today, such </span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.612.1">as </span><strong class="bold"><span class="koboSpan" id="kobo.613.1">Mercurial</span></strong><span class="koboSpan" id="kobo.614.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.615.1">Subversion</span></strong><span class="koboSpan" id="kobo.616.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.617.1">ClearCase</span></strong><span class="koboSpan" id="kobo.618.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.619.1">Git</span></strong><span class="koboSpan" id="kobo.620.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.621.1">BitKeeper</span></strong><span class="koboSpan" id="kobo.622.1">. </span><span class="koboSpan" id="kobo.622.2">Each one </span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.623.1">has its trade-offs. </span><span class="koboSpan" id="kobo.623.2">In </span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.624.1">particular, Git is used today by most projects </span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.625.1">and </span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.626.1">developers around the globe. </span><span class="koboSpan" id="kobo.626.2">Statistics on the internet show different percentages for the most popular ones, but each one shows this trend. </span><span class="koboSpan" id="kobo.626.3">Because of this, it is important that we learn how to use Git, which is our </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">next topic.</span></span></p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.628.1">Source control with Git</span></h1>
<p><span class="koboSpan" id="kobo.629.1">Currently, the mos</span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.630.1">t popular SCS is Git, which was created by </span><strong class="bold"><span class="koboSpan" id="kobo.631.1">Linus Torvalds</span></strong><span class="koboSpan" id="kobo.632.1">, who</span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.633.1"> is also the creator of the Linux kernel. </span><span class="koboSpan" id="kobo.633.2">The story goes that the Linux kernel project used </span><em class="italic"><span class="koboSpan" id="kobo.634.1">BitKeeper </span></em><span class="koboSpan" id="kobo.635.1">for source control, but the team hit many issues with the growing complexity and distributed nature of the development. </span><span class="koboSpan" id="kobo.635.2">Frustrated, Linus Torvalds decided to make his own SCS to solve the real-life problems they had... </span><span class="koboSpan" id="kobo.635.3">and it took him one weekend! </span><span class="koboSpan" id="kobo.635.4">(See </span><a href="https://www.linux.com/news/10-years-git-interview-git-creator-linus-torvalds/"><span class="koboSpan" id="kobo.636.1">https://www.linux.com/news/10-years-git-interview-git-creator-linus-torvalds/</span></a><span class="koboSpan" id="kobo.637.1">.) That was the humble beginning of Git, and from there, it became popular in the open source community as well as in the </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">enterprise world.</span></span></p>
<p><span class="koboSpan" id="kobo.639.1">Git is a distributed SCMS, simple and effective to use from the command line. </span><span class="koboSpan" id="kobo.639.2">It offers the </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">following features:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.641.1">Creates and manages a </span><strong class="bold"><span class="koboSpan" id="kobo.642.1">repository</span></strong><span class="koboSpan" id="kobo.643.1">, where it collects the source files and the history of changes for </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">each one.</span></span></li>
<li><span class="koboSpan" id="kobo.645.1">Allows sharing projects by cloning </span><strong class="bold"><span class="koboSpan" id="kobo.646.1">remote repositories</span></strong><span class="koboSpan" id="kobo.647.1"> into </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">local projects.</span></span></li>
<li><span class="koboSpan" id="kobo.649.1">Allows the project to be branched and merged. </span><span class="koboSpan" id="kobo.649.2">This means that you can have different copies of the same project with different code (a </span><strong class="bold"><span class="koboSpan" id="kobo.650.1">branch</span></strong><span class="koboSpan" id="kobo.651.1">), switch between them, join them, and unify them by request (</span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">a </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.653.1">merge</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.655.1">Synchronizes changes from a remote repository into a local copy (called </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">a </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.657.1">pull</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.659.1">Sends local </span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.660.1">changes </span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.661.1">to a remote repository (called </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">a </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.663.1">push</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">).</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.665.1">Let’s learn how to use Git by applying it to our current project for this chapter. </span><span class="koboSpan" id="kobo.665.2">Let’s start by installing it in our system, so it’s available for all </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">our projects.</span></span></p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.667.1">Installation on Windows systems</span></h2>
<p><span class="koboSpan" id="kobo.668.1">The</span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.669.1"> easiest and recommended way to install Git on Windows </span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.670.1">systems is to download the installers from the official Git website at </span><a href="https://git-scm.com/download/win"><span class="koboSpan" id="kobo.671.1">https://git-scm.com/download/win</span></a><span class="koboSpan" id="kobo.672.1">. </span><span class="koboSpan" id="kobo.672.2">Click on the version you want to use, according to your operating system (32- or 64-bit), and then run the installer following </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">the directions.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer072">
<span class="koboSpan" id="kobo.674.1"><img alt="Figure 9.7 – Official Git installers for Windows" src="image/Figure_9.07_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.675.1">Figure 9.7 – Official Git installers for Windows</span></p>
<p><span class="koboSpan" id="kobo.676.1">Once the installation is done, the command-line tools will be installed on your system so we can run them through a terminal. </span><span class="koboSpan" id="kobo.676.2">Also, if you are using a code editor such as Visual Studio Code, it will integrate the tools and provide you with a GUI to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">basic operations.</span></span></p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.678.1">Installation on Linux systems</span></h2>
<p><span class="koboSpan" id="kobo.679.1">In </span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.680.1">Linux systems, the installation is done through the command line, using </span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.681.1">the distribution’s package manager. </span><span class="koboSpan" id="kobo.681.2">The package name in (almost) all distributions is simply </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">git</span></strong><span class="koboSpan" id="kobo.683.1">. </span><span class="koboSpan" id="kobo.683.2">In Debian and Ubuntu systems, the installation can be run with </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.685.1">
$ sudo apt install git</span></pre>
<p><span class="koboSpan" id="kobo.686.1">However, in these distributions, there may not be the latest version, so if you need the latest stable release, you need to add the official PPA repository. </span><span class="koboSpan" id="kobo.686.2">In this case, run the following commands </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">in order:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.688.1">
$ sudo add-apt-repository ppa:git-core/ppa
$ sudo apt update
$ sudo apt install git</span></pre>
<p><span class="koboSpan" id="kobo.689.1">The preceding commands will update your system dependencies and install (or upgrade) Git on your system. </span><span class="koboSpan" id="kobo.689.2">For a complete list of distributions and commands to install Git, please refer to the official documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">at </span></span><a href="https://git-scm.com/download/linux"><span class="No-Break"><span class="koboSpan" id="kobo.691.1">https://git-scm.com/download/linux</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.692.1">.</span></span></p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.693.1">Installation on macOS systems</span></h2>
<p><span class="koboSpan" id="kobo.694.1">In </span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.695.1">macOS systems, there are </span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.696.1">different ways to </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">install Git:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.698.1">If you have Homebrew installed, run </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">$ brew install git</span></strong><span class="koboSpan" id="kobo.700.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">a Terminal</span></span></li>
<li><span class="koboSpan" id="kobo.702.1">If instead, you have MacPorts, run </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">$ sudo port install git</span></strong><span class="koboSpan" id="kobo.704.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">a Terminal</span></span></li>
<li><span class="koboSpan" id="kobo.706.1">If you have installed Xcode, Git </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">is included</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.708.1">For other alternatives, please check the official documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">at https://git-scm.com/download/mac.</span></span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.710.1">Using Git</span></h2>
<p><span class="koboSpan" id="kobo.711.1">Regardless of which system you</span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.712.1"> are working on, or the installation type you made, Git will be installed in your local path, so it can be executed from any terminal window. </span><span class="koboSpan" id="kobo.712.2">To verify the installation and version, run this command (does not require </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">admin privileges):</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.714.1">
$ git –-version</span></pre>
<p><span class="koboSpan" id="kobo.715.1">At the time of writing, the current stable version is </span><em class="italic"><span class="koboSpan" id="kobo.716.1">2.39.2</span></em><span class="koboSpan" id="kobo.717.1">. </span><span class="koboSpan" id="kobo.717.2">With this done, open a terminal window in the root folder of our project. </span><span class="koboSpan" id="kobo.717.3">To start using Git, we need to create a local repository with </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">this command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.719.1">
$ git init</span></pre>
<p><span class="koboSpan" id="kobo.720.1">After the execution is done, a new hidden directory will be created in the folder. </span><span class="koboSpan" id="kobo.720.2">You don’t have to worry about it, as it will be managed by Git. </span><span class="koboSpan" id="kobo.720.3">If your File Explorer has deactivated the option to see hidden files, then you may not notice the creation. </span><span class="koboSpan" id="kobo.720.4">It is recommended that you have </span><strong class="bold"><span class="koboSpan" id="kobo.721.1">Show/view hidden files</span></strong><span class="koboSpan" id="kobo.722.1"> in your </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">system activated.</span></span></p>
<p><span class="koboSpan" id="kobo.724.1">Once we have created the repository, we can start using it. </span><span class="koboSpan" id="kobo.724.2">The steps to work with files usually includes the </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">following stages:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<span class="koboSpan" id="kobo.726.1"><img alt="Figure 9.8 – Working stages of Git" src="image/Figure_9.08_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.727.1">Figure 9.8 – Working stages of Git</span></p>
<p><span class="koboSpan" id="kobo.728.1">Once we have files created or edited, the next step is to “stage” the files. </span><span class="koboSpan" id="kobo.728.2">This indicates to Git that it needs to keep track of changes and include the file in the next commit event. </span><strong class="bold"><span class="koboSpan" id="kobo.729.1">Committing</span></strong><span class="koboSpan" id="kobo.730.1"> is the </span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.731.1">act of moving those files/changes into the repository. </span><span class="koboSpan" id="kobo.731.2">If a file is not staged, it will not be included in the commit. </span><span class="koboSpan" id="kobo.731.3">To add a file, run the </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.733.1">
$ git add [filename1] [filename2]..</span></pre>
<p><span class="koboSpan" id="kobo.734.1">This will add the files, but it is quite verbose. </span><span class="koboSpan" id="kobo.734.2">Instead, if you want to add all changes in all files, run </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">this instead:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.736.1">
$ git add .</span></pre>
<p><span class="koboSpan" id="kobo.737.1">This will come in handy in the first commit when the repository is initialized. </span><span class="koboSpan" id="kobo.737.2">After running this command, all the files will start to be tracked. </span><span class="koboSpan" id="kobo.737.3">However, we do not want to track everything in our root folder, so to exclude files or directories, we can use a special file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">.gitignore</span></strong><span class="koboSpan" id="kobo.739.1">. </span><span class="koboSpan" id="kobo.739.2">If you</span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.740.1"> open this file in the example directory, you will find something </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.742.1">/chapter 10/.gitignore</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.743.1">
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*
node_modules
dist
dist-ssr
*.local
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?</span></pre>
<p><span class="koboSpan" id="kobo.744.1">This is a plain text file that indicates to Git not to track the files and directories indicated in each line. </span><span class="koboSpan" id="kobo.744.2">You can also use wildcards such as an asterisk (</span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">*</span></strong><span class="koboSpan" id="kobo.746.1">) and question mark (</span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">?</span></strong><span class="koboSpan" id="kobo.748.1">) to include a match pattern. </span><span class="koboSpan" id="kobo.748.2">This is very useful, as there are parts of your code base that you don’t need to track, such as the node dependencies and binary files (images and the like). </span><span class="koboSpan" id="kobo.748.3">Make sure to have this file in your directory before making a </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">massive staging.</span></span></p>
<p><span class="koboSpan" id="kobo.750.1">Once you have </span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.751.1">staged files, you can check them with </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">this command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.753.1">
$ git status</span></pre>
<p><span class="koboSpan" id="kobo.754.1">In the case of our example project, it will show something </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer074">
<span class="koboSpan" id="kobo.756.1"><img alt="Figure 9.9 – First staging in Git" src="image/Figure_9.09_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.757.1">Figure 9.9 – First staging in Git</span></p>
<p><span class="koboSpan" id="kobo.758.1">Notice how Git informs us also that we are in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">master</span></strong><span class="koboSpan" id="kobo.760.1"> branch, and that there have not been any commits yet. </span><span class="koboSpan" id="kobo.760.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">master</span></strong><span class="koboSpan" id="kobo.762.1"> branch is the main branch for our code and is created by default. </span><span class="koboSpan" id="kobo.762.2">This is a special branch that is used to keep the stable code of our applications. </span><span class="koboSpan" id="kobo.762.3">In tools such as GitLab and GitHub (we will talk about them later), these branches also trigger certain events once committed. </span><span class="koboSpan" id="kobo.762.4">For now, let’s move forward and create our first</span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.763.1"> commit with </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">this command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.765.1">
$ git commit –m "First commit"</span></pre>
<p><span class="koboSpan" id="kobo.766.1">We will see results </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<span class="koboSpan" id="kobo.768.1"><img alt="Figure 9.10 – Results from the first commit" src="image/Figure_9.10_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.769.1">Figure 9.10 – Results from the first commit</span></p>
<p><span class="koboSpan" id="kobo.770.1">With these simple lines, we have started to keep track of our source code. </span><span class="koboSpan" id="kobo.770.2">Now, as mentioned before, we have committed our initial code to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">master</span></strong><span class="koboSpan" id="kobo.772.1"> branch. </span><span class="koboSpan" id="kobo.772.2">Git allows us to make an instant copy of the state of our code, much like a screenshot, and continue working from there without affecting the original. </span><span class="koboSpan" id="kobo.772.3">This is</span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.773.1"> called </span><strong class="bold"><span class="koboSpan" id="kobo.774.1">branching</span></strong><span class="koboSpan" id="kobo.775.1"> and is an important part of </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">using Git.</span></span></p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.777.1">Managing branches and merges</span></h2>
<p><span class="koboSpan" id="kobo.778.1">Using branches</span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.779.1"> to control our development is a very good way to move forward on a certain footing. </span><span class="koboSpan" id="kobo.779.2">Here are the most common commands to </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">manage branches:</span></span></p>
<table class="No-Table-Style" id="table001-5">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.781.1">Action</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.782.1">Command example</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.783.1">Create a branch and switch </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">to it</span></span></p>
</td>
<td class="No-Table-Style">
<pre class="console"><span class="koboSpan" id="kobo.785.1">
$ git checkout –b [branch_name]</span></pre>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.786.1">Create a branch but stay </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">in current</span></span></p>
</td>
<td class="No-Table-Style">
<pre class="console"><span class="koboSpan" id="kobo.788.1">
$ git branch [branch_name]</span></pre>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.789.1">Delete branch</span></span></p>
</td>
<td class="No-Table-Style">
<pre class="console"><span class="koboSpan" id="kobo.790.1">
$ git branch –d [branch_name]</span></pre>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.791.1">Switch to </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">a branch</span></span></p>
</td>
<td class="No-Table-Style">
<pre class="console"><span class="koboSpan" id="kobo.793.1">
$ git checkout [branch_name]</span></pre>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.794.1">Merge a branch </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">with current</span></span></p>
</td>
<td class="No-Table-Style">
<pre class="console"><span class="koboSpan" id="kobo.796.1">
$ git merge [branch_name]</span></pre>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.797.1">Check </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">current branch</span></span></p>
</td>
<td class="No-Table-Style">
<pre class="console"><span class="koboSpan" id="kobo.799.1">
$ git branch</span></pre>
</td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.800.1">Once you have moved to another branch, you can perform all the regular Git operations (edit and delete files, etc.) without affecting the </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">other ones.</span></span></p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.802.1">Merging conflicts</span></h2>
<p><span class="koboSpan" id="kobo.803.1">When merging multiple </span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.804.1">branches together or with </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">master</span></strong><span class="koboSpan" id="kobo.806.1">, it is possible and more than likely that some files will have a discrepancy with the current branch. </span><span class="koboSpan" id="kobo.806.2">In this case, the </span><em class="italic"><span class="koboSpan" id="kobo.807.1">merge </span></em><span class="koboSpan" id="kobo.808.1">will fail, and the user will be prompted to solve the differences. </span><span class="koboSpan" id="kobo.808.2">What Git does is mark the target file (the file in the current branch) with markers in the text for the user to edit. </span><span class="koboSpan" id="kobo.808.3">Once these have been edited, the file can be staged and committed, thus ending the </span><em class="italic"><span class="koboSpan" id="kobo.809.1">merge</span></em><span class="koboSpan" id="kobo.810.1">. </span><span class="koboSpan" id="kobo.810.2">Let’s try that without code, by purposely creating a discrepancy to fix. </span><span class="koboSpan" id="kobo.810.3">Follow </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.812.1">Create a new branch, </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">dev</span></strong><span class="koboSpan" id="kobo.814.1">, with this command: </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">$ git checkout –</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">b dev</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.818.1">Edit </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">index.html</span></strong><span class="koboSpan" id="kobo.820.1">, adding in line 11 (before the script tag) the following: </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">&lt;div&gt;A div created in </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">branch dev&lt;/div&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.824.1">Save the file, stage it, and commit the change with </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">$ git add index.html</span></strong><span class="koboSpan" id="kobo.826.1"> and then </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">$ git commit –m "added div </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">in dev"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.830.1">Now, we will move to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">master</span></strong><span class="koboSpan" id="kobo.832.1"> branch with </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">$ git </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">checkout master</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.836.1">Notice how line 11 with the div has disappeared from </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">index.html</span></strong><span class="koboSpan" id="kobo.838.1">. </span><span class="koboSpan" id="kobo.838.2">This is because that edition was never made on this file. </span><span class="koboSpan" id="kobo.838.3">Now, add in that line the following: </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">&lt;p&gt;This change was made </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">in master&lt;/p&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.841.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.842.1">Save the file, stage it, and commit it with a different message (look at </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.843.1">step 3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">).</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.845.1">Now, we will try to merge both branches and, as </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">index.html</span></strong><span class="koboSpan" id="kobo.847.1"> has been committed to both with a different code, it will fail! </span><span class="koboSpan" id="kobo.847.2">To start the </span><em class="italic"><span class="koboSpan" id="kobo.848.1">merge</span></em><span class="koboSpan" id="kobo.849.1">, run </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">$ git merge dev</span></strong><span class="koboSpan" id="kobo.851.1">.</span></p>
<p><span class="koboSpan" id="kobo.852.1">You should see an</span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.853.1"> error on the terminal, and new lines added to </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">index.html</span></strong><span class="koboSpan" id="kobo.855.1"> indicating the discrepancies. </span><span class="koboSpan" id="kobo.855.2">In our code example, it looks like this:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<span class="koboSpan" id="kobo.856.1"><img alt="Figure 9.11 – Merge conflict" src="image/Figure_9.11_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.857.1">Figure 9.11 – Merge conflict</span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.858.1">To resolve the conflict, just edit the source code to your best judgment (also delete the extra labels added by Git), then save the file, stage it, and finally make a commit. </span><span class="koboSpan" id="kobo.858.2">You will </span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.859.1">receive a message indicating that the </span><em class="italic"><span class="koboSpan" id="kobo.860.1">merge </span></em><span class="koboSpan" id="kobo.861.1">has </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">been resolved.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.863.1">Working with branches and resolving mergers when they appear is a common practice and quite useful, but we are still not using the full potential of Git. </span><span class="koboSpan" id="kobo.863.2">As you remember, Git is a distributed SCMS, and this relies on its great potential. </span><span class="koboSpan" id="kobo.863.3">Enter the </span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">remote repository...</span></span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.865.1">Working with remote repositories</span></h2>
<p><span class="koboSpan" id="kobo.866.1">In the same way that we work </span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.867.1">with a local repository, Git can also synchronize code with a remote repository. </span><span class="koboSpan" id="kobo.867.2">This enables team members from anywhere in the world to collaborate together in the same code base, resolve conflicts, and also synchronize their own code with others’ contributions. </span><span class="koboSpan" id="kobo.867.3">Working with a remote repository involves the following steps to </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">set up:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.869.1">The remote repository must be created, and a URL provided to connect </span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">to it.</span></span></li>
<li><span class="koboSpan" id="kobo.871.1">We add the remote repository as a new origin to our local repository with the </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">following command:</span></span><pre class="console">
<strong class="bold"><span class="koboSpan" id="kobo.873.1">$ git remote add origin URL</span></strong></pre></li>
<li><span class="koboSpan" id="kobo.874.1">We set our </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">master</span></strong><span class="koboSpan" id="kobo.876.1"> branch to synchronize with the </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">remote repository:</span></span><pre class="console">
<strong class="bold"><span class="koboSpan" id="kobo.878.1">$ git push –set-upstream origin master</span></strong></pre></li>
<li><span class="koboSpan" id="kobo.879.1">We retrieve changes from the </span><span class="No-Break"><span class="koboSpan" id="kobo.880.1">remote repository:</span></span><pre class="console">
<strong class="bold"><span class="koboSpan" id="kobo.881.1">$ git pull origin master</span></strong></pre></li>
<li><span class="koboSpan" id="kobo.882.1">We submit our changes to the </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">remote repository:</span></span><pre class="console">
<strong class="bold"><span class="koboSpan" id="kobo.884.1">$ git push origin master</span></strong></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.885.1">Once you have done </span><em class="italic"><span class="koboSpan" id="kobo.886.1">steps 1</span></em><span class="koboSpan" id="kobo.887.1"> to </span><em class="italic"><span class="koboSpan" id="kobo.888.1">3</span></em><span class="koboSpan" id="kobo.889.1">, the regular activity will involve </span><em class="italic"><span class="koboSpan" id="kobo.890.1">steps 4</span></em><span class="koboSpan" id="kobo.891.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.892.1">5</span></em><span class="koboSpan" id="kobo.893.1">. </span><span class="koboSpan" id="kobo.893.2">These activities will keep your local repository synchronized with your remote repository. </span><span class="koboSpan" id="kobo.893.3">In practice, modern IDEs such as Visual Studio Code will already provide you with graphical tools to make these operations, and this results in more convenience when you are working on a project. </span><span class="koboSpan" id="kobo.893.4">They also include visual tools to resolve conflicts </span><span class="No-Break"><span class="koboSpan" id="kobo.894.1">during </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.895.1">merges</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.896.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.897.1">Setting up a Git server for your local network is outside the scope of this book, but this introduction would not be complete without a word about </span><strong class="bold"><span class="koboSpan" id="kobo.898.1">GitHub </span></strong><span class="koboSpan" id="kobo.899.1">and </span><strong class="bold"><span class="koboSpan" id="kobo.900.1">GitLab</span></strong><span class="koboSpan" id="kobo.901.1">. </span><span class="koboSpan" id="kobo.901.2">It is common that when people first hear about Git, they associate it</span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.902.1"> with GitHub, which is</span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.903.1"> understandable, as the latter has a much more popular media presence. </span><span class="koboSpan" id="kobo.903.2">GitHub is not Git. </span><span class="koboSpan" id="kobo.903.3">It is a web platform that provides</span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.904.1"> tools built on top of Git, to host online projects hosting remote repositories. </span><span class="koboSpan" id="kobo.904.2">Thus, you can perfectly work with Git locally, and synchronize with a GitHub or GitLab remote repository. </span><span class="koboSpan" id="kobo.904.3">This is the most </span><span class="No-Break"><span class="koboSpan" id="kobo.905.1">common case.</span></span></p>
<p><span class="koboSpan" id="kobo.906.1">GitHub provides messaging and documentation tools, and much more – even additional services that allow detecting events in our repository to trigger certain actions and services, some provided locally (at a cost), others remotely (for example, webhooks). </span><span class="koboSpan" id="kobo.906.2">For example, it is possible for you to commit locally, push the changes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">master</span></strong><span class="koboSpan" id="kobo.908.1"> branch on GitHub, and</span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.909.1"> have a whole set of routines started, from compilation to website presentation. </span><span class="koboSpan" id="kobo.909.2">Again, managing all these options is outside our current scope in this chapter, but the important thing to remember is that all of this is based and built upon Git, so if you understand </span><em class="italic"><span class="koboSpan" id="kobo.910.1">how </span></em><span class="koboSpan" id="kobo.911.1">it the works and </span><em class="italic"><span class="koboSpan" id="kobo.912.1">what </span></em><span class="koboSpan" id="kobo.913.1">it does, you have a solid foundation to move ahead with other tools and services. </span><span class="koboSpan" id="kobo.913.2">There is one more concept that has become familiar with this topic, Continuous Integration and Delivery, which we will </span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">see next.</span></span></p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.915.1">Continuous Integration and Delivery</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.916.1">Continuous Integration</span></strong><span class="koboSpan" id="kobo.917.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.918.1">CI</span></strong><span class="koboSpan" id="kobo.919.1">) is a</span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.920.1"> practice enabled by the technologies we have seen thus far, where developers commit their changes to a central (remote) repository as frequently as possible. </span><span class="koboSpan" id="kobo.920.2">The central repository detects the incoming changes and triggers automated tests against the code. </span><span class="koboSpan" id="kobo.920.3">Then, it compiles/builds the final product. </span><span class="koboSpan" id="kobo.920.4">This is done continuously, as opposed to the practice of merging and compiling on a given date </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">before launch.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.922.1">Continuous Delivery</span></strong><span class="koboSpan" id="kobo.923.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.924.1">CD</span></strong><span class="koboSpan" id="kobo.925.1">) builds </span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.926.1">on top of CI, by also deploying the released product to its final location. </span><span class="koboSpan" id="kobo.926.2">You can configure this process to create preliminary versions of software or web applications, (for example, betas, nightly builds, etc.), and program a release date for the end location and delivery to the customers (sometimes, this last part may involve a process of its own and is called </span><strong class="bold"><span class="koboSpan" id="kobo.927.1">Continuous Deployment</span></strong><span class="koboSpan" id="kobo.928.1">). </span><span class="koboSpan" id="kobo.928.2">Both </span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.929.1">services mentioned before (GitHub and GitLab) offer these types </span><span class="No-Break"><span class="koboSpan" id="kobo.930.1">of services.</span></span></p>
<p><span class="koboSpan" id="kobo.931.1">By using these concepts, it is possible to set up a whole automated workflow from your desktop to the web, where a simple Git commit and a push to the server would trigger your application to be tested and published in its destination online. </span><span class="koboSpan" id="kobo.931.2">The way to implement this workflow is particular to the tool used to implement CI </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">and CD.</span></span></p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.933.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.934.1">In this chapter, we have covered very important concepts regarding the care and quality of our code. </span><span class="koboSpan" id="kobo.934.2">We have learned how to install official tools to perform automated tests in our code and components, as well as how to keep track of changes and management in the source code. </span><span class="koboSpan" id="kobo.934.3">While the examples and information provided here are introductory, they are detailed enough to implement them in your own projects and keep your learning skills growing. </span><span class="koboSpan" id="kobo.934.4">The concepts of CI and CD, as well as services provided by online repositories, also give you a solid foundation to learn to use them, as they all are based on the functionality provided by Git. </span><span class="koboSpan" id="kobo.934.5">All these tools have professional value for a developer and are required in the </span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">industry today.</span></span></p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.936.1">Review questions</span></h1>
<ul>
<li><span class="koboSpan" id="kobo.937.1">Why is automated testing important? </span><span class="koboSpan" id="kobo.937.2">Does it eliminate the need to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.938.1">manual testing?</span></span></li>
<li><span class="koboSpan" id="kobo.939.1">What is necessary to test our Single File Components </span><span class="No-Break"><span class="koboSpan" id="kobo.940.1">in Vue?</span></span></li>
<li><span class="koboSpan" id="kobo.941.1">What is source control, and why is </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">it necessary?</span></span></li>
<li><span class="koboSpan" id="kobo.943.1">What is Git, and how is it different </span><span class="No-Break"><span class="koboSpan" id="kobo.944.1">from GitHub/GitLab?</span></span></li>
<li><span class="koboSpan" id="kobo.945.1">When you modify a file in a branch, does that modify it in all other branches? </span><span class="koboSpan" id="kobo.945.2">Why does or doesn’t </span><span class="No-Break"><span class="koboSpan" id="kobo.946.1">this happen?</span></span></li>
<li><span class="koboSpan" id="kobo.947.1">Are the commands to control Git the same across </span><span class="No-Break"><span class="koboSpan" id="kobo.948.1">all platforms?</span></span></li>
<li><span class="koboSpan" id="kobo.949.1">What do CI and CD stand for, and what is the value they add to </span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">a workflow?</span></span></li>
</ul>
</div>
</body></html>