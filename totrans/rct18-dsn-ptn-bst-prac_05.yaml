- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing Code for the Browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some specific operations we can conduct when we work with React and
    the browser. For example, we can ask our users to enter some information using
    forms. In this chapter, we will look at how we can apply different techniques
    to deal with forms. We can implement **uncontrolled components** and let the fields
    keep their internal states, or we can use controlled ones where we have full control
    over the state of the fields.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will also look at how events in React work and how the library
    implements some advanced techniques to give us a consistent interface across different
    browsers. We will look at some interesting solutions that the React team has implemented
    to make the event system very performant.
  prefs: []
  type: TYPE_NORMAL
- en: After events, we will jump into **refs** to look at how we can access the underlying
    **DOM** nodes in our React components. This represents a powerful feature, but
    it should be used carefully because it breaks some of the conventions that make
    React easy to work with.
  prefs: []
  type: TYPE_NORMAL
- en: After refs, we will look at how we can implement animations easily with the
    React add-ons. Finally, we will learn how easy it is to work with **Scalable Vector
    Graphics** (**SVG**) in React, and how we can create dynamically configurable
    icons for our applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using different techniques to create forms with React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening to DOM events and implementing custom handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way of performing imperative operations on DOM nodes using refs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating simple animations that work across different browsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The React way of generating SVG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 19+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter in the book’s GitHub repository: [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and implementing forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to implement forms with React. As
    soon as we start building a real application with React, we need to interact with
    the users. If we want to ask for information from our users within the browser,
    forms are the most common solution. Due to the way the library works and its declarative
    nature, dealing with input fields and other form elements is non-trivial with
    React, but as soon as we understand its logic, it will become clear. In the next
    sections, we are going to learn how to use uncontrolled and controlled components.
  prefs: []
  type: TYPE_NORMAL
- en: Uncontrolled components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Uncontrolled components** are like regular HTML form inputs for which you
    will not be able to manage the value yourself but instead, the DOM will take care
    of handling the value and you can get this value by using a React ref. Let’s start
    with a basic example—displaying a form with an input field and a `Submit` button.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If we run the preceding snippet in the browser, we will see exactly what we
    expect—an input field in which we can write something and a clickable button.
    This is an example of an uncontrolled component, where we do not set the value
    of the input field, but we let the component manage its own internal state.
  prefs: []
  type: TYPE_NORMAL
- en: Most likely, we want to do something with the value of the element when the
    `Submit` button is clicked. For example, we may want to send the data to an API
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: We can do this easily by adding an `onChange` listener (we will talk more about
    event listeners later in this chapter). Let’s look at what it means to add a listener.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create the `handleChange` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The event listener is receiving an event object, where the target represents
    the field that generated the event, and we are interested in its value. We start
    by just logging it because it is important to proceed with small steps, but we
    will store the value into the state soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we render the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we render the component inside the browser and type the word `React` into
    the form field, we will see something like the following inside the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `handleChange` listener is fired every time the value of the input changes.
    Therefore, our function is called once for each typed character. The next step
    is to store the value that’s entered by the user and make it available when the
    user clicks the `Submit` button.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just have to change the implementation of the handler to store it in the
    state instead of logging it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Getting notified of when the form is submitted is very similar to listening
    to the change event of the input field; they are both events that are called by
    the browser when something happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define the `handleSubmit` function, where we just log the value. In a
    real-world scenario, you could send the data to an API endpoint or pass it to
    another component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This handler is pretty straightforward; we just log the value currently stored
    in the state. We also want to overcome the default behavior of the browser when
    the form is submitted, to perform a custom action. This seems reasonable, and
    it works very well for a single field. The question now is, *what if we have multiple
    fields? Suppose we have tens of different fields?*
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a basic example, where we create each field and handler manually
    and look at how we can improve it by applying different levels of optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new form with first and last name fields. We can reuse the `Uncontrolled`
    component and add some new states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We initialize the two fields inside the state, and we define an event handler
    for each one of the fields as well. As you may have noticed, this does not scale
    very well when there are lots of fields, but it is important to understand the
    problem clearly before moving to a more flexible solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we implement the new handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have to change the submit handler a little bit so that it displays
    the first and the last name when it gets clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we render the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We are ready to go: if we run the preceding component in the browser, we will
    see two fields, and if we type `Carlos` into the first one and `Santana` into
    the second one, we will see the full name displayed in the browser console when
    the form is submitted.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, this works fine, and we can do some interesting things this way, but
    it does not handle complex scenarios without requiring us to write a lot of boilerplate
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how we can optimize it a little bit. Our goal is to use a single
    change handler so that we can add an arbitrary number of fields without creating
    new listeners.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to the component and let’s change our states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We may still want to initialize the values, and later in this section, we will
    look at how to provide prefilled values for the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the interesting bit is the way in which we can modify the `onChange` handler
    implementation to make it work in different fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen previously, the `target` property of the event we receive represents
    the input field that has fired the event, so we can use the name of the field
    and its value as variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then have to set the name for each field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: That’s it! We can now add as many fields as we want without creating additional
    handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Controlled components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A controlled component is a React component that controls the values of input
    elements in a form by using the component state.
  prefs: []
  type: TYPE_NORMAL
- en: Here we are going to look at how we can prefill the form fields with some values,
    which we may receive from the server or as props from the parent. To understand
    this concept fully, we will start again from a very simple stateless function
    component, and we will improve it step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first example shows a predefined value inside the input field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If we run this component inside the browser, we realize that it shows the default
    value as expected, but it does not let us change the value or type anything else
    inside it.
  prefs: []
  type: TYPE_NORMAL
- en: The reason it does this is that in React, we declare what we want to see on
    the screen, and setting a fixed-value attribute always results in rendering that
    value, no matter what other actions are taken. This is unlikely to be a behavior
    we want in a real-world application.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open the console, we get the following error message. React itself is
    telling us that we are doing something wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we just want the input field to have a default value and we want to
    be able to change it by typing, we can use the `defaultValue` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, the field is going to show `Hello React` when it is rendered,
    but then the user can type anything inside it and change its value. Now let’s
    add some states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The handlers are the same as the previous ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, we will use the value attributes of the input fields to set their
    initial values, as well as the updated one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first time the form is rendered, React uses the initial values from the
    state as the value of the input fields. When the user types something into the
    field, the `handleChange` function is called and the new value for the field is
    stored in the state.
  prefs: []
  type: TYPE_NORMAL
- en: When the state changes, React re-renders the component and uses it again to
    reflect the current values of the input fields. We now have full control over
    the values of the fields, and we call this pattern **controlled components**.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to work with events, which are a fundamental
    part of React to handle data coming from forms.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Events` work in a slightly different way across various browsers. React tries
    to abstract the way events work and give developers a consistent interface to
    deal with. This is a great feature of React because we can forget about the browsers
    we are targeting and write event handlers and functions that are *vendor-agnostic*.'
  prefs: []
  type: TYPE_NORMAL
- en: To offer this feature, React introduced the concept of the synthetic event.
    A synthetic event is an object that wraps the original event object provided by
    the browser, and it has the same properties, no matter where it is created.
  prefs: []
  type: TYPE_NORMAL
- en: To attach an event listener to a node and get the event object when the event
    is fired, we can use a simple convention that recalls the way events are attached
    to the DOM nodes. In fact, we can use the word on plus the `camelCased` event
    name (for example, `onKeyDown`) to define the callback to be fired when the events
    happen. A popular convention is to name the event handler functions after the
    event name and prefix them using `handle` (for example, `handleKeyDown`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen this pattern in action in the previous examples, where we were
    listening to the `onChange` event of the form fields. Let’s reiterate a basic
    event listener example to see how we can organize multiple events inside the same
    component in a nicer way. We are going to implement a simple button, and we start,
    as usual, by creating a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we define the event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see here, we are doing a very simple thing: we just check the type
    of the event object we receive from React and the type of native event attached
    to it. We expect the first to return false and the second to return true.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should never need to access the original native event, but it is good to
    know you can do it if you need to. Finally, we define the button with the `onClick`
    attribute to which we attach our event listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose we want to attach a second handler to the button that listens
    to the double-click event. One solution would be to create a new separate handler
    and attach it to the button using the `onDoubleClick` attribute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Remember that we always aim to write less boilerplate and avoid duplicating
    code. For that reason, a common practice is to write a `single event handler`
    for each component, which can trigger different actions according to the event
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique is described in a collection of patterns by Michael Chan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://reactpatterns.com/#event-switch](http://reactpatterns.com/#event-switch)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement the generic event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The generic event handler receives the event object and switches on the event
    type to fire the right action. This is particularly useful if we want to call
    a function on each event (for example, analytics) or if some events share the
    same logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we attach the new event listener to the `onClick` and `onDoubleClick`
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: From this point on, whenever we need to create a new event handler for the same
    component, instead of creating a new method and binding it, we can just add a
    new case to the switch.
  prefs: []
  type: TYPE_NORMAL
- en: A couple more interesting things to know about events in React are that synthetic
    events are reused and that there is a **single global handler**. The first concept
    means that we cannot store a synthetic event and reuse it later because it becomes
    null right after the action. This technique is very good in terms of performance,
    but it can be problematic if we want to store the event inside the state of the
    component for some reason. To solve this problem, React gives us a persist method
    on the synthetic events, which we can call to make the event persistent so that
    we can store it and retrieve it later.
  prefs: []
  type: TYPE_NORMAL
- en: The second very interesting implementation detail is again about performance,
    and it is to do with the way React attaches the event handlers to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we use the on attribute, we are describing to React the behavior we
    want to achieve, but the library does not attach the actual event handler to the
    underlying DOM nodes.
  prefs: []
  type: TYPE_NORMAL
- en: What it does instead attaches a single event handler to the root element, which
    listens to all the events, thanks to **event bubbling**. When an event we are
    interested in is fired by the browser, React calls the handler on the specific
    components on its behalf. This technique is called **event delegation** and is
    used for memory and speed optimization.
  prefs: []
  type: TYPE_NORMAL
- en: In our next section, we are going to explore React refs and see how we can take
    advantage of them.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring refs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the reasons people love React is that it is declarative. Being declarative
    means that you just describe what you want to be displayed on the screen at any
    point in time and React takes care of the communications with the browser. This
    feature makes React very easy to reason about and very powerful at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: However, there might be some cases where you need to access the underlying DOM
    nodes to perform some imperative operations. This should be avoided because, in
    most cases, there is a more React-compliant solution to achieve the same result,
    but it is important to know that we have the option to do it and to know how it
    works so that we can make the right decision.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to create a simple form with an input element and a button,
    and we want it to behave in such a way that when the button is clicked, the input
    field gets focused. What we want to do is call the focus method on the input node,
    the actual DOM instance of the input, inside the browser’s window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a component called `Focus`; you need to import `useRef` and create
    an `inputRef` constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we implement the `handleClick` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are referencing the current attribute of `inputRef` and calling
    the focus method on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand where it comes from, you just have to check the implementation
    of the render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here comes the core of the logic. We create a form with an input element inside
    it and we define a function on its `ref` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The callback we defined is called when the component gets mounted, and the element
    parameter represents the DOM instance of the input. It is important to know that,
    when the component gets unmounted, the same callback is called with a null parameter
    to free the memory.
  prefs: []
  type: TYPE_NORMAL
- en: What we are doing in the callback is storing the reference of the element to
    be able to use it in the future (for example, when the `handleClick` method is
    fired). Then, we have the button with its event handler. Running the preceding
    code in a browser will show the form with the field and the button, and clicking
    on the button will focus the input field, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '*As we mentioned previously, in general, we should try to avoid using refs
    because they force the code to be more imperative, and they become harder to read
    and maintain.*'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding forwardRef
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`React.forwardRef` is a useful feature that allows you to pass a ref (short
    for “reference”) from a parent component down to a child component. This article
    will provide a basic introduction to `React.forwardRef` and offer a straightforward
    example to help you understand its practical usage.'
  prefs: []
  type: TYPE_NORMAL
- en: Refs in React are a mechanism to access and interact with the DOM elements rendered
    by a component. They provide a way to modify the DOM or access DOM properties
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: '`React.forwardRef` is a higher-order component that allows you to pass a ref
    down to a child component. This is useful when you need to access the child component’s
    DOM element or instance from the parent component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a component that can accept a forwarded ref, you will use the `React.forwardRef`
    function, which takes a render function as an argument. This render function receives
    two parameters: the component’s `props` and the forwarded ref.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To use the `forwardRef` component, you will create a ref using the `useRef()`
    hook and assign it to the `forwardRef` component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we created a `TextInputWithRef` component that accepts a forwarded
    ref. In the `App` component, we use the `useRef()` hook to create a ref, which
    we then pass to the `TextInputWithRef` component. When the `"Focus on input"`
    button is clicked, the `handleClick` function is called, which focuses on the
    input element.
  prefs: []
  type: TYPE_NORMAL
- en: '`React.forwardRef` is a powerful feature that allows you to pass refs from
    parent components to child components, providing greater control over the child
    components’ behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: By understanding the basics of refs and `forwardRef`, and examining a simple
    example, you can effectively utilize this feature in your React applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the nuances of utilizing `React.forwardRef` for superior control over
    components explored, we can now shift our focus toward another pivotal aspect
    of enhancing user experiences in React applications: implementing animations.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we think about UIs and the browser, we must surely think about animations
    as well. Animated UIs are more pleasant for users, and they are a very important
    tool to show users that something has happened or is about to occur.
  prefs: []
  type: TYPE_NORMAL
- en: This section does not aim to be an exhaustive guide to creating animations and
    beautiful UIs; the goal here is to provide you with some basic information about
    the common solutions we can put in place to animate our React components.
  prefs: []
  type: TYPE_NORMAL
- en: For a UI library such as React, it is crucial to provide an easy way for developers
    to create and manage animations. React comes with an add-on, called `react-transition-group`,
    which is a component that helps us build animations in a declarative way. Again,
    being able to perform operations declaratively is incredibly powerful, and it
    makes the code much easier to reason about and share with the team.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do to start building an animated component is to
    install the add-on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have done that, we can import the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we just wrap the component to which we want to apply the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are some props that need explaining. First, we are declaring
    the `transitionName` prop. `ReactTransitionGroup` applies a class with the name
    of that property to the child element so that we can then use CSS transitions
    to create our animations.
  prefs: []
  type: TYPE_NORMAL
- en: With a single class, we cannot easily create a proper animation, and that is
    why the transition group applies multiple classes according to the state of the
    animation. In this case, with the `transitionAppear` prop, we are telling the
    component that we want to animate the children when they appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: So, what the library does is apply the `fade-appear` class (where fade is the
    value of the `transitionName` prop) to the component as soon as it gets rendered.
    On the next tick, the `fade-appear-active` class is applied so that we can fire
    our animation from the initial state to the new one, using CSS.
  prefs: []
  type: TYPE_NORMAL
- en: We also have to set the `transitionAppearTimeout` property to tell React the
    length of the animation so that it doesn’t remove elements from the DOM before
    animations are completed.
  prefs: []
  type: TYPE_NORMAL
- en: The CSS to make an element `fade-in` is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the opacity of the element in the initial state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define our transition using the second class, which starts as soon
    as it gets applied to the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We are transitioning the opacity from 0.01 to 1 in 500ms using the ease-in function.
    This is pretty easy, but we can create more complex animations, and we can also
    animate different states of the component. For example, the `*-enter` and `*-enter-active`
    classes are applied when a new element is added as a child of the transition group.
    A similar thing applies to remove elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'After delving into the dynamic world of animations and understanding how they
    can dramatically enhance our React components, let’s now turn our attention to
    another fascinating facet of web design: the exploration of **Scalable Vector
    Graphics** (**SVG**).'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring SVG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, one of the most interesting techniques we can apply in the browser
    to draw icons and graphs is SVG.
  prefs: []
  type: TYPE_NORMAL
- en: SVG is great because it is a declarative way of describing vectors and it fits
    perfectly with the purposes of React. We used to use icon fonts to create icons,
    but they have well-known problems, with the first being that they are not accessible.
    It is also pretty hard to position icon fonts with CSS, and they do not always
    look beautiful in all browsers. These are the reasons we should prefer SVG for
    our web applications.
  prefs: []
  type: TYPE_NORMAL
- en: From a React point of view, it does not make any difference if we output a div
    or an SVG element from the render method, and this is what makes it so powerful.
    We also tend to choose SVG because we can easily modify them at runtime using
    CSS and JavaScript, which makes them an excellent candidate for the functional
    approach of React.
  prefs: []
  type: TYPE_NORMAL
- en: So, if we think about our components as a function of their props, we can easily
    imagine how we can create self-contained SVG icons that we can manipulate by passing
    different props to them. A common way to create SVG in a web app with React is
    to wrap our vectors into a React component and use the props to define their dynamic
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a simple example where we draw a blue circle, thus creating a
    React component that wraps an SVG element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can easily use a stateless functional component that wraps
    the SVG markup, and it accepts the same props as SVG does.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We can obviously use the full power of React and set some default parameters
    so that, if the circle icon is rendered without props, we still show something.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can define the default color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty powerful when we build UIs, especially in a team where we share
    our icon set and we want to have some default values in it, but we also want to
    let other teams decide their settings without having to recreate the same SVG
    shapes.
  prefs: []
  type: TYPE_NORMAL
- en: However, in some cases, we prefer to be stricter and fix some values to keep
    consistency. With React, this is a super simple task.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can wrap the base circle component into `RedCircle`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, the color is set by default, and it cannot be changed, while the other
    props are transparently passed to the original circle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows two circles, blue and red, that are generated
    by React using SVG:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Icon  Description automatically generated](img/B18414_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Two circles, blue and red SVGs'
  prefs: []
  type: TYPE_NORMAL
- en: We can apply this technique and create different variations of the circle, such
    as `SmallCircle` and `RightCircle`, and everything else we need to build our UIs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the different capabilities of React when targeting
    the browser, from creating forms and handling events to animating SVGs. We also
    learned about the new `useRef` Hook, which provides a simple way to access DOM
    nodes. React’s declarative approach simplifies the management of complex web applications.
    Additionally, React provides a way to access the DOM nodes, allowing for imperative
    operations if needed, making it easier to integrate React with existing libraries.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will delve into CSS and inline styles, and explore the
    concept of writing CSS in JavaScript.
  prefs: []
  type: TYPE_NORMAL
