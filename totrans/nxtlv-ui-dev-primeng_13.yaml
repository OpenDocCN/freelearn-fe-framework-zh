- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing PrimeNG Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will dive into the critical aspects of testing Angular applications
    powered by PrimeNG components. Throughout the journey, you will learn how to effectively
    test your PrimeNG components, ensuring their reliability and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding the principles, techniques, and tools of testing, you can enhance
    the quality, stability, and maintainability of your Angular applications. Throughout
    this chapter, you will acquire fundamental knowledge on setting up tests and efficiently
    testing your Angular components through various examples. Additionally, you will
    become acquainted with best practices and libraries that can enhance and support
    your testing endeavors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with basic Angular testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests for PrimeNG components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing testing tips and tricks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter contains various code samples for testing. You can find the related
    source code in the `chapter-13` folder of the following GitHub repository: [https://github.com/PacktPublishing/Next-Level-UI-Development-with-PrimeNG/tree/main/apps/chapter-13](https://github.com/PacktPublishing/Next-Level-UI-Development-with-PrimeNG/tree/main/apps/chapter-13)'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with basic Angular testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will introduce you to the fundamentals of testing in Angular
    applications. Testing is an essential part of the development process that allows
    early bug detection, faster feedback cycles, and improved code stability. Moreover,
    when continuously making changes to your code over time, following testing best
    practices can effectively mitigate potential issues, preserve existing functionality,
    and ensure the delivery of high-quality software to your users.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Angular testing fundamentals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular provides a robust testing framework that allows you to write tests for
    your components, services, and other parts of your application. Testing in Angular
    is based on the principles of unit testing, where individual units of code are
    tested in isolation. This approach helps ensure that each unit functions correctly
    and meets the expected requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in Angular involves writing test cases that simulate user interactions,
    verify component behavior, and assert expected outcomes. These tests help you
    identify and fix bugs, validate business logic, and ensure that your application
    works as intended.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you first install an Angular project, it comes with `package.json` and
    `angular.json` in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This code snippet is part of the configuration files for setting up testing
    in an Angular application. Let’s break this code block down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`devDependencies: {...}`: This contains the packages for running tests in Angular.
    For example, `karma-jasmine-html-reporter` generates a detailed HTML report after
    tests run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`karma`: This is a popular test runner for JavaScript applications. It allows
    you to execute tests in multiple browsers, capture the results, and report them.
    When you run `ng test`, Karma launches a development server, opens specified browsers,
    and executes Jasmine tests in those browsers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jasmine`: This is a **behavior-driven development** (**BDD**) testing framework
    for JavaScript. In the context of Angular, Jasmine is often used as the testing
    framework for writing and running unit tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"builder": "@angular-devkit/build-angular:karma"`: This is a builder provided
    by the Angular DevKit, and it’s used as a target for running Karma tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to run a test in Angular, you can run the `npm run test` command,
    which will generate the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the test will also appear in the terminal and the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Karma test result](img/B18805_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – Karma test result
  prefs: []
  type: TYPE_NORMAL
- en: As a result, when you run the command for testing, Karma will open the browser
    and successfully execute the tests from `AppComponent`. Additionally, you will
    be able to observe the executed tests and their outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Angular testing with Jest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Angular, Karma and Jasmine have been the default testing framework choices,
    but with the introduction of Angular v16, **Jest** has been included as an experimental
    alternative for writing unit tests. The decision to adopt Jest stems from the
    fact that Karma, while effective, relies on a real web browser, leading to slower
    and heavier tests. Additionally, the use of a real browser introduces complexities
    in **continuous integration** (**CI**). Another factor to consider is that Karma
    has been deprecated ([https://github.com/karma-runner/karma](https://github.com/karma-runner/karma)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: CI is a development practice that involves automatically integrating code changes
    from multiple contributors into a shared repository. It includes automated processes
    such as building and testing to detect integration issues early in the development
    cycle. CI promotes collaboration, accelerates development, and ensures code quality
    by providing immediate feedback on the health of the code base. Popular CI tools
    include Jenkins, Travis CI, CircleCI, and GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some other benefits when running Jest:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Snapshot testing**: This simplifies the process of visually inspecting changes
    in the UI and helps prevent unintended regressions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fast and parallel test execution**: Jest is known for its speed and efficient
    test execution. It can run tests in parallel, providing quicker feedback during
    development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to integrate**: Jest is easily set up with Angular projects without
    requiring complex configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Built-in code coverage reports**: Jest includes built-in support for generating
    code coverage reports. This allows developers to assess how much of their code
    is covered by tests, aiding in identifying areas that may need additional testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mocking and spying simplified**: Jest provides a convenient API for creating
    mocks and spies, making it easier to isolate components or services during testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Watch mode with intelligent test re-runs**: Jest’s watch mode intelligently
    re-runs only the tests affected by code changes, significantly speeding up the
    feedback loop during development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ecosystem and community**: Jest has a vibrant and active community with a
    growing ecosystem of plugins and extensions. This can be advantageous when looking
    for solutions, support, or integrations within the broader JavaScript and testing
    ecosystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, let’s change our testing framework to Jest instead. First, you need to
    install Jest packages by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This command will install `jest` and `jest-environment-jsdom`, which is an environment
    for Jest that simulates a browser-like environment using JSDOM.
  prefs: []
  type: TYPE_NORMAL
- en: '`jest-environment-jsdom`, Jest tests can run in a simulated browser environment,
    allowing you to write and run tests that interact with the DOM, handle events,
    and perform other browser-related operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, let’s update our testing target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By changing the builder from `@angular-devkit/build-angular:karma` to `@angular-devkit/build-angular:jest`,
    we now can utilize Jest for running our unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the test result by running `npm` `run test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that there is no difference in the process of writing unit tests
    and the execution speed of the tests is significantly faster.
  prefs: []
  type: TYPE_NORMAL
- en: Step-by-step guide to writing your initial Angular tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have covered the preparation part, let’s dive into writing your
    first set of tests. In unit testing, you can utilize the **Arrange, Act, and Assert**
    (**AAA**) pattern, a common methodology for structuring and organizing unit tests.
    Each part of AAA serves a distinct purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrange**: In this step, you set up the test environment. This involves creating
    instances of the components or services you want to test, providing any necessary
    dependencies, and configuring the initial state of the test.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Act**: This is where you perform the action or trigger the behavior that
    you want to test. It might involve calling a method, interacting with a component,
    or simulating an event.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Assert**: In the final step, you check the results of the action to ensure
    that it matches the expected outcome. This is where you make assertions about
    the state of your application after the action has been performed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the AAA pattern helps to keep tests organized, readable, and focused on
    specific behaviors. It provides a clear structure for writing and understanding
    tests, making it easier to maintain and troubleshoot them as your code base evolves.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let’s have a look at a real Angular test.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down a simple unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we first create an Angular application, the CLI helps to generate a test
    file for your `AppComponent`. Let’s have a look at the sample test file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The provided code snippet is an Angular test script for the `AppComponent`
    component. Let’s break this code block down in the following list so we can understand
    it more:'
  prefs: []
  type: TYPE_NORMAL
- en: '`describe(''AppComponent'', ()...`: This is a test suite that groups related
    tests. In this case, it groups tests for `AppComponent`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beforeEach(async () => ...)`: This function is a setup function that runs
    before each individual test case. It is an asynchronous function that configures
    the testing module using `TestBed.configureTestingModule`, which is a key part
    of Angular’s testing infrastructure provided by the `TestBed` utility. It allows
    you to configure the testing module by specifying the necessary dependencies,
    providers, and imports for the component undergoing testing. In this case, it
    imports `AppComponent`. This is also the Arrange step in the AAA pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`it(''should render title''...`: This function is a test case that defines
    a specific behavior to be tested. In this case, the test case is named `should
    render title`. Let’s break this function down based on the AAA pattern:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AppComponent` using `TestBed.createComponent`, and retrieved the compiled
    HTML element with `fixture.nativeElement`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fixture.detectChanges()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<h1>` element contains the string `Welcome` `to chapter-13`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, this test verifies that `AppComponent` correctly renders a title with
    the expected text content. It sets up the component, triggers change detection,
    and asserts the expected outcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, by using basic testing techniques, we can set a solid foundation
    for ensuring the quality and reliability of our Angular applications. Now that
    we have a grasp of basic testing concepts, let’s dive into a specific use case:
    writing tests for PrimeNG components. We will also write our unit tests while
    utilizing Jest as our unit testing framework.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing test for PrimeNG components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing PrimeNG components follows the same principles as testing regular Angular
    components. This similarity arises from the fact that PrimeNG components are essentially
    Angular components under the hood. In the following sections, we will explore
    a few of these tests to gain insights and knowledge in this area.
  prefs: []
  type: TYPE_NORMAL
- en: How PrimeNG tests its components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let’s have a look at how PrimeNG tests its own components. Due to space
    limitations in this book, it is not possible to display the entire test file,
    as it is quite lengthy. However, we can focus on a specific section that illustrates
    how PrimeNG tests its components in its source code. Here is the example code
    of a PrimeNG `Button` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the code in the following list so we can understand its different
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`beforeEach(...)`: This function is used to set up the testing environment
    before each test case. In this case, it is used to configure the testing module
    by calling `TestBed.configureTestingModule`. The `imports` property specifies
    any required modules, and the `declarations` property specifies the component
    being tested. In this case, it imports `NoopAnimationsModule` and adds `Button`
    to the declarations array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`should disabled when disabled is true`: This test case sets the `disabled`
    property of the `Button` component to `true`, triggers change detection using
    `fixture.detectChanges()`, and then queries the DOM for the button element using
    `fixture.debugElement.query`. It asserts that the `disabled` property of the button
    element is `true` using `expect(...).toBeTruthy()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`should display the label and have a text only class`: This test case sets
    the `label` property of the `Button` component to `PrimeNG`, triggers change detection,
    and queries the DOM for the `button` element. It asserts that the `button` element’s
    text content contains `PrimeNG` using `expect(...).toContain(...)`, and it verifies
    that the `button` element has only one child element using `expect(...).toEqual(1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of these tests is to verify the expected behavior of the `Button`
    component. By changing its properties and triggering change detection, the tests
    ensure that the component renders correctly and behaves as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In the PrimeNG source code ([https://github.com/primefaces/primeng/tree/master/src/app/components](https://github.com/primefaces/primeng/tree/master/src/app/components)),
    there are existing tests that you can study and use as references to enhance your
    understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and testing our own component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Putting the previous examples and knowledge into practice, let’s create a test
    for the following card component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Sample card component](img/B18805_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – Sample card component
  prefs: []
  type: TYPE_NORMAL
- en: 'By examining the screenshot, you can observe the visual representation of the
    card component we created. To ensure the proper functioning of this component,
    it is essential to write tests that validate the correct rendering of its title,
    subtitle, and buttons. The following code block is an example of the test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the code in the following list so that we can understand its
    different sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`should create`: The test case checks whether the `component` instance is `Truthy`,
    meaning that it has been successfully created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`should display the product title and subtitle`: This test case triggers change
    detection and then queries the DOM for the `p-card` element using `fixture.debugElement.query`.
    It asserts that the content of the `p-card` element contains the expected product
    `title` value and `subtitle` value using `expect(...).toContain(...)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`should have a footer`: This test case triggers change detection, then queries
    the DOM for the footer element with the`.p-card-footer` class and all the buttons
    with the`.p-button` class. It asserts that both the footer element and the buttons
    are `Truthy` using `expect(...).toBeTruthy()`, and it also verifies that there
    are two buttons present by checking the length of the `ctaButtons` array using
    `expect(...).toEqual(2)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After running the test, you can see that it passes successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In conclusion, writing tests for PrimeNG components equips you with the ability
    to ensure the functionality and reliability of these components within your Angular
    applications. Now that we have explored the process of writing tests for PrimeNG
    components, let’s further enhance our testing practices by utilizing helpful tips
    and tricks to improve the effectiveness and efficiency of our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing testing tips and tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even though testing enables us to ensure the correctness and stability of our
    code, writing effective tests can sometimes be challenging. In this section, we
    will explore various tips and tricks that can help you improve your testing practices,
    using the following editable table as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Sample editable table](img/B18805_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – Sample editable table
  prefs: []
  type: TYPE_NORMAL
- en: The table presents a list of products that are editable and removable. Upon
    clicking the delete icon, a confirmation dialog appears to verify the deletion
    action.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s now look at some testing tips.
  prefs: []
  type: TYPE_NORMAL
- en: Isolate unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing unit tests, it’s crucial to isolate the component or service undergoing
    testing from its dependencies. Angular’s **TestBed** provides a powerful toolset
    for creating and configuring testing modules. By leveraging TestBed, we can mock
    dependencies and provide fake implementations, enabling us to focus solely on
    the unit we want to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use `TestBed.configureTestingModule` to set up the testing
    module. By specifying `imports` and `providers`, we can mock dependencies and
    ensure they are correctly injected into the component or service being tested.
    In this case, instead of calling the `getProducts()` function from `ShopService`,
    we replace the result with the `productsStub` value, which makes it isolated and
    easier to test.
  prefs: []
  type: TYPE_NORMAL
- en: Utilize NO_ERRORS_SCHEMA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When testing Angular components, we often encounter situations where we don’t
    need to assert the behavior or rendering of child components such as Angular Material
    components. In such cases, `NO_ERRORS_SCHEMA` can be a handy tool to simplify
    our test setup.
  prefs: []
  type: TYPE_NORMAL
- en: '`NO_ERRORS_SCHEMA` tells Angular’s compiler to ignore unrecognized elements
    and attributes within the component template. This allows us to focus on testing
    the component’s logic without the need to provide detailed mock implementations
    of child components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we specify `schemas: [NO_ERRORS_SCHEMA]` in the testing module
    configuration. This allows us to test `AppComponent` without worrying about the
    presence or behavior of any child components.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Avoid using `NO_ERRORS_SCHEMA` if you are writing integration tests. This is
    because the `NO_ERRORS_SCHEMA` option will ignore template errors for unknown
    elements and attributes. It allows Angular to run tests even if there are issues
    with child components’ templates. You can read more at [https://angular.io/guide/testing-components-scenarios#no_errors_schema](https://angular.io/guide/testing-components-scenarios#no_errors_schema).
  prefs: []
  type: TYPE_NORMAL
- en: Utilize the spyOn method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`spyOn` function, along with the spy object, to facilitate method spying.'
  prefs: []
  type: TYPE_NORMAL
- en: By using `spyOn`, we can replace a method with a spy function that records all
    invocations and provides additional capabilities, such as returning specific values
    or throwing exceptions. This enables us to verify whether a method was called,
    how many times it was called, and with which arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the code in the following list and learn what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(''should show accept message on delete'', () => { ... })`: This is a test
    case description. In this case, it is checking whether a specific message is shown
    after deleting a row.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const messageSpy = jest.spyOn(messageService, ''add'')`: This line creates
    a spy using Jest’s `spyOn` function. It spies on the `add` method of the `messageService`
    object. This allows us to track whether and how this method is called during the
    test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`component.onRowDelete(1)`: This line calls the `onRowDelete` method of the
    component under test and passes `1` as an argument. This simulates the deletion
    of a row with an index of `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fixture.detectChanges()`: This line triggers change detection in the test
    fixture. It ensures that any changes in the component’s template are applied and
    updates are reflected in the test environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`confirmDialog.accept()`: This line simulates the user accepting a confirmation
    dialog. It assumes that the component has a `confirmDialog` object with an `accept`
    method, which is called to confirm the deletion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expect(messageSpy).toHaveBeenCalledWith({ ... })`: This line uses the `expect`
    function to make an assertion. It checks whether the `add` method of the `messageService`
    object was called with the expected argument. In this case, it expects that the
    method was called with an object containing specific properties such as `severity`,
    `summary`, and `detail`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, the spying method is a powerful tool for tracking and controlling
    function calls during testing, providing insights into the behavior of your application.
    As we transition to the next section, let’s explore how to handle asynchronous
    code and manage time-related operations in Angular testing.
  prefs: []
  type: TYPE_NORMAL
- en: Working with fakeAsync
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`fakeAsync` is a utility in Angular testing that enables synchronous testing
    of asynchronous code. It runs the test in a special “fake” zone where asynchronous
    operations can be controlled using `tick()`. Here is a simple demonstration of
    `fakeAsync` and `tick`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `fakeAsync` is used to wrap the `test` function. `setTimeout`
    is used to simulate an asynchronous operation, and `tick` is used to simulate
    the passage of time. By calling `tick(500)`, you simulate the passing of 500 milliseconds,
    and then you can make assertions about the state of your application. This is
    useful for testing asynchronous behavior in a synchronous manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s have a look at some more example code that tests the behavior of
    PrimeNG `MessageService` in `TipsComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This test verifies whether the message displays the correct value upon pressing
    the *Esc* button. The following bullet points outline the flow of the test:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we trigger the delete action through the `component.onRowDelete(1)` function,
    so the confirmation dialog shows up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, we use `tick` to advance the virtual clock by a specified amount
    of time. In this case, we use `tick(300)` to simulate a 300-millisecond delay.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the `tick` function is used, we simulate the `Escape` keydown event by
    creating a `KeyboardEvent` object and dispatching it on the document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the `Escape` event is dispatched, we can assert on the message service
    via `expect(messageSpy).toHaveBeenCalledWith({...})`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we use `flush` to flush any pending asynchronous tasks, ensuring that
    all asynchronous operations have been completed before the `test` function exits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this section, we’ve gained insights into managing asynchronous operations
    in Angular testing. In the next section, we will delve into a powerful testing
    utility that simplifies and enhances our testing capabilities: Spectator.'
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing third-party libraries – Spectator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Spectator** ([https://ngneat.github.io/spectator](https://ngneat.github.io/spectator))
    provides a set of utilities and techniques that facilitate writing concise and
    expressive tests for Angular components. It allows you to create component instances,
    mock dependencies, access the component’s DOM, and assert the component’s behavior
    with minimal boilerplate code. It also provides a clean and intuitive syntax that
    makes test cases more readable and maintainable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, first, we need to install the `spectator` package by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, let’s create an example test in which we use `Spectator` for testing
    an Angular component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The given code utilizes Spectator to test the behavior of the `TipsComponent`
    instance. Let’s break down the code block in the following list so we can understand
    each part:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const createComponent = createComponentFactory({ ... })`: This defines a `createComponent`
    function using `createComponentFactory` from `Spectator`. This function is used
    to create an instance of `TipsComponent` for testing. It also provides a mock
    instance of `ShopService` through the `providers` array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beforeEach(() => (spectator = createComponent()))`: This is a setup step that
    runs before each test case. It creates a new instance of `TipsComponent` using
    the `createComponent` function and assigns it to the `spectator` variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`it(''should show table content'', () => { ... })`: This line defines a test
    case with the description `should show table content`. This test case verifies
    that the table in `TipsComponent` contains the expected content. This is broken
    down in more detail as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const table = spectator.query(''p-table'')`: This uses the `query` method
    from the `spectator` object to find the `<p-table>` element in the component’s
    template.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expect(table?.textContent).toContain(...)`: This asserts that `textContent`
    of the `table` element (if it exists) contains the string `Product 1` or `Product
    2`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we conclude our exploration of `Spectator`, we’ve discovered its efficacy
    in simplifying and improving our testing workflow for Angular components. Now,
    let’s have a look at another helpful library to enhance our testing practices:
    `ng-mocks`.'
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing third-party libraries – ng-mocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another powerful third-party library for testing Angular applications is `ng-mocks`
    simplifies the testing process by providing flexible mocking and stubbing capabilities,
    making it easier to isolate components and services during testing.
  prefs: []
  type: TYPE_NORMAL
- en: With ng-mocks, we can create mock implementations of Angular components and
    services, define custom behavior for methods, and verify interactions. This allows
    us to focus on testing specific units without worrying about the complexities
    of real implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, first, we need to install the `ng-mocks` package by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s have a look at how to use ng-mocks in Angular testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the code block in the following list so that we can understand
    what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`providers: [MockProvider(ShopService)]`: This is used to create a mock version
    of `ShopService` and configure it as a provider in the test environment. This
    ensures that the test uses the mock version of `ShopService` instead of the actual
    implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beforeAll(() => MockInstance(ShopService, () => ({ ... })))`: This `beforeAll`
    hook is executed once before all the test cases in the suite. It mocks the `ShopService`
    dependency by using the `MockInstance` function from `ng-mocks`. It replaces the
    original `getProducts` method with a mocked implementation that returns `productsStub`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`ng-mocks` also works fine with `spectator`. You can read more at [https://ng-mocks.sudo.eu/extra/with-3rd-party](https://ng-mocks.sudo.eu/extra/with-3rd-party).'
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we’ve delved into the intricacies of Angular testing, uncovering
    practical tips and tricks that empower you to enhance the efficiency and resilience
    of your test suites.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to effectively test PrimeNG components in your
    Angular applications. By leveraging Jest, a powerful testing framework, you gained
    the ability to ensure the functionality and reliability of these components.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, you explored various concepts and techniques related
    to testing PrimeNG components. You started by understanding the importance of
    testing and the benefits it brings to your development workflow. Then, you delved
    into the specific steps involved in writing unit tests for PrimeNG components,
    including component setup, testing component behavior, and validating component
    appearance and interactions.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you also encountered practical examples, code snippets, and best
    practices that demonstrated how to effectively test PrimeNG components. By following
    along and implementing these testing strategies, you gained hands-on experience
    in verifying the correctness, reliability, and performance of your PrimeNG components.
  prefs: []
  type: TYPE_NORMAL
- en: As we transition to the next chapter, we will shift our focus to the world of
    building a responsive web application utilizing PrimeNG components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 4: Real-World Application'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final part, you will apply all the knowledge and skills you have acquired
    throughout the previous chapters to build a real-world responsive web application.
    This part will provide you with hands-on experience, allowing you to put your
    PrimeNG and Angular expertise to practical use.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this part, you will have completed a fully functional responsive
    web application using PrimeNG and Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B18805_14.xhtml#_idTextAnchor288), *Building a Responsive Web
    Application*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
