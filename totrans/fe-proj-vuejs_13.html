<html><head></head><body>
		<div>
			<div id="_idContainer362" class="Content">
			</div>
		</div>
		<div id="_idContainer363" class="Content">
			<h1 id="_idParaDest-260"><a id="_idTextAnchor347"/>13. End-to-End Testing</h1>
		</div>
		<div id="_idContainer387" class="Content">
			<p class="callout-heading"><a id="_idTextAnchor348"/>Overview</p>
			<p class="callout">In this chapter, we will look at how to create an <strong class="bold">End-to-End</strong> (<strong class="bold">E2E</strong>) test suite for a Vue.js application with Cypress. In order to write robust tests, we'll look at common pitfalls and best practices such as intercepting HTTP requests and waiting for elements to appear without timeouts.</p>
			<p class="callout">As we proceed, you will gain an understanding of E2E testing and its use cases. You will see how Cypress can be configured to test a Vue.js application and also interact with and inspect a user interface using it. Throughout the course of the chapter, you will gain familiarity with the pitfalls of arbitrary timeouts and how to avoid them with Cypress' waiting functionality. Toward the end of the chapter, you will also learn when, why, and how to intercept HTTP requests with Cypress.</p>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor349"/>Introduction</h1>
			<p>In this chapter, we'll write E2E tests for a highly asynchronous application.</p>
			<p>In previous chapters, we've seen how to build complex Vue.js applications and how to write unit tests for them. This chapter will cover how to use Cypress to write E2E tests for a Vue.js application that is highly interactive and uses an HTTP API. We'll see how E2E testing gives you a high level of confidence that an application will work as designed by automating user flows.</p>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor350"/>Understanding E2E Testing and Its Use Cases</h1>
			<p>Most developers will have seen a version of the testing pyramid shown in the following figure:</p>
			<div>
				<div id="_idContainer364" class="IMG---Figure">
					<img src="image/B15218_13_01.jpg" alt="Figure 13.1: A diagram of the testing pyramid&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.1: A diagram of the testing pyramid</p>
			<p>E2E tests fall under the <strong class="bold">User Interface</strong> (<strong class="bold">UI</strong>) testing category. The type of test we'll be looking at in this chapter is automated E2E tests using Cypress.</p>
			<p>E2E and UI tests provide a level of confidence higher than unit or integration tests. They're testing the application as used by the end user. The end user doesn't care why or where a bug is happening, just that there is a bug. The <em class="italic">where and why</em> of a bug tends to be the concern of unit and system-level tests. Unit and system-level tests check that the internals of a system work as the specification or code describes them. UI-level tests validate that application flows are working as expected.</p>
			<p>A strong E2E test suite that runs fast, has few false negatives (where a test fails but the application works), and even fewer false positives (where all tests pass but the application is broken) enables <strong class="bold">Continuous Deployment</strong> (<strong class="bold">CD</strong>). CD, as its name entails, involves deploying a project or application continually. In this kind of setup, an application version is validated by the E2E suite and is then automatically deployed to production.</p>
			<h1 id="_idParaDest-263">C<a id="_idTextAnchor351"/>onfiguring Cypress for a Vue.js Application</h1>
			<p><strong class="bold">Cypress</strong> is a JavaScript E2E testing framework. It's designed to solve the very specific need of writing E2E tests using JavaScript. This is in contrast to other fully fledged <strong class="bold">browser automation</strong> solutions such as <strong class="bold">WebDriverIO</strong> (<a href="https://webdriver.io/">https://webdriver.io/</a>), <strong class="bold">Selenium Webdriver</strong> (<a href="https://www.selenium.dev/">https://www.selenium.dev/</a>), <strong class="bold">Puppeteer</strong> (<a href="https://developers.google.com/web/tools/puppeteer/">https://developers.google.com/web/tools/puppeteer/</a>), and <strong class="bold">Playwright</strong> (<a href="https://github.com/microsoft/playwright">https://github.com/microsoft/playwright</a>), which are commonly used to write E2E tests.</p>
			<p>The big difference with Cypress compared to these other solutions is its singular focus on writing E2E tests (as opposed to generic browser automation). Tests can only be written using JavaScript (Selenium supports other languages), and up until recently, it only supported Chrome (Cypress 4.0 now has support for Firefox and Microsoft Edge as per <a href="https://www.cypress.io/blog/2020/02/06/introducing-firefox-and-edge-support-in-cypress-4-0/">https://www.cypress.io/blog/2020/02/06/introducing-firefox-and-edge-support-in-cypress-4-0/</a>).</p>
			<p>Cypress has a <strong class="bold">Graphical User Interface</strong> (<strong class="bold">GUI</strong>) to run and debug tests locally and comes with built-in assertion and stubbing/mocking libraries.</p>
			<p>To add Cypress to a project using the Vue CLI, we can use the <strong class="source-inline">e2e-cypress</strong> plugin (<a href="https://cli.vuejs.org/core-plugins/e2e-cypress.html">https://cli.vuejs.org/core-plugins/e2e-cypress.html</a>), whose install instructions guide us to run the following command at the command line. As part of adding the plugin, Cypress and its supporting packages are downloaded and unpacked, so it might take a while to complete:</p>
			<p class="source-code">vue add @vue/e2e-cypress</p>
			<p>The plugin adds a <strong class="source-inline">test:e2e</strong> script that we can run using the following command. This command takes a while to start since it needs to run a production build of the application and then start the Cypress app:</p>
			<p class="source-code">npm run test:e2e</p>
			<p>Eventually, we'll see the Cypress GUI as follows:</p>
			<div>
				<div id="_idContainer365" class="IMG---Figure">
					<img src="image/B15218_13_02.jpg" alt="Figure 13.2: The Cypress GUI after plugin installation and the run test:e2e command&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.2: The Cypress GUI after plugin installation and the run test:e2e command</p>
			<p>The plugin creates a default <strong class="source-inline">test.js</strong> file for us. The contents are as follows by default. The test goes to the application root (<strong class="source-inline">/</strong>) and checks that the <strong class="source-inline">h1</strong> on the page contains <strong class="source-inline">Welcome to Your Vue.js App</strong>:</p>
			<p class="source-code">// https://docs.cypress.io/api/introduction/api.html</p>
			<p class="source-code">describe('My First Test', () =&gt; {</p>
			<p class="source-code">  it('Visits the app root url', () =&gt; {</p>
			<p class="source-code">    cy.visit('/')</p>
			<p class="source-code">    cy.contains('h1', 'Welcome to Your Vue.js App')</p>
			<p class="source-code">  })</p>
			<p class="source-code">})</p>
			<p>This works in an empty Vue CLI project.</p>
			<p>We can try visiting <strong class="source-inline">google.com</strong> using <strong class="source-inline">cy.visit(url)</strong> and check that the <strong class="source-inline">input</strong> element that's synonymous with the Google home page is there by first selecting the input elements on the page with <strong class="source-inline">cy.get('input')</strong> and then using the <strong class="source-inline">.should('exist')</strong> assertion:</p>
			<p class="source-code">describe('My First Test', () =&gt; {</p>
			<p class="source-code">  it('Opens an arbitrary URL', () =&gt; {</p>
			<p class="source-code">    cy.visit('https://google.com')</p>
			<p class="source-code">    cy.get('input').should('exist')</p>
			<p class="source-code">  })</p>
			<p class="source-code">})</p>
			<p>We can run the test by clicking on <strong class="source-inline">test.js</strong> in the Cypress UI (when <strong class="source-inline">npm run test:e2e</strong> is running) as follows:</p>
			<div>
				<div id="_idContainer366" class="IMG---Figure">
					<img src="image/B15218_13_03.jpg" alt="Figure 13.3: The Cypress UI running test.js&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.3: The Cypress UI running test.js</p>
			<p>When Cypress is running tests, a browser window is opened to run them:</p>
			<div>
				<div id="_idContainer367" class="IMG---Figure">
					<img src="image/B15218_13_04.jpg" alt="Figure 13.4: Cypress tests running in Chrome while visiting the Google home page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.4: Cypress tests running in Chrome while visiting the Google home page</p>
			<p>We've now seen how to install and use Cypress to visit web pages.</p>
			<p>In the next section, we'll see how Cypress can be used to interact with and inspect a UI.</p>
			<h2 id="_idParaDest-264">Usin<a id="_idTextAnchor352"/>g Cypress to Interact with and Inspect a Vue.js UI</h2>
			<p>In order to E2E test the <strong class="bold">Commentator Pro</strong> application, we should start by adding something to test. In this case, we'll have a heading (<strong class="source-inline">h2</strong>) with the name of the application. In the <strong class="source-inline">App.vue</strong> file, we'll have the following code:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app" class="p-10"&gt;</p>
			<p class="source-code">    &lt;div class="flex flex-col"&gt;</p>
			<p class="source-code">      &lt;h2</p>
			<p class="source-code">        class="uppercase leading-loose pb-4 flex justify-center           m-auto md:w-1/3 text-xl mb-8 font-bold text-gray-800           border-b"</p>
			<p class="source-code">      &gt;</p>
			<p class="source-code">        Commentator Pro</p>
			<p class="source-code">      &lt;/h2&gt;</p>
			<p class="source-code">   &lt;/div&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>In order to test this with Cypress, we can change the <strong class="source-inline">tests/e2e/specs/test.js</strong> file with the following code. We'll go to the running application using <strong class="source-inline">cy.visit('/')</strong> and then check that the <strong class="source-inline">h2</strong> on the page contains <strong class="bold">Commentator Pro</strong> using <strong class="source-inline">cy.contains('h2', 'Commentator Pro')</strong>. The <strong class="source-inline">cy.contains</strong> function is overloaded and can be used with one parameter (the text to match against) or two parameters (the selector for the container and the text to match against):</p>
			<p class="source-code">describe('Commentator Pro', () =&gt; {</p>
			<p class="source-code">  it('Has a h2 with "Commentator Pro"', () =&gt; {</p>
			<p class="source-code">    cy.visit('/')</p>
			<p class="source-code">    cy.contains('h2', 'Commentator Pro')</p>
			<p class="source-code">  })</p>
			<p class="source-code">})</p>
			<p>We can then run <strong class="source-inline">test.js</strong> using the Cypress UI as seen in the following screenshot:</p>
			<div>
				<div id="_idContainer368" class="IMG---Figure">
					<img src="image/B15218_13_05.jpg" alt="Figure 13.5: Heading content test running successfully in Chrome&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.5: Heading content test running successfully in Chrome</p>
			<p>Now t<a id="_idTextAnchor353"/>hat we've seen how to visit a page and assert on its content, we'll see how we can use Cypress to automate tests for a new feature in a Vue.js application.</p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor354"/>Exercise 13.01: Adding a "New Comment" Button and Corresponding E2E Test</h2>
			<p>In order for the <strong class="bold">Commentator Pro</strong> application to be useful, we should have an <strong class="source-inline">Add a new comment</strong> button to allow users to add comments.</p>
			<p>We will add a blue jumbo button with the text <strong class="source-inline">Add a New Comment</strong> and write the corresponding E2E test with Cypress. </p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/36PefjJ">https://packt.live/36PefjJ</a>.</p>
			<p>To do this, perform the following steps:</p>
			<ol>
				<li>To add a button in the app, we'll add a <strong class="source-inline">button</strong> element with some <strong class="source-inline">TailwindCSS</strong> classes in <strong class="source-inline">src/App.vue</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app" class="p-10"&gt;</p><p class="source-code">    &lt;div class="flex flex-col"&gt;</p><p class="source-code">      &lt;!-- rest of template --&gt;</p><p class="source-code">      &lt;button class="flex mx-auto bg-blue-500 hover:bg-blue-700         text-white font-bold py-2 px-4 rounded"&gt;</p><p class="source-code">        Add a New Comment</p><p class="source-code">      &lt;/button&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p>The output should show as follows:</p><div id="_idContainer369" class="IMG---Figure"><img src="image/B15218_13_06.jpg" alt="Figure 13.6: Commentator Pro application with the &quot;Add a New Comment&quot; button&#13;&#10;"/></div><p class="figure-caption">Figure 13.6: Commentator Pro application with the "Add a New Comment" button</p></li>
				<li>Next, we'll create a new E2E test at <strong class="source-inline">tests/e2e/specs/add-new-comment.js</strong>. We'll set the name of the suite and description of the test to <strong class="source-inline">Adding a New Comment</strong> and <strong class="source-inline">the homepage should have a button with the right text</strong> respectively:<p class="source-code">describe('Adding a New Comment', () =&gt; {</p><p class="source-code">  it('the homepage should have a button with the right text',     () =&gt; {</p><p class="source-code">    // test will go here</p><p class="source-code">  })</p><p class="source-code">})</p></li>
				<li>In order to test the home page, we'll have to navigate to it using <strong class="source-inline">cy.visit('/')</strong>:<p class="source-code">describe('Adding a New Comment', () =&gt; {</p><p class="source-code">  it('the homepage should have a button with the right text',     () =&gt; {</p><p class="source-code">    cy.visit('/')</p><p class="source-code">  })</p><p class="source-code">})</p></li>
				<li>Finally, we can write the assertion that a <strong class="source-inline">button</strong> instance containing the text <strong class="source-inline">Add a New Comment</strong> is on the page:<p class="source-code">describe('Adding a New Comment', () =&gt; {</p><p class="source-code">  it('the homepage should have a button with the right text',     () =&gt; {</p><p class="source-code">    cy.visit('/')</p><p class="source-code">    cy.contains('button', 'Add a New Comment')</p><p class="source-code">  })</p><p class="source-code">})</p></li>
				<li>We can run this test using the Cypress UI (get it running using <strong class="source-inline">npm run test:e2e</strong>):<div id="_idContainer370" class="IMG---Figure"><img src="image/B15218_13_07.jpg" alt="Figure 13.7: The &quot;add-new-comment.js&quot; test displaying in the Cypress UI&#13;&#10;"/></div><p class="figure-caption">Figure 13.7: The "add-new-comment.js" test displaying in the Cypress UI</p></li>
				<li>When we run the test, we'll get the following output in Chrome. The test passes since there is a button with the relevant text on the home page:<div id="_idContainer371" class="IMG---Figure"><img src="image/B15218_13_08.jpg" alt="Figure 13.8: Cypress running our &quot;add-new-comment&quot; test in Chrome&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.8: Cypress running our "add-new-comment" test in Chrome</p>
			<p>We've now seen how to visit pages and assert against their content.</p>
			<p>In the next section, we will look at using Cypress to test interactive behavior. Cypress has automatic selector retries, which make it a great fit for testing highly interactive Vue.js applications. We'll see how to use Cypress to interact with the UI and assert on the effect of our interactions.</p>
			<h2 id="_idParaDest-266">Triggeri<a id="_idTextAnchor355"/>ng and Waiting for UI Updates with Cypress</h2>
			<p>The tests we've written up until now are quite simple and only check that the application isn't crashing on load in the browser.</p>
			<p>One of the strengths of E2E tests is testing with high fidelity that the UI behaves as expected when a user interacts with it. We'll use Cypress' selection (the <strong class="source-inline">.get()</strong> function), event triggering (the <strong class="source-inline">.click()</strong> function), and assertion (the <strong class="source-inline">.should()</strong> function) functionality to test a Vue.js application in this section. Cypress' automatic retries on DOM selection will allow us to write E2E tests without explicit wait/timeout conditions. Waits and timeouts are a staple of other E2E testing systems and tend to be a source of flakiness in tests.</p>
			<p>To begin with, we will add a comment editor to our <strong class="bold">Commentator Pro</strong> application. Displaying the editor (a simple <strong class="source-inline">textarea</strong>) will be toggled by clicking on the <strong class="source-inline">Add a New Comment</strong> button.</p>
			<p>In order to keep writing tests without wrangling complicated and brittle selectors, we'll start adding <strong class="source-inline">data-test-id</strong> attributes; to begin with, we can add one to the <strong class="source-inline">Add a New Comment</strong> button in the <strong class="source-inline">App.vue</strong> file:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app" class="p-10"&gt;</p>
			<p class="source-code">    &lt;div class="flex flex-col"&gt;</p>
			<p class="source-code">      &lt;!-- rest of template --&gt;</p>
			<p class="source-code">      &lt;button</p>
			<p class="source-code">        class="flex mx-auto bg-blue-500 hover:bg-blue-700           text-white font-bold py-2 px-4 rounded"</p>
			<p class="source-code">        data-test-id="new-comment-button"</p>
			<p class="source-code">      &gt;</p>
			<p class="source-code">        Add a New Comment</p>
			<p class="source-code">      &lt;/button&gt;</p>
			<p class="source-code">      &lt;!-- rest of template --&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>Next, we'll add a <strong class="source-inline">showEditor</strong> property to the Vue.js <strong class="source-inline">data()</strong> method on the <strong class="source-inline">App</strong> component. We'll use this expression in the <strong class="source-inline">v-if</strong> for the editor. We can also set the new comment button to toggle this instance property:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app" class="p-10"&gt;</p>
			<p class="source-code">    &lt;div class="flex flex-col"&gt;</p>
			<p class="source-code">      &lt;!-- rest of template --&gt;</p>
			<p class="source-code">     &lt;button</p>
			<p class="source-code">        @click="showEditor = !showEditor"</p>
			<p class="source-code">        class="flex mx-auto bg-blue-500 hover:bg-blue-700           text-white font-bold py-2 px-4 rounded"</p>
			<p class="source-code">        data-test-id="new-comment-button"</p>
			<p class="source-code">      &gt;</p>
			<p class="source-code">        Add a New Comment</p>
			<p class="source-code">      &lt;/button&gt;</p>
			<p class="source-code">      &lt;!-- rest of template --&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      showEditor: false</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>We can add our editor with the <strong class="source-inline">new-comment-editor</strong> <strong class="source-inline">data-test-id</strong> that is toggled by <strong class="source-inline">showEditor</strong>:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app" class="p-10"&gt;</p>
			<p class="source-code">    &lt;div class="flex flex-col"&gt;</p>
			<p class="source-code">      &lt;!-- rest of template --&gt;</p>
			<p class="source-code">      &lt;div v-if="showEditor"&gt;</p>
			<p class="source-code">        &lt;textarea</p>
			<p class="source-code">          data-test-id="new-comment-editor"</p>
			<p class="source-code">          class="flex mx-auto my-6 shadow appearance-none             border rounded py-2 px-3 text-gray-700 leading-tight             focus:outline-none focus:shadow-outline"</p>
			<p class="source-code">        &gt;</p>
			<p class="source-code">        &lt;/textarea&gt;</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>In order to test the toggling, we can add a test that opens that app and checks that the comment editor is not initially shown, as well as checking whether or not it shows depending on how many clicks are triggered on the <strong class="source-inline">new-comment-button</strong>:</p>
			<p class="source-code">describe('Adding a New Comment', () =&gt; {</p>
			<p class="source-code">  // other tests   it('the Add a New Comment button should toggle the editor     display on and off', () =&gt; {</p>
			<p class="source-code">    cy.visit('/')</p>
			<p class="source-code">    cy.get('[data-test-id="new-comment-editor"]').should       ('not.be.visible')</p>
			<p class="source-code">    cy.get('[data-test-id="new-comment-button"]').click()</p>
			<p class="source-code">    cy.get('[data-test-id="new-comment-editor"]').should       ('be.visible')</p>
			<p class="source-code">    cy.get('[data-test-id="new-comment-button"]').click()</p>
			<p class="source-code">    cy.get('[data-test-id="new-comment-editor"]').should       ('not.be.visible')</p>
			<p class="source-code">  })</p>
			<p class="source-code">})</p>
			<p>The preceding code will generate the following result:</p>
			<div>
				<div id="_idContainer372" class="IMG---Figure">
					<img src="image/B15218_13_09.jpg" alt="Figure 13.9: Cypress running &quot;add-new-comment&quot; tests, including &#13;&#10;the new editor-toggling test&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.9: Cypress running "add-new-comment" tests, including the new editor-toggling test</p>
			<p>We've now seen how to write Cypress tests that select and assert over DOM elements.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">data-test-id</strong> instances, as a convention, are a way to decouple tests from application and styling-specific selectors. This is especially useful if the people writing the tests aren't always the ones writing the code. In that situation, using <strong class="source-inline">data-test-id</strong> allows the markup structure and classes to change, but the tests will keep passing as long as the <strong class="source-inline">test-id</strong> instances remain on the correct element.</p>
			<h2 id="_idParaDest-267">Exercise <a id="_idTextAnchor356"/>13.02: Adding New Comment Editor Input and Submit Functionality</h2>
			<p>To be able to send the new comment text to an API, we will need to store the text in a Vue.js state. The other prerequisite to adding a comment is to have a dummy "<strong class="source-inline">submit</strong>" button. </p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/2HaWanh">https://packt.live/2HaWanh</a>.</p>
			<p>To add these features and their corresponding tests, perform the following steps: </p>
			<ol>
				<li value="1">To store the <strong class="source-inline">textarea</strong> (editor) content in-memory, we'll use <strong class="source-inline">v-model</strong>. We'll create a new data (state) variable, <strong class="source-inline">newComment</strong>, that gets initialized to <strong class="source-inline">""</strong>. Now, <strong class="source-inline">v-model</strong> will two-way bind the <strong class="source-inline">textarea</strong> content and <strong class="source-inline">newComment</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app" class="p-10"&gt;</p><p class="source-code">        &lt;!-- rest of template --&gt;</p><p class="source-code">        &lt;textarea</p><p class="source-code">          data-test-id="new-comment-editor"</p><p class="source-code">          class="flex mx-auto my-6 shadow appearance-none             border rounded py-2 px-3 text-gray-700 leading-tight             focus:outline-none focus:shadow-outline"</p><p class="source-code">          v-model="newComment"</p><p class="source-code">        &gt;</p><p class="source-code">        &lt;/textarea&gt;</p><p class="source-code">        &lt;!-- rest of template --&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      // other data properties</p><p class="source-code">      newComment: ''</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>We'll add a <strong class="source-inline">submit</strong> button inside the editor, which should only show when the editor is toggled on. We also make sure to include a <strong class="source-inline">data-test-id="new-comment-submit"</strong> attribute in order to be able to select it with Cypress later:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app" class="p-10"&gt;</p><p class="source-code">    &lt;!-- rest of template --&gt;</p><p class="source-code">      &lt;div v-if="showEditor"&gt;</p><p class="source-code">        &lt;!-- rest of template --&gt;</p><p class="source-code">        &lt;button</p><p class="source-code">          data-test-id="new-comment-submit"</p><p class="source-code">          class="flex mx-auto bg-blue-500 hover:bg-blue-700             text-white font-bold py-2 px-4 rounded"</p><p class="source-code">        &gt;</p><p class="source-code">        Submit</p><p class="source-code">        &lt;/button&gt;</p><p class="source-code">        &lt;!-- rest of template --&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;!-- rest of template --&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>It's now time to add an E2E test to test that <strong class="source-inline">new-comment-editor</strong> works as expected when we type text into it. In order to achieve this, we need to load up the application and click the <strong class="source-inline">new comment</strong> button so that the editor is displayed. We can then select <strong class="source-inline">new-comment-editor</strong> (by <strong class="source-inline">data-test-id</strong>) and use the Cypress <strong class="source-inline">.type</strong> function to add some text. We can chain <strong class="source-inline">.should('have.value', 'Just saying...')</strong> to validate that our interaction with <strong class="source-inline">textarea</strong> was successful:<p class="source-code">describe('Adding a New Comment', () =&gt; {</p><p class="source-code">  // other tests</p><p class="source-code">  it('the new comment editor should support text input',     () =&gt; {</p><p class="source-code">    cy.visit('/')</p><p class="source-code">    // Get the editor to show</p><p class="source-code">    cy.get('[data-test-id="new-comment-button"]').click()</p><p class="source-code">    cy.get('[data-test-id="new-comment-editor"]').should       ('be.visible')</p><p class="source-code">    cy.get('[data-test-id="new-comment-editor"]')</p><p class="source-code">      .type('Just saying...')</p><p class="source-code">      .should('have.value', 'Just saying...')</p><p class="source-code">  })</p><p class="source-code">})</p><p>When run using the Cypress UI, this <strong class="source-inline">add-new-comment</strong> test suite should yield the following result:</p><div id="_idContainer373" class="IMG---Figure"><img src="image/B15218_13_10.jpg" alt="Figure 13.10: Cypress running &quot;add-new-comment&quot; tests, including &#13;&#10;the new editor text input test&#13;&#10;"/></div><p class="figure-caption">Figure 13.10: Cypress running "add-new-comment" tests, including the new editor text input test</p></li>
				<li>Finally, we can add an <strong class="source-inline">E2E test</strong> to check that the <strong class="source-inline">submit</strong> button does not appear by default but does appear when we click the <strong class="source-inline">new comment</strong> button. We can also check the text content of the <strong class="source-inline">new-comment-submit</strong> button:<p class="source-code">describe('Adding a New Comment', () =&gt; {</p><p class="source-code">  // other tests</p><p class="source-code">  it('the new comment editor should have a submit button',     () =&gt; {</p><p class="source-code">    cy.visit('/')</p><p class="source-code">    cy.get('[data-test-id="new-comment-submit"]').should       ('not.be.visible')</p><p class="source-code">    // Get the editor to show</p><p class="source-code">    cy.get('[data-test-id="new-comment-button"]').click()</p><p class="source-code">    cy.get('[data-test-id="new-comment-submit"]').should       ('be.visible')</p><p class="source-code">    cy.contains('[data-test-id="new-comment-submit"]', 'Submit')</p><p class="source-code">  })</p><p class="source-code">})</p><p>When this test is run through the Cypress UI, we see the following result:</p><div id="_idContainer374" class="IMG---Figure"><img src="image/B15218_13_11.jpg" alt="Figure 13.11: Cypress running &quot;add-new-comment&quot; tests, including &#13;&#10;the new submit button test&#13;&#10;"/></div><p class="figure-caption">Figure 13.11: Cypress running "add-new-comment" tests, including the new submit button test</p></li>
				<li>One more feature we can add is to make the <strong class="source-inline">submit</strong> button disabled until there's text in the text editor. To do this, we can bind <strong class="source-inline">:disabled</strong> to <strong class="source-inline">!newComment</strong> on the <strong class="source-inline">new comment submit</strong> button. We'll make the button look disabled using reduced opacity. As an aside, one of the big reasons we added a two-way binding between <strong class="source-inline">newComment</strong> and <strong class="source-inline">textarea</strong> is to enable UI validations like this one:<p class="source-code">&lt;template&gt;</p><p class="source-code">        &lt;!-- rest of template --&gt;</p><p class="source-code">        &lt;button</p><p class="source-code">          data-test-id="new-comment-submit"</p><p class="source-code">          class="flex mx-auto bg-blue-500 hover:bg-blue-700             text-white font-bold py-2 px-4 rounded"</p><p class="source-code">          :disabled="!newComment"</p><p class="source-code">          :class="{ 'opacity-50 cursor-not-allowed' : !newComment }"</p><p class="source-code">        &gt;</p><p class="source-code">        Submit</p><p class="source-code">        &lt;/button&gt;</p><p class="source-code">        &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>The relevant test will look at whether or not the <strong class="source-inline">new-comment-submit</strong> button is disabled when the text editor content is empty using Cypress' <strong class="source-inline">should('be.disabled')</strong> and <strong class="source-inline">should('not.be.disabled')</strong> assertions:<p class="source-code">describe('Adding a New Comment', () =&gt; {</p><p class="source-code">  // other tests</p><p class="source-code">  it('the new comment submit button should be disabled based     on "new comment" content', () =&gt; {</p><p class="source-code">    cy.visit('/')</p><p class="source-code">    // Get the editor to show</p><p class="source-code">    cy.get('[data-test-id="new-comment-button"]').click()</p><p class="source-code">    cy.get('[data-test-id="new-comment-submit"]').should       ('be.visible')</p><p class="source-code">    cy.get('[data-test-id="new-comment-submit"]')</p><p class="source-code">      .should('be.disabled')</p><p class="source-code">    cy.get('[data-test-id="new-comment-editor"]')</p><p class="source-code">      .type('Just saying...')</p><p class="source-code">    cy.get('[data-test-id="new-comment-submit"]')</p><p class="source-code">      .should('not.be.disabled')</p><p class="source-code">  })</p><p class="source-code">})</p><p>This yields the following output when run through Cypress UI and Chrome automation:</p><div id="_idContainer375" class="IMG---Figure"><img src="image/B15218_13_12.jpg" alt="Figure 13.12: Cypress running &quot;add-new-comment&quot; tests, including &#13;&#10;the new comment submit button disabled test&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.12: Cypress running "add-new-comment" tests, including the new comment submit button disabled test</p>
			<p>We've now seen how to use Cypress to select, click, and input text. We've also seen approaches to check element visibility, text content, input values, and disabled states.</p>
			<p>Anyone familiar with other automation frameworks will have noticed that in Cypress tests, there are no explicit waits or retries. This is because Cypress waits and retries assertions and selections automatically. Most of the tests we've written don't showcase this in a major way, but the next exercise, where we bring asynchronicity into the mix, will.</p>
			<h2 id="_idParaDest-268">Exercise 13.<a id="_idTextAnchor357"/>03: Adding a Submitting State to the New Comment Editor</h2>
			<p>In order to showcase Cypress's impressive automatic retry/wait capability, we will look at adding and testing a <strong class="source-inline">submitting</strong> state for the new comment editor.</p>
			<p>In effect, we'll be reacting to a click on the <strong class="source-inline">submit</strong> button and showing a spinner for <strong class="source-inline">2.5s</strong> to simulate a reasonably slow HTTP request to a backend API. This is an example that showcases Cypress' ability to automatically wait and retry selections. This feature reduces the need for arbitrary waits and that flakiness associated with them.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/2UzsYJU">https://packt.live/2UzsYJU</a>:</p>
			<ol>
				<li value="1">In order to show the spinner, we add the <strong class="source-inline">tailwindcss-spinner</strong> package to the project:<p class="source-code">npm install --save-dev tailwindcss-spinner</p><p class="source-code"># or </p><p class="source-code">yarn add -D tailwindcss-spinner</p></li>
				<li>We will need to configure it in the Tailwind config file (<strong class="source-inline">tailwind.js</strong>). It needs to be imported using <strong class="source-inline">require('tailwindcss-spinner')</strong>, added as a plugin, and the relevant variables need to be set in <strong class="source-inline">theme</strong>. Our spinner will be <strong class="source-inline">gray</strong> in color, use a Tailwind spacing of size <strong class="source-inline">4</strong>, and have a border width of <strong class="source-inline">2px</strong> and a duration of <strong class="source-inline">500ms</strong>:<p class="source-code">module.exports = {</p><p class="source-code">  theme: {</p><p class="source-code">    extend: {},</p><p class="source-code">    spinner: (theme) =&gt; ({</p><p class="source-code">      default: {</p><p class="source-code">        color: theme('colors.gray.400'), </p><p class="source-code">        size: theme('spacing.4'),</p><p class="source-code">        border: theme('borderWidth.2'),</p><p class="source-code">        speed: theme('transitionDuration.500'),</p><p class="source-code">      },</p><p class="source-code">    }),</p><p class="source-code">  },</p><p class="source-code">  variants: {</p><p class="source-code">    spinner: ['responsive'],</p><p class="source-code">  },</p><p class="source-code">  plugins: [require('tailwindcss-spinner')()],</p><p class="source-code">}</p></li>
				<li>Next, we need to add an <strong class="source-inline">isSubmitting</strong> state to the Vue.js application in <strong class="source-inline">data()</strong>, which will allow us to toggle the state for the <strong class="source-inline">submit</strong> button. We will initialize it to <strong class="source-inline">false</strong> since we are not submitting anything until the user clicks the <strong class="source-inline">submit</strong> button:<p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      // other properties</p><p class="source-code"><strong class="bold">      isSubmitting: false</strong></p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Next, we will add a click handler for the <strong class="source-inline">submit</strong> button (as <strong class="source-inline">methods.submitNewComment</strong>). It will simulate a <strong class="source-inline">2.5s</strong> load time using <strong class="source-inline">setTimeout</strong>:<p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  // other component properties</p><p class="source-code">  methods: {</p><p class="source-code">   submitNewComment() {</p><p class="source-code">      this.isSubmitting = true</p><p class="source-code">      setTimeout(() =&gt; {</p><p class="source-code">        this.isSubmitting = false</p><p class="source-code">      }, 2500)</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Now that we've got a <strong class="source-inline">fake submit</strong> handler, we should bind it to click events on the <strong class="source-inline">new-comment-submit</strong> button:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app" class="p-10"&gt;</p><p class="source-code">    &lt;div class="flex flex-col"&gt;</p><p class="source-code">      &lt;!-- rest of template --&gt;</p><p class="source-code">      &lt;div v-if="showEditor"&gt;</p><p class="source-code">        &lt;!-- rest of editor --&gt;</p><p class="source-code">        &lt;button</p><p class="source-code">          data-test-id="new-comment-submit"</p><p class="source-code">          class="flex mx-auto bg-blue-500 hover:bg-blue-700 text-</p><p class="source-code">            white font-bold py-2 px-4 rounded"</p><p class="source-code">          :disabled="!newComment"</p><p class="source-code">          :class="{ 'opacity-50 cursor-not-allowed' : !newComment </p><p class="source-code">            }"</p><p class="source-code">          @click="submitNewComment()"</p><p class="source-code">        &gt;</p><p class="source-code">        Submit</p><p class="source-code">        &lt;/button&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>Now comes the part where we need to react to the submit button. We'll be showing the spinner when <strong class="source-inline">isSubmitting</strong> is true. In order to do this, we simply need to set the <strong class="source-inline">spinner</strong> class to be added when <strong class="source-inline">isSubmitting</strong> is true. In addition to this, we'll set the button to be disabled when <strong class="source-inline">isSubmitting</strong> is true:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app" class="p-10"&gt;</p><p class="source-code">    &lt;div class="flex flex-col"&gt;</p><p class="source-code">      &lt;!-- rest of template --&gt;</p><p class="source-code">      &lt;div v-if="showEditor"&gt;</p><p class="source-code">        &lt;!-- rest of editor --&gt;</p><p class="source-code">        &lt;button</p><p class="source-code">          data-test-id="new-comment-submit"</p><p class="source-code">          class="flex mx-auto bg-blue-500 hover:bg-blue-700             text-white font-bold py-2 px-4 rounded"</p><p class="source-code">          :disabled="!newComment || isSubmitting"</p><p class="source-code">          :class="{</p><p class="source-code">            'opacity-50 cursor-not-allowed' : !newComment,</p><p class="source-code">            spinner: isSubmitting</p><p class="source-code">          }"</p><p class="source-code">          @click="submitNewComment()"</p><p class="source-code">        &gt;</p><p class="source-code">        Submit</p><p class="source-code">        &lt;/button&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>Finally, we can add a test to check that the loading spinner appears when the <strong class="source-inline">submit</strong> button is clicked. To begin with, we'll need to set up the text editor so that when clicking the <strong class="source-inline">add new comment</strong> button and setting a text value for the comment, the text editor is shown and enabled. Next, we can click the enabled <strong class="source-inline">new-comment-submit</strong> button and check that it is disabled and has the <strong class="source-inline">spinner</strong> class (using the <strong class="source-inline">should()</strong> function). After that, we should write another assertion that the button is not disabled anymore and does not show the spinner:<p class="source-code">it('the new comment editor should show a spinner on submit',   () =&gt; {</p><p class="source-code">    cy.visit('/')</p><p class="source-code">    // Get the editor to show</p><p class="source-code">    cy.get('[data-test-id="new-comment-button"]').click()</p><p class="source-code">    cy.get('[data-test-id="new-comment-submit"]').should       ('be.visible')</p><p class="source-code">    cy.get('[data-test-id="new-comment-editor"]')</p><p class="source-code">      .type('Just saying...')</p><p class="source-code">    cy.get('[data-test-id="new-comment-submit"]')</p><p class="source-code">      .should('not.be.disabled')</p><p class="source-code">      .click()</p><p class="source-code">      .should('have.class', 'spinner')</p><p class="source-code">      .should('be.disabled')</p><p class="source-code">    // eventually, the spinner should stop showing</p><p class="source-code">    cy.get('[data-test-id="new-comment-submit"]')</p><p class="source-code">      .should('not.have.class', 'spinner')</p><p class="source-code">      .should('not.be.disabled')</p><p class="source-code">  })</p><p>Despite the <strong class="source-inline">2.5s</strong> during which the spinner shows, this test still passes due to Cypress' automatic retry/wait functionality:</p><div id="_idContainer376" class="IMG---Figure"><img src="image/B15218_13_13.jpg" alt="Figure 13.13: Cypress running &quot;add-new-comment&quot; tests, including the comment submission loading state test&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.13: Cypress running "add-new-comment" tests, including the comment submission loading state test</p>
			<p>We've now seen how Cypress allows us to seamlessly work around asynchronicity in the application by automatically waiting/retrying where an assertion or selection would fail.</p>
			<h2 id="_idParaDest-269">Intercepting <a id="_idTextAnchor358"/>HTTP Requests</h2>
			<p>As mentioned in previous sections, Cypress is designed as a JavaScript E2E testing solution. This means that it comes with built-ins such as assertions, automatic wait/retries, sane defaults for running the application, and extensive mocking functionality.</p>
			<p>HTTP requests can be slow and tend to introduce flaky behavior to tests. What's meant by flaky is intermittent false negatives, that is, failures that are not caused by an application issue but rather by connectivity issues (for example, between the server running the tests and the backend hosts).</p>
			<p>We would also be testing the implementation of the backend system. When using <strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>), this would mean having to run the backend systems in whichever CI pipeline step needs to run E2E tests.</p>
			<p>Usually, when the backend requests are intercepted and a mock response is sent, we also say that the HTTP requests are <strong class="bold">stubbed</strong>, in order to avoid tests flaking (meaning intermittent failures not linked to application changes).</p>
			<p>Seeing that the requests do not go all the way through the stack (including the backend API), this is technically not a full E2E test of the system anymore. We can, however, consider it an E2E test of the frontend application since the whole application is made up of separate exercises and is not implementation-specific.</p>
			<p>In order to mock requests in Cypress, we'll need to use <strong class="source-inline">cy.server()</strong> and <strong class="source-inline">cy.route()</strong>. The Cypress documentation also lets us know that in order to use the HTTP interception functionality, we currently need a client that uses <strong class="source-inline">XMLHttpRequest</strong> (and not the <strong class="source-inline">fetch</strong> API).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There is work underway to support HTTP-level interception (which means <strong class="source-inline">fetch</strong>, <strong class="bold">XHR</strong>, and more will be supported eventually).</p>
			<p>We'll use the <strong class="source-inline">unfetch</strong> library, which implements the <strong class="source-inline">fetch</strong> interface on top of <strong class="source-inline">XMLHttpRequest</strong>. We can install it using the following command:</p>
			<p class="source-code">npm install --save-dev unfetch</p>
			<p class="source-code"># or</p>
			<p class="source-code">yarn add -D unfetch</p>
			<p>We can then import it into <strong class="source-inline">src/App.vue</strong> as follows.</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import fetch from 'unfetch'</p>
			<p class="source-code">// rest of component</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>To showcase HTTP interception, we'll fetch a list of comments from <strong class="source-inline">JSONPlaceholder</strong> and store them under a <strong class="source-inline">comments</strong> reactive instance variable. We can use <strong class="source-inline">fetch</strong> (the name under which we imported <strong class="source-inline">unfetch</strong>) to do this in the <strong class="source-inline">mounted()</strong> life cycle event as follows:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">// imports</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      // other data properties</p>
			<p class="source-code">      comments: []</p>
			<p class="source-code">    }</p>
			<p class="source-code">  },</p>
			<p class="source-code">  mounted() {</p>
			<p class="source-code">    fetch('https://jsonplaceholder.typicode.com/comments')</p>
			<p class="source-code">      .then(res =&gt; res.json())</p>
			<p class="source-code">      .then(comments =&gt; {</p>
			<p class="source-code">        this.comments = comments</p>
			<p class="source-code">      })</p>
			<p class="source-code">  }</p>
			<p class="source-code">  // other component properties</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>A sample comment includes an ID, a body, and an email, among other properties.</p>
			<p>That means we can render the comments by creating a <strong class="source-inline">ul</strong> container, which only shows if there are comments (<strong class="source-inline">comments.length &gt; 0)</strong>. Inside the <strong class="source-inline">ul</strong> container, we can render a list of <strong class="source-inline">li</strong> elements with a card layout using <strong class="source-inline">v-for</strong>. Each card will render the body of the comment and the author's email inside a <strong class="source-inline">mailto:</strong> link.</p>
			<p>Note how we set <strong class="source-inline">comments-list</strong> and <strong class="source-inline">comment-card</strong> <strong class="source-inline">data-test-ids</strong> for the list container and the list items respectively:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app" class="p-10"&gt;</p>
			<p class="source-code">    &lt;div class="flex flex-col"&gt;</p>
			<p class="source-code">      &lt;!-- rest of template --&gt;</p>
			<p class="source-code">      &lt;ul</p>
			<p class="source-code">        v-if="comments.length &gt; 0"</p>
			<p class="source-code">        class="flex flex-col items-center my-4 mx-auto           md:w-2/3 lg:w-1/2"</p>
			<p class="source-code">        data-test-id="comments-list"</p>
			<p class="source-code">      &gt;</p>
			<p class="source-code">        &lt;li</p>
			<p class="source-code">          class="flex flex-col px-6 py-4 rounded overflow-hidden             shadow-lg mb-6"</p>
			<p class="source-code">          v-for="(comment, index) in comments"</p>
			<p class="source-code">          :key="comment.id + index"</p>
			<p class="source-code">          data-test-id="comment-card"</p>
			<p class="source-code">        &gt;</p>
			<p class="source-code">          &lt;p class="flex text-gray-700 text-lg mb-4"&gt;            {{ comment.body }}&lt;/p&gt;</p>
			<p class="source-code">          &lt;p class="flex text-gray-600 font-semibold text-sm"&gt;</p>
			<p class="source-code">            &lt;a :href="'mailto:' + comment.email"&gt;              {{ comment.email }}&lt;/a&gt;</p>
			<p class="source-code">          &lt;/p&gt;</p>
			<p class="source-code">        &lt;/li&gt;</p>
			<p class="source-code">      &lt;/ul&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>If we were to test this without HTTP interception, we would have to keep the assertions quite generic. For example, we can check that <strong class="source-inline">comments-list</strong> is visible and that there is a number (greater than 0) of <strong class="source-inline">comment-card</strong> instances in a new E2E test file:</p>
			<p class="source-code">describe('Loading Existing Comments', () =&gt; {</p>
			<p class="source-code">  it('should load &amp; display comments', () =&gt; {</p>
			<p class="source-code">    cy.visit('/')</p>
			<p class="source-code">    cy.get('[data-test-id="comments-list"]')</p>
			<p class="source-code">      .should('be.visible')</p>
			<p class="source-code">    cy.get('[data-test-id="comment-card"]')</p>
			<p class="source-code">      .should('have.length.gt', 0)</p>
			<p class="source-code">  })</p>
			<p class="source-code">})</p>
			<p>The following test run using the Cypress GUI passes but the tests are quite generic. We can't make any assertions about the specific number of comments or their content:</p>
			<div>
				<div id="_idContainer377" class="IMG---Figure">
					<img src="image/B15218_13_14.jpg" alt="Figure 13.14: Cypress running &quot;load-comments&quot; tests, including &#13;&#10;a generic load and display test&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.14: Cypress running "load-comments" tests, including a generic load and display test</p>
			<p>To intercept the request, we have to initialize the Cypress mock server with <strong class="source-inline">cy.server()</strong>. We can then intercept specific requests using <strong class="source-inline">cy.route()</strong>, which yields the following new test. <strong class="source-inline">cy.route</strong>, when used with two parameters, takes the URL followed by the stub response, in our case an array of comments. We'll use a fictitious email address in our stubs:</p>
			<p class="source-code">describe('Loading Existing Comments', () =&gt; {</p>
			<p class="source-code">  // other tests</p>
			<p class="source-code">  it('should load and display comments correctly', () =&gt; {</p>
			<p class="source-code">    cy.server()</p>
			<p class="source-code">    cy.route('**/comments', [</p>
			<p class="source-code">      {</p>
			<p class="source-code">        body: 'Vue is getting great adoption',</p>
			<p class="source-code">        email: 'evan@vuejs.org',</p>
			<p class="source-code">        id: 100,</p>
			<p class="source-code">      },</p>
			<p class="source-code">      {</p>
			<p class="source-code">        body: 'Just saying...',</p>
			<p class="source-code">        email: 'evan@vuejs.org',</p>
			<p class="source-code">        id: 10</p>
			<p class="source-code">      },</p>
			<p class="source-code">      {</p>
			<p class="source-code">        body: 'The JS ecosystem is great',</p>
			<p class="source-code">        email: 'evan@vuejs.org',</p>
			<p class="source-code">        id: 1</p>
			<p class="source-code">      }</p>
			<p class="source-code">    ]).as('getComments')</p>
			<p class="source-code">  })</p>
			<p class="source-code">})</p>
			<p>Once we've got our stub route set up, we can visit the page and wait for the comment fetching to finish using <strong class="source-inline">cy.wait('@getComments')</strong>, since we've previously set the alias of the comments fetch route to <strong class="source-inline">getComments</strong> with <strong class="source-inline">.as('getComments')</strong>:</p>
			<p class="source-code">describe('Loading Existing Comments', () =&gt; {</p>
			<p class="source-code">  // other tests</p>
			<p class="source-code">  it('should load and display comments correctly', () =&gt; {</p>
			<p class="source-code">    // test setup</p>
			<p class="source-code">    cy.visit('/')</p>
			<p class="source-code">    cy.wait('@getComments')</p>
			<p class="source-code">  })</p>
			<p class="source-code">})</p>
			<p>We can then start asserting, first off, that <strong class="source-inline">comments-list</strong> is visible, and then assert on the number of <strong class="source-inline">comment-card</strong> cards:</p>
			<p class="source-code">describe('Loading Existing Comments', () =&gt; {</p>
			<p class="source-code">  // other tests</p>
			<p class="source-code">  it('should load and display comments correctly', () =&gt; {</p>
			<p class="source-code">    // test setup</p>
			<p class="source-code">    cy.get('[data-test-id="comments-list"]')</p>
			<p class="source-code">      .should('be.visible')</p>
			<p class="source-code">    cy.get('[data-test-id="comment-card"]')</p>
			<p class="source-code">      .should('have.length', 3)</p>
			<p class="source-code">  })</p>
			<p class="source-code">})</p>
			<p>We can also assert on the specific contents of the cards using the <strong class="source-inline">.contains()</strong> function:</p>
			<p class="source-code">describe('Loading Existing Comments', () =&gt; {</p>
			<p class="source-code">  // other tests</p>
			<p class="source-code">  it('should load and display comments correctly', () =&gt; {</p>
			<p class="source-code">    // test setup</p>
			<p class="source-code">    cy.contains('[data-test-id="comment-card"]', 'Vue is       getting great adoption')</p>
			<p class="source-code">      .contains('evan@vuejs.org')</p>
			<p class="source-code">    cy.contains('[data-test-id="comment-card"]', 'Just saying...')</p>
			<p class="source-code">      .contains('evan@vuejs.org')</p>
			<p class="source-code">    cy.contains('[data-test-id="comment-card"]', 'The JS       ecosystem is great')</p>
			<p class="source-code">      .contains('evan@vuejs.org')</p>
			<p class="source-code">  })</p>
			<p class="source-code">})</p>
			<p>We can then run the suite with the Cypress GUI and see it passing:</p>
			<div>
				<div id="_idContainer378" class="IMG---Figure">
					<img src="image/B15218_13_15.jpg" alt="Figure 13.15: Cypress running &quot;load-comments&quot; tests, including our stubbed comments test&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.15: Cypress running "load-comments" tests, including our stubbed comments test</p>
			<p>We've now seen how and why we might stub HTTP requests using Cypress.</p>
			<h2 id="_idParaDest-270">Exercise 13.04:<a id="_idTextAnchor359"/> POST Comment to API on Submission</h2>
			<p>The <strong class="source-inline">new comment</strong> submit button currently only sets a loading state for a few seconds and then resets – the comment is not actually being sent anywhere.</p>
			<p>Let's use the <strong class="source-inline">JSONPlaceholder</strong> API as the place to send our new comment.</p>
			<p>When the POST request to the API succeeds, we'll add the comment to the top of the comments list.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/2IIWY3g">https://packt.live/2IIWY3g</a>.</p>
			<p>To complete the exercise, we will perform the following steps:</p>
			<ol>
				<li value="1">Start by making the <strong class="source-inline">submitNewComment</strong> method actually post data to <strong class="source-inline">c</strong> using <strong class="source-inline">fetch</strong> (which is actually <strong class="source-inline">unfetch</strong>):<p class="source-code">&lt;script&gt;</p><p class="source-code">// imports</p><p class="source-code">export default {</p><p class="source-code">  // other component properties</p><p class="source-code">  methods: {</p><p class="source-code">    submitNewComment() {</p><p class="source-code">      this.isSubmitting = true</p><p class="source-code">      fetch('https://jsonplaceholder.typicode.com/comments', {</p><p class="source-code">        method: 'POST',</p><p class="source-code">        headers: {</p><p class="source-code">          'Content-Type': 'application/json'</p><p class="source-code">        },</p><p class="source-code">        body: JSON.stringify({</p><p class="source-code">          email: this.email,</p><p class="source-code">          body: this.newComment</p><p class="source-code">        })</p><p class="source-code">      })</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>Unfortunately, the <strong class="source-inline">fetch()</strong> call by itself doesn't update the data or come out of the loading state. In order to do so, we need to chain some <strong class="source-inline">.then()</strong> function calls to handle the response, and a <strong class="source-inline">.catch</strong> function call in case we have an error. On success (<strong class="source-inline">.then</strong>), we should get the JSON output of the request and add it to the front of a copy of the <strong class="source-inline">comments</strong> array. We should also reset <strong class="source-inline">isSubmitting</strong>, <strong class="source-inline">newComment</strong>, and <strong class="source-inline">showEditor</strong>. On error (<strong class="source-inline">.catch</strong>), we will just reset the loading state, <strong class="source-inline">isSubmitting</strong>, to false; we won't clear the editor or close it since the user might want to try to submit it again:</p><p class="source-code">&lt;script&gt;</p><p class="source-code">// imports</p><p class="source-code">export default {</p><p class="source-code">  // other component properties</p><p class="source-code">  methods: {</p><p class="source-code">    submitNewComment() {</p><p class="source-code">      this.isSubmitting = true</p><p class="source-code">      fetch(</p><p class="source-code">        // fetch params</p><p class="source-code">      ).then(res =&gt; res.json())</p><p class="source-code">      .then(data =&gt; {</p><p class="source-code">        this.comments = [</p><p class="source-code">          data,</p><p class="source-code">          ...this.comments,</p><p class="source-code">        ]</p><p class="source-code">        this.isSubmitting = false</p><p class="source-code">        this.newComment = ''</p><p class="source-code">        this.showEditor = false</p><p class="source-code">      }).catch(() =&gt; {</p><p class="source-code">        this.isSubmitting = false</p><p class="source-code">      })</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>We should now add new tests to the <strong class="source-inline">tests/e2e/specs/add-new-comment.js</strong> test suite.</p></li>
				<li>First of all, to be good users of <strong class="source-inline">JSONPlaceholder</strong>, we'll stub out all the <strong class="source-inline">GET</strong> requests to <strong class="source-inline">/comments</strong> for the <strong class="source-inline">add-new-comment</strong> suite. In order to achieve this, we'll use a <strong class="source-inline">beforeEach</strong> hook that will start the Cypress stub server (<strong class="source-inline">cy.server()</strong>) and stub out <strong class="source-inline">GET</strong> requests to any URL matching the <strong class="source-inline">**/comments</strong> glob with the <strong class="source-inline">[]</strong> response (<strong class="source-inline">cy.route('GET', '**/comments', [])</strong>):<p class="source-code">describe('Adding a New Comment', () =&gt; {</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    cy.server()</p><p class="source-code">    // GET comments is not the concern of this test suite</p><p class="source-code">    cy.route('GET', '**/comments', [])</p><p class="source-code">  })</p><p class="source-code">  // tests</p></li>
				<li>We can then proceed to update the <strong class="source-inline">the new comment editor should show a spinner on submit</strong> test since we're not using a <strong class="source-inline">setTimeout</strong> anymore but an HTTP request. To start with, we need to stub out the <strong class="source-inline">/comments</strong> POST request, for which we'll use the configuration object syntax for <strong class="source-inline">cy.route</strong> in order to introduce some delay in the HTTP request so that it doesn't respond immediately. We alias this request with <strong class="source-inline">.as('newComment')</strong>:<p class="source-code">describe('Adding a New Comment', () =&gt; {</p><p class="source-code">  // setup &amp; tests</p><p class="source-code">  it('the new comment editor should show a spinner on submit',     () =&gt; {</p><p class="source-code">    cy.route({</p><p class="source-code">      method: 'POST',</p><p class="source-code">      url: '**/comments',</p><p class="source-code">      delay: 1500,</p><p class="source-code">      response: {}</p><p class="source-code">    }).as('newComment')</p><p class="source-code">    // rest of the test</p><p class="source-code">  })</p><p class="source-code">})</p></li>
				<li>Instead of <strong class="source-inline">// eventually, the spinner should stop showing</strong>, we can now use <strong class="source-inline">cy.wait()</strong> to wait for the <strong class="source-inline">newComment</strong> HTTP request to complete before the check that the spinner is gone:<p class="source-code">describe('Adding a New Comment', () =&gt; {</p><p class="source-code">  // setup &amp; tests</p><p class="source-code">  it('the new comment editor should show a spinner on submit',     () =&gt; {</p><p class="source-code">    // test setup</p><p class="source-code">    // click the "submit" button</p><p class="source-code">    // check the spinner appears</p><p class="source-code">    cy.wait('@newComment')</p><p class="source-code">    // check that the spinner is gone</p><p class="source-code">  })</p><p class="source-code">})</p></li>
				<li>We've added new functionality to close the editor when the <strong class="source-inline">submit</strong> operation completes successfully, so we should add the relevant test. We'll use a similar skeleton to the updated <strong class="source-inline">loading state</strong> test with the setup of the POST comments route stubbing <strong class="source-inline">cy.route('POST', '**/comments', {}</strong>, aliased as <strong class="source-inline">.as('newComment')</strong>. We can then get the new comment editor to display, add some text, and submit the form. We'll then proceed to wait for the <strong class="source-inline">POST</strong> request to complete before checking that the editor and submit button are not visible anymore:<p class="source-code">describe('Adding a New Comment', () =&gt; {</p><p class="source-code">  // other tests</p><p class="source-code">  it('adding a new comment should close the editor', () =&gt; {</p><p class="source-code">    cy.route(</p><p class="source-code">      'POST',</p><p class="source-code">      '**/comments',</p><p class="source-code">      { body: 'Just saying...', email: 'hi@vuejs.org' }</p><p class="source-code">    ).as('newComment')</p><p class="source-code">    cy.visit('/')</p><p class="source-code">    // Get the editor to show</p><p class="source-code">    cy.get('[data-test-id="new-comment-button"]').click()</p><p class="source-code">    cy.get('[data-test-id="new-comment-submit"]').should       ('be.visible')</p><p class="source-code">    cy.get('[data-test-id="new-comment-editor"]')</p><p class="source-code">      .type('Just saying...')</p><p class="source-code">    cy.get('[data-test-id="new-comment-submit"]')</p><p class="source-code">      .should('not.be.disabled')</p><p class="source-code">      .click()</p><p class="source-code">    cy.wait('@newComment')</p><p class="source-code">    cy.get('[data-test-id="new-comment-editor"]').should       ('not.be.visible')</p><p class="source-code">    cy.get('[data-test-id="new-comment-submit"]').should       ('not.be.visible')</p><p class="source-code">  })</p><p class="source-code">})</p><p>This test can now be run with the Cypress GUI and will pass:</p><div id="_idContainer379" class="IMG---Figure"><img src="image/B15218_13_16.jpg" alt="Figure 13.16: Cypress running &quot;add-new-comment&quot; tests, including &#13;&#10;the editor closing on submission test&#13;&#10;"/></div><p class="figure-caption">Figure 13.16: Cypress running "add-new-comment" tests, including the editor closing on submission test</p></li>
				<li>The second bit of functionality that we've added is that on completion of the HTTP request the new case is added to the front of the comments list. To test this, it's better to change the response of the comments' <strong class="source-inline">GET</strong> request to have at least one element (so that we can check that the new comment is added to the top of the list):<p class="source-code">describe('Adding a New Comment', () =&gt; {</p><p class="source-code">  // setup &amp; other tests</p><p class="source-code">  it('submitting a new comment should POST to /comments and     adds response to top of comments list', () =&gt; {</p><p class="source-code">    cy.route('GET', '**/comments', [</p><p class="source-code">      {</p><p class="source-code">        email: 'evan@vuejs.org',</p><p class="source-code">        body: 'Existing comment'</p><p class="source-code">      }</p><p class="source-code">    ])</p><p class="source-code">  })</p><p class="source-code">})</p></li>
				<li>We can then stub the <strong class="source-inline">POST</strong> request with some mock data, add text to the editor, and submit the form:<p class="source-code">describe('Adding a New Comment', () =&gt; {</p><p class="source-code">  // setup &amp; other tests</p><p class="source-code">  it('submitting a new comment should POST to /comments and     adds response to top of comments list', () =&gt; {</p><p class="source-code">    // GET request stubbing</p><p class="source-code">    cy.route({</p><p class="source-code">      method: 'POST',</p><p class="source-code">      url: '**/comments',</p><p class="source-code">      response: {</p><p class="source-code">        email: 'evan@vuejs.org',</p><p class="source-code">        body: 'Just saying...',</p><p class="source-code">      },</p><p class="source-code">    }).as('newComment')</p><p class="source-code">    cy.visit('/')</p><p class="source-code">    cy.get('[data-test-id="comment-card"]').should       ('have.length', 1)</p><p class="source-code">    cy.get('[data-test-id="new-comment-button"]').click()</p><p class="source-code">    cy.get('[data-test-id="new-comment-editor"]')</p><p class="source-code">      .type('Just saying...')</p><p class="source-code">    cy.get('[data-test-id="new-comment-submit"]')</p><p class="source-code">      .should('not.be.disabled')</p><p class="source-code">      .click()</p><p class="source-code">    cy.wait('@newComment')</p><p class="source-code">  })</p><p class="source-code">})</p></li>
				<li>Finally, we can assert on the fact that the first comment is the newly added comment using a combination of <strong class="source-inline">cy.get()</strong>, <strong class="source-inline">.first()</strong>, and <strong class="source-inline">.contains()</strong>:<p class="source-code">describe('Adding a New Comment', () =&gt; {</p><p class="source-code">  // setup &amp; other tests</p><p class="source-code">  it('submitting a new comment should POST to /comments and     adds response to top of comments list', () =&gt; {</p><p class="source-code">    // setup &amp; wait for POST completion</p><p class="source-code">    cy.get('[data-test-id="comments-list"]').should('be.visible')</p><p class="source-code">    cy.get('[data-test-id="comment-card"]')</p><p class="source-code">      .should('have.length', 2)</p><p class="source-code">      .first()</p><p class="source-code">      .contains('[data-test-id="comment-card"]', 'Just saying...')</p><p class="source-code">      .contains('evan@vuejs.org')</p><p class="source-code">  })</p><p class="source-code">})</p><p>When running the <strong class="source-inline">add-new-comment</strong> suite with the Cypress GUI, we can see the new test passing:</p><div id="_idContainer380" class="IMG---Figure"><img src="image/B15218_13_17.jpg" alt="Figure 13.17: Cypress running &quot;add-new-comment&quot; tests, including &#13;&#10;the new comment added to the top of the list test&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.17: Cypress running "add-new-comment" tests, including the new comment added to the top of the list test</p>
			<p>We've now seen how to use Cypress to intercept HTTP requests, so in the next section, we'll look at some of the reporting tools Cypress provides around visual regression (snapshot) testing.</p>
			<h2 id="_idParaDest-271">Visual Regression<a id="_idTextAnchor360"/> Testing with Cypress Snapshots</h2>
			<p>The types of tests we've written with Cypress up to now have been functional tests, for the most part.</p>
			<p>Functional tests check that the application <em class="italic">behaves</em> as expected. Visual tests check that the application <em class="italic">looks</em> as expected.</p>
			<p>There are ways to inspect the rendered CSS, but that approach tends to be quite tedious and prone to breakage when the markup or styling is refactored (that is, the same visual output but with different rules or markup).</p>
			<p>Fortunately, Cypress, with the <strong class="source-inline">cypress-plugin-snapshots</strong> plugin, allows us to take and compare snapshots of an application. First, it needs to be installed using the following command:</p>
			<p class="source-code">npm install --save-dev cypress-plugin-snapshots</p>
			<p class="source-code"># or </p>
			<p class="source-code">yarn add -D cypress-plugin-snapshots</p>
			<p>The plugin adds the <strong class="source-inline">.toMatchImageSnapshot</strong> method on Cypress selections. For it to work, we need to register it in the plugin's initialization file.</p>
			<p>We should import <strong class="source-inline">cypress-plugin-snapshots/plugin</strong> and run its export <strong class="source-inline">initPlugin</strong> with the plugin initialization data:</p>
			<p class="source-code">const { initPlugin } = require('cypress-plugin-snapshots/plugin');</p>
			<p class="source-code">module.exports = (on, config) =&gt; {</p>
			<p class="source-code">  initPlugin(on, config);</p>
			<p class="source-code">  // rest of plugin config, including return</p>
			<p class="source-code">}</p>
			<p>We also need to register the relevant command from <strong class="source-inline">cypress-plugin-snapshots/commands</strong>, which can be done in the <strong class="source-inline">commands.js</strong> file:</p>
			<p class="source-code">import 'cypress-plugin-snapshots/commands'</p>
			<p>We'll also need to add some config for <strong class="source-inline">cypress-plugin-snapshots</strong> to <strong class="source-inline">cypress.json</strong>:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "//": "other config",</p>
			<p class="source-code">  "env": {</p>
			<p class="source-code">    "cypress-plugin-snapshots": {</p>
			<p class="source-code">      "autoCleanUp": false,</p>
			<p class="source-code">      "autopassNewSnapshots": true,</p>
			<p class="source-code">      "diffLines": 3,</p>
			<p class="source-code">      "imageConfig": {</p>
			<p class="source-code">        "createDiffImage": true,</p>
			<p class="source-code">        "resizeDevicePixelRatio": true,</p>
			<p class="source-code">        "threshold": 0.01,</p>
			<p class="source-code">        "thresholdType": "percent"</p>
			<p class="source-code">      },</p>
			<p class="source-code">      "screenshotConfig": {</p>
			<p class="source-code">        "blackout": [],</p>
			<p class="source-code">        "capture": "fullPage",</p>
			<p class="source-code">        "clip": null,</p>
			<p class="source-code">        "disableTimersAndAnimations": true,</p>
			<p class="source-code">        "log": false,</p>
			<p class="source-code">        "scale": false,</p>
			<p class="source-code">        "timeout": 30000</p>
			<p class="source-code">      },</p>
			<p class="source-code">      "backgroundBlend": "difference"</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Finally, we can add a snapshot test in the <strong class="source-inline">test.js</strong> file.</p>
			<p>First, we'll clean up the file and stub out the <strong class="source-inline">/comments</strong> API call (this will be particularly useful for the snapshot test):</p>
			<p class="source-code">describe('Commentator Pro', () =&gt; {</p>
			<p class="source-code">  beforeEach(() =&gt; {</p>
			<p class="source-code">    cy.server()</p>
			<p class="source-code">    cy.route('GET', '**/comments', [</p>
			<p class="source-code">      {</p>
			<p class="source-code">        body: 'Just saying...',</p>
			<p class="source-code">        email: 'evant@vuejs.org'</p>
			<p class="source-code">      }</p>
			<p class="source-code">    ]).as('getComments')</p>
			<p class="source-code">  })</p>
			<p class="source-code">  // tests</p>
			<p class="source-code">})</p>
			<p>Next, we can add the visual regression test. We'll get the editor open to maximize the single snapshot test, get the whole <strong class="source-inline">app</strong> using <strong class="source-inline">#app</strong>, and snapshot that:</p>
			<p class="source-code">describe('Commentator Pro', () =&gt; {</p>
			<p class="source-code">  // setup &amp; other tests</p>
			<p class="source-code">  it('visual regression', () =&gt; {</p>
			<p class="source-code">    cy.visit('/')</p>
			<p class="source-code">    cy.get('[data-test-id="new-comment-button"]')</p>
			<p class="source-code">      .click()</p>
			<p class="source-code">    cy.wait('@getComments')</p>
			<p class="source-code">    cy.get('[data-test-id="new-comment-editor"]')</p>
			<p class="source-code">      .should('be.visible')</p>
			<p class="source-code">    cy.get('#app').toMatchImageSnapshot({</p>
			<p class="source-code">      threshold: 0.001,</p>
			<p class="source-code">    })</p>
			<p class="source-code">  })</p>
			<p class="source-code">})</p>
			<p>When running the tests with the Cypress UI, we see the following output:</p>
			<div>
				<div id="_idContainer381" class="IMG---Figure">
					<img src="image/B15218_13_18.jpg" alt="Figure 13.18: Cypress running tests, including the visual regression test&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.18: Cypress running tests, including the visual regression test</p>
			<p>We can show the snapshots failing by changing the button color to red (from <strong class="source-inline">bg-blue-500</strong> to <strong class="source-inline">bg-red-500</strong>) in the <strong class="source-inline">App.vue</strong> file:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app" class="p-10"&gt;</p>
			<p class="source-code">    &lt;div class="flex flex-col"&gt;</p>
			<p class="source-code">      &lt;!-- rest of template --&gt;</p>
			<p class="source-code">      &lt;button</p>
			<p class="source-code">        @click="showEditor = !showEditor"</p>
			<p class="source-code">        class="flex mx-auto bg-red-500 hover:bg-blue-700           text-white font-bold py-2 px-4 rounded"</p>
			<p class="source-code">        data-test-id="new-comment-button"</p>
			<p class="source-code">      &gt;</p>
			<p class="source-code">        Add a New Comment</p>
			<p class="source-code">      &lt;/button&gt;</p>
			<p class="source-code">      &lt;!-- rest of template --&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>When we run the relevant set of tests, they're now failing (because, as we can see, the button is red instead of blue):</p>
			<div>
				<div id="_idContainer382" class="IMG---Figure">
					<img src="image/B15218_13_19.jpg" alt="Figure 13.19: Cypress running tests, with a failing visual regression test&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.19: Cypress running tests, with a failing visual regression test</p>
			<p>By clicking on <strong class="source-inline">COMPARE SNAPSHOT</strong>, we get a visual diff view, which allows us to update the snapshot:</p>
			<div>
				<div id="_idContainer383" class="IMG---Figure">
					<img src="image/B15218_13_20.jpg" alt="Figure 13.20: Cypress' failing visual regression test diff view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.20: Cypress' failing visual regression test diff view</p>
			<p>We've now seen how Cypress can be used to do visual regression testing.</p>
			<p>We'll now look at adding a new feature and all the relevant tests for it.</p>
			<h2 id="_idParaDest-272">Activity 13.01: Addi<a id="_idTextAnchor361"/>ng the Ability to Set a User's Email and Tests</h2>
			<p>You'll remember that we've hardcoded <strong class="source-inline">evan@vuejs.org</strong> as the email for any comments. What we'll do in this activity is add an email input that will set the <strong class="source-inline">email</strong> property on comments. We'll add the relevant tests in a new <strong class="source-inline">tests/e2e/specs/enter-email.js</strong> suite:</p>
			<ol>
				<li value="1">In order to keep track of the email, we'll set it as a piece of reactive state in <strong class="source-inline">data()</strong> and add an email type input to the page, which will be two-way bound to <strong class="source-inline">email</strong> using <strong class="source-inline">v-model</strong>. We also add a label and corresponding markup. Note that we'll have a <strong class="source-inline">data-test-id</strong> attribute on the email input set to <strong class="source-inline">email-input</strong>.</li>
				<li>We'll now add a <strong class="source-inline">beforeEach</strong> hook to set up the Cypress mock server and stub out the <strong class="source-inline">GET</strong> comments (list) request. The comments list request should be aliased as <strong class="source-inline">getComments</strong>.</li>
				<li>We'll add our first test that checks whether typing into the email input works correctly. We'll go to the app, type an email, and check that what we typed is now the input value.<p>When run using the Cypress UI, we should get the following passing test:</p><div id="_idContainer384" class="IMG---Figure"><img src="image/B15218_13_21.jpg" alt="Figure 13.21: Cypress running &quot;enter-email&quot; tests, with the email input test&#13;&#10;"/></div><p class="figure-caption">Figure 13.21: Cypress running "enter-email" tests, with the email input test</p></li>
				<li>Having the <strong class="source-inline">email</strong> property is a pre-requisite to adding comments, so we'll disable the <strong class="source-inline">Add a New Comment</strong> button while <strong class="source-inline">email</strong> is empty (<strong class="source-inline">!email</strong>). We'll bind to the <strong class="source-inline">disabled</strong> attribute and toggle some classes based on whether or not the <strong class="source-inline">email</strong> field is populated.</li>
				<li>With this new <strong class="source-inline">disable add new comment button while email is empty</strong> functionality, we should add a new E2E test. We'll load up the page and on initial load, we'll check that the email input is empty and that the <strong class="source-inline">Add a New Comment</strong> button is disabled. We'll then type an email into the email input field and check that the <strong class="source-inline">Add a New Comment</strong> button is now <em class="italic">not</em> disabled, which means it is enabled.<p>When run using the Cypress UI, we should see the new test passing with the following output:</p><div id="_idContainer385" class="IMG---Figure"><img src="image/B15218_13_22.jpg" alt="Figure 13.22: Cypress running &quot;enter-email&quot; tests, with the disabled &#13;&#10;add comment button test&#13;&#10;"/></div><p class="figure-caption">Figure 13.22: Cypress running "enter-email" tests, with the disabled add comment button test</p></li>
				<li>Now that we've got a way to capture the email, we should pass it to the backend API when making the POST comments call (that is, when submitting a new comment). In order to do this, we should modify the spot in <strong class="source-inline">methods.submitNewComment</strong> where <strong class="source-inline">email</strong> is hardcoded as <strong class="source-inline">evan@vuejs.org</strong>.</li>
				<li>Now that we're using the email that's been input by the user, we should write an E2E test to check that it's being sent. We'll stub out the POST request, alias it to <strong class="source-inline">newComment</strong>, and send back an arbitrary value. We can then visit the page, fill out the email input, open the comment editor, fill that out, and submit it. We'll then wait on the <strong class="source-inline">newComment</strong> request and assert on the request body that the body and email are as they were when we completed them.<p class="callout-heading">Note </p><p class="callout">We could also opt to not stub out the <strong class="source-inline">POST</strong> request and instead check that the new comment card inserted on the page contains the right email and body.</p><p>When run using the Cypress UI, we get the following test run output:</p><div id="_idContainer386" class="IMG---Figure"><img src="image/B15218_13_23.jpg" alt="Figure 13.23: Cypress running &quot;enter-email&quot; tests, with the email input test&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 13.23: Cypress running "enter-email" tests, with the email input test</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found via <a href="B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor408">this link</a>.</p>
			<h1 id="_idParaDest-273"><a id="_idTextAnchor362"/>Summary</h1>
			<p>Throughout this<a id="_idTextAnchor363"/> chapter, we've looked at leveraging Cypress to test Vue.js applications from end to end.</p>
			<p>E2E tests in general are useful to give us a high level of confidence that tested flows will work as expected, as opposed to unit or integration tests, which validate that our code works as expected at a much lower overhead.</p>
			<p>We've seen how to use Cypress to inspect, interact with, and assert against a UI. We've also shown how Cypress' default wait/retry functionality is a great advantage while writing robust tests.</p>
			<p>We leveraged Cypress' HTTP interception library to stub out HTTP requests and make tests more predictable and faster.</p>
			<p>Finally, we looked at how to set up visual regression testing with Cypress.</p>
			<p>In the next chapter, we'll look at how to deploy a Vue.js application to the web.</p>
		</div>
		<div>
			<div id="_idContainer388" class="Content">
			</div>
		</div>
	</body></html>