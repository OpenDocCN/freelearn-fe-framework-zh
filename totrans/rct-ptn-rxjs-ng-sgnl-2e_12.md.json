["```js\nwebSocket<T>(urlConfigOrSource: string | WebSocketSubjectConfig<T>): WebSocketSubject<T>;\n```", "```js\nimport { webSocket } from \"rxjs/webSocket\";\nconst subject = webSocket(\"ws://localhost:8081\");\n```", "```js\nimport { webSocket } from 'rxjs/webSocket';\nconst subject$ = webSocket({url:'ws://localhost:8081'});\n```", "```js\nimport { webSocket } from 'rxjs/webSocket';\nconst subject$ = webSocket({url:'ws://localhost:8081'});\nsubject$.subscribe();\n```", "```js\nconst subject$ = webSocket('ws://localhost:8080');\n// Listen to messages from the server\nconst subscription = subject$.subscribe(msg => {\n  console.log('Message received from the socket'+ msg);\n});\n```", "```js\n// Push messages to the server\nsubject$.next('Message to the server');\n```", "```js\n// Push errors to the server\nsubject$.error('Something wrong happens')\n// Handle incoming errors from the server\nsubject$.pipe(catchError(error=>of('Something wrong happens')))\n```", "```js\n// Close the connection\nsubject$.complete();\n//or\nsubject$.unsubscribe();\n```", "```js\nconst firstSubject$ = webSocket('ws://localhost:8080');\nconst  secondSubject$ = webSocket('ws://localhost:8080');\n// the first subscriber, opens the WebSocket connection\nconst subscription1 = firstSubject$.subscribe(msg => {\n});\n// the second subscriber, uses the already opened WebSocket\n   connection\nconst subscription2 = firstSubject$.subscribe(msg => {\n});\n//this subscriber opens a new connection\nconst subscription3 = secondSubject$.subscribe(msg => {\n});\n```", "```js\nconst subject$ = webSocket('ws://localhost:8080');\n// the first subscriber, opens the WebSocket connection\nconst subscription1 = subject$.subscribe(msg => {});\n// the second subscriber, uses the already opened WebSocket connection\nconst subscription2 = subject$.subscribe(msg => {});\n// the connection stays open\nsubscription1.unsubscribe();\n// closes the connection\nsubscription2.unsubscribe();\n```", "```js\nimport { Injectable } from '@angular/core';\nimport { webSocket, WebSocketSubject } from 'rxjs/webSocket';\nimport { environment } from '../../../environments/environment';\nimport { Recipe } from '../model/recipe.model';\nexport const WS_ENDPOINT = environment.wsEndpoint;\n@Injectable({\n  providedIn: 'root'\n})\nexport class RealTimeService {\n  private socket$: WebSocketSubject<Recipe[]> | undefined;\n  private messagesSubject$ = new\n    BehaviorSubject<Observable<Recipe[]>>(EMPTY);\n  private getNewWebSocket(): WebSocketSubject<Recipe[]> {\n    return webSocket(WS_ENDPOINT);\n  }\n  sendMessage(msg: Recipe[]) {\n    this.socket$?.next(msg);\n  }\n  close() {\n    this.socket$?.complete();\n  } }\n```", "```js\n  public connect(): void {\n      if (!this.socket$ || this.socket$.closed) {\n      this.socket$ = this.getNewWebSocket();\n      const messages = this.socket$.pipe(\n        tap({\n          error: error => console.log(error),\n        }), catchError(_ => EMPTY));\n      this.messagesSubject$.next(messages);\n    }\n  }\n```", "```js\n  public messages$ = this.messagesSubject$.pipe(\n  switchAll(), catchError(e => { throw e }));\n```", "```js\nconstructor(private service: RealTimeService ) {\nthis.service.connect();\n}\n```", "```js\nrecipes$=this.service.recipes$;\n```", "```js\nrecipes$=combineLatest([this.service.recipes$,\nthis.realTimeservice.messages$]).pipe(map(([recipes,\nupdatedRecipes]) => {\n    // Merge or concatenate the two arrays into a single\n       array\n    return [...recipes, ...updatedRecipes];\n  }));\n```", "```js\n  recipes$ = combineLatest([\n    this.service.recipes$,\n    this.realTimeService.messages$\n  ]).pipe(\n    scan((acc: Recipe[], [recipes, updatedRecipes]:\n    [Recipe[], Recipe[]]) => {\n      // Merge or concatenate the two arrays into a single\n         array\n      return acc.length === 0 &&\n        updatedRecipes.length === 0 ? recipes : [...acc,\n          ...updatedRecipes,];\n    }, [])\n  );\n```", "```js\n@if ( recipes$ | async; as recipes) {\n....\n}\n```", "```js\n  public messages$ =\n  this.messagesSubject$.pipe(switchAll(), startWith([]),\n  catchError(e => { throw e }));\n```", "```js\n@Component({\n  selector: 'app-recipes-list',\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\n```", "```js\nexport interface WebSocketSubjectConfig<T> {\n  url: string;\n  protocol?: string | Array<string>;\n  /** @deprecated Will be removed in v8\\. Use {@link\n  deserializer} instead. */\n  resultSelector?: (e: MessageEvent) => T;\n  openObserver?: NextObserver<Event>;\n  serializer?: (value: T) => WebSocketMessage;\n  deserializer?: (e: MessageEvent) => T;\n  closeObserver?: NextObserver<CloseEvent>;\n  closingObserver?: NextObserver<void>;\n  WebSocketCtor?: { new(url: string,\n  protocols?:string|string[]): WebSocket };\n  binaryType?: 'blob' | 'arraybuffer';\n}\n```", "```js\nprivate getNewWebSocket() {\n  return webSocket({\n    url: WS_ENDPOINT,\n    closeObserver: {\n      next: () => {\n        console.log('[RealTimeService]: connection\n                    closed');\n      }\n    },\n  });\n}\n```", "```js\n    private reconnect(observable: Observable< Recipe[] >):\n    Observable< Recipe[] > {\n      return observable.pipe(retryWhen(errors =>\n        errors.pipe(\n          tap(val => console.log('[Data Service]\n            Try to reconnect', val)),\n              delayWhen(_ => timer(RECONNECT_INTERVAL)))));\n    }\n```", "```js\npublic connect(cfg: { reconnect: boolean } = { reconnect: false }): void {\n  if (!this.socket$ || this.socket$.closed) {\n    this.socket$ = this.getNewWebSocket();\n    const messages = this.socket$.pipe(cfg.reconnect ?\n    this.reconnect : o => o,\n      tap({\n        error: error => console.log(error),\n      }), catchError(_ => EMPTY))\n    this.messagesSubject$.next(messages);\n  }\n}\n```", "```js\n    private getNewWebSocket() {\n      return webSocket({\n        url: WS_ENDPOINT,\n        closeObserver: {\n          next: () => {\n            console.log('[DataService]: connection\n                        closed');\n            this.socket$ = undefined;\n            this.connect({ reconnect: true });\n          }\n        },\n      });\n```"]