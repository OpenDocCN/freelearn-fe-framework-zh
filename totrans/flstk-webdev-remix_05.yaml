- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fetching and Mutating Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling dynamic data is crucial in today's web development landscape. Most
    modern apps interact with data from various sources. The way an app manages loading
    states, errors, and data updates plays a big role in user experience. Fortunately,
    Remix offers a comprehensive solution for both retrieving and updating data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutating data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will implement data reads and writes in BeeRich. First,
    we will practice data loading. Then, we will learn about data mutations in Remix
    and implement an expense creation form.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know how to fetch and mutate data in Remix.
    You will also understand how Remix executes `loader` and `action` functions and
    how Remix revalidates loader data after mutations. Finally, you will have practiced
    building applications with progressive enhancement in mind, which we will build
    upon in [*Chapter 6*](B17399_06.xhtml#_idTextAnchor090), *Progressively Enhancing
    the* *User Experience*.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the setup instructions for this chapter here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/05-fetching-and-mutating-data/bee-rich/README.md](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/05-fetching-and-mutating-data/bee-rich/README.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the code in the `start` folder of this chapter is different from our
    final solution from [*Chapter 4*](B17399_04.xhtml#_idTextAnchor057), *Routing
    in Remix*. Read the instructions in the `README.md` file of this chapter’s folder
    on GitHub before you continue.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before diving into this chapter, make sure you''ve followed the steps in the
    technical requirements section. Once you''ve completed the setup guide, let''s
    briefly revisit the key steps to prevent any issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Run `npm i` to install all dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are missing a `.env` file in your project’s root, create a new `.env`
    file and add the following line to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Prisma – our database toolkit of choice – uses the `DATABASE_URL` environment
    variable to connect to our database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, run `npm run build` to generate the Prisma client for our data schema.
    Prisma reads our Prisma schema from the `prisma/schema.prisma` file and generates
    types and functions for us to work with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm run update:db` to create or update the SQLite database. We use SQLite
    with Prisma to persist our development data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, run `npm run seed` to seed our local database with mock data. You can
    find the mock script in `prisma/seed.tsx`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our datatabase is set up, and we can now use Prisma to query the database. Next,
    let's add the code to fetch data from the database to BeeRich.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data at the route level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s use Remix’s `loader` functions and route-level data fetching to query
    the database for expense data:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `app/routes/dashboard.expenses.tsx` file in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `loader` function to the route module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`loader` functions are Remix’s HTTP `Request`–`Response` interface. Remix’s
    `loader` functions are executed only on the server and must return a `Response`
    object ([https://developer.mozilla.org/en-US/docs/Web/API/Response](https://developer.mozilla.org/en-US/docs/Web/API/Response)).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For now, we return an empty JavaScript object. Remix serializes the object for
    us (`JSON.stringify`) and creates a `Response` object with `Content-Type` `application/json`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, import our new database client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information about our Prisma client setup in the `README.md`
    file here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/05-fetching-and-mutating-data/bee-rich/README.md](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/05-fetching-and-mutating-data/bee-rich/README.md).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the database client to query for all expenses and return the results array
    from the `loader` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: json helper function returns a Response object with Content-Type application/json.
    Using the helper function allows us to provide an init object as the second argument
    to add HTTP headers, a status text, and a status code to the response.This step
    is optional as we don’t return any HTTP headers or cookies with the `Response`
    object just yet. We’ll cover this in more detail later in this book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the database query to order the data by date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Move as much logic as possible to the server
  prefs: []
  type: TYPE_NORMAL
- en: We should try to move as much code as possible to the server-side `action` and
    `loader` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Moving code to the server ensures that less code is shipped to the client. It
    also increases the amount of logic that works before JavaScript has fully loaded
    on the client. Finally, we make sure we decrease the complexity of our client-side
    application by moving the code to our fast and powerful server and database runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: Thereafter, add `console.log` to the `loader` function so that we can track
    its execution on the terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the app (`npm run dev`) and open BeeRich in a browser window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, navigate between different pages and check the server terminal for
    your `console.log` message. Take note when the `loader` function is executed.
    Since `loader` functions only run on the server, you will find the log statements
    in the terminal and not the browser console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great! Whenever the `dashboard/expenses` path is added to the URL, Remix calls
    the `dashboard.expenses.tsx` route module’s `loader` function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to figure out how to access the data in React. Luckily, this is
    as easy as it gets in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Again, open the `dashboard.expenses.tsx` route module in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `useLoaderData` hook from `@remix-run/react`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, call the hook in the route module component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `useLoaderData` hook to access the loader data `loader` functions
    first and then renders the React application on the server. In our React component,
    we access the fetched data without having to manage loading states. This allows
    us to eliminate a big chunk of boilerplate code that many React apps suffer from.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So far, the `expenses` variable in our route component is typed as `any`. This
    isn’t ideal. Luckily, we are using TypeScript for both our frontend and backend
    code. We are further co-locating client and server code in the same `app` folder.
    This allows us to do powerful things, such as inferring the type of the loader
    data when calling `useLoaderData`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pass the type of the `loader` function to the generic slot of `useLoaderData`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s use the expense array to replace the hardcoded expense list. Loop over
    the expense data to render the list of expenses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, run the application and visit the expense overview page. You should
    be able to view a list of expenses from the seed data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Amazing! We utilize a server-side `loader` function to fetch data, and then
    we access the data in React to render our page. Remix’s `loader` function allows
    us to co-locate server-side data loading and data rendering in the same file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that data fetching in Remix happens in `loader` functions at the route
    level. Route-level data fetching offers many advantages by giving up some of the
    flexibility of fetching from components.
  prefs: []
  type: TYPE_NORMAL
- en: Component-based data loading is susceptible to blocking requests, which may
    lead to fetch waterfalls. A component that fetches data often defers rendering
    its child components until the data is loaded. This blocks the children from kicking
    off their own fetch requests, effectively creating a waterfall of fetch requests.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a component that renders the layout of the page. First, it fetches the
    user object and displays a big loading spinner until the user data has been fetched.
    After the user data has been fetched, the page is rendered. Nested components
    now fetch their own data. The user fetch request blocked these requests. This
    behavior may repeat itself several times in nested subtrees of an app.
  prefs: []
  type: TYPE_NORMAL
- en: Remix promotes route-level data fetching
  prefs: []
  type: TYPE_NORMAL
- en: In Remix, we aim to fetch data in route modules instead of components. By avoiding
    granular data fetching at the component level, we aim to optimize data loading
    and prevent fetch waterfalls. We should remember this as a best practice.
  prefs: []
  type: TYPE_NORMAL
- en: Note that route-level data fetching does not imply that you can only access
    the data at the route level. You can use the `useLoaderData`, `useRouteLoaderData`,
    and `useMatches` hooks in any custom hook or component of your application to
    access loader data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `useRouteLoaderData` and `useMatches` hooks are used to access data from
    any currently active route – compared to `useLoaderData`, which returns the data
    of the route module that the hook is called in. Refer to the Remix documentation
    for more information: [https://remix.run/docs/en/2/hooks/use-route-loader-data](https://remix.run/docs/en/2/hooks/use-route-loader-data).'
  prefs: []
  type: TYPE_NORMAL
- en: As always, make sure to implement the same functionality for the income routes.
    This ensures you revisit the concepts introduced in this section before moving
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s have a look at how we can fetch data based on dynamic route parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching dynamic data in parameterized routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve updated the expenses overview page, you might have noticed that
    this broke our hardcoded expense details route. Let’s fix that.
  prefs: []
  type: TYPE_NORMAL
- en: You may remember from [*Chapter 4*](B17399_04.xhtml#_idTextAnchor057), *Routing
    in Remix*, that we designed the expense details page as a nested route that renders
    within the expenses overview page. It is also a parameterized route that uses
    a dynamic route parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update the code so that it queries the requested expense from the database
    based on the route parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `/app/routes/dashboard.expenses.$id.tsx` file in your editor. We’re
    already using a `loader` function to render our mock data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the mock data array from the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, update the `loader` function to query the database and find a unique
    expense object with the `id` parameter that we access from the URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run BeeRich by executing `npm run dev` in a terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a browser window and navigate to [http://localhost:3000/dashboard/expenses/](http://localhost:3000/dashboard/expenses/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on one of the listed expenses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the URL changes to include the `id` parameter of the expense. Remix
    executes a client-side navigation (when JS is available) to update the URL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Remix executes a `loader` function when we navigate to the associated route
    segment. On every page navigation, Remix fetches the loader data of each new route
    module that matches the newly requested page. If we navigate to `/login`, then
    the `loader` functions of all **newly matching routes** are executed. This may
    include the following route modules (from root to leaf):'
  prefs: []
  type: TYPE_NORMAL
- en: '`root.tsx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`routes/_layout.tsx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`routes/_layout.login.tsx`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we further navigate from `/login` to `/signup`, then only the `_layout.signup.tsx`
    route module’s `loader` function is executed as it’s the only route segment that
    wasn’t already active before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s visualize what’s going on by reviewing the **Network** tab in the developer
    tools of the browser window:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the developer tools in the browser window that runs your app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Network** tab of the developer tools.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filter by `Fetch/XHR` network requests. This is optional but helps you find
    all fetch requests made to the `loader` functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, change the URL in the URL bar to [http://localhost:3000/dashboard/expenses/](http://localhost:3000/dashboard/expenses/)
    and reload the browser window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see no fetch requests in the `dashboard.expenses.tsx` route module’s
    `loader` function is executed, and the data is used to render the HTML on the
    server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on any of the expenses in the expenses list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remix is now running client-side. After hydration, the client-side Remix app
    takes over the routing of our application. This allows us to avoid full-page requests,
    which would require more network bandwidth and increase response times.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since we are using Remix’s `Link` component, Remix can intercept page transitions.
    Remix prevents the browser’s default behavior (full-page reload) if JavaScript
    is loaded. Instead, it emulates the behavior by making fetch requests to our `loader`
    functions to fetch the required data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inspect the request in the `/dashboard/expenses/$id` invokes a fetch request
    to the `dashboard.expenses.$id.tsx` route module’s `loader` function, as shown
    in *Figure 5**.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Screenshot of the fetched loader data after a route transition](img/Figure_5.01_B17399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Screenshot of the fetched loader data after a route transition
  prefs: []
  type: TYPE_NORMAL
- en: As visible in *Figure 5**.1*, Remix executes a fetch request to the `loader`
    function, which then returns the expense object as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Click on another expense. Notice that Remix repeats the behavior for each navigation
    to an expense details route. Every time we click on a new expense, the URL changes,
    and the `loader` function of the details page is called again with the next `$id`
    route parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that Remix never re-fetches the expenses array for the overview page.
    That is because we remain on the `dashboard.expenses.tsx` route segment. **Remix
    only loads data for newly matching** **route segments.**
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Great! We are now able to fetch dynamic data with parameterized routes. Note
    that Remix only fetches data for newly matching route segments. This avoids unnecessary
    requests. We also learned that Remix fetches from `loader` functions during server-side
    rendering and client-side navigations. Remix handles data loading on a per-route
    level on both sides of the network.
  prefs: []
  type: TYPE_NORMAL
- en: Remix is both a frontend and a backend framework
  prefs: []
  type: TYPE_NORMAL
- en: Remix calls `loader` functions on the initial request on the server before rendering
    React server-side. On the client, Remix fetches loader data on client-side navigations
    with AJAX requests (fetch requests).
  prefs: []
  type: TYPE_NORMAL
- en: Revisit the concepts introduced in this section by updating the `dashboard.income.$id.tsx`
    route module so that it matches `dashboard.expenses.$id.tsx`. Make sure you test
    your implementation before moving on. Inspect which `loader` functions are executed
    when switching between the `/income` and `/expenses` routes by using the **Network**
    tab.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s see how `loader` functions are called in parallel. For this, we
    need to adapt our application logic a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Loading data in parallel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As visible in *Figure 5**.2*, the expense overview page has two sections –
    the list of all expenses (`dashboard.expenses.tsx`) and the details view of the
    currently selected expense (`dashboard.expenses.$id.tsx`). The details view is
    empty when navigating to `/dashboard/expenses` since the nested `$id` route module
    does not appear on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Screenshot of the expenses route with a nested $id route module](img/Figure_5.02_B17399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Screenshot of the expenses route with a nested $id route module
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update the `/dashboard/expenses`. We will update this link so that it
    points to the most recently created expense instead:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `dashboard.tsx` route module in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `loader` function to the route module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `loader` function queries the database for the most recently created expense.
    It then returns the queried `firstExpense`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that `firstExpense` can also be `null` if the database has no expense entries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, access the `firstExpense` object using the `useLoaderData` hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We type the `useLoaderData` hook with the type of the `loader` function. `firstExpense`
    is now correctly typed as the serialized version of an expense object or `null`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `firstExpense` to update the `to` property of the `NavLink`. Since `firstExpense`
    can be `null`, we must ensure we make this change conditionally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run BeeRich by executing `npm run dev` and open the expenses overview page
    in a browser window: [http://localhost:3000/dashboard/expenses](http://localhost:3000/dashboard/expenses).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the `NavLink` component lost its active styling. This is because
    the link now points to a nested route, which does not trigger the `isActive` condition
    on Remix’s `NavLink` component. Luckily, our custom `NavLink` component offers
    a `styleAsActive` prop, which can be used to apply the active styling whenever
    we want.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Import the `useLocation` hook from `@remix-run/react`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, call the hook in the route module component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remix’s `useLocation` hook lets us access a global location object with information
    about the current URL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `styleAsActive` prop to the `NavLink`. Set the property to `true` whenever
    the user is on an `/``expenses` route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Visit the `/dashboard/income` page in a browser window and clear the **Network**
    tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, navigate to the details page of the most recently created expense by clicking
    on the **Expenses** navigation menu link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As visible in *Figure 5**.3*, you should now see two fetch requests in the
    `loader` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`dashboard.expenses.tsx`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dashboard.expenses.$id.tsx`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `loader` function in `dashboard.tsx` is not executed as the route module
    was already active on the page before the navigation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Inspecting the fetch request waterfall](img/Figure_5.03_B17399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Inspecting the fetch request waterfall
  prefs: []
  type: TYPE_NORMAL
- en: As visible in *Figure 5**.3*, we can inspect the waterfall of the fetch requests
    in the **Network** tab. The green bar indicates the server execution time for
    the request. Note that both fetch requests are executed in parallel. This flattens
    the request waterfall and improves the response time.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that we query the database again in the `loader` function
    in `dashboard.expenses.$id.tsx`. You might have asked yourself why we are not
    reusing the loader data from `dashboard.expenses.tsx` as we already fetch all
    expenses from the database. This is a trade-off for the parallel execution of
    `loader` functions. Several loaders cannot depend on each other’s data as they
    are all executed in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s summarize our observations:'
  prefs: []
  type: TYPE_NORMAL
- en: On initial request, Remix renders our app on the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All active `loader` functions are executed in parallel and passed to the React
    app during server-side rendering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With loaders, we fetch application data on a per-route level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remix emulates the browser’s default behavior with JavaScript. All subsequent
    page navigations execute client-side if JavaScript has loaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remix uses fetch requests to load all required loader data on navigation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `loader` functions of all newly matching route segments are executed in
    parallel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Already active `loader` functions are not executed again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practice what you’ve learned in this section by implementing the same functionality
    on the `/income` routes. Query for the most recently created invoice in the `dashboard.tsx`
    route module’s `loader` function. Then, update the `NavLink` component. Finally,
    use the `useLocation` hook to add the `styleAsActive` prop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s see whether we can optimize the code a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `app/routes/dashboard.tsx` file in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After adding the invoice query to the `loader` function, the function may look
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Refactor the code so that it executes the two queries in parallel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this section, we went over data fetching in Remix. You learned how to use
    and type the `useLoaderData` hook and how to query data based on dynamic route
    parameters. You now know that Remix promotes data fetching at the route module
    level. This allows us to execute `loader` functions in parallel and avoid request
    waterfalls. You further understand the importance of moving as much logic as possible
    to the server to reduce the size and complexity of the client bundle. Finally,
    you practiced optimizing `loader` functions to make independent requests in parallel.
    Next, we’ll learn about data mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Mutating data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating and updating data is just as important as fetching data. In this section,
    we will add an expense creation form and learn how to mutate data in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Mutating data without JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember the three-step process for building web UIs from Ryan Florence that
    we discussed in [*Chapter 1*](B17399_01.xhtml#_idTextAnchor013)? The first step
    is to make the user experience work without JavaScript. After that, we add JavaScript
    to enhance the experience but ensure that the baseline implementation still works.
    This process is called **progressive enhancement**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we use Remix''s `action` function to handle incoming form
    submissions on the server. In the `action` function, we will validate the user
    data and write the new expense object to the database. Let''s see how we can use
    the native form element to submit user data, without the need for client-side
    JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new route module for the expense creation form: `app/routes/dashboard.expenses._index.tsx`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We add the expense creation form to the index route of the `/dashboard/expenses/`
    path. This leads to the following route hierarchy:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`/dashboard/expenses/`: Shows the expenses list and the expense creation form'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dashboard/expenses/$id`: Shows the expenses list and the expense details
    for the expense with the `id` identifier'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add a route component to `dashboard.expenses._index.tsx` that contains an HTML
    form element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: POST to mutate, GET to load
  prefs: []
  type: TYPE_NORMAL
- en: HTML forms use the HTTP verbs `POST` and `GET` for submissions. It’s best to
    use a `POST` request for mutations and a `GET` request to read data from the server.
  prefs: []
  type: TYPE_NORMAL
- en: We want to submit the data to the `dashboard.expenses._index.tsx` route module
    (the route module of the form element). Note that this is the default behavior,
    so we could also omit the attribute declaration. However, for educational purposes,
    we set `action` to `/dashboard/expenses?index` as the pathname for the action.
  prefs: []
  type: TYPE_NORMAL
- en: Note the `?index` search parameter that is added to the action’s pathname. Index
    route modules and their parent route modules both match the same URL. When defining
    an `action` function, that action can live in either `dashboard.expenses.tsx`
    or `dashboard.expenses._index.tsx`. The `?index` search parameter tells Remix
    to submit to the index route module, not the parent module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s add input fields for the expense data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add an `action` function to the route module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `request` parameter to parse the request body into form data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import our database client and the `redirect` function from Remix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Validate the form data before using it to create a new expense:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Review the return statement of the `action` function. We redirect to the expense
    details page of the created expense to communicate success:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Like `loader` functions, `action` functions must return a `Response` object
    or plain JSON (which Remix wraps in a `Response` object for us).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We utilize Remix’s `redirect` helper function to create a redirect response
    object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `/dashboard.expenses.$id.tsx` route module in your editor and add
    a quick link to the expense creation page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Execute `npm run dev` to start the dev server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the expenses overview page ([http://localhost:3000/dashboard/expenses/](http://localhost:3000/dashboard/expenses/))
    and test the implementation. Create your first expense!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do you notice? When submitting the native HTML form element, the browser
    executes a full-page reload. This is the browser’s default behavior on form submissions.
    Furthermore, you might notice that the created expense appears in the expense
    list after completing the submission.
  prefs: []
  type: TYPE_NORMAL
- en: A full-page reload triggers a refresh of the full page. Remix renders the HTML
    on the server and triggers all active loader functions. The expense overview is
    reloaded on submission.
  prefs: []
  type: TYPE_NORMAL
- en: The form element provides a `FormData` API and use named input fields to declare
    what fields should be sent to the server. Form submissions trigger `POST` requests
    to the `action` function. We use the `Request` object to parse the submitted form
    data. This happens on the server. So far, our implementation uses no client-side
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a React SPA, we often call `event.preventDefault` in `onSubmit` handlers
    to prevent the browser’s default behavior. Here, we initiate a client-side fetch
    request. This may look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: By doing so, we avoid full-page reloads and gain control over what pieces of
    the React state should be updated by the mutation. However, without supporting
    native form submissions, we lose the ability to fall back to the browser’s default
    behavior. Worse, implementing this ourselves forces us to develop custom solutions
    for pending states, error handling, and state revalidation after mutation.
  prefs: []
  type: TYPE_NORMAL
- en: Making it work without JavaScript enables us to support user interactions before
    JavaScript has loaded or in case it fails to load. This is a powerful feature
    we get when using Remix’s primitives and conventions. However, Remix also scales
    upward. Let’s add JavaScript to enhance the experience.
  prefs: []
  type: TYPE_NORMAL
- en: Mutating data with JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remix provides a `Form` component that progressively enhances the experience.
    All we need to do is replace the native HTML form element through Remix’s `Form`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `Form` component from Remix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use it to replace the native HTML form element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our custom page loading indicator is triggered, indicating that form submissions
    also affect Remix’s global navigation object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After submission, the app still executes a redirect and transitions the user
    to the expense details page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After submission, the new expense appears in the expense overview list as part
    of the `/dashboard/expenses/` route’s loader data. Remix emulates the browser’s
    default behavior of refreshing all content on the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember how Remix’s `NavLink` and `Link` components enhance anchor tag navigations?
    By replacing the native form element with Remix’s `Form` component, we get client-side
    data fetching, progressive enhancement, and client-side state revalidation out
    of the box.
  prefs: []
  type: TYPE_NORMAL
- en: We now take advantage of JavaScript on the client, but that JavaScript is provided
    through Remix’s `Form` component, and no custom boilerplate code is required.
    Remix’s `Form` component sets the global navigation object’s state to `submitting`
    and `loading` for managing pending UIs. Using Remix’s `Form` component further
    ensures the refetching of all active `loader` functions after mutation.
  prefs: []
  type: TYPE_NORMAL
- en: Remix revalidates loader data after every action
  prefs: []
  type: TYPE_NORMAL
- en: Remix refreshes all loader data by re-fetching from all active `loader` functions
    after executing an `action` function, just like a full-page reload would do on
    a HTML form submission.
  prefs: []
  type: TYPE_NORMAL
- en: Data revalidation is a powerful feature that lets us avoid stale data on the
    client or having to develop custom logic to synchronize client and server states.
  prefs: []
  type: TYPE_NORMAL
- en: Nice! In this section, we implemented an expense creation form and associated
    `action` function. You learned how Remix removes boilerplate code by providing
    the `Form` component, which does the heavy lifting under the hood. You practiced
    declaring a fetch request using named input fields and Remix’s `Form` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on, let’s style our form by bringing in some of the prepared
    UI components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `Textarea`, `Input`, and `Form` components from the `components`
    folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove the import of Remix’s `Form` component since we will be using our custom
    wrapper component instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the native label, input, and textarea elements with our styled counterparts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: import { Button } from '~/components/buttons';
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the native button element with our wrapper component and add the `isPrimary`
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run BeeRich locally. The form should look much nicer now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure you implement the invoice creation form and replicate what we did
    for the expense routes. Start by implementing the functionality without JavaScript.
    Then, enhance the experience with Remix’s `Form` component. I encourage you to
    keep the `Fetch/XHR` network requests and inspect how Remix revalidates all loader
    data after each form submission. If you get stuck working on the income routes,
    you can find the final solution for this chapter on GitHub: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/05-fetching-and-mutating-data/bee-rich/solution](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/05-fetching-and-mutating-data/bee-rich/solution).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reading and writing data are important aspects of modern web application development.
    Remix provides primitives, conventions, and levers for both.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduced you to Remix’s server-side `loader` and `action` functions.
    You learned that `loader` and `action` functions are route-level HTTP request
    handlers that get and mutate data. Loaders handle HTTP `GET` requests, while `action`
    functions receive all other incoming HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, Remix renders our app on the server. All further page transitions
    happen on the client. On the initial request, loader data is used during server-side
    rendering. On all subsequent navigations, Remix fetches loader data via fetch
    requests and only re-renders the changing parts of the route hierarchy on the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you learned that route-level data fetching allows us – among other things
    – to flatten request waterfalls that may occur with component-level fetching.
    Remix also executes `loader` functions in parallel to reduce response times.
  prefs: []
  type: TYPE_NORMAL
- en: By completing this chapter, you should now understand how Remix uses the HTML
    form element to work with mutations declaratively. Remix provides progressive
    enhancement out of the box. By default, Remix executes client-side fetch requests
    to perform data mutations. However, if JavaScript isn’t available (hasn’t loaded
    yet, failed to load, or is disabled), then Remix can fall back to the browser’s
    default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we added an `action` function to validate request data and
    create a new expense object. Remix automatically refetches all loader data after
    every mutation. With Remix, we get data revalidation out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Remix’s data loading and mutations work with and without JavaScript. This allows
    us to enhance the experience progressively and make our application accessible
    to more users. In the next chapter, we will learn more about progressively enhancing
    the experience. We will formalize what we learned in this chapter and learn about
    more tools to enhance the experience in our Remix apps.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Remix documentation outlines the full stack data flow in Remix here: [https://remix.run/docs/en/2/discussion/data-flow](https://remix.run/docs/en/2/discussion/data-flow).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find Remix’s documentation about data loading here: [https://remix.run/docs/en/2/guides/data-loading](https://remix.run/docs/en/2/guides/data-loading).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find Remix’s documentation about mutations here: [https://remix.run/docs/en/2/guides/data-writes](https://remix.run/docs/en/2/guides/data-writes).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Remix team has created an amazing video series called Remix Singles that
    goes in depth into how to work with data in Remix. The series starts with a video
    about data loading, which you can find here: [https://www.youtube.com/watch?v=NXqEP_PsPNc](https://www.youtube.com/watch?v=NXqEP_PsPNc).'
  prefs: []
  type: TYPE_NORMAL
- en: 'MDN Web Docs is a great place to learn more about the HTTP protocol: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP).'
  prefs: []
  type: TYPE_NORMAL
