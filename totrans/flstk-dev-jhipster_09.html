<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Building Microservices with JHipster</h1>
                </header>
            
            <article>
                
<p>Now, it's time to build a full-fledged microservices stack. So far, we have generated, developed, and deployed a monolithic application using JHipster, and in the previous chapter, we saw the benefits offered by a microservice stack. In this chapter, we will look at how to build microservices with JHipster.</p>
<p>We will start by converting our monolithic store application into a microservice gateway application. Next, we will add a new functionality to our e-commerce shop as a separate microservice application. We will then see how these applications communicate with each other and work as a single application for our end users.</p>
<p>In this chapter, we will:</p>
<ul>
<li>Generate a Gateway application:
<ul>
<li>Run through the generated code</li>
<li>See a brief introduction to JWT</li>
</ul>
</li>
<li>Generate a microservice application:
<ul>
<li>Invoice service</li>
<li>Notification service</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application architecture</h1>
                </header>
            
            <article>
                
<p>We built an online e-commerce shop using JHipster in <a href="3c863445-9d8d-4cd3-b14e-5331593913e3.xhtml">Chapter 3</a>, <em>Building Monolithic Web Applications</em> with JHipster. It was built as a monolith since the scope was small and it was an easier choice to start with. Let's say that our e-commerce store has grown tremendously in terms of users and scope, resulting in a more demanding situation. The team is finding it difficult to roll out features faster with the monolithic architecture, and would like to have more control over individual parts of the application.</p>
<p>One of the solutions to this problem would be to adopt a microservice architecture. The application was created using JHipster; the option to move to microservices is much easier to accomplish. JHipster follows the <strong>proxy microservice pattern</strong> in which there is an aggregator/proxy in front of the services, which acts as the gateway for the end users. In much simpler terms, JHipster creates a gateway (which handles all the user requests) and the individual services that talk via the gateway to the users.</p>
<p>This said, we need to have a gateway service, along with one or a few microservice applications that can run alone.</p>
<p>Our customers are facing some issues regarding invoicing, since it is taking longer for the system to respond. Customers are also complaining that they are not receiving notifications so they can track their orders. To solve this, we will remove the invoice service from our monolithic application and make it a separate service, and then create a separate <strong>Notification Service</strong> that will take care of the notifications. For the former, we will stick with the same SQL database. For the latter, we will use the NoSQL database.</p>
<p>Let's have a look at the application architecture that we are going to generate:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6a4c466f-edc1-453a-9658-6cc03e7fe770.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Gateway application generation</h1>
                </header>
            
            <article>
                
<p>We will start by converting the monolithic application that we have generated into a microservice gateway application. </p>
<p>Even though microservices are made up of different services inside, for end users it should be a single, unified product. There are a lot of services that are designed to work in a lot of different ways, but there should be a single entry point for users. Thus, we need a gateway application, since they form the frontend of your application. </p>
<p>Segregate the internal contracts and services from external users. We may have application-level internal services that we shouldn't expose to external users, so these can be masked away. <span>This also adds another level of security to the application.</span></p>
<p>Easier to mock services for testing help validate the services independently in integration testing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Converting a monolithic application to a microservice gateway</h1>
                </header>
            
            <article>
                
<p>We already have our monolithic application generated, as well as our entities. As a part of monolithic application generation, we have already selected some options via JHipster CLI. We will stick to the same options (the database, authentication type, package name, i18n, and so on) when we generate the microservice gateway application. </p>
<div class="packt_tip packt_infobox">Note: We will see how the customizations that we applied in the monolithic app can be applied to the gateway later.</div>
<p>It's coding time now, so let's start building a gateway application using JHipster CLI.</p>
<p>The first step here is to convert the monolithic app into a microservice gateway application with almost the same configuration that we used when we created a monolithic application.</p>
<p>Let's move to the Terminal (Command Prompt, if you are using Windows) now, and start by navigating to the folder where we created the monolithic application. Once you're in the folder, create a new Git branch so that we can do a clean merge back to master once we are done:</p>
<pre><strong>&gt; cd e-commerce-app/online-store</strong><br/><strong>&gt; git checkout -b gateway-conversion</strong></pre>
<p class="mce-root">Now, open the <kbd>.yo-rc.json</kbd> file in your favorite text editor or IDE and change the following value:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c58dc656-48af-47ab-8020-75c30440f768.png"/></div>
<p>In order to make the monolith into a microservice gateway application, we can just change the preceding values in the <kbd>.yo-rc.json</kbd> file. We have added the service discovery type to Eureka since for monolithic applications, it is not mandatory to have service discovery.</p>
<p>Also, obviously, the next change is to change the application type from monolith to gateway. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application generation</h1>
                </header>
            
            <article>
                
<p class="mce-root">Now, let's run the <kbd>jhipster</kbd> command to generate the application:</p>
<div class="CDPAlignCenter CDPAlign"><img height="138" src="assets/e157b3a8-ae89-494b-bae6-9ab95f4d9f7a.png" width="296"/></div>
<p>JHipster then asks whether you want to overwrite the conflicting files or use your existing ones, as well as a few other options. Users can use any one of the desired options.</p>
<p>Right now, we will choose option <kbd>a</kbd>. It will overwrite all of the other files, including the highlighted file.</p>
<div class="packt_infobox">This prompt is extremely useful if you have a lot of custom code written on your application. You can choose the appropriate option to get the desired result.</div>
<div class="CDPAlignCenter CDPAlign"><img height="155" src="assets/7a386280-9640-4fd0-84c8-8487b2d4bb17.png" width="292"/></div>
<p>This will overwrite all the customizations we did in our monolithic application. We can easily bring them back into this branch by cherry picking the required changes from our master branch using GIT. You can follow a similar approach to the one we saw in <a href="63e6ed92-1616-40b7-86b8-1b3332fcbfb7.xhtml">Chapter 5</a>, <em>Customization and Further Development</em>, for that. Once all changes are applied, we can merge this branch back into the master. You will have to do the same for entity files as well in <a href="28229d3b-052f-436e-9dc9-322727b9be4a.xhtml">Chapter 10</a>, <em>Working with Microservices</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating a new Gateway</h1>
                </header>
            
            <article>
                
<p>If you do not want to convert the existing monolith and want to start fresh, then follow these steps.</p>
<p>In the Terminal, navigate to the <kbd>e-commerce-app</kbd> folder and create a new folder called <kbd>app-gateway</kbd>,  <span><span>change the directory to</span></span> <kbd>app-gateway</kbd>, and run the <kbd>jhipster</kbd> command.</p>
<p><span>So, obviously, the first question is, <span class="packt_screen"><span class="packt_screen">W</span>hich *type* of application would we like to create?</span> We will select the <span class="packt_screen">Microservice gateway</span> (third option) and then click <em>Enter</em>:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="65" src="assets/bfa5cc5a-e486-4c5d-b189-0ce4693d240c.png" width="383"/></div>
<p>Then, we will enter the base name of our application. We will use the name <kbd>store</kbd>:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="29" src="assets/1ffbf974-3a76-47c8-b4b4-a9bb4122d43b.png" width="507"/></div>
<p>Since we are working with microservices, there is a high risk of having port conflicts. In order to avoid them, JHipster will ask you to select a port for each microservice application (both gateway and application). By default, we will have <kbd>8080</kbd> as the port, but we can change the port as necessary. For now, we will use the default port since the gateway will run on <kbd>8080</kbd>, similar to what our monolithic application had: </p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/7d85a3d1-a89a-4e9b-8f5f-ced6207d3cc6.png"/></div>
<p>Then, we enter the package name for our application. We will use the default name that is available, which is <kbd>com.mycompany.store</kbd>:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/d47aabf3-4b7b-48b1-bed7-e98a36b075b1.png"/></div>
<p>For the next question, JHipster will ask you to configure the registry service. We will select the necessary registry service to configure, monitor, and scale our microservices and gateway application. We can either choose to use the JHipster registry or Consul. This is also optional; we don't need to choose any registry service here. We can then select <span class="packt_screen">No service discovery</span>. </p>
<div class="packt_infobox">When you select <span class="packt_screen">No service discovery</span>, the microservice URLs are hardcoded in the property files. </div>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/804d5adf-7774-4922-bdcf-2509505072f5.png"/></div>
<p>For the next question, JHipster will ask you to select the authentication type. JHipster provides three options for the authentication type, which are JWT, OAuth2, and UAA server-based. JWT is stateless, while the UAA runs on a different server (and application altogether). OAuth2, on the other hand, will provide authorization tokens, while the authorization is done on the third-party system. </p>
<div class="packt_infobox">JHipster does provide an option to create a UAA server application. </div>
<p><span>We will look at JWT in more detail shortly. For now, we will select </span><span class="packt_screen">JWT authentication</span><span>.</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/443b3149-1253-4a02-aa27-54bb51cbb2b2.png"/></div>
<p>We will select the database type next. We have an option to select either SQL and NoSQL. In terms of NoSQL, we can choose MongoDB or Cassandra. We will select the <span class="packt_screen">SQL</span> database:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/84c34984-58bb-4d75-a980-1dda176da298.png"/></div>
<p>Then, we will select the database that we will be using for production and development. JHipster provides an option to use a different database for your production and development environment. This really helps to kick-start application development faster and easier.</p>
<p>We will select a <span class="packt_screen">MySQL</span> database for production:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/aeb5da7b-b329-4619-aac0-b210a80dcff4.png"/></div>
<p>Then, we will select <span class="packt_screen">H2 with disk-based persistence</span> for development:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/e7d52a14-8a6e-4e02-9308-16911416e47d.png"/></div>
<p>Following the databases, we will select <span class="packt_screen">yes</span> for the second level hibernate cache:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/2b6f1490-0960-4328-ba4d-38618a10e329.png"/></div>
<p>Then,<span> we will select</span> <span class="packt_screen"><span>Gr</span>adle<span> for building the backend</span></span><span>. We have an option to select <span class="packt_screen">Gradle</span> for the backend development:</span></p>
<div class="CDPAlignCenter CDPAlign"><span><img src="assets/a48dce56-58d2-4880-b47e-8d93dc072e52.png"/></span></div>
<p class="mce-root">Then, we can select any other additional technologies that we need to use. JHipster provides an option to select Elasticsearch, using Hazelcast for clustered applications, WebSockets, and Swagger Codegen for API-based development and Kafka-based asynchronous messaging. We will select <span>WebSockets</span> here, similar to what we used in our monolithic store:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/d69c4e3c-e728-47eb-a145-37edc6a2c490.png"/></div>
<p>Since our gateway application needs a user interface, for the next question we can choose the framework that we need to use for the client. We will select <kbd>Angular 5</kbd> for this:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/419cca66-7b4e-449d-9c6b-76a92e9b7be8.png"/></div>
<p>Then, we will select whether we need to use a SASS-based preprocessor for the CSS. We will use SASS here, so we will select <span class="packt_screen">y</span>:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/352fdcac-4156-4c4c-a5ae-71e47f12cd1d.png"/></div>
<p>Then, we will select whether we need to enable internationalization support. We will select <span class="packt_screen">yes</span> for this:</p>
<div class="CDPAlignCenter CDPAlign"><span><img src="assets/0fc1836a-ec40-47ce-a0fd-bd32b0218efc.png"/></span></div>
<p>Then, we will choose <span class="packt_screen">English</span> as our native language:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/c5173b16-8f5f-4751-a6e1-6eee2d2e5b3a.png"/></div>
<p>Then, choose any other additional languages:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="190" src="assets/166821e5-0441-48ac-99fa-6571be79b2f2.png" width="529"/></div>
<p>Then, select any other testing frameworks, such as Gatling, Cucumber, and/or Protractor, since this is required. We will select <span class="packt_screen">Protractor</span> as the testing tool:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="158" src="assets/9732311a-69d6-4d73-961d-51b0660747fc.png" width="530"/></div>
<p>Finally, JHipster asks us to install any other generators from the marketplace; we will select no here:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="145" src="assets/d93c0cd7-4a57-4c2b-b0a4-69e9472ef74e.png" width="532"/></div>
<p>This will create all the necessary files and install the frontend dependencies using Yarn: </p>
<div class="CDPAlignCenter CDPAlign"><img height="166" src="assets/6135ec47-8d4a-4998-b5d6-4ae12bb2c9b0.png" width="313"/></div>
<p>Now, our gateway application is generated. <span>JHipster will automatically commit the generated files to Git; if you wish to do this step yourself, you can do so by passing the</span> <kbd>skip-git</kbd> <span>flag during execution, for example, </span><kbd>jhipster --skip-git</kbd><span>, and executing the steps manually as follows:</span></p>
<pre><strong>&gt; git init</strong><br/><strong>&gt; git add --all</strong><br/><strong>&gt; git commit -am "converted into gateway application"</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Gateway configuration</h1>
                </header>
            
            <article>
                
<div>
<p>The gateway application is generated in a similar fashion to the monolithic application, except for configurations related to Zuul proxy, Eureka Client, and Hystrix:</p>
</div>
<pre>@ComponentScan<br/>@EnableAutoConfiguration(exclude = {MetricFilterAutoConfiguration.<span>class</span>, MetricRepositoryAutoConfiguration.<span>class</span>, MetricsDropwizardAutoConfiguration.<span>class</span>})<br/>@EnableConfigurationProperties({LiquibaseProperties.<span>class</span>, ApplicationProperties.<span>class</span>})<br/><strong>@EnableDiscoveryClient</strong><br/><strong>@EnableZuulProxy</strong><br/><span>public class </span>GatewayApp {<br/>...<br/>}</pre>
<p>We have selected the JHipster registry for our registry service. This will be a standalone registry server which other<span> </span>microservice<span> </span>applications and gateways will register itself:</p>
<ul>
<li><kbd>@EnableDiscoveryClient</kbd> is added to Spring Boot's main class, which will enable the Netflix Discovery Client. The microservice applications and gateways need to register themselves to the registry service. It uses Spring Cloud's discovery client abstraction to interrogate its own host and port, and then adds them to the registry server.</li>
<li><span>Zuul, on the other hand, is the gatekeeper. This helps route the authorized requests to the respective endpoints, limits the requests per route, and relays the necessary tokens to the microservice application. </span></li>
<li><kbd>@EnableZuulProxy</kbd> helps the microservice gateway application route the requests to the applicable microservice application based on the configurations provided in the <kbd>application.yml</kbd>:</li>
</ul>
<pre style="padding-left: 60px"><span>zuul: </span><span># those values must be configured depending on the application specific needs<br/></span><span>    </span><span>host:<br/></span><span>        max-total-connections: </span>1000<br/>        <span>max-per-route-connections: </span>100<br/>    <span>semaphore:<br/></span><span>        max-semaphores: </span>500</pre>
<p>In the gateway app, we have specified the aforementioned settings  for Zuul configuration. The maximum number of total connections that a proxy can hold open is kept at <kbd>1000</kbd>. The maximum number of route connections that a proxy can hold open is kept at <kbd>100</kbd>. Semaphore is kept to a maximum of <kbd>500</kbd>. (Semaphore is like a counter that is used for synchronization between threads and processes.)</p>
<p>Access to the backend microservice endpoint is controlled by <kbd>AccessControlFilter</kbd>, which will check whether the request is authorized, and is allowed to request the endpoint:</p>
<pre><span>public class </span>AccessControlFilter <span>extends </span>ZuulFilter {<br/>     ...<br/>     public boolean shouldFilter() {<br/>       ...<br/>       return !isAuthorizedRequests(serviceUrl, serviceName, <br/>       requestUri);<br/>     }<br/>    ...<br/>}</pre>
<p>Zuul, as a gatekeeper, also acts as a rate limiter. A rate-limiting filter is added to the generated application, which limits the number of HTTP calls that are made per client. This is enabled conditionally with:</p>
<pre><span>@ConditionalOnProperty</span>(<span>"jhipster.gateway.rate-limiting.enabled"</span>)<br/>public static class RateLimitingConfiguration { <br/>... <br/>}</pre>
<p><kbd>SwaggerBasePathRewritingFilter</kbd> is also used, which will help to rewrite the microservice Swagger URL base path:</p>
<pre><span>@Component<br/></span><span>public</span><span> </span><span>class</span><span> </span><span>SwaggerBasePathRewritingFilter</span><span> </span><span>extends</span><span> </span><span>SendResponseFilter</span><span> {<br/></span><span>    @Override<br/></span><span>    public</span><span> </span><span>Object</span><span> </span><span>run</span><span>() {<br/></span><span>        RequestContext</span><span> </span><span>ctx</span><span> </span><span>=</span><span> </span><span>RequestContext</span><span>.</span><span>getCurrentContext</span><span>();<br/>        if(!context.getResponseGzipped()) {<br/>            context.getResponse().setCharacterEncoding("UTF-8");<br/>        }<br/></span><span>        // rewrite the base path and send down the response<br/></span><span>    }<br/>...</span></pre>
<p>A <kbd>TokenRelayFilter</kbd> is added to remove the authorization from Zuul's ignore list. This will help to propagate the generated authorization token:</p>
<div>
<pre><span>@Component<br/></span><span>public</span><span> </span><span>class</span><span> </span><span>TokenRelayFilter</span><span> </span><span>extends</span><span> </span><span>ZuulFilter</span><span> {<br/></span><span>    @Override<br/></span><span>    public</span><span> </span><span>Object</span><span> </span><span>run</span><span>() {<br/></span><span>        RequestContext</span><span> </span><span>ctx</span><span> </span><span>=</span><span> </span><span>RequestContext</span><span>.</span><span>getCurrentContext</span><span>();<br/></span><span>        Set</span><span>&lt;</span><span>String</span><span>&gt; </span><span>headers</span><span> </span><span>=</span><span> (</span><span>Set</span><span>&lt;</span><span>String</span><span>&gt;</span><span>) </span><span>ctx</span><span>.</span><span>get</span><span>(</span><span>"ignoredHeaders"</span><span>);<br/></span><span>        // JWT tokens should be relayed to the resource servers<br/></span><span>        headers</span><span>.</span><span>remove</span><span>(</span><span>"authorization"</span><span>);<br/></span><span>        return</span><span> </span><span>null</span><span>;<br/></span><span>    }<br/>...</span></pre></div>
<p>Each application should have a Eureka client that helps load balance the requests among the services, as well as sending health information to the Eureka Server or registries. The Eureka client is configured in <kbd>application-dev.yml</kbd> as follows:</p>
<pre><span>eureka:<br/></span><span>    client:<br/></span><span>        enabled: </span>true<br/>        <span>healthcheck:<br/></span><span>            enabled: </span>true<br/>        <span>fetch-registry: </span>true<br/>        <span>register-with-eureka: </span>true<br/>        <span>instance-info-replication-interval-seconds: </span>10<br/>        <span>registry-fetch-interval-seconds: </span>10<br/>    <span>instance:<br/></span><span>        appname: </span>gateway<br/>        <span>instanceId: </span>gateway:${<span>spring.application.instance-id:${random.value}</span>}<br/>        <span>lease-renewal-interval-in-seconds: </span>5<br/>        <span>lease-expiration-duration-in-seconds: </span>10<br/>        <span>status-page-url-path: </span>${<span>management.context-path</span>}/info<br/>        <span>health-check-url-path: </span>${<span>management.context-path</span>}/health<br/>        <span>metadata-map:<br/></span><span>            zone: </span>primary <span># This is needed for the load balancer<br/></span><span>            </span><span>profile: </span>${<span>spring.profiles.active</span>}<br/>            <span>version: </span>${<span>info.project.version</span>}</pre>
<p>We have chosen to enable health checks and have the interval to register and replicate be within <kbd>10</kbd> seconds, as well as instances where we define the lease renewal interval and expiration duration. </p>
<p>We will configure timeout in Hystrix, beyond which the server is considered to be closed:</p>
<pre><span>hystrix:<br/></span><span>    command:<br/></span><span>        default:<br/></span><span>            execution:<br/></span><span>                isolation:<br/></span><span>                    thread:<br/></span><span>                        timeoutInMilliseconds: </span>10000</pre>
<p>If the server does not respond within <kbd>10</kbd> seconds, then the server is considered dead and is registered in the registry service. This makes sure no subsequent requests are sent to that server until the server is made active.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JWT authentication</h1>
                </header>
            
            <article>
                
<p>We need to transfer information between microserves securely. The requests must be verified and signed digitally, where the applications verify the authenticity of the requests and respond to them. </p>
<p>We need to have a compact way to handle this information in the REST or HTTP world, since the information is required to be sent with each request. JWT is here to help. JWT is basically JSON web tokens in an open web standard that helps to securely transfer information between parties (applications). <span>JWT will be signed using a secret, based on the HMAC algorithm, or with a public/private key. They are compact and self-contained.</span></p>
<div class="packt_infobox">For advanced uses, we need to add Bouncy Castle (<a href="https://en.wikipedia.org/wiki/Bouncy_Castle_(cryptography)">librarieshttps://en.wikipedia.org/wiki/Bouncy_Castle_(cryptography)</a>).</div>
<p><strong>Compact</strong>: They are small and can be sent to each request.</p>
<p><strong>Self-contained</strong>: The payload contains all the necessary details about the user, which prevents us from querying the database for user authentication.</p>
<p>JWT consists of the header, payload, and signature. They are base64 encoded strings, separated by <kbd>.</kbd> (a period):</p>
<pre>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IlNlbmRpbCBLdW1hciBOIiwiYWRtaW4iOnRydWV9.ILwKeJ128TwDZmLGAeeY7qiROxA3kXiXOG4MxTQVk_I</pre>
<pre class="pre-encode HS256">#Algorithm for JWT generation<br/>HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  
)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How JWT works</h1>
                </header>
            
            <article>
                
<p><span>When a user logs in to the system, a token is generated based on the payload (that is, the user information and secret key). The generated token is stored locally. For all future requests, this token is added to the request and the application will validate the token before responding to the request:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/06f4754b-3f61-4656-ba67-e7feac2d7197.jpg"/></div>
<p>The token will be in this format:</p>
<pre><span>Authorization: Bearer &lt;token&gt;</span></pre>
<p>In JHipster, we use <strong>JJWT</strong> (<strong>Java-based JSON Web Tokens</strong>) from Okta. This is a simplified builder pattern-based library used to generate and sign the token as a producer, and parse and validate the token as a consumer.</p>
<p><strong>Creating the token</strong>:</p>
<pre><span>public class TokenProvider {<br/>  ...<br/>    public </span>String createToken(Authentication authentication, Boolean rememberMe) {<br/>        ...<br/><br/>        <span>return </span>Jwts.<span>builder</span>()<br/>            .setSubject(authentication.getName())<br/>            .claim(<span>AUTHORITIES_KEY</span>, authorities)<br/>            .signWith(SignatureAlgorithm.<span>HS512</span>, <span>secretKey</span>)<br/>            .setExpiration(validity)<br/>            .compact();<br/>    }<br/>}</pre>
<p><strong>Validating the token</strong>: </p>
<pre><span>public boolean </span>validateToken(String authToken) {<br/>    <span>try </span>{<br/>        Jwts.<span>parser</span>().setSigningKey(<span>secretKey</span>).parseClaimsJws(authToken);<br/>        <span>return true</span>;<br/>    } <span>catch </span>(SignatureException e) {<br/>        <span>log</span>.info(<span>"Invalid JWT signature."</span>);<br/>        <span>log</span>.trace(<span>"Invalid JWT signature trace: {}"</span>, e);<br/>    } <span>catch </span>(MalformedJwtException e) {<br/>        <span>log</span>.info(<span>"Invalid JWT token."</span>);<br/>        <span>log</span>.trace(<span>"Invalid JWT token trace: {}"</span>, e);<br/>    } <span>catch </span>(ExpiredJwtException e) {<br/>        <span>log</span>.info(<span>"Expired JWT token."</span>);<br/>        <span>log</span>.trace(<span>"Expired JWT token trace: {}"</span>, e);<br/>    } <span>catch </span>(UnsupportedJwtException e) {<br/>        <span>log</span>.info(<span>"Unsupported JWT token."</span>);<br/>        <span>log</span>.trace(<span>"Unsupported JWT token trace: {}"</span>, e);<br/>    } <span>catch </span>(IllegalArgumentException e) {<br/>        <span>log</span>.info(<span>"JWT token compact of handler are invalid."</span>);<br/>        <span>log</span>.trace(<span>"JWT token compact of handler are invalid trace: {}"</span>, e);<br/>    }<br/>    <span>return false</span>;<br/>}</pre>
<p>So far, we have created a gateway application, which will serve as a single point of entry for our application and services. Now, we will generate a microservice application using JHipster.</p>
<p>Microservice applications are <em>the</em> services. We will construct two sample services in this book and discuss the features that JHipster offers, one with the SQL database (MySQL) and the other with the NoSQL database (MongoDB). These services are individual and loosely coupled. </p>
<p>With JHipster, you can build microservice applications serving as REST endpoints. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microservice application -  Invoice Service with MySQL database</h1>
                </header>
            
            <article>
                
<p>We can take the invoice service from our monolithic application, separate it, and make them separate microservice applications. Let's name it <kbd>Invoice Service</kbd>. This service is responsible for creating and tracking invoices. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application generation</h1>
                </header>
            
            <article>
                
<p>First, let's see how we can generate a microservices application. In the <kbd>e-commerce-app</kbd> folder, create a new folder where you will keep the microservices application. Let's name the folder <kbd>invoice</kbd>. Go into the directory and start creating the application by typing <kbd>jhipster</kbd>.</p>
<p>The first question we are asked is to select the type of application we would like to create. We have to choose <span class="packt_screen">Microservice application</span> and then click <em>Enter</em>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="73" src="assets/4e17b905-7db2-486e-bcbb-3b66de4aee72.png" width="418"/></div>
<p>Then, you need to give a base name to your application. We will go with the default application name, <kbd>invoice</kbd> (by default, JHipster selects a folder name the same as the application name):</p>
<div class="CDPAlignCenter CDPAlign"><img height="24" src="assets/9fd3d888-bb65-4f1c-8584-cc23c1f133ab.png" width="470"/></div>
<p>Then, we will select the default port in which the application has to run. By default, JHipster prompts <kbd>8081</kbd> as the default port for microservices, since we use <kbd>8080</kbd> for the gateway application:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8017b65a-03b6-4170-8285-9eba66127c9f.png"/></div>
<p>Then, we will select the default package name:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/46ad4bf4-8b4d-49b7-8efc-5ae201772ab8.png"/></div>
<p>Since we have selected <span class="packt_screen">JHipster Registry</span> for the gateway application, we will select the same here. Similarly, if we selected <span class="packt_screen">Consul</span> for the gateway application, then we can select <span class="packt_screen">Consul</span>. We can even choose to have no registry and then add any custom registry there:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c801cc1d-6ed1-4fc2-abaa-eb2a625a2efc.png"/></div>
<p>Then, JHipster asks for the type of authentication that we would like to use. We will select JWT authentication, the same as we have selected for the gateway application:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0edeebcc-c85f-4b4c-a6f3-1d7a16cd319b.png"/></div>
<p>Then, select the type of database that we need to have. As highlighted, the invoice service will have the SQL database. We will select the <span class="packt_screen">SQL</span> option. JHipster provides an option to opt out of the database itself. When <span class="packt_screen">No database</span> is selected, the application is generated with no database connection:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c9bac2b4-739a-42ba-a709-0a6e3677a425.png"/></div>
<p>We will select the production database as <span class="packt_screen">MySQL</span>: </p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/38ca070e-3f68-4f09-b85a-c3d79ffb1eb5.png"/></div>
<p>We will then select the development database as <span class="packt_screen">H2 with disk-based persistence</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8d9676cd-e413-4466-860e-d0f631aeef24.png"/></div>
<p>Then, we will select <span class="packt_screen">HazelCast</span> cache as t<span>he Spring </span>cache abstraction. Hazelcast provides a shared cache among all sessions. It is possible to hold the persistent data across the cluster or at the JVM level. We can have different modes available, with single or multiple nodes. </p>
<p>Ehcache is a local cache and it is useful for storing information in a single node. Infinispan and HazelCast are capable of creating a cluster and sharing information among multiple nodes, with HazelCast using a distributed cache, each of them connected together. On the other hand, Inifinispan is a hybrid cache:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0835f7db-0939-4f5c-9af0-d9e5e23d9e3c.png"/></div>
<p>Then, we will choose <span class="packt_screen">Hibernate 2nd level cache</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/34d9625d-60b7-49dc-9915-5b3bf5adf143.png"/></div>
<p>We will select <span class="packt_screen">Gradle</span> for the build tool:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4f3a071c-bb09-4dbe-bfca-97b757a55100.png"/></div>
<p>Then, JHipster asks whether we have any other technologies that we would like to add. We will not select anything here and go with the default option:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/79e8b6a6-5547-431e-a07b-0c6f758d6aab.png"/></div>
<p>Then, we will opt to have <strong>internationalization</strong> (<strong>i18n</strong>):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8de93a2f-1f4e-4ff9-ae80-4d674117f23b.png"/></div>
<p>And then, we will select <span class="packt_screen">English</span> as the default option:</p>
<div class="CDPAlignCenter CDPAlign"><img height="170" src="assets/cee1b70b-d3d7-4908-9ad1-3077b6a6c761.png" width="530"/></div>
<p>And select the additional languages that we need:</p>
<div class="CDPAlignCenter CDPAlign"><img height="174" src="assets/590fd2e0-1caf-4c0c-a854-252000be3ad4.png" width="530"/></div>
<p>Then, select any other testing frameworks that we would like to add to Gatling or Cucumber. Note that since it will not generate a frontend application, options such as Protractor are not listed:</p>
<div class="CDPAlignCenter CDPAlign"><img height="144" src="assets/d055b131-1c63-4e08-84e4-613406808f4b.png" width="530"/></div>
<p>Finally, we will select any other generators that we need to install from the JHipster marketplace. Currently, we will not select any other generators (default option):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d8a4d1f5-1b1a-48ff-aceb-3c8860351241.png"/></div>
<p>Then, the server application is generated:</p>
<div class="CDPAlignCenter CDPAlign"><img height="77" src="assets/8d34b1df-4ba3-4ec6-bb2f-c67a21fcb26b.png" width="328"/></div>
<p>Our microservice application is generated. <span>JHipster will automatically commit the generated files to Git. If you wish to do this step yourself, you can do so by passing the </span><kbd>skip-git</kbd><span> flag during execution, for example, </span><kbd>jhipster --skip-git</kbd><span>, and executing the steps manually as follows:</span></p>
<pre><strong>&gt; git init</strong><br/><strong>&gt; git add --all</strong><br/><strong>&gt; git commit -am "generated invoice microservice application"</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microservice configuration</h1>
                </header>
            
            <article>
                
<p>The application that is generated will not feature any frontend. Again, the invoice service is a Spring Boot-based application. The security features are configured in <kbd>MicroserviceSecurityConfiguration.java</kbd><em>.</em></p>
<p>Ignore all the frontend related requests, so whenever a user tries to reach any frontend-related resources such as HTML, CSS, and JS, the request will be ignored by the invoice service:</p>
<pre><span>@Override<br/></span><span>public void </span>configure(WebSecurity web) <span>throws </span>Exception {<br/>    web.ignoring()<br/>        .antMatchers(HttpMethod.<span>OPTIONS</span>, <span>"/**"</span>)<br/>        .antMatchers(<span>"/app/**/*.{js,html}"</span>)<br/>        .antMatchers(<span>"/bower_components/**"</span>)<br/>        .antMatchers(<span>"/i18n/**"</span>)<br/>        .antMatchers(<span>"/content/**"</span>)<br/>        .antMatchers(<span>"/swagger-ui/index.html"</span>)<br/>        .antMatchers(<span>"/test/**"</span>)<br/>        .antMatchers(<span>"/h2-console/**"</span>);<br/>}</pre>
<p>Since the services are independent, they can be deployed and run on another server with a different IP address. This requires us to disable <strong>CSRF</strong> (<strong>Cross Site Request Forgery</strong>) by default. We will also enable the STATELESS session policy in session management. This makes our application unable to create or maintain any sessions. Every request is authenticated and authorized based on the token.</p>
<p>We will also use the STATELESS session policy in session management. This is the strictest session policy available. This will not allow our application to generate a session, and so our requests have to have the (time-bound) tokens attached to each and every request. This enhances the security of our services. Their stateless constraint is another advantage of using REST APIs.</p>
<div class="packt_infobox">For more options and information on session policies, please look at the following documentation:  <a href="https://docs.spring.io/autorepo/docs/spring-security/4.2.3.RELEASE/apidocs/org/springframework/security/config/http/SessionCreationPolicy.html">https://docs.spring.io/autorepo/docs/spring-security/4.2.3.RELEASE/apidocs/org/springframework/security/config/http/SessionCreationPolicy.html</a>.</div>
<p>Then, all API-related requests and Swagger resources should be allowed once the request is authorized (based on the JWT token):</p>
<pre><span>@Override<br/></span><span>protected void </span>configure(HttpSecurity http) <span>throws </span>Exception {<br/>    http<br/>        .csrf()<br/>        .disable()<br/>        .headers()<br/>        .frameOptions()<br/>        .disable()<br/>    .and()<br/>        .sessionManagement()<br/>        .sessionCreationPolicy(SessionCreationPolicy.<span>STATELESS</span>)<br/>    .and()<br/>        .authorizeRequests()<br/>        .antMatchers(<span>"/api/**"</span>).authenticated()<br/>        .antMatchers(<span>"/management/health"</span>).permitAll()<br/>        .antMatchers(<span>"/management/**"</span>).hasAuthority(AuthoritiesConstants.<span>ADMIN</span>)<br/>        .antMatchers(<span>"/swagger-resources/configuration/ui"</span>).permitAll()<br/>    .and()<br/>        .apply(securityConfigurerAdapter());<br/>}</pre>
<p>On the resource side, in <kbd>bootstrap.yml</kbd>, we have defined the registry-related information.</p>
<p>Our current microservice application uses the JHipster registry as the registry service in order to register and deregister their existence in a heartbeat. We need to provide the password of our registry service with which the application can connect to the registry service:</p>
<pre><span>jhipster:<br/></span><span>    registry:<br/></span><span>        password: </span>admin</pre>
<p>Also, the name of the Spring Boot service and the default Spring Cloud Config parameters are enabled in the <kbd>bootstrap.yml</kbd>. We have also added the URI that we have to connect in order to fetch the configuration of the registry service:</p>
<pre><span>spring:<br/></span><span>    application:<br/></span><span>        name: </span>invoice<br/>        ...<br/><span>    </span><span>cloud:<br/></span><span>        config:<br/></span><span>            fail-fast: </span>false <span># if not in "prod" profile, do not force to use Spring Cloud Config<br/></span><span>            </span><span>uri: </span>http://admin:${<span>jhipster.registry.password</span>}@localhost:8761/config<br/>            <span># name of the config server's property source (file.yml) that we want to use<br/></span><span>            </span><span>name: </span>invoice<br/>            ...<span><br/></span></pre>
<p>Similar to the gateway, the rest of the service-related configurations are done in the <kbd>application.yml</kbd> file. </p>
<p>The Eureka configuration is exactly the same as in the gateway application. All the generated applications will have a similar Eureka configuration:</p>
<pre><span>eureka:<br/></span><span>    client:<br/></span><span>        enabled: </span>true<br/>        <span>healthcheck:<br/></span><span>            enabled: </span>true<br/>        <span>fetch-registry: </span>true<br/>        <span>register-with-eureka: </span>true<br/>        <span>instance-info-replication-interval-seconds: </span>10<br/>        <span>registry-fetch-interval-seconds: </span>10<br/>    <span>instance:<br/></span><span>        appname: </span>invoice<br/>        <span>instanceId: </span>invoice:${<span>spring.application.instance-id:${random.value}</span>}<br/>        <span>lease-renewal-interval-in-seconds: </span>5<br/>        <span>lease-expiration-duration-in-seconds: </span>10<br/>        <span>status-page-url-path: </span>${<span>management.context-path</span>}/info<br/>        <span>health-check-url-path: </span>${<span>management.context-path</span>}/health<br/>        <span>metadata-map:<br/></span><span>            zone: </span>primary <span># This is needed for the load balancer<br/></span><span>            </span><span>profile: </span>${<span>spring.profiles.active</span>}<br/>            <span>version: </span>${<span>info.project.version</span>}</pre>
<p>The database and JPA configurations are made:</p>
<pre><span>spring:<br/></span><span>    profiles:<br/></span><span>        active: </span>dev<br/>    ...<br/>    <span>datasource:<br/></span><span>        type: &lt;connector jar&gt;</span><br/>        <span>url: &lt;db url&gt;</span><br/>        <span>username: &lt;username&gt;</span><br/>        <span>password: &lt;password&gt;<br/>    ...<br/></span>    <span>jpa:<br/></span><span>        database-platform: &lt;DB platform&gt;</span><br/>        <span>database: &lt;H2 or MySQL or any SQL database&gt;</span><br/>        <span>show-sql: </span>true<br/>        <span>properties:<br/></span><span>            hibernate.id.new_generator_mappings: </span>true<br/>            <span>hibernate.cache.use_second_level_cache: </span>true<br/>            <span>hibernate.cache.use_query_cache: </span>false<br/>            <span>hibernate.generate_statistics: </span>true<br/>            <span>hibernate.cache.region.factory_class: </span>com.hazelcast.hibernate.HazelcastCacheRegionFactory<br/>            <span>hibernate.cache.hazelcast.instance_name: </span>invoice<br/>            <span>hibernate.cache.use_minimal_puts: </span>true<br/>            <span>hibernate.cache.hazelcast.use_lite_member: </span>true</pre>
<p>The rest of the configurations remain similar to what was generated in the gateway application, and they can be tweaked or customized based on your requirements.</p>
<p>Now, we can boot up the application alongside the gateway application and registry service. Since the application tries to connect to the registry service first, if there is no registry service available at the specified location, then the application will not know where to connect and whom to respond to. </p>
<p>Thus, the invoice service is generated. Now, we can generate a notification service with NoSQL as the backend database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microservice application - notification service with NoSQL database</h1>
                </header>
            
            <article>
                
<p>For an e-commerce website, it is really essential that orders are tracked and users are notified at the right moment. We will create a notification service which will notify users whenever their order status changes. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application generation</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's generate our second microservice application (notification service) in the <kbd>e-commerce-app</kbd><span> folder. Cr</span>eate a new folder where you will keep the microservices application. Let's name the folder <kbd>notification</kbd>. Go into the directory and start creating the application by running <kbd>jhipster</kbd>.</p>
<p>The first question we are asked is to select the type of application we would like to create. We have to choose <span class="packt_screen">Microservice application</span> and then click <em>Enter</em>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="72" src="assets/178c818e-593f-495b-9e30-6c70f754d4c1.png" width="400"/></div>
<p>Then, we will select the default application name, <kbd>notification</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="29" src="assets/54fbf7a7-c148-41ba-8002-1be2d6173916.png" width="503"/></div>
<p>Then, we will select the port for the application. Since we have selected <kbd>8080</kbd> for the monolithic application and <kbd>8081</kbd> for the invoice service, we will use port <kbd>8082</kbd> for the notification service:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1ac1b9cd-bb3e-41d8-b3d2-1265b8987630.png"/></div>
<p>For the next three questions, we will use the same options as we did previously:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d475c013-8d0b-43fc-91f5-c874a3d462c6.png"/></div>
<p>Then, we will select <span class="packt_screen">MongoDB</span> as the database. After selecting <span class="packt_screen">MongoDB</span>, JHipster will now ask for the different types of database you would like to use for the development and production servers. We will use MongoDB as both the development and production database:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/ccad6fc7-b2c4-454d-bd26-75100bde78b0.png"/></div>
<p>For the remaining questions, we will select options that are similar to what we chose for the invoice service:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/546e532b-012d-4490-851d-0b35940b89e0.png"/></div>
<p class="mce-root"><span>The server is generated successfully:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="79" src="assets/290c5027-31e8-4cc1-a49d-003da91c9138.png" width="310"/></div>
<p>Our microservice application is generated. <span>JHipster will automatically commit the generated files to Git. If you wish to do this step yourself, you can do so by passing the </span><kbd>skip-git</kbd><span> flag during execution, for example, </span><kbd>jhipster --skip-git</kbd><span>, and executing the steps manually as follows:</span></p>
<pre><strong>&gt; git init</strong><br/><strong>&gt; git add --all</strong><br/><strong>&gt; git commit -am "generated notification microservice application"</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Microservice configuration</h1>
                </header>
            
            <article>
                
<p>The application is finally generated, since we have selected similar options for both microservices. The code generated will be similar, except for the database configuration:</p>
<div class="CDPAlignCenter CDPAlign"><img height="75" src="assets/75ed1cc5-10a4-4410-b82b-17934bb4a4b8.png" width="310"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Well, we have generated a gateway application and two microservice applications in this chapter. We have shown you how easy it is to generate a microservice bundle with JHipster. Now, before we run our application, we need to kick-start our registry server.</p>
<p>In the next chapter, we will kick-start the registry server, and we will also see how to add entities to our new services.</p>


            </article>

            
        </section>
    </body></html>