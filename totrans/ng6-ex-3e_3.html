<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">More Angular – SPA and Routing</h1>
                
            
            <article>
                
<p class="calibre3">The previous chapter was about building our first useful app in Angular, then this chapter is about adding a whole lot of Angular goodness to it. Within the learning curve, we have made a start in exploring a technology platform and now we can build some rudimentary apps using Angular. But that's just the start! There is a lot more to learn before we can make effective use of Angular in a decent-sized application. This chapter takes us one step closer to realizing this goal.</p>
<p class="calibre3">The<span class="calibre6"> </span><em class="calibre17">7-Minute Workout</em><span class="calibre6"> </span>app still has some rough edges that we can fix while making the overall app experience better. This chapter is all about adding those enhancements and features. And as always, this app-building process provides us with enough opportunities to enhance our understanding of the framework and learn new things about it.</p>
<p class="calibre3">The topics we cover in this chapter include:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Exploring Angular's Single Page Applications</strong><span> </span>(<strong class="calibre1">SPAs</strong>): We explore Angular's SPA capabilities, which include route navigation, link generation, and routing events.</li>
<li class="calibre12"><strong class="calibre1">Understanding dependency injection</strong>: One of the core platform features. In this chapter, we learn how Angular makes effective use of<span> </span>dependency injection<span> </span>to inject components and services across the application.</li>
<li class="calibre12"><strong class="calibre1">Angular pure (stateless) and impure (stateful) pipes</strong>: We explore the primary data transformation construct of Angular, pipes, in more detail as we build some new pipes.</li>
</ul>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Cross-component communication</strong>: Since Angular is all about components and their interactions, we look at how to do cross-component communication in a parent-child and sibling component setup. We learn how Angular's <em class="calibre2">template variables</em><span> </span>and<span> </span><em class="calibre2">events</em><span> </span>facilitate this communication.</li>
<li class="calibre12"><strong class="calibre1">Creating and consuming events</strong>: We learn how a component can expose its own events and how to bind to these events from the HTML template and from other components.</li>
</ul>
<p class="calibre3">As a side note, I expect you are using the<span class="calibre6"> </span><em class="calibre17">7-Minute Workout</em><span class="calibre6"> </span>on a regular basis and working on your physical fitness. If not, take a seven-minute exercise break and<span class="calibre6"> </span>exercise<span class="calibre6"> </span>now. I insist!</p>
<p class="calibre3">Hope the workout was fun! Now let's get back to some serious business. Let's start<span class="calibre6"> </span>with<span class="calibre6"> </span>exploring Angular's<span class="calibre6"> </span><strong class="calibre5">Single Page Application</strong><span class="calibre6"> </span>(<strong class="calibre5">SPA</strong>) capabilities.</p>
<div class="packt_infobox">We are starting from where we left off in<span class="packt_screen"> </span><span class="packt_screen"><a href="" class="calibre21">Chapter 2</a>,<span class="packt_screen"> </span><em class="calibre31">Building Our First App - 7-Minute Workout</em></span>. The <kbd class="calibre24">checkpoint2.4</kbd> Git branch can serve as the base for this chapter. The code is also available on GitHub (<span class="packt_screen"><a href="https://github.com/chandermani/angular6byexample" class="calibre21">https://github.com/chandermani/angular6byexample</a></span>) for everyone to download. Checkpoints are implemented as branches in GitHub. If you are not using Git, download the snapshot of<span class="packt_screen"> </span><kbd class="calibre24">checkpoint2.4</kbd><span class="packt_screen"> </span>(a ZIP file) from the GitHub location: <a href="http://bit.ly/ng6be-checkpoint-2-4" class="calibre21">http://bit.ly/ng6be-checkpoint-2-4</a><span class="packt_screen"/>. Refer to the<span class="packt_screen"> </span><kbd class="calibre24">README.md</kbd><span class="packt_screen"> </span>file in the<span class="packt_screen"> </span><kbd class="calibre24">trainer</kbd><span class="packt_screen"> </span>folder when setting up the snapshot for the first time.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Exploring Single Page Application capabilities</h1>
                
            
            <article>
                
<p class="calibre3">The<span class="calibre6"> </span><em class="calibre17">7-Minute Workout</em><span class="calibre6"> </span>starts when we load the app, but it ends<span class="calibre6"> </span>with<span class="calibre6"> </span>the last exercise sticking to the screen permanently. Not a very elegant solution. Why don't we add a start and finish page to the app? This makes the app look more professional and allows us to understand the single-page nomenclature of Angular.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Angular SPA infrastructure</h1>
                
            
            <article>
                
<p class="calibre3">With modern web frameworks, such as Angular and Vue.js, we are now getting used to apps that do not perform full-page refreshes. But if you are new to this scene, it's<span class="calibre6"> </span>worth<span class="calibre6"> </span>mentioning what<span class="calibre6"> </span><em class="calibre17">SPAs</em><span class="calibre6"> </span>are.</p>
<p class="calibre3"><strong class="calibre5">Single Page Applications</strong><span class="calibre6"> </span>(<strong class="calibre5">SPAs</strong>) are browser-based apps devoid of any full-page refresh. In such apps, once the initial HTML is loaded, any future page navigations are retrieved using AJAX and HTML fragments and injected into the already loaded view. Google Mail is a great example of an SPA. SPAs<span class="calibre6"> </span>make for a great user experience as the user gets a desktop app-like feel, with no constant post-backs and page refreshes, which are typically associated with traditional web apps.</p>
<p class="calibre3">Like any modern JavaScript framework, Angular also provides the necessary constructs for SPA implementation. Let's understand them and add our app pages too.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Angular routing</h1>
                
            
            <article>
                
<p class="calibre3">Angular supports SPA development<span class="calibre6"> </span>using<span class="calibre6"> </span>its<span class="calibre6"> </span><strong class="calibre5">routing infrastructure</strong>. This infrastructure tracks browser URLs, enables hyperlink generation, exposes routing events, and provides a set of directives/components for views that react to URL changes.</p>
<p class="calibre3">There are four major<span class="calibre6"> </span>framework<span class="calibre6"> </span>pieces that work together to support the Angular routing infrastructure:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">The Router (Router)</strong>: The primary infrastructure piece that actually provides component navigation</li>
<li class="calibre12"><strong class="calibre1">The Routing configuration (Route)</strong>: The component<span> </span>router<span> </span>is dependent upon the routing configuration for setting up routes</li>
<li class="calibre12"><strong class="calibre1">The RouterOutlet component</strong>: The<span> </span><kbd class="calibre13">RouterOutlet</kbd><span> </span>component is the<span> </span>placeholder<span> </span>container (<em class="calibre2">host</em>) where route-specific views are loaded</li>
<li class="calibre12"><strong class="calibre1">The RouterLink directive</strong>: This generates hyperlinks that<span> </span>can<span> </span>be embedded in the anchor tags for navigation</li>
</ul>
<p class="calibre3">The following diagram highlights the roles these components play within the routing setup:</p>
<div class="packt_figure"><img src="../images/00021.jpeg" class="calibre43"/></div>
<p class="calibre3">I highly encourage everyone to keep revisiting this diagram as we set up routing for<span class="calibre6"> </span><em class="calibre17">7-Minute Workout</em>.</p>
<p class="calibre3"><em class="calibre17">The router</em><span class="calibre6"> </span>is the central piece of this complete setup; therefore a quick overview of the router will be helpful.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Angular router</h1>
                
            
            <article>
                
<p class="calibre3">If you have worked with<span class="calibre6"> </span>any<span class="calibre6"> </span>JavaScript framework with SPA support, this is how things work. The framework watches the browser URL and serves views based on the URL loaded. There are dedicated framework components for this job. In the<span class="calibre6"> </span>Angular<span class="calibre6"> </span>world, this tracking is done by a<span class="calibre6"> </span><em class="calibre17">framework service</em>,<span class="calibre6"> </span><strong class="calibre5">the router</strong>.</p>
<div class="packt_infobox">In Angular, any class, object, or function that provides some generic functionality is termed a<span class="packt_screen"> </span><strong class="calibre26">service</strong>.<span class="packt_screen"> </span><em class="calibre31">Angular does not provide any special construct to declare a service as it does for components, directives, and pipes</em>. Anything that can be consumed by components/directives/pipes can be termed a service. The router is one such service. And there are many more services that are part of the framework.<span class="packt_screen"> </span><em class="calibre31">If you are from the Angular 1 realm, this is a pleasant surprise-no service, factory, provider, value, or constant!</em></div>
<p class="calibre3">The Angular router is there to:</p>
<ul class="calibre11">
<li class="calibre12">Enable navigation between components on route change</li>
<li class="calibre12">Pass routing data between component views</li>
<li class="calibre12">Make the state of the current route available to active/loaded components</li>
<li class="calibre12">Provide APIs that allow navigation from component code</li>
<li class="calibre12">Track the navigation history, allowing us to move back and forward between component views using browser buttons</li>
<li class="calibre12">Provide life cycle events and guard conditions that allow us to affect navigation based on some external factors</li>
</ul>
<div class="packt_infobox">The router also supports some advanced routing concepts, such as parent-child routes. This gives us the ability to define routes at multiple levels inside the component tree. The parent component can define routes and child components can further add more sub-routes to the parent route definition. This is something that we cover in detail in<span class="packt_screen"> </span><a href="" class="calibre21">Chapter 4</a>,<span class="packt_screen"> </span><em class="calibre31">Building<span class="packt_screen"> </span>Personal Trainer</em>.</div>
<p class="calibre3">The router does not work alone. As highlighted in the preceding diagram, it depends upon other framework pieces to achieve the desired results. Let's add some app pages and work with each piece of the puzzle.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Routing setup</h1>
                
            
            <article>
                
<p class="calibre3">The<span class="calibre6"> </span>Angular<span class="calibre6"> </span>router is not part of the core Angular framework. It has a separate Angular module and its own npm package. Angular CLI has already installed this package as part of the project setup. Look at<span class="calibre6"> </span><kbd class="calibre13">package.json</kbd><span class="calibre6"> </span>to confirm this:</p>
<pre class="calibre19">"@angular/platform-browser-dynamic": "6.0.0",<strong class="calibre1"><br class="title-page-name"/>"@angular/router": "6.0.0",</strong></pre>
<p class="calibre3">Since the router is already installed, we just need to integrate it into<span class="calibre6"> </span><em class="calibre17">7-Minute Workout</em>.</p>
<p class="calibre3">We can start by adding the  <kbd class="calibre13">base</kbd><span class="calibre6"> </span>reference (highlighted) to the<span class="calibre6"> </span><kbd class="calibre13">head</kbd><span class="calibre6"> </span>section of<span class="calibre6"> </span><kbd class="calibre13">index.html</kbd>, if not present:</p>
<pre class="calibre19">&lt;title&gt;Trainer&lt;/title&gt;<br class="title-page-name"/><strong class="calibre1">&lt;base href="/"&gt;</strong></pre>
<p class="calibre3"><em class="calibre17">The router requires<span class="calibre6"> </span><kbd class="calibre13">base href</kbd><span class="calibre6"> </span>to be set.</em><span class="calibre6"> </span>The<span class="calibre6"> </span><kbd class="calibre13">href</kbd><span class="calibre6"> </span>value specifies the base URL to use for all relative URLs within an HTML document, including links to CSS, scripts, images, and any other resource. This setting helps the router to create navigation URLs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding start and finish pages</h1>
                
            
            <article>
                
<p class="calibre3">The plan here is to have three pages for<span class="calibre6"> </span><em class="calibre17">7-Minute Workout</em>:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Start page</strong>: This becomes the landing<span> </span>page<span> </span>for the app</li>
<li class="calibre12"><strong class="calibre1">Workout page</strong>: What we have currently</li>
<li class="calibre12"><strong class="calibre1">Finish page</strong>: We navigate to this once the<span> </span>workout<span> </span>is complete</li>
</ul>
<p class="calibre3">The workout<span class="calibre6"> </span>component<span class="calibre6"> </span>and its view (<kbd class="calibre13">workout-runner.component.ts</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">workout-runner.component.html</kbd>) are<span class="calibre6"> </span>already<span class="calibre6"> </span>there. So let's create<span class="calibre6"> </span><kbd class="calibre13">StartComponent</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">FinishComponent</kbd>.</p>
<p class="calibre3">Again, using the Angular CLI generates the boilerplate for the start and finish components. Navigate to the <kbd class="calibre13">trainer/src/app</kbd><span class="calibre6"> </span>folder and execute the component-generation command:</p>
<pre class="calibre19"><strong class="calibre1">ng generate component start -is</strong><br class="title-page-name"/><strong class="calibre1">ng generate component finish -is</strong></pre>
<p class="calibre3">Next, copy the views for the <em class="calibre17">start</em><span class="calibre6"> </span>and<span class="calibre6"> </span><em class="calibre17">finish</em><span class="calibre6"> </span>components from the <kbd class="calibre13">checkpoint3.1</kbd> Git branch (the GitHub location to download from is<span class="calibre6"> </span><a href="http://bit.ly/ng6be-3-1-app" class="calibre10"><span>http://bit.ly/ng6be-3-1-app</span></a>).</p>
<p class="calibre3">Both the <em class="calibre17">start</em><span class="calibre6"> </span>and<span class="calibre6"> </span><em class="calibre17">finish</em><span class="calibre6"> </span>components' implementations are empty. The interesting bits are in the view. The start component view has a link to navigate to the workout runner component (<kbd class="calibre13"><span>&lt;</span><span>a</span><span> </span><span>routerLink</span><span>=</span><span><span>"/</span>workout<span>" ...</span></span></kbd>) and so does finish. We have yet to define the routes.</p>
<div class="packt_infobox">The start and finish components have been added to<span class="packt_screen"> </span><em class="calibre31">app module</em>, as they are rudimentary views, unlike workout runner, which has its own <kbd class="calibre24">WorkoutRunnerModule</kbd> module.</div>
<p class="calibre3">All three components are ready. Time to define the route configurations!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Route configuration</h1>
                
            
            <article>
                
<p class="calibre3">To set up the routes for<span class="calibre6"> </span><em class="calibre17">7-Minute Workout</em>, we<span class="calibre6"> </span>are<span class="calibre6"> </span>going to create a<span class="calibre6"> </span><em class="calibre17">route definition module file</em>. Create a file called<span class="calibre6"> </span><kbd class="calibre13">app-routing.module.ts</kbd><span class="calibre6"> </span>in the<span class="calibre6"> </span><kbd class="calibre13">trainer/src/app</kbd><span class="calibre6"> </span>folder defining the top-level routes for the app. Add the following routing setup or copy it from the <kbd class="calibre13">checkpoint3.1</kbd> Git branch:</p>
<pre class="calibre19">import { NgModule } from '@angular/core';<br class="title-page-name"/>import { Routes, RouterModule } from '@angular/router';<br class="title-page-name"/>import { WorkoutRunnerComponent } from './workout-runner/workout-runner.component';<br class="title-page-name"/>import { StartComponent } from './start/start.component';<br class="title-page-name"/>import { FinishComponent } from './finish/finish.component';<br class="title-page-name"/><br class="title-page-name"/>const routes: Routes = [<br class="title-page-name"/>    { path: 'start', component: StartComponent },<br class="title-page-name"/>    { path: 'workout', component: WorkoutRunnerComponent },<br class="title-page-name"/>    { path: 'finish', component: FinishComponent },<br class="title-page-name"/>    { path: '**', redirectTo: '/start' }<br class="title-page-name"/>];<br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/>    imports: [RouterModule.forRoot(routes, { enableTracing: true })],<br class="title-page-name"/>    exports: [RouterModule]<br class="title-page-name"/>})<br class="title-page-name"/>export class AppRoutingModule { }<br class="title-page-name"/> </pre>
<div class="packt_infobox">The Angular CLI also supports boilerplate route-generation for modules. We have not used that feature. We can learn about it from the CLI documentation at <a href="http://bit.ly/ng-cli-routing" class="calibre21">http://bit.ly/ng-cli-routing</a>.</div>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">routes</kbd><span class="calibre6"> </span>variable is an array of<span class="calibre6"> </span><kbd class="calibre13">Route</kbd><span class="calibre6"> </span>objects. Each<span class="calibre6"> </span><kbd class="calibre13">Route</kbd><span class="calibre6"> </span>defines the<span class="calibre6"> </span>configuration<span class="calibre6"> </span>of a single route, which contains:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">path</kbd>: The target path to match</li>
<li class="calibre12"><kbd class="calibre13">component</kbd>: The component to be loaded when the path is hit</li>
</ul>
<p class="calibre3">Such a route definition can be interpreted as, "when the user navigates to a URL (defined in<span class="calibre6"> </span><kbd class="calibre13">path</kbd>), load the corresponding component defined in the<span class="calibre6"> </span><kbd class="calibre13">component</kbd><span class="calibre6"> </span>property." Take the first route example; navigating to<span class="calibre6"> </span><kbd class="calibre13">http://localhost:9000/start</kbd><span class="calibre6"> </span>loads the component view for<span class="calibre6"> </span><kbd class="calibre13">StartComponent</kbd>.</p>
<p class="calibre3">You may have noticed that the last<span class="calibre6"> </span><kbd class="calibre13">Route</kbd><span class="calibre6"> </span>definition looks a bit different. <kbd class="calibre13">path</kbd><span class="calibre6"> </span>looks odd and it does not have a<span class="calibre6"> </span><kbd class="calibre13">component</kbd><span class="calibre6"> </span>property either. A path with<span class="calibre6"> </span><kbd class="calibre13">**</kbd><span class="calibre6"> </span>denotes a catch-all path or the<span class="calibre6"> </span><strong class="calibre5">wildcard route</strong><span class="calibre6"> </span>for our app. Any navigation that does not match one of the first three routes<span class="calibre6"> </span>matches<span class="calibre6"> </span>the catch-all route, causing the app to navigate to the start page (defined in the<span class="calibre6"> </span><kbd class="calibre13">redirectTo</kbd><span class="calibre6"> </span>property).</p>
<div class="packt_infobox">We can try this once the routing setup is complete. Type any random route, such as<span class="packt_screen"> </span><kbd class="calibre24">http://localhost:9000/abcd</kbd>, and the app automatically redirects to<span class="packt_screen"> </span><kbd class="calibre24">http://localhost:9000/start</kbd>.</div>
<p class="calibre3">We finally create and import a new module into<span class="calibre6"> </span><kbd class="calibre13">AppRoutingModule</kbd><span class="calibre6"> </span>with the call to<span class="calibre6"> </span><kbd class="calibre13">RouterModule.forRoot</kbd>.  And by re-exporting Angular's<span class="calibre6"> </span><kbd class="calibre13">RouterModule</kbd>, we can import<span class="calibre6"> </span><kbd class="calibre13">AppRoutingModule</kbd><span class="calibre6"> </span>instead of<span class="calibre6"> </span><kbd class="calibre13">RouterModule</kbd><span class="calibre6"> </span>and have access to all of the routing constructs together with our app routes available in<span class="calibre6"> </span><kbd class="calibre13">AppModule</kbd>.</p>
<div class="packt_infobox">The<span class="packt_screen"> </span><kbd class="calibre24">enableTracing: true</kbd><span class="packt_screen"> </span>property on the<span class="packt_screen"> </span><kbd class="calibre24">forRoot</kbd><span class="packt_screen"> </span>function parameter allows us to monitor the<span class="packt_screen"> </span><em class="calibre31">router events</em><span class="packt_screen"> </span>(such as<span class="packt_screen"> </span><kbd class="calibre24">NavigationStart</kbd>,<span class="packt_screen"> </span><kbd class="calibre24">NavigationEnd</kbd>, and <kbd class="calibre24">NavigationCancel</kbd>) that happen when navigation takes place and the correct route is resolved. The logs are visible in the browser's debugger console.<span class="packt_screen"> </span><em class="calibre31">Use it for debugging purposes only, remove it from production builds</em>.<br class="calibre27"/>
Could the preceding routing setup could have been done inside<span class="packt_screen"> </span><kbd class="calibre24">AppModule</kbd>? Yes, it's definitely possible, but we would recommend against it. As the number of routes grow and the routing setup becomes more complex, having a separate routing module helps us organize the code better. </div>
<p class="calibre3">An important thing to highlight here:<em class="calibre17"> route ordering is important in route definition</em>. Since route matching is done in a top-down fashion, it stops at the first match to define your specific routes before any generic catch-all route, such as the <kbd class="calibre13">**</kbd> <em class="calibre17">wildcard route </em><span class="calibre6">in our definition, which is declared at the last.</span></p>
<p class="calibre3">The default router setup uses the<span class="calibre6"> </span><strong class="calibre5">pushstate</strong><span class="calibre6"> </span>mechanism for<span class="calibre6"> </span>URL<span class="calibre6"> </span>navigation. In such a setup, URLs look like:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">localhost:4200/start</kbd></li>
<li class="calibre12"><kbd class="calibre13">localhost:4200/workout</kbd></li>
<li class="calibre12"><kbd class="calibre13">localhost:4200/finish</kbd></li>
</ul>
<p class="calibre3">This may not seem like a big deal, but remember that we are<span class="calibre6"> </span>doing<span class="calibre6"> </span>client-side navigation, not the full-page redirects that we are so used to. As the<span class="calibre6"> </span><strong class="calibre5">developer guide</strong><span class="calibre6"> </span>states:</p>
<div class="packt_infobox">Modern HTML 5 browsers support<span class="packt_screen"> </span><kbd class="calibre24">history.pushState</kbd>, a technique that changes a browser's location and history without triggering a server page request. The router can compose a "natural" URL that is indistinguishable from one that would otherwise require a page load.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pushstate API and server-side url-rewrites</h1>
                
            
            <article>
                
<p class="calibre3">The router uses the  pushstate<span class="calibre6"> </span>API in one of two cases:</p>
<ul class="calibre11">
<li class="calibre12">When we click on links embedded in the view (<kbd class="calibre13">&lt;a&gt;</kbd><span> </span>tag)</li>
<li class="calibre12">When we use the router API</li>
</ul>
<p class="calibre3">In both cases, the router intercepts any navigation events, loads the appropriate component view, and finally updates the browser URL. The request never goes to the server.</p>
<p class="calibre3">But what if we refresh the browser window?</p>
<p class="calibre3">The Angular router cannot intercept the browser's refresh event, and hence a complete page refresh happens. In such a scenario, the server needs to respond to a resource request (URL) that only exists on the client side. A typical server response is to send the app entry file (such as<span class="calibre6"> </span><kbd class="calibre13">index.html</kbd>)<span class="calibre6"> </span>for<span class="calibre6"> </span>any arbitrary request that may result in a<span class="calibre6"> </span><kbd class="calibre13">404 (Not Found)</kbd><span class="calibre6"> </span>error. This is what we call the server<span class="calibre6"> </span><strong class="calibre5"><span class="calibre6">url-rewrite</span></strong>. This implies requests to any non-existent URLs, such as<span class="calibre6"> </span><kbd class="calibre13">/start</kbd>,<span class="calibre6"> </span><kbd class="calibre13">/workout</kbd>, or <kbd class="calibre13">/finish</kbd> loads the index page.</p>
<div class="packt_tip">Each server platform has a different mechanism to support url-rewrite. We suggest you look at the documentation for the server stack you use to enable url-rewrite for your Angular apps.</div>
<p class="calibre3">We can see the server-side rewrites in action once the app routing is complete. Once completed, try to refresh the app and see the browser's network log;<span class="calibre6"> </span><em class="calibre17">the server sends the same  generated</em><span class="calibre6"> </span><kbd class="calibre13">index.html</kbd><span class="calibre6"> </span><em class="calibre17">content every time irrespective of the URL requested</em>.</p>
<p class="calibre3">The routing module definition is complete now. Before proceeding further, open<span class="calibre6"> </span><kbd class="calibre13">app.module.ts</kbd><span class="calibre6"> </span>and import <kbd class="calibre13">AppRoutingModule</kbd>:</p>
<pre class="calibre19">import { FinishComponent } from './finish/finish.component';<br class="title-page-name"/><strong class="calibre1">import { AppRoutingModule } from './app-routing.module';</strong><br class="title-page-name"/> @NgModule({ 
  imports: [..., StartModule, FinishModule, <strong class="calibre1">AppRoutingModule</strong>], </pre>
<p class="calibre3">Now that we have all the required components and all the routes defined, where do we inject these components on route change? We just need to define a placeholder for that in the host view.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Rendering component views with router-outlet</h1>
                
            
            <article>
                
<p class="calibre3">Look at the current<span class="calibre6"> </span><kbd class="calibre13">AppComponent</kbd> template (<kbd class="calibre13">app.component.html</kbd>), it has<span class="calibre6"> </span>an<span class="calibre6"> </span>embedded<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd>:</p>
<pre class="calibre19">&lt;abe-workout-runner&gt;&lt;/abe-workout-runner&gt;</pre>
<p class="calibre3">This needs to change as we need to render different components based on the URL (<kbd class="calibre13">/start</kbd>,<span class="calibre6"> </span><kbd class="calibre13">/workout</kbd>, or <kbd class="calibre13">/finish</kbd>). Remove the preceding declaration and replace it with a<span class="calibre6"> </span><em class="calibre17">router directive</em>:</p>
<pre class="calibre19">&lt;router-outlet&gt;&lt;/router-outlet&gt;</pre>
<p class="calibre3"><kbd class="calibre13">RouterOutlet</kbd><span class="calibre6"> </span>is an Angular component directive that acts as a placeholder for loading route-specific components when the route changes. It integrates with the router service to load the appropriate component based on the current browser URL and the route definition.</p>
<p class="calibre3">The following diagram helps us to easily visualize what is happening with the<span class="calibre6"> </span><kbd class="calibre13">router-outlet</kbd><span class="calibre6"> </span>setup:</p>
<div class="packt_figure"><img src="../images/00022.jpeg" class="calibre44"/></div>
<p class="calibre3">We are almost done; it's time to trigger navigation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Route navigation</h1>
                
            
            <article>
                
<p class="calibre3">Like standard browser navigation, Angular<span class="calibre6"> </span>navigation happens:</p>
<ul class="calibre11">
<li class="calibre12">When a user enters a URL directly into the browser address bar</li>
<li class="calibre12">On clicking on a link on the anchor tag</li>
<li class="calibre12">On using a script/code to navigate</li>
</ul>
<p class="calibre3">If not started, start the app and load<span class="calibre6"> </span><kbd class="calibre13">http://localhost:4200</kbd><span class="calibre6"> </span>or<span class="calibre6"> </span><kbd class="calibre13">http://localhost:4200/start</kbd>. The start page should be loaded.</p>
<p class="calibre3">Click on the<span class="calibre6"> </span><span class="calibre6">Start</span><span class="calibre6"> </span>button and the workout should start under the <kbd class="calibre13">http://localhost:4200/workout</kbd> URL.</p>
<div class="packt_infobox">
<p class="calibre20">The Angular router also supports the old style of<span class="calibre22"> </span><em class="calibre25">hash (#)-based routing</em>. When hash-based routing is enabled, the routes appear as follows:</p>
<ul class="calibre45">
<li class="calibre46"><kbd class="calibre24">localhost:9000/#/start</kbd></li>
<li class="calibre46"><kbd class="calibre24">localhost:9000/#/workout</kbd></li>
<li class="calibre46"><kbd class="calibre24">localhost:9000/#/finish</kbd></li>
</ul>
<p class="calibre20">To change it to hash-based routing, the route configuration for the top-level routes should be augmented with an extra <kbd class="calibre24">useHash:true</kbd> property in the <kbd class="calibre24">RouterModule.forRoot</kbd> function (second parameter).</p>
</div>
<p class="calibre3">Interestingly, the anchor link in the<span class="calibre6"> </span><kbd class="calibre13">StartComponent</kbd> view definition does not have an <kbd class="calibre13">href</kbd><span class="calibre6"> </span>attribute. Instead, there is a<span class="calibre6"> </span><kbd class="calibre13">RouterLink</kbd><span class="calibre6"> </span>directive (the directive name is<span class="calibre6"> </span><kbd class="calibre13">RouterLink</kbd>, the selector is<span class="calibre6"> </span><kbd class="calibre13">routerLink</kbd>):</p>
<pre class="calibre19">&lt;a routerLink="/workout"&gt;</pre>
<p class="calibre3">In the preceding case, since the route is fixed, the directive takes a constant expression (<kbd class="calibre13">"/workout"</kbd>). We are not using the standard square bracket notation (<kbd class="calibre13">[]</kbd>) here, instead are assigning the directive a fixed value. This is known as<span class="calibre6"> </span><strong class="calibre5">one-time binding</strong>. For dynamic routes, we can use template expressions and the link parameter array. We'll touch upon dynamic<span class="calibre6"> </span>routes<span class="calibre6"> </span>and the link parameter array shortly.</p>
<div class="packt_infobox">Notice the<span class="packt_screen"> </span><strong class="calibre26">/</strong><span class="packt_screen"> </span>prefix in the preceding route path.<span class="packt_screen"> </span><kbd class="calibre24">/</kbd><span class="packt_screen"> </span>is used to specify an absolute path. The Angular router also supports relative paths, which are useful when working with child routes. We will explore the concept of child routes in the next few chapters.</div>
<p class="calibre3">Refresh the app and check the rendered HTML for<span class="calibre6"> </span><kbd class="calibre13">StartComponent</kbd>; the preceding anchor tag is rendered with the correct<span class="calibre6"> </span><kbd class="calibre13">href</kbd><span class="calibre6"> </span>value:</p>
<pre class="calibre19">&lt;a ... href="/workout"&gt;</pre>
<div class="packt_tip"><span class="packt_screen">Avoid hardcoding route links</span><br class="calibre27"/>
While you could have directly used<span class="packt_screen"> </span><kbd class="calibre24">&lt;a href="/workout"&gt;</kbd>, prefer<span class="packt_screen"> </span><kbd class="calibre24">routerLink</kbd><span class="packt_screen"> </span>to avoid hardcoding routes.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The link parameter array</h1>
                
            
            <article>
                
<p class="calibre3">The route setup for the current<span class="calibre6"> </span><em class="calibre17">7-Minute Workout</em><span class="calibre6"> </span>is quite simple, and there isn't a need to pass parameters as part of link generation. But the<span class="calibre6"> </span>capability<span class="calibre6"> </span>is there for non-trivial routes that require dynamic parameters. See this example:</p>
<pre class="calibre19">@RouteConfig([ 
<strong class="calibre1">  { path: '/users/:id', component: UserDetail },</strong> 
  { path: '/users', component: UserList}, 
])</pre>
<p class="calibre3">This is how the first route can be generated:</p>
<pre class="calibre19">&lt;a [routerLink]="['/users', 2]  // generates /users/2</pre>
<p class="calibre3">The array assigned to the<span class="calibre6"> </span><kbd class="calibre13">RouterLink</kbd><span class="calibre6"> </span>directive is what we called the <strong class="calibre5">link parameter array</strong>. The array follows a specific pattern:</p>
<pre class="calibre19">['routePath', param1, param2, {prop1:val1, prop2:val2} ....] </pre>
<p class="calibre3">The first element is always the route path, and the next set of parameters is there to replace placeholder tokens defined in a route template.</p>
<div class="packt_infobox">The Angular router is quite a beast and supports almost everything that we expect from a modern router library. It supports child routes, async routes, lifecycle hooks, secondary routes, and some other advanced scenarios. We'll delay discussion on these topics until later chapters. This chapter just gets us started with Angular routing, but there is more to come!</div>
<p class="calibre3">The router link parameter can also be an object. Such objects are used to supply<span class="calibre6"> </span><strong class="calibre5">optional parameters</strong><span class="calibre6"> </span>to the route. See this example:</p>
<pre class="calibre19">&lt;a [routerLink]="['/users', {id:2}]  // generates /users;id=2</pre>
<p class="calibre3">Note that the generated link contains a semicolon to separate optional parameters from the route and other parameters.</p>
<p class="calibre3">The last missing part of the implementation is routing to the finish page once the workout completes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the router service for component navigation</h1>
                
            
            <article>
                
<p class="calibre3">Navigation from the workout page to the<span class="calibre6"> </span>finish<span class="calibre6"> </span>page is not triggered manually but on completion of the workout.<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>needs to trigger this transition.</p>
<p class="calibre3">For this,<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>needs to get hold of the router and invoke the<span class="calibre6"> </span><kbd class="calibre13">navigate</kbd><span class="calibre6"> </span>method on it.</p>
<p class="calibre3">How does<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>get the router instance? Using Angular's<span class="calibre6"> </span><em class="calibre17">dependency injection framework</em>. We have been shying away from this topic for some time now. We have<span class="calibre6"> </span>achieved<span class="calibre6"> </span>a lot without even knowing that there's a dependency injection framework in play all this time. Let's wait a tad longer and first concentrate on fixing the navigation issue.</p>
<p class="calibre3">For<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>to get hold of the router service instance, it just needs to declare the service on the constructor. Update the<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>constructor and add the imports:</p>
<pre class="calibre19"><strong class="calibre1">import {Router} from '@angular/router';</strong> <br class="title-page-name"/>...
constructor(<strong class="calibre1">private router: Router</strong>) {</pre>
<p class="calibre3">Angular now magically injects the current router into the<span class="calibre6"> </span><kbd class="calibre13">router</kbd><span class="calibre6"> </span>private variable when<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>is instantiated. The magic is done by<span class="calibre6"> </span><em class="calibre17">dependency injection framework</em>.</p>
<p class="calibre3">It's now just a matter of replacing the <kbd class="calibre13">console.log("Workout complete!");</kbd> statement with the call to the<span class="calibre6"> </span><kbd class="calibre13">navigation</kbd><span class="calibre6"> </span>router:</p>
<pre class="calibre19">this.router.navigate( ['/finish'] );</pre>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">navigate</kbd><span class="calibre6"> </span>method takes the same<span class="calibre6"> </span><em class="calibre17">link parameter array</em><span class="calibre6"> </span>as the<span class="calibre6"> </span><kbd class="calibre13">RouterLink</kbd><span class="calibre6"> </span>directive. We can verify the implementation by patiently waiting for the workout to complete!</p>
<div class="packt_infobox">If you are having a problem running the code, look at the <kbd class="calibre24">checkpoint3.1</kbd> Git branch for a working version of what we have done thus far. Or if you are not using Git, download the snapshot of<span class="packt_screen"> </span><kbd class="calibre24">checkpoint3.1</kbd><span class="packt_screen"> </span>(a ZIP file) from<span class="packt_screen"> </span><a href="http://bit.ly/ng6be-checkpoint-3-1" class="calibre21">http://bit.ly/ng6be-checkpoint-3-1</a>. Refer to the<span class="packt_screen"> </span><kbd class="calibre24">README.md</kbd><span class="packt_screen"> </span>file in the trainer folder when setting up the snapshot for the first time.</div>
<p class="calibre3">The routes we have defined in<span class="calibre6"> </span><em class="calibre17">7-Minute Workout</em><span class="calibre6"> </span>are standard simple routes. But if there are dynamic routes that take parameters, how do we make the parameters available in our components? Angular has a service for that, the<span class="calibre6"> </span><kbd class="calibre13">ActivatedRoute</kbd><span class="calibre6"> </span>service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the ActivatedRoute service to access route params</h1>
                
            
            <article>
                
<p class="calibre3">There are times when the app requires<span class="calibre6"> </span>access to the active route state. Information such as the current URL fragment, the current route parameters, and other route-related data may come in handy during a component's implementation.</p>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">ActivatedRoute</kbd><span class="calibre6"> </span>service is a one-stop shop for all current route-related queries. It has a number of properties, including<span class="calibre6"> </span><kbd class="calibre13">url</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">paramMap</kbd>, that can be used to query the route's current state.</p>
<p class="calibre3">Let's look at an example of a parameterized route and how to access a parameter passed from a component,  given this route:</p>
<pre class="calibre19">{ path: '/users/:id', component: UserDetailComponent },</pre>
<p class="calibre3">When the user navigates to<span class="calibre6"> </span><kbd class="calibre13">/user/5</kbd>, the underlying component  can access the<span class="calibre6"> </span><kbd class="calibre13">:id</kbd><span class="calibre6"> </span>parameter value by first injecting<span class="calibre6"> </span><kbd class="calibre13">ActivatedRoute</kbd><span class="calibre6"> </span>into its constructor:</p>
<pre class="calibre19">export class UserDetailComponent { 
  constructor( private route: ActivatedRoute ... </pre>
<p class="calibre3">And then, anywhere in the code where the parameter is required, call<span class="calibre6"> </span><kbd class="calibre13">get</kbd><span class="calibre6"> </span>methods on the <kbd class="calibre13">ActivatedRoute.paramMap</kbd><span class="calibre6"> </span>property:</p>
<pre class="calibre19">ngOnInit() {<br class="title-page-name"/>    let id = +this.route.paramMap.get('id'); // (+) converts string 'id' to a number<br class="title-page-name"/>    var currentUser=this.getUser(id) <br class="title-page-name"/>}  </pre>
<div class="packt_infobox">The<span class="packt_screen"> </span><kbd class="calibre24">paramMap</kbd><span class="packt_screen"> </span>property on<span class="packt_screen"> </span><kbd class="calibre24">ActivatedObject</kbd><span class="packt_screen"> </span>is actually an<span class="packt_screen"> </span><strong class="calibre26">observable.</strong><span class="packt_screen"> </span>We will learn more about observables later in the chapter, but for now, it is enough to understand that observables are objects that let the outside world know about their state changes by raising events that others can listen into.</div>
<p class="calibre3">We'll use this router capability in the later chapters where we build a new app that can create workouts and edit existing workouts. In the upcoming chapters, we also look at some advanced routing concepts, including<span class="calibre6"> </span><em class="calibre17">child routes</em>,<span class="calibre6"> </span><em class="calibre17">lazy loaded routes</em>, and<span class="calibre6"> </span><em class="calibre17">guard conditions</em>.</p>
<p class="calibre3">We have covered the basics of Angular routing, it's now time to concentrate on a much overdue topic:<span class="calibre6"> </span><em class="calibre17">Dependency Injection</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Angular dependency Injection</h1>
                
            
            <article>
                
<p class="calibre3">Angular makes heavy use of<span class="calibre6"> </span>dependency<span class="calibre6"> </span>injection to manage app and framework dependencies. The surprising part is that we could ignore this topic until we started our discussion on the router. All this time, the Angular dependency injection framework has been supporting our implementation. The hallmark of a good dependency injection framework is that the consumer can use it without bothering too much about the internals and with little ceremony.</p>
<p class="calibre3">If you are not sure what dependency injection is or just have a vague idea about it, an introduction to DI surely does not hurt anyone.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dependency injection 101</h1>
                
            
            <article>
                
<p class="calibre3">For any application, its components (not to be confused with Angular components) do not work in isolation. There are dependencies between them. A component may use other<span class="calibre6"> </span>components<span class="calibre6"> </span>to achieve its desired functionalities.<span class="calibre6"> </span><strong class="calibre5">Dependency injection</strong><span class="calibre6"> </span>is a pattern for managing such dependencies.</p>
<p class="calibre3">The DI pattern is popular in many programming languages as it allows us to manage dependencies in a loosely coupled manner. With such a framework in place, dependent objects are managed by a DI container. This makes dependencies swappable and the overall code more decoupled and testable.</p>
<p class="calibre3">The idea behind DI is that an object does not create/manage its<span class="calibre6"> </span>own<span class="calibre6"> </span>dependencies. Instead, the dependencies are provided from the outside. These dependencies are made available either through a constructor, which is called<span class="calibre6"> </span><strong class="calibre5">constructor injection</strong><span class="calibre6"> </span>(Angular also does this) or by directly setting the<span class="calibre6"> </span>object<span class="calibre6"> </span>properties, which is called<span class="calibre6"> </span><strong class="calibre5">property injection</strong>.</p>
<p class="calibre3">Here is a rudimentary example of DI in action. Consider a class called<span class="calibre6"> </span><kbd class="calibre13">Tracker</kbd><span class="calibre6"> </span>that requires <kbd class="calibre13">Logger</kbd><span class="calibre6"> </span>for a logging operation:</p>
<pre class="calibre19">class Tracker() { 
  logger:Logger; 
  constructor() { 
    this.logger = new Logger();    
  } 
}</pre>
<p class="calibre3">The dependency of the <kbd class="calibre13">Logger</kbd> class is hardwired inside<span class="calibre6"> </span><kbd class="calibre13">Tracker</kbd><span class="calibre6"> </span>as <kbd class="calibre13">Tracker</kbd><span class="calibre6"> </span>itself instantiates the<span class="calibre6"> </span><kbd class="calibre13">Logger</kbd><span class="calibre6"> </span>instance. What if we externalize this dependency? So the class becomes:</p>
<pre class="calibre19">class Tracker { 
  logger:Logger; 
  constructor(logger:Logger) { 
    this.logger = logger;    
  } 
}</pre>
<p class="calibre3">This innocuous-looking change has a major impact. By adding the<span class="calibre6"> </span>ability<span class="calibre6"> </span>to provide the dependency externally, we can now:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Decouple these components and enable extensibility</strong>. The DI pattern allows us to alter the logging behavior of the<span> </span><kbd class="calibre13">Tracker</kbd><span> </span>class without touching the class itself. Here is an example:</li>
</ul>
<pre class="calibre19">        var trackerWithDBLog=new Tracker(new DBLogger()); 
        var trackerWithMemoryLog=new Tracker(new MemoryLogger()); </pre>
<p class="calibre36">The two<span class="calibre6"> </span><kbd class="calibre13">Tracker</kbd><span class="calibre6"> </span>objects we just saw have different logging capabilities for the same<span class="calibre6"> </span><kbd class="calibre13">Tracker</kbd><span class="calibre6"> </span>class implementation.<span class="calibre6"> </span><kbd class="calibre13">trackerWithDBLog</kbd><span class="calibre6"> </span>logs to a DB and<span class="calibre6"> </span><kbd class="calibre13">trackerWithMemoryLog</kbd><span class="calibre6"> </span>to the memory (assuming both<span class="calibre6"> </span><kbd class="calibre13">DBLogger</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">MemoryLogger</kbd><span class="calibre6"> </span>are derived from the <kbd class="calibre13">Logger</kbd><span class="calibre6"> </span>class). Since<span class="calibre6"> </span><kbd class="calibre13">Tracker</kbd><span class="calibre6"> </span>is not dependent on a specific implementation on  <kbd class="calibre13">Logger</kbd><span class="calibre6"> </span>(<kbd class="calibre13">DBLogger</kbd><span class="calibre6"> </span>or<span class="calibre6"> </span><kbd class="calibre13">MemoryLogger</kbd>), this implies<span class="calibre6"> </span><kbd class="calibre13">Logger</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">Tracker</kbd><span class="calibre6"> </span>are loosely coupled. In the future, we can derive a new<span class="calibre6"> </span><kbd class="calibre13">Logger</kbd><span class="calibre6"> </span>class implementation and use that for logging without changing the<span class="calibre6"> </span><kbd class="calibre13">Tracker</kbd><span class="calibre6"> </span>implementation.</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Mock dependencies</strong>: The ability to mock dependencies makes our components more testable. The<span> </span><kbd class="calibre13">Tracker</kbd><span> </span>implementation can be tested in isolation (unit testing) by providing a mock implementation for<span> </span><kbd class="calibre13">Logger</kbd>, such as<span> </span><kbd class="calibre13">MockLogger</kbd>, or by using a mocking framework that can easily mock the<span> </span><kbd class="calibre13">Logger</kbd><span> </span>interface.</li>
</ul>
<p class="calibre3">We can now understand how powerful DI is.</p>
<p class="calibre3">Think carefully: once DI is in place, the responsibility for resolving the dependencies now falls on the calling/consumer code. In the preceding example, a class that was earlier instantiating<span class="calibre6"> </span><kbd class="calibre13">Tracker</kbd><span class="calibre6"> </span>now needs to create a<span class="calibre6"> </span><kbd class="calibre13">Logger</kbd><span class="calibre6"> </span>derivation and inject it into<span class="calibre6"> </span><kbd class="calibre13">Tracker</kbd><span class="calibre6"> </span>before using it.</p>
<p class="calibre3">Clearly, this flexibility in swapping internal dependencies of a component comes at a price. The calling code implementation can become overly complex as it now has to manage child dependencies too. This may seem simple at first, but given the fact that dependent components<span class="calibre6"> </span>may<span class="calibre6"> </span>themselves have dependencies, what we are dealing with is a complex dependency-tree structure.</p>
<p class="calibre3">This is where DI containers/frameworks add value. They make managing dependencies less cumbersome for the calling code. These containers then construct/manage dependencies and provide it to our client/consumer code.</p>
<p class="calibre3">The Angular DI framework manages dependencies for our Angular components, directives, pipes, and services.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Exploring dependency injection in Angular</h1>
                
            
            <article>
                
<p class="calibre3">Angular employs its very own DI<span class="calibre6"> </span>framework<span class="calibre6"> </span>to manage dependencies across the application. The very first example of visible dependency injection was the injection of the component router into<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd>:</p>
<pre class="calibre19">constructor(private router: Router) { </pre>
<p class="calibre3">When the<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>class gets instantiated, the DI framework internally locates/creates the correct router instance and injects it into the caller (in our case,<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd>).</p>
<p class="calibre3">While Angular does a good job of keeping the DI infrastructure hidden, it's imperative that we understand how Angular DI works. Otherwise, everything may seem rather magical.</p>
<p class="calibre3">DI is about creating and managing dependencies, and the framework component that does this is dubbed the <strong class="calibre5">the injector</strong>. For the injector to<span class="calibre6"> </span>manage<span class="calibre6"> </span>dependencies, it needs to understand the following:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">The what:</strong><span> </span>What is the dependency? The dependency could be a class, an object, a factory function, or a value. Every dependency needs to be registered with the DI framework before it can be injected.</li>
<li class="calibre12"><strong class="calibre1">The where/when:</strong><span> </span>The DI framework needs to know where to inject a dependency and when.</li>
<li class="calibre12"><strong class="calibre1">The how</strong>: The DI framework also needs to know the recipe for creating the dependency when requested.</li>
</ul>
<p class="calibre3">Any injected dependency needs to answer these questions, irrespective of whether it's a framework construct or an artifact created by us.</p>
<p class="calibre3">Take, for example, the<span class="calibre6"> </span><kbd class="calibre13">Router</kbd><span class="calibre6"> </span>instance injection done in<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd>. To answer the what and how parts, we register the<span class="calibre6"> </span><kbd class="calibre13">Router</kbd><span class="calibre6"> </span>service by importing the<span class="calibre6"> </span><kbd class="calibre13">RouterModule</kbd><span class="calibre6"> </span>into<span class="calibre6"> </span><kbd class="calibre13">AppRoutingModule</kbd>:</p>
<pre class="calibre19">imports: [..., AppRoutingModule];</pre>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">AppRoutingModule</kbd><span class="calibre6"> </span>is a module that exports multiple routes together with all the Angular-router-related services (technically it re-exports<span class="calibre6"> </span><kbd class="calibre13">RouterModule</kbd>).</p>
<p class="calibre3">The where and when are decided based on the component that requires the dependencies. The constructor of<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>takes a dependency of<span class="calibre6"> </span><kbd class="calibre13">Router</kbd>. This informs the injector to inject the current<span class="calibre6"> </span><kbd class="calibre13">Router</kbd><span class="calibre6"> </span>instance when<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>is created as part of route navigation.</p>
<div class="packt_infobox">Internally, the injector determines the dependencies of a class based on the metadata reflected from it when converting TypeScript to ES5 code (done by the TypeScript compiler). The metadata is generated only if we add a decorator, such as<span class="packt_screen"> </span><kbd class="calibre24">@Component</kbd><span class="packt_screen"> </span>or<span class="packt_screen"> </span><kbd class="calibre24">@Pipe</kbd>, on the class.</div>
<p class="calibre3">What happens if we inject<span class="calibre6"> </span><kbd class="calibre13">Router</kbd><span class="calibre6"> </span>into another class? Is the same<span class="calibre6"> </span><kbd class="calibre13">Router</kbd><span class="calibre6"> </span>instance used? The short answer is yes. The Angular injector creates and caches dependencies for future reuse, and hence these services are singleton in nature.</p>
<div class="packt_infobox">While dependencies in an injector are singleton, at any given time, there can be multiple injectors active throughout an Angular app. You'll learn about the injector hierarchy shortly. With the router, there is another layer of complexity. Since Angular supports the child route concept, each of these child routes has its own router instance. Wait until we cover child routers in the next chapter so that you can understand the intricacies!</div>
<p class="calibre3">Let's create an Angular service to track workout history. This process will help you understand how dependencies are wired using Angular DI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Tracking workout history</h1>
                
            
            <article>
                
<p class="calibre3">It would be a great addition to our app if we could track our workout<span class="calibre6"> </span>history. When did we last exercise? Did we complete it? How much time did we spend on it?</p>
<p class="calibre3">To answer these questions, we need to track when the workout starts and when it ends. This tracking data then needs to be persisted somewhere.</p>
<p class="calibre3">A possible solution could be to extend our<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>with the desired functionality. But that adds unnecessary complexity to<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>and that's not its primary job.</p>
<p class="calibre3">We need a dedicated history-tracking service for this job, a service that tracks historical data and shares it throughout the app. Let's start building the workout-history-tracker service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building the workout-history-tracker service</h1>
                
            
            <article>
                
<p class="calibre3">The workout-history-tracker service is going to track workout progress. The service will also expose an interface, allowing<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>to start and stop workout tracking.</p>
<p class="calibre3">Inspired again by the<span class="calibre6"> </span><em class="calibre17">Angular style guide</em>, we are<span class="calibre6"> </span>going<span class="calibre6"> </span>to create a new module, <strong class="calibre5">core module</strong>, and add the service to this module. The role of the core module is to host services that are available across the application. It is also a good place to add single-use components that are required when the application starts. A nav bar and busy indicator are good examples of such components.</p>
<p class="calibre3">On the command line, navigate to the <kbd class="calibre13">trainer/src/app</kbd><span class="calibre6"> </span>folder and generate a new module:</p>
<pre class="calibre19"><strong class="calibre1">ng generate module core --module app</strong></pre>
<p class="calibre3">This creates a new <kbd class="calibre13">CoreModule</kbd> module and imports it into<span class="calibre6"> </span><kbd class="calibre13">AppModule</kbd>. Next, create a new service inside the <kbd class="calibre13">trainer/src/app/core</kbd><span class="calibre6"> </span>folder, again using Angular CLI:</p>
<pre class="calibre19"><strong class="calibre1">ng generate service workout-history-tracker</strong></pre>
<p class="calibre3">The generated code is quite simple. The generator creates a new class<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>(<kbd class="calibre13">workout-history-tracker.service.ts</kbd>) with a<span class="calibre6"> </span><kbd class="calibre13">@Injectable</kbd><span class="calibre6"> </span>decorator applied on the class:</p>
<pre class="calibre19">@Injectable({<br class="title-page-name"/>  providedIn: 'root'<br class="title-page-name"/>})<br class="title-page-name"/>export class WorkoutHistoryTrackerService {<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">providedIn:'root'</kbd><span class="calibre6"> </span>property on<span class="calibre6"> </span><kbd class="calibre13">Injectable</kbd><span class="calibre6"> </span>instructs Angular to create<span class="calibre6"> </span><strong class="calibre5">a provider</strong><span class="calibre6"> </span>with the<span class="calibre6"> </span><em class="calibre17">root injector</em>. The sole job of this provider is to create the<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>service and return it when Angular's DI injector desires. Any service that we create/use needs to be registered on an injector. As the Angular documentation on<span class="calibre6"> </span><em class="calibre17">providers</em><span class="calibre6"> </span>describes,</p>
<p class="calibre3"><em class="calibre17">Providers tell the injector how to create the service. Without a provider, the injector would not know that it is responsible for injecting the service nor be able to create the service</em>.</p>
<div class="packt_infobox"><br class="calibre27"/>
A service in Angular is just a class that has been registered with Angular's DI framework. Nothing special about them!</div>
<p class="calibre3">Sometimes it is desirable to include the service as part of a module instead of registering it with the root injector. In such a case, the service can be registered at the module level. There are two ways to achieve this:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Option 1</strong>: Reference the module with the <kbd class="calibre13">providedIn</kbd><span> </span>property:</li>
</ul>
<pre class="calibre19">@Injectable({<br class="title-page-name"/>  providedIn: CoreModule<br class="title-page-name"/>})<br class="title-page-name"/>export class WorkoutHistoryTrackerService {</pre>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Option 2</strong>: Register the service on the module, using the<span> </span><kbd class="calibre13">providers</kbd><span> </span>array:</li>
</ul>
<pre class="calibre19">@NgModule({<br class="title-page-name"/>  providers: [<strong class="calibre1">WorkoutHistoryTrackerService</strong>],<br class="title-page-name"/>})<br class="title-page-name"/>export class CoreModule { }</pre>
<p class="calibre3">Registering services at module level is advantageous in scenarios where a module is lazy loaded.</p>
<p class="calibre3">Registering the service using<span class="calibre6"> </span><kbd class="calibre13">Injectable</kbd><span class="calibre6"> </span>(<em class="calibre17">option 1</em>) has another advantage. It enables Angular CLI build to perform advanced optimization with code bundling, leaving out any<span class="calibre6"> </span>service<span class="calibre6"> </span>that is declared but never used (a process called<span class="calibre6"> </span><strong class="calibre5">tree shaking</strong>).</p>
<div class="packt_infobox"><br class="calibre27"/>
Irrespective of the two options we use, the service is still registered (via a provider) with the root injector.</div>
<p class="calibre3">We are going to use the<span class="calibre6"> </span><kbd class="calibre13">Injectable</kbd><span class="calibre6"> </span>approach to registering dependency throughout the book, unless stated otherwise. Open<span class="calibre6"> </span><kbd class="calibre13">workout-history-tracker.service.ts</kbd><span class="calibre6"> </span>and add the following implementation:</p>
<pre class="calibre19">import { ExercisePlan } from '../workout-runner/model';<br class="title-page-name"/>import { CoreModule } from './core.module';<br class="title-page-name"/>import { Injectable } from '@angular/core';<br class="title-page-name"/>@Injectable({<br class="title-page-name"/>  providedIn: CoreModule<br class="title-page-name"/>})
export class WorkoutHistoryTrackerService { 
  private maxHistoryItems = 20;   //Tracking last 20 exercises 
  private currentWorkoutLog: WorkoutLogEntry = null; 
  private workoutHistory: Array&lt;WorkoutLogEntry&gt; = []; 
  private  workoutTracked: boolean;</pre>
<pre class="calibre19">  constructor() { } 
   
  get tracking(): boolean { 
    return this. workoutTracked; 
  } 
}
 
export class WorkoutLogEntry { 
  constructor( 
    public startedOn: Date, 
    public completed: boolean = false, 
    public exercisesDone: number = 0, 
    public lastExercise?: string, 
    public endedOn?: Date) { } 
}</pre>
<p class="calibre3">There are two classes defined: <kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">WorkoutLogEntry</kbd>. As the name suggests,<span class="calibre6"> </span><kbd class="calibre13">WorkoutLogEntry</kbd><span class="calibre6"> </span>defines log data for one workout execution.<span class="calibre6"> </span><kbd class="calibre13">maxHistoryItems</kbd><span class="calibre6"> </span>allows us to configure the maximum number of items to store in the<span class="calibre6"> </span><kbd class="calibre13">workoutHistory</kbd><span class="calibre6"> </span>array, the array that contains the historical data. The<span class="calibre6"> </span><kbd class="calibre13">get tracking()</kbd><span class="calibre6"> </span>method defines a getter property for<span class="calibre6"> </span><kbd class="calibre13">workoutTracked</kbd><span class="calibre6"> </span>in TypeScript.<span class="calibre6"> </span><kbd class="calibre13">workoutTracked</kbd><span class="calibre6"> </span>is set to<span class="calibre6"> </span><kbd class="calibre13">true</kbd><span class="calibre6"> </span>during<span class="calibre6"> </span>workout<span class="calibre6"> </span>execution.</p>
<p class="calibre3">Let's add the start tracking, stop tracking, and exercise complete functions to<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd>:</p>
<pre class="calibre19">startTracking() { 
  this.workoutTracked = true; 
  this.currentWorkoutLog = new WorkoutLogEntry(new Date()); 
  if (this.workoutHistory.length &gt;= this.maxHistoryItems) { 
    this.workoutHistory.shift(); 
  } 
    this.workoutHistory.push(this.currentWorkoutLog); 
} 
 
exerciseComplete(exercise: ExercisePlan) { 
  this.currentWorkoutLog.lastExercise = exercise.exercise.title; 
  ++this.currentWorkoutLog.exercisesDone; 
} 
 
endTracking(completed: boolean) { 
  this.currentWorkoutLog.completed = completed; 
  this.currentWorkoutLog.endedOn = new Date(); 
  this.currentWorkoutLog = null; 
  this.workoutTracked = false; 
}</pre>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">startTracking</kbd><span class="calibre6"> </span>function creates a<span class="calibre6"> </span><kbd class="calibre13">WorkoutLogEntry</kbd><span class="calibre6"> </span>and adds it to the<span class="calibre6"> </span><kbd class="calibre13">workoutHistory</kbd><span class="calibre6"> </span>array. By setting the<span class="calibre6"> </span><kbd class="calibre13">currentWorkoutLog</kbd><span class="calibre6"> </span>to the newly created log entry, we can manipulate it later during workout execution. The<span class="calibre6"> </span><kbd class="calibre13">endTracking</kbd><span class="calibre6"> </span>function and the<span class="calibre6"> </span><kbd class="calibre13">exerciseComplete</kbd><span class="calibre6"> </span>function just alter<span class="calibre6"> </span><kbd class="calibre13">currentWorkoutLog</kbd>. The<span class="calibre6"> </span><kbd class="calibre13">exerciseComplete</kbd><span class="calibre6"> </span>function should be called on completion of each exercise that is part of the workout.  To save you some keystrokes, get the complete code for implementation done thus far from this gist: <a href="http://bit.ly/ng6be-gist-workout-history-tracker-v1-ts" class="calibre10">http://bit.ly/ng6be-gist-workout-history-tracker-v1-ts</a>.</p>
<p class="calibre3">The service implementation now also includes a function to get workout history data:</p>
<pre class="calibre19">getHistory(): Array&lt;WorkoutLogEntry&gt; { 
  return this.workoutHistory; 
}</pre>
<p class="calibre3">That completes the<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>implementation; now it's time to integrate it into the workout execution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Integrating with WorkoutRunnerComponent</h1>
                
            
            <article>
                
<p class="calibre3"><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>requires<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>to track workout history; hence there is a dependency to be fulfilled. We already<span class="calibre6"> </span>have<span class="calibre6"> </span>registered<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>with Angular's DI framework using the <kbd class="calibre13">Injectable</kbd><span class="calibre6"> </span>decorator and now it's time to consume the service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Injecting dependencies with Constructor Injection</h1>
                
            
            <article>
                
<p class="calibre3">Consuming dependency is easy!<span class="calibre6"> </span><em class="calibre17">More often than not, we use constructor injection to consume a dependency</em>.</p>
<p class="calibre3">Add the<span class="calibre6"> </span><kbd class="calibre13">import</kbd><span class="calibre6"> </span>statement at the<span class="calibre6"> </span>top<span class="calibre6"> </span>and update the<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd> constructor, as follows:</p>
<pre class="calibre19"><strong class="calibre1">import { WorkoutHistoryTrackerService } from '../core/workout-history-tracker.service';</strong><br class="title-page-name"/>... 
constructor(private router: Router,<br class="title-page-name"/>    <strong class="calibre1">private tracker: WorkoutHistoryTrackerService</strong>   
<strong class="calibre1">) {</strong></pre>
<p class="calibre3">As with<span class="calibre6"> </span><kbd class="calibre13">router,</kbd><span class="calibre6"> </span>Angular injects<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>too when<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>is created. Easy!</p>
<p class="calibre3">Once the service is injected and available to<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd>, the service instance (<kbd class="calibre13">tracker</kbd>) needs to be called when the workout starts, when an exercise is complete, and when the workout finishes.</p>
<p class="calibre3">Add this as the first statement in the<span class="calibre6"> </span><kbd class="calibre13">start</kbd><span class="calibre6"> </span>function:</p>
<pre class="calibre19">this.tracker.startTracking();</pre>
<p class="calibre3">In the<span class="calibre6"> </span><kbd class="calibre13">startExerciseTimeTracking</kbd><span class="calibre6"> </span>function, add the highlighted code after the<span class="calibre6"> </span><kbd class="calibre13">clearInterval</kbd><span class="calibre6"> </span>call:</p>
<pre class="calibre19">clearInterval(this.exerciseTrackingInterval); 
<strong class="calibre1">if (this.currentExercise !== this.restExercise) {
    </strong><strong class="calibre1">this.tracker.exerciseComplete(this.workoutPlan</strong><strong class="calibre1">.exercises[this.currentExerciseIndex]);<br class="title-page-name"/></strong><strong class="calibre1">}</strong></pre>
<p class="calibre3">And the highlighted code inside the workout to complete the<span class="calibre6"> </span><kbd class="calibre13">else</kbd><span class="calibre6"> </span>condition in the same function:</p>
<pre class="calibre19"><strong class="calibre1">this.tracker.endTracking(true);</strong> 
this.router.navigate(['/finish']); </pre>
<p class="calibre3">History tracking is almost complete except for one case. What if the user manually navigates away from the workout page? How do we stop tracking?</p>
<p class="calibre3">When that happens, we can always rely on the component's life cycle hooks/events to help us. Workout tracking can be stopped when the<span class="calibre6"> </span><kbd class="calibre13">NgOnDestroy</kbd><span class="calibre6"> </span>event is fired. An appropriate place to perform any cleanup work is before the component is removed from the component tree. Let's do it.</p>
<p class="calibre3">Add this function and the corresponding life cycle event interface to<span class="calibre6"> </span><kbd class="calibre13">workout-runner.component.ts</kbd>:</p>
<pre class="calibre19">export class WorkoutRunnerComponent implements OnInit, <strong class="calibre1">OnDestroy</strong> {<br class="title-page-name"/>...<br class="title-page-name"/>ngOnDestroy() { 
  this.tracker.endTracking(false); 
} </pre>
<p class="calibre3">The workout-history-tracking implementation is complete. We are eager to start the workout history page/component implementation, but not before completing our discussion on Angular's DI capabilities.</p>
<div class="packt_infobox"><br class="calibre27"/>
Feel free to skip the next section for now if you want to maintain the app-building velocity. Come back to this section with a fresh and relaxed mind. There are some very important core concepts we'll share in the next section.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dependency injection in depth</h1>
                
            
            <article>
                
<p class="calibre3">Let's first try to understand the different<span class="calibre6"> </span>places<span class="calibre6"> </span>we can register a dependency using <kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>as an example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Registering dependencies</h1>
                
            
            <article>
                
<p class="calibre3">The standard way to register a dependency is to register it at the root/global level. This<span class="calibre6"> </span>can<span class="calibre6"> </span>be done either by passing the dependency type into the<span class="calibre6"> </span><kbd class="calibre13">provides</kbd><span class="calibre6"> </span>attribute (array) in the<span class="calibre6"> </span><kbd class="calibre13">NgModule</kbd><span class="calibre6"> </span>decorator, or by using the<span class="calibre6"> </span><kbd class="calibre13">providedIn</kbd><span class="calibre6"> </span>attribute on the <kbd class="calibre13">Injectable</kbd><span class="calibre6"> </span>service decorator.</p>
<p class="calibre3">Remember our<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>registration? Check the following:</p>
<pre class="calibre19">@Injectable({<br class="title-page-name"/>  providedIn: CoreModule<br class="title-page-name"/>})<br class="title-page-name"/>export class WorkoutHistoryTrackerService {</pre>
<p class="calibre3">The same thing can be done on the module declaration too, as shown here:</p>
<pre class="calibre19">@NgModule({...<strong class="calibre1">providers: [WorkoutHistoryTrackerService],</strong>})</pre>
<p class="calibre3">Technically speaking, when using any of the preceding mechanisms, the service gets registered with the<span class="calibre6"> </span><strong class="calibre5">app's root injector</strong>, irrespective of the Angular module it is declared in. Any Angular artifact across<span class="calibre6"> </span>modules<span class="calibre6"> </span>henceforth can use the service (<kbd class="calibre13">WorkoutHistoryTrackerService</kbd>). No module imports are required at all.</p>
<div class="packt_infobox"><br class="calibre27"/>
This behavior is different from component/directive/pipe registration. Such artifacts have to be exported from a module for another module to use them.</div>
<p class="calibre3"><em class="calibre17">Another place where dependencies can be registered is on the component</em>. The <kbd class="calibre13">@Component</kbd><span class="calibre6"> </span>decorator has a<span class="calibre6"> </span><kbd class="calibre13">providers</kbd><span class="calibre6"> </span>array parameter to register dependencies. With these two levels of dependency registration, the obvious question that we need to answer is, which one to use?</p>
<p class="calibre3">It seems obvious that if the dependency is exclusively used by a component and its children, it should be registered at the<span class="calibre6"> </span><kbd class="calibre13">@Component</kbd><span class="calibre6"> </span>decorator level. Not really! There is much more we need to understand before we can answer this question. There is a whole new world of hierarchical injectors that need to be introduced. Let's wait, and instead learn other ways of registering dependencies, by continuing our discussion on providers.</p>
<p class="calibre3"><em class="calibre17">Providers create dependencies when the Angular injector requests them</em>.<span class="calibre6"> </span><em class="calibre17">These providers have the recipe to create these dependencies</em>. While a class seems to be the obvious dependency that can be registered, we can also register:</p>
<ul class="calibre11">
<li class="calibre12">A specific object/value</li>
<li class="calibre12">A factory function</li>
</ul>
<p class="calibre3">Registering<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>using the <kbd class="calibre13">Injectable</kbd><span class="calibre6"> </span>decorator is the most common pattern of registration. But at times we need some flexibility with our dependency registrations. To register an object or a factory function, we need to use the expanded version of provider registrations available on<span class="calibre6"> </span><kbd class="calibre13">NgModule</kbd>.</p>
<p class="calibre3">To learn about these variations, we need to explore providers and dependency registration in a little more detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Angular providers</h1>
                
            
            <article>
                
<p class="calibre3">Providers create dependencies that are<span class="calibre6"> </span>served<span class="calibre6"> </span>by the DI framework.</p>
<p class="calibre3">Look at this<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>dependency registration done on<span class="calibre6"> </span><kbd class="calibre13">NgModule</kbd>:</p>
<pre class="calibre19">providers: [WorkoutHistoryTrackerService],</pre>
<p class="calibre3">This syntax is a short-form notation for the following version:</p>
<pre class="calibre19">providers:({ provide: WorkoutHistoryTrackerService, useClass: WorkoutHistoryTrackerService })</pre>
<p class="calibre3">The first property (<kbd class="calibre13">provide</kbd>) is a token that acts as a key for registering a dependency. This key also allows us to locate the dependency during dependency injection.</p>
<p class="calibre3">The second property (<kbd class="calibre13">useClass</kbd>) is a<span class="calibre6"> </span><em class="calibre17">provider definition object</em><span class="calibre6"> </span>that defines the recipe for creating the dependency value.</p>
<p class="calibre3">With<span class="calibre6"> </span><kbd class="calibre13">useClass</kbd>, we are registering a<span class="calibre6"> </span><strong class="calibre5">class provider</strong>. <span class="calibre6"> </span><em class="calibre17">A class provider creates dependencies by instantiating the type of object requested for</em>. There are some other<span class="calibre6"> </span>provider<span class="calibre6"> </span>types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Value providers</h1>
                
            
            <article>
                
<p class="calibre3"><em class="calibre17">A class provider</em> creates class objects and fulfills the dependency, but at<span class="calibre6"> </span>times<span class="calibre6"> </span>we want to register a specific object/primitive with the DI<span class="calibre6"> </span>provider<span class="calibre6"> </span>instead.<span class="calibre6"> </span><strong class="calibre5">Value providers</strong><span class="calibre6"> </span>solve this use case.</p>
<p class="calibre3">Had we registered<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>using this technique, the registration would have looked like this:</p>
<pre class="calibre19">{provide: WorkoutHistoryTrackerService, useValue: <strong class="calibre1">new WorkoutHistoryTrackerService()</strong>};</pre>
<p class="calibre3"><em class="calibre17">With the value provider, we have the responsibility to provide an instance of a service/object/primitive to Angular DI.</em></p>
<p class="calibre3">With the <em class="calibre17">value provider</em>, since we are creating the dependency manually, we are also responsible for constructing any child dependencies if there are dependencies further down the lineage. Take the example of<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>again. If<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>has some dependencies, those too need to be fulfilled by manual injection:</p>
<pre class="calibre19">{provide: WorkoutHistoryTrackerService, useValue: <strong class="calibre1">new WorkoutHistoryTrackerService(new LocalStorage())</strong>});</pre>
<p class="calibre3">In the preceding example, we not only have to create an instance of<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd>, we also have to create an instance of the <kbd class="calibre13">LocalStorage</kbd><span class="calibre6"> </span>service. For a service with a complex dependency graph, setting up that service with a value provider becomes challenging.</p>
<div class="packt_tip"><br class="calibre27"/>
Wherever possible, prefer<span class="packt_screen"> </span><em class="calibre31">class provider</em><span class="packt_screen"> </span>over<span class="packt_screen"> </span><em class="calibre31">value provider</em>.</div>
<p class="calibre3">Value providers still come in handy in specific scenarios. For example, we can<span class="calibre6"> </span>register<span class="calibre6"> </span>a common app configuration using a value provider:</p>
<pre class="calibre19">{provide: AppConfig, {useValue: {name:'Test App', gridSetting: {...} ...}}</pre>
<p class="calibre3">Or register a mock dependency while unit testing:</p>
<pre class="calibre19">{provide:WorkoutHistoryTrackerService, {useValue: new MockWorkoutHistoryTracker()}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Factory providers</h1>
                
            
            <article>
                
<p class="calibre3">There are times when dependency construction is<span class="calibre6"> </span>not<span class="calibre6"> </span>a trivial affair. Construction depends upon external factors. These factors decide what objects or class instances are created and returned.<span class="calibre6"> </span><strong class="calibre5">Factory providers</strong><span class="calibre6"> </span>do this heavy lifting.</p>
<p class="calibre3">Take an example where we want to have different<span class="calibre6"> </span>configurations<span class="calibre6"> </span>for dev and production releases. We can very well use a factory implementation to select the right configuration:</p>
<pre class="calibre19">{provide: AppConfig, useFactory: () =&gt; { 
  if(PRODUCTION) { 
    return {name:'Production App', gridSetting: {...} ...} 
  } 
  else { 
    return {name:'Test App', gridSetting: {...} ...} 
  }
}</pre>
<p class="calibre3">A factory function can have its own dependencies too. In such a case, the syntax changes a bit:</p>
<pre class="calibre19">{provide: WorkoutHistoryTrackerService, useFactory: (environment:Environment) =&gt; { 
  if(Environment.isTest) { 
    return new MockWorkoutHistoryTracker(); 
  } 
  else { 
    return new WorkoutHistoryTrackerService(); 
  }, 
    deps:[Environment]
}</pre>
<p class="calibre3">The dependencies are passed as a parameters to the factory function and registered on the provider definition object property,<span class="calibre6"> </span><kbd class="calibre13">deps</kbd><span class="calibre6"> </span>(<kbd class="calibre13">Environment</kbd><span class="calibre6"> </span>is the dependency injected in the preceding example).</p>
<p class="calibre3">Use the<span class="calibre6"> </span><kbd class="calibre13">UseFactory</kbd> provide<span class="calibre6"> </span>if the construction of the dependency is complex and not everything can be decided during dependency wire-up.</p>
<p class="calibre3">While we have a number of options to declare dependencies, consuming dependencies is far simpler. We saw one way of constructor injection in the <em class="calibre17">Injecting dependencies with Constructor Injection </em>section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Explicit injection using injector</h1>
                
            
            <article>
                
<p class="calibre3">We can even do explicit<span class="calibre6"> </span>injections<span class="calibre6"> </span>using Angular's<span class="calibre6"> </span><strong class="calibre5">Injector service</strong>. This is the<span class="calibre6"> </span>same<span class="calibre6"> </span>injector Angular uses to support DI. Here is how to inject the <kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>service using<span class="calibre6"> </span><kbd class="calibre13">Injector</kbd>:</p>
<pre class="calibre19">constructor(private router: Router, private injector:Injector) {
  this.tracker=injector.get(WorkoutHistoryTrackerService);</pre>
<p class="calibre3">We inject the <span class="calibre6"> </span><kbd class="calibre13">Injector</kbd><span class="calibre6"> </span>service and then ask for the<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>instance explicitly.</p>
<p class="calibre3">When would someone want to do this? Well, almost never. Avoid this pattern as it exposes the DI container to your implementation and adds a bit of noise.</p>
<p class="calibre3">We now know how to register dependency and how to consume it, but how does the DI framework locate these dependencies?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dependency tokens</h1>
                
            
            <article>
                
<p class="calibre3">Remember this<span class="calibre6"> </span>expanded<span class="calibre6"> </span>version of dependency registration shown earlier:</p>
<pre class="calibre19">{ <strong class="calibre1">provide: WorkoutHistoryTrackerService</strong>, useClass: WorkoutHistoryTrackerService }</pre>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">provide</kbd><span class="calibre6"> </span>property value is a<span class="calibre6"> </span><strong class="calibre5">token</strong>. This token is used to identify the dependency to inject. In the preceding example, we use class name or type to<span class="calibre6"> </span>identify<span class="calibre6"> </span>dependency and hence the token is called a <strong class="calibre5">class token</strong>.</p>
<p class="calibre3">Based on the<span class="calibre6"> </span>preceding<span class="calibre6"> </span>registration, whenever Angular sees a statement similar to the following, it injects<span class="calibre6"> the correct dependency based on the class type, here</span><span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6">:</span></p>
<pre class="calibre19">constructor(tracker: WorkoutHistoryTrackerService)</pre>
<p class="calibre3">Angular supports some other tokens too.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using InjectionToken</h1>
                
            
            <article>
                
<p class="calibre3">There are times when the dependency we define is either a primitive, object, or function. In such a scenario, the class token cannot be used as there is no class. Angular solves this problem using<span class="calibre6"> </span><kbd class="calibre13">InjectionToken</kbd><span class="calibre6"> </span>(or<span class="calibre6"> </span><strong class="calibre5">string tokens</strong><span class="calibre6"> </span>as we'll see later). <span class="calibre6">The app configuration registration examples that we shared earlier can be rewritten using string tokens if there is no </span><kbd class="calibre13">AppConfig</kbd><span class="calibre6"> class.</span></p>
<p class="calibre3">To register a dependency using<span class="calibre6"> </span><kbd class="calibre13">InjectionToken</kbd>, we first need to create the<span class="calibre6"> </span><span class="calibre6"><kbd class="calibre13">InjectionToken</kbd> class instance</span>:</p>
<pre class="calibre19">export const APP_CONFIG = new InjectionToken('Application Configuration');</pre>
<p class="calibre3">Then, use the token to register the dependency:</p>
<pre class="calibre19"><span>{ provide: APP_CONFIG, useValue: {name:'Test App', gridSetting: {...} ...});</span></pre>
<p class="calibre3">And finally, inject the dependency anywhere using the<span class="calibre6"> </span><kbd class="calibre13">@Inject</kbd><span class="calibre6"> </span>decorator:</p>
<pre class="calibre19">constructor(@Inject(APP_CONFIG) config) { }</pre>
<div class="packt_infobox">Interestingly, when<span class="packt_screen"> </span><kbd class="calibre24">@Inject()</kbd><span class="packt_screen"> </span>is not present, the injector uses the type/class name of the parameter (<em class="calibre31">class token</em>) to locate the dependency.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using string tokens</h1>
                
            
            <article>
                
<p class="calibre3">Angular also supports<span class="calibre6"> </span><strong class="calibre5">string tokens</strong>, allowing us to use string literals to identify and inject dependencies. The preceding example with a<span class="calibre6"> </span>string<span class="calibre6"> </span>token becomes:</p>
<pre class="calibre19"><span>{ provide: <strong class="calibre1">'appconfig'</strong>, useValue: {name:'Test App', gridSetting: {...} ...});<br class="title-page-name"/>...<br class="title-page-name"/></span>constructor(@Inject(<strong class="calibre1">'appconfig'</strong>) config) { }</pre>
<p class="calibre3">A downside to string tokens is that you can misspell the token across the declaration and injection.</p>
<p class="calibre3">Phew! This was a really long section on Angular's Dependency Injection and there's still stuff left to cover. For now, let's get back on track and add the workout history page.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding the workout history page</h1>
                
            
            <article>
                
<p class="calibre3">The workout history data that we are collecting<span class="calibre6"> </span>during<span class="calibre6"> </span>the execution of the workout can now be rendered in a view. Let's add a<span class="calibre6"> </span><kbd class="calibre13">History</kbd><span class="calibre6"> </span>component. The component will be available at the<span class="calibre6"> </span><kbd class="calibre13">/history</kbd><span class="calibre6"> </span>location and can be loaded by clicking on a link in the app header section.</p>
<p class="calibre3">Update the route definition in<span class="calibre6"> </span><kbd class="calibre13">app.routes.ts</kbd><span class="calibre6"> </span>to include a new route and the related import:</p>
<pre class="calibre19"><strong class="calibre1">import { WorkoutHistoryComponent } from './workout-history/workout-history.component';</strong> 
... 
export const routes: Routes = [ 
  ..., 
<strong class="calibre1">  { path: 'history', component: WorkoutHistoryComponent }</strong> ,
  { path: '**', redirectTo: '/start' } 
]) </pre>
<p class="calibre3">The<span class="calibre6"> </span><span class="calibre6">History</span><span class="calibre6"> </span>link needs to be added to the app header section. Let's refactor the header section into its own component. Update the<span class="calibre6"> </span><kbd class="calibre13">app.component.html</kbd><span class="calibre6"> </span>template and replace the<span class="calibre6"> </span><kbd class="calibre13">nav</kbd><span class="calibre6"> </span>element with the following code:</p>
<pre class="calibre19">&lt;div id="header"&gt;<br class="title-page-name"/>    &lt;abe-header&gt;&lt;/abe-header&gt;<br class="title-page-name"/>&lt;/div&gt; </pre>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">nav</kbd><span class="calibre6"> </span>element moves into a header component, which we still need to create. Use<span class="calibre6"> </span><kbd class="calibre13">ng generate</kbd><span class="calibre6"> </span>to generate a new <kbd class="calibre13">HeaderComponent</kbd> component by running the command inside the <kbd class="calibre13">trainer/src/app/core</kbd><span class="calibre6"> </span>folder:</p>
<pre class="calibre19"><strong class="calibre1">ng generate component header -is</strong></pre>
<p class="calibre3">This statement creates a new header component and declares it on the core module. Next, update the definition for the header component (<kbd class="calibre13">header.component.ts</kbd>) and its view (<kbd class="calibre13">header.component.html</kbd>) from the <kbd class="calibre13">checkpoint3.2</kbd> Git branch (GitHub location:<span class="calibre6"> </span><a href="http://bit.ly/ng6be-3-2-header" class="calibre10">http://bit.ly/ng6be-3-2-header</a>).</p>
<p class="calibre3">While we have added the header element to<span class="calibre6"> </span><kbd class="calibre13">app.component.html</kbd>, the header component will not render unless we import the core module and export the component from the core module. Angular CLI did the first part for us, for the second part, update<span class="calibre6"> </span><kbd class="calibre13">core.module.ts</kbd><span class="calibre6"> </span>to:</p>
<pre class="calibre19">imports: [ CommonModule, <strong class="calibre1">RouterModule</strong>],<br class="title-page-name"/>declarations: [HeaderComponent],    <br class="title-page-name"/><strong class="calibre1">exports: [HeaderComponent]</strong></pre>
<p class="calibre3">If you look at the <kbd class="calibre13">HeaderComponent</kbd><span class="calibre6"> </span>view, the history link is now there. We had to import<span class="calibre6"> </span><kbd class="calibre13">RouterModule</kbd> as the following link is generated using the <kbd class="calibre13">RouterLink</kbd><span class="calibre6"> </span>directive, which is part of<span class="calibre6"> </span><kbd class="calibre13">RouterModule</kbd>:</p>
<pre class="calibre19">&lt;a class="nav-link" routerLink="/history" title="Workout History"&gt;History&lt;/a&gt;</pre>
<p class="calibre3">Let's add the workout history component by first generating the component's boilerplate. From the command line, navigate to<span class="calibre6"> </span><kbd class="calibre13">trainer/src/app</kbd><span class="calibre6"> </span>and run:</p>
<pre class="calibre19"><strong class="calibre1">ng generate component workout-history -is</strong></pre>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryComponent</kbd><span class="calibre6"> </span>implementation is available in the <kbd class="calibre13">checkpoint3.2</kbd> Git branch; the folder is<span class="calibre6"> </span><kbd class="calibre13">workout-history</kbd><span class="calibre6"> </span>(GitHub location:<span class="calibre6"> </span><a href="http://bit.ly/ng6be-3-2-workout-history" class="calibre10">http://bit.ly/ng6be-3-2-workout-history</a>).</p>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryComponent</kbd><span class="calibre6"> </span>view code is trivial, to say the least: a few Angular constructs, including<span class="calibre6"> </span><kbd class="calibre13">ngFor</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">ngIf</kbd>. The component implementation too is pretty straightforward. Inject the<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>service dependency and load the history data when<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryComponent</kbd><span class="calibre6"> </span>is initialized:</p>
<pre class="calibre19">ngOnInit() { 
  this.history = this.tracker.getHistory(); 
}</pre>
<p class="calibre3">And this time, we use the<span class="calibre6"> </span><kbd class="calibre13">Location</kbd><span class="calibre6"> </span>service instead of<span class="calibre6"> </span><kbd class="calibre13">Router</kbd><span class="calibre6"> </span>to navigate away from the<span class="calibre6"> </span><kbd class="calibre13">history</kbd><span class="calibre6"> </span>component:</p>
<pre class="calibre19">goBack() { 
  this.location.back(); 
}</pre>
<p class="calibre3">The Location service is used to interact with the browser URL. Depending upon the URL strategy, either URL paths (such as<span class="calibre6"> </span><kbd class="calibre13">/start</kbd> or <kbd class="calibre13">/workout</kbd>) or URL hash segments (such as<span class="calibre6"> </span><kbd class="calibre13">#/start</kbd> or <kbd class="calibre13">#/workout</kbd>) are used to track location changes. The router service internally uses the location service to trigger navigation.</p>
<div class="packt_tip"><span class="packt_screen">Router versus Location</span><br class="calibre27"/>
While the<span class="packt_screen"> </span><kbd class="calibre24">Location</kbd><span class="packt_screen"> </span>service allows us to perform navigation, using<span class="packt_screen"> </span><kbd class="calibre24">Router</kbd><span class="packt_screen"> </span>is a preferred way of performing route navigation. We used the location service here because the need was to navigate to the last route without bothering about how to construct the route.</div>
<p class="calibre3">We are ready to test our workout<span class="calibre6"> </span>history<span class="calibre6"> </span>implementation. Load the start page and click on the<span class="calibre6"> </span><span class="calibre6">History</span><span class="calibre6"> </span>link. The history page is loaded with an empty grid. Go back, start a workout, and let an exercise complete. Check the history page again; there should be a workout listed:</p>
<div class="packt_figure"><img src="../images/00023.jpeg" class="calibre47"/></div>
<p class="calibre3">Looks good! If we run the workout multiple times and let the history list build, we realize there is one sore point in this listing. Historical data is not sorted in reverse-chronological order, with the newest at the top. Also, it would be great if we had some filtering capabilities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Sorting and filtering history data using pipes</h1>
                
            
            <article>
                
<p class="calibre3">In<span class="calibre6"> </span><a href="" class="calibre10">Chapter 2</a>,<span class="calibre6"> </span><em class="calibre17">Building Our First App <span class="calibre6">–</span><span class="calibre6"> </span>7-Minute Workout</em>, we explored pipes. We even built our own pipe to format the seconds values as hh:mm:ss. The primary purpose of pipes is to transform data and, surprisingly, they work on arrays too! For arrays, pipes can sort and filter data. We create two pipes, one for<span class="calibre6"> </span>each<span class="calibre6"> </span>sorting and filtering.</p>
<div class="packt_infobox">AngularJS has prebuilt filters (filters are pipes in Angular),<span class="packt_screen"> </span><kbd class="calibre24">orderBy</kbd><span class="packt_screen"> </span>and<span class="packt_screen"> </span><kbd class="calibre24">filter</kbd>, for this very purpose. Angular does not come with these pipes and there is a good reason. These pipes are prone to poor performance. Learn the rationale behind this decision in the framework documentation on pipes at <a href="http://bit.ly/ng-no-filter-orderby-pipe" class="calibre21">http://bit.ly/ng-no-filter-orderby-pipe</a>.</div>
<p class="calibre3">Let's start with the<span class="calibre6"> </span><kbd class="calibre13">orderBy</kbd><span class="calibre6"> </span>pipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The orderBy pipe</h1>
                
            
            <article>
                
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">orderBy</kbd><span class="calibre6"> </span>pipe we implement is going to<span class="calibre6"> </span>order<span class="calibre6"> </span>an array of objects based on any of the object's properties. The usage pattern for sorting items in ascending order based on the<span class="calibre6"> </span><kbd class="calibre13">fieldName</kbd><span class="calibre6"> </span>property is going to be:</p>
<pre class="calibre19">*ngFor="let item of items| orderBy:fieldName"</pre>
<p class="calibre3">And for sorting items in descending order, the usage pattern is:</p>
<pre class="calibre19">*ngFor="let item of items| orderBy:-fieldName"</pre>
<p class="calibre3">Make note of the extra hyphen (<kbd class="calibre13">-</kbd>) before<span class="calibre6"> </span><kbd class="calibre13">fieldName</kbd>.</p>
<p class="calibre3">We plan to add<span class="calibre6"> </span><kbd class="calibre13">OrderByPipe</kbd><span class="calibre6"> </span>in a new shared module. Are you thinking, why not add it to core module? By convention, the core module contains global services and one-time-use components.<span class="calibre6"> </span>This<span class="calibre6"> </span>is exactly one core module per application. Shared modules, on the other hand, have components/directives/pipes that<span class="calibre6"> </span><span class="calibre6">are shared </span>across modules. Such shared modules can be also be defined at multiple levels, across the parent and child modules. In this case, we will define the shared module inside<span class="calibre6"> </span><kbd class="calibre13">AppModule</kbd>.</p>
<p class="calibre3">Create a new <kbd class="calibre13">SharedModule</kbd> module by running this command in the <kbd class="calibre13">trainer/src/app</kbd><span class="calibre6"> </span>directory:</p>
<pre class="calibre19"><strong class="calibre1">ng generate module shared --module app</strong></pre>
<p class="calibre3">From the command line, navigate to the <kbd class="calibre13">trainer/src/app/shared</kbd> folder and generate the order by pipe boilerplate:</p>
<pre class="calibre19"><strong class="calibre1">ng generate pipe order-by</strong></pre>
<p class="calibre3">Open<span class="calibre6"> </span><kbd class="calibre13">order-by.pipe.ts</kbd><span class="calibre6"> </span>and update the definition from the checkpoint3.2 code (GitHub location:<span class="calibre6"> </span><a href="http://bit.ly/ng6be-3-2-order-by-pipe" class="calibre10">http://bit.ly/ng6be-3-2-order-by-pipe</a>). While we are not going to delve into the pipe's implementation details, some relevant parts need to be highlighted. Look at this pipe outline:</p>
<pre class="calibre19">@Pipe({ name: 'orderBy' }) 
export class OrderByPipe {
  transform(value: Array&lt;any&gt;, field:string): any { 
   ... 
  } 
}</pre>
<p class="calibre3">The preceding<span class="calibre6"> </span><kbd class="calibre13">field</kbd><span class="calibre6"> </span>variable receives the field on which sorting is required. If the field has a<span class="calibre6"> </span><kbd class="calibre13">-</kbd><span class="calibre6"> </span>prefix, we truncate the prefix before sorting the array in descending order.</p>
<div class="packt_infobox">The pipe also uses the spread operator, <kbd class="calibre24">[...]</kbd>, which may be new to you. Learn more about the spread operator on MDN at <a href="http://bit.ly/js-spread" class="calibre21">http://bit.ly/js-spread</a>.</div>
<p class="calibre3">To use<span class="calibre6"> </span><kbd class="calibre13">OrderByPipe</kbd>, update the template view for<span class="calibre6"> </span>workout<span class="calibre6"> </span>history:</p>
<pre class="calibre19">&lt;tr *ngFor="let historyItem of history<strong class="calibre1">|orderBy:'-startedOn'</strong>; let i = index"&gt; </pre>
<p class="calibre3">And again, we need to export the pipe from the shared module allowing <kbd class="calibre13">WorkoutHistoryComponent</kbd><span class="calibre6"> </span>to use it. Add an exports property on <kbd class="calibre13">SharedModule</kbd><span class="calibre6"> </span>and set it to<span class="calibre6"> </span><kbd class="calibre13">OrderByPipe</kbd>:</p>
<pre class="calibre19">declarations:[...],<br class="title-page-name"/><strong class="calibre1">exports:[OrderByPipe]</strong></pre>
<p class="calibre3">The historical data will now be sorted in descending order on the <kbd class="calibre13">startedOn</kbd> field.</p>
<div class="packt_infobox">Make note of the single quotes around the pipe parameter (<kbd class="calibre24">'-startedOn'</kbd>). We are passing a literal string to the<span class="packt_screen"> </span><kbd class="calibre24">orderBy</kbd><span class="packt_screen"> </span>pipe. Pipe parameters support data binding and can be bound to component properties too.</div>
<p class="calibre3">That's enough for the<span class="calibre6"> </span><kbd class="calibre13">orderBy</kbd><span class="calibre6"> </span>pipe. Let's implement filtering.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pipe chaining with search pipe</h1>
                
            
            <article>
                
<p class="calibre3">We start by creating the search pipe boilerplate by running the following command from the <kbd class="calibre13">trainer/src/app/shared</kbd><span class="calibre6"> </span>folder:</p>
<pre class="calibre19"><strong class="calibre1">ng generate pipe search</strong></pre>
<p class="calibre3">The implementation can now be copied from checkpoint3.2 (GitHub location:<span class="calibre6"> </span><a href="http://bit.ly/ng6be-3-2-search-pipe" class="calibre10">http://bit.ly/ng6be-3-2-search-pipe</a>). <kbd class="calibre13">SearchPipe</kbd><span class="calibre6"> </span>does a<span class="calibre6"> </span>basic<span class="calibre6"> </span>equality-based filtering. Nothing special.</p>
<p class="calibre3">Look at the pipe code; the pipe takes two arguments, the first being the field to search, and the second the value to search. We use the JavaScript array's<span class="calibre6"> </span><kbd class="calibre13">filter</kbd><span class="calibre6"> </span>function to filter the record, doing a strict equality check. Wondering about the <kbd class="calibre13">pure</kbd><span class="calibre6"> </span>attribute on the<span class="calibre6"> </span><kbd class="calibre13">Pipe</kbd><span class="calibre6"> </span>decorator? This is going to be the subject of discussion in the next section.</p>
<p class="calibre3">Let's update the workout history view and incorporate the search pipe too. Open<span class="calibre6"> </span><kbd class="calibre13">workout-history.component.html</kbd><span class="calibre6"> </span>and uncomment the div with radio buttons. These radio buttons filter workouts based on whether they were completed or not. This is how the HTML filter selection looks:</p>
<pre class="calibre19">&lt;label&gt;&lt;input type="radio" name="searchFilter" value=""  
    (change)="completed = null" checked=""&gt;All &lt;/label&gt; 
&lt;label&gt;&lt;input type="radio" name="searchFilter" value="true"  
    (change)="completed = $event.target.value=='true'"&gt; Completed &lt;/label&gt; 
&lt;label&gt;&lt;input type="radio" name="searchFilter" value="false"  
    (change)="completed = $event.target.value=='true'"&gt; Incomplete &lt;/label&gt; </pre>
<p class="calibre3">We define three filters:<span class="calibre6"> </span><kbd class="calibre13">all</kbd>,<span class="calibre6"> </span><kbd class="calibre13">completed</kbd>, and<span class="calibre6"> </span><kbd class="calibre13">incomplete</kbd><span class="calibre6"> </span>workouts. The radio selection sets the component's <kbd class="calibre13">completed</kbd> property using the<span class="calibre6"> </span><kbd class="calibre13">change</kbd><span class="calibre6"> </span>event expression.<span class="calibre6"> </span><kbd class="calibre13">$event.target</kbd><span class="calibre6"> </span>is the radio button that was clicked. </p>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">search</kbd><span class="calibre6"> </span>pipe can now be added to the<span class="calibre6"> </span><kbd class="calibre13">ngFor</kbd><span class="calibre6"> </span>directive expression. We are going to chain the<span class="calibre6"> </span><kbd class="calibre13">search</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">orderBy</kbd><span class="calibre6"> </span>pipes. Update the<span class="calibre6"> </span><kbd class="calibre13">ngFor</kbd><span class="calibre6"> </span>expression to:</p>
<pre class="calibre19">&lt;tr *ngFor="let historyItem of history <strong class="calibre1">|search:'completed':completed</strong> |orderBy:'-startedOn';  
    let i = index"&gt;</pre>
<p class="calibre3">A great example of Angular's pipe chaining capabilities!</p>
<p class="calibre3">As we did with<span class="calibre6"> </span><kbd class="calibre13">OrderByPipe</kbd>,<span class="calibre6"> </span><kbd class="calibre13">SearchPipe</kbd><span class="calibre6"> </span>too needs to be exported from the shared module before using it.</p>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">search</kbd><span class="calibre6"> </span>pipe first filters the historical data, followed by the<span class="calibre6"> </span><kbd class="calibre13">orderBy</kbd><span class="calibre6"> </span>pipe reordering it. Pay close attention to the<span class="calibre6"> </span><kbd class="calibre13">search</kbd><span class="calibre6"> </span>pipe parameters: the first parameter is a string literal denoting the field to search (<span class="calibre6"><kbd class="calibre13">historyItem.completed</kbd></span>), whereas the second parameter is derived from the component's <kbd class="calibre13">completed</kbd> property. Having the ability to bind pipe parameters to component properties allows us great flexibility.</p>
<p class="calibre3">Go ahead and verify the search capabilities of the<span class="calibre6"> </span>history<span class="calibre6"> </span>page. Based on the radio selection, the history records are filtered, and of course, they are sorted in reverse-chronological order based on the workout start dates.</p>
<p class="calibre3">While pipe usage with arrays looks simple, it can throw up some surprises if we do not understand when pipes are evaluated.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pipe gotcha with arrays</h1>
                
            
            <article>
                
<p class="calibre3">To understand the issue<span class="calibre6"> </span>with<span class="calibre6"> </span>pipes applied to arrays, let's reproduce the problem.</p>
<p class="calibre3">Open<span class="calibre6"> </span><kbd class="calibre13">search.pipe.ts</kbd><span class="calibre6"> </span>and remove the<span class="calibre6"> </span><kbd class="calibre13">@Pipe</kbd><span class="calibre6"> </span>decorator's <kbd class="calibre13">pure</kbd> attribute. Also, take the following statement:</p>
<pre class="calibre19">if (searchTerm == null) return [...value];</pre>
<p class="calibre3">And change it into this:</p>
<pre class="calibre19">if (searchTerm == null) return [value];</pre>
<p class="calibre3">Add a button at the end of the radio list (in<span class="calibre6"> </span><kbd class="calibre13">workout-history.component.html</kbd>) that adds a new log entry to the<span class="calibre6"> </span><kbd class="calibre13">history</kbd><span class="calibre6"> </span>array:</p>
<pre class="calibre19">&lt;button (click)="addLog()"&gt;Add Log&lt;/button&gt;</pre>
<p class="calibre3">Add a function to<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryComponent</kbd>:</p>
<pre class="calibre19">addLog() { 
  this.history.push(Object.assign({}, this.history[this.history.length-1])); 
}</pre>
<p class="calibre3">The preceding function duplicates the first history item and adds back to the<span class="calibre6"> </span><kbd class="calibre13">history</kbd><span class="calibre6"> </span>array. If we load the page and click on the button, a new log entry gets added to the history array, but it does not show up on the view unless we change the filter (by clicking on the other radios). Interesting!</p>
<div class="packt_infobox"><br class="calibre27"/>
Before calling<span class="packt_screen"> </span><kbd class="calibre24">addLog</kbd><span class="packt_screen"> </span>make sure at least one history log is already there; otherwise the<span class="packt_screen"> </span><kbd class="calibre24">addLog</kbd><span class="packt_screen"> </span>function will fail.</div>
<p class="calibre3">The pipes that we have built thus far are<span class="calibre6"> </span><strong class="calibre5">stateless</strong><span class="calibre6"> </span>(also called<span class="calibre6"> </span><strong class="calibre5">pure</strong>) in nature. They simply transform input data into output.<span class="calibre6"> </span><strong class="calibre5">Stateless</strong><span class="calibre6"> </span><strong class="calibre5">pipes</strong><span class="calibre6"> </span>are reevaluated only<span class="calibre6"> </span>if the pipe input changes (the expression on the left side of pipe symbol) or any pipe argument is updated.</p>
<p class="calibre3">For arrays, this happens on an array assignment/reference change and not on the addition or deletion of elements. Switching the filter condition works, as it causes the search pipe to evaluate again as the search parameter (the <kbd class="calibre13">completed</kbd><span class="calibre6"> </span>status) changes. This behavior is something to be aware of.</p>
<p class="calibre3">What's the fix? For starters, we can make the history array immutable, which implies that it cannot be changed once created. To add a new element, we need to create a new array<span class="calibre6"> </span>with<span class="calibre6"> </span>the new value, something like:</p>
<pre class="calibre19">this.history = [...this.history,  Object.assign({}, this.history[0])];</pre>
<p class="calibre3">This works perfectly, but we are changing our implementation to make it work with pipes which is incorrect. Instead, we can change the pipe. The<span class="calibre6"> </span><span class="calibre6">pipe should be marked stateful</span>.</p>
<p class="calibre3">The difference between a stateless and stateful pipe is that stateful pipes are evaluated by Angular every time the framework does a change-detection run, which involves checking the complete application for changes. Therefore, with stateful pipes, the check is not limited to the pipe input/argument changes.</p>
<p class="calibre3">To make a <kbd class="calibre13">search</kbd><span class="calibre6"> </span>pipe stateless, just revert the first change we made and add back<span class="calibre6"> </span><kbd class="calibre13">pure: false</kbd><span class="calibre6"> </span>on the<span class="calibre6"> </span><kbd class="calibre13">Pipe</kbd><span class="calibre6"> </span>decorator:</p>
<pre class="calibre19">@Pipe({ 
  name: 'search', 
<strong class="calibre1">  pure:false</strong> 
}) </pre>
<p class="calibre3">It still does not work! The<span class="calibre6"> </span><kbd class="calibre13">search</kbd><span class="calibre6"> </span>pipe has one more quirk that needs a fix. The<span class="calibre6"> </span><span class="calibre6">All</span> radio selection does not work perfectly. Add a new workout log, and it still will not show up, unless we switch filters.</p>
<p class="calibre3">The fix here is to revert the second change. Isolate this line in the <kbd class="calibre13">search</kbd><span class="calibre6"> </span>pipe:</p>
<pre class="calibre19">if (searchTerm == null) return value;</pre>
<p class="calibre3">And change it to the following:</p>
<pre class="calibre19">if (searchTerm == null) return [...value];</pre>
<p class="calibre3">We changed the<span class="calibre6"> </span><kbd class="calibre13">if</kbd><span class="calibre6"> </span>condition to return a new array every time (using the spread operator), even when<span class="calibre6"> </span><kbd class="calibre13">searchTerm</kbd><span class="calibre6"> </span>is<span class="calibre6"> </span><kbd class="calibre13">null</kbd>. If we return the same array reference, Angular does not check for a size change in the array and hence does not update the UI.</p>
<p class="calibre3">That completes our History page implementation. You<span class="calibre6"> </span>may<span class="calibre6"> </span>now be wondering what the last few fixes on pipes have to do with how change detection works. Or you may be wondering what change detection is. Let's put all of these doubts to rest and introduce everyone to<span class="calibre6"> </span><em class="calibre17">Angular's change-detection system</em>.</p>
<div class="packt_infobox">Angular's change detection will be covered extensively in<span class="packt_screen"> </span><a href="" class="calibre21">Chapter 8</a>,<span class="packt_screen"> </span><em class="calibre31">Some Practical Scenarios</em>. The aim of the next section is to introduce the concept of change detection and how Angular performs this process.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Angular change detection overview</h1>
                
            
            <article>
                
<p class="calibre3">To put it succinctly, change<span class="calibre6"> </span>detection<span class="calibre6"> </span>is all about tracking changes done to the component's model during app execution. This helps Angular's data-binding infrastructure to identify what parts of the view need to be updated. Every data binding framework needs to address this issue, and the approach these frameworks take for tracking changes differs. It even differs from AngularJS to Angular.</p>
<p class="calibre3">To understand how change detection works in Angular, there are a few things that we need to keep in mind.</p>
<ul class="calibre11">
<li class="calibre12">An Angular app is nothing but a hierarchy of components, from the root to the leaf.</li>
<li class="calibre12">There is nothing special about the component properties that we bind to view; therefore Angular needs an efficient mechanism to know when these properties change. It cannot keep polling for changes in these properties.</li>
</ul>
<ul class="calibre11">
<li class="calibre12">To detect changes in a property value, Angular does a<span> </span><em class="calibre2">strict comparison</em><span> </span>(<kbd class="calibre13">===</kbd>) between the previous and current value. For reference types, it means only the references are compared. No deep comparison is done.</li>
</ul>
<div class="packt_infobox">For precisely this reason, we had to mark our search pipe as stateful. Adding elements to an existing array does not change the array reference and hence Angular fails to detect any change in the array. Once the pipe is marked as stateful, the pipe is evaluated, irrespective of whether the array has changed or not.</div>
<p class="calibre3">Since Angular cannot know when any bound property is updated automatically, it instead resorts to checking every bound property when a change detection run is triggered. Starting from the root of the component tree, Angular checks each bound property for changes as it goes down the component hierarchy. If a change is detected, that component is marked for refresh. It's worth reiterating that changes in a bound property do not immediately update the view. Instead, a change-detection run works in two phases.</p>
<ul class="calibre11">
<li class="calibre12">In the<span> </span><em class="calibre2">first phase</em>, it does the component tree walk and marks components that need to be refreshed due to model updates</li>
<li class="calibre12">In the<span> </span><em class="calibre2">second phase</em>, the actual view is synchronized with the underlying model</li>
</ul>
<div class="packt_infobox"><br class="calibre27"/>
Model changes and view updates are never interleaved during a change-detection run.</div>
<p class="calibre3">We now just need to answer two more questions:</p>
<ul class="calibre11">
<li class="calibre12">When is a change-detection run triggered?</li>
<li class="calibre12">How many times does it run?</li>
</ul>
<p class="calibre3">An Angular change-detection run is triggered when any of these<span class="calibre6"> </span>events<span class="calibre6"> </span>are triggered:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">User input/browser events</strong>: We click on a button, enter some text, scroll the content. Each of these actions can update the view (and the underlying model).</li>
<li class="calibre12"><strong class="calibre1">Remote XHR requests</strong>: This is another common reason for view updates. Getting data from a remote server to show on the grid and getting user data to render a view are examples of this.</li>
<li class="calibre12"><strong class="calibre1">setTimeout and setInterval</strong>: As it turns out, we can use<span> </span><kbd class="calibre13">setTimeout</kbd><span> </span>and<span> </span><kbd class="calibre13">setInterval</kbd><span> </span>to execute some code asynchronously and at specific intervals. Such code can also update the model. For example, a<span> </span><kbd class="calibre13">setInterval</kbd><span> </span>timer may check for stock quotes at regular intervals and update the stock price on the UI.</li>
</ul>
<p class="calibre3">To answer how many times,<span class="calibre6"> </span><strong class="calibre5">it's one</strong>. Each component model is checked only once, in a top-down fashion, starting from the root component to the tree leaves.</p>
<div class="packt_infobox">The last statement is true when Angular is configured to run in production mode. In development mode, the component tree is traversed twice for changes. Angular expects the model to be stable after the first tree walk. If that is not the case, Angular throws an error in development mode, and ignores the changes in production mode. We can enable the production mode by invoking the <kbd class="calibre24">enableProdMode</kbd><span class="packt_screen"> </span>function before the<span class="packt_screen"> </span><kbd class="calibre24">bootstrap</kbd><span class="packt_screen"> </span>function call. </div>
<p class="calibre3">It's time now to pick another topic linked to Angular's depedency injection. The concept of<span class="calibre6"> </span><strong class="calibre5">hierarchical injectors</strong><span class="calibre6"> </span>will be our next topic of discussion.  It is a very powerful feature that can come in handy as we build bigger and better apps using Angular.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Hierarchical injectors</h1>
                
            
            <article>
                
<p class="calibre3">An<span class="calibre6"> </span><strong class="calibre5">injector</strong><span class="calibre6"> </span>in Angular's dependency injection setup is a container that is<span class="calibre6"> </span>responsible<span class="calibre6"> </span>for storing dependencies and dispensing them when asked for. The<span class="calibre6"> </span>provider<span class="calibre6"> </span>registration examples shared earlier actually register the dependencies with a global injector.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Registering component-level dependencies</h1>
                
            
            <article>
                
<p class="calibre3">All of the dependency registrations that we have<span class="calibre6"> </span>done<span class="calibre6"> </span>thus far were done on a module. Angular goes one step further and allows registration of dependencies at the component level too. There is a similar<span class="calibre6"> </span><kbd class="calibre13">providers</kbd><span class="calibre6"> </span>attribute on the <kbd class="calibre13">@Component</kbd><span class="calibre6"> </span>decorator that allows us to register dependency at the component level.</p>
<p class="calibre3">We could've very well registered the<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>dependency on<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd>. Something along these lines:</p>
<pre class="calibre19">@Component({ 
  selector: 'abe-workout-runner', 
  providers: [WorkoutHistoryTrackerService] <br class="title-page-name"/>  ...
})</pre>
<p class="calibre3">But whether we should do it or not is something that we discuss here.</p>
<p class="calibre3">In the context of this discussion on hierarchical injectors, it's important to understand that Angular creates an injector per component (oversimplified). Dependency registration done at the component level is available on the component and its descendants.</p>
<p class="calibre3">We also learned that dependencies are singleton in nature. Once created, the injector will always return the same dependency every time. This feature is evident from the workout history implementation.</p>
<p class="calibre3"><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>was registered with the<span class="calibre6"> </span><kbd class="calibre13">CoreModule</kbd><span class="calibre6"> </span>and then injected into two components: <kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryComponent</kbd>. Both components get the same instance of<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd>. The next diagram highlights this registration and injection:</p>
<div class="packt_figure"><img src="../images/00024.jpeg" class="calibre48"/></div>
<p class="calibre3">To confirm, just add a<span class="calibre6"> </span><kbd class="calibre13">console.log</kbd><span class="calibre6"> </span>statement in the <kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>constructor:</p>
<pre class="calibre19">console.log("WorkoutHistoryTrackerService instance created.")</pre>
<p class="calibre3">Refresh the app and open the history page by clicking on the header link. The message log is generated once, irrespective of how many times we run the workout or open the history page.</p>
<p class="calibre3">That's also a new interaction/data flow pattern!</p>
<p class="calibre3">Think carefully; a service is being used to share state between two components.<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>is generating data and<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryComponent</kbd><span class="calibre6"> </span>is consuming it. And without any interdependence. We are exploiting the fact that dependencies are singleton in nature. This data-sharing/interaction/data-flow pattern can be used to share state between any number of components. Indeed, this is a very powerful weapon in our arsenal. The next time there is a need to share state between unrelated components, think of services.</p>
<p class="calibre3">But what does all this<span class="calibre6"> </span>have<span class="calibre6"> </span>to do with hierarchical injectors? OK, let's not beat around the bush; let's get straight to the point.</p>
<p class="calibre3">While dependencies registered with the injector are singleton,<span class="calibre6"> </span><kbd class="calibre13">Injector</kbd><span class="calibre6"> </span>itself is not! At any given point in time, there are multiple injectors active in the application. In fact, injectors are created in the same hierarchy as the component tree. Angular creates an<span class="calibre6"> </span><kbd class="calibre13">Injector</kbd><span class="calibre6"> </span>instance for every component in the component tree (oversimplification; see the next information box).</p>
<div class="packt_infobox">Angular does not literally create an injector for each component. As explained in the Angular developer guide: every component doesn't need its own injector and it would be horribly inefficient to create masses of injectors for no good purpose. But it is true that every component has an injector (even if it shares that injector with another component) and there may be many different injector instances operating at different levels of the component tree. It is useful to pretend that every component has its own injector.</div>
<p class="calibre3">The component and injector tree looks something like this when a workout is running:</p>
<div class="packt_figure"><img src="../images/00025.jpeg" class="calibre49"/></div>
<p class="calibre3">The insert textbox denotes the component name. The<span class="calibre6"> </span><strong class="calibre5">root injector</strong><span class="calibre6"> </span>is the injector<span class="calibre6"> </span>created<span class="calibre6"> </span>as part of the application bootstrap process.</p>
<p class="calibre3">What is the significance of this injector hierarchy? To understand the implications, we need to understand what happens when a component requests a dependency.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Angular DI dependency walk</h1>
                
            
            <article>
                
<p class="calibre3">Whenever requested for a dependency, Angular first<span class="calibre6"> </span>tries<span class="calibre6"> </span>to satisfy the dependency from the component's own injector. If it fails to find the requested dependency, it queries the parent component injector for the dependency, and its parent if the probing fails again, and so on and so forth till it finds the dependency or reaches the root injector. The takeaway: any dependency search is hierarchy-based.</p>
<p class="calibre3">Earlier when we registered<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd>, it was registered with the root injector. The<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>dependency request from both<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryComponent</kbd><span class="calibre6"> </span>gets satisfied by the root injector, and not by their own component injectors.</p>
<p class="calibre3">This hierarchical injector structure brings a lot of flexibility. We can configure different providers at different component levels and override the parent provider configuration in child components. This only applies to dependencies registered on components. If the dependency is added to a module, it gets registered on the root injector.</p>
<p class="calibre3">Also, if a dependency is registered at the component level, its life cycle is bound to the component's life cycle. The dependency is created every time the component is loaded, and destroyed when the component is destroyed. Unlike module-level dependencies that are created only once: when requested for the first time.</p>
<p class="calibre3">Let's try to override the global<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>service in components that use it to learn what happens on such overrides. It's going to be fun and we will learn a lot!</p>
<p class="calibre3">Open<span class="calibre6"> </span><kbd class="calibre13">workout-runner.component.ts</kbd><span class="calibre6"> </span>and add a<span class="calibre6"> </span><kbd class="calibre13">providers</kbd><span class="calibre6"> </span>attribute to<span class="calibre6"> </span><span class="calibre6">the</span><span class="calibre6"> </span><kbd class="calibre13">@Component</kbd><span class="calibre6"> </span><span class="calibre6">decorator</span><span class="calibre6">:</span></p>
<pre class="calibre19">providers: [WorkoutHistoryTrackerService]</pre>
<p class="calibre3">Do this in<span class="calibre6"> </span><kbd class="calibre13">workout-history.component.ts</kbd><span class="calibre6"> </span>too. Now if we refresh the app, start a workout, and then load the history page, the grid is empty. Irrespective of the times we try to run the workout, the history grid is always empty.</p>
<p class="calibre3">The reason is quite obvious. After setting the<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>provider on each<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryComponent</kbd>, the dependency is being fulfilled by the respective component injectors themselves. Both component injectors create their own instance of<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>when requested, and hence the history tracking is broken. Look at the following diagram to understand how the request is fulfilled in both scenarios:</p>
<div class="packt_figure"><img src="../images/00026.jpeg" class="calibre50"/></div>
<p class="calibre3">A quick question: what happens if we register the<span class="calibre6"> </span>dependency<span class="calibre6"> </span>in the root component,<span class="calibre6"> </span><kbd class="calibre13">TrainerAppComponent</kbd>, instead of doing it on the module? Something like this:</p>
<pre class="calibre19">@Component({ 
  selector: 'abe-root', 
<strong class="calibre1">  providers:[WorkoutHistoryTrackerService]</strong> 
} 
export class AppComponent { </pre>
<p class="calibre3">Interestingly, with this setup too, things work perfectly. That's pretty evident;<span class="calibre6"> </span><kbd class="calibre13">TrainerAppComponent</kbd><span class="calibre6"> </span>is a parent component for<span class="calibre6"> </span><kbd class="calibre13">RouterOutlet</kbd><span class="calibre6"> </span>that internally loads<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryComponent</kbd>. Hence in such a setup, the dependency gets fulfilled by the<span class="calibre6"> </span><kbd class="calibre13">TrainerAppComponent</kbd> injector.</p>
<div class="packt_infobox"><br class="calibre27"/>
Dependency lookup up on the component hierarchy<span class="packt_screen"> </span>can be manipulated if an intermediate component has declared itself as a host component. We will learn more about it in later chapters.</div>
<p class="calibre3">Hierarchical injectors allow us to register dependencies at a component level, avoiding the need to register all dependencies globally.</p>
<p class="calibre3">The predominant use case for this functionality is when building an Angular library component. Such components can register their own dependencies without requiring the consumer of the library to register library-specific dependencies.</p>
<div class="packt_tip"><br class="calibre27"/>
Remember: if you are having trouble loading the right service/dependency, make sure you check the component hierarchy for overrides done at any level.</div>
<p class="calibre3">We now understand how dependency resolution works in components. But what happens if a service has a dependency? Yet more uncharted territory to explore. Let's extend our app further.</p>
<div class="packt_tip"><br class="calibre27"/>
Remove any<span class="packt_screen"> </span><kbd class="calibre24">provider</kbd><span class="packt_screen"> </span>registration done on components before continuing further.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0"> Dependency injection with @Injectable</h1>
                
            
            <article>
                
<p class="calibre3"><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>has a fundamental flaw: the history is not persisted. Refresh the<span class="calibre6"> </span>app<span class="calibre6"> </span>and the history is lost. We need to add persistence logic to store historical data. To avoid any complex setup, we are going to use the browser local storage to store historical data.</p>
<p class="calibre3">Add a new <kbd class="calibre13">LocalStorageService</kbd> service by invoking this CLI command from the <kbd class="calibre13">trainer/src/app/core</kbd><span class="calibre6"> </span>folder:</p>
<pre class="calibre19"><strong class="calibre1">ng generate service local-storage</strong></pre>
<p class="calibre3">Copy the following two functions to the generated class, or copy them from the <kbd class="calibre13">checkpoint3.2</kbd><span class="calibre6"> </span>GitHub branch:</p>
<pre class="calibre19">getItem&lt;T&gt;(key: string): T {<br class="title-page-name"/>    if (localStorage[key]) {<br class="title-page-name"/>      return &lt;T&gt;JSON.parse(localStorage[key]);<br class="title-page-name"/>    }<br class="title-page-name"/>    return null;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>setItem(key: string, item: any) {<br class="title-page-name"/>    localStorage[key] = JSON.stringify(item);<br class="title-page-name"/>}</pre>
<p class="calibre3">A simple wrapper over the browser's<span class="calibre6"> </span><kbd class="calibre13">localStorage</kbd><span class="calibre6"> </span>object.</p>
<p class="calibre3">Like any other dependency, inject it into the<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>constructor (the<span class="calibre6"> </span><kbd class="calibre13">workout-history-tracker.ts</kbd><span class="calibre6"> </span>file) with the necessary import:</p>
<pre class="calibre19">import {LocalStorage} from './local-storage'; 
... 
constructor(private storage: LocalStorageService) {</pre>
<p class="calibre3">It is advisable that the default<span class="calibre6"> </span><kbd class="calibre13">Injectable</kbd><span class="calibre6"> </span>decorator on the service is applied, even if we register the dependency on module (<kbd class="calibre13">NgModule</kbd><span class="calibre6"> </span>provider registrations syntax). Especially when the service itself has a dependency, as it does with the preceding example of<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd>. Do not use the <kbd class="calibre13">providedIn</kbd><span class="calibre6"> </span>decorator attribute of<span class="calibre6"> </span><kbd class="calibre13">Injectable</kbd>  when using the module-based service registration.</p>
<p class="calibre3">By putting in the<span class="calibre6"> </span><kbd class="calibre13">@Injectable</kbd><span class="calibre6"> </span>decorator, we are forcing the TypeScript transpiler to generate metadata for the<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>class. This includes details about the constructor arguments. Angular DI consumes this generated metadata to determine the types of<span class="calibre6"> </span>dependency<span class="calibre6"> </span>the service has, and in future, it fulfills these dependencies when the service is created.</p>
<p class="calibre3">What about<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd>, which that uses<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd>? We have not used<span class="calibre6"> </span><kbd class="calibre13">@Injectable</kbd><span class="calibre6"> </span>there but still, the DI works. We don't need to. Any decorator works and there is already an <kbd class="calibre13">@Component</kbd><span class="calibre6"> </span>decorator applied to all components.</p>
<p class="calibre3">The actual integration between the<span class="calibre6"> </span><kbd class="calibre13">LocalStorage</kbd><span class="calibre6"> </span>service and<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>is a mundane process.</p>
<p class="calibre3">Update the constructor for<span class="calibre6"> </span><kbd class="calibre13">WorkoutHistoryTrackerService</kbd><span class="calibre6"> </span>as follows:</p>
<pre class="calibre19">constructor(private storage: LocalStorage) { 
   this.workoutHistory = (storage.getItem&lt;Array&lt;WorkoutLogEntry&gt;&gt;(this.storageKey) || [])<br class="title-page-name"/>      .map((item: WorkoutLogEntry) =&gt; {<br class="title-page-name"/>        item.startedOn = new Date(item.startedOn.toString());<br class="title-page-name"/>        item.endedOn = item.endedOn == null ? null : new Date(item.endedOn.toString());<br class="title-page-name"/>        return item;<br class="title-page-name"/>      }); 
} </pre>
<p class="calibre3">And add a declaration for<span class="calibre6"> </span><kbd class="calibre13">storageKey</kbd>:</p>
<pre class="calibre19">private storageKey = 'workouts';</pre>
<p class="calibre3">The constructor loads the workout logs from the local storage. The<span class="calibre6"> </span><kbd class="calibre13">map</kbd><span class="calibre6"> </span>function call is necessary as everything stored in<span class="calibre6"> </span><kbd class="calibre13">localStorage</kbd><span class="calibre6"> </span>is a string. Therefore, while de-serializing, we need to convert the string back to the date value.</p>
<p class="calibre3">Add this statement last in the <kbd class="calibre13">startTracking</kbd>,<span class="calibre6"> </span><kbd class="calibre13">exerciseComplete</kbd>, and<span class="calibre6"> </span><kbd class="calibre13">endTracking</kbd><span class="calibre6"> </span>functions:</p>
<pre class="calibre19">this.storage.setItem(this.storageKey, this.workoutHistory);</pre>
<p class="calibre3">We save the workout history to local storage every time the historical data changes.</p>
<p class="calibre3">That's it! We have built workout history tracking over<span class="calibre6"> </span><kbd class="calibre13">localStorage</kbd>. Verify it!</p>
<p class="calibre3">Before we move on to our big-ticket item, audio support, there are a<span class="calibre6"> </span>few<span class="calibre6"> </span>minor fixes that are needed for a better user experience. The first one is related to the<span class="calibre6"> </span><span class="calibre6">History</span><span class="calibre6"> </span>link.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Tracking route changes using the router service</h1>
                
            
            <article>
                
<p class="calibre3">The<span class="calibre6"> </span><span class="calibre6">History</span><span class="calibre6"> </span>link in the<span class="calibre6"> </span><kbd class="calibre13">Header</kbd><span class="calibre6"> </span>component is<span class="calibre6"> </span>visible<span class="calibre6"> </span>for all routes other that when a workout is in progress. We don't want to lose an in-progress workout by accidentally clicking on the<span class="calibre6"> </span><span class="calibre6">History</span><span class="calibre6"> </span>link. Moreover, no one is interested in knowing about the workout history while doing a workout.</p>
<p class="calibre3">The fix is easy. We just need to determine whether the current route is the workout route and hide the link. The<span class="calibre6"> </span><kbd class="calibre13">Router</kbd><span class="calibre6"> </span>service is going to help us with this job.</p>
<p class="calibre3">Open<span class="calibre6"> </span><kbd class="calibre13">header.component.ts</kbd><span class="calibre6"> </span>and look at the highlighted implementation:</p>
<pre class="calibre19"><strong class="calibre1">import { Router, NavigationEnd } from '@angular/router';</strong><br class="title-page-name"/><strong class="calibre1">import 'rxjs/add/operator/filter';
</strong>... 
export class HeaderComponent { 
  <strong class="calibre1">private showHistoryLink= true;</strong> 
  constructor(<strong class="calibre1">private router: Router</strong>) { 
    <strong class="calibre1">this.router.events.pipe(    </strong><br class="title-page-name"/><strong class="calibre1">      filter(e =&gt; e instanceof NavigationEnd))</strong><br class="title-page-name"/><strong class="calibre1">      .subscribe((e: NavigationEnd) =&gt; {</strong><br class="title-page-name"/><strong class="calibre1">        this.showHistoryLink = !e.url.startsWith('/workout');</strong><br class="title-page-name"/><strong class="calibre1">      });</strong> 
  } </pre>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">showHistoryLink</kbd><span class="calibre6"> </span>property binds to the view and decides whether the history link is shown to the user or not. In the constructor, we inject the<span class="calibre6"> </span><kbd class="calibre13">Router</kbd><span class="calibre6"> </span>service and subscribe to the<span class="calibre6"> observable</span><span class="calibre6"> </span><kbd class="calibre13">events</kbd><span class="calibre6"> using the</span><span class="calibre6"> </span><kbd class="calibre13">subscribe</kbd><span class="calibre6"> </span><span class="calibre6">function.</span></p>
<p class="calibre3">We will learn more about observables later in the chapter, but for now, it is enough to understand that observables are objects that raise events and can be subscribed to. Since the router raises a number of events throughout the component's life cycle, the <kbd class="calibre13">filter</kbd><span class="calibre6"> </span>operator allows us to filter the event we are interested in and the<span class="calibre6"> </span><kbd class="calibre13">subscribe</kbd><span class="calibre6"> </span>function registers a callback function that is invoked every time the route changes.</p>
<p class="calibre3">To learn about the other router events, including<span class="calibre6"> </span><kbd class="calibre13">NavigationStart</kbd>,<span class="calibre6"> </span><kbd class="calibre13">NavigationEnd</kbd>,<span class="calibre6"> </span><kbd class="calibre13">NavigationCancel</kbd>, and <kbd class="calibre13">NavigationError</kbd>, look at the<span class="calibre6"> </span>router<span class="calibre6"> </span>documentation (<a href="http://bit.ly/ng-router-events" class="calibre10">http://bit.ly/ng-router-events</a>) to understand when the events are raised.</p>
<p class="calibre3">The callback implementation just toggles the<span class="calibre6"> </span><kbd class="calibre13">showHistoryLink</kbd><span class="calibre6"> </span>state based on the current route URL. To use <kbd class="calibre13">showHistoryLink</kbd><span class="calibre6"> </span>in the view, just update the header template line with the anchor tag to:</p>
<pre class="calibre19">&lt;li *ngIf="showHistoryLink"&gt;&lt;a routerLink="/history" ...&gt;...&lt;/a&gt;&lt;/li&gt;</pre>
<p class="calibre3">And that's it! The<span class="calibre6"> </span><span class="calibre6">History</span><span class="calibre6"> </span>link does not show up on the workout page.</p>
<div class="packt_infobox">If you are having a problem with running the code, look at the <kbd class="calibre24">checkpoint3.2</kbd> Git branch for a working version of what we have done thus far. Or if you are not using Git, download the snapshot of<span class="packt_screen"> </span><kbd class="calibre24">checkpoint3.2</kbd><span class="packt_screen"> </span>(a ZIP file) from<span class="packt_screen"> </span><a href="http://bit.ly/ng6be-checkpoint-3-2" class="calibre21">http://bit.ly/ng6be-checkpoint-3-2</a>. Refer to the<span class="packt_screen"> </span><kbd class="calibre24">README.md</kbd><span class="packt_screen"> </span>file in the<span class="packt_screen"> </span><kbd class="calibre24">trainer</kbd><span class="packt_screen"> </span>folder when setting up the snapshot for the first time.</div>
<p class="calibre3">Another fix/enhancement is related to the video panel on the workout page.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Fixing the video playback experience</h1>
                
            
            <article>
                
<p class="calibre3">The current video panel<span class="calibre6"> </span>implementation<span class="calibre6"> </span>can at best be termed amateurish. The size of the default player is small. When we play the video, the workout does not pause. The video playback is interrupted on exercise transitions. Also, the overall video-load experience adds a noticeable lag at the start of every exercise routine. This is a clear indication that this approach to video playback needs some fixing.</p>
<p class="calibre3">This is what we are going to do to fix the video panel:</p>
<ul class="calibre11">
<li class="calibre12">Show the image thumbnail for the exercise video instead of loading the video player itself</li>
<li class="calibre12">When the user clicks on the thumbnail, load a popup/dialog with a bigger video player that can play the selected video</li>
<li class="calibre12">Pause the workout while the video playback is on</li>
</ul>
<p class="calibre3">Let's get on with the job!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using thumbnails for video</h1>
                
            
            <article>
                
<p class="calibre3">Replace the<span class="calibre6"> </span><kbd class="calibre13">ngFor</kbd> HTML template inside<span class="calibre6"> </span><kbd class="calibre13">video-player.component.html</kbd><span class="calibre6"> </span>with<span class="calibre6"> </span>this<span class="calibre6"> </span>snippet:</p>
<pre class="calibre19">&lt;div *ngFor="let video of videos" class="row"&gt;<br class="title-page-name"/>      &lt;div class="col-sm-12 p-2"&gt;<br class="title-page-name"/>        &lt;img class="video-image" [src]="'//i.ytimg.com/vi/'+video+'/hqdefault.jpg'" /&gt;<br class="title-page-name"/>      &lt;/div&gt;<br class="title-page-name"/>&lt;/div&gt; </pre>
<p class="calibre3">We have abandoned iframe, and instead loaded the thumbnail image of the video (check the<span class="calibre6"> </span><kbd class="calibre13">img</kbd><span class="calibre6"> </span>tag). All other content shown here is for styling the image.</p>
<div class="packt_infobox"><br class="calibre27"/>
We have referenced the Stack Overflow post (<span class="packt_screen"><a href="http://bit.ly/so-yt-thumbnail" class="calibre21">http://bit.ly/so-yt-thumbnail</a>)</span><span class="packt_screen"> </span>to determine the thumbnail image URL for our videos.</div>
<p class="calibre3">Start a new workout; the images should show up, but the playback functionality is broken. We need to add a video playback dialog.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the ngx-modialog library</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6">To show the video in a dialog, we are going to incorporate a third-party library,</span><span class="calibre6"> </span><span class="calibre6"><strong class="calibre5">ngx-modialog</strong>, available on GitHub at</span><span class="calibre6"> </span><a href="http://bit.ly/ngx-modialog" class="calibre10">http://bit.ly/ngx-modialog</a><span class="calibre6">. Let's install and configure the library.</span></p>
<p class="calibre3">From the command line (inside the<span class="calibre6"> </span><kbd class="calibre13">trainer</kbd><span class="calibre6"> </span>folder), run the following command to install the library:</p>
<pre class="calibre19"><strong class="calibre1">npm i ngx-modialog@5.0.0 --save</strong></pre>
<div class="packt_infobox">Work on an Angular v6-compatible<span class="packt_screen"> </span><kbd class="calibre24">ngx-modialog</kbd><span class="packt_screen"> </span>library is in progress (<a href="https://github.com/shlomiassaf/ngx-modialog/issues/426" class="calibre21">https://github.com/shlomiassaf/ngx-modialog/issues/426</a>). To use the version 5 library, which is dependent on older version of RxJS, install the <kbd class="calibre24">rxjs-compat</kbd><span class="packt_screen"> </span>package from command line,<span class="packt_screen"> </span><kbd class="calibre24">npm i rxjs-compat --save</kbd>, before proceeding.</div>
<p class="calibre3">Next import and configure the library in the core module. Open<span class="calibre6"> </span><kbd class="calibre13">core.module.ts</kbd><span class="calibre6"> </span>and add the highlighted configurations:</p>
<pre class="calibre19">import { RouterModule } from '@angular/router';<br class="title-page-name"/><strong class="calibre1">import { ModalModule } from 'ngx-modialog';</strong><br class="title-page-name"/><strong class="calibre1">import { BootstrapModalModule } from 'ngx-modialog/plugins/bootstrap';</strong><br class="title-page-name"/>...<br class="title-page-name"/>imports: [<br class="title-page-name"/>   ...<br class="title-page-name"/><strong class="calibre1">   ModalModule.forRoot(),</strong><br class="title-page-name"/><strong class="calibre1">   BootstrapModalModule</strong><br class="title-page-name"/>  ],</pre>
<p class="calibre3">The library is now ready for use.</p>
<p class="calibre3">While<span class="calibre6"> </span><em class="calibre17">ngx-modialog</em><span class="calibre6"> </span>has a number of predefined templates for standard dialogs, such as alert, prompt, and confirm, these dialogs provide little customization in terms of look and feel. To have better control over the dialog UI, we need to create a custom dialog, which thankfully the library supports.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating custom dialogs</h1>
                
            
            <article>
                
<p class="calibre3">Custom dialogs in<span class="calibre6"> </span><kbd class="calibre13">ngx-modialog</kbd><span class="calibre6"> </span>are nothing but Angular<span class="calibre6"> </span>components<span class="calibre6"> </span>with some special library construct incorporated.</p>
<p class="calibre3">Let's start with building a video dialog component that shows the YouTube video in a popup dialog. Generate the component's boilerplate by navigating to<span class="calibre6"> </span><kbd class="calibre13">trainer/src/app/workout-runner/video-player</kbd><span class="calibre6"> </span>and running the following command:</p>
<pre class="calibre19"><strong class="calibre1">ng generate component video-dialog -is</strong></pre>
<p class="calibre3">Copy the video dialog implementation from the<span class="calibre6"> </span><kbd class="calibre13">workout-runner/video-player/video-dialog</kbd><span class="calibre6"> </span>folder in the <kbd class="calibre13">checkpoint3.3</kbd> Git branch (GitHub location: <a href="http://bit.ly/ng6be-3-3-video-dialog" class="calibre10">http://bit.ly/ng6be-3-3-video-dialog</a>) into your local setup. You need to update the component implementation and the view.</p>
<p class="calibre3">Next, update<span class="calibre6"> </span><kbd class="calibre13">workout-runner.module.ts</kbd><span class="calibre6"> </span>and add a new<span class="calibre6"> </span><kbd class="calibre13">entryComponents</kbd><span class="calibre6"> </span>attribute to the module decorator:</p>
<pre class="calibre19">...
declarations: [..., VideoDialogComponent], 
<strong class="calibre1">entryComponents:[VideoDialogComponent] </strong></pre>
<p class="calibre3">The newly created <kbd class="calibre13">VideoDialogComponent</kbd><span class="calibre6"> </span>needs to be added to<span class="calibre6"> </span><kbd class="calibre13">entryComponents</kbd><span class="calibre6"> </span>as it is not explicitly used in the component tree.</p>
<p class="calibre3"><kbd class="calibre13">VideoDialogComponent</kbd><span class="calibre6"> </span>is a standard Angular component, with some modal dialog and specific implementations that we describe later. The<span class="calibre6"> </span><kbd class="calibre13">VideoDialogContext</kbd><span class="calibre6"> </span>class declared inside<span class="calibre6"> </span><kbd class="calibre13">VideoDialogComponent</kbd><span class="calibre6"> </span>has been created to pass the<span class="calibre6"> </span><kbd class="calibre13">videoId</kbd><span class="calibre6"> </span>of the YouTube video clicked to the dialog instance. The library uses this context class to pass data between the calling code and the modal dialog. The<span class="calibre6"> </span><kbd class="calibre13">VideoDialogContext</kbd><span class="calibre6"> </span>class inherits a configuration class that the dialog library uses to alter the behavior and UI of the modal dialog f<span class="calibre6">rom</span><span class="calibre6"> </span><kbd class="calibre13">BSModalContext</kbd><span class="calibre6">.</span></p>
<p class="calibre3">To get a better sense of how<span class="calibre6"> </span><kbd class="calibre13">VideoDialogContext</kbd><span class="calibre6"> </span>is utilized, let's invoke the preceding dialog from the workout runner when the video image is clicked.</p>
<p class="calibre3">Update the<span class="calibre6"> </span><kbd class="calibre13">ngFor</kbd><span class="calibre6"> </span>div in<span class="calibre6"> </span><kbd class="calibre13">video-player.component.html</kbd><span class="calibre6"> </span>and add a<span class="calibre6"> </span><kbd class="calibre13">click</kbd><span class="calibre6"> </span>event handler:</p>
<pre class="calibre19">&lt;div *ngFor="let video of videos" <strong class="calibre1">(click)="playVideo(video)"    </strong> ...&gt; </pre>
<p class="calibre3">The preceding handler invokes the<span class="calibre6"> </span><kbd class="calibre13">playVideo</kbd><span class="calibre6"> </span>method, passing in the video clicked. The<span class="calibre6"> </span><kbd class="calibre13">playVideo</kbd><span class="calibre6"> </span>function, in turn, opens the corresponding video dialog. Add the<span class="calibre6"> </span><kbd class="calibre13">playVideo</kbd><span class="calibre6"> </span>implementation to<span class="calibre6"> </span><kbd class="calibre13">video-player.component.ts</kbd><span class="calibre6"> </span>as highlighted:</p>
<pre class="calibre19"><strong class="calibre1">import { Modal } from 'ngx-modialog/plugins/bootstrap';</strong><br class="title-page-name"/><strong class="calibre1">import { VideoDialogComponent, VideoDialogContext } from './video-dialog/video-dialog.component';</strong><br class="title-page-name"/><strong class="calibre1">import { overlayConfigFactory } from 'ngx-modialog';</strong><br class="title-page-name"/>... 
export class VideoPlayerComponent { 
      @Input() videos: Array&lt;string&gt;;</pre>
<pre class="calibre19">  <br class="title-page-name"/><strong class="calibre1">constructor(private modal: Modal) { }</strong><strong class="calibre1"> 
  
        playVideo(videoId: string) {
            </strong><strong class="calibre1">this.modal.open(VideoDialogComponent, <br class="title-page-name"/>                            overlayConfigFactory(new VideoDialogContext(videoId)));<br class="title-page-name"/>        </strong><strong class="calibre1">}</strong>
}</pre>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">playVideo</kbd><span class="calibre6"> </span>function calls the<span class="calibre6"> </span><kbd class="calibre13">Modal</kbd><span class="calibre6"> </span>class' <kbd class="calibre13">open</kbd><span class="calibre6"> </span>function, passing in the dialog component to open and a new instance of the <kbd class="calibre13">VideoDialogContext</kbd><span class="calibre6"> </span>class with the<span class="calibre6"> </span><kbd class="calibre13">videoId</kbd><span class="calibre6"> </span>of the YouTube video. Before proceeding, delete the<span class="calibre6"> </span><kbd class="calibre13">ngOnChange</kbd><span class="calibre6"> </span>function and the interface declaration too.</p>
<p class="calibre3">Coming back to the<span class="calibre6"> </span><kbd class="calibre13">VideoDialogComponent</kbd><span class="calibre6"> </span>implementation, the component implements the<span class="calibre6"> </span><kbd class="calibre13">ModalComponent&lt;VideoDialogContext&gt;</kbd><span class="calibre6"> </span>interface required by the modal library. Look at how the context (<kbd class="calibre13">VideoDialogContext</kbd>) to the dialog is passed to the constructor and how we extract and assign the<span class="calibre6"> </span><kbd class="calibre13">videoId</kbd><span class="calibre6"> </span>property from the context. Then it's just a matter of binding the<span class="calibre6"> </span><kbd class="calibre13">videoId</kbd><span class="calibre6"> </span>property to the template view (see the HTML template) and rendering the YouTube player.</p>
<p class="calibre3">And we are good to go. Load the app and start the workout. Then<span class="calibre6"> </span>click<span class="calibre6"> </span>on any workout video images. The video dialog should load and now we can watch the video!</p>
<p class="calibre3">Before we call the dialog implementation complete, there is one small issue that needs to be fixed. When the dialog opens, the workout should pause: that's not happening currently. We will help you fix it at the end of the next section using Angular's eventing infrastructure.</p>
<div class="packt_infobox">If you are having a problem with running the code, look at the <kbd class="calibre24">checkpoint3.3</kbd> Git branch for a working version of what we have done thus far. Or if you are not using Git, download the snapshot of<span class="packt_screen"> </span><kbd class="calibre24">checkpoint3.3</kbd><span class="packt_screen"> </span>(a ZIP file) from<span class="packt_screen"> </span><a href="http://bit.ly/ng6be-checkpoint-3-3" class="calibre21">http://bit.ly/ng6be-checkpoint-3-3</a>. Refer to the<span class="packt_screen"> </span><kbd class="calibre24">README.md</kbd><span class="packt_screen"> </span>file in the<span class="packt_screen"> </span><kbd class="calibre24">trainer</kbd><span class="packt_screen"> </span>folder when setting up the snapshot for the first time.</div>
<p class="calibre3">There is one last feature that we plan to add to<span class="calibre6"> </span><em class="calibre17">7-Minute Workout</em><span class="calibre6"> </span>before wrapping up the application and building something new with Angular: audio support. It teaches us some new cross-component communication patterns too.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Cross-component communication using Angular events</h1>
                
            
            <article>
                
<p class="calibre3">We touched upon events in<span class="calibre6"> </span>the last chapter<span class="calibre6"> </span>when learning about Angular's<span class="calibre6"> </span>binding<span class="calibre6"> </span>infrastructure. It's time now to look at eventing in more depth. Let's add audio support to<span class="calibre6"> </span><em class="calibre17">7-Minute Workout</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Tracking exercise progress with audio</h1>
                
            
            <article>
                
<p class="calibre3">For the<span class="calibre6"> </span><em class="calibre17">7-Minute Workout</em><span class="calibre6"> </span>app, adding sound support is vital. One<span class="calibre6"> </span>cannot<span class="calibre6"> </span>exercise while constantly staring at the screen. Audio clues help the user perform the workout effectively as they<span class="calibre6"> </span>can just follow the audio instructions.</p>
<p class="calibre3">Here is how we are going to support exercise tracking using audio clues:</p>
<ul class="calibre11">
<li class="calibre12">A ticking clock soundtrack progress during the exercise</li>
<li class="calibre12">A half-way indicator sounds, indicating that the exercise is halfway through</li>
<li class="calibre12">An exercise-completion audio clip plays when the exercise is about to end</li>
<li class="calibre12">An audio clip plays during the rest phase and informs users about the next exercise</li>
</ul>
<p class="calibre3">There will be an audio clip for each of these scenarios.</p>
<p class="calibre3">Modern browsers have good support for audio. The HTML5<span class="calibre6"> </span><kbd class="calibre13">&lt;audio&gt;</kbd><span class="calibre6"> </span>tag provides a mechanism to embed audio clips into HTML content. We too will use the<span class="calibre6"> </span><kbd class="calibre13">&lt;audio&gt;</kbd><span class="calibre6"> </span>tag to play back our clips.</p>
<p class="calibre3">Since the plan is to use the HTML <kbd class="calibre13">&lt;audio&gt;</kbd><span class="calibre6"> </span>element, we need to create a wrapper directive that allows us to control audio elements from Angular. Remember that directives are HTML extensions without a view.</p>
<div class="packt_infobox">The <kbd class="calibre24">checkpoint3.4</kbd> Git and the <kbd class="calibre24">trainer/static/audio</kbd> folder contain all the audio files used for playback; copy them first. If you are not using Git, a snapshot of the chapter code is available at<span class="packt_screen"> </span><a href="http://bit.ly/ng6be-checkpoint-3-4" class="calibre21">http://bit.ly/ng6be-checkpoint-3-4</a>. Download and unzip the contents and copy the audio files.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building Angular directives to wrap HTML audio</h1>
                
            
            <article>
                
<p class="calibre3">If you have worked a lot with JavaScript and jQuery, you may have realized<span class="calibre6"> </span>we<span class="calibre6"> </span>have purposefully shied away from directly accessing the DOM for any of our component implementations. There has not been a need to do it. The Angular data-binding infrastructure, including property, attribute, and event binding, has helped us manipulate HTML without touching the DOM.</p>
<p class="calibre3">For the audio element too, the access pattern should be Angularish. In Angular, the only place where direct DOM manipulation is acceptable and practiced is inside directives. Let's create a directive that wraps access to audio elements.</p>
<p class="calibre3">Navigate to<span class="calibre6"> </span><kbd class="calibre13">trainer/src/app/shared</kbd><span class="calibre6"> </span>and run this command to generate a template directive:</p>
<pre class="calibre19"><strong class="calibre1">ng generate directive my-audio</strong></pre>
<div class="packt_infobox"><br class="calibre27"/>
Since it is the first time we are creating a directive, we encourage you to look at the generated code.</div>
<p class="calibre3">Since the directive is added to the shared module, it needs to be exported too. Add the <kbd class="calibre13">MyAudioDirective</kbd><span class="calibre6"> </span>reference in the <kbd class="calibre13">exports</kbd><span class="calibre6"> </span>array too (<kbd class="calibre13">shared.module.ts</kbd>). Then update the directive definition with the following code:</p>
<pre class="calibre19">    import {Directive, <strong class="calibre1">ElementRef</strong>} from '@angular/core'; 
 
    @Directive({ 
      <strong class="calibre1">selector: 'audio', 
      exportAs: 'MyAudio' </strong>
    }) 
    export class MyAudioDirective { 
      <strong class="calibre1">private audioPlayer: HTMLAudioElement; 
      constructor(element: ElementRef) { 
        this.audioPlayer = element.nativeElement; 
      }</strong> 
    } </pre>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">MyAudioDirective</kbd><span class="calibre6"> </span>class is decorated with<span class="calibre6"> </span><kbd class="calibre13">@Directive</kbd>. The<span class="calibre6"> </span><kbd class="calibre13">@Directive</kbd><span class="calibre6"> </span>decorator is similar to the<span class="calibre6"> </span><kbd class="calibre13">@Component</kbd><span class="calibre6"> </span>decorator except we cannot have an attached view. Therefore, no<span class="calibre6"> </span><kbd class="calibre13">template</kbd><span class="calibre6"> </span>or<span class="calibre6"> </span><kbd class="calibre13">templateUrl</kbd> is allowed!</p>
<p class="calibre3">The preceding<span class="calibre6"> </span><kbd class="calibre13">selector</kbd><span class="calibre6"> </span>property allows the framework to identify where to apply the directive. We have replaced the generated <kbd class="calibre13">[abeMyAudioDirective]</kbd> attribute selector with just<span class="calibre6"> </span><kbd class="calibre13">audio</kbd>. Using<span class="calibre6"> </span><kbd class="calibre13">audio</kbd><span class="calibre6"> </span>as the selector makes our directive load for every<span class="calibre6"> </span><kbd class="calibre13">&lt;audio&gt;</kbd><span class="calibre6"> </span>tag used in HTML. The new selector works as an element selector.</p>
<div class="packt_infobox">In a standard scenario, directive selectors are attribute-based (such as<span class="packt_screen"> </span><kbd class="calibre24">[abeMyAudioDirective]</kbd><span class="packt_screen"> </span>for the generated code), which helps us identify where the directive has been applied. We deviate from this norm and use an element selector for the<span class="packt_screen"> </span><kbd class="calibre24">MyAudioDirective</kbd><span class="packt_screen"> </span>directive. We want this directive to be loaded for every audio element, and it becomes cumbersome to go to each audio declaration and add a directive-specific attribute. Hence an element selector.</div>
<p class="calibre3">The use of<span class="calibre6"> </span><kbd class="calibre13">exportAs</kbd><span class="calibre6"> </span>becomes clear when we use this directive in view templates.</p>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">ElementRef</kbd><span class="calibre6"> </span>object injected in the constructor is the Angular element (<kbd class="calibre13">audio</kbd><span class="calibre6"> </span>in this case) for which the directive is loaded. Angular creates the<span class="calibre6"> </span><kbd class="calibre13">ElementRef</kbd><span class="calibre6"> </span>instance for every component and directive when it compiles and executes the HTML template. When requested in the constructor, the DI framework locates the corresponding<span class="calibre6"> </span><kbd class="calibre13">ElementRef</kbd><span class="calibre6"> </span>and injects it. We use<span class="calibre6"> </span><kbd class="calibre13">ElementRef</kbd><span class="calibre6"> </span>to get hold of the underlying audio element in the code (the instance of<span class="calibre6"> </span><kbd class="calibre13">HTMLAudioElement</kbd>). The<span class="calibre6"> </span><kbd class="calibre13">audioPlayer</kbd><span class="calibre6"> </span>property holds this reference.</p>
<p class="calibre3">The directive now needs to expose an API to manipulate the audio player. Add these functions to the <kbd class="calibre13">MyAudioDirective</kbd><span class="calibre6"> </span>directive:</p>
<pre class="calibre19">    stop() { 
      this.audioPlayer.pause(); 
    }
 
    start() { 
      this.audioPlayer.play();
    }
    get currentTime(): number { 
      return this.audioPlayer.currentTime; 
    }

    get duration(): number { 
      return this.audioPlayer.duration; 
    }

    get playbackComplete() { 
      return this.duration == this.currentTime; 
    }</pre>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">MyAudioDirective</kbd><span class="calibre6"> </span>API has two functions (<kbd class="calibre13">start</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">stop</kbd>) and three getters (<kbd class="calibre13">currentTime</kbd>,<span class="calibre6"> </span><kbd class="calibre13">duration</kbd>, and a Boolean property called<span class="calibre6"> </span><kbd class="calibre13">playbackComplete</kbd>). The implementations for these functions and properties just wrap the audio element functions.</p>
<div class="packt_infobox"><br class="calibre27"/>
Learn about these audio functions from the MDN documentation here: <span class="packt_screen"><a href="http://bit.ly/html-media-element" class="calibre21">http://bit.ly/html-media-element</a></span>.</div>
<p class="calibre3">To understand how we use the audio directive, let's create a new component that manages audio playback.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating WorkoutAudioComponent for audio support</h1>
                
            
            <article>
                
<p class="calibre3">If we go back and look at the audio<span class="calibre6"> </span>cues<span class="calibre6"> </span>that are required, there are four distinct audio cues, and hence we are going to create a component with five embedded<span class="calibre6"> </span><kbd class="calibre13">&lt;audio&gt;</kbd><span class="calibre6"> </span>tags (two audio tags work together for next-up audio).</p>
<p class="calibre3">From the command line go to the <kbd class="calibre13">trainer/src/app/workout-runner</kbd> folder and add a new <kbd class="calibre13">WorkoutAudioComponent</kbd> component using Angular CLI. </p>
<p class="calibre3">Open <kbd class="calibre13">workout-audio.component.html</kbd><span class="calibre6"> </span>and replace the existing view template with this HTML snippet:</p>
<pre class="calibre19">&lt;audio #ticks="MyAudio" loop src="/assets/audio/tick10s.mp3"&gt;&lt;/audio&gt;<br class="title-page-name"/>&lt;audio #nextUp="MyAudio" src="/assets/audio/nextup.mp3"&gt;&lt;/audio&gt;<br class="title-page-name"/>&lt;audio #nextUpExercise="MyAudio" [src]="'/assets/audio/' + nextupSound"&gt;&lt;/audio&gt;<br class="title-page-name"/>&lt;audio #halfway="MyAudio" src="/assets/audio/15seconds.wav"&gt;&lt;/audio&gt;<br class="title-page-name"/>&lt;audio #aboutToComplete="MyAudio" src="/assets/audio/321.wav"&gt;&lt;/audio&gt; </pre>
<p class="calibre3">There are five<span class="calibre6"> </span><kbd class="calibre13">&lt;audio&gt;</kbd><span class="calibre6"> </span>tags, one for each of the following:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Ticking audio</strong>: The first audio tag produces the ticking sound and is<span> </span>started<span> </span>as soon as the workout starts.</li>
<li class="calibre12"><strong class="calibre1">Next up audio and exercise audio</strong>: There next two audio tags work together. The first tag produces the "Next up" sound. And the actual exercise audio is handled by the third tag (in the preceding code snippet).</li>
<li class="calibre12"><strong class="calibre1">Halfway audio</strong>: The fourth audio tag plays halfway through the exercise.</li>
</ul>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">About to complete audio</strong>: The final audio tag plays a piece to denote the completion of an exercise.</li>
</ul>
<p class="calibre3">Did you notice the usage of the<span class="calibre6"> </span><kbd class="calibre13">#</kbd><span class="calibre6"> </span>symbol in each of the<span class="calibre6"> </span><kbd class="calibre13">audio</kbd><span class="calibre6"> </span>tags? There are some variable assignments prefixed with<span class="calibre6"> </span><kbd class="calibre13">#</kbd>. In the Angular world, these<span class="calibre6"> </span>variables<span class="calibre6"> </span>are known as<span class="calibre6"> </span><strong class="calibre5">template reference variables</strong><span class="calibre6"> </span>or at times<span class="calibre6"> </span><strong class="calibre5">template variables</strong>.</p>
<p class="calibre3">As the platform guide defines:</p>
<p class="calibre3">A template reference variable is often a reference to a DOM element or directive within a template.</p>
<div class="packt_infobox">Don't confuse them with the template input variables that we have used with the<span class="packt_screen"> </span><kbd class="calibre24">ngFor</kbd><span class="packt_screen"> </span>directive earlier, <kbd class="calibre24">*ngFor="let</kbd><span class="packt_screen"> </span>video<span class="packt_screen"> </span><kbd class="calibre24">of videos"</kbd>. The <strong class="calibre26">template input variable's</strong><span class="packt_screen"> </span>(<kbd class="calibre24">video</kbd><span class="packt_screen"> </span>in this case) scope is within the HTML fragment it is declared, whereas the template reference variable can be accessed across the entire template.</div>
<p class="calibre3">Look at the last section where<span class="calibre6"> </span><kbd class="calibre13">MyAudioDirective</kbd><span class="calibre6"> </span>was defined. The <kbd class="calibre13">exportAs</kbd><span class="calibre6"> </span>metadata is set to<span class="calibre6"> </span><kbd class="calibre13">MyAudio</kbd>. We repeat that same<span class="calibre6"> </span><kbd class="calibre13">MyAudio</kbd><span class="calibre6"> </span>string while assigning the<span class="calibre6"> </span><kbd class="calibre13">template reference variable</kbd><span class="calibre6"> </span>for each audio tag:</p>
<pre class="calibre19">#ticks="MyAudio"</pre>
<p class="calibre3">The role of<span class="calibre6"> </span><kbd class="calibre13">exportAs</kbd><span class="calibre6"> </span>is to define the name that can be<span class="calibre6"> </span>used<span class="calibre6"> </span>in the view to assign this directive to a variable. Remember, a single element/component can have multiple directives applied to it.<span class="calibre6"> </span><kbd class="calibre13">exportAs</kbd><span class="calibre6"> </span>allows us to select which directive should be assigned to a template-reference variable based on what is on the right side of equals.</p>
<p class="calibre3">Typically, template variables, once declared, give access to the view element/component they are attached to, to other parts of the view, something we will discuss shortly. But in our case, we will use template variables to refer to the multiple<span class="calibre6"> </span><kbd class="calibre13">MyAudioDirective</kbd><span class="calibre6"> </span>from the parent component's code. Let's understand how to use them.</p>
<p class="calibre3">Update the generated<span class="calibre6"> </span><kbd class="calibre13">workout-audio.compnent.ts</kbd><span class="calibre6"> </span>with the following outline:</p>
<pre class="calibre19">import { Component, OnInit, <strong class="calibre1">ViewChild</strong> } from '@angular/core';<br class="title-page-name"/><strong class="calibre1">import { MyAudioDirective } from '../../shared/my-audio.directive';</strong><br class="title-page-name"/><br class="title-page-name"/>@Component({<br class="title-page-name"/> ...<br class="title-page-name"/>})<br class="title-page-name"/>export class WorkoutAudioComponent implements OnInit {<br class="title-page-name"/><strong class="calibre1">  @ViewChild('ticks') private ticks: MyAudioDirective;</strong><br class="title-page-name"/><strong class="calibre1">  @ViewChild('nextUp') private nextUp: MyAudioDirective;</strong><br class="title-page-name"/><strong class="calibre1">  @ViewChild('nextUpExercise') private nextUpExercise: MyAudioDirective;</strong><br class="title-page-name"/><strong class="calibre1">  @ViewChild('halfway') private halfway: MyAudioDirective;</strong><br class="title-page-name"/><strong class="calibre1">  @ViewChild('aboutToComplete') private aboutToComplete: MyAudioDirective;</strong><br class="title-page-name"/><strong class="calibre1">  private nextupSound: string;</strong><br class="title-page-name"/><br class="title-page-name"/>  constructor() { } <br class="title-page-name"/>  ...<br class="title-page-name"/>}</pre>
<p class="calibre3">The interesting bit in this outline is the<span class="calibre6"> </span><kbd class="calibre13">@ViewChild</kbd><span class="calibre6"> </span>decorator against the five properties. The<span class="calibre6"> </span><kbd class="calibre13">@ViewChild</kbd><span class="calibre6"> </span>decorator allows us to inject a child component/directive/element reference into its parent. The parameter passed to the decorator is the template variable name, which helps DI match the element/directive to inject. When Angular instantiates the main<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd>, it injects the corresponding audio directives based on the<span class="calibre6"> </span><kbd class="calibre13">@ViewChild</kbd><span class="calibre6"> </span>decorator and the template reference variable name passed. Let's complete the basic class implementation before we look at<span class="calibre6"> </span><kbd class="calibre13">@ViewChild</kbd><span class="calibre6"> </span>in detail.</p>
<div class="packt_infobox">Without<span class="packt_screen"> </span><kbd class="calibre24">exportAs</kbd><span class="packt_screen"> </span>set on the<span class="packt_screen"> </span><kbd class="calibre24">MyAudioDirective</kbd><span class="packt_screen"> </span>directive, the<span class="packt_screen"> </span><kbd class="calibre24">@ViewChild</kbd><span class="packt_screen"> </span>injection injects the related<span class="packt_screen"> </span><kbd class="calibre24">ElementRef</kbd><span class="packt_screen"> </span>instance instead of the<span class="packt_screen"> </span><kbd class="calibre24">MyAudioDirective</kbd><span class="packt_screen"> </span>instance. We can confirm this by removing the<span class="packt_screen"> </span><kbd class="calibre24">exportAs</kbd><span class="packt_screen"> </span>attribute from<span class="packt_screen"> </span><kbd class="calibre24">myAudioDirective</kbd><span class="packt_screen"> </span>and then looking at the injected dependencies in<span class="packt_screen"> </span><kbd class="calibre24">WorkoutAudioComponent</kbd>.</div>
<p class="calibre3">The remaining task is to just play the correct audio component at the right time. Add these functions to<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd>:</p>
<pre class="calibre19">stop() {<br class="title-page-name"/>    this.ticks.stop();<br class="title-page-name"/>    this.nextUp.stop();<br class="title-page-name"/>    this.halfway.stop();<br class="title-page-name"/>    this.aboutToComplete.stop();<br class="title-page-name"/>    this.nextUpExercise.stop();<br class="title-page-name"/>  }<br class="title-page-name"/>  resume() {<br class="title-page-name"/>    this.ticks.start();<br class="title-page-name"/>    if (this.nextUp.currentTime &gt; 0 &amp;&amp; !this.nextUp.playbackComplete) <br class="title-page-name"/>        { this.nextUp.start(); }<br class="title-page-name"/>    else if (this.nextUpExercise.currentTime &gt; 0 &amp;&amp; !this.nextUpExercise.playbackComplete)<br class="title-page-name"/>         { this.nextUpExercise.start(); }<br class="title-page-name"/>    else if (this.halfway.currentTime &gt; 0 &amp;&amp; !this.halfway.playbackComplete) <br class="title-page-name"/>        { this.halfway.start(); }<br class="title-page-name"/>    else if (this.aboutToComplete.currentTime &gt; 0 &amp;&amp; !this.aboutToComplete.playbackComplete) <br class="title-page-name"/>        { this.aboutToComplete.start(); }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  onExerciseProgress(progress: ExerciseProgressEvent) {<br class="title-page-name"/>    if (progress.runningFor === Math.floor(progress.exercise.duration / 2)<br class="title-page-name"/>      &amp;&amp; progress.exercise.exercise.name != 'rest') {<br class="title-page-name"/>      this.halfway.start();<br class="title-page-name"/>    }<br class="title-page-name"/>    else if (progress.timeRemaining === 3) {<br class="title-page-name"/>      this.aboutToComplete.start();<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  onExerciseChanged(state: ExerciseChangedEvent) {<br class="title-page-name"/>    if (state.current.exercise.name === 'rest') {<br class="title-page-name"/>      this.nextupSound = state.next.exercise.nameSound;<br class="title-page-name"/>      setTimeout(() =&gt; this.nextUp.start(), 2000);<br class="title-page-name"/>      setTimeout(() =&gt; this.nextUpExercise.start(), 3000);<br class="title-page-name"/>    }<br class="title-page-name"/>  } </pre>
<p class="calibre3">Having trouble writing these functions? They are available in the <kbd class="calibre13">checkpoint3.3</kbd> Git branch.</p>
<p class="calibre3">There are two new model classes used in the preceding code. Add their declarations to<span class="calibre6"> </span><kbd class="calibre13">model.ts</kbd>, as follows (again available in<span class="calibre6"> </span><kbd class="calibre13">checkpoint3.3</kbd>):</p>
<pre class="calibre19">export class ExerciseProgressEvent {<br class="title-page-name"/>    constructor(<br class="title-page-name"/>        public exercise: ExercisePlan,<br class="title-page-name"/>        public runningFor: number,<br class="title-page-name"/>        public timeRemaining: number,<br class="title-page-name"/>        public workoutTimeRemaining: number) { }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>export class ExerciseChangedEvent {<br class="title-page-name"/>    constructor(<br class="title-page-name"/>        public current: ExercisePlan,<br class="title-page-name"/>        public next: ExercisePlan) { }<br class="title-page-name"/>} </pre>
<p class="calibre3">These are model classes to track progress events. The<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span class="calibre6"> </span>implementation consumes this data. Remember to import the reference for<span class="calibre6"> </span><kbd class="calibre13">ExerciseProgressEvent</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">ExerciseProgressEvent</kbd><span class="calibre6"> </span>in<span class="calibre6"> </span><kbd class="calibre13">workout-audio.component.ts</kbd>.</p>
<p class="calibre3">To reiterate, the audio component consumes the events by defining two event handlers: <kbd class="calibre13">onExerciseProgress</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">onExerciseChanged.</kbd><span class="calibre6"> </span>How the events are generated becomes clear as we move along.</p>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">start</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">resume</kbd><span class="calibre6"> </span>functions stop and resume audio whenever a workout starts, pauses, or completes. The extra complexity in the resume function it to tackle cases when the workout was paused during next up, about to complete, or half-way audio playback. We just want to continue from where we left off.</p>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">onExerciseProgress</kbd><span class="calibre6"> </span>function should be called to report the workout progress. It's used to play the halfway audio and about-to-complete audio based on the state of the workout. The parameter passed to it is an object that contains exercise progress data.</p>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">onExerciseChanged</kbd><span class="calibre6"> </span>function should be called when the exercise changes. The input parameter contains the current and next exercise in line and helps<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span class="calibre6"> </span>to decide when to play the next up exercise audio.</p>
<p class="calibre3">We touched upon two new concepts in this section: template reference variables and injecting child elements/directives into the parent. It's worth exploring these two concepts in more detail before we continue with the implementation. We'll start with learning more about template reference variables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding template reference variables</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Template reference variables</strong><span class="calibre6"> </span>are created on the view template and<span class="calibre6"> </span>are<span class="calibre6"> </span>mostly consumed from the view. As you have already learned, these variables<span class="calibre6"> </span>can<span class="calibre6"> </span>be identified by the<span class="calibre6"> </span><kbd class="calibre13">#</kbd><span class="calibre6"> </span>prefix used to declare them.</p>
<p class="calibre3">One of the greatest benefits of template variables is that they facilitate cross-component communication at the view template level. Once declared, such variables can be referenced by sibling elements/components and their children. Check out the following snippet:</p>
<pre class="calibre19">    &lt;input #emailId type="email"&gt;Email to {{emailId.value}} 
    &lt;button (click)= "MailUser(emaild.value)"&gt;Send&lt;/button&gt; </pre>
<p class="calibre3">This snippet declares a template variable,<span class="calibre6"> </span><kbd class="calibre13">emailId</kbd>, and then references it in the interpolation and the button<span class="calibre6"> </span><kbd class="calibre13">click</kbd><span class="calibre6"> </span>expression.</p>
<p class="calibre3">The Angular templating engine assigns the DOM object for<span class="calibre6"> </span><kbd class="calibre13">input</kbd><span class="calibre6"> </span>(an instance of<span class="calibre6"> </span><kbd class="calibre13">HTMLInputElement</kbd>) to the<span class="calibre6"> </span><kbd class="calibre13">emailId</kbd><span class="calibre6"> </span>variable. Since the variable is available across siblings, we use it in a button's<span class="calibre6"> </span><kbd class="calibre13">click</kbd><span class="calibre6"> </span>expression.</p>
<p class="calibre3">Template variables work with components too. We can easily do this:</p>
<pre class="calibre19">    &lt;trainer-app&gt; 
     &lt;workout-runner #runner&gt;&lt;/workout-runner&gt; 
     &lt;button (click)= "runner.start()"&gt;Start Workout&lt;/button&gt; 
    &lt;/trainer-app&gt; </pre>
<p class="calibre3">In this case,<span class="calibre6"> </span><kbd class="calibre13">runner</kbd><span class="calibre6"> </span>has a reference to the <kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>object, and the button is used to start the workout.</p>
<div class="packt_infobox"><br class="calibre27"/>
The<span class="packt_screen"> </span><kbd class="calibre24">ref-</kbd><span class="packt_screen"> </span>prefix is the canonical alternative to<span class="packt_screen"> </span><kbd class="calibre24">#</kbd>. The<span class="packt_screen"> </span><kbd class="calibre24">#runner</kbd><span class="packt_screen"> </span>variable can also be declared as<span class="packt_screen"> </span><kbd class="calibre24">ref-runner</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Template variable assignment</h1>
                
            
            <article>
                
<p class="calibre3">You may not have noticed but there is something interesting about the<span class="calibre6"> </span>template<span class="calibre6"> </span>variable assignments described in the last few sections. To recap, the three examples that we have used are:</p>
<pre class="calibre19">&lt;audio #ticks="MyAudio" loop src="/static/audio/tick10s.mp3"&gt;&lt;/audio&gt; <br class="title-page-name"/>    <br class="title-page-name"/>&lt;input #emailId type="email"&gt;Email to {{emailId.value}}
<br class="title-page-name"/>&lt;workout-runner #runner&gt;&lt;/workout-runner&gt; </pre>
<p class="calibre3">What got assigned to the variable depends on where the variable was declared. This is governed by rules in Angular:</p>
<ul class="calibre11">
<li class="calibre12">If a directive is present on the element, such as<span> </span><kbd class="calibre13">MyAudioDirective</kbd><span> </span>in the first example shown previously, the directive sets the value. The<span> </span><kbd class="calibre13">MyAudioDirective</kbd><span> </span>directive sets the<span> </span><kbd class="calibre13">ticks</kbd><span> </span>variable to an instance of<span> </span><kbd class="calibre13">MyAudioDirective</kbd>.</li>
<li class="calibre12">If there is no directive present, either the underlying HTML DOM element is assigned or a component object is assigned (as shown in the<span> </span><kbd class="calibre13">input</kbd><span> </span>and<span> </span><kbd class="calibre13">workout-runner</kbd><span> </span>examples).</li>
</ul>
<p class="calibre3">We will be employing this technique to implement the workout audio component integration with the workout runner component. This introduction gives us the head start that we need.</p>
<p class="calibre3">The other new concept that we promised to cover is child element/directive injection using the <kbd class="calibre13">ViewChild</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">ViewChildren</kbd><span class="calibre6"> </span>decorators.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the @ViewChild decorator</h1>
                
            
            <article>
                
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">@ViewChild</kbd><span class="calibre6"> </span>decorator instructs the Angular DI<span class="calibre6"> </span>framework<span class="calibre6"> </span>to search for some specific child component/directive/element in the component tree and inject it into the parent. This allows the parent component to interact with child components/element using the reference to the child, a new communication pattern!</p>
<p class="calibre3">In the preceding code, the audio element directive (the<span class="calibre6"> </span><kbd class="calibre13">MyAudioDirective</kbd><span class="calibre6"> </span>class) is injected into the<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span class="calibre6"> </span>code.</p>
<p class="calibre3">To establish the context, let's recheck a view fragment from<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd>:</p>
<pre class="calibre19">    &lt;audio #ticks="MyAudio" loop src="/static/audio/tick10s.mp3"&gt;&lt;/audio&gt; </pre>
<p class="calibre3">Angular injects the directive (<kbd class="calibre13">MyAudioDirective</kbd>) into the<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span class="calibre6"> </span>property: <kbd class="calibre13">ticks</kbd>. The search is done based on the selector passed to the<span class="calibre6"> </span><kbd class="calibre13">@ViewChild</kbd><span class="calibre6"> </span>decorator. Let's see the audio example again:</p>
<pre class="calibre19"><strong class="calibre1">  @ViewChild('ticks')</strong> private ticks: MyAudioDirective;</pre>
<p class="calibre3">The selector parameter on<span class="calibre6"> </span><kbd class="calibre13">ViewChild</kbd><span class="calibre6"> </span>can be a string value, in which case Angular searches for a matching template variable, as before.</p>
<p class="calibre3">Or it can be a<span class="calibre6"> </span><em class="calibre17">type.</em><span class="calibre6"> </span>This is valid a<span class="calibre6">nd should inject an instance of</span><span class="calibre6"> </span><kbd class="calibre13">MyAudioDirective</kbd><span class="calibre6">:</span></p>
<pre class="calibre19">@ViewChild(MyAudioDirective) private ticks: MyAudioDirective; </pre>
<p class="calibre3">However, it does not work in our case. Why? Because there are multiple<span class="calibre6"> </span><kbd class="calibre13">MyAudioDirective</kbd><span class="calibre6"> </span>directives declared in the<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span class="calibre6"> </span>view, one for each of the<span class="calibre6"> </span><kbd class="calibre13">&lt;audio&gt;</kbd><span class="calibre6"> </span>tags. In such a scenario, the first match is injected. Not very useful. Passing the type selector would have worked if there was only one<span class="calibre6"> </span><kbd class="calibre13">&lt;audio&gt;</kbd><span class="calibre6"> </span>tag in the view!</p>
<div class="packt_tip">Properties decorated with<span class="packt_screen"> </span><kbd class="calibre24">@ViewChild</kbd><span class="packt_screen"> </span>are sure to be set before the <kbd class="calibre24">ngAfterViewInit</kbd><span class="packt_screen"> </span>event hook on the component is called. This implies such properties are<span class="packt_screen"> </span><kbd class="calibre24">null</kbd><span class="packt_screen"> </span>if accessed inside the constructor.</div>
<p class="calibre3">Angular also has a decorator to locate and inject multiple child components/directives: <kbd class="calibre13">@ViewChildren</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The @ViewChildren decorator</h1>
                
            
            <article>
                
<p class="calibre3"><kbd class="calibre13">@ViewChildren</kbd><span class="calibre6"> </span>works similarly to<span class="calibre6"> </span><kbd class="calibre13">@ViewChild</kbd>, except it can<span class="calibre6"> </span>be<span class="calibre6"> </span>used to inject multiple child types into the parent. Again taking the previous audio component above as an example, using<span class="calibre6"> </span><kbd class="calibre13">@ViewChildren</kbd>, we can get all the<span class="calibre6"> </span><kbd class="calibre13">MyAudioDirective</kbd><span class="calibre6"> </span>directive instances in<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd>, as shown here:</p>
<pre class="calibre19">@ViewChildren(MyAudioDirective) allAudios: QueryList&lt;MyAudioDirective&gt;; </pre>
<p class="calibre3">Look carefully;<span class="calibre6"> </span><kbd class="calibre13">allAudios</kbd><span class="calibre6"> </span>is not a standard JavaScript array, but a custom class,<span class="calibre6"> </span><kbd class="calibre13">QueryList&lt;Type&gt;</kbd>. The <kbd class="calibre13">QueryList</kbd> class is an immutable collection that contains the reference to the components/directives that Angular was able to locate based on the filter criteria passed to the <kbd class="calibre13">@ViewChildren</kbd><span class="calibre6"> </span>decorator. The best thing about this list is that Angular will keep this list in sync with the state of the view. When directives/components get added/removed from the view dynamically, this list is updated too. Components/directives generated using<span class="calibre6"> </span><kbd class="calibre13">ng-for</kbd><span class="calibre6"> </span>are a prime example of this dynamic behavior. Consider the preceding<span class="calibre6"> </span><kbd class="calibre13">@ViewChildren</kbd><span class="calibre6"> </span>usage and this view template:</p>
<pre class="calibre19">&lt;audio *ngFor="let clip of clips" src="/static/audio/ "+{{clip}}&gt;&lt;/audio&gt; </pre>
<p class="calibre3">The number of<span class="calibre6"> </span><kbd class="calibre13">MyAudioDirective</kbd><span class="calibre6"> </span>directives created by Angular depends upon the number of<span class="calibre6"> </span><kbd class="calibre13">clips</kbd>. When<span class="calibre6"> </span><kbd class="calibre13">@ViewChildren</kbd><span class="calibre6"> </span>is used, Angular injects the correct number of<span class="calibre6"> </span><kbd class="calibre13">MyAudioDirective</kbd><span class="calibre6"> </span>instances into the <kbd class="calibre13">allAudio</kbd><span class="calibre6"> </span>property and keeps it in sync when items are added or removed from the <kbd class="calibre13">clips</kbd><span class="calibre6"> </span>array.</p>
<p class="calibre3">While the usage of<span class="calibre6"> </span><kbd class="calibre13">@ViewChildren</kbd><span class="calibre6"> </span>allows us to get hold of all<span class="calibre6"> </span><kbd class="calibre13">MyAudioDirective</kbd><span class="calibre6"> </span>directives, it cannot be used to control the playback. You see, we need to get hold of individual<span class="calibre6"> </span><kbd class="calibre13">MyAudioDirective</kbd><span class="calibre6"> </span>instances as the audio playback timing varies. Hence the distinct <kbd class="calibre13">@ViewChild</kbd><span class="calibre6"> </span>implementation.</p>
<p class="calibre3">Once we get hold of the<span class="calibre6"> </span><kbd class="calibre13">MyAudioDirective</kbd><span class="calibre6"> </span>directive attached to each audio element, it is just a matter of playing the audio tracks at the right time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Integrating WorkoutAudioComponent</h1>
                
            
            <article>
                
<p class="calibre3">While we have<span class="calibre6"> </span>componentized the audio playback functionality into<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd>, it is and always will be tightly coupled to the <kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>implementation.<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span class="calibre6"> </span>derives its operational intelligence from<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd>. Hence the two components need to interact.<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>needs to provide the<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span class="calibre6"> </span>state change data, including<span class="calibre6"> </span>when<span class="calibre6"> </span>the workout started, exercise progress, workout stopped, paused, and resumed.</p>
<p class="calibre3">One way to achieve this integration would be to use the currently exposed<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span class="calibre6"> </span>API (stop, resume, and other functions) from<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd>.</p>
<p class="calibre3">Something can be done by injecting<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span class="calibre6"> </span>into<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd>, as we did earlier when we injected<span class="calibre6"> </span><kbd class="calibre13">MyAudioDirective</kbd><span class="calibre6"> </span>into<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd>.</p>
<p class="calibre3">Declare the<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span class="calibre6"> </span>in the<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent's</kbd><span class="calibre6"> </span>view, such as:</p>
<pre class="calibre19">&lt;div class="row pt-4"&gt;...&lt;/div&gt;<br class="title-page-name"/><strong class="calibre1">&lt;abe-workout-audio&gt;&lt;/abe-workout-audio&gt;</strong></pre>
<p class="calibre3">Doing so gives us a reference to the<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span class="calibre6"> </span>inside the <kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>implementation:</p>
<pre class="calibre19">@ViewChild(WorkoutAudioComponent) workoutAudioPlayer: WorkoutAudioComponent; </pre>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span class="calibre6"> </span>functions can then be invoked from<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>from different places in the code. For example, this is how<span class="calibre6"> </span><kbd class="calibre13">pause</kbd><span class="calibre6"> </span>would change:</p>
<pre class="calibre19">    pause() { 
      clearInterval(this.exerciseTrackingInterval); 
      this.workoutPaused = true; 
<strong class="calibre1">      this.workoutAudioPlayer.stop();</strong> 
    }</pre>
<p class="calibre3">And to play the next-up audio, we would need to change parts of the<span class="calibre6"> </span><kbd class="calibre13">startExerciseTimeTracking</kbd><span class="calibre6"> </span>function:</p>
<pre class="calibre19">this.startExercise(next); 
<strong class="calibre1">this.workoutAudioPlayer.onExerciseChanged(new ExerciseChangedEvent(next, this.getNextExercise()));</strong></pre>
<p class="calibre3">This is a perfectly viable option where<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span class="calibre6"> </span>becomes a dumb component controlled by<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd>. The only problem with this solution is that it adds some noise to the<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>implementation.<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>now needs to manage audio playback too.</p>
<p class="calibre3">There is an alternative, however.</p>
<p class="calibre3"><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>can expose events that are triggered during different times of workout execution, such as workout started, exercise started, and workout paused. The advantage of having<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>expose events is that it allows us to integrate other components/directives with<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>using the same events. Be it the<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span class="calibre6"> </span>or components we create in future.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Exposing WorkoutRunnerComponent events</h1>
                
            
            <article>
                
<p class="calibre3">Till now we have only explored how to consume events. Angular allows us to raise events too. Angular components and directives can expose<span class="calibre6"> </span>custom events using the<span class="calibre6"> </span><kbd class="calibre13">EventEmitter</kbd><span class="calibre6"> </span>class and the <kbd class="calibre13">@Output</kbd><span class="calibre6"> </span>decorator.</p>
<p class="calibre3">Add these event declarations to<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>at the end of the variable declaration section:</p>
<pre class="calibre19">workoutPaused: boolean; 
<strong class="calibre1">@Output() exercisePaused: EventEmitter&lt;number&gt; </strong><strong class="calibre1">= <br class="title-page-name"/>    new EventEmitter&lt;number&gt;();
</strong><strong class="calibre1">@Output() exerciseResumed: EventEmitter&lt;number&gt; </strong><strong class="calibre1">= <br class="title-page-name"/>    new EventEmitter&lt;number&gt;()<br class="title-page-name"/></strong><strong class="calibre1">@Output() exerciseProgress:EventEmitter&lt;ExerciseProgressEvent&gt; </strong><strong class="calibre1">= <br class="title-page-name"/>    new EventEmitter&lt;ExerciseProgressEvent&gt;();
</strong><strong class="calibre1">@Output() exerciseChanged: EventEmitter&lt;ExerciseChangedEvent&gt; </strong><strong class="calibre1">= 
    new EventEmitter&lt;ExerciseChangedEvent&gt;();
</strong><strong class="calibre1">@Output() workoutStarted: EventEmitter&lt;WorkoutPlan&gt; </strong><strong class="calibre1">= 
    new EventEmitter&lt;WorkoutPlan&gt;();
</strong><strong class="calibre1">@Output() workoutComplete: EventEmitter&lt;WorkoutPlan&gt; </strong><strong class="calibre1">= 
    new EventEmitter&lt;WorkoutPlan&gt;();</strong></pre>
<p class="calibre3">The names of the events are self-explanatory, and within our<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>implementation, we need to raise them at the appropriate times.</p>
<p class="calibre3">Remember to add the <kbd class="calibre13">ExerciseProgressEvent</kbd> and<span class="calibre6"> </span><kbd class="calibre13">ExerciseChangeEvent</kbd><span class="calibre6"> </span>imports to the<span class="calibre6"> </span><kbd class="calibre13">model</kbd><span class="calibre6"> </span>already declared on top. And add the<span class="calibre6"> </span><kbd class="calibre13">Output</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">EventEmitter</kbd><span class="calibre6"> </span>imports to<span class="calibre6"> </span><kbd class="calibre13">@angular/core</kbd>.</p>
<p class="calibre3">Let's try to understand the role of the<span class="calibre6"> </span><kbd class="calibre13">@Output</kbd><span class="calibre6"> </span>decorator and the<span class="calibre6"> </span><kbd class="calibre13">EventEmitter</kbd><span class="calibre6"> </span>class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The @Output decorator</h1>
                
            
            <article>
                
<p class="calibre3">We covered a decent<span class="calibre6"> </span>amount<span class="calibre6"> </span>of Angular eventing capabilities in<span class="calibre6"> </span><a href="" class="calibre10">Chapter 2</a>,<span class="calibre6"> </span><em class="calibre17">Building Our First App <span class="calibre6">–</span><span class="calibre6"> </span>7-Minute Workout</em>. Specifically, we learned how we can consume any event on a component, directive, or DOM element using the<span class="calibre6"> </span><kbd class="calibre13">bracketed ()</kbd><span class="calibre6"> </span>syntax. How about raising our own events?</p>
<p class="calibre3">In Angular, we can create and raise our own events, events that signify something noteworthy has happened in our component/directive. Using the<span class="calibre6"> </span><kbd class="calibre13">@Output</kbd><span class="calibre6"> </span>decorator and the<span class="calibre6"> </span><kbd class="calibre13">EventEmitter</kbd><span class="calibre6"> </span>class, we can define and raise custom events.</p>
<div class="packt_infobox">It's also a good time to refresh what we learned about events, by revisiting the<span class="packt_screen"> </span><em class="calibre31">Eventing subsection</em><span class="packt_screen"> </span>in the<span class="packt_screen"> </span><em class="calibre31">Angular event binding infrastructure</em><span class="packt_screen"> </span>section from<span class="packt_screen"> </span><a href="" class="calibre21">Chapter 2</a>,<span class="packt_screen"> </span><em class="calibre31">Building Our First App <span class="packt_screen">–</span><span class="packt_screen"> </span>7-Minute Workout</em>.</div>
<p class="calibre3">Remember this: it is through events that components can communicate with the outside world. When we declare:</p>
<pre class="calibre19">@Output() exercisePaused: EventEmitter&lt;number&gt; = new EventEmitter&lt;number&gt;(); </pre>
<p class="calibre3">It signifies that<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>exposes an event, <kbd class="calibre13">exercisePaused</kbd><span class="calibre6"> </span>(raised when the workout is paused).</p>
<p class="calibre3">To subscribe to this event, we can do the following:</p>
<pre class="calibre19">&lt;abe-workout-runner (exercisePaused)="onExercisePaused($event)"&gt;&lt;/abe-workout-runner&gt;</pre>
<p class="calibre3">This looks absolutely similar to how we did the DOM event subscription in the workout runner template. See this sample<span class="calibre6"> </span>stipped<span class="calibre6"> </span>from the workout-runner's view:</p>
<pre class="calibre19">&lt;div id="pause-overlay" (click)="pauseResumeToggle()" (window:keyup)="onKeyPressed($event)"&gt; </pre>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">@Output</kbd><span class="calibre6"> </span>decorator instructs Angular to make this event available for template binding. Events created without the<span class="calibre6"> </span><kbd class="calibre13">@Output</kbd><span class="calibre6"> </span>decorator cannot be referenced in HTML.</p>
<div class="packt_infobox">The<span class="packt_screen"> </span><kbd class="calibre24">@Output</kbd><span class="packt_screen"> </span>decorator can also take a parameter, signifying the name of the event. If not provided, the decorator uses the property name:<span class="packt_screen"> </span><kbd class="calibre24">@Output("workoutPaused") exercisePaused: EventEmitter&lt;number&gt; ...</kbd>. This declares a <kbd class="calibre24">workoutPaused</kbd> event instead of<span class="packt_screen"> </span><kbd class="calibre24">exercisePaused</kbd>.</div>
<p class="calibre3">Like any decorator, the<span class="calibre6"> </span><kbd class="calibre13">@Output</kbd><span class="calibre6"> </span>decorator is there just to provide metadata for the Angular framework to work with. The real heavy lifting is done by the<span class="calibre6"> </span><kbd class="calibre13">EventEmitter</kbd><span class="calibre6"> </span>class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Eventing with EventEmitter</h1>
                
            
            <article>
                
<p class="calibre3">Angular embraces<span class="calibre6"> </span><strong class="calibre5">reactive programming</strong><span class="calibre6"> </span>(also dubbed <strong class="calibre5">Rx</strong>-style programming) to<span class="calibre6"> </span>support<span class="calibre6"> </span>asynchronous operations with events. If you are hearing this term for the first<span class="calibre6"> </span>time<span class="calibre6"> </span>or don't have much idea about what reactive programming is, you're not alone.</p>
<p class="calibre3">Reactive programming is all about programming against<span class="calibre6"> </span><strong class="calibre5">asynchronous data streams</strong>. Such a stream is nothing but a sequence of ongoing<span class="calibre6"> </span>events<span class="calibre6"> </span>ordered based on the time they occur. We can imagine a stream as a pipe generating data (in some manner) and pushing it to one or more subscribers. Since these events are captured asynchronously by subscribers, they are called asynchronous data streams.</p>
<p class="calibre3">The data can be anything, ranging from browser/DOM element events to user input to loading remote data using AJAX. With<span class="calibre6"> </span><em class="calibre17">Rx</em><span class="calibre6"> </span>style, we consume this data uniformly.</p>
<p class="calibre3">In the Rx world, there are Observers and Observables, a concept derived from the very popular<span class="calibre6"> </span><strong class="calibre5">Observer design pattern</strong>.<span class="calibre6"> </span><strong class="calibre5">Observables</strong><span class="calibre6"> </span>are streams that emit data.<span class="calibre6"> </span><strong class="calibre5">Observers</strong>, on the<span class="calibre6"> </span>other<span class="calibre6"> </span>hand, subscribe to these events.</p>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">EventEmitter</kbd><span class="calibre6"> </span>class in Angular is primarily responsible for providing eventing support. It acts both as an<span class="calibre6"> </span><em class="calibre17">observer</em><span class="calibre6"> </span>and<span class="calibre6"> </span><em class="calibre17">observable</em>. We can fire<span class="calibre6"> </span>events<span class="calibre6"> </span>on it and it can also listen to events.</p>
<p class="calibre3">There are two functions available on<span class="calibre6"> </span><kbd class="calibre13">EventEmitter</kbd><span class="calibre6"> </span>that are of interest to us:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">emit</kbd>: As the name suggests, use this function to raise events. It takes a single argument that is the event data.<span> </span><kbd class="calibre13">emit</kbd><span> </span><em class="calibre2">is the observable side</em>.</li>
<li class="calibre12"><kbd class="calibre13">subscribe</kbd>: Use this function to subscribe to the events raised by<span> </span><kbd class="calibre13">EventEmitter</kbd>.<span> </span><kbd class="calibre13">subscribe</kbd><span> </span>is the observer side.</li>
</ul>
<p class="calibre3">Let's do some event publishing and subscriptions to understand how the preceding functions work.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Raising events from WorkoutRunnerComponent</h1>
                
            
            <article>
                
<p class="calibre3">Look at the<span class="calibre6"> </span><kbd class="calibre13">EventEmitter</kbd><span class="calibre6"> </span>declaration. These have<span class="calibre6"> </span>been<span class="calibre6"> </span>declared with the <kbd class="calibre13">type</kbd><span class="calibre6"> </span>parameter. The<span class="calibre6"> </span><kbd class="calibre13">type</kbd><span class="calibre6"> </span>parameter on<span class="calibre6"> </span><kbd class="calibre13">EventEmitter</kbd><span class="calibre6"> </span>signifies the type of data emitted.</p>
<p class="calibre3">Let's add the event implementation to<span class="calibre6"> </span><kbd class="calibre13">workout-runner.component.ts</kbd>, starting from the top of the file and moving down.</p>
<p class="calibre3">Add this statement to the end of the <kbd class="calibre13">start</kbd><span class="calibre6"> </span>function:</p>
<pre class="calibre19">this.workoutStarted.emit(this.workoutPlan);</pre>
<p class="calibre3">We use the<span class="calibre6"> </span><kbd class="calibre13">emit</kbd><span class="calibre6"> </span>function of <span class="calibre6"> </span><kbd class="calibre13">EventEmitter</kbd><span class="calibre6"> </span><span class="calibre6"> to raise a </span><kbd class="calibre13">workoutStarted</kbd><span class="calibre6"> event with the current workout plan as an argument.</span></p>
<p class="calibre3">To<span class="calibre6"> </span><kbd class="calibre13">pause</kbd>, add this line to raise the <kbd class="calibre13">exercisePaused</kbd><span class="calibre6"> </span>event:</p>
<pre class="calibre19">this.exercisePaused.emit(this.currentExerciseIndex); </pre>
<p class="calibre3">To<span class="calibre6"> </span><kbd class="calibre13">resume</kbd>, add the following line:</p>
<pre class="calibre19">this.exerciseResumed.emit(this.currentExerciseIndex); </pre>
<p class="calibre3">Each time, we pass the current exercise index as an argument to<span class="calibre6"> </span><kbd class="calibre13">emit</kbd><span class="calibre6"> </span>when raising the <kbd class="calibre13">exercisePaused</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">exerciseResumed</kbd><span class="calibre6"> </span>events.</p>
<p class="calibre3">Inside the <kbd class="calibre13">startExerciseTimeTracking</kbd><span class="calibre6"> </span>function, add the highlighted code after the call to<span class="calibre6"> </span><kbd class="calibre13">startExercise</kbd>:</p>
<pre class="calibre19">this.startExercise(next); 
<strong class="calibre1">this.exerciseChanged.emit(new ExerciseChangedEvent(next, this.getNextExercise()));</strong></pre>
<p class="calibre3">The argument passed contains the exercise that is going to start (<kbd class="calibre13">next</kbd>) and the next exercise in line (<kbd class="calibre13">this.getNextExercise()</kbd>).</p>
<p class="calibre3">To the same function, add the highlighted code:</p>
<pre class="calibre19">this.tracker.endTracking(true); 
<strong class="calibre1">this.workoutComplete.emit(this.workoutPlan);</strong> 
this.router.navigate(['finish']); </pre>
<p class="calibre3">The event is raised when the workout is completed.</p>
<p class="calibre3">In the same function, we raise an event that<span class="calibre6"> </span>communicates the workout progress. Add this statement:</p>
<pre class="calibre19">--this.workoutTimeRemaining; 
<strong class="calibre1">this.exerciseProgress.emit(new ExerciseProgressEvent( 
    </strong><strong class="calibre1">this.currentExercise,</strong><strong class="calibre1"> <br class="title-page-name"/>    this.exerciseRunningDuration,</strong><strong class="calibre1"> 
    this.currentExercise.duration -</strong><strong class="calibre1">this.exerciseRunningDuration,</strong><strong class="calibre1"> 
    this.workoutTimeRemaining</strong><strong class="calibre1">));</strong></pre>
<p class="calibre3">That completes our eventing implementation.</p>
<p class="calibre3">As you may have guessed,<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span class="calibre6"> </span>now needs to consume these events. The challenge here is how to organize these components so that they can communicate with each other with the minimum dependency on each other.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Component communication patterns</h1>
                
            
            <article>
                
<p class="calibre3">As the implementation stands now, we have:</p>
<ul class="calibre11">
<li class="calibre12">A basic<span> </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span> </span>implementation</li>
<li class="calibre12">Augmented<span> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span> </span>by exposing workout life cycle events</li>
</ul>
<p class="calibre3">These two components just need to talk to each<span class="calibre6"> </span>other<span class="calibre6"> </span>now.</p>
<p class="calibre3">If the parent needs to communicate with its children, it can do this by:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Property binding</strong>: The parent component can set up a property binding on the child component to push data to the child component. For example, this property binding can stop the audio player when the workout is paused:</li>
</ul>
<pre class="calibre19">        &lt;workout-audio [stopped]="workoutPaused"&gt;&lt;/workout-audio&gt;</pre>
<p class="calibre36">Property binding, in this case, works fine. When the workout is paused, the audio is stopped too. But not all scenarios can be handled using property bindings. Playing the next exercise audio or halfway audio requires a bit more control.</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Calling functions on child components</strong>: The parent component can also call functions on the child component if it can get hold of the child component. We have already seen how to achieve this using the<span> </span><kbd class="calibre13">@ViewChild</kbd><span> </span>and<span> </span><kbd class="calibre13">@ViewChildren</kbd><span> </span>decorators in the<span> </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span> </span>implementation. This approach and its shortcomings have also been discussed briefly in the <em class="calibre2">Integrating WorkoutAudioComponent</em><span> </span>section.</li>
</ul>
<p class="calibre3">There is one more not-so-good option. Instead of the parent referencing the child component, the child references the parent component. This allows the child component to call the parent component's public functions or subscribe to parent component events.</p>
<p class="calibre3">We are going to try this approach and then scrap the implementation for a better one! A lot of learning can be derived from the not-so-optimal solution we plan to implement.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Injecting a parent component into a child component</h1>
                
            
            <article>
                
<p class="calibre3">Add the<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span class="calibre6"> </span>to the<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>view just<span class="calibre6"> </span>before<span class="calibre6"> </span>the last closing<span class="calibre6"> </span><kbd class="calibre13">div</kbd>:</p>
<pre class="calibre19"> &lt;abe-workout-audio&gt;&lt;/abe-workout-audio&gt; </pre>
<p class="calibre3">Next, inject<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>into<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd>. Open<span class="calibre6"> </span><kbd class="calibre13">workout-audio.component.ts</kbd><span class="calibre6"> </span>and add the following declaration and update the constructor:</p>
<pre class="calibre19">private subscriptions: Array&lt;any&gt;; 
 
constructor( @Inject(forwardRef(() =&gt; WorkoutRunnerComponent)) 
    private runner: WorkoutRunnerComponent) { 
    this.subscriptions = [ 
      this.runner.exercisePaused.subscribe((exercise: ExercisePlan) =&gt; 
          this.stop()), 
      this.runner.workoutComplete.subscribe((exercise: ExercisePlan) =&gt; 
          this.stop()), 
      this.runner.exerciseResumed.subscribe((exercise: ExercisePlan) =&gt; 
          this.resume()), 
      this.runner.exerciseProgress.subscribe((progress: ExerciseProgressEvent) =&gt; 
          this.onExerciseProgress(progress)),</pre>
<pre class="calibre19"><br class="title-page-name"/>      this.runner.exerciseChanged.subscribe((state: ExerciseChangedEvent) =&gt;  
          this.onExerciseChanged(state))]; 
    } </pre>
<p class="calibre3">And remember to add these imports:</p>
<pre class="calibre19">    import {Component, ViewChild, <strong class="calibre1">Inject</strong>, <strong class="calibre1">forwardRef</strong>} from '@angular/core'; 
    import <strong class="calibre1">{WorkoutRunnerComponent}</strong> from '../workout-runner.component'  </pre>
<p class="calibre3">Let's try to understand what we have done before running the app. There is some amount of trickery involved in the construction injection. If we directly try to inject<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>into<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd>, it fails with Angular complaining of not being able to find all the dependencies. Read the code and think carefully; there is a subtle dependency cycle issue lurking.<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd> is already dependent on<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd>, as we have referenced<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span class="calibre6"> </span>in the<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>view. Now by injecting<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>in<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd>, we have created a dependency cycle.</p>
<p class="calibre3">Cyclic dependencies are challenging for any DI framework. When creating a component with a cyclic dependency, the framework has to somehow resolve the cycle. In the preceding example, we resolve the circular dependency issue by using an<span class="calibre6"> </span><kbd class="calibre13">@Inject</kbd><span class="calibre6"> </span>decorator and passing in the token created using the<span class="calibre6"> </span><kbd class="calibre13">forwardRef()</kbd><span class="calibre6"> </span>global framework function.</p>
<p class="calibre3">Once the injection is done correctly, inside the constructor, we attach a handler to the<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd> events, using the <kbd class="calibre13">subscribe</kbd><span class="calibre6"> </span>function of<span class="calibre6"> </span><kbd class="calibre13">EventEmitter</kbd><span class="calibre6">. The arrow function passed to</span><span class="calibre6"> </span><kbd class="calibre13">subscribe</kbd><span class="calibre6"> </span><span class="calibre6">is called whenever the event occurs with a specific event argument. We collect all the subscriptions into a </span><kbd class="calibre13">subscription</kbd><span class="calibre6"> array. This array comes in handy when we unsubscribe, which we need to, to avoid memory leaks.</span></p>
<p class="calibre3">A bit about<span class="calibre6"> </span><kbd class="calibre13">EventEmitter</kbd>: the<span class="calibre6"> </span><kbd class="calibre13">EventEmmiter</kbd> subscription (<kbd class="calibre13">subscribe</kbd><span class="calibre6"> </span>function) takes three arguments:</p>
<pre class="calibre19">    subscribe(generatorOrNext?: any, error?: any, complete?: any) : any </pre>
<ul class="calibre11">
<li class="calibre12">The first argument is a callback, which is invoked<span> </span>whenever<span> </span>an event is emitted</li>
<li class="calibre12">The second argument is an error callback function, invoked when the observable (the part that is generating events) errors out</li>
<li class="calibre12">The final argument takes a callback function that is called when the observable is done publishing events</li>
</ul>
<p class="calibre3">We have done enough to make audio integration work. Run the app and start the workout. Except for the ticking audio, all the<span class="calibre6"> </span><kbd class="calibre13">\</kbd><span class="calibre6"> </span>audio clips play at the right time. You may have to wait some time to hear the other audio clips. What is the problem?</p>
<p class="calibre3">As it turns out, we never started the ticking audio clip at the start of the workout. We can fix it by either setting the<span class="calibre6"> </span><kbd class="calibre13">autoplay</kbd><span class="calibre6"> </span>attribute on the <kbd class="calibre13">ticks</kbd><span class="calibre6"> </span>audio element or using the component life cycle events to trigger the ticking sound. Let's take the second approach.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using component life cycle events</h1>
                
            
            <article>
                
<p class="calibre3">The injected<span class="calibre6"> </span><kbd class="calibre13">MyAudioDirective</kbd><span class="calibre6"> </span>in<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd>, shown as follows, is not available till the view is initialized:</p>
<pre class="calibre19">&lt;audio #ticks="MyAudio" loop src="/assets/audio/tick10s.mp3"&gt;&lt;/audio&gt;<br class="title-page-name"/>&lt;audio #nextUp="MyAudio" src="/assets/audio/nextup.mp3"&gt;&lt;/audio&gt;<br class="title-page-name"/>...</pre>
<p class="calibre3">We can verify it by accessing the <kbd class="calibre13">ticks</kbd><span class="calibre6"> </span>variable inside the constructor; it will be null. Angular has still not done its magic and we need to wait for the children of <kbd class="calibre13">WorkoutAudioComponent</kbd> to be initialized.</p>
<p class="calibre3">The component's life cycle hooks<span class="calibre6"> </span>can<span class="calibre6"> </span>help us here. The<span class="calibre6"> </span><kbd class="calibre13">AfterViewInit</kbd><span class="calibre6"> </span>event hook is called once the component's view has been initialized and hence is a safe place from which to access the component's child directives/elements. Let's do it quickly.</p>
<p class="calibre3">Update <kbd class="calibre13">WorkoutAudioComponent</kbd><span class="calibre6"> </span>by adding the interface implementation, and the necessary imports, as highlighted:</p>
<pre class="calibre19">import {..., <strong class="calibre1">AfterViewInit</strong>} from '@angular/core'; 
... 
export class WorkoutAudioComponent implements OnInit, <strong class="calibre1">AfterViewInit</strong> { 
    <strong class="calibre1">ngAfterViewInit() { 
          this.ticks.start(); 
    }</strong></pre>
<p class="calibre3">Go ahead and test the app. The app has come to life with full-fledged audio feedback. Nice!</p>
<p class="calibre3">While everything looks fine and dandy on the surface, there is a memory leak in the application now. If, in the middle of the workout, we navigate away from the workout page (to the start or finish page) and again return to the workout page, multiple audio clips play at random times.</p>
<p class="calibre3">It seems that <kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>is not getting destroyed on route navigation, and due to this, none of the child components are destroyed, including<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd>. The net result? A new<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>is being created every time we navigate to the workout page but is never removed from the memory on navigating away.</p>
<p class="calibre3">The primary reason for this memory leak is the event handlers we have added in<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd>. We need to unsubscribe from these events when the audio component unloads, or else the<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>reference will never be dereferenced.</p>
<p class="calibre3">Another component lifecycle event comes to<span class="calibre6"> </span>our<span class="calibre6"> </span>rescue here: <kbd class="calibre13">OnDestroy</kbd> Add this implementation to the<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span class="calibre6"> </span>class:</p>
<pre class="calibre19">    ngOnDestroy() { 
      this.subscriptions.forEach((s) =&gt; s.unsubscribe()); 
    }</pre>
<p class="calibre3">Also, remember to add references to the<span class="calibre6"> </span><kbd class="calibre13">OnDestroy</kbd><span class="calibre6"> </span>event interface as we did for<span class="calibre6"> </span><kbd class="calibre13">AfterViewInit</kbd>.</p>
<p class="calibre3">Hope the<span class="calibre6"> </span><kbd class="calibre13">subscription</kbd><span class="calibre6"> </span>array that we created during event subscription makes sense now. One-shot unsubscribe!</p>
<p class="calibre3">This audio integration is now complete. While this approach is not an awfully bad way of integrating the two components, we can do better. Child components referring to the parent component seems to be undesirable.</p>
<div class="packt_infobox">Before proceeding, delete the code that we have added to<span class="packt_screen"> </span><kbd class="calibre24">workout-audio.component.ts</kbd><span class="packt_screen"> </span>from the<span class="packt_screen"> </span><em class="calibre31">Injecting a parent component into a child component</em><span class="packt_screen"> </span>section onward.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Sibling component interaction using events and template variables</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6">What if </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> and </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span class="calibre6"> were organized as sibling components? </span></p>
<p class="calibre3">If<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>become siblings, we can make good use of Angular's <em class="calibre17">eventing</em><span class="calibre6"> </span>and<span class="calibre6"> </span><em class="calibre17">template reference variables</em>. Confused? Well, to<span class="calibre6"> </span>start<span class="calibre6"> </span>with, this is how<span class="calibre6"> </span>the<span class="calibre6"> </span>components should be laid out:</p>
<pre class="calibre19">    &lt;workout-runner&gt;&lt;/workout-runner&gt; 
    &lt;workout-audio&gt;&lt;/workout-audio&gt; </pre>
<p class="calibre3">Does it ring any bells? Starting from this template, can you guess how the final HTML template would look? Think about it before you proceed further.</p>
<p class="calibre3">Still struggling? As soon as we make them sibling components, the power of the Angular templating engine comes to the fore. The following template code is enough to integrate<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd>:</p>
<pre class="calibre19">&lt;abe-workout-runner (exercisePaused)="wa.stop()" <br class="title-page-name"/>    (exerciseResumed)="wa.resume()" <br class="title-page-name"/>    (exerciseProgress)= "wa.onExerciseProgress($event)" <br class="title-page-name"/>    (exerciseChanged)= "wa.onExerciseChanged($event)" <br class="title-page-name"/>    (workoutComplete)="wa.stop()" 
    (workoutStarted)="wa.resume()"&gt; 
&lt;/abe-workout-runner&gt; 
&lt;abe-workout-audio #wa&gt;&lt;/abe-workout-audio&gt; </pre>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd> template variable, <kbd class="calibre13">wa</kbd>, is being manipulated by referencing the variable in the event handler expressions on<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd>. Quite elegant! We still need to solve the biggest puzzle in this approach: Where does the preceding code go? Remember,<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>is loaded as part of route loading. Nowhere in the code have we had a statement like this:</p>
<pre class="calibre19">    &lt;workout-runner&gt;&lt;/workout-runner&gt; </pre>
<p class="calibre3">We need to reorganize the component tree and bring in a container component that can host<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd>. The router then loads this container component instead of<span class="calibre6"> </span><kbd class="calibre13">WorkoutRunnerComponent</kbd>. Let's do it.</p>
<p class="calibre3">Generate a new component code from command line by navigating to<span class="calibre6"> </span><kbd class="calibre13">trainer/src/app/workout-runner</kbd><span class="calibre6"> </span>and executing:</p>
<pre class="calibre19"><strong class="calibre1">ng generate component workout-container -is</strong></pre>
<p class="calibre3">Copy the HTML code with the events described to the template file. The workout container component is ready.</p>
<p class="calibre3">We just need to rewire the routing setup. Open<span class="calibre6"> </span><kbd class="calibre13">app-routing.module.ts</kbd>. Change the route for the workout runner and add the necessary import:</p>
<pre class="calibre19"><strong class="calibre1">import {WorkoutContainerComponent} </strong><br class="title-page-name"/><strong class="calibre1">        from './workout-runner/workout-container/workout-container.component';</strong> 
..
<strong class="calibre1">{ path: '/workout', component: WorkoutContainerComponent },</strong></pre>
<p class="calibre3">And we have a working audio integration that is clear, concise, and pleasing to the eye!</p>
<p class="calibre3">It's time now to wrap up the chapter, but not before addressing<span class="calibre6"> </span>the<span class="calibre6"> </span>video player dialog glitch introduced in the earlier sections. The workout does not stop/pause when<span class="calibre6"> </span>the<span class="calibre6"> </span>video player dialog is open.</p>
<p class="calibre3">We are not going to detail the fix here, and urge the readers to give it a try without consulting the<span class="calibre6"> </span><kbd class="calibre13">checkpoint3.4</kbd><span class="calibre6"> </span>code.</p>
<p class="calibre3">Here is an obvious hint. Use the eventing infrastructure!</p>
<p class="calibre3">And another one: raise events from<span class="calibre6"> </span><kbd class="calibre13">VideoPlayerComponent</kbd>, one for each playback started and ended.</p>
<p class="calibre3">And one last hint: the<span class="calibre6"> </span><kbd class="calibre13">open</kbd><span class="calibre6"> </span>function on the dialog service (<kbd class="calibre13">Modal</kbd>) returns a promise, which is resolved when the dialog is closed.</p>
<div class="packt_infobox">If you are having a problem with running the code, look at the <kbd class="calibre24">checkpoint3.4</kbd> Git branch for a working version of what we have done thus far. Or if you are not using Git, download the snapshot of<span class="packt_screen"> </span><kbd class="calibre24">checkpoint3.4</kbd><span class="packt_screen"> </span>(a ZIP file) from<span class="packt_screen"> </span><a href="http://bit.ly/ng6be-checkpoint-3-4" class="calibre21">http://bit.ly/ng6be-checkpoint-3-4</a><span class="packt_screen"/>. Refer to the<span class="packt_screen"> </span><kbd class="calibre24">README.md</kbd><span class="packt_screen"> </span>file in the<span class="packt_screen"> </span><kbd class="calibre24">trainer</kbd><span class="packt_screen"> </span>folder when setting up the snapshot for the first time.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre3">Bit by bit, piece by piece, we have added a number of enhancements to the<span class="calibre6"> </span><em class="calibre17">7-Minute Workout</em> app that are imperative for any professional app. There is still scope for new features and improvements, but the core app works just fine.</p>
<p class="calibre3">We started the chapter by exploring the Single Page Application (SPA) capabilities of Angular. Here we learned about basic Angular routing, setting up routes, using route configuration, generating links using the<span class="calibre6"> </span><kbd class="calibre13">RouterLink</kbd><span class="calibre6"> </span>directive, and using the Angular<span class="calibre6"> </span><kbd class="calibre13">Router</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">Location</kbd><span class="calibre6"> </span>services to perform navigation.</p>
<p class="calibre3">From the app perspective, we added start, finish, and workout pages to<span class="calibre6"> </span><em class="calibre17">7-Minute Workout</em>.</p>
<p class="calibre3">We then built a workout history tracker service that was used to track historical workout executions. During this process, we learned about Angular's <strong class="calibre5">Dependency Injection (DI)</strong><span class="calibre6"> </span>in depth. We covered how a dependency is registered, what a dependency token is, and how dependencies are singleton in nature. We also learned about injectors and how hierarchical injectors affect dependency probing.</p>
<p class="calibre3">Lastly, we touched upon an important topic: cross-component communication, primarily using Angular eventing. We detailed how to create custom events using the<span class="calibre6"> </span><kbd class="calibre13">@Output</kbd><span class="calibre6"> </span>decorator and<span class="calibre6"> </span><kbd class="calibre13">EventEmitter</kbd>.</p>
<p class="calibre3">The<span class="calibre6"> </span><kbd class="calibre13">@ViewChild</kbd><span class="calibre6"> </span>and<span class="calibre6"> </span><kbd class="calibre13">@ViewChildren</kbd><span class="calibre6"> </span>decorators that we touched upon in this chapter helped us understand how a parent can get hold of a child component for use. Angular DI also allows injecting a parent component into a child.</p>
<p class="calibre3">We concluded this chapter by building a<span class="calibre6"> </span><kbd class="calibre13">WorkoutAudioComponent</kbd><span class="calibre6"> </span>and highlighted how sibling-component communication can happen using Angular events and template variables.</p>
<p class="calibre3">What's next? We are going to build a new app,<span class="calibre6"> </span><em class="calibre17">Personal Trainer</em>. This app will allow us to build our own custom workouts. Once we can create our own workout, we are going to morph the<span class="calibre6"> </span><em class="calibre17">7-Minute Workout</em><span class="calibre6"> </span>app into a generic<span class="calibre6"> </span><em class="calibre17">Workout Runner</em><span class="calibre6"> </span>app that can run workouts that we build using<span class="calibre6"> </span><em class="calibre17">Personal Trainer</em>.</p>
<p class="calibre3">For the next chapter, we'll showcase Angular's form capabilities while we build a UI that allows us to create, update, and view our own custom workouts/exercises.</p>


            </article>

            
        </section>
    </body></html>