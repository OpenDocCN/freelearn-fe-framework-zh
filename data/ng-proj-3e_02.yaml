- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Building an SPA Application with Scully and Angular Router
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Scully和Angular Router构建SPA应用程序
- en: Angular applications follow the **Single-Page Application (SPA)** architecture,
    where different views of the web page can be activated using the URL in the browser.
    Any changes to that URL can be intercepted by the Angular router and translated
    to routes that can activate a particular Angular component.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Angular应用程序遵循**单页应用程序（SPA）**架构，其中可以使用浏览器中的URL激活网页的不同视图。任何对该URL的更改都可以被Angular路由器拦截并转换为可以激活特定Angular组件的路由。
- en: '**Scully** is a popular static website generator that is based on the **Jamstack**
    architecture. It can cooperate nicely with the Angular router to prerender the
    content of an Angular application according to each route.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**Scully**是一个流行的基于**Jamstack**架构的静态网站生成器。它可以很好地与Angular路由器合作，根据每个路由预渲染Angular应用程序的内容。'
- en: 'In this chapter, we are going to combine Angular and Scully to create a personal
    blog. The following topics are going to be covered:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将结合Angular和Scully创建一个个人博客。以下主题将被涵盖：
- en: Setting up routing in an Angular application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular应用程序中设置路由
- en: Creating the basic layout of our blog
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们博客的基本布局
- en: Configuring routing for our application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置我们应用程序的路由
- en: Adding blog capabilities with Scully
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Scully添加博客功能
- en: Displaying blog posts on the home page
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主页上显示博客文章
- en: Essential background theory and context
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 必要的背景理论和上下文
- en: In the old days of web development, client-side applications were highly coupled
    with the underlying server infrastructure. Much machinery was involved when we
    wanted to visit the page of a website using a URL.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web开发的早期，客户端应用程序与底层服务器基础设施高度耦合。当我们想要通过URL访问网站页面时，涉及到许多机械操作。
- en: The browser would send the requested URL to the server, and the server should
    respond with a matching HTML file for that URL. This was a complicated process
    that would result in delays and varying round-trip times.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器会将请求的URL发送到服务器，服务器应该响应与该URL匹配的HTML文件。这是一个复杂的过程，会导致延迟和往返时间的差异。
- en: Modern web applications eliminate these problems using the SPA architecture.
    A client needs to request a single HTML file only once from the server. Any subsequent
    changes to the URL of the browser are handled internally by the client infrastructure.
    In Angular, the router is responsible for intercepting in-app URL requests and
    handling them according to a defined route configuration.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Web应用程序使用SPA架构消除了这些问题。客户端只需要从服务器请求一次单个HTML文件。浏览器URL的任何后续更改都由客户端基础设施内部处理。在Angular中，路由器负责拦截应用程序内的URL请求并根据定义的路由配置处理它们。
- en: 'Jamstack is a hot emerging technology that allows us to create fast and secure
    web applications. It can be used for any application type, ranging from an e-commerce
    website to a **Software as a Service (SaaS)** web application or even a personal
    blog. The architecture of Jamstack is based on the following pillars:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Jamstack是一种热门的新兴技术，允许我们创建快速和安全的Web应用程序。它可以用于任何应用程序类型，从电子商务网站到**软件即服务（SaaS）**Web应用程序，甚至个人博客。Jamstack的架构基于以下支柱：
- en: '**Performance**: Pages are generated and prerendered during production, eliminating
    the need to wait for content to load.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：页面在生产过程中生成和预渲染，消除了等待内容加载的需要。'
- en: '**Scaling**: Content is static files that can be served from anywhere, even
    from a **Content Delivery Network (CDN)** provider that improves the performance
    of the application.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展性**：内容是静态文件，可以从任何地方提供，甚至可以从提高应用程序性能的**内容分发网络（CDN）**提供商那里提供。'
- en: '**Security**: The serverless nature of server-side processes and the fact that
    content is already static eliminates potential attacks that target server infrastructures.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：服务器端过程的无服务器性质以及内容已经是静态的事实消除了针对服务器基础设施的潜在攻击。'
- en: Scully is the first static website generator for Angular that embraces the Jamstack
    approach. It essentially generates pages of the Angular application during build
    time to be immediately available when requested.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Scully是第一个采用Jamstack方法的Angular静态网站生成器。它本质上在构建时生成Angular应用程序的页面，以便在请求时立即可用。
- en: Project overview
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: 'In this project, we will build a personal blog using the Angular framework
    and enhance it with Jamstack characteristics using the Scully site generator.
    Initially, we will scaffold a new Angular application and enable it for routing.
    We will then create the basic layout of our application by adding some barebones
    components. As soon as we have a working Angular application, we will add blog
    support to it using Scully. We will then create some blog posts using Markdown
    files and display them on the home page of our application. The following diagram
    depicts an architectural overview of the project:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用 Angular 框架构建一个个人博客，并使用 Scully 网站生成器增强其 Jamstack 特性。最初，我们将构建一个新的
    Angular 应用程序并启用其路由功能。然后，我们将通过添加一些基本组件来创建我们应用程序的基本布局。一旦我们有一个可工作的 Angular 应用程序，我们将使用
    Scully 为其添加博客支持。然后，我们将使用 Markdown 文件创建一些博客文章，并在我们应用程序的首页上显示它们。以下图表展示了项目的架构概述：
- en: '![Εικόνα που περιέχει κείμενο, διάγραμμα, σκίτσο/σχέδιο, γραμμή  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B18465_02_01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、图表、草图/设计、线条的图像自动生成的描述](img/B18465_02_01.png)'
- en: Figure 2.1 – Project architecture
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 项目架构
- en: 'Build time: 1 hour.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 构建时间：1 小时。
- en: Getting started
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'The following software tools are required to complete this project:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此项目所需的以下软件工具：
- en: 'Angular CLI: A command-line interface for Angular that you can find at [https://angular.io/cli](https://angular.io/cli).'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular CLI：Angular 的命令行界面，您可以在 [https://angular.io/cli](https://angular.io/cli)
    找到。
- en: 'GitHub material: The related code for this chapter, which you can find in the
    `Chapter02` folder at [https://github.com/PacktPublishing/Angular-Projects-Third-Edition](https://github.com/PacktPublishing/Angular-Projects-Third-Edition).'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub 资料库：本章的相关代码，您可以在 [https://github.com/PacktPublishing/Angular-Projects-Third-Edition](https://github.com/PacktPublishing/Angular-Projects-Third-Edition)
    的 `Chapter02` 文件夹中找到。
- en: Setting up routing in an Angular application
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Angular 应用程序中设置路由
- en: 'We will kick off our project by creating a new Angular application from scratch.
    Execute the following Angular CLI command in a terminal window to create a new
    Angular application:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过从头开始创建一个新的 Angular 应用程序来启动我们的项目。在终端窗口中执行以下 Angular CLI 命令以创建一个新的 Angular
    应用程序：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We use the `ng new` command to create a new Angular application, passing the
    following options:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `ng new` 命令创建一个新的 Angular 应用程序，传递以下选项：
- en: '`my-blog`: The name of the Angular application that we want to create. The
    Angular CLI will create a `my-blog` folder in the path where we execute the command.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my-blog`: 我们想要创建的 Angular 应用程序的名称。Angular CLI 将在执行命令的路径中创建一个 `my-blog` 文件夹。'
- en: Every command that we run in the terminal window should be run inside this folder.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在终端窗口中运行的每个命令都应该在这个文件夹内执行。
- en: '`--routing`: Enables routing in the Angular application.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--routing`: 启用 Angular 应用程序中的路由功能。'
- en: '`--style=scss`: Configures the Angular application to use the SCSS stylesheet
    format when working with CSS styles.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--style=scss`: 配置 Angular 应用程序在处理 CSS 样式时使用 SCSS 样式表格式。'
- en: 'When we enable routing in an Angular application, the Angular CLI imports several
    artifacts from the **@angular/router** npm package in our application:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 Angular 应用程序中启用路由时，Angular CLI 将从 `@angular/router` npm 包中导入几个工件到我们的应用程序中：
- en: 'It creates the `app-routing.module.ts` file, which is the main routing module
    of our application:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了 `app-routing.module.ts` 文件，这是我们的应用程序的主要路由模块：
- en: '[PRE1]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It imports `AppRoutingModule` into the main module of our application, `app.module.ts`:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将 `AppRoutingModule` 导入我们的应用程序的主要模块 `app.module.ts`：
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We configured our application to use the SCSS stylesheet format. Instead of
    creating the styles of our application manually, we will use the **Bootstrap CSS**
    library:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置了我们的应用程序以使用 SCSS 样式表格式。我们不会手动创建应用程序的样式，而是将使用 **Bootstrap CSS** 库：
- en: 'Execute the following command in a terminal window to install Bootstrap:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端窗口中执行以下命令以安装 Bootstrap：
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding command, we use the `npm` executable to install the `bootstrap`
    package from the npm registry.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们使用 `npm` 可执行文件从 npm 注册表中安装 `bootstrap` 包。
- en: 'Add the following `import` statement at the top of the `styles.scss` file that
    exists in the `src` folder of our Angular application:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们 Angular 应用程序的 `src` 文件夹中存在的 `styles.scss` 文件顶部添加以下 `import` 语句：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the following section, we will learn how to create the basic layout of our
    blog by creating components, such as the header and the footer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将学习如何通过创建组件（如页眉和页脚）来创建我们博客的基本布局。
- en: Creating the basic layout of our blog
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们博客的基本布局
- en: A blog typically has a header containing all the primary website links and a
    footer containing copyright information and other useful links. In the world of
    Angular, both can be represented as separate components.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个博客通常包含一个包含所有主要网站链接的标题，以及一个包含版权信息和其他有用链接的页脚。在Angular的世界里，这两个都可以表示为单独的组件。
- en: 'The header component is used only once since it is added when our application
    starts up, and it is always rendered as the main menu of the website. In Angular,
    we typically create a module, named `core` by convention, to keep such components
    or services central to our application. To create the module, we use the `generate`
    command of the Angular CLI:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 标题组件仅使用一次，因为它在我们应用程序启动时添加，并且始终作为网站的主菜单进行渲染。在Angular中，我们通常创建一个名为`core`的模块，按照惯例，以保持此类组件或服务在我们的应用程序中的中心位置。要创建模块，我们使用Angular
    CLI的`generate`命令：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding command will create the module in the `src\app\core` folder of
    our application. To create the header component, we will use the same command,
    passing a different set of options:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将在我们的应用程序的`src\app\core`文件夹中创建模块。要创建标题组件，我们将使用相同的命令，传递不同的选项集：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The previous command will create all necessary component files inside the `src\app\core\header`
    folder. It will also declare `HeaderComponent` in the `core.module.ts` file and
    add it to the `exports` property so that other modules can use it:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将在`src\app\core\header`文件夹内创建所有必要的组件文件。它还会在`core.module.ts`文件中声明`HeaderComponent`，并将其添加到`exports`属性中，以便其他模块可以使用它：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The header component should display the main links of our blog. Open the `header.component.html`
    template file of the header component and replace its content with the following
    snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 标题组件应显示我们博客的主要链接。打开标题组件的`header.component.html`模板文件，并用以下片段替换其内容：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The footer component can be used more than once in an Angular application.
    Currently, we want to display it on the main page of our application. In the future,
    we may want to have it also on a login page that will be available for blog visitors.
    In such a case, the footer component should be reusable. When we want to group
    components that will be reused throughout our application, we typically create
    a module named **shared** by convention. Use the Angular CLI `generate` command
    to create the module:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 页脚组件可以在Angular应用程序中使用多次。目前，我们希望在应用程序的主页上显示它。在未来，我们可能还希望在可供博客访客使用的登录页上显示它。在这种情况下，页脚组件应该是可重用的。当我们想要将将在整个应用程序中重用的组件分组时，我们通常按照惯例创建一个名为**shared**的模块。使用Angular
    CLI的`generate`命令来创建模块：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The previous command will create the `shared` module in the `src\app\shared`
    folder. The footer component can now be created using the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将在`src\app\shared`文件夹中创建`shared`模块。现在，可以使用以下命令创建页脚组件：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The previous command will create all necessary files of the footer component
    inside the `src\app\shared\footer` folder. It will also add `FooterComponent`
    in the `declarations` and `exports` properties in the `shared.module.ts` file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将在`src\app\shared\footer`文件夹内创建页脚组件的所有必要文件。它还会在`shared.module.ts`文件的`declarations`和`exports`属性中添加`FooterComponent`：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The content of the footer component should contain copyright information about
    our blog.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 页脚组件的内容应包含关于我们博客的版权信息。
- en: 'Let’s see how to add this information to our component:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将此信息添加到我们的组件中：
- en: 'Open the `footer.component.ts` file, add a `currentDate` property in the `FooterComponent`
    class, and initialize it to a new `Date` object:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`footer.component.ts`文件，在`FooterComponent`类中添加一个`currentDate`属性，并将其初始化为一个新的`Date`对象：
- en: '[PRE13]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Open the `footer.component.html` template file of the footer component and
    replace its content with the following:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开页脚组件的`footer.component.html`模板文件，并用以下内容替换其内容：
- en: '[PRE14]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code uses interpolation to display the value of the `currentDate`
    property on the screen. It also uses the built-in `date` pipe to display only
    the year of the current date.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用插值来在屏幕上显示`currentDate`属性的值。它还使用内置的`date`管道来仅显示当前日期的年份。
- en: Pipes are a built-in feature of the Angular framework that apply transformations
    on the view representation of a component property. The underlying value of the
    property remains intact.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是Angular框架的内置功能，它对组件属性的可视表示形式应用转换。属性的底层值保持不变。
- en: 'We have already created the essential components of our blog. Now it is time
    to display them on the screen:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了博客的必要组件。现在，是时候在屏幕上显示它们了：
- en: 'Open the main module of the application, the `app.module.ts` file, and add
    `CoreModule` and `SharedModule` into the `imports` property of the `@NgModule`
    decorator:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开应用程序的主模块，即 `app.module.ts` 文件，并将 `CoreModule` 和 `SharedModule` 添加到 `@NgModule`
    装饰器的 `imports` 属性中：
- en: '[PRE15]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the appropriate `import` statements at the top of the file for each module:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件的顶部为每个模块添加适当的 `import` 语句：
- en: '[PRE16]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Open the `app.component.html` template file of the main component and replace
    its content with the following HTML snippet:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开主组件的 `app.component.html` 模板文件，并用以下 HTML 片段替换其内容：
- en: '[PRE17]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We added the header and the footer component in the preceding snippet by using
    their CSS selectors.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们通过使用它们的 CSS 选择器添加了标题和页脚组件。
- en: 'If we run the `serve` command of the Angular CLI to preview the application,
    we should get the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行 Angular CLI 的 `serve` 命令来预览应用程序，我们应该得到以下结果：
- en: '![Figure 2.2 – Basic layout](img/B18465_02_02.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 基本布局](img/B18465_02_02.png)'
- en: Figure 2.2 – Basic layout
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 基本布局
- en: We have already completed the basic layout of our blog application, and it looks
    great! But the header contains two additional links that we have not covered yet.
    We will learn how to use routing to activate those links in the following section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了我们博客应用程序的基本布局，看起来很棒！但是标题中包含两个我们尚未覆盖的额外链接。我们将在下一节中学习如何使用路由来激活这些链接。
- en: Configuring routing for our application
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的应用程序配置路由
- en: 'The header component that we created in the previous section contains two links:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一节中创建的标题组件包含两个链接：
- en: '**Articles**: Displays a list of blog articles'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文章**: 显示博客文章列表'
- en: '**Contact**: Displays personal information about the blog owner'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**联系**: 显示博客所有者的个人信息'
- en: The previous links will also become the main features of our application. So,
    we need to create an Angular module for each one.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的链接也将成为我们应用程序的主要功能。因此，我们需要为每个功能创建一个 Angular 模块。
- en: When you design your website and need to decide upon the Angular modules that
    you will use, check out the main menu of the website. Each link of the menu should
    be a different feature and, thus, a different Angular module.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设计你的网站并需要决定将使用哪些 Angular 模块时，查看网站的主菜单。菜单中的每个链接都应该是一个不同的功能，因此是一个不同的 Angular
    模块。
- en: By convention, Angular modules that contain functionality for a specific feature
    are called **feature modules**.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，包含特定功能功能的 Angular 模块被称为 **功能模块**。
- en: Creating the contact page
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建联系页面
- en: 'Let’s begin by creating our contact feature:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建我们的联系功能开始：
- en: 'Create a module that will be the home for our contact feature:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将成为我们联系功能家的模块：
- en: '[PRE18]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a component that will be the main component of the `contact` module:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将成为 `contact` 模块主要组件的组件：
- en: '[PRE19]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We pass the `--flat` option to the `generate` command so that the Angular CLI
    will not create a separate folder for our component, as in previous cases. The
    `contact` component will be the only component in our module, so there is no point
    in having it separately.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将 `--flat` 选项传递给 `generate` 命令，这样 Angular CLI 就不会为我们的组件创建一个单独的文件夹，就像之前的例子一样。由于
    `contact` 组件将是我们的模块中唯一的组件，所以没有必要单独创建它。
- en: 'Open the `contact.component.html` file and add the following HTML content:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `contact.component.html` 文件并添加以下 HTML 内容：
- en: '[PRE20]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, we used the `angular.png` image, which you can find in
    the `src\assets` folder of the project from the accompanying GitHub repository.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了 `angular.png` 图像，你可以在随附的 GitHub 仓库项目的 `src\assets` 文件夹中找到它。
- en: The `assets` folder in an Angular CLI project is used for static content such
    as images, fonts, or JSON files.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI 项目的 `assets` 文件夹用于静态内容，如图像、字体或 JSON 文件。
- en: 'We have already created our contact feature. The next step is to add it to
    the main page of our Angular application:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了我们的联系功能。下一步是将它添加到我们的 Angular 应用程序的主页上：
- en: 'Open the `app-routing.module.ts` file and add a new route configuration object
    in the `routes` property:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app-routing.module.ts` 文件，并在 `routes` 属性中添加一个新的路由配置对象：
- en: '[PRE21]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code indicates that when the URL of the browser points to the
    `contact` path, our application will activate and display `ContactComponent` on
    the screen. The `routes` property of a routing module contains the routing configuration
    of the respective feature module. It is an array of route configuration objects
    where each one defines the component class and the URL path that activates it.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码表明，当浏览器的URL指向`contact`路径时，我们的应用程序将激活并在屏幕上显示`ContactComponent`。路由模块的`routes`属性包含相应功能模块的路由配置。它是一个路由配置对象数组，其中每个对象定义了组件类和激活它的URL路径。
- en: 'Add `ContactModule` in the `imports` array of the `@NgModule` decorator of
    `AppModule` to be able to use it:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppModule`的`@NgModule`装饰器的`imports`数组中添加`ContactModule`，以便能够使用它：
- en: '[PRE22]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Do not forget to add the respective `import` statement for `ContactModule` at
    the top of the file.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要忘记在文件顶部添加对`ContactModule`的相应`import`语句。
- en: 'Routed components, just like `ContactComponent`, need a place where they can
    be loaded. Open the `app.component.html` file and add the `<router-outlet>` directive:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由组件，就像`ContactComponent`一样，需要一个可以加载的地方。打开`app.component.html`文件，并添加`<router-outlet>`指令：
- en: '[PRE23]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we need to wire up the route configuration that we created with the actual
    link on the header component:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将我们创建的路由配置与页眉组件的实际链接连接起来：
- en: 'Open the `header.component.html` file and add the `routerLink` directive to
    the respective anchor HTML element:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`header.component.html`文件，并将`routerLink`指令添加到相应的锚HTML元素中：
- en: '[PRE24]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that the value of the `routerLink` directive contains a leading `/`,
    whereas the `path` property of the route configuration object that we defined
    does not. According to the case, omitting the `/` would give a different meaning
    to the route.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`routerLink`指令的值包含一个前导`/`，而我们所定义的路由配置对象的`path`属性则没有。根据情况，省略`/`会给路由带来不同的含义。
- en: 'The `routerLink` and `routerLinkActive` directives are part of the Angular
    Router package. We need to import `RouterModule` in the `core.module.ts` file
    to use them:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`routerLink`和`routerLinkActive`指令是Angular Router包的一部分。我们需要在`core.module.ts`文件中导入`RouterModule`才能使用它们：'
- en: '[PRE26]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We are now ready to preview our new contact page! If we run the application
    using `ng serve` and click on the **Contact** link, we should see the following
    output:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好预览我们新的联系页面！如果我们使用`ng serve`运行应用程序并点击**联系**链接，我们应该看到以下输出：
- en: '![Εικόνα που περιέχει κείμενο, λογότυπο, γραμματοσειρά, στιγμιότυπο οθόνης  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B18465_02_03.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、徽标、字体、屏幕截图的图片，自动生成的描述](img/B18465_02_03.png)'
- en: Figure 2.3 – Contact page
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 联系页面
- en: In the following section, we will build the functionality for the **Articles**
    link of the header in our blog.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将构建我们博客页眉中**文章**链接的功能。
- en: Adding the articles page
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加文章页面
- en: 'The feature that is responsible for displaying articles in our blog will be
    the `articles` module. It will also be the module that connects the dots between
    Angular and Scully. We will use the `generate` command of the Angular CLI to create
    that module:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 负责在我们博客中显示文章的功能将是`articles`模块。它也将是连接Angular和Scully之间的模块。我们将使用Angular CLI的`generate`命令来创建该模块：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the previous command, we pass some additional routing options:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的命令中，我们传递了一些额外的路由选项：
- en: '`--route`: Defines the URL path of our feature'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--route`：定义我们功能的URL路径'
- en: '`--module`: Indicates the routing module that will define the route configuration
    object that activates our feature'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--module`：指示将定义激活我们功能的路由配置对象的路由模块'
- en: 'The Angular CLI performs additional actions, instead of just creating the module,
    upon executing the command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行命令时，Angular CLI执行了额外的操作，而不仅仅是创建模块：
- en: It creates a routed component in the `src\app\articles` folder that will be
    activated by default from a route navigation object. It is the landing page of
    our feature, and it will display a list of blog posts, as we will see in the *Displaying
    blog data on the home page* section.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在`src\app\articles`文件夹中创建了一个路由组件，该组件将默认由路由导航对象激活。它是我们功能的着陆页，并将显示博客文章列表，正如我们将在*在主页上显示博客数据*部分中看到的那样。
- en: It creates a routing module named `articles-routing.module.ts` that contains
    the routing configuration of our module.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了一个名为`articles-routing.module.ts`的路由模块，其中包含我们模块的路由配置。
- en: It adds a new route configuration object in the route configuration of the main
    application module that activates our module.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主应用模块的路由配置中添加了一个新的路由配置对象，该对象激活了我们的模块。
- en: 'The `articles-routing.module.ts` file contains the routing configuration for
    the `articles` module:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`articles-routing.module.ts`文件包含`articles`模块的路由配置：'
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It imports `RouterModule` using the `forChild` method to pass the routing configuration
    to the Angular router. If we take a look at the main routing module of the application,
    we will see that it follows a slightly different approach:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用`forChild`方法导入`RouterModule`，将路由配置传递给Angular路由器。如果我们查看应用程序的主路由模块，我们会看到它采用了一种略有不同的方法：
- en: '`app-routing.module.ts`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`app-routing.module.ts`'
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `forChild` method is used in feature modules, whereas the `forRoot` method
    should be used *only* in the main application module.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能模块中使用`forChild`方法，而`forRoot`方法应仅在主应用程序模块中使用*仅此而已*。
- en: The route configuration of the `articles` module contains only one route that
    activates `ArticlesComponent`. The path of the route is set to an empty string
    to indicate that it is the default route of the routing module. It essentially
    means that `ArticlesComponent` will be activated whenever that module is loaded.
    But how is the `articles` module loaded in our application?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`articles`模块的路由配置只包含一个激活`ArticlesComponent`的路由。该路由的路径设置为空字符串，以表示它是路由模块的默认路由。这实际上意味着每当该模块被加载时，`ArticlesComponent`将被激活。但我们的应用程序是如何加载`articles`模块的呢？'
- en: The second route of the main routing module contains a route configuration object
    that does not activate a component but rather a module. It uses the `loadChildren`
    method to load `ArticlesModule` dynamically when navigation triggers the `articles`
    path.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 主路由模块的第二路由包含一个路由配置对象，该对象不激活组件而是激活一个模块。它使用`loadChildren`方法在导航触发`articles`路径时动态加载`ArticlesModule`。
- en: The `import` function in the `loadChildren` property accepts the relative path
    of the TypeScript module file without the extension.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadChildren`属性的`import`函数接受TypeScript模块文件的相对路径，不包括扩展名。'
- en: 'The previous approach is called **lazy loading** and improves the startup and
    the overall performance of an Angular application. It creates a separate bundle
    for each lazy-loaded module, which is loaded upon request, reducing the final
    bundle size and the memory consumption of your application. Let’s wire up the
    new route to our header component:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的方法称为**懒加载**，它提高了Angular应用程序的启动和整体性能。它为每个懒加载的模块创建一个单独的包，在请求时加载，减少了最终包的大小和应用程序的内存消耗。让我们将新路由连接到我们的标题组件：
- en: 'Open the `header.component.html` file and add the following `routerLink` and
    `routerLinkActive` directives to the `Articles` anchor HTML element:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`header.component.html`文件，并将以下`routerLink`和`routerLinkActive`指令添加到`Articles`锚点HTML元素中：
- en: '[PRE30]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Run `ng serve` and use your favorite browser to preview your application.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ng serve`并使用您喜欢的浏览器预览您的应用程序。
- en: 'Open the developer tools of your browser, click on the **Articles** link, and
    inspect the **Network** tab:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您浏览器的开发者工具，点击**Articles**链接，并检查**网络**选项卡：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, αριθμός, λογισμικό  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B18465_02_04.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、屏幕截图、编号、软件的图片自动生成的描述](img/B18465_02_04.png)'
- en: Figure 2.4 – Lazy loading Angular module
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 懒加载Angular模块
- en: Among other requests, you should see one named `src_app_articles_articles_module_ts.js`.
    It is the bundle of the lazy-loaded articles module that was loaded when you clicked
    on the **Articles** link.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他请求中，你应该看到一个名为`src_app_articles_articles_module_ts.js`的请求。这是当你点击**Articles**链接时加载的懒加载文章模块的包。
- en: We are now ready to convert our amazing Angular application into a professional
    blog website.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好将我们的出色Angular应用程序转换成一个专业的博客网站。
- en: 'Before we move on, let’s add some additional routes to the `app-routing.module.ts`
    file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们向`app-routing.module.ts`文件添加一些额外的路由：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We added a default route to automatically redirect our blog users to the `articles`
    path upon visiting the blog. Additionally, we created a new route configuration
    object with its path set to `**` that also navigates to the `articles` path. The
    `**` syntax is called the **wildcard** route, and it is triggered when the router
    cannot match a requested URL with a defined route.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个默认路由，在访问博客时自动将博客用户重定向到`articles`路径。此外，我们还创建了一个新的路由配置对象，其路径设置为`**`，它也会导航到`articles`路径。`**`语法称为**通配符**路由，当路由器无法将请求的URL与定义的路由匹配时，它会被触发。
- en: Define the most specific routes first and then add any generic ones, such as
    the default and the wildcard routes. The Angular router parses the route configuration
    in the order that we define and follows a first-match-wins strategy to select
    one.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义最具体的路由，然后添加任何通用的路由，例如默认路由和通配符路由。Angular 路由器按照我们定义的顺序解析路由配置，并遵循“首次匹配即获胜”的策略来选择一个。
- en: We have already enabled and configured routing in our Angular application. In
    the following section, we will establish the infrastructure needed to add blogging
    capabilities to our application.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 Angular 应用程序中启用了并配置了路由。在下一节中，我们将建立添加博客功能所需的基础设施。
- en: Adding blog capabilities with Scully
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Scully 添加博客功能
- en: Our application currently does not have any specific logic regarding blog posts.
    It is a typical Angular application that uses routing. However, by adding a routing
    configuration, we have established the foundation for adding blog support using
    Scully.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序目前还没有关于博客文章的任何特定逻辑。它是一个典型的 Angular 应用程序，使用路由。然而，通过添加路由配置，我们已经为使用 Scully
    添加博客支持奠定了基础。
- en: Scully needs at least one route defined in an Angular application to work correctly.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Scully 至少需要在 Angular 应用程序中定义一个路由才能正确工作。
- en: First, we need to install Scully in our application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的应用程序中安装 Scully。
- en: Installing the Scully library
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Scully 库
- en: 'We will use the `install` command of the npm CLI to install Scully in our Angular
    application:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 npm CLI 的 `install` 命令在我们的 Angular 应用程序中安装 Scully：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding command downloads and installs all the necessary npm packages
    for Scully to work correctly in our Angular application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令下载并安装了 Scully 在我们的 Angular 应用程序中正确工作所需的所有必要的 npm 包。
- en: The Scully library is not fully compatible with Angular 16, as of this writing.
    In the preceding command we use the `--force` option to ignore any warnings that
    come from the Angular version incompatibility.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Scully 库与 Angular 16 不完全兼容，截至本文撰写时为止。在上一个命令中，我们使用了 `--force` 选项来忽略来自 Angular
    版本不兼容的任何警告。
- en: 'Open the `app.module.ts` file and import `ScullyLibModule`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `app.module.ts` 文件并导入 `ScullyLibModule`：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`ScullyLibModule` is the main module of the Scully library; it contains various
    Angular services and directives that Scully will need.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScullyLibModule` 是 Scully 库的主要模块；它包含 Scully 需要的各种 Angular 服务和指令。'
- en: 'Create a configuration file for the Scully library in the root folder of the
    Angular CLI workspace with the following contents:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular CLI 工作区的根目录中为 Scully 库创建一个配置文件，内容如下：
- en: '`scully.my-blog.config.ts`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`scully.my-blog.config.ts`'
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The configuration file contains information about our Angular application that
    Scully will need along the way:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件包含 Scully 在过程中需要了解的关于我们的 Angular 应用程序的信息：
- en: '`projectRoot`: The path containing the source code of the Angular application'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`projectRoot`：包含 Angular 应用程序源代码的路径'
- en: '`projectName`: The name of the Angular application'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`projectName`：Angular 应用程序的名称'
- en: '`outDir`: The output path of the Scully-generated files'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`outDir`：Scully 生成的文件输出路径'
- en: The Scully output path must be different from the path that the Angular CLI
    outputs for the bundle of your Angular application. The latter can be configured
    in the `angular.json` file.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Scully 的输出路径必须与 Angular CLI 为您的 Angular 应用程序捆绑输出的路径不同。后者可以在 `angular.json` 文件中配置。
- en: '`routes`: It contains the route configuration that will be used for accessing
    our blog posts. Scully will populate it automatically, as we will see in the following
    section.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routes`：它包含用于访问我们的博客文章的路由配置。Scully 将自动填充它，正如我们将在下一节中看到的。'
- en: Since we have installed Scully successfully in our Angular application, we can
    now configure it to initialize our blog.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经成功地在 Angular 应用程序中安装了 Scully，我们现在可以配置它来初始化我们的博客。
- en: Initializing our blog page
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化我们的博客页面
- en: 'Scully provides a specific Angular CLI schematic for initializing an Angular
    application, such as a blog, by using Markdown (.md) files:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Scully 为初始化 Angular 应用程序（如博客）提供了一个特定的 Angular CLI 模板，通过使用 Markdown (.md) 文件：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The previous command will start the configuration process of our blog by going
    through a list of questions (default values are shown inside parentheses):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将通过一系列问题（括号内显示默认值）启动博客的配置过程：
- en: 'Type `posts` as the name of the blog module:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将博客模块的名称输入为 `posts`：
- en: '[PRE36]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will create a new Angular module named `posts`.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建一个名为 `posts` 的新 Angular 模块。
- en: 'Leave the slug choice empty, and press *Enter* to accept the default value:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 留空 slug 选择，并按 *Enter* 键接受默认值：
- en: '[PRE37]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The slug is a unique identifier for each post, and it is defined in the route
    configuration object of the module.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: slug 是每篇帖子的唯一标识符，它在模块的路由配置对象中定义。
- en: 'Enter `mdfiles` as the path that Scully will use to store our actual blog post
    files:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路径设置为 `mdfiles`，这是 Scully 将用于存储我们的实际博客文章文件的位置：
- en: '[PRE38]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will create an `mdfiles` folder inside the root path of our Angular CLI
    project. By default, it will also create a blog post for our convenience. We will
    learn how to create our own in the *Displaying blog data on the home page* section.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在我们的 Angular CLI 项目的根路径内创建一个 `mdfiles` 文件夹。默认情况下，它还会为了我们的方便创建一篇博客文章。我们将在 *在主页上显示博客数据*
    这一部分学习如何创建自己的。
- en: 'Type `posts` as the name of the route for accessing our blog posts:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路由名称设置为 `posts` 以访问我们的博客文章：
- en: '[PRE39]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The name of the route is the `path` property of the route configuration object
    that will be created.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 路由的名称是创建的路由配置对象的 `path` 属性。
- en: 'Scully performs various actions upon executing the preceding commands, including
    the creation of the routing configuration of the `posts` module:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Scully 在执行前面的命令时执行各种操作，包括创建 `posts` 模块的路由配置：
- en: '`posts-routing.module.ts`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`posts-routing.module.ts`'
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `path` property for the first route is set to `:id` and activates `PostsComponent`.
    The colon character indicates that `id` is a route parameter. The `id` parameter
    is related to the `slug` property defined earlier in the Scully configuration.
    Scully works by creating one route for each blog post that we create. It uses
    the route configuration of the `posts` module and the main application module
    to build the `routes` property in the Scully configuration file:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条路由的 `path` 属性设置为 `:id` 并激活 `PostsComponent`。冒号字符表示 `id` 是一个路由参数。`id` 参数与
    Scully 配置中早先定义的 `slug` 属性相关。Scully 通过为每篇我们创建的博客文章创建一个路由来工作。它使用 `posts` 模块的路线配置和主应用程序模块来构建
    Scully 配置文件中的 `routes` 属性：
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`PostsComponent` is the Angular component that is used to render the details
    of each blog post. The template file of the component can be further customized
    according to your needs:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostsComponent` 是一个 Angular 组件，用于渲染每篇博客的详细信息。根据您的需求，组件的模板文件可以进一步自定义：'
- en: '`posts.component.html`'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`posts.component.html`'
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can customize all content in the previous template file except the `<scully-content></scully-content>`
    line, which is used internally by Scully.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自定义除 `<scully-content></scully-content>` 行之外的前一个模板文件中的所有内容，该行是 Scully 内部使用的。
- en: At this point, we have completed the installation and configuration of Scully
    in our Angular application. It is now time for the final part of the project!
    In the next section, we will get Angular and Scully to cooperate and display blog
    posts in our Angular application.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了 Scully 在我们的 Angular 应用程序中的安装和配置。现在是项目的最后一部分！在下一节中，我们将让 Angular
    和 Scully 合作，并在我们的 Angular 应用程序中显示博客文章。
- en: Displaying blog posts on the home page
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在主页上显示博客文章
- en: 'We would like our users to see the list of available blog posts as soon as
    they land on our blog website. According to the default route path that we have
    defined, `ArticlesComponent` is the landing page of our blog. Scully provides
    `ScullyRoutesService`, an Angular service that we can use in our components to
    get information about the routes that it will create according to the blog posts.
    Let’s put this service into action on our landing page:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望用户一登录我们的博客网站就能看到可用的博客文章列表。根据我们定义的默认路由路径，`ArticlesComponent` 是我们博客的着陆页。Scully
    提供了 `ScullyRoutesService`，这是一个 Angular 服务，我们可以在我们的组件中使用它来获取关于它将根据博客文章创建的路由的信息。让我们在我们的着陆页上使用这个服务：
- en: 'Open the `articles.component.ts` file and modify the `import` statements as
    follows:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `articles.component.ts` 文件，并按如下修改 `import` 语句：
- en: '[PRE43]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add the `OnInit` interface to the list of implemented interfaces of the `ArticlesComponent`
    class:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `OnInit` 接口添加到 `ArticlesComponent` 类实现的接口列表中：
- en: '[PRE44]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Inject `ScullyRoutesService` in the `constructor` of the `ArticlesComponent`
    class:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ArticlesComponent` 类的 `constructor` 中注入 `ScullyRoutesService`：
- en: '[PRE45]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create the following component property:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下组件属性：
- en: '[PRE46]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Implement the `ngOnInit` method:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `ngOnInit` 方法：
- en: '[PRE47]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Open the `articles.component.html` file and add the following HTML code:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `articles.component.html` 文件并添加以下 HTML 代码：
- en: '[PRE48]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: There are many Angular techniques involved in the previous steps, so let’s break
    them down piece by piece.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中涉及了许多 Angular 技巧，所以让我们一点一点地分解它们。
- en: When we want to use an Angular service in a component, we just need to ask for
    it from the Angular framework. How? By adding it as a property in the `constructor`
    of the component. The component does not need to know anything about how the service
    is implemented.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想在组件中使用 Angular 服务时，我们只需从 Angular 框架中请求它。如何？通过将其添加到组件的 `constructor` 中的属性。组件不需要了解服务是如何实现的。
- en: The `ngOnInit` method is part of the `OnInit` interface, which is implemented
    by our component. It is called by the Angular framework when a component is initialized
    and provides us with a hook to add custom logic to be executed.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngOnInit` 方法是 `OnInit` 接口的一部分，该接口由我们的组件实现。当 Angular 框架初始化组件时，它会被调用，并为我们提供了一个钩子来添加要执行的定制逻辑。'
- en: Angular services that provide initialization logic to a component should be
    called inside the `ngOnInit` method and not in the `constructor` because it is
    easier to provide mocks about those services when unit testing the component.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为组件提供初始化逻辑的 Angular 服务应该在 `ngOnInit` 方法中调用，而不是在 `constructor` 中，因为当对组件进行单元测试时，提供这些服务的模拟更容易。
- en: The `available$` property of `ScullyRoutesService` is called an **observable**
    and returns all the available routes that were generated from Scully when we subscribe
    to it. To avoid displaying routes other than those related to blog posts, such
    as the `contact` route, we filter out the results from the `available$` property.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScullyRoutesService` 的 `available$` 属性被称为 **可观察对象**，当订阅它时返回所有由 Scully 生成的可用路由。为了避免显示与博客文章无关的路由，例如
    `contact` 路由，我们从 `available$` 属性中过滤掉结果。'
- en: In the component template, we use the `*ngFor` Angular built-in directive and
    the `async` pipe to subscribe to the `posts$` observable inside HTML. We can then
    access each item using the `post` template reference variable and use interpolation
    to display `title` and `description`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件模板中，我们使用 Angular 内置的 `*ngFor` 指令和 `async` 管道来订阅 HTML 中的 `posts$` 可观察对象。然后我们可以使用
    `post` 模板引用变量访问每个项目，并使用插值来显示 `title` 和 `description`。
- en: Finally, we add a `routerLink` directive to each anchor element to navigate
    to the respective blog post when clicked. Notice that `routerLink` is surrounded
    by `[]`. The `[]` syntax is called **property binding**, and we use it when we
    want to bind the property of an HTML element to a variable. In our case, we bind
    the `routerLink` directive to the `route` property of the `post` variable.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为每个锚点元素添加一个 `routerLink` 指令，以便在点击时导航到相应的博客文章。注意，`routerLink` 被括号 `[]` 包围。这种括号语法称为
    **属性绑定**，我们使用它来将 HTML 元素的属性绑定到一个变量。在我们的情况下，我们将 `routerLink` 指令绑定到 `post` 变量的 `route`
    属性。
- en: 'Now that we have finally completed all the pieces of the puzzle, we can see
    our blog website in action:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于完成了拼图的每一块，我们可以看到我们的博客网站正在运行：
- en: 'Run the `build` command of the Angular CLI to build our Angular application:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Angular CLI 的 `build` 命令来构建我们的 Angular 应用程序：
- en: '[PRE49]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Execute the following command to build Scully and generate our blog routes:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令来构建 Scully 并生成我们的博客路由：
- en: '[PRE50]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The preceding command will create a `scully-routes.json` file inside the `src\assets`
    folder. It contains the routes of our Angular application and is needed by the
    Scully runtime.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述命令将在 `src\assets` 文件夹中创建一个 `scully-routes.json` 文件。它包含我们的 Angular 应用程序的路由，并且是
    Scully 运行时所需的。
- en: Running the Scully executable for the first time will prompt you to collect
    anonymous errors to improve its services.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首次运行 Scully 可执行文件时，会提示您收集匿名错误以改进其服务。
- en: 'Run the following command to serve our blog:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来提供我们的博客：
- en: '[PRE51]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The preceding command will start two web servers: one that contains the static
    prerendered version of our website built using Scully and another that is the
    Angular live version of our application:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将启动两个网络服务器：一个包含使用 Scully 构建的网站的静态预渲染版本，另一个是应用程序的 Angular 实时版本：
- en: '![](img/B18465_02_05.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18465_02_05.png)'
- en: Figure 2.5 – Serving our application
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 服务器上的我们的应用程序
- en: 'If we open our browser and navigate to `http://localhost:1668`, we will not
    see any blog posts. A blog post created with Scully is not returned in the `available$`
    property of `ScullyRoutesService` *unless* we publish it. To publish a blog post,
    we do the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开浏览器并导航到 `http://localhost:1668`，我们将看不到任何博客文章。使用 Scully 创建的博客文章不会在 `ScullyRoutesService`
    的 `available$` 属性中返回，*除非*我们发布它。要发布博客文章，我们执行以下操作：
- en: 'Navigate to the `mdfiles` folder that Scully created and open the only `.md`
    file that you will find. The name and contents may vary for your file because
    it is based on the date Scully created it:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 Scully 创建的 `mdfiles` 文件夹并打开你找到的唯一 `.md` 文件。该文件名和内容可能因 Scully 创建它的日期而异：
- en: '[PRE52]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Scully has defined a set of properties between the closing and ending `---`
    lines at the top of the file representing metadata about the blog post. You can
    also add your own as key-value pairs.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Scully 在文件顶部关闭和结束 `---` 行之间定义了一组属性，代表关于博客文章的元数据。您也可以添加自己的作为键值对。
- en: 'Delete the `slugs` property and set the `published` property to `true`:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `slugs` 属性并将 `published` 属性设置为 `true`：
- en: '[PRE53]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Run the following command to force Scully to regenerate the routes of our application:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以强制 Scully 重新生成我们应用的路线：
- en: '[PRE54]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We need to execute the previous command *every time* we make a change in our
    blog-related files.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要每次在博客相关文件中做出更改时都执行前面的命令。
- en: Execute the `npx scully serve --project my-blog` command and navigate to preview
    the generated website.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `npx scully serve --project my-blog` 命令并导航到预览生成的网站。
- en: 'We can now see one blog post, the default one that was created when we installed
    Scully. Let’s create another one:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到一篇博客文章，这是当我们安装 Scully 时创建的默认文章。让我们再创建一篇：
- en: 'Run the following `generate` command of the Angular CLI:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下 Angular CLI 的 `generate` 命令：
- en: '[PRE55]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding command, we use the `@scullyio/init:post` schematic, passing
    the name of the post that we want to create as an option.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们使用 `@scullyio/init:post` 规范，传递我们想要创建的文章的名称作为选项。
- en: 'Set the target folder for the new blog post to `mdfiles`:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新博客文章的目标文件夹设置为 `mdfiles`：
- en: '[PRE56]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Scully will create a Markdown file named `angular-and-scully.md` inside the
    specified folder. Open that file and update its content to be the same as the
    following:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Scully 将在指定的文件夹内创建一个名为 `angular-and-scully.md` 的 Markdown 文件。打开该文件并更新其内容，使其与以下内容相同：
- en: '[PRE57]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Run `npx scully --project my-blog` to create a route for the newly created blog
    post. Scully will also update the `scully-routes.json` file with the new route.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `npx scully --project my-blog` 以为新建的博客文章创建一个路由。Scully 还会更新 `scully-routes.json`
    文件以包含新的路由。
- en: 'If we preview our application now, it should look like the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在预览我们的应用，它应该看起来像以下这样：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, γραμμή  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B18465_02_06.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、屏幕截图、字体、行，自动生成的描述](img/B18465_02_06.png)'
- en: Figure 2.6 – List of blog posts
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 博客文章列表
- en: 'If we click on one of the blog items, we will navigate to the selected blog
    post. The content that is currently shown on the screen is a prerendered version
    of the blog post route:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击其中一个博客条目，我们将导航到所选的博客文章。当前屏幕上显示的内容是博客文章路由的预渲染版本：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B18465_02_07.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、屏幕截图、字体，自动生成的描述](img/B18465_02_07.png)'
- en: Figure 2.7 – Blog post details
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 博客文章详情
- en: 'To verify that, navigate to the `dist` folder of your Angular project, where
    you will find two folders:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这一点，导航到你的 Angular 项目的 `dist` 文件夹，在那里你会找到两个文件夹：
- en: '`my-blog`: This contains the Angular live version of our application. When
    we execute the `ng build` Angular CLI command, it builds our application and outputs
    bundle files in this folder.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my-blog`: 这包含了我们应用的 Angular 实时版本。当我们执行 `ng build` Angular CLI 命令时，它会构建我们的应用并将捆绑文件输出到这个文件夹中。'
- en: '`static`: This contains a prerendered version of our Angular application generated
    from Scully when we run the `npx scully --project my-blog` command.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static`: 这包含了一个由 Scully 生成的 Angular 应用程序的预渲染版本，当我们运行 `npx scully --project
    my-blog` 命令时。'
- en: If we navigate to the `static` folder, we will see that Scully has created one
    folder for each route of our Angular application. Each folder contains an `index.html`
    file, which represents the component that is activated from that route.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们导航到 `static` 文件夹，我们会看到 Scully 为我们的 Angular 应用程序的每个路由创建了一个文件夹。每个文件夹都包含一个
    `index.html` 文件，它代表了从该路由激活的组件。
- en: The contents of the `index.html` file are auto-generated by Scully, and behave
    as if we run our application live and navigate to that component.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html` 文件的内容是由 Scully 自动生成的，并且表现得好像我们正在实时运行我们的应用并导航到该组件。'
- en: Now you can take your Angular application, upload it to the CDN or web server
    of your choice, and you will have your blog ready in no time! All you will have
    to do then will be to exercise your writing skills to create excellent blog content.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以将您的Angular应用程序上传到您选择的CDN或Web服务器，您的博客将立即准备好！接下来，您只需练习您的写作技巧，以创建优秀的博客内容。
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned how to combine the Angular framework with the Scully
    library to create a personal blog.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将Angular框架与Scully库结合使用来创建个人博客。
- en: We saw how Angular uses the built-in router package to enhance web applications
    with in-app navigation. We also learned how to organize an Angular application
    into modules and how to navigate through these.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了Angular如何使用内置的路由包来增强Web应用程序的内部导航。我们还学习了如何将Angular应用程序组织成模块以及如何在这些模块间导航。
- en: We introduced Jamstack to our Angular application using the Scully library and
    saw how easy it is to convert our application into a prerendered blog. We used
    the Scully interface to create some blog posts and display them on the screen.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Scully库将Jamstack引入到我们的Angular应用程序中，并看到了如何轻松地将我们的应用程序转换为预渲染的博客。我们使用Scully界面创建了一些博客文章并在屏幕上显示它们。
- en: In the following chapter, we will investigate another exciting feature of the
    Angular framework, forms. We are going to learn how to use them and build an issue-tracking
    system.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Angular框架的另一个令人兴奋的特性——表单。我们将学习如何使用它们并构建一个问题跟踪系统。
- en: Practice questions
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践问题
- en: 'Let’s take a look at a few practice questions:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个实践问题：
- en: Which library do we use for routing in an Angular application?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在Angular应用程序中使用哪个库进行路由？
- en: How do we add routing capabilities in an HTML anchor element?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在HTML锚点元素中添加路由功能？
- en: Which Angular pipe do we use for date formatting?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用哪个Angular管道进行日期格式化？
- en: What is the purpose of the `assets` folder in an Angular CLI application?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Angular CLI应用程序中的`assets`文件夹的目的是什么？
- en: Which route property do we use for lazily loading a module?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用哪个路由属性来实现模块的懒加载？
- en: Which npm CLI command do we use for installing Scully?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用哪个npm CLI命令来安装Scully？
- en: Which service do we use for fetching Scully routes?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用哪个服务来获取Scully路由？
- en: What is property binding?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性绑定是什么？
- en: Which Angular directive do we use for iterating over an array in HTML?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在HTML中使用哪个Angular指令来遍历数组？
- en: What is the difference between a standard Angular application and a Scully one?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准Angular应用程序与Scully应用程序之间的区别是什么？
- en: Further reading
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are some links to build upon what we learned in this chapter:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些链接，可以帮助我们巩固本章所学的内容：
- en: 'Angular routing: [https://angular.io/guide/router](https://angular.io/guide/router)'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular路由：[https://angular.io/guide/router](https://angular.io/guide/router)
- en: 'Angular feature modules: [https://angular.io/guide/module-types](https://angular.io/guide/module-types)'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular功能模块：[https://angular.io/guide/module-types](https://angular.io/guide/module-types)
- en: 'Lazy loading modules: [https://angular.io/guide/lazy-loading-ngmodules](https://angular.io/guide/lazy-loading-ngmodules)'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载模块：[https://angular.io/guide/lazy-loading-ngmodules](https://angular.io/guide/lazy-loading-ngmodules)
- en: 'Angular built-in pipes: [https://angular.io/api?type=pipe](https://angular.io/api?type=pipe)'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular内置管道：[https://angular.io/api?type=pipe](https://angular.io/api?type=pipe)
- en: 'Bootstrap CSS: [https://getbootstrap.com](https://getbootstrap.com)'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bootstrap CSS：[https://getbootstrap.com](https://getbootstrap.com)
- en: 'Jamstack: [https://jamstack.org](https://jamstack.org)'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jamstack：[https://jamstack.org](https://jamstack.org)
- en: 'Scully: [https://scully.io](https://scully.io)'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scully：[https://scully.io](https://scully.io)
- en: 'Mastering Markdown: [https://guides.github.com/features/mastering-markdown](https://guides.github.com/features/mastering-markdown)'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握Markdown：[https://guides.github.com/features/mastering-markdown](https://guides.github.com/features/mastering-markdown)
