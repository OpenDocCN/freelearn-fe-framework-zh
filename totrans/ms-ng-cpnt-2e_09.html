<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Spaceship Dashboard</h1>
                </header>
            
            <article>
                
<p>When I was a child, I loved to play spaceship pilot. I piled up old carton boxes and decorated the interiors to look like a spaceship cockpit. With a marker, I drew a spaceship dashboard on the inside of the boxes, and I remember playing in there for hours.</p>
<p>The thing that's special about the design of cockpits and spaceship dashboard is that they need to provide an overview and control over the whole spaceship, in very limited space. I think the same applies to application dashboards. A dashboard should provide the user with an overview and a sense of the overall status of what's going on.</p>
<p>In this chapter, we will create such a dashboard for our task management application. We will make use of the open source charting library Chartist to create good looking, responsive charts and provide an overview of open tasks and project statuses:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/926c564d-4442-4162-9cce-752159eb7aff.png" style=""/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">A preview of the tasks chart that we will build in this chapter</div>
<p>On a higher level, we will create the following components in this chapter:</p>
<ul>
<li><strong>Project summary</strong>: This is the project summary that will provide a quick insight into the overall project status. By aggregating the efforts of all tasks in a project, we can provide a nice overall effort status, for which we have created the components in the previous chapter.</li>
<li><strong>Project activity chart</strong>: Without any labels or scales, this bar chart will give a quick sense of the activity on projects in the last 24 hours.</li>
<li><strong>Project tasks chart</strong>: This chart will provide an overview of the task progress on projects. Using a line chart, we will display the count of open tasks over a certain time period. Using the toggle component that we created in <a href="11f96942-6e99-46c5-b152-1af3b2579d44.xhtml"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Ready, Set, Go!</em>, we'll provide an easy way for the user to switch the timeframe displayed on the chart.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to Chartist</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will create some components that will render charts, and we should look for some help in rendering them. Of course, we can follow a similar approach to what we used in <a href="2ba38f09-ef9f-4aee-952f-3ade56c99356.xhtml"><span class="ChapterrefPACKT">Chapter 6</span></a>, <em>Keeping up with Activities</em>, when we drew our activity timeline. However, when it comes to more complex data visualization, it's better to rely on a library to do the heavy lifting.</p>
<p>It shouldn't be a surprise that we'll use a library called Chartist to fill this gap, because I've spent almost two years writing it. As the author of Chartist, I feel very lucky that we've found a perfect spot in this book to make use of it.</p>
<p>I'd like to take the opportunity to briefly introduce you to Chartist, before we dive into the implementation of the components for our dashboard.</p>
<p>Chartist claims to provide simple responsive charts. Luckily, this is still the case after three years of existence. I can tell you that the hardest job of maintaining this library was probably protecting it from feature bloat. There are so many great movements, technologies, and ideas in the open source community, and to resist bloating the scope of the library and always stay focused on the initial claim wasn't easy.</p>
<p>Let me show you a very basic example of how you can create a simple line chart, once you've included the Chartist scripts on your website:</p>
<pre>const chart = new Chartist.Line('#chart', { <br/>  labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'], <br/>  series: [ <br/>    [10, 7, 2, 8, 5] <br/>  ] <br/>}); </pre>
<p>The corresponding HTML markup that is required for this example looks as follows:</p>
<pre>&lt;body&gt; <br/>&lt;div id="chart" class="ct-golden-section"&gt;&lt;/div&gt; <br/>&lt;/body&gt; </pre>
<p>The following figure shows you the resulting chart that is rendered by Chartist:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3968c7cc-44ba-4d16-83b5-daf2edc809d9.png" style=""/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">A simple line chart rendered with Chartist</div>
<p>I believe that by saying we'll stick to being simple, we've not promised too much.</p>
<p>Let's look at the second core concern of Chartist, which is to be perfectly responsive. Chartist tries to stick to a very clear separation of concerns wherever possible, which means that it uses CSS for its appearance, SVG for its basic graphical structure, and JavaScript for any behaviors. By following this principle, we've already enabled a lot of responsiveness. We can use CSS media queries to apply different styles to our charts on different media.</p>
<p>While CSS is great for visual styles, there are plenty of elements in the process of rendering charts, which, unfortunately, can't be controlled by CSS. After all, that is the reason why we use a JavaScript library to render charts.</p>
<p>So, how can we control how Chartist renders our charts on different media, if we don't have control over this in CSS? Well, Chartist provides something called <strong>responsive configuration overrides</strong>. Using the browser's <kbd>matchMedia</kbd> API, Chartist is able to provide a configuration mechanism that allows you to specify options that you want to use only on certain media (mobile, desktop etc.).</p>
<p>Let's look at a simple example of how we can easily implement responsive behavior using a mobile-first approach:</p>
<pre>const chart = new Chartist.Line('#chart', { <br/>  labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'], <br/>  series: [ <br/>    [10, 7, 2, 8, 5]<br/>  ]<br/>}, {<br/>  showPoint: true,<br/>  showLine: true<br/>}, [<br/>  ['screen and (min-width: 400px)', {<br/>    showPoint: false<br/>  }],<br/>  ['screen and (min-width: 800px)', {<br/>    lineSmooth: false<br/>  }]<br/>]);</pre>
<p>In this example, the second parameter to the <kbd>Chartist.Line</kbd> constructor sets the initial options; we can provide overriding options, annotated with media queries in an array, as the third parameter of the constructor. In this example, we'll override the <kbd>showPoint</kbd> option for any media larger than 400 px in width. Media larger than 800 px in width will receive both the <kbd>showPoint</kbd> override and the <kbd>lineSmooth</kbd> override.</p>
<p>Not only can we specify real media queries to trigger setting changes, but we can also use an overriding mechanism that is very similar to CSS. This way, we can implement various approaches, such as ranged or exclusive media queries, mobile-first, or desktop-first. The responsive options mechanism can be used for all of the options available in Chartist:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8e4ec997-6217-4cf6-a2f7-f9a8c40b3e15.png" style=""/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Displaying the previous chart on three different media, left to right, with a media with less than 400 px (A), less than 800 px (B), and more than 800 px (C)</div>
<p>As you can see, implementing complex responsive behavior is a breeze with Chartist. Although our task management application was never meant to be a responsive web application, we can still benefit from this feature, in order to optimize our content.</p>
<p>That's enough about Chartist to get you started. If you would like to know more about my library, I recommend that you check out the project's website at <a href="http://gionkunz.github.io/chartist-js"><span class="URLPACKT">http://gionkunz.github.io/chartist-js</span></a>. On the website, you can also visit the live example page at <a href="http://gionkunz.github.io/chartist-js/examples.html"><span class="URLPACKT">http://gionkunz.github.io/chartist-js/examples.html</span></a>, where you can hack some charts directly in the browser.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Projects dashboard</h1>
                </header>
            
            <article>
                
<p>In this chapter, we'll create a projects dashboard, which will consist of the following components:</p>
<ul>
<li><strong>Projects dashboard</strong>: This is the main component in the dashboard and represents our whole dashboard view. It's a composition of the rest of the components.</li>
<li><strong>Project summary</strong><span>: This is where we'll display a summary of each project, where we will outline the most important facts. Our project summary component will also include an activity chart component that visualizes project activities.</span></li>
<li><strong>Projects dashboard container</strong>: We also need to create a new container component, to expose our new component tree to the router and connect it to our database.</li>
<li><strong>Tasks chart</strong>: This is where we'll provide a visual overview of open tasks over time. All projects will be represented in a line chart that displays the progress of open tasks. We'll also provide some user interaction, so that the user can choose between different timeframes.</li>
<li><strong>Activity chart</strong>: This component visualizes activities in a bar chart over a timeframe of 24 hours. This will help our users to quickly identify overall project activities and peaks.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the projects dashboard component</h1>
                </header>
            
            <article>
                
<p>Let's follow our established tradition and start by modelling our data, which we're going to use in our components. We'd like to create a new interface to summarize projects. This includes the project data, tasks, activities, and a short description.</p>
<p>Open our model file, located in <span><kbd>src/app/model.ts</kbd>, and add the following interface:</span></p>
<pre>…<br/><br/><strong>export interface ProjectSummary {</strong><br/><strong>  project: Project;</strong><br/><strong>  description: string;</strong><br/><strong>  tasks: Task[];</strong><br/><strong>  activities: ProjectActivity[];</strong><br/><strong>}</strong></pre>
<p>Using this interface, we can aggregate all project relevant data into a single object, which simplifies our development a lot.</p>
<p>Let's move ahead and create our main dashboard component. The projects dashboard component has the responsibility of composing the main dashboard layout, by including our dashboard sub-components. It holds together all of the pieces within our projects dashboard.</p>
<p>Let's create our new projects dashboard component by using the Angular CLI tool:</p>
<pre><strong>ng generate component --spec false -ve none -cd onpush projects-dashboard/projects-dashboard</strong></pre>
<p>Open up the generated component class, located on the path <kbd>src/app/projects-dashboard/projects-dashboard/projects-dashboard.component.ts</kbd>, and replace the stub code with the following:</p>
<pre>import {Component, ViewEncapsulation, ChangeDetectionStrategy, Input, EventEmitter, Output} from '@angular/core';<br/>import {Project, ProjectSummary} from '../model';<br/><br/>@Component({<br/>  selector: 'mac-projects-dashboard',<br/>  templateUrl: './projects-dashboard.component.html',<br/>  styleUrls: ['./projects-dashboard.component.css'],<br/>  changeDetection: ChangeDetectionStrategy.OnPush,<br/>  encapsulation: ViewEncapsulation.None<br/>})<br/>export class ProjectsDashboardComponent {<br/>  @Input() projectSummaries: ProjectSummary[];<br/>  @Output() outActivateProject = new EventEmitter&lt;Project&gt;();<br/><br/>  activateProject(project: Project) {<br/>    this.outActivateProject.emit(project);<br/>  }<br/>}</pre>
<p>Our dashboard component accepts a <kbd>projectSummaries</kbd> input, which is a list of project summary objects that conforms to the <kbd>ProjectSummary</kbd> interface that we just created within our <kbd>TypeScript</kbd> model file.</p>
<p>A user can activate a project by clicking on a project summary component. Our projects dashboard component uses the output <kbd>outActivateProject</kbd> to delegate the event to the container, which we'll create later.</p>
<p>Let's take a look at the view of our component, and change the content within the file <span><kbd>src/app/projects-dashboard/projects-dashboard/projects-dashboard.component.html</kbd> to the following:</span></p>
<pre>&lt;header class="dashboard-header"&gt;<br/>  &lt;h2 class="dashboard-title"&gt;Dashboard&lt;/h2&gt;<br/>&lt;/header&gt;<br/>&lt;div class="dashboard-main"&gt;<br/>  &lt;h3 class="dashboard-sub-title"&gt;Projects&gt;h3&gt;<br/> &lt;ul class="dashboard-list"&gt;<br/>    &lt;li *ngFor="let projectSummary of projectSummaries"<br/>        class="dashboard-list-item"&gt;<br/>      &lt;strong&gt;projectSummary.project.title&lt;/strong&gt;<br/>      &lt;p&gt;projectSummary.description&lt;/p&gt;<br/>    &lt;/li&gt;<br/>  &lt;/ul&gt;<br/>&lt;/div&gt;</pre>
<p>For the moment, we only displayed the project title and the description that we'll compute on our project summary objects. In the next section, we will create a new project summary component that will deal with some more complex rendering.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project summary component</h1>
                </header>
            
            <article>
                
<p>In this section, we'll create a project summary component that will provide some overview information for projects. Within the container component of our projects dashboard component tree, we'll make sure that we aggregate all of the necessary information to summarize projects. Our project summary UI component renders the data provided in the project summary objects, to create nice looking project overview cards.</p>
<p>Let's start building our component using the Angular CLI tool:</p>
<pre><strong>ng generate component --spec false -ve none -cd onpush projects-dashboard/project-summary</strong></pre>
<p>Let's open the component class, located in <kbd>src/app/projects-dashboard/project-summary/project-summary.component.ts</kbd>, and replace its content with the following code:</p>
<pre>import {ChangeDetectionStrategy, Component, Input, OnChanges, SimpleChanges, ViewEncapsulation} from '@angular/core';<br/>import {ProjectSummary, TimeEfforts} from '../../model';<br/><br/>@Component({<br/>  selector: 'mac-project-summary',<br/>  templateUrl: './project-summary.component.html',<br/>  styleUrls: ['./project-summary.component.css'],<br/>  changeDetection: ChangeDetectionStrategy.OnPush,<br/>  encapsulation: ViewEncapsulation.None<br/>})<br/>export class ProjectSummaryComponent implements OnChanges {<br/>  @Input() projectSummary: ProjectSummary;<br/><br/>  totalEfforts: TimeEfforts;<br/><br/>  ngOnChanges(changes: SimpleChanges) {<br/>    if (changes.projectSummary &amp;&amp; this.projectSummary) {<br/>      this.totalEfforts = this.projectSummary.tasks.reduce((totalEfforts, task) =&gt; {<br/>        if (task.efforts) {<br/>          totalEfforts.estimated += task.efforts.estimated || 0;<br/>          totalEfforts.effective += task.efforts.effective || 0;<br/>        }<br/><br/>        return totalEfforts;<br/>      }, {<br/>        estimated: 0,<br/>        effective: 0<br/>      });<br/>    }<br/>  }<br/>}</pre>
<p>The <kbd>projectSummary</kbd> input allows for passing a project summary object into our new UI component. There, we have all of the necessary information for displaying an overview of the project.</p>
<p>If you remember from the previous chapter, <a href="43791ecf-9bd7-4439-ba76-8f34098d350a.xhtml">Chapter 8</a>, <em>Time Will Tell</em>, we've created a nice effort timeline component using SVG. Within our project summary, we would now like to reuse that component. However, we need to compute the total effort from the underlying tasks of our project.</p>
<p>What we need to do is accumulate all task efforts into one overall effort. Using the <kbd>Array.prototype.reduce</kbd> function, we can accumulate all task efforts relatively easy. We're depending on the tasks present within our project summary object, which is passed to us with the input <kbd>projectSummary</kbd><span>. Since we'd like to recalculate the total effort when the project information changes, we can use the <kbd>OnChanges</kbd> life cycle hook and implement the method <kbd>ngOnChanges</kbd>.</span></p>
<p>Let's create the template of our component, to see how we're going to use the total efforts data to display our efforts timeline component. Open the file on the path <span><kbd>src/app/projects-dashboard/project-summary/project-summary.component.ts</kbd>, and amend it with the following content:</span></p>
<pre>&lt;div class="summary-title"&gt;{{projectSummary.project.title}}&lt;/div&gt;<br/>&lt;div class="summary-description"&gt;<br/>  {{projectSummary.description}}<br/>&lt;/div&gt;<br/>&lt;div class="summary-label"&gt;Total Efforts&lt;/div&gt;<br/>&lt;mac-efforts-timeline [efforts]="totalEfforts"&gt;<br/>&lt;/mac-efforts-timeline&gt;<br/>&lt;p&gt;{{totalEfforts | formatEfforts}}&lt;/p&gt;</pre>
<p>After displaying the project title and a description of the project summary, we included our efforts timeline component. We simply pass our computed <kbd>totalEfforts</kbd> into the <kbd>efforts</kbd> input, and the efforts timeline component will take care of the rendering. This timeline will now display the total aggregated amount of efforts logged on all tasks of a given project.</p>
<p>In addition to the timeline, we also rendered a formatted efforts text, like the one that we already rendered in the efforts component of the previous chapter. For this, we used the <kbd>formatEfforts</kbd> pipe.</p>
<p>Now, we still need to integrate our project summary component into the projects dashboard component.</p>
<p>Let's open the template of our projects dashboard, located in <kbd><span>src/app/projects-dashboard/projects-dashboard/projects-dashboard.component.html</span></kbd>, and modify the template to include our project summary component:</p>
<pre>&lt;header class="dashboard-header"&gt;<br/> &lt;h2 class="dashboard-title"&gt;Dashboard&lt;/h2&gt;<br/>&lt;/header&gt;<br/>&lt;div class="dashboard-main"&gt;<br/>  &lt;h3 class="dashboard-sub-title"&gt;Projects&lt;/h3&gt;<br/>  &lt;ul class="dashboard-list"&gt;<br/>    &lt;li *ngFor="let projectSummary of projectSummaries"<br/>        class="dashboard-list-item"&gt;<br/><strong>      &lt;mac-project-summary [projectSummary]="projectSummary"</strong><br/><strong>                           (click)="activateProject(projectSummary.project)"&gt;</strong><br/><strong>      &lt;/mac-project-summary&gt;</strong><br/>    &lt;/li&gt;<br/>  &lt;/ul&gt;<br/>&lt;/div&gt;<br/> </pre>
<p>We can simply forward the project summary object to our newly created project summary component. Additionally, we've added a click event binding on project summary components, which will trigger our <kbd>activateProject</kbd> method on the projects dashboard component. This will allow us to implement a programmatic navigation within our container component, which is up next for implementation:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/109ad064-df33-4643-bd5c-23cf44292389.png" style=""/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">A projects dashboard displaying two project summary components, with the aggregated total effort</div>
<p>Okay; so far, so good. We created two new UI components and reused our efforts timeline component to create an aggregated view of the total task efforts. Now, it's time to integrate our components by creating a new container component and configure the router of our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating the projects dashboard</h1>
                </header>
            
            <article>
                
<p>We've created our initial projects dashboard components, and will now work on their integration into our application. We're going to need a new container component, which we'll also expose within the router configuration. We also need to update the navigation component of our application, in order to show a new navigation link to the dashboard view.</p>
<p>Let's start with our new container component and use the Angular CLI tool to create the stubs for it:</p>
<pre><strong>ng generate component --spec false -ve none -cd onpush container/projects-dashboard-container</strong></pre>
<p>Open up the generated component class, located in <kbd>src/app/container/projects-dashboard-container/projects-dashboard-container.component.ts</kbd><span>, and replace its content with the following code:</span></p>
<pre>import {ChangeDetectionStrategy, Component, ViewEncapsulation} from '@angular/core';<br/>import {ProjectService} from '../../project/project.service';<br/>import {Observable, combineLatest} from 'rxjs';<br/>import {Project, ProjectSummary} from '../../model';<br/>import {map} from 'rxjs/operators';<br/>import {Router} from '@angular/router';<br/>import {ActivitiesService} from '../../activities/activities.service';<br/>import {TaskService} from '../../tasks/task.service';<br/>import {limitWithEllipsis} from '../../utilities/string-utilities';<br/><br/>@Component({<br/>  selector: 'mac-projects-dashboard-container',<br/>  templateUrl: './projects-dashboard-container.component.html',<br/>  styleUrls: ['./projects-dashboard-container.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class ProjectsDashboardContainerComponent {<br/>  projectSummaries: Observable&lt;ProjectSummary[]&gt;;<br/><br/>  constructor(private projectService: ProjectService,<br/>              private taskService: TaskService,<br/>              private activitiesService: ActivitiesService,<br/>              private router: Router) {<br/>    this.projectSummaries = combineLatest(<br/>      this.projectService.getProjects(),<br/>      this.taskService.getTasks(),<br/>      this.activitiesService.getActivities()<br/>    ).pipe(<br/>      map(([projects, tasks, activities]) =&gt;<br/>        projects<br/>          .map(project =&gt; ({<br/>            project,<br/>            description: limitWithEllipsis(project.description, 100),<br/>            tasks: tasks.filter(task =&gt; task.projectId === project.id),<br/>            activities: activities.filter(activity =&gt; activity.projectId === project.id)<br/>          }))<br/>      )<br/>    );<br/>  }<br/><br/>  activateProject(project: Project) {<br/>    this.router.navigate(['/projects', project.id]);<br/>  }<br/>}</pre>
<p>Our newly created container is responsible for gathering all information necessary to create a list of project summary objects. We're using RxJS observables to create a reactive stream of project summary objects. The RxJS utility <kbd>combineLatests</kbd> allows us to join projects, tasks, and activities into one single stream. Within this joined stream, we are using the <kbd>map</kbd> operator to create one project summary object for every project obtained from the project service.</p>
<p>We're using our <kbd>limitWithEllipsis</kbd> helper function to convert the project description into a truncated (if necessary) version, which we're adding directly to our project summary object.</p>
<p>We've also injected the router into our container component, and will use it to do a programmatic navigation to the project view. We've implemented a method, <kbd>activateProject</kbd>, for this purpose, which we're going to call from our view.</p>
<p>Let's also change the template of our container component where we want to render the projects dashboard UI component and create the necessary bindings to pass our project summary data into the UI component tree. Open the file <span><kbd>src/app/container/projects-dashboard-container/projects-dashboard-container.component.html</kbd>, and replace its content with the following code:</span></p>
<pre>&lt;mac-projects-dashboard<br/>  [projectSummaries]="projectSummaries | async"<br/>  (outActivateProject)="activateProject($event)"&gt;<br/>&lt;/mac-projects-dashboard&gt;</pre>
<p>All we need to do is render our projects dashboard UI component. We're passing our generated project summary objects down into the component input. Since we've implemented this using an observable stream, we need to use the <kbd>async</kbd> pipe.</p>
<p>When a project gets activated within the projects dashboard UI component, we receive an <kbd>outActivateProject</kbd> output event, which we can then use to call our <kbd>activateProject</kbd> method. There, we're using the router to navigate to the given project view.</p>
<p>Alright; now, we have all of the components ready to render our projects dashboard. There are two things left to do. We need to configure our router to activate our newly created container component and create a new navigation item within our app root component.</p>
<p>Let's start with the route configuration. Open up the route configuration file, located in <kbd>src/app/routes.ts</kbd>, and apply the following changes:</p>
<pre>…<br/><br/><strong>import {ProjectsDashboardContainerComponent} from './container/projects-dashboard-container/projects-dashboard-container.component';</strong><br/><br/>export const routes: Route[] = [<strong>{</strong><br/><strong>  path: 'dashboard',</strong><br/><strong>  component: ProjectsDashboardContainerComponent</strong><br/><strong>},</strong> {<br/>  path: 'projects/:projectId',<br/>  component: ProjectContainerComponent,<br/>  canActivate: [ProjectContainerGuard],<br/>  children: [{<br/>    path: 'tasks',<br/>    component: TaskListContainerComponent<br/>  }, {<br/>    path: 'tasks/:taskId',<br/>    component: TaskDetailsContainerComponent<br/>  }, {<br/>    path: 'comments',<br/>    component: ProjectCommentsContainerComponent<br/>  }, {<br/>    path: 'activities',<br/>    component: ProjectActivitiesContainerComponent<br/>  }, {<br/>    path: '**',<br/>    redirectTo: 'tasks'<br/>  }]<br/>}, {<br/>  path: '',<br/>  pathMatch: 'full',<br/> <strong> redirectTo: '/dashboard'</strong><br/>}];</pre>
<p>We've added a new route configuration to activate our projects dashboard container component. In addition, we've changed our default redirect URL to redirect to our dashboard, instead of the first project detail view.</p>
<p>Okay; let's move on and use our new route to create a navigation item within our app root component. Open up the app component template, located in <kbd>src/app/app.component.html</kbd>, and perform the following changes:</p>
<pre>&lt;aside class="side-nav"&gt;<br/> &lt;mac-user-area [user]="user | async"<br/>                 [openTasksCount]="openTasksCount | async"&gt;<br/>  &lt;/mac-user-area&gt;<br/>  &lt;mac-navigation&gt;<br/>    <strong>&lt;mac-navigation-section title="Main"&gt;</strong><br/><strong>      &lt;mac-navigation-item title="Dashboard"</strong><br/><strong>                           navId="dashboard"</strong><br/><strong>                           routerLinkActive="active"</strong><br/><strong>                           [routerLink]="['/dashboard']"&gt;</strong><br/><strong>      &lt;/mac-navigation-item&gt;</strong><br/><strong>    &lt;/mac-navigation-section&gt;</strong><br/>    &lt;mac-navigation-section title="Projects"&gt;<br/>      &lt;mac-navigation-item *ngFor="let project of projects | async; trackBy: trackByProjectId"<br/>                           [navId]="project.id"<br/>                           [title]="project.title"<br/>                           routerLinkActive="active"<br/>                           [routerLink]="['/projects', project.id]"&gt;<br/>      &lt;/mac-navigation-item&gt;<br/>    &lt;/mac-navigation-section&gt;<br/>  &lt;/mac-navigation&gt;<br/>&lt;/aside&gt;<br/>&lt;main class="main"&gt;<br/>  &lt;router-outlet&gt;&lt;/router-outlet&gt;<br/>&lt;/main&gt;</pre>
<p>Awesome! You've just completed all of the steps necessary for integrating our first set of projects dashboard components. You can now preview your changes in the browser. There should be a new navigation item available within the main navigation of the application. Also, when starting the application, you should<span> automatically</span> be redirected to the dashboard view.</p>
<p>You can already play with the efforts aggregation and try to modify a new task effort of a project, to see how the summary will be affected.</p>
<p>In the next section, we will enrich our project summary component with a nice Chartist chart.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating your first chart</h1>
                </header>
            
            <article>
                
<p>In this section, we will create our first chart using Chartist, to provide a project activity overview over the past 24 hours. This bar chart will only provide some visual clues about the project activity, and our goal isn't to provide detailed information. For this reason, we will configure it to hide any labels, scales, and grid lines. The only visible part should be the bars of the bar chart.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Processing activity data</h1>
                </header>
            
            <article>
                
<p>Before we start creating the activity chart itself, we need to look at how we should transform and prepare our data for the charts.</p>
<p>Let's look at what data we already have in our system. As far as the activities go, they all have a timestamp stored in the <kbd>time</kbd> field. However, for our chart, a list of timestamps is not sufficient enough. What we're looking for is a chart that displays one bar for each hour of the past 24 hours. Each one hour bar should represent the count of activities during that time.</p>
<p>The following illustration shows our source data, which is basically a time stream of activity events. On the lower arrow, we can see the data that we need to end up with for our chart:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/26fd9766-7b21-4cf7-bb7d-5b33e092b85c.png" style=""/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">An illustration displaying activities as a time stream, where dots represent activities. By rasterizing the events into one-hour slices, we get something we call rasterized counts, as shown on the bottom arrow.</div>
<p>First of all, we're going to introduce a new interface within our application model. We would like to represent a data value within a list of values, which is getting rasterized.</p>
<p>We use the term rasterization to describe the process of sampling underlying data into slices on a raster. This is very similar to how a digital camera would sample the photons of light rays and accumulate them on a raster which we call pixels. </p>
<p>Since we'd like to not only use a timestamp for rasterization, but also weigh data values differently, depending on situations, we will introduce the following interface to our model, located in <kbd>src/app/model.ts</kbd>:</p>
<pre>…<br/><br/>export interface RasterizationData {<br/>  time: number;<br/>  weight: number;<br/>}</pre>
<p>In the previous figure, we counted all activities within a given hour and added up them up. However, we will need a more specific solution that allows us to incorporate weight while counting. This is especially useful if you want to make certain activities count more than others. By using a property called <kbd>weight</kbd> on data input to the rasterization process, we can accomplish a weighted count. In fact, we're no longer counting data values within a <kbd>timeframe</kbd>; we're adding up their weights to get a total weight for a given <kbd>timeframe</kbd>. This allows us to use negative weights, which will subtract from the total weight. This will be important for the second chart, which we're going to create at a later stage.</p>
<p>Let's implement the function that performs the outlined data transformation. We'll add this function to our time utility module, located in <kbd>src/app/utilities/time-utilities.ts</kbd>:</p>
<pre>…<br/><br/>export function rasterize(<br/>  timeData: RasterizationData[],<br/>  timeFrame: number,<br/>  quantity: number,<br/>  now: number = +new Date(),<br/>  fill: number = 0): number[] {<br/><br/>  now = Math.floor(now / timeFrame) * timeFrame;<br/><br/>  return timeData.reduce((rasterized: number[], data: RasterizationData) =&gt; {<br/>    const index = Math.ceil((now - data.time) / timeFrame);<br/>    if (index &lt; quantity) {<br/>      rasterized[index] = (rasterized[index] || 0) + data.weight;<br/>    }<br/>    return rasterized;<br/>  }, &lt;number[]&gt;Array.from({length: quantity}).fill(fill)).reverse();<br/>}</pre>
<p>Let's briefly look at the input parameters of our newly created function:</p>
<ul>
<li><kbd>timeData</kbd>: This parameter is expected to be an array of rasterization data objects that contains a <kbd>time</kbd> property set to the timestamp of the event that should be counted. The objects should also contain a <kbd>weight</kbd> property, which is used to count. Using this property, we can count one event as two, or even count minus values to decrease the count in a rasterized frame.</li>
<li><kbd>timeFrame</kbd>: This parameter specifies the time span of each rasterized frame, in milliseconds. If we want to have 24 rasterized frames, each consisting of one hour, this parameter needs to be set to 3,600,000 (<em>1 h = 60 min = 3,600 s = 3,600,000 ms</em>).</li>
<li><kbd>quantity</kbd>: This parameter sets the amount of rasterized frames that should be present in the output array. In the case of 24 frames of one hour, this parameter should be set to 24.</li>
<li><kbd>now</kbd>: This parameter should be set as the point in time when the rasterization process will start. The rasterization will always move backwards in time, so this time marks the end time of our rasterization. The <kbd>now</kbd> parameter should be a timestamp, in milliseconds.</li>
<li><kbd>fill</kbd>: This is how we can specify how we'd like our rasterized output array to be initialized. In the case of our activity counts, we want this to be set to zero.</li>
</ul>
<p>The function that we just created is necessary to create the activity chart. The transformation helps us to prepare project activities for the input data of the chart.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an activity chart</h1>
                </header>
            
            <article>
                
<p>It's time to create our first chart component using Chartist! However, before we get into our component, we need to make sure that Chartist is installed within our project. Let's use npm to install Chartist as a dependency:</p>
<pre><strong>npm install chartist@0.11.0 @types/chartist@0.9.40 --save</strong></pre>
<p>Chartist is currently written in pure JavaScript. Luckily, the community created a very sophisticated type definition for Chartist, so you can benefit from typed interfaces when using Chartist with TypeScript.</p>
<p>Okay; that's all it takes to get us going with Chartist. Now, let's create our activity chart using the Angular CLI:</p>
<pre><strong>ng generate component --spec false -ve none -cd onpush projects-dashboard/activity-chart</strong></pre>
<p>Let's open the generated template, located on the path <kbd>src/app/projects-dashboard/activity-chart/activity-chart.component.html</kbd>, and replace its content with the following code:</p>
<pre>&lt;div #chartContainer&gt;&lt;/div&gt; </pre>
<p>As we leave all of the rendering up to Chartist, this is actually everything we need. Chartist needs an element as a container to create the chart in. We set a <kbd>chartContainer</kbd> local view reference, so that we can reference it from our component and pass it to Chartist.</p>
<p>Let's move on with the chart creation. Open up the component class, located in <kbd><span>src/app/projects-dashboard/activity-chart/activity-chart.component.ts</span></kbd>, and add the following code:</p>
<pre>import {<br/>  Component, ViewEncapsulation, ViewChild, ElementRef, Input, ChangeDetectionStrategy<br/>} from '@angular/core';<br/>import * as Chartist from 'chartist';<br/>import {IChartistBarChart} from 'chartist';<br/>import {Activity} from '../../model';<br/><br/>@Component({<br/>  selector: 'mac-activity-chart',<br/>  templateUrl: './activity-chart.component.html',<br/>  styleUrls: ['./activity-chart.component.css'],<br/>  changeDetection: ChangeDetectionStrategy.OnPush,<br/>  encapsulation: ViewEncapsulation.None<br/>})<br/>export class ActivityChartComponent {<br/>  @Input() activities: Activity[];<br/>  @ViewChild('chartContainer') chartContainer: ElementRef;<br/><br/>  chart: IChartistBarChart;<br/>}</pre>
<p>In addition to the imports from the Angular core module, we're also importing the Chartist namespace object, as well as the interface, <kbd>IChartistBarChart</kbd>.</p>
<p>Our component takes a list of activities as input, which we're going to transform using our new rasterization function. This transformed data is then used with Chartist to visualize the data. We're using a member, chart, to store the Chartist instance, once created.</p>
<p>Using the <kbd>ViewChild</kbd> decorator, we're obtaining the DOM element from our component view, which will be used as a container to create our chart.</p>
<p>Let's continue by adding a method to transform the activity list into something Chartist can work with. Within the same component class file, append the following method:</p>
<pre>import {<br/>  Component, ViewEncapsulation, ViewChild, ElementRef, Input, ChangeDetectionStrategy<br/>} from '@angular/core';<br/>import * as Chartist from 'chartist';<br/>import {IChartistBarChart, <strong>IChartistData</strong>} from 'chartist';<br/><br/><strong>import {rasterize, UNITS} from '../../utilities/time-utilities';</strong><br/>import {Activity<strong>, RasterizationData</strong>} from '../../model';<br/><br/>@Component({<br/>  selector: 'mac-activity-chart',<br/>  templateUrl: './activity-chart.component.html',<br/>  styleUrls: ['./activity-chart.component.css'],<br/>  changeDetection: ChangeDetectionStrategy.OnPush,<br/>  encapsulation: ViewEncapsulation.None<br/>})<br/>export class ActivityChartComponent {<br/>  @Input() activities: Activity[];<br/>  @ViewChild('chartContainer') chartContainer: ElementRef;<br/><br/>  chart: IChartistBarChart;<br/><br/><strong>  createChartData(): IChartistData {</strong><br/><strong>    const timeData: RasterizationData[] = this.activities.map((activity) =&gt; {</strong><br/><strong>      return {</strong><br/><strong>        time: activity.time,</strong><br/><strong>        weight: 1</strong><br/><strong>      };</strong><br/><strong>    });</strong><br/><br/><strong>    return {</strong><br/><strong>      series: [</strong><br/><strong>        rasterize(</strong><br/><strong>          timeData,</strong><br/><strong>          UNITS.find((unit) =&gt; unit.short === 'h').milliseconds,</strong><br/><strong>          24,</strong><br/><strong>          +new Date())</strong><br/><strong>      ]</strong><br/><strong>    };</strong><br/><strong>  }</strong><br/>}</pre>
<p>Within the <kbd>createChartData</kbd> method, we are first creating a list of rasterization data objects from the list of activities that we provided from our component input. We can use the activity time as a timestamp, and all of our activities currently count the same, so we use a fixed weight of <kbd>1</kbd>.</p>
<p>Now, we would like to extract the count of activities for every hour within the last 24 hours. We can use our <kbd>rasterize</kbd> function, with the necessary parameters, to transform our activities into exactly that format. The <kbd>rasterize</kbd> function will always return a list of numbers representing the count of activities within the desired timeframes. Together with the rasterization data, we pass the number of milliseconds for one hour, a total of 24 frames, and the current time as the starting point in time.</p>
<p>Our method returns an object of the type <kbd>IChartistData</kbd>, which contains the data that we want to visualize with Chartist. The output of our <kbd>rasterize</kbd> function has exactly the right format for representing a data series in Chartist.</p>
<p>Let's add the remaining code to complete our component class. Code changes are highlighted in bold, while the ellipsis character indicates irrelevant, hidden code:</p>
<pre>import {<br/>  Component, ViewEncapsulation, ViewChild, ElementRef, Input, ChangeDetectionStrategy,<br/>  <strong>OnChanges, AfterViewInit</strong><br/>} from '@angular/core';<br/>…<br/><br/>…<br/>export class ActivityChartComponent<strong> implements OnChanges, AfterViewInit</strong> {<br/>  @Input() activities: Activity[];<br/>  @ViewChild('chartContainer') chartContainer: ElementRef;<br/><br/>  chart: IChartistBarChart;<br/><br/> <strong> ngOnChanges() {</strong><br/><strong>    this.createOrUpdateChart();</strong><br/><strong>  }</strong><br/><br/><strong>  ngAfterViewInit() {</strong><br/><strong>    this.createOrUpdateChart();</strong><br/><strong>  }</strong><br/><br/>  <strong>createOrUpdateChart() {</strong><br/><strong>    if (!this.activities || !this.chartContainer) {</strong><br/><strong>      return;</strong><br/><strong>    }</strong><br/><br/><strong>    const data = this.createChartData();</strong><br/><br/><strong>    if (this.chart) {</strong><br/><strong>      this.chart.update(data);</strong><br/><strong>    } else {</strong><br/><strong>      this.createChart(data);</strong><br/><strong>    }</strong><br/><strong>  }</strong><br/><br/>  <strong>createChart(data: IChartistData) {</strong><br/><strong>    this.chart = new Chartist.Bar(this.chartContainer.nativeElement, data, {</strong><br/><strong>      width: '100%',</strong><br/><strong>      height: 60,</strong><br/><strong>      axisY: {</strong><br/><strong>        onlyInteger: true,</strong><br/><strong>        showGrid: false,</strong><br/><strong>        showLabel: false,</strong><br/><strong>        offset: 0</strong><br/><strong>      },</strong><br/><strong>      axisX: {</strong><br/><strong>        showGrid: false,</strong><br/><strong>        showLabel: false,</strong><br/><strong>        offset: 0</strong><br/><strong>      },</strong><br/><strong>      chartPadding: {</strong><br/><strong>        top: 0,</strong><br/><strong>        right: 0,</strong><br/><strong>        bottom: 0,</strong><br/><strong>        left: 0</strong><br/><strong>      }</strong><br/><strong>    });</strong><br/><br/><strong>    this.chart.on('draw', (context) =&gt; {</strong><br/><strong>      if (context.type === 'bar' &amp;&amp; context.value.y === 0) {</strong><br/><strong>        context.element.attr({</strong><br/><strong>          y2: context.y2 - 1</strong><br/><strong>        });</strong><br/><strong>      }</strong><br/><strong>    });</strong><br/><strong>  }</strong><br/><br/>  …<br/>}</pre>
<p>Let's look into the code in more detail and walk through it step by step.</p>
<p><span>The <kbd>createChart</kbd> method creates a new chart instance with the data that is passed to the method. In order to create a new bar chart, we can use the <kbd>Chartist.Bar</kbd> constructor. As a first parameter</span><span>, we pass the DOM element of our container view child. Chartist will create our chart in this container element. The second argument is our data, which we get from our method parameter. In the chart options, we'll set everything to achieve a very plain-looking chart, without any detailed information. We disable the grids, hide the labels, and remove any padding.</span></p>
<p>Additionally, we're using the Chartist draw event to control how zero value bars are drawn. By default, Chartist won't draw a bar when the value for the bar is exactly zero. We can control and change this behavior by implementing our own custom draw event logic.</p>
<p>The <kbd>createOrUpdateChart</kbd> method checks whether the chart was already created, and only needs to be updated if we really need to create a new chart instance. This simplifies our handling a lot. As we get called from both the <kbd>AfterViewInit</kbd> and <kbd>OnChanges</kbd> life cycle hooks, we need to make sure that both the <kbd>chartContainer</kbd> view child and the <kbd>activities</kbd> input are ready before we continue.</p>
<p>If the <kbd>chart</kbd> member is already set to a chart that was previously created, we can use the <kbd>update</kbd> function on the Chartist instance to update it with the new data. If there's no chart object, we need to create a new chart. We can simply call our <kbd>createChart</kbd> method for that.</p>
<p>This is great! We've created our first chart component using Chartist! Now, we can go back to our project summary component and integrate the activity chart there, to provide an activity overview. Open up the template of the project summary component, located in the file <span><kbd>src/app/projects-dashboard/project-summary/project-summary.component.html</kbd>, and apply the following changes:</span></p>
<pre>&lt;div class="summary-title"&gt;{{projectSummary.project.title}}&lt;/div&gt;<br/>&lt;div class="summary-description"&gt;<br/>  {{projectSummary.description}}<br/>&lt;/div&gt;<br/>&lt;div class="summary-label"&gt;Total Efforts&lt;/div&gt;<br/>&lt;mac-efforts-timeline [efforts]="totalEfforts"&gt;<br/>&lt;/mac-efforts-timeline&gt;<br/>&lt;p&gt;{{totalEfforts | formatEfforts}}&lt;/p&gt;<br/><strong>&lt;div class="summary-label"&gt;Activity last 24 hours&lt;/div&gt;</strong><br/><strong>&lt;mac-activity-chart [activities]="projectSummary.activities"&gt;&lt;/mac-activity-chart&gt;</strong></pre>
<p>We added our activity chart component at the bottom of the already existing template. We also created the necessary binding to pass our activities, which we already had available on our project summary object, into the component.</p>
<p>Congratulations! You've successfully integrated the Chartist library into your project, and have used it to visualize project activity on our project summary components.</p>
<p>In the next section, we'll dive a bit deeper into the charting capabilities of Chartist, and will also provide some interactivity using Angular.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visualizing open tasks</h1>
                </header>
            
            <article>
                
<p>In this section, we will create a line chart component using Chartist, which will display the open task progress of projects over time. To do this, we'll use a line chart with a specific interpolation that provides quantized steps, rather than lines with directly connected points.</p>
<p>We will also provide some interactivity, so that the user will be able to switch the displayed timeframe by using a toggle button. This will allow us to reuse the toggle UI component that we created in <a href="11f96942-6e99-46c5-b152-1af3b2579d44.xhtml"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Ready, Set, Go!</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing task data</h1>
                </header>
            
            <article>
                
<p>First, let's look at the data that we have available in our system, when it comes to project tasks. The <kbd>created</kbd> attribute is set to the timestamp at the moment when the task was created. If a task is marked as done, however, we currently don't save the timestamp of that moment. In order to produce the chart that we're looking for, we will need to know when a task was completed.</p>
<p>Let's introduce a new property on our task model for this purpose. Open up the <kbd>model</kbd> file, located in <kbd>src/app/model.ts</kbd>, and apply the following changes:</p>
<pre>export interface Task {<br/>  readonly id?: number;<br/>  readonly projectId?: number;<br/>  readonly title: string;<br/>  readonly description?: string;<br/>  readonly done: boolean;<br/>  readonly order: number;<br/>  readonly created: number;<br/><strong>  readonly completed?: number;</strong><br/>  readonly efforts?: TimeEfforts;<br/>}<br/><br/>…</pre>
<p>Now we need to make sure to set the <kbd>completed</kbd> property at the right moment, whenever a task is completed. Let's open the class of our task component, located in <kbd>src/app/tasks/task/task.component.ts</kbd>, and apply the following changes. Only modify the part in your code that is highlighted in the following code excerpt:</p>
<pre>…<br/>export class TaskComponent {<br/>  …<br/><br/>  updateTask(done: boolean) {<br/>    this.outUpdateTask.emit({<br/>      ...this.task,<br/>      done<strong>,</strong><br/><strong>      completed: done ? +new Date() : this.task.completed</strong><br/>    });<br/>  }<br/><br/>  …<br/>}</pre>
<p>Alright; to complete this exercise, we also want to update our initial data within the in-memory database, to reflect a more accurate scenario. Open the file <kbd>src/app/database.ts</kbd>, and apply the following changes. Again, only change the parts that are highlighted:</p>
<pre>import {InMemoryDbService} from 'angular-in-memory-web-api';<br/>import {Activity, Project, Task, User} from './model';<br/><br/>export class Database implements InMemoryDbService {<br/>  createDb() {<br/>    …<br/><br/>    <strong>const hour = 3600000;</strong><br/>    const tasks: Task[] = [<br/>      {id: 1, projectId: 1, title: 'Task 1', done: false, order: 1<strong>, created: +new Date() - hour * 8</strong>},<br/>      {id: 2, projectId: 1, title: 'Task 2', done: false, order: 2<strong>, created: +new Date() - hour * 6</strong>},<br/>      {id: 3, projectId: 1, title: 'Task 3', done: true, order: 3<strong>, created: +new Date() - hour * 12</strong>,<strong> <br/>       completed: +new Date() - hour * 3</strong>},<br/>      {id: 4, projectId: 1, title: 'Task 4', done: false, order: 4<strong>, created: +new Date() - hour * 20</strong>}<br/>    ];<br/><br/>    …<br/>  }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modeling the problem</h1>
                </header>
            
            <article>
                
<p>First, let's think about the problem of showing open task counts over time. As we're only interested in the number of open tasks at any given time, we can use a model where we put all tasks onto a single timeline, and where we are only concerned with the events of tasks being created or completed. Let's look at the following illustration to get a better understanding of the problem:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/897d7898-90ee-4582-bfa6-e217d7bb03db.png" style=""/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">An illustration that shows how we can represent all task timelines on a single timeline, using the created and completed events. The created events count as +1, while the completed events count as -1</div>
<p>The lower arrow is a representation of all tasks of the created and completed events on a timeline. We can now use this information as input to our <kbd>rasterize</kbd> function, in order to get the data that we need for our chart. As the rasterization data objects that are used as input for the function also support a <kbd>weight</kbd> property, we can use this to represent the created (<kbd>+1</kbd>) or completed (<kbd>-1</kbd>) events.</p>
<p>We need to make a slight modification to our <kbd>rasterize</kbd> function. So far, the <kbd>rasterize</kbd> function only counts events together in frames. However, for the open task counts, we will look into an accumulation over time. If the task count changes, we need to keep the value until it changes again. In the transformation of activities in the previous section, we didn't use this same logic. There, we only counted events inside frames, but there was no accumulation.</p>
<p>Let's look at the following illustration to see the differences, as compared to the rasterization that we applied when processing activities:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ce0fe326-e7da-4517-8a78-4272ddaeb8cb.png" style=""/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">An illustration that shows how we can accumulate the open task count over time</div>
<p>We can count each <kbd>weight</kbd> property of the <span>rasterization data </span>objects (events) together over time. If there's a change in the accumulated value, we will write the current accumulated value into the rasterized output array.</p>
<p>Let's implement this accumulation feature into our <kbd>rasterize</kbd> function. Open up the time utility module, on the path <kbd>src/app/utilities/time-utilities.ts</kbd>, and apply the following changes:</p>
<pre>export function rasterize(<br/>  timeData: RasterizationData[],<br/>  timeFrame: number,<br/>  quantity: number,<br/>  now: number = +new Date(),<br/>  fill: number = 0<strong>,</strong><br/><strong>  accumulate: boolean = false</strong>): number[] {<br/><br/>  now = Math.floor(now / timeFrame) * timeFrame;<br/>  <strong>let accumulatedValue = 0;</strong><br/><br/>  <strong>if (accumulate) {</strong><br/><strong>    timeData = timeData.slice().sort((a, b) =&gt; a.time &lt; b.time ? -1 : a.time &gt; b.time ? 1 : 0);</strong><br/><strong>  }</strong><br/><br/>  return timeData.reduce((rasterized: number[], data: RasterizationData) =&gt; {<br/>    <strong>accumulatedValue += data.weight;</strong><br/>    const index = Math.ceil((now - data.time) / timeFrame);<br/>    if (index &lt; quantity) {<br/>      <strong>rasterized[index] = accumulate ? accumulatedValue : (rasterized[index] || 0) + data.weight;</strong><br/>    }<br/>    return rasterized;<br/>  }, &lt;number[]&gt;Array.from({length: quantity}).fill(fill)).reverse();<br/>}</pre>
<p>Let's walk through the changes that we applied to the <kbd>rasterize</kbd> function.</p>
<p>First of all, we add a new parameter to our function, with the name <kbd>accumulate</kbd>. We use ES6 default parameters to set the parameter to <kbd>false</kbd>, if no value was passed into the function when called.</p>
<p>We define a new <kbd>accumulatedValue</kbd> variable, which we initialize with zero. This variable is used to keep track of the sum of all <kbd>weight</kbd> values over time.</p>
<p>The next bit of code is very important. If we want to accumulate the sum of all <kbd>weight</kbd> values over time, we need to make sure that these values come in sequence. In order to ensure this, we sort the <kbd>timeData</kbd> list by its items <kbd>time</kbd> attribute.</p>
<p>In the reduce callback, we increase the <kbd>accumulatedValue</kbd> variable by the <kbd>weight</kbd> value of the current <kbd>timeData</kbd> object.</p>
<p>If the <kbd>timeData</kbd> object falls into a rasterized frame, we do not increase this frame's count like we did before. In accumulation mode, we set the frames count to the current value in <kbd>accumulatedValue</kbd>. This will result in all changed accumulated values being reflected in the rasterized output array.</p>
<p>That's all the preparation we need to create our open tasks chart. We were able to refactor our <kbd>rasterize</kbd> function, which is now able to process time data and produce rasterized data series for various applications. With the use of a negative <kbd>weight</kbd> property, we can now create data series that increase and decrease, based on open tasks within a project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an open tasks chart</h1>
                </header>
            
            <article>
                
<p>Let's take a look at the line chart that we're going to create:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4c89891c-8f39-4861-9e9b-8f49f03ff7e7.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Open tasks visualized with our tasks chart component, using Chartist's step interpolation</span></div>
<p>We will utilize the refactored <kbd>rasterize</kbd> function of the previous topic, and will use the new accumulate mode to track open task counts over time.</p>
<p>Let's use the Angular CLI tool to create our new tasks chart component:</p>
<pre><strong>ng generate component --spec false -ve none -cd onpush projects-dashboard/tasks-chart</strong></pre>
<p>Let's edit the component class, on the path <kbd>src/app/projects-dashboard/tasks-chart/tasks-chart.component.ts</kbd>, and change its content to the following:</p>
<pre>import {<br/>  AfterViewInit, ChangeDetectionStrategy, Component, ElementRef,<br/>  Input, OnChanges, SimpleChanges, ViewChild, ViewEncapsulation<br/>} from '@angular/core';<br/>import * as Chartist from 'chartist';<br/>import {IChartistData, IChartistLineChart} from 'chartist';<br/>import * as moment from 'moment';<br/><br/>import {rasterize} from '../../utilities/time-utilities';<br/>import {ProjectSummary, RasterizationData} from '../../model';<br/><br/>@Component({<br/>  selector: 'mac-tasks-chart',<br/>  templateUrl: './tasks-chart.component.html',<br/>  styleUrls: ['./tasks-chart.component.css'],<br/>  changeDetection: ChangeDetectionStrategy.OnPush,<br/>  encapsulation: ViewEncapsulation.None<br/>})<br/>export class TasksChartComponent implements OnChanges, AfterViewInit {<br/>  @Input() projectSummaries: ProjectSummary[];<br/>  @ViewChild('chartContainer') chartContainer: ElementRef;<br/><br/>  chart: IChartistLineChart;<br/><br/>  ngOnChanges(changes: SimpleChanges) {<br/>    this.createOrUpdateChart();<br/>  }<br/><br/>  ngAfterViewInit() {<br/>    this.createOrUpdateChart();<br/>  }<br/><br/>  createOrUpdateChart() {<br/>    if (!this.projectSummaries || !this.chartContainer) {<br/>      return;<br/>    }<br/><br/>    const data = this.createChartData();<br/>    if (this.chart) {<br/>      this.chart.update(data);<br/>    } else {<br/>      this.createChart(data);<br/>    }<br/>  }<br/><br/>  createChartData(): IChartistData {<br/>    const now = +new Date();<br/>    return {<br/>      series: this.projectSummaries.map(projectSummary =&gt; {<br/>        const tasks = projectSummary.tasks<br/>          .filter(task =&gt; task.projectId === projectSummary.project.id);<br/>        const timeData: RasterizationData[] = tasks.reduce((data, task) =&gt; {<br/>          data.push({<br/>            time: task.created,<br/>            weight: 1<br/>          });<br/><br/>          if (task.done) {<br/>            data.push({<br/>              time: task.completed,<br/>              weight: -1<br/>            });<br/>          }<br/>          return data;<br/>        }, []);<br/><br/>        return rasterize(timeData, 600000, 144, now, null, true);<br/>      }),<br/>      labels: Array.from({<br/>        length: 144<br/>      }).map((e, index) =&gt; now - index * 600000).reverse()<br/>    };<br/>  }<br/><br/>  createChart(data: IChartistData) {<br/>    this.chart = new Chartist.Line(this.chartContainer.nativeElement, data, {<br/>      width: '100%',<br/>      height: 300,<br/>      lineSmooth: Chartist.Interpolation.step({<br/>        fillHoles: true<br/>      }),<br/>      axisY: {<br/>        onlyInteger: true,<br/>        low: 0,<br/>        offset: 70,<br/>        labelInterpolationFnc: value =&gt; `${value} tasks`<br/>      },<br/>      axisX: {<br/>        labelInterpolationFnc: (value, index) =&gt;<br/>          index % Math.floor(144 / 2) === 0 ?<br/>            moment(value).calendar() : null,<br/>        labelOffset: {<br/>          y: 10<br/>        }<br/>      }<br/>    }, [<br/>      ['screen and (min-width: 1200px)', {<br/>        axisX: {<br/>          labelInterpolationFnc: (value, index) =&gt;<br/>            index % Math.floor(144 / 4) === 0 ?<br/>              moment(value).calendar() : null<br/>        }<br/>      }], ['screen and (min-width: 1500px)', {<br/>        axisX: {<br/>          labelInterpolationFnc: (value, index) =&gt;<br/>            index % Math.floor(144 / 6) === 0 ?<br/>              moment(value).calendar() : null<br/>        }<br/>      }]<br/>    ]);<br/>  }<br/>}</pre>
<p>The basic structure of the preceding code should already look familiar to you. We're using the same structure as in our previous chart. However, the line chart that we are going to create now contains much more detailed information. We will render both axis labels and some scales. The <em>x</em>-axis of our chart will be a timeline, and we will use the Moment.js library to format the timestamps to a human-readable format.</p>
<p><span>Let's take a closer look at the <kbd>createChartData</kbd> and <kbd>createChart</kbd> methods. There's quite a bit of code here! Let's walk through it, step by step, to gain a better understanding of what's going on.</span></p>
<p><span>We use the </span><kbd>projectSummaries</kbd><span> input as a base for our data visualization. We transform the tasks data using our updated </span><kbd>rasterize</kbd><span> function, in order to prepare the data for our line chart.</span></p>
<p>First, we need to create our transformed series data by mapping the project summary list. The series array should include one data array for each project. Each data array will contain the open project tasks over time.</p>
<p>As the <kbd>rasterize</kbd> function expects a list of rasterization data objects, we need to first transform the projects task list into this format. We will make use of the weight feature of our <kbd>rasterize</kbd><span> function. We can simply create a rasterization data object with a weight of <kbd>1</kbd> for every event of a created task. For completed tasks, we create a rasterization data object with a weight of <kbd>-1</kbd>. This results in the desired input data for our <kbd>rasterize</kbd> function.</span></p>
<p>After preparing the <span>data</span>, we can call the <kbd>rasterize</kbd> function, in order to create a list of open tasks over a certain amount of rasterization frames. We use ten minute timeframes (600,000 ms) and rasterize with 144 frames. This makes a total of 24 hours. So, that's where those two magic numbers come from! However, this code will change a bit when we introduce the interactivity to our chart.</p>
<p>Besides the series data, we also need labels for our chart. We create a new array and initialize this with 144 timestamps, all of which are set to the start of the 144 rasterized frames that we display on the chart.</p>
<p>We now have the series data and the labels ready, and all that's left to do is render our chart. Within the <kbd>createChart</kbd> method, we're creating our line chart instance using the <kbd>Chartist.Line</kbd> constructor.</p>
<p>Using the <kbd>lineSmooth</kbd> configuration, we can specify a special kind of interpolation for our line chart. The step interpolation will not connect each point in our line chart directly, but will rather plot our data in discrete steps, to move from point to point. This is exactly what we're looking for to render the open task counts over time.</p>
<p>Setting the <kbd>fillHoles</kbd> option to <kbd>true</kbd> in the step interpolation is very important. Using this setting, we can actually tell Chartist that it should close any gaps in the data (actually null values) and connect the line to the next valid value. Without this setting, we'd see gaps on the chart between the task count changes in our data arrays.</p>
<p>Okay; that's all we need in our component class, for the moment. Let's move on to the rather simple template for our tasks chart component. Open the file, located on the path <kbd>src/app/projects-dashboard/tasks-chart/tasks-chart.component.html</kbd><span>, and change its content to the following:</span></p>
<pre>&lt;div #chartContainer class="chart-container"&gt;&lt;/div&gt;</pre>
<p>Similar to the activity chart component, we only create a simple chart container element, which we already reference in our component class using the view child decorator.</p>
<p>Our<span> t</span>asks chart<span> </span>component is now ready to be integrated into our dashboard. We can achieve this with some small changes to the template of our<span> p</span>rojects dashboard<span> </span>component. Let's open the file <kbd>src/app/projects-dashboard/projects-dashboard/projects-dashboard.component.html</kbd>, and apply the following changes:</p>
<pre>&lt;header class="dashboard-header"&gt;<br/>  &lt;h2 class="dashboard-title"&gt;Dashboard&lt;/h2&gt;<br/>&lt;/header&gt;<br/>&lt;div class="dashboard-main"&gt;<br/><strong>  &lt;h3 class="dashboard-sub-title"&gt;Tasks Overview&lt;/h3&gt;</strong><br/><strong>  &lt;div class="dashboard-tasks"&gt;</strong><br/><strong>    &lt;mac-tasks-chart [projectSummaries]="projectSummaries"&gt;</strong><br/><strong>    &lt;/mac-tasks-chart&gt;</strong><br/><strong>  &lt;/div&gt;</strong><br/>  &lt;h3 class="dashboard-sub-title"&gt;Projects&lt;/h3&gt;<br/> &lt;ul class="dashboard-list"&gt;<br/>    &lt;li *ngFor="let projectSummary of projectSummaries"<br/>        class="dashboard-list-item"&gt;<br/>      &lt;mac-project-summary [projectSummary]="projectSummary"<br/>                           (click)="activateProject(projectSummary.project)"&gt;<br/>      &lt;/mac-project-summary&gt;<br/>    &lt;/li&gt;<br/>  &lt;/ul&gt;<br/>&lt;/div&gt;</pre>
<p><span>Good stuff!</span> This is basically all that we need to make our newly created tasks chart appear on our dashboard. <span>You've created a simple line chart to visualize open tasks over time.</span></p>
<p>Let's further enhance our chart by rendering a chart legend and making the chart interactive for our users.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a chart legend</h1>
                </header>
            
            <article>
                
<p>Currently, there's no way to tell exactly what line on our chart represents what project. We can see one colored line for each project, but we can't associate these colors. What we need is a simple legend that helps our users to associate line chart colors to projects.</p>
<p>Let's look at the required code changes to implement legends on our chart. Open our tasks chart component class, located on the path <kbd><span>src/app/projects-dashboard/tasks-chart/tasks-chart.component.ts</span></kbd>, and apply the following changes. Irrelevant parts of this change are hidden using the ellipsis character, while effective changes are marked in bold:</p>
<pre>…<br/><br/><strong>export interface ChartLegendItem {</strong><br/><strong>  title: string;</strong><br/><strong>  class: string;</strong><br/><strong>}</strong><br/><br/>@Component({<br/>  selector: 'mac-tasks-chart',<br/>  templateUrl: './tasks-chart.component.html',<br/>  styleUrls: ['./tasks-chart.component.css'],<br/>  changeDetection: ChangeDetectionStrategy.OnPush,<br/>  encapsulation: ViewEncapsulation.None<br/>})<br/>export class TasksChartComponent implements OnChanges, AfterViewInit {<br/>  …<br/><br/>  <strong>legend: ChartLegendItem[];</strong><br/><br/>  ngOnChanges(changes: SimpleChanges) {<br/>    <strong>if (changes.projectSummaries &amp;&amp; this.projectSummaries) {</strong><br/><strong>      this.legend = this.projectSummaries.map((projectSummary, index) =&gt; ({</strong><br/><strong>        title: projectSummary.project.title,</strong><br/><strong>        class: `series-${index + 1}`</strong><br/><strong>      }));</strong><br/><strong>    }</strong><br/><br/>    this.createOrUpdateChart();<br/>  }<br/><br/>  …<br/>}</pre>
<p>We've added a local interface in our component module to represent individual legend items. The <kbd>title</kbd> property is going to be displayed for each item within our legend. The <kbd>class</kbd> property is used to set an appropriate CSS class, in order to render every legend item with the correct color, to match the colors of lines within our chart.</p>
<p>In the <kbd>OnChanges</kbd> life cycle hook, we simply map the project summary objects to a list of legend objects. The template string <kbd>`series-${index + 1}`</kbd> will generate the necessary class names to render the right color into our legend.</p>
<p>Using this legend information, we can now go ahead and implement the necessary template changes to render the legend in our tasks chart component. Open the template, located on the path <kbd><span>src/app/projects-dashboard/tasks-chart/tasks-chart.component.html</span></kbd>, and apply the following changes:</p>
<pre>&lt;ul class="series-list"&gt;<br/>  &lt;li *ngFor="let series of legend"<br/>      class="series {{series.class}}"&gt;{{series.title}}&lt;/li&gt;<br/>&lt;/ul&gt;<br/>&lt;div #chartContainer class="chart-container"&gt;&lt;/div&gt;</pre>
<p>Well, that was a piece of cake, right? However, the result speaks for itself. We created a nice legend for the chart in just a couple of minutes:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/064e3c96-1945-4627-8eac-de28c663a376.png" style=""/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Open tasks chart with our added legend</div>
<p>In the next topic, we're going to add some user interaction to our chart and let our users control the timeframe that we're using to render our data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making the tasks chart interactive</h1>
                </header>
            
            <article>
                
<p>Currently, we hardcoded the timeframe of our open task chart to be 144 frames, each 10 minutes long, making a total of 24 hours displayed to the user. However, maybe our users will want to change this view.</p>
<p>In this topic, we will create a simple input control using our toggle component, which will allow our users to change the timeframe settings of the chart.</p>
<p>We will provide the following views as options to choose from:</p>
<ul>
<li><strong>Day</strong>: This view will rasterize into 144 frames, each consisting of 10 minutes, which makes a total of 24 hours</li>
<li><strong>Week</strong>: This view will rasterize into 168 frames, each consisting of one hour, which makes a total of seven days</li>
<li><strong>Year</strong>: This view will rasterize into 360 frames, each representing a full day</li>
</ul>
<p>Let's start the implementation by modifying the tasks chart component <kbd>TypeScript</kbd> file, located on the path <kbd><span>src/app/projects-dashboard/tasks-chart/tasks-chart.component.ts</span></kbd>:</p>
<pre>…<br/><br/><strong>export interface ChartTimeFrame {</strong><br/><strong>  name: string;</strong><br/><strong>  timeFrame: number;</strong><br/><strong>  amount: number;</strong><br/><strong>}</strong><br/><br/>@Component({<br/>  selector: 'mac-tasks-chart',<br/>  templateUrl: './tasks-chart.component.html',<br/>  styleUrls: ['./tasks-chart.component.css'],<br/>  changeDetection: ChangeDetectionStrategy.OnPush,<br/>  encapsulation: ViewEncapsulation.None<br/>})<br/>export class TasksChartComponent implements OnChanges, AfterViewInit {<br/>  …<br/><br/><strong>  timeFrames: ChartTimeFrame[] = [{</strong><br/><strong>    name: 'day',</strong><br/><strong>    timeFrame: 600000,</strong><br/><strong>    amount: 144</strong><br/><strong>  }, {</strong><br/><strong>    name: 'week',</strong><br/><strong>    timeFrame: 3600000,</strong><br/><strong>    amount: 168</strong><br/><strong>  }, {</strong><br/><strong>    name: 'year',</strong><br/><strong>    timeFrame: 86400000,</strong><br/><strong>    amount: 360</strong><br/><strong>  }];</strong><br/><strong>  timeFrameNames = this.timeFrames.map((timeFrame) =&gt; timeFrame.name);</strong><br/><strong>  selectedTimeFrame = this.timeFrames[0];</strong><br/><br/>  …<br/><br/>  <strong>selectTimeFrame(timeFrameName: string) {</strong><br/><strong>    this.selectedTimeFrame = this.timeFrames.find((timeFrame) =&gt; timeFrame.name === timeFrameName);</strong><br/><strong>    this.createOrUpdateChart();</strong><br/><strong>  }</strong><br/><br/>  createChartData(): IChartistData {<br/>    const now = +new Date();<br/>    return {<br/>      series: this.projectSummaries.map(projectSummary =&gt; {<br/>        …<br/><br/>       <strong> </strong>return rasterize(timeData, <strong>this.selectedTimeFrame.timeFrame, </strong><br/><strong>          this.selectedTimeFrame.amount,</strong> now, null, true);<br/>      }),<br/>      labels: Array.from({<br/>        length: <strong>this.selectedTimeFrame.amount</strong><br/>      }).map((e, index) =&gt; now - index * <strong>this.selectedTimeFrame.timeFrame</strong>).reverse()<br/>    };<br/>  }<br/><br/>  …<br/>}</pre>
<p>Let's briefly go over these changes. First, we added another local interface to represent the <kbd>timeframe</kbd> choices presented to the user. The <kbd>ChartTimeFrame</kbd> interface consists of a name property, which we'll use to present to the user. We also stored the <kbd>timeFrame</kbd> and <kbd>amount</kbd> properties for each chart <kbd>timeframe</kbd> object. These two properties represent the number of milliseconds for each frame and the frame count, respectively.</p>
<p>The new <kbd>timeFrames</kbd> member is set to an array of <kbd>timeframe</kbd> objects. These are the choices we'll present to the user, and they reflect the settings we discussed at the beginning of this section. The <kbd>timeFrameNames</kbd> member contains a list of timeframe names, which is directly derived from the <kbd>timeFrames</kbd> list. Finally, we have a <kbd>selectedTimeFrame</kbd> member, which simply points to the first available timeframe object to start with.</p>
<p>In the <kbd>createOrUpdateChart</kbd> function, we no longer rely on hardcoded values for the task count rasterization, but we refer to the data in the <kbd>selectedTimeFrame</kbd> object. By changing this object reference and calling the <kbd>createOrUpdateChart</kbd> function again, we can now switch the view on the underlying data dynamically.</p>
<p>Finally, we added a new <kbd>selectTimeFrame</kbd> method, which we will call from our component view to switch to a different timeframe.</p>
<p>Let's look at the necessary template changes to enable the switching of timeframes. We're using our <kbd>toggle</kbd> UI component that we created at the very beginning of this book:</p>
<pre><strong>&lt;mac-toggle [buttonList]="timeFrameNames"</strong><br/><strong>            [activeButton]="selectedTimeFrame.name"</strong><br/><strong>            (outActivate)="selectTimeFrame($event)"&gt;&lt;/mac-toggle&gt;</strong><br/>&lt;ul class="series-list"&gt;<br/>  &lt;li *ngFor="let series of legend"<br/>      class="series {{series.class}}"&gt;{{series.title}}&lt;/li&gt;<br/>&lt;/ul&gt;<br/>&lt;div #chartContainer class="chart-container"&gt;&lt;/div&gt;</pre>
<p>From the bindings to the <kbd>toggle</kbd> component, you can already tell that we rely on the <kbd>timeFrameNames</kbd> member of our component to represent all selectable timeframes. We also bind to the <kbd>activeButton</kbd> input property of the <kbd>toggle</kbd> component using the <kbd>selectedTimeFrame</kbd> property of our tasks chart component. When the user activates a toggle button, we call the <kbd>selectTimeFrame</kbd> function, where the timeframe is switched and the chart is updated.</p>
<p>This is all that we need to enable switching the timeframe on our chart. The user can now choose between the year, week, and day views.</p>
<p>Excellent work! You've added interactivity to the tasks chart by reusing the <kbd>toggle</kbd> UI component. Let's take a look at the final result of our work:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/32180d58-7013-4408-8ca4-a155f19fc90b.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Final tasks chart, which is now rendered within our application dashboard</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about Chartist and how to use it in conjunction with Angular to create good looking and functional charts. We can leverage the power of both worlds to create reusable chart components that are nicely encapsulated.</p>
<p>Just like in most real cases, we always have a lot of data available. However, bringing that data into the right shape is sometimes tricky. In this chapter, we learned how we can transform existing data into a form that is optimized for visual representation.</p>
<p>In the next chapter, we will look at building a plugin system in our application. This will allow us to develop portable functionality that is packaged into plugins. Our plugin system will render new plugins dynamically, and we will use it to develop a simple agile estimation plugin.</p>


            </article>

            
        </section>
    </body></html>