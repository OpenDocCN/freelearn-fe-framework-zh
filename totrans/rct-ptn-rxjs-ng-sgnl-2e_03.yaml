- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fetching Data as Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way you manage your application’s data has a huge impact on your UI performance
    and the user experience. As far as I’m concerned, great user experience and performant
    UIs are no longer an option nowadays – they are key determinants of user satisfaction.
    Furthermore, managing data efficiently optimizes the code and enhances its quality,
    which consequently minimizes maintenance and improvement costs.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we manage our data efficiently? Well, this is what we will be answering
    in the following chapters. There are a few reactive patterns that come in handy
    in many use cases, and we will start by exploring the most basic reactive pattern
    for displaying values received from a REST endpoint to allow users to read and
    interact with them.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, we will explain the requirement that we’re going to implement in the
    recipe application. Then, we will introduce the classic pattern to retrieve data,
    followed by the different approaches that you can use to manage unsubscriptions
    and all the important technical concepts surrounding them. We will also learn
    about a new feature of Angular 14+, which is standalone components. Following
    this, we will explain the reactive pattern to fetch data, and highlight the advantages
    of the reactive pattern over the classic one. Finally, we will learn about the
    new built-in control flow introduced in Angular 17.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the data fetch requirement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the classic pattern for fetching data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the reactive pattern for fetching data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlighting the advantages of the reactive pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diving into the built-in control flow in Angular 17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have a basic understanding of HttpClient, Angular
    components, Angular modules, and routing.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be using a mocked REST API backend built with JSON Server, which allows
    you to spin up a REST API server with a fully working API. We’ll not be learning
    how to use JSON Server, but if you are interested in learning more, you can find
    further information at [https://github.com/typicode/json-server](https://github.com/typicode/json-server).
  prefs: []
  type: TYPE_NORMAL
- en: You can access the project source code for this chapter in the GitHub repository
    at [https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap03](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap03).
  prefs: []
  type: TYPE_NORMAL
- en: 'The project is composed of two folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`recipes-book-api`: This contains the mocked RESTful server already set up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`recipes-book-front`: This contains the frontend application that was built
    with Angular 17 and RxJS 7\. As a third-party dependency, we’ve added `bootstrap`
    and `primeng` libraries to help us build beautiful UI components quickly. Please
    refer to the previous chapter’s *Technical requirements* section for the environment
    and dependencies setup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The project complies with the standard Angular style guide, which can be found
    at [https://angular.dev/style-guide#](https://angular.dev/style-guide#).
  prefs: []
  type: TYPE_NORMAL
- en: The first time you run the apps, you will need to install dependencies beforehand.
    You only have to run the `npm i` command in the `recipes-book-api` and `recipes-book-front`
    folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once dependencies are installed, you need to start the server by running the
    following command in the `recipes-book-api` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The server will be running `at http://localhost:8081`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you start the frontend by running the following command in the `recipes-book-front`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can read more about the `--proxy-config` parameter at [https://angular.dev/tools/cli/serve#proxying-to-a-backend-server](https://angular.dev/tools/cli/serve#proxying-to-a-backend-server).
  prefs: []
  type: TYPE_NORMAL
- en: Defining the data fetch requirement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let’s define the requirement we are going to implement in a reactive
    way. We want to display the list of recipes retrieved from the mocked backend
    on the home page, progressively building the user story detailed in the *View
    one – the landing page* section of [*Chapter 2*](B21180_02.xhtml#_idTextAnchor031),
    *Walking through* *Our Application*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The landing page view](img/B21180_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – The landing page view
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to fetch the list of recipes beforehand to display it to
    the user as cards, right? So, the list of recipes represents the first data that
    we need to request, which is available in our `recipes-book-api` server through
    the following endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Please don’t forget to start the server as detailed in the *Technical requirements*
    section. Once the server is started, you can check the result of the fetch API
    at `http://localhost:8081/api/recipes`.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will see how we can implement the fetching data
    requirement in both classic and reactive styles to understand the basic differences
    between them, and to see the benefits the reactive programming gives us over the
    imperative one.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the classic pattern for fetching data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s first have a look at the implementation of the classic pattern for fetching
    the list of recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the structure of your data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First and foremost, we need to define the structure of our data so that we can
    strongly type it. This will allow us to take advantage of TypeScript’s type-checking
    features and catch type errors early.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the Angular CLI to generate the `src/app/` `core/model` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For convention purposes, we will change the name of the generated file from
    `recipe.ts` to `recipe.model.ts`. Then, we will populate the interface with the
    specific properties of `Recipe`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: One by one, we enter the properties of the recipe we are going to use, followed
    by the type of each property. The description of each property is detailed in
    *View two – the New Recipe interface* section of [*Chapter 2*](B21180_02.xhtml#_idTextAnchor031),
    *Walking through* *Our Application*.
  prefs: []
  type: TYPE_NORMAL
- en: For optional properties, we placed a question mark (`?`) just before the property’s
    type annotation when declaring the interface to tell TypeScript that the property
    is optional.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the fetching data service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to create an Angular service named `RecipesService` that will
    be responsible for managing all the operations around the recipes. This service
    will encapsulate the **create, read, update, and delete** (**CRUD**) operations
    and make them available to the various UI components. In this chapter, we will
    only implement the read (fetch) operation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, why do we create a service? Well, we do it to increase modularity and to
    ensure the reusability of the service over the other components.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the service underneath the `core/services` folder, we execute the
    `ng g s` command under the `core/services` folder like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the service is generated successfully, let’s create and implement
    the method that will have the responsibility of fetching the data. We will inject
    the `HttpClient` in the `RecipesService` and define a method to retrieve the data.
    The service will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down what is going on at the level of `RecipesService`. It’s nothing
    fancy – we have a `getRecipes()` method that gets the list of recipes over HTTP
    and returns a strongly typed HTTP response: `Observable<Recipe[]>`. This Observable
    represents the data stream that will be created when you issue the HTTP GET request.
    When you subscribe to it, it will emit the list of recipes as a JSON array and
    then completes. So, the stream represented by this HTTP request will be completed
    after emitting the response data once.'
  prefs: []
  type: TYPE_NORMAL
- en: As a best practice, we externalized `BASE_PATH` in the `environment.ts` file
    because, in many cases, the server’s base path depends on the environment (such
    as testing or production). This way, it is easier to update the paths in one place
    rather than updating all the services using it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Starting from Angular 15, the environment files are not shipped by default anymore.
    However, you can choose to generate them on demand by executing `$ ng` `g environments`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve also injected the `HttpClient` dependency in the constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This technique is known as **constructor injection**. Angular’s built-in dependency
    injection system will automatically provide the injected dependencies when an
    instance of the component or service is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Plus, starting from version 14, Angular’s dependency injection system provided
    the `inject()` utility function. This allows you to manually resolve and retrieve
    dependencies within a component or a service like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This approach is useful when you need to dynamically resolve dependencies or
    perform conditional dependency injection based on runtime conditions.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the constructor injection technique throughout the book. However,
    should you wish to adopt the newer approach, you have the flexibility to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Angular standalone components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we should create the component responsible for displaying the list of
    recipes named `RecipesListComponent` under `src/app/recipe-list`. Before that,
    though, let’s just stop here and explain a super interesting new type of component
    introduced in Angular 14: the standalone component.'
  prefs: []
  type: TYPE_NORMAL
- en: By definition, a `NgModule` and can be used by either other standalone components
    or module-based components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before Angular 14, we only had one way to create components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This command will create a component named `RecipesListComponent` and add it
    to an `NgModule`. Which module, though? If you specify `--module` in the command
    line, followed by the path of your module, then the CLI will add the component
    in that specific module. If the `--module` option is not set, then the CLI will
    check whether there’s a module in the same directory; if not, it will check in
    the nearest parent directory. If neither of those options is the case, it will
    generate a new module file in the same directory as the component and declare
    the component in that new module.
  prefs: []
  type: TYPE_NORMAL
- en: In short, the CLI will always end up associating the component to a module and
    adding it to the module’s declaration array; otherwise, you will get a compilation
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, starting from Angular 14, you can decide to create a standalone component
    that doesn’t belong to any `NgModule` by mentioning the `--standalone` flag in
    the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this in our project, `RecipesListComponent` won’t be added to an `NgModule`,
    and will contain the `standalone: true` flag inside the `@Component` decorator,
    as well as the `imports` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If the standalone component depends on other components, whether module-based
    or standalone, you should mention those components in the `imports` array; otherwise,
    you will get a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: Standalone components can also be used by module-based components or other standalone
    components. Plus, they can be used when loading routes, and in lazy loading. It’s
    also worth knowing that you can create standalone directives and standalone pipes
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, so good! Now, why should you care? There are a few good reasons we
    should adopt standalone components in our projects:'
  prefs: []
  type: TYPE_NORMAL
- en: Less code means less boilerplate to write, and hence, quicker build times, plus
    better code organization, testing, and maintainability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easier to understand the component’s dependencies as they are mentioned
    directly in the `imports` property of the standalone component. For a module-based
    component, you will have to scan your component’s code and then check the module’s
    dependencies that are shared by all the components belonging to that module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The power of standalone components lies in their isolation and self-contained
    nature. You only import what is needed by your component, while module-based components
    sometimes import useless dependencies used by other components in the same module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s suppose that we have a module “M” that imports “A,” “B,” and “C” components
    and “S1,” “S2,” and “S3” services, and we have a “D” component that does not belong
    to that module but depends on the component “B.” As “B” is a module-based component,
    then “D” should import the entire module ‘M’; this leads to unnecessary dependencies
    as “D” does not need the components “A” and “B” or the services “S1” and “S2.”
    So, integrating standalone components gives us more flexibility to only import
    the components and services required, since standalone components are self-contained
    and have their own sets of dependencies and logic. Consequently, it eliminates
    redundant code, leading to a more optimized app.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It makes the learning curve for beginner Angular developers less steep.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will be using standalone components in our recipe app to adopt a modular
    and self-contained approach. We will only keep the app component as a module-based
    component, even though we can bootstrap the application using a standalone component.
    Here’s a schema representing our component’s dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – The recipe app''s components’ dependencies](img/B21180_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – The recipe app's components’ dependencies
  prefs: []
  type: TYPE_NORMAL
- en: The `AppComponent` parent component is a module-based component that imports
    the `HeaderComponent` standalone component in the `AppModule` imports declaration.
    `HeaderComponent` uses some PrimeNG external dependencies, so it needs to be imported
    in the component’s imports declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '`HomeComponent` is a standalone component that will be routed to by `AppComponent`.
    `HomeComponent` imports the `RecipesListComponent` standalone component in the
    component’s imports declaration. The latter uses some PrimeNG external dependencies,
    so it needs to be imported in the component’s imports declaration. All the code
    is available in the GitHub repository.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on standalone components, you can check [https://angular.dev/reference/migrations/standalone](https://angular.dev/reference/migrations/standalone)
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, the concept of standalone components is clear, so let’s move on to
    the following step.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting and subscribing to the service in your component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will inject the `RecipesService` service in the `RecipesListComponent`
    component and call the `getRecipes()`method in `ngOnInit()` (when the component
    is initialized). We will also make a read operation against the API server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get the data emitted, we need to subscribe to the returned Observable
    from the `getRecipes()` method. Then, we bind the data to a local array property
    created in our component, called `recipes`. The component’s code will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve retrieved the data and stored it in a local property, let’s see
    how we will display it in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the data in the template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we can use the `recipes` property (which is available in the component)
    in our HTML template to display the list of recipes in our UI. In our case, we
    are using the `DataView` PrimeNG component to display the list of recipes as cards
    in a grid layout (further details about this component can be found at [https://primeng.org/dataview](https://primeng.org/dataview)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, our goal is to focus not on the template code, but on the manipulation
    of the data inside it. As you can see in the following example, we passed the
    `recipes` array to the `value` input of the data view component (you can also
    use structural directives to render a data view component with pure HTML if you
    don’t want to include a third-party dependency):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is the basic pattern for collecting data, which you would have discovered
    back when you started learning about Angular, so you have likely seen something
    like this before.
  prefs: []
  type: TYPE_NORMAL
- en: Now there’s just one thing left – you should handle the unsubscription of the
    Observable, as this code manages subscriptions manually. Otherwise, the `Observable`
    subscription will stay alive after the component has been destroyed, and the memory’s
    reference will not be released, causing memory leaks. That’s why you should always
    be careful of this when manually subscribing to Observables inside Angular components.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Although `HttpClient` Observables unsubscribe automatically after the server
    request responds or times out, we will still demonstrate how to handle their unsubscription
    to secure our implementation and showcase best practices. This will also serve
    as a showcase for handling unsubscription with other Observables.
  prefs: []
  type: TYPE_NORMAL
- en: Managing unsubscriptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two commonly used ways to manage unsubscriptions: the imperative
    pattern and the declarative reactive pattern. Let’s look at both patterns in detail.'
  prefs: []
  type: TYPE_NORMAL
- en: Imperative unsubscription management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imperative unsubscription means that we manually call the `unsubscribe()` method
    on the subscription object that we manage ourselves. The following code snippet
    illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply store the subscription inside a variable called `subscription`
    and unsubscribe from it in the `ngOnDestroy()` lifecycle hook.
  prefs: []
  type: TYPE_NORMAL
- en: This works fine, but it is not a recommended pattern. There is a better way,
    using the power of RxJS.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative unsubscription management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second unsubscription method is cleaner and far more declarative, using
    the RxJS `takeUntil` operator. However, before we dive into this pattern, let’s
    gain an understanding of the role of `takeUntil` using the following marble diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – The takeUntil marble diagram](img/B21180_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – The takeUntil marble diagram
  prefs: []
  type: TYPE_NORMAL
- en: The `takeUntil()` operator emits values from the source Observable (the first
    timeline) until the `Observable` notifier, which is given as input (the second
    timeline), emits a value. At that time, `takeUntil()` will stop the emission and
    complete. In the marble diagram, the source Observable emitted the values of `a`,
    `b`, `c`, and `d` – so `takeUntil()` will emit them, respectively. After that,
    the `Observable` notifier emits `z`, then `takeUntil()` will stop emitting values
    and will be completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our application, the `takeUntil` operator will help us keep the subscription
    alive for a period that we define. We want it to be alive until the component
    has been destroyed, so we will create an RxJS subject that will emit a value when
    the component has been destroyed. Then, we will pass this subject to `takeUntil`
    as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `$` sign is an informal convention that is used to indicate that the variable
    is an Observable.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you might notice here is that it’s less code than the first
    approach. Furthermore, when we call `unsubscribe()` on a returned subscription
    object (the first way), there’s no way we can be notified that the unsubscription
    happened. However, using `takeUntil()`, we will be notified of the Observable
    completion through the completion handler.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that this implementation can be further enhanced by using
    the `takeUntilDestroyed` operator introduced in Angular 16\. This operator simplifies
    Observable subscription management in your Angular components and directives.
    It automatically completes subscriptions when the associated component or directive
    is destroyed, eliminating the need for manual cleanup in the `ngOnDestroy` lifecycle
    hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'You only have to import the `takeUntilDestroyed` operator from the `@angular/core/rxjs-interop`
    package as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use this operator within the pipe operator of our subscription. The
    previous code will look like this after using `takeUntilDestroyed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the manual cleanup code in the `ngOnDestroy` lifecycle hook
    has been removed along with the `destroy$` subject, resulting in a more concise
    and readable component implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The `takeUntilDestroyed()` operator will automatically handle the subscription
    cleanup when `RecipesListComponent` is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the `takeUntil` and `takeUntilDestroyed` operators, there are other
    operators that manage unsubscription for you in a more reactive way. The following
    are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`take(X)`: This emits *x* values and then completes (will no longer emit values).
    For example, `take(3)` will emit three values from the given Observable and then
    complete. However, bear in mind that if your network is slow and the *xth* emission
    didn’t happen, then you have to unsubscribe manually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`first()`: This emits the first value and then completes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`last()`: This emits the last value and then completes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This was the classic pattern that we have all learned as a beginner, and it
    is a relatively valid way for fetching data. To sum up, the following diagram
    describes all the steps that we walked through:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – The classic pattern workflow](img/B21180_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – The classic pattern workflow
  prefs: []
  type: TYPE_NORMAL
- en: However, there is another pattern that we can use, which is much more declarative
    and reactive and has many advantages. We’ll discover it next!
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the reactive pattern for fetching data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea behind this reactive pattern is to keep and use the Observable as a
    stream throughout the application. Don’t worry – this will become more apparent
    to you as you explore this section. Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving data as streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start using the reactive pattern, instead of defining a method to retrieve
    our data, we will declare a variable inside our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are declaring the `recipes$` variable as the result of HTTP GET, which
    is either an Observable or the data stream. Think of every piece of data that
    changes over time as a stream and declare it as an Observable in a separate service.
    This will make it accessible throughout the app and give us more flexibility to
    manipulate it in different parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the stream in your component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, in `RecipesListComponent`, we are going to do the same thing we did in
    the classic pattern – that is, declare a variable holding the stream returned
    from our service. However, this time, the variable is the Observable we created
    in `RecipesService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: But wait! We need to subscribe in order to get the emitted data, right? That’s
    absolutely correct. Let’s see how we will do it.
  prefs: []
  type: TYPE_NORMAL
- en: Using the async pipe in your template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this pattern, we will not subscribe manually but instead, use a better way,
    the async pipe. The **async pipe** makes rendering values emitted from the Observable
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, it automatically subscribes to the input Observable. Then, it
    returns the latest value emitted. Best of all, when the component has been destroyed,
    it automatically unsubscribes to avoid any potential memory leaks. This means
    there is no need to manually clean up any subscriptions when the component has
    been destroyed. That’s amazing!
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the template, we bind to an Observable using the async pipe. As `recipes`
    describes the array variable that the values are emitted into, we can use it in
    the template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, the `<div>` element contains a `*ngIf` structural directive.
    This directive conditionally renders its child elements based on the truthiness
    of the `recipes$ |` `async` expression.
  prefs: []
  type: TYPE_NORMAL
- en: The `recipes$ | async` expression subscribes to the `recipes$` Observable and
    asynchronously renders the child elements of the `<div>` element (which is the
    `DataView` component in our case) when the Observable emits a value. It also unsubscribes
    and cleans up the subscription when the element is removed from the **DOM** (**Document**
    **Object Model**).
  prefs: []
  type: TYPE_NORMAL
- en: The `*ngIf` directive is followed by `as recipes`, which assigns the emitted
    value from the Observable to the local `recipes` variable. This allows us to access
    the emitted value within the scope of the `<div>` element and its children using
    the `recipes` variable.
  prefs: []
  type: TYPE_NORMAL
- en: By using the async pipes, we don’t need the `ngOnInit` lifecycle hook, as we
    will not subscribe to the `Observable` notifier in `ngOnInit()` and unsubscribe
    from `ngOnDestroy()` as we did in the classic pattern. Instead, we simply set
    a local property in our component and we are good to go – we don’t need to handle
    the subscription and unsubscription on our own!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The full code of the HTML template is available in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up this pattern, the following diagram describes all the steps we walked
    through:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – The reactive pattern workflow](img/B21180_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – The reactive pattern workflow
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explained the reactive pattern in action, in the next section,
    let’s review its advantages.
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting the advantages of the reactive pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I think you might have guessed the first advantage of the reactive pattern –
    we don’t have to manually manage subscriptions and unsubscriptions, and what a
    relief – but there are a lot of other advantages. Let’s look at the other advantages
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Using the declarative approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s shed light on why we don’t explicitly use the `subscribe()` method. What’s
    wrong with `subscribe()`? Well, subscribing to a stream inside our component means
    we are allowing imperative code to leak into our functional and reactive code.
    Using the RxJS Observables does not make our code reactive and declarative systematically.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what does declarative mean, exactly? Well, first, we will nail down some
    key terms. Then, let’s iterate from there:'
  prefs: []
  type: TYPE_NORMAL
- en: A **pure function** is a function that will always return identical outputs
    for identical inputs, no matter how many times it is called. In other words, the
    function will always predictably produce the same output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Declarative** refers to the use of declared functions to perform actions.
    You rely upon pure functions that can define an event flow. With RxJS, you can
    see this in the form of Observables and operators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, why should you care? Well, you should care because the declarative approach
    using RxJS operators and Observables has many advantages, namely, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It makes your code cleaner and more readable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes your code easier to test because it is predictable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes you able to cache the stream output given a certain input, and this
    will enhance performance. We will explore this in more detail in [*Chapter 7*](B21180_07.xhtml#_idTextAnchor107),
    *Sharing Data between Angular Components*, [*Chapter 9*](B21180_09.xhtml#_idTextAnchor146),
    *Demystifying Multicasting*, and [*Chapter 10*](B21180_10.xhtml#_idTextAnchor159),
    *Boosting Performance with* *Reactive Caching*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enables you to leverage RxJS operators and transform and combine streams
    coming from different services or even within the same service. This is what we
    will see in [*Chapter 5*](B21180_05.xhtml#_idTextAnchor083), *Combining Streams*,
    and [*Chapter 6*](B21180_06.xhtml#_idTextAnchor097), *Transforming Streams*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps you react easily to user interactions in order to execute an action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, more declarative means more reactive. However, be careful. This doesn’t
    mean you can’t ever call the `subscribe()` method. It is unavoidable in some situations
    to trigger the `Observable` notifier. But try to ask yourself: do I really need
    to subscribe here? Can I instead compose multiple streams together, or use RxJS
    operators, to achieve what I need without subscribing? Aside from cases where
    it is unavoidable, never use `subscribe()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move to the change detection concept and see how it can improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: Using the change detection strategy of OnPush
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The other really cool thing is that we can use the `changeDetection` strategy,
    `OnPush`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Change detection** is one of the most powerful features of Angular. It is
    about detecting when the component’s data changes and then automatically re-rendering
    the view or updating the DOM to reflect that change. The default strategy of “check
    always” means that, whenever any data is mutated or changed, Angular will run
    the change detector to update the DOM. So, it is automatic until explicitly deactivated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `OnPush` strategy, Angular will only run the change detector when one
    of the following occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Condition 1*: A reference of a component’s `@Input` property changes (bear
    in mind that when the input property object is mutated directly, then the reference
    of the object will not change and, consequently, the change detector will not
    run. In this case, we should return a new reference of the property object to
    trigger the change detection).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Condition 2*: A component event handler is emitted or gets triggered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Condition 3*: A bound Observable via the async pipe emits a new value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, using the `ChangeDetection` `OnPush` strategy minimizes any change
    detection cycles and will only check for changes to re-render our components in
    the preceding cases. This strategy applies to all child directives and cannot
    be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our scenario, we only need the change detector to run if we get a new value;
    otherwise, we get useless updates. So, our scenario matches *Condition 3*. The
    good news is that we can use the change detection `onPush` strategy as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we remember to use the async pipe as much as possible, we will see a couple
    of advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: We will make it easier to later switch from the default change detection strategy
    to `OnPush` if we need to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will run into fewer change detection cycles using `OnPush`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, using the async pipe will help you to achieve a high-performing
    UI, and it will have a lot of impact if your view is doing multiple tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'And here’s the output of our UI after all of that work in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – An overview of the list of recipes](img/B21180_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – An overview of the list of recipes
  prefs: []
  type: TYPE_NORMAL
- en: So, after all that, in a nutshell, using the reactive pattern for fetching data
    will improve the performance of your application, the change detection strategy,
    and the code clarity and readability. As well as that, it will make the code more
    declarative and reactive, it will make it easier to leverage RxJS operators, and
    it will make it easier to react to user actions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve established the reactive pattern, let’s conclude this chapter
    by exploring an intriguing feature introduced in Angular 17, understanding its
    benefits, and applying it in practice within our recipe app.
  prefs: []
  type: TYPE_NORMAL
- en: Diving into the built-in control flow in Angular 17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before Angular 17, control flow within templates was predominantly managed using
    structural directives. Let’s start by exploring the structural directives.
  prefs: []
  type: TYPE_NORMAL
- en: Structural directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Structural directives are responsible for altering the structure of the DOM
    and orchestrating how elements are added, removed, or repeated based on certain
    conditions. Here’s the list of available directives in Angular to control the
    execution of the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*ngIf`: This structural directive is used to conditionally include or exclude
    elements from the DOM based on the truthiness of an expression. For instance,
    consider the following code snippet, which displays the message `items` array
    is empty:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <ul>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <li *ngFor="let product of products">
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{ product.name }}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </li>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </ul>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <ul>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '<li *ngFor="let product of products; trackBy:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: trackProduct">{{ product.name }}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </li>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </ul>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'trackProduct(index: number, product: Product) {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'return product ? product.id : undefined;'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ngSwitch`: This structural directive is used to conditionally include or exclude
    elements from the DOM based on the evaluated value of a provided expression. It
    is commonly used when there are multiple conditions to be evaluated. Here’s an
    example that renders different views based on user roles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we’ve explored the structural directives in Angular, which provided
    a mechanism for dynamically altering the structure of the DOM based on certain
    conditions, we can delve into the next evolution of control flow management within
    Angular templates. With the release of Angular version 17, a new paradigm emerges:
    the built-in control flow. Let’s delve into the details of this exciting new feature
    and explore how it enhances the Angular development experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in control flows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Built-in control flows offer a more concise and declarative way to manage control
    flow logic directly within your component templates, eliminating the need for
    structural directives. Here are the new built-in control flow statements.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in if statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@if` statement conditionally renders content based on a Boolean expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the previous example of `*ngIf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the new `@if` and `@else` statements, the example will now look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, there are differences in syntax between the two code
    blocks. The `@if` and `@else` statements replace the `*ngIf` directive and the
    `ng-template` element by providing a more intuitive and JavaScript-like syntax
    for handling conditional rendering within component templates. You can optionally
    use an `@else` statement to provide alternative content when the condition evaluates
    to false.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, while `*ngIf` requires importing `CommonModule` to function properly,
    `@if` is a standalone statement that can be directly used within the template
    without any additional imports.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the `@if` block may have one or more associated `@else` blocks.
    After an `@if` block, you can optionally chain any number of `@else if` blocks
    and one `@else` block as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Built-in for-loop statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@for` statement iterates over a collection of data and renders content
    for each item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take the previous `*ngFor` example again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the new `@for` statement, the example will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Replacing the previously optional `trackBy` function used with `*ngFor` is the
    `track` function within the `@for` statement. Both approaches serve the same core
    purpose, enabling Angular to efficiently track changes within your iterated lists
    by focusing on the unique identifier of each item rather than its position in
    the array.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While `trackBy` was optional, its absence often led to performance issues. However,
    using `track` is now mandatory within `@for` loops, ensuring optimal rendering
    speed by default.
  prefs: []
  type: TYPE_NORMAL
- en: A significant advantage of `track` is its ease of use compared to `trackBy`.
    You can directly include an expression representing the unique identifier of each
    item within the template itself, eliminating the need for a separate `trackBy`
    method in your component class (`trackProduct` in the previous example). This
    streamlines your code and improves readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The transition to `track` is designed to be seamless for developers who have
    already implemented `trackBy` functions and wish to migrate without removing those
    methods. They can seamlessly retain the existing methods and simply update the
    template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This ensures backward compatibility and a smooth transition process.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, `track` offers a mandatory and simplified approach to change tracking
    within `@for` loops, promoting optimal performance and a more concise syntax in
    your Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that the `@for` statement uses a new diffing algorithm
    and offers a more optimized implementation compared to `*ngFor`. This enhancement
    results in up to 90% faster runtime according to community framework benchmarks.
    For more information, refer to [https://krausest.github.io/js-framework-benchmark/current.html](https://krausest.github.io/js-framework-benchmark/current.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, the built-in `@for` loop has a shortcut to deal with empty collections,
    referred to as the optional `@``empty` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `@empty` block offers a convenient and efficient way to display informative
    messages or alternative content when no data is available. It promotes a better
    user experience and keeps your component logic well-organized.
  prefs: []
  type: TYPE_NORMAL
- en: 'We went into a bit of detail there, so to summarize, here are the key benefits
    of the new `@``for` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@for` syntax offers a cleaner and more readable way to iterate over lists,
    display alternative content when no data is available, and define unique identifiers
    for the list items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By requiring `track`, `@for` guarantees efficient DOM updates, leading to a
    smoother user experience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@for` loop leverages a new, optimized diffing algorithm compared to `*ngFor`.
    This has led to significant performance improvements, as evidenced by community
    benchmarks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In essence, the `@for` statement provides an all-around upgrade for iterating
    over collections in your Angular applications. It empowers developers with a cleaner,
    more performant, and more user-friendly way to manage data within templates.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in switch statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@switch` statement selects content based on a matching expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take the previous example of `*ngSwitch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the new `@switch` statement, it will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, both `@switch` and `*ngSwitch` achieve conditional
    rendering in Angular templates. However, `@switch` offers a more concise and modern
    approach that aligns better with current JavaScript practices. This syntax is
    more intuitive and closer to standard JavaScript switch statements, making code
    easier to understand and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: The `@default` block is optional and can be excluded. In the absence of a matching
    `@case` and if there’s no `@default` block provided, nothing will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Including built-in control flows in our recipe app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve learned about the new built-in control flow, let’s take advantage
    of it and update our template code with this new syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML code of our `RecipesListComponent.html` file uses the Angular structural
    directives `*ngIf` (used to conditionally render the data view when the `recipes$`
    Observable returns a value) and `*ngFor` (used to iterate over the list of recipes
    and render a card for each recipe). Here is the code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s update this code using the new built-in control flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We replaced `*ngIf` with `@if` to conditionally render the data view when the
    `recipes$` Observable returns a value.
  prefs: []
  type: TYPE_NORMAL
- en: We also replaced `*ngFor` with `@for` to iterate over the list of recipes and
    render a card for each recipe. We included within the `@for` statement the track
    function, `track recipe.id`. The recipe’s ID is the unique identifier of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a refreshed template that not only is more performant but also aligns
    seamlessly with the latest version of Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, if you have existing projects, you can easily migrate them to
    leverage the new built-in flow syntax by using the following migration schematic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Benefits of built-in control flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several benefits to using Angular’s built-in control flow syntax,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Improved readability*: The syntax aligns more closely with JavaScript, making
    the code easier to understand and maintain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reduced boilerplate*: You can remove the need for separate directive imports
    and properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Built-in availability*: No additional imports are required; the feature is
    readily available out of the box in your templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Enhanced type safety*: The compiler provides more robust type narrowing, resulting
    in improved type safety and error detection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Performance improvements*: While performance improvements can vary depending
    on your application’s structure and data size, the `@for` statement utilizes a
    more streamlined diffing algorithm compared to `*ngFor`. This can potentially
    lead to smoother rendering and a better user experience, especially when dealing
    with large or frequently updated lists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, the built-in control flow syntax fosters a more intuitive, concise,
    and performant approach to writing Angular templates. It promotes code readability,
    reduces boilerplate, and offers enhanced type safety.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the classic and reactive patterns for fetching
    data. We learned about the imperative way in which to manage unsubscriptions and
    the reactive pattern. We explained some useful RxJS operators, and also shed light
    on the advantages of using the reactive pattern and learned about all the technical
    aspects around it. We also learned about standalone components, a new edition
    to Angular, as well as how to create them, and what their benefits are. Lastly,
    we delved into the new built-in control flow introduced in Angular 17, covering
    its various applications, syntax, and associated benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have retrieved our data as RxJS streams, in the next chapters, let’s
    start playing with those streams to react to user actions using RxJS streams and,
    consequently, build our `RecipesApp` application in a reactive way. In the next
    chapter, we will focus on the reactive patterns for error handling and the different
    strategies that are available.
  prefs: []
  type: TYPE_NORMAL
