- en: Creating Our First Create React App Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个Create React App应用程序
- en: In [Chapter 1](f616eaec-1edb-44b2-bc14-7fec21a70501.xhtml), *Introducing Create
    React App 2,* we started off by taking a good, long look at Create React App and
    some of the options it provides. We even got started with `create-react-app` and
    started learning React at a very basic level. What we need to do now, however,
    is start diving into building an application that will serve as the framework
    for adding more functionality and testing the limits of Create React App.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '在[第1章](f616eaec-1edb-44b2-bc14-7fec21a70501.xhtml)《介绍Create React App 2》中，我们首先仔细研究了Create
    React App及其提供的一些选项。我们甚至开始了`create-react-app`的学习，并从非常基础的React知识开始学习。然而，我们现在需要开始构建一个将作为添加更多功能和测试Create
    React App极限框架的应用程序。 '
- en: To make things extra easy, we're going to build a simple **to do list**, since
    that is an application that nearly everyone can understand. It even has a great
    non-digital analog to it, making it a simple thing to reason about!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让事情更加简单，我们将构建一个简单的**待办事项列表**，因为这是一个几乎每个人都能理解的应用程序。它甚至有一个很好的非数字类似物，这使得它很容易进行推理！
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Designing a web app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个网络应用程序
- en: Building a simple project structure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个简单的项目结构
- en: Passing values to components via props
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过props向组件传递值
- en: Passing functions to children components via props
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过props将函数传递给子组件
- en: Basic component styling with included CSS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包含的CSS进行基本组件样式设计
- en: Creating our first major project
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个主要项目
- en: It's now time for us to move forward and start building a real project that
    will function as the baseline project for all of the other features that we want
    to explore in this book! To do that, though, let's take a brief moment to talk
    about how we want to design our application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们向前推进并开始构建一个真正项目的时候了，这个项目将作为我们想要在这个书中探索的所有其他功能的基准项目。不过，为了做到这一点，让我们先简要地谈谈我们想要如何设计我们的应用程序。
- en: Designing our application
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计我们的应用程序
- en: It's very difficult to build a project when you're not sure precisely what you're
    building in the first place, right? When we talk about how to design, build, and
    plan an application, we need to talk about the problem we're ultimately trying
    to solve in the first place. With that in mind, let's talk about the theoretical
    vision for our application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不确定最初要构建什么时，构建项目是非常困难的，对吧？当我们谈论如何设计、构建和规划一个应用程序时，我们需要讨论我们最初试图解决的问题。考虑到这一点，让我们来谈谈我们应用程序的理论愿景。
- en: First off, we're going to build out a mixture between a **pomodoro tracker**
    and a to-do list. This will give us the functionality of a plain old to-do list,
    but also allow us to track time spent on each item as we go through the list.
    We'll keep the overall design of this application pretty simple; there's no reason
    to dive into a giant application. A relatively small and simple application will
    teach you all you need to get started quickly with Create React App.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将构建一个介于**番茄计时器**和待办事项列表之间的混合体。这将给我们一个普通的待办事项列表的功能，同时允许我们在通过列表时跟踪每个项目花费的时间。我们将保持这个应用程序的整体设计相当简单；没有必要深入一个庞大的应用程序。一个相对较小且简单的应用程序将教会你如何快速开始使用Create
    React App。
- en: This chapter is also going to be the only chapter that's really only focused
    on the React side of things and less on Create React App. Being able to get started
    with any tool is essentially useless if you don't know how to build something
    after you get up and moving, so that is what this chapter is designed to help
    you solve.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章也将是唯一一个真正只关注React方面，而较少关注Create React App的章节。如果你在开始使用任何工具后不知道如何构建东西，那么能够开始使用任何工具基本上是没有用的，这就是本章旨在帮助你解决的问题。
- en: 'Our application will have a simple to-do interface with a Mark As Done button
    for each. For each item, you''ll be able to mark the item as complete after you
    add it and it will change the display of that item to let you know it''s done.
    There''s not really anything particularly fancy going on, just a very simple application
    design. Let''s take a look at what the design for this might look like (at a very
    high level):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将有一个简单的待办事项界面，每个待办事项都有一个“标记为完成”按钮。对于每个项目，你可以在添加后将其标记为完成，并且它将更改该项目的显示，让你知道它已完成。实际上并没有什么特别复杂的事情，只是一个非常简单的应用程序设计。让我们看看这个设计的可能样子（从非常高的层面来看）：
- en: '![](img/8ea111d6-4175-4de0-a3ab-5102792a830d.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8ea111d6-4175-4de0-a3ab-5102792a830d.png)'
- en: Building the baseline functionality for our application
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的应用程序构建基准功能
- en: Now that we understand the design, we'll want to jump right in to creating the
    project and getting things built. While the application is not particularly tricky,
    there's a decent amount of complexity overall and a pretty good amount of code
    we'll end up having to write. To make things work, we'll separate out our application's
    concerns and make sure what we're building, even in its limited scope, is still
    very similar to what you'd build in a real world application!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了设计，我们将直接开始创建项目并构建。虽然应用程序本身并不特别复杂，但整体上具有一定的复杂性，并且我们将最终需要编写相当多的代码。为了使一切正常工作，我们将分离应用程序的关注点，并确保我们在有限范围内构建的内容仍然非常类似于在现实世界应用程序中构建的内容！
- en: Creating our project
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的项目
- en: 'Similar to the previous project, we''ll start off by creating a new project
    with Create React App, which we''ll call `todoifier`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个项目类似，我们将使用 Create React App 创建一个新的项目，我们将称之为 `todoifier`：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After the project has been created, we''ll also verify that everything was
    set up correctly and runs by running `start` on the project:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目创建完成后，我们将通过在项目上运行 `start` 来验证一切是否正确设置并运行：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Initializing our components to build on top off
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化我们的组件以构建在之上
- en: 'Whenever you''re building your project, you should strive to keep the top-level
    component, which is `src/App.js` in our case, as simple as possible and keep as
    little code in it as you possibly can. In our case, we''re just going to remove
    everything (similar to the work we did in the previous chapter, [Chapter 1](f616eaec-1edb-44b2-bc14-7fec21a70501.xhtml),
    *Introducing Create React App 2*) and replace it with a simple replacement header
    and not much else:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建你的项目时，你应该努力使顶级组件（在我们的例子中是 `src/App.js`）尽可能简单，并尽可能少地将其中的代码放入其中。在我们的例子中，我们将移除所有内容（类似于我们在上一章[第1章](f616eaec-1edb-44b2-bc14-7fec21a70501.xhtml)，*介绍
    Create React App 2*)中完成的工作，并用一个简单的替换标题和一些其他内容来替换它：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We'll also want to remove everything from `App.css`, since we're taking a blank-slate
    approach with this project as well!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望从 `App.css` 中移除所有内容，因为我们在这个项目中也将采取空白石板的方法！
- en: Building separate components in separate files
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在单独的文件中构建独立的组件
- en: One of the nicest things about Create React App is how simple it makes even
    the process of importing other files as their own separate React components without
    you really having to think about how Webpack is organizing everything. We're going
    to build a new simple component to get started with. Let's create a `Todo` component
    to keep track of each of the `Todo` items we'll need to add as we go along.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Create React App 最令人愉快的事情之一是它使导入其他文件作为它们自己的独立 React 组件的过程变得非常简单，而无需你真正思考 Webpack
    如何组织一切。我们将从构建一个新的简单组件开始。让我们创建一个 `Todo` 组件来跟踪我们将需要添加的每个 `Todo` 项目。
- en: 'Back over in `src/Todo.js`, we''ll want to duplicate everything from `App.js`
    (except the string in the `className` property and the function name):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/Todo.js` 中，我们希望复制 `App.js` 中的所有内容（除了 `className` 属性中的字符串和函数名）：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There''s nothing exciting to talk about here, so we''ll keep forging ahead!
    We should also create a `Todo.css` file to make sure our component does not remain
    unstyled:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么令人兴奋的内容可以讨论，所以我们将继续前进！我们还应该创建一个 `Todo.css` 文件，以确保我们的组件不被未设置样式：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Without doing anything, we won''t see the results of our fancy new `Todo` component
    that we just created, so we''ll need to head back to `src/App.js` and change the
    code. We''ll start by adding an `import` statement at the top for the `Todo` component!
    Remember, we''re loading this file from the local filesystem and not some installed
    dependency:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不做任何事情，我们将看不到我们刚刚创建的华丽新 `Todo` 组件的结果，因此我们需要回到 `src/App.js` 并更改代码。我们将从在顶部添加一个
    `import` 语句来导入 `Todo` 组件开始！记住，我们是从本地文件系统加载这个文件，而不是从安装的依赖中加载：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We''ll also need to include the `Todo` component somewhere in the source so
    that it shows up when we re-render the page:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在源代码中包含 `Todo` 组件，以便在重新渲染页面时显示：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All we've added here is the `Todo` component, which is getting rendered in the
    main root `div` of the `App` component. When the browser refreshes (assuming you've
    saved), you should see the `Todo` component show up and be ready to go!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里添加的只是 `Todo` 组件，它被渲染在 `App` 组件的主根 `div` 中。当浏览器刷新（假设你已经保存），你应该能看到 `Todo`
    组件出现并准备好使用！
- en: The exciting part of this whole process is that we've already introduced better
    code standards and reusability by doing this. The `Todo` component has been fully
    extracted out, so if we wanted to include multiple `Todo` components in our `App`,
    we could do so without having to do anything more complicated than copying and
    pasting a few lines of code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个整个过程最令人兴奋的部分是，我们已经通过这种方式引入了更好的代码标准和可复用性。`Todo`组件已经被完全提取出来，所以如果我们想在`App`组件中包含多个`Todo`组件，我们只需复制粘贴几行代码，而不需要做任何更复杂的事情。
- en: 'This sounds pretty great, so let''s try it out ourselves and verify that it
    all works as we expect. Back in the `App` component, add a few more `Todo` components
    as JSX tags:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来相当不错，所以让我们自己尝试一下，验证一切是否如我们所预期。回到`App`组件，添加一些更多的`Todo`组件作为JSX标签：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When we have our `Todo` declared twice in the root of our `App` component,
    we should see those two show up:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`App`组件的根目录中声明两次`Todo`时，我们应该看到这两个组件出现：
- en: '![](img/a90cdac8-cead-492d-974b-1632fb3e266c.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a90cdac8-cead-492d-974b-1632fb3e266c.png)'
- en: With that, we've gotten a nice clean amount of reusability and have had to put
    in almost no effort! The problem that still exists, though, is that there is no
    variation here. The components are just blindly repeated over and over, and we'd
    much rather this do something such as display some different content per each
    `Todo`. We can make that work in React by introducing two new concepts: **state**
    and **props**! We'll get to state in a little bit, so let's start off with props
    to get this all implemented in the simplest way possible.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们得到了相当多的可复用性，而且几乎不需要付出任何努力！然而，存在的问题是这里没有变化。组件只是盲目地重复，我们更希望它能够做些不同的事情，比如为每个`Todo`显示不同的内容。我们可以通过引入两个新概念来实现这一点：**状态**和**属性**！我们稍后会谈到状态，让我们先从属性开始，以尽可能简单的方式实现所有这些。
- en: Introducing props
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍props
- en: So, what are props? Props are shorthand for *properties*, and as you can guess,
    they define properties inside of our React components. Generally speaking, these
    get passed in from the parent, although they can get passed in from anywhere,
    truth be told.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是props？Props是*属性*的缩写，正如你可以猜到的，它们定义了我们React组件内部的属性。一般来说，这些属性是从父组件传递过来的，尽管实际上它们可以从任何地方传递过来。
- en: Right now, we're just using a simple functional component, and that function
    doesn't specify any arguments as part of its signature, so if we want to start
    using props we'll have to change that first.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只是使用一个简单的函数组件，而这个函数在其签名中并没有指定任何参数，所以如果我们想开始使用props，我们首先需要改变这一点。
- en: 'Let''s open up our `Todo` component in `src/Todo.js`, and change the function
    declaration to also pass in a `props` argument:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`Todo`组件在`src/Todo.js`中的代码，并将函数声明更改为传递一个`props`参数：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This would roughly be the equivalent of us writing the following in vanilla
    JavaScript:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这大致相当于我们用纯JavaScript编写以下内容：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we''ll have to change the display text to actually use something from
    our `props` argument, so we''ll add a reference to `{props.description}`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须更改显示文本，以便实际使用`props`参数中的某个内容，所以我们将添加对`{props.description}`的引用：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Save the file, because now we''ll have to head back over to our primary `App`
    component (`src/App.js`) and start passing in the `description` as part of the
    properties passed in to our `Todo` components:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，因为我们现在需要回到我们的主要`App`组件（`src/App.js`）并开始将`description`作为属性传递给我们的`Todo`组件：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After saving the file and seeing the browser window refresh, we should expect
    to see the properties we just entered now show up in the browser, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并看到浏览器窗口刷新后，我们应该期望看到我们刚刚输入的属性现在显示在浏览器中，如下所示：
- en: '![](img/8f804268-9afe-4846-98cb-c0735cd3d98e.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f804268-9afe-4846-98cb-c0735cd3d98e.png)'
- en: And there we are! Reusable, modifiable components, done with almost no effort
    at all!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！可复用、可修改的组件，几乎不需要任何努力就完成了！
- en: The even better part is that any changes to `props` will trigger React to re-render
    that component (depending on what changed and where it changed). This is something
    that is profoundly useful, especially when you factor in that the old world had
    you checking for changes, and then trying to either delete and recreate elements
    on the fly or try to sneak the changes in without having to remove it all away.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的部分是，对`props`的任何更改都会触发React重新渲染该组件（取决于更改了什么以及在哪里更改）。这非常有用，尤其是在考虑到旧世界需要你检查更改，然后尝试在飞行中删除和重新创建元素，或者试图在不删除所有内容的情况下悄悄地更改更改的情况下。
- en: Props are great, overall, but if we want to do something a little more permanent
    and something that is better for storing how something changes over time, we need
    to introduce the concept of state. Instead of props, state is meant to be used
    for something that is changing all of the time, generally local to a single component;
    you'll pass the state down to child components that need it via props.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Props总体来说很棒，但如果我们想要做一些更持久的事情，或者更好地存储随时间变化的东西，我们需要引入状态的概念。与props不同，状态是用来表示不断变化的东西的，通常局部于单个组件；你将通过props将状态传递给需要它的子组件。
- en: The trouble is that we're currently using functional components, which is fine
    for now, but the minute we want to start tracking any sort of internal state,
    we'll need to switch to a different method of creating our React components.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们目前使用的是函数组件，这对于现在来说是可以的，但当我们想要开始跟踪任何类型的内部状态时，我们就需要切换到创建React组件的不同方法。
- en: Writing a class-based component
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写基于类的组件
- en: In **ECMAScript 6** (**ES6**), we got our first taste of real object-oriented
    programming in JavaScript with **Classes**. A class is declared in a fundamentally
    different way than our functional components, but most of the core tenets remain
    the same and there's not a huge amount more we need to learn to start using them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在**ECMAScript 6**（**ES6**）中，我们第一次在JavaScript中尝到了真正的面向对象编程的滋味，那就是**类**。类的声明方式与我们的函数组件有根本的不同，但大部分核心原则仍然相同，我们不需要学习太多就可以开始使用它们。
- en: 'The first thing we''ll need to do is make a small modification to the `import`
    statement in `src/Todo.js`. We''ll need to `import` not just React itself: we''ll
    also need to `import` a particular named export specified in React, something
    called `Component`**.** Let''s take a look at what the new `import` statement
    looks like:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是对`src/Todo.js`中的`import`语句进行一些小的修改。我们需要`import`的不只是React本身：我们还需要`import`React中指定的一个命名导出，称为`Component`**。**让我们看看新的`import`语句是什么样子的：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have our `Component` imported as well, so let''s explore the syntax for
    declaring a `class`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经导入了`Component`，所以让我们看看声明`class`的语法：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This tells JavaScript that we''re building a new `Todo` class that inherits
    the functionality of `Component` (thus the `extends` keyword). Next, any React
    component we build as an ES6 class needs to have a `render()` function declared.
    To declare a function inside of a class, you just write the name, the arguments,
    and then the body inside of your class definition:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉JavaScript我们正在构建一个新的`Todo`类，它继承自`Component`的功能（因此有`extends`关键字）。接下来，任何作为ES6类构建的React组件都需要声明一个`render()`函数。要在类中声明一个函数，你只需在类定义中写出名称、参数和函数体：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'React specifically requires us to declare a `render()` function with no arguments,
    as we mentioned earlier. Our `return` statement is identical to what we had in
    our previous functional component, so putting everything together we should end
    up with something similar to this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: React特别要求我们声明一个不带参数的`render()`函数，正如我们之前提到的。我们的`return`语句与我们在之前的函数组件中的相同，所以将所有内容组合起来，我们应该得到类似以下的内容：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we write out our `render() { … }` function, which is largely unchanged
    except for one small change: `props.description` is now `this.props.description`!'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们编写我们的`render() { … }`函数，它基本上没有变化，除了一个小变化：`props.description`现在变成了`this.props.description`！
- en: The reason for this is that props is not something that is just an argument
    on a function anymore. It's actually part of a class-specific property, so we
    need to tell JavaScript that when we say `props`, we actually mean the *props
    local to this class*. We just shorthand that with `this.props`! With that out
    of the way, we can start diving even further into the world of state!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于props不再是函数的简单参数了。它实际上是类特定属性的一部分，因此我们需要告诉JavaScript当我们说`props`时，我们实际上是指这个类的*局部props*。我们只是用`this.props`来简写它！这样我们就解决了这个问题，接下来我们可以更深入地探索状态的世界！
- en: Bringing state into our component
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将状态引入我们的组件
- en: 'Part of declaring state to a class component is to start off with an initial
    or default state. We can''t do that without telling JavaScript what to do when
    our class is actually instantiated, so our class will need to have a `constructor`
    to handle that work. In our `Todo` class, we''ll build out our `constructor` function,
    which will take in `props` as its single argument:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 声明状态到类组件的一部分是开始一个初始或默认状态。如果我们不告诉JavaScript当我们的类实际实例化时应该做什么，我们就无法做到这一点，所以我们的类需要一个`constructor`来处理这项工作。在我们的`Todo`类中，我们将构建我们的`constructor`函数，它将`props`作为其单个参数接收：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'JavaScript knows to use `constructor()` as our constructor since that is a
    language construct, and we know it needs to take in `props`. Since we''re extending
    off of React''s `Component` class, we need to call `super()` as our first line
    of code in `constructor()`. This tells JavaScript to instead use the code in `constructor()`
    of `Component` to set up whatever it needs to. Next, we set the state by declaring
    a new variable attached to our class called, uninterestingly enough, `this.state`.
    We make it a plain object with a key of `description`, which just stores the passed-in
    description on the `props` argument. It also has a property called `done` that
    starts off with a default value of `false` (since we should not create our tasks
    as already done). This code by itself won''t actually do anything, so let''s also
    change our `render()` function to take advantage of our `state`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript知道使用`constructor()`作为我们的构造函数，因为这是一个语言构造，我们知道它需要接收`props`。由于我们是在扩展React的`Component`类，我们需要在`constructor()`的第一行代码中调用`super()`。这告诉JavaScript使用`Component`的`constructor()`中的代码来设置它需要设置的内容。接下来，我们通过声明一个新变量并将其附加到我们的类上，命名为（有点无聊地）`this.state`来设置状态。我们将其设为一个带有`description`键的普通对象，它只是存储在`props`参数上传递的描述。它还有一个名为`done`的属性，初始值为`false`（因为我们不应该创建已经完成的任务）。仅此代码本身并不会做任何事情，所以让我们也改变我们的`render()`函数以利用我们的`state`：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Nothing has quite changed yet. Instead, we'll need to add some form of interactivity
    to make the case for using `state` really known!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有什么变化。相反，我们需要添加某种形式的交互性，以真正了解使用`state`的好处！
- en: Adding interactivity via state modifications
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过状态修改添加交互性
- en: 'We''ll add a very simple `button` to our `Todo` component called `Mark as Done`.
    When clicked, this `button` should change our `state` `done` status for that `Todo`
    item to `true`. Now, we''ll want to make sure that anything that does change is
    only changed on this component and not all components, which is a big part of
    using internal state! Let''s first build out our `markAsDone()` function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的`Todo`组件中添加一个非常简单的`button`，命名为`Mark as Done`。当点击时，这个`button`应该将这个`Todo`项的`state`
    `done`状态改为`true`。现在，我们想要确保只有在这个组件上改变，而不是所有组件上改变，这是使用内部状态的一个重要部分！让我们首先构建我们的`markAsDone()`函数：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'That being done, we can move on to implementing our functionality by including
    our `Mark as Done` button:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 做完这些后，我们可以继续实现我们的功能，包括我们的`Mark as Done`按钮：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, if we just hit save, wait for the refresh, and try to click the `markAsDone`
    button, we''ll end up getting an error message:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们只是保存，等待刷新，然后尝试点击`markAsDone`按钮，我们最终会得到一个错误信息：
- en: '![](img/78fdf8b7-7d30-450a-844d-3f08127182f1.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/78fdf8b7-7d30-450a-844d-3f08127182f1.png)'
- en: 'Let''s explore this error message a little more. We''re getting a TypeError:
    this is undefined message, here, and it''s not the most clear error message in
    the world, certainly. This is one of the drawbacks of using ES6 classes with any
    sort of React component in combination with JavaScript event handlers. So in this
    case, when we have our `onClick` calling out to `this.markAsDone`, and the function
    goes into the body of `markAsDone`, it tries to call `this.setState` but it doesn''t
    actually understand what `this` is trying to reference! This only happens with
    event handlers, so we don''t need to worry about this all of the time. The good
    news is that there is a simple means of fixing this issue. Let''s add one more
    line back to our `constructor`, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们更深入地探索这个错误信息。我们得到了一个TypeError: this is undefined的消息，这绝对不是世界上最清晰的错误信息，当然。这是使用ES6类与任何类型的React组件以及JavaScript事件处理器结合使用的一个缺点。所以在这种情况下，当我们的`onClick`调用`this.markAsDone`时，函数进入`markAsDone`的主体，它试图调用`this.setState`，但它实际上并不理解`this`试图引用什么！这仅发生在事件处理器中，所以我们不需要总是担心这个问题。好消息是，有一个简单的方法可以解决这个问题。让我们在我们的`constructor`中再添加一行，如下所示：'
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This tells JavaScript that if it ever sees a reference to `this` inside of the
    `markAsDone` function, it is a specific reference to the `Todo` class. Save the
    file and click the button—it works! Well, you can't tell whether it works yet.
    We'll need to add a little bit of visual indication that it has worked.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉JavaScript，如果它看到`markAsDone`函数内部对`this`的引用，它是对`Todo`类的特定引用。保存文件并点击按钮——它工作了！好吧，你还不能确定它是否真的工作。我们需要添加一些视觉指示来表明它已经工作。
- en: Indicating our state with CSS
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CSS表示我们的状态
- en: 'We''re very close to this working perfectly, but we''re missing a little bit
    of code to tell our React component to know when to use certain CSS classes. Let''s
    start by adding a new function, `cssClasses()`, which will return a list of CSS
    classes to include in our component:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作几乎已经完美无缺，但我们还缺少一些代码来告诉我们的 React 组件何时使用某些 CSS 类。让我们先添加一个新函数 `cssClasses()`，它将返回一个包含在我们组件中的
    CSS 类列表：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There''s nothing particularly special about this other than the use of the
    JavaScript spread operator (the `...classes` bit). This is just a way for us to
    add on to the end of the array in a safe way. Next, we''ll change the logic where
    we declare `className` for our component to use this new function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的特别之处仅在于使用了 JavaScript 扩展运算符（即 `...classes` 部分）。这仅仅是我们以安全的方式向数组末尾添加内容的一种方法。接下来，我们将改变声明我们组件的
    `className` 的逻辑，以便使用这个新函数：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, in `src/Todo.css`, add the new `.Done` CSS class definition:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `src/Todo.css` 中添加新的 `.Done` CSS 类定义：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And now, we can see the result when we click on one of the Mark as Done buttons:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到点击标记为完成的按钮时的结果：
- en: '![](img/293ea9dd-06cc-4f8a-8da6-70cfa687c5f3.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/293ea9dd-06cc-4f8a-8da6-70cfa687c5f3.png)'
- en: Iterating our project further
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步迭代我们的项目
- en: Okay, we have some state and some props in each component; we have components
    that can be used and reused as needed, we can see a little bit of interactivity,
    and we have great separation of each of our components. This brings us a little
    closer to writing more difficult and complex React components. More importantly,
    we're getting to build a larger, more complex application that will require some
    of the bells and whistles that we get as part of Create React App's toolset.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，每个组件中都有一些状态和属性；我们有可以按需使用和重用的组件，我们可以看到一点交互性，并且我们组件之间的分离做得很好。这让我们离编写更复杂和困难的
    React 组件更近了一步。更重要的是，我们正在构建一个更大、更复杂的应用程序，这将需要我们作为 Create React App 工具集一部分的一些功能。
- en: Building a List component
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建列表组件
- en: Let’s take things a step further with our `Todo` components and actually create
    a dynamic list of components that we can add to! We’ll need to start by adding
    a new `TodoList` that is in charge of rendering our list of `Todo` components!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步扩展我们的 `Todo` 组件，并实际创建一个动态的组件列表，我们可以将其添加到列表中！我们需要首先添加一个新的 `TodoList`，它负责渲染我们的
    `Todo` 组件列表！
- en: 'We''ll start by adding two new files to handle our list of Todos: `src/TodoList.js`
    and `src/TodoList.css`. In our `src/TodoList.js` file, we''ll start off with a
    pretty standard React scaffold (you''ll be writing something similar to this pretty
    often, so this will become second nature very quickly):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加两个新文件来处理我们的 `Todo` 列表：`src/TodoList.js` 和 `src/TodoList.css`。在我们的 `src/TodoList.js`
    文件中，我们将从一个相当标准的 React 框架开始（你将经常编写类似的内容，所以这会很快成为你的第二天性）：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that the body of our class is empty right now. We''ll next need to add
    a `render()` function, so let''s jump right to that:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们类的主体目前是空的。接下来，我们需要添加一个 `render()` 函数，让我们直接跳到那里：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We''ll also need to modify our style sheet for the `TodoList` so it''s not
    just completely default:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改 `TodoList` 的样式表，使其不仅仅是默认的：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Adding the TodoList to our App
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 TodoList 添加到我们的 App 中
- en: 'Right now, we just display a list of `Todo` items through copying and pasting
    the component a bunch of times, but that''s not very interesting, nor is it good
    programming practice! Instead, let''s add our `List` component to our `App` and
    have that be responsible for handling multiple items. We''ll start off by importing
    our new `TodoList` component from the local filesystem into `src/App.js`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只是通过复制粘贴组件多次来显示 `Todo` 项的列表，但这并不有趣，也不是好的编程实践！相反，让我们将我们的 `List` 组件添加到 `App`
    中，并使其负责处理多个项。我们将首先从本地文件系统导入新的 `TodoList` 组件到 `src/App.js`：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We''ll also need to change the `render()` function to use the `TodoList` component,
    instead of the two `Todo` components directly:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改 `render()` 函数，以便使用 `TodoList` 组件，而不是直接使用两个 `Todo` 组件：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Everything should look almost the same, except since we changed the style sheet
    a little bit there should be a clean little blue box around the entire list. This
    helps us see the distinction between each component and the parent components
    surrounding it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来几乎都一样，但因为我们稍微改变了样式表，所以整个列表周围应该有一个干净的蓝色框。这有助于我们区分每个组件及其周围的父组件。
- en: Adding state to TodoList
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 TodoList 添加状态
- en: 'We''ll need some `state` in `src/TodoList.js` before we can do much else, so
    we''ll just create an initial `state` that''s not too exciting but gets the job
    done. Add a `constructor` to the `TodoList` component and give it the following
    body:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够做更多事情之前，我们需要在 `src/TodoList.js` 中添加一些 `state`，所以我们将创建一个初始的 `state`，它可能不是那么令人兴奋，但能完成任务。给
    `TodoList` 组件添加一个 `constructor`，并给它以下内容：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Creating and using a helper render() function
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和使用辅助的 render() 函数
- en: Creating and initializing state but not doing anything with it doesn't help
    us very much, so we'll want to make sure that all of the JSX is built with the
    help of our state! We'll have to loop over each `Todo` item that is stored in
    our `state`, which we'll name `this.state.items`, and for each item we'll render
    the `Todo` component and, using props, pass in the `description` of that `Todo`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和初始化状态，但不使用它对我们帮助不大，所以我们要确保所有的 JSX 都是在我们状态的帮助下构建的！我们必须遍历存储在我们状态中的每个 `Todo`
    项目，我们将它命名为 `this.state.items`，对于每个项目，我们将渲染 `Todo` 组件，并使用属性传递该 `Todo` 的 `description`。
- en: 'We''re going to use the `map` function here specifically since `map` will iterate
    over each item, perform a function, and then store the results as an array. JSX
    is expecting us to return either a single JSX element or an array of JSX elements,
    so this will fit our needs quite nicely. We''ll also delegate this task to a new
    function called `renderItems()` to make sure each of our functions serves a single
    small purpose:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里特别使用 `map` 函数，因为 `map` 将遍历每个项目，执行一个函数，然后将结果存储为数组。JSX 期望我们返回一个单一的 JSX 元素或一个
    JSX 元素的数组，所以这非常适合我们的需求。我们还将把这个任务委托给一个新的函数，称为 `renderItems()`，以确保我们的每个函数都服务于单一的小目标：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The only new thing here is the addition of the `key` property. This is an important
    part of adding multiple items in React via JSX: React has to know how to reference
    the item in question in some sort of unique way. If React is going to change something,
    delete it, or otherwise affect the DOM, it has to have something to reference
    the specific item by.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的新增是添加了 `key` 属性。这是在 React 中通过 JSX 添加多个项目的一个重要部分：React 必须以某种独特的方式知道如何引用相关项目。如果
    React 要更改某些内容、删除它或以其他方式影响 DOM，它必须有一些东西可以用来引用特定的项目。
- en: We're not actually guaranteeing much of anything here with the list of names;
    if we end up with any duplicates it will cause us issues, but this is just our
    naive implementation for now.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们并没有对名字列表做出任何保证；如果我们最终出现任何重复，这将会给我们带来问题，但这是我们现在的天真实现。
- en: 'Return back to the `render()` function and we''ll add a reference to our new `renderItems()`
    function instead of the multiple calls to `Todo`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 `render()` 函数，我们将添加对新创建的 `renderItems()` 函数的引用，而不是对 `Todo` 的多次调用：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Just to be extra sure, let''s also add a third item back in our `constructor`
    to our initial state. If we can verify this as well, then we know we''ve implemented
    everything correctly:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更加确信，让我们也在 `constructor` 中添加第三个项目到我们的初始状态。如果我们也能验证这一点，那么我们就知道我们已经正确地实现了所有内容：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There we are! Three items, all working appropriately, and all functioning entirely
    off of the `state`! That's a pretty good measure of progress!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！三个项目，都按预期工作，并且完全依赖于 `state`！这是一个相当好的进度指标！
- en: Creating a new Todo component
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的 Todo 组件
- en: 'Now that we have a good initial pass at dynamic state affecting our DOM, it''s
    time to create a new component that will allow us to add additional `Todo` items
    to our `TodoList`. We''ll call this, well, `NewTodo`! Create `src/NewTodo.js`
    and `src/NewTodo.css` to start, as per usual. Then, in `src/NewTodo.css`, give
    it some default style:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对动态状态影响我们的 DOM 有了一个良好的初始尝试，是时候创建一个新的组件，允许我们向 `TodoList` 添加额外的 `Todo` 项目了。我们将称之为
    `NewTodo`！按照惯例，首先创建 `src/NewTodo.js` 和 `src/NewTodo.css`。然后在 `src/NewTodo.css`
    中，给它一些默认样式：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And then, it''s time for us to build out our `NewTodo` component! We start
    off with our React boilerplate code that we do all the time:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，是我们构建 `NewTodo` 组件的时候了！我们开始于我们经常使用的 React 模板代码：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we''ll build out our `constructor()` function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建我们的 `constructor()` 函数：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We start off with our call to `super()`, same as always. Next, we''ll set up
    an initial state with an `item` property that starts off blank (more on this later).
    We''ll also need to write something to handle updates, so we''ll write a`bind`
    statement on a `handleUpdate()` function (which we''ll write next):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始于对 `super()` 的调用，就像往常一样。接下来，我们将设置一个初始状态，其中包含一个 `item` 属性，它一开始是空的（关于这一点我们稍后再说）。我们还需要编写一些处理更新的内容，所以我们将在一个
    `handleUpdate()` 函数上编写一个 `bind` 语句（我们将在下一个步骤中编写）：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So, when `handleUpdate()` is called, it is going to take a DOM event, which
    if we wanted to get the value of the input that is changing, we''d grab it via `event.target.value`.
    Finally, let''s hit up our `render()` function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当 `handleUpdate()` 被调用时，它将接收一个 DOM 事件，如果我们想获取正在更改的输入的值，我们可以通过 `event.target.value`
    来获取它。最后，让我们调用我们的 `render()` 函数：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Most of this code is unremarkable, but note that we have an `input` here, which
    is a `text` type, which reacts to every time the input's value is changed by delegating
    the handler to the `handleUpdate()` function we already wrote!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码大部分都很普通，但请注意，我们这里有一个 `input`，它是一个 `text` 类型，每次输入值改变时都会通过委托处理程序到我们已编写的 `handleUpdate()`
    函数来响应！
- en: 'It''s time to head back to our `TodoList`, import the `NewTodo` component,
    and add it near the top of our call to `render()`. At the top of `src/TodoList.js`,
    add the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候回到我们的 `TodoList`，导入 `NewTodo` 组件，并将其添加到 `render()` 调用的顶部。在 `src/TodoList.js`
    的顶部添加以下内容：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And then, add `NewTodo` into the `render()` function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将 `NewTodo` 添加到 `render()` 函数中：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Passing a function as a prop
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数作为属性传递
- en: 'This introduces a very interesting *chicken and egg* sort of scenario: how
    do we add a component to a parent from the child component? The list of `Todo`
    items lives in `TodoList`, and our component where we need to add new Todos is
    a separate component that lives inside of `TodoList`! There''s no internal state
    for a list of Todos in `NewTodo`, so how do we make this work?'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这引入了一个非常有趣的“鸡生蛋，蛋生鸡”的场景：我们如何从子组件向父组件添加组件？`Todo` 项的列表位于 `TodoList` 中，而我们需要添加新
    `Todo` 的组件是一个独立的组件，它位于 `TodoList` 内部！`NewTodo` 中没有 `Todo` 列表的内部状态，那么我们如何让它工作呢？
- en: 'Easy! We''ll create a function in `TodoList`, which can modify its list of
    components, and then pass that function into our `NewTodo` component. So, inside
    of `src/TodoList.js`, we''ll need to add a new function called `addTodo()` and
    we will have to make sure it includes a `bind()` statement so that no matter where
    that function lives, it knows how to handle references to `this`. In the `constructor`,
    add our `bind` statement:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 简单！我们将在 `TodoList` 中创建一个函数，该函数可以修改其组件列表，然后将其传递给我们的 `NewTodo` 组件。所以，在 `src/TodoList.js`
    中，我们需要添加一个名为 `addTodo()` 的新函数，并确保它包含一个 `bind()` 语句，这样无论该函数在哪里，它都知道如何处理对 `this`
    的引用。在 `constructor` 中添加我们的 `bind` 语句：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s move on to writing our `addTodo()` function. We''ll accept a single
    string, which will be the description that we add. The good news is that this
    function is super easy to write:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续编写我们的 `addTodo()` 函数。我们将接受一个单独的字符串，它将是我们添加的描述。好消息是这个函数非常容易编写：
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We''re using some new JavaScript syntax here, an array spread. This allows
    us to essentially take a shortcut with adding new items! Essentially, we want
    to add new items onto the list of items in the `state`, but we want to do so in
    a way that is non-destructive. This will make a modified copy of the item list
    and preserve the original. We set the list of items equal to this newly-modified
    array and that''s it! All we have to do next is just pass this new `addTodo` function
    to `NewTodo` as a prop:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了一些新的 JavaScript 语法，一个数组展开。这允许我们本质上通过添加新项目来简化操作！本质上，我们想要将新项目添加到 `state`
    中的项目列表中，但我们希望以一种非破坏性的方式做到这一点。这将创建一个修改后的项目列表副本并保留原始列表。我们将项目列表设置为这个新修改后的数组，这就完成了！我们接下来要做的就是只需将这个新的
    `addTodo` 函数作为属性传递给 `NewTodo`：
- en: '[PRE42]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s hop back over to `src/NewTodo.js`. We''ll need to duplicate our function
    name, so we''ll add an `addTodo` function inside of `NewTodo`. This is going to
    be called via a JavaScript event handler, so we''ll need to add a `bind` statement
    for it inside of our `constructor`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `src/NewTodo.js`。我们需要复制我们的函数名，所以我们在 `NewTodo` 中添加一个 `addTodo` 函数。这个函数将通过
    JavaScript 事件处理程序来调用，所以我们需要在 `constructor` 中为它添加一个 `bind` 语句：
- en: '[PRE43]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And, note the following for our `addTodo()` function body:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容，关于我们的 `addTodo()` 函数体：
- en: '[PRE44]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Remember the `addTodo()` function that we passed down via props? We''ll need
    to call that function via the props on the object and pass in the `item` property
    inside of our `state`. Remember, `item` is the value that is getting updated all
    of the time via our `onChange` event handlers! Finally, let''s modify `render()`
    to put it all together:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们通过属性传递下来的 `addTodo()` 函数吗？我们需要通过对象上的属性调用该函数，并将 `state` 中的 `item` 属性传递进去。记住，`item`
    是通过我们的 `onChange` 事件处理程序不断更新的值！最后，让我们修改 `render()` 来将其全部组合起来：
- en: '[PRE45]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We need to add a new value property and set it to the current value of the `item`
    property from our `state`. Without doing this, we won't be able to see what is
    going on when we clear out the state's `item` property. Finally, we added a new
    `onClick` event handler that just calls out to `addTodo`, just like we prepared
    for!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个新的值属性，并将其设置为`state`中`item`属性的当前值。如果不这样做，我们就无法看到当我们清除`state`的`item`属性时发生了什么。最后，我们添加了一个新的`onClick`事件处理程序，它只是调用`addTodo`，就像我们准备的那样！
- en: 'Test it out and there we go: interactivity!'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下，我们就有了：交互性！
- en: Removing items is important too
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除项目同样重要
- en: 'If we''re adding items, we should remove them too, so we''ll implement a `removeTodo()`
    function in the `TodoList`, and then that will get passed down into each `Todo`.
    This is very similar to what we did in the `NewTodo` component. We''ll need to
    follow the same steps: add a `bind` statement, write the `removeTodo()`function,
    and implement calling it in the `Todo` component.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在添加项目，我们也应该删除它们，所以我们在`TodoList`中实现一个`removeTodo()`函数，然后它将传递到每个`Todo`中。这与我们在`NewTodo`组件中所做的是非常相似的。我们需要遵循相同的步骤：添加一个`bind`语句，编写`removeTodo()`函数，并在`Todo`组件中实现调用它。
- en: 'First, the `bind` in `src/TodoList.js` is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`src/TodoList.js`中的`bind`如下所示：
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we''ll implement the `removeTodo()` function. We''ll `filter` out any
    Todos that match the item we want to remove and set that as the new list of Todos:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现`removeTodo()`函数。我们将`filter`掉任何匹配我们要删除的项目的新Todos列表：
- en: '[PRE47]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The final thing we need to do is change the `renderItems()` call so that it
    passes this new function down to each `Todo`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是更改`renderItems()`调用，以便将这个新函数传递给每个`Todo`：
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we''re ready to implement this in the child component. Open up `src/Todo.js`,
    and we''ll implement a duplicate-named `removeTodo()` function inside of the `Todo`
    component. We''ll also need a `bind`, so we''ll start this implementation in the
    `constructor`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备在子组件中实现这个功能。打开`src/Todo.js`，我们将在`Todo`组件内部实现一个同名`removeTodo()`函数。我们还需要一个`bind`，所以我们将从`constructor`开始这个实现：
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And, we''ll write the `removeTodo()` function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将编写`removeTodo()`函数：
- en: '[PRE50]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The last thing we need to do is add a call, via a `button` and an `onClick`
    event handler, and call the component''s `removeTodo()` function:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是通过一个`button`和一个`onClick`事件处理程序添加一个调用，并调用组件的`removeTodo()`函数：
- en: '[PRE51]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'After saving and the browser refreshing, you should now be able to add and
    remove items on the fly! Full interactivity! Refer to the following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 保存后刷新浏览器，你现在应该能够即时添加和删除项目！完全的交互性！请参考以下截图：
- en: '![](img/b9c39065-0d21-4a77-b830-7688b927f879.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9c39065-0d21-4a77-b830-7688b927f879.png)'
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'By now, you should have a strong grasp on React, how React functions, how to
    write good JSX and React code, and a bunch of the different gotchas and concerns
    you can run into. We covered all of this while still getting work done without
    ever having to go outside of Create React App. Now, we should have the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该对React有了深刻的理解，包括React的工作原理、如何编写良好的JSX和React代码，以及你可能会遇到的各种问题和关注点。我们在完成工作的同时涵盖了所有这些内容，而且从未需要离开Create
    React App。现在，我们应该有以下几点：
- en: A working Create React App project
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正在工作的Create React App项目
- en: A more complicated application structure
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更复杂的应用程序结构
- en: An understanding of how to affect parent structures by passing variables and
    functions as properties
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何通过传递变量和函数作为属性来影响父结构
- en: How to bind functions that may be called from inside event handlers
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何绑定可能从事件处理程序内部调用的函数
- en: As we move on from this chapter, we'll dive more deeply into the other features
    of Create React App and the functionality it supports. It was important for us
    to have our application built and ready to go to give us room to iterate and explore
    the real depths of Create React App, so now that we're ready to go, we can have
    a lot more fun playing around with things!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续本章的学习，我们将更深入地探讨Create React App的其他功能和它所支持的功能。对我们来说，重要的是我们的应用程序已经构建并准备好，这样我们就有空间迭代和探索Create
    React App的真正深度。现在我们已经准备好了，我们可以尽情地玩转各种东西！
