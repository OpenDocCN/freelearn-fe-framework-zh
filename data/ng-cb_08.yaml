- en: '*Chapter 8*: Mastering Angular Forms'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：精通Angular表单'
- en: Getting user inputs is an integral part of almost any modern app that we use.
    Whether it is authenticating users, asking for feedback, or filling out business-critical
    forms, knowing how to implement and present forms to end users is always an interesting
    challenge. In this chapter, you'll learn about Angular forms and how you can create
    great user experiences using them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 获取用户输入是几乎任何现代应用程序的一个重要部分。无论是对用户进行身份验证、征求反馈意见，还是填写业务关键表单，知道如何实现和呈现表单给最终用户始终是一个有趣的挑战。在本章中，您将了解Angular表单以及如何使用它们创建出色的用户体验。
- en: 'Here are the recipes that we''re going to cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章将要涵盖的示例：
- en: Creating your first template-driven Angular form
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的第一个模板驱动Angular表单
- en: Form validation with template-driven forms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板驱动表单进行表单验证
- en: Testing template-driven forms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试模板驱动表单
- en: Creating your first Reactive form
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的第一个响应式表单
- en: Form validation with Reactive forms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用响应式表单进行表单验证
- en: Creating an asynchronous validator function
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个异步验证器函数
- en: Testing Reactive forms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试响应式表单
- en: Using debounce with Reactive form control
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用响应式表单控件进行去抖动
- en: Writing your own custom form control using `ControlValueAccessor`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ControlValueAccessor`编写自定义表单控件
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the recipes in this chapter, make sure you have **Git** and **NodeJS** installed
    on your machine. You also need to have the `@angular/cli` package installed, which
    you can do with `npm install -g @angular/cli` from your terminal. The code for
    this chapter can be found at [https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter08](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter08).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的示例，请确保您的计算机上已安装了**Git**和**NodeJS**。您还需要安装`@angular/cli`包，可以在终端中使用`npm install
    -g @angular/cli`来安装。本章的代码可以在[https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter08](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter08)找到。
- en: Creating your first template-driven Angular form
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个模板驱动Angular表单
- en: Let's start getting familiar with Angular forms in this recipe. In this one,
    you'll learn about the basic concepts of template-driven forms and will create
    a basic Angular form using the template-driven forms API.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这个示例中开始熟悉Angular表单。在这个示例中，您将了解模板驱动表单的基本概念，并将使用模板驱动表单API创建一个基本的Angular表单。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter08/start_here/template-driven-forms`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中的项目位于`chapter08/start_here/template-driven-forms`中：
- en: Open the project in Visual Studio Code.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab and you should see the following
    view:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在新的浏览器选项卡中打开应用程序，并且您应该看到以下视图：
- en: '![Figure 8.1 – Template-driven forms app running on http://localhost:4200'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1-在http://localhost:4200上运行的模板驱动表单应用程序'
- en: '](image/Figure_8.1_B15150.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.1_B15150.jpg)'
- en: Figure 8.1 – Template-driven forms app running on http://localhost:4200
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1-在http://localhost:4200上运行的模板驱动表单应用程序
- en: How to do it…
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We have an Angular app that already has a release log component and a bunch
    of things set up, such as the `ReleaseLog` class under the `src/app/classes` folder.
    So, in this recipe, we''ll create a template-driven form to allow the user to
    pick an app and submit a release version. Let''s get started:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个Angular应用程序，其中已经有一个发布日志组件和一堆设置，例如`src/app/classes`文件夹下的`ReleaseLog`类。因此，在这个示例中，我们将创建一个模板驱动表单，允许用户选择一个应用程序并提交一个发布版本。让我们开始吧：
- en: 'First, open the terminal in the project''s root and create a component for
    the release form as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在项目的根目录中打开终端，并创建一个发布表单组件，如下所示：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The command should create a new component in the `src/app/components` folder
    named `ReleaseFormComponent`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应在`src/app/components`文件夹中创建一个名为`ReleaseFormComponent`的新组件。
- en: 'Add the newly created component to the template of `VersionControlComponent`
    and modify the `version-control.component.html` file as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的组件添加到`VersionControlComponent`的模板中，并修改`version-control.component.html`文件如下：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, let's adjust some styles for the release form to be used within `VersionControlComponent`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们调整一些样式，以便在`VersionControlComponent`中使用发布表单。
- en: 'Modify the `version-control.component.scss` file as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`version-control.component.scss`文件如下：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We'll have two inputs in the `ReleaseFormComponent` template. One to select
    the app we want to release, and the second for the version we want to release.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ReleaseFormComponent`模板中，我们将有两个输入。一个用于选择我们要发布的应用程序，另一个用于我们要发布的版本。
- en: 'Let''s modify the `release-form.component.ts` file to add the `Apps` enum as
    a local property that we can later use in the template:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改`release-form.component.ts`文件，将`Apps`枚举添加为一个本地属性，以便我们稍后可以在模板中使用：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s now add the template for our form. Modify the `release-form.component.html`
    file and add the following code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们添加我们表单的模板。修改`release-form.component.html`文件，并添加以下代码：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We now need to integrate the template-driven form. Let''s add `FormsModule`
    to the `app.module.ts` file as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要集成模板驱动表单。让我们在`app.module.ts`文件中添加`FormsModule`，如下所示：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can now make our form work in the template. Let''s modify the `release-form.component.html`
    file to create a template variable for the form, named `#releaseForm`. We will
    also use the `[(ngModel)]` binding for both the inputs against appropriate values
    for the `newLog` property as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以让我们的表单在模板中工作。让我们修改`release-form.component.html`文件，为表单创建一个模板变量，命名为`#releaseForm`。我们还将使用`[(ngModel)]`绑定来针对`newLog`属性的适当值：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a method for when the form will be submitted. Modify the `release-form.component.ts`
    file to add a new method named `formSubmit`. When this method is called, we''ll
    emit a new instance of `ReleaseLog` using an Angular `@Output` emitter as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个当表单提交时将被调用的方法。修改`release-form.component.ts`文件，添加一个名为`formSubmit`的新方法。当调用此方法时，我们将使用Angular的`@Output`发射器发出`ReleaseLog`的新实例，如下所示：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Update the template now to use the `formSubmit` method on the form''s submission
    and modify the `release-form.component.html` file as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更新模板，使用表单提交上的`formSubmit`方法，并修改`release-form.component.html`文件如下：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We now need to modify `VersionControlComponent` to be able to act on the new
    release log emitted. In order to do so, modify the `version-control.component.html`
    file to listen to the `newReleaseLog` output event from `ReleaseFormComponent`
    as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要修改`VersionControlComponent`以便对新发布日志进行操作。为了这样做，修改`version-control.component.html`文件，以便监听来自`ReleaseFormComponent`的`newReleaseLog`输出事件，如下所示：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Cool! Let''s create the `addNewReleaseLog` method in the `version-control.component.ts`
    file and add the `ReleaseLog` received to the `releaseLogs` array. Your code should
    look as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太棒了！让我们在`version-control.component.ts`文件中创建`addNewReleaseLog`方法，并将接收到的`ReleaseLog`添加到`releaseLogs`数组中。您的代码应如下所示：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Awesome! Within a few minutes, we were able to create our first template-driven
    form in Angular. If you refresh the app now and try creating some releases, you
    should see something similar to the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！在几分钟内，我们就能够在Angular中创建我们的第一个模板驱动表单。如果现在刷新应用程序并尝试创建一些发布，您应该会看到类似以下内容的东西：
- en: '![Figure 8.2 – Template-driven forms app final output'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 - 模板驱动表单应用程序最终输出'
- en: '](image/Figure_8.2_B15150.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.2_B15150.jpg)'
- en: Figure 8.2 – Template-driven forms app final output
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 - 模板驱动表单应用程序最终输出
- en: Now that you know how the template-driven forms are created, let's see the next
    section to understand how it works.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何创建模板驱动表单，让我们看看下一节，了解它是如何工作的。
- en: How it works…
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The key to using template-driven forms in Angular resides in `FormsModule`,
    the `ngForm` directive, by creating a **template variable** using the `ngForm`
    directive and using the `[(ngModel)]` two-way data binding along with the `name`
    attributes for inputs in the template. We began by creating a simple form with
    some inputs. Then, we added the `FormsModule`, which is necessary for using the
    `ngForm` directive and the `[(ngModel)]` two-way data binding. Once we added the
    module, we could use both the directive and the data binding with our newly created
    local property named `newLog` in the `ReleaseFormComponent`. Notice that it could
    be an instance of the `ReleaseLog` class, but we kept it as an object of the `IReleaseLog`
    type instead because we don't want the `ReleaseLog` class's `message` property
    as we don't use it. With the `[(ngModel)]` usages and the `#releaseForm` template
    variable in place, we could submit the form using the `ngSubmit` emitter of Angular's
    `<form>` directive. Notice that we pass the `releaseForm` variable to the `formSubmit`
    method, which makes it easier to test the functionality for us. Upon submitting
    the form, we use the form's value to create a new `ReleaseLog` item and we emit
    it using the `newReleaseLog` output emitter. Notice that if you provide an invalid
    `version` for the new release log, the app will throw an error and will not create
    a release log. This is because we validate the version in the `constructor` of
    the `ReleaseLog` class. Finally, when this `newReleaseLog` event is captured by
    `VersionControlComponent`, it calls the `addNewReleaseLog` method, which adds
    our newly created release log to the `releaseLogs` array. And since the `releaseLogs`
    array is passed as an `@Input()` to `ReleaseLogsComponent`, it immediately shows
    it right away.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中使用模板驱动表单的关键在于`FormsModule`，`ngForm`指令，通过使用`ngForm`指令创建**模板变量**，并在模板中为输入使用`[(ngModel)]`双向数据绑定以及`name`属性。我们首先创建了一个带有一些输入的简单表单。然后，我们添加了`FormsModule`，这是必须的，用于使用`ngForm`指令和`[(ngModel)]`双向数据绑定。一旦我们添加了该模块，我们就可以在`ReleaseFormComponent`中使用该指令和数据绑定，使用新创建的本地属性命名为`newLog`。请注意，它可以是`ReleaseLog`类的实例，但我们将其保留为`IReleaseLog`类型的对象，因为我们不使用`ReleaseLog`类的`message`属性。通过使用`[(ngModel)]`和`#releaseForm`模板变量，我们可以使用Angular的`<form>`指令的`ngSubmit`发射器提交表单。请注意，我们将`releaseForm`变量传递给`formSubmit`方法，这样可以更容易地测试功能。提交表单时，我们使用表单的值创建一个新的`ReleaseLog`项目，并使用`newReleaseLog`输出发射器发射它。请注意，如果为新发布日志提供无效的`version`，应用程序将抛出错误并且不会创建发布日志。这是因为我们在`ReleaseLog`类的`constructor`中验证了版本。最后，当`VersionControlComponent`捕获到`newReleaseLog`事件时，它调用`addNewReleaseLog`方法，将我们新创建的发布日志添加到`releaseLogs`数组中。由于`releaseLogs`数组作为`@Input()`传递给`ReleaseLogsComponent`，因此它会立即显示出来。
- en: See also
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Building a template-driven form in Angular: [https://angular.io/guide/forms#building-a-template-driven-form](https://angular.io/guide/forms#building-a-template-driven-form)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular中构建模板驱动表单：[https://angular.io/guide/forms#building-a-template-driven-form](https://angular.io/guide/forms#building-a-template-driven-form)
- en: Form validation with template-driven forms
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板驱动表单进行表单验证
- en: A great user experience is key to acquiring more users that love to use your
    applications. And using forms is one of those things that users don't really enjoy.
    To make sure that users spend the least amount of time filling in forms and are
    done with them faster, we can implement form validation to make sure that users
    enter the appropriate data a.s.a.p. In this recipe, we're going to look at how
    we can implement form validation in template-driven forms.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的用户体验是获得更多喜欢使用您的应用程序的用户的关键。而使用表单是用户并不真正喜欢的事情之一。为了确保用户在填写表单上花费最少的时间，并且尽快完成，我们可以实现表单验证，以确保用户尽快输入适当的数据。在这个配方中，我们将看看如何在模板驱动表单中实现表单验证。
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter08/start_here/tdf-form-validation`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的项目位于`chapter08/start_here/tdf-form-validation`中：
- en: Open the project in Visual Studio Code.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行 `npm install` 来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab and you should see the app as
    follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器选项卡中打开应用程序，并且您应该看到应用程序如下所示：
- en: '![Figure 8.3 – TDF form validation app running on http://localhost:4200'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 - 运行在http://localhost:4200上的TDF表单验证应用程序'
- en: '](image/Figure_8.3_B15150.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.3_B15150.jpg)'
- en: Figure 8.3 – TDF form validation app running on http://localhost:4200
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 - 运行在http://localhost:4200上的TDF表单验证应用程序
- en: Now that we have the app running locally, let's see the steps involved in this
    recipe in the next section.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用程序，让我们在下一节中看看这个配方涉及的步骤。
- en: How to do it…
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We now have the app from the previous recipe, a simple Angular app with one
    template-driven form using the `ngForm` and `ngModel` directives. The form is
    used to create release logs. In this recipe, we''re going to make this form better
    in terms of validating the input as the user types the input. Let''s get started:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了上一个配方中的应用程序，一个简单的Angular应用程序，使用`ngForm`和`ngModel`指令创建一个模板驱动表单。该表单用于创建发布日志。在这个配方中，我们将在用户输入时使这个表单更好地验证输入。让我们开始吧：
- en: 'First of all, we''ll add some validators from the `@angular/forms` package
    that are part of the Reactive forms API. We''ll apply the **required** validation
    to both inputs and a **regex** validation on the version input. We need to create
    template variables for both our inputs. We will name them `nameInput` and `versionInput`,
    respectively. Modify the code in the `release-form.component.html` file so that
    it looks as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从`@angular/forms`包中添加一些验证器，这些验证器是响应式表单API的一部分。我们将对两个输入应用**required**验证，并对版本输入应用**regex**验证。我们需要为我们的两个输入创建模板变量。我们将分别命名它们为`nameInput`和`versionInput`。修改`release-form.component.html`文件中的代码，使其如下所示：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can now use the template variables to apply validations. Let''s start with
    the name input. In terms of validation, the name input shouldn''t be empty and
    an app should be selected from the select box. Let''s show a default Bootstrap
    alert when the input is invalid. Modify the code in the `release-form.component.html`
    file. It should look as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用模板变量来应用验证。让我们从名称输入开始。在验证方面，名称输入不应为空，并且应从选择框中选择一个应用程序。当输入无效时，让我们显示一个默认的Bootstrap警报。修改`release-form.component.html`文件中的代码。它应该如下所示：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To validate the version name input, we need to apply the `SEMANTIC_VERSION`
    regex from our `src/app/constants/regexes.ts` file. Add the constant as a local
    property in the `ReleaseFormComponent` class to the `release-form.component.ts`
    file as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证版本名称输入，我们需要应用来自`src/app/constants/regexes.ts`文件的`SEMANTIC_VERSION`正则表达式。将常量添加为`ReleaseFormComponent`类中的本地属性，添加到`release-form.component.ts`文件中，如下所示：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, use `versionInputRegex` in the template to apply the validation and show
    the related error as well. Modify the `release-form.component.html` file so that
    the code looks as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在模板中使用`versionInputRegex`来应用验证并显示相关错误。修改`release-form.component.html`文件，使代码如下所示：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Refresh the app and try to invalidate both inputs by selecting the first option
    named **--Choose--** from the **Select App** drop-down menu and by emptying the
    version input field. You should see the following errors:![Figure 8.4 – Displaying
    input errors using ngModel and validation
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新应用程序，并尝试通过从“选择应用程序”下拉菜单中选择名为**--选择--**的第一个选项，并清空版本输入字段来使两个输入无效。您应该会看到以下错误：![图8.4
    - 使用ngModel和验证显示输入错误
- en: '](image/Figure_8.4_B15150.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.4_B15150.jpg)'
- en: Figure 8.4 – Displaying input errors using ngModel and validation
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 - 使用ngModel和验证显示输入错误
- en: 'Next, we''re going to add some styles to make our inputs more visual when it
    comes to validation. Let''s add some styles to the `release-form.component.scss`
    file as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一些样式，使我们的输入在验证时更加直观。让我们在`release-form.component.scss`文件中添加一些样式，如下所示：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, let''s make the validation around the form submission. We''ll disable
    the **Submit** button if the inputs do not have valid values. Let''s modify the
    template in `release-form.component.html` as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们围绕表单提交进行验证。如果输入值无效，我们将禁用**提交**按钮。让我们修改`release-form.component.html`模板如下：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you refresh the app now, you'll see that the submit button is disabled whenever
    one or more inputs are invalid.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在刷新应用程序，您会发现只要一个或多个输入无效，提交按钮就会被禁用。
- en: Great! You just learned how to validate template-driven forms and to make the
    overall user experience with template-driven forms slightly better.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！您刚学会了如何验证模板驱动表单，并使模板驱动表单的整体用户体验稍微好一些。
- en: How it works…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The core components of this recipe were the `ngForm` and `ngModel` directives.
    We could easily identify whether the submit button should be clickable (not disabled)
    or not based on whether the form is valid, that is, if all the inputs in the form
    have valid values. Note that we used the template variable created using the `#releaseForm="ngForm"`
    syntax on the `<form>` element. This is possible due to the ability of the `ngForm`
    directive to be exported into a template variable. Therefore, we were able to
    use the `releaseForm.invalid` property in the `[disabled]` binding of the submit
    button to conditionally disable it. We also showed the errors on individual inputs
    based on the condition that the input might be invalid. In this case, we show
    the Bootstrap `alert` element ( a `<div>` with the CSS class `alert`). We also
    use Angular's provided classes, `ng-valid` and `ng-invalid`, on the form inputs
    to highlight the input in a certain way depending on the validity of the input's
    value. What's interesting about this recipe is that we validated the app name's
    input by making sure it contains a non-falsy value where the first `<option>`
    of the `<select>` box has the value `""`. And what's even more fun is that we
    also validated the version name right when the user types it using the `[pattern]`
    binding on the input to a regex. Otherwise, we'd have to wait for the user to
    submit the form, and then it would have been validated. Thus, we're providing
    a great user experience by providing the errors as the user types the version.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的核心组件是`ngForm`和`ngModel`指令。我们可以很容易地确定提交按钮是否应该可点击（未禁用），这取决于表单是否有效，也就是说，如果表单中的所有输入都具有有效值。请注意，我们在`<form>`元素上使用了使用`#releaseForm="ngForm"`语法创建的模板变量。这是由于`ngForm`指令能够导出为模板变量。因此，我们能够在提交按钮的`[disabled]`绑定中使用`releaseForm.invalid`属性来有条件地禁用它。我们还根据输入可能无效的条件显示单个输入的错误。在这种情况下，我们显示Bootstrap的`alert`元素（带有CSS类`alert`的`<div>`）。我们还在表单输入上使用Angular提供的类`ng-valid`和`ng-invalid`，以根据输入值的有效性以某种方式突出显示输入。这个教程有趣的地方在于，我们通过确保应用程序名称的输入包含一个非假值来验证它，其中`<select>`框的第一个`<option>`的值为`""`。更有趣的是，我们还通过在输入上绑定`[pattern]`到一个正则表达式来验证用户输入版本名称。否则，我们将不得不等待用户提交表单，然后才能进行验证。因此，我们通过在用户输入版本时提供错误信息来提供出色的用户体验。
- en: See also
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Show and hide validation error messages (Angular Docs): [https://angular.io/guide/forms#show-and-hide-validation-error-messages](https://angular.io/guide/forms#show-and-hide-validation-error-messages)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示和隐藏验证错误消息（Angular文档）：[https://angular.io/guide/forms#show-and-hide-validation-error-messages](https://angular.io/guide/forms#show-and-hide-validation-error-messages)
- en: 'NgForm docs: `https://angular.io/api/forms/NgForm`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NgForm文档：`https://angular.io/api/forms/NgForm`
- en: Testing template-driven forms
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试模板驱动表单
- en: To make sure we build robust and bug-free forms for end users, it is a really
    good idea to have tests relating to your forms. It makes the code more resilient
    and less prone to errors. In this recipe, you'll learn how to test your template-driven
    forms using unit tests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们为最终用户构建健壮且无错误的表单，最好是对表单进行测试。这样可以使代码更具弹性，更不容易出错。在本教程中，您将学习如何使用单元测试来测试模板驱动表单。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter08/start_here/testing-td-forms`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的项目位于`chapter08/start_here/testing-td-forms`中。
- en: Open the project in Visual Studio Code.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`以安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab and you should see the app as
    follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器选项卡中打开应用程序，您应该会看到应用程序如下所示：
- en: '![Figure 8.5 – The Testing Template-Driven Forms app running on http://localhost:4200'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5 - 正在运行的Testing Template-Driven Forms应用程序，网址为http://localhost:4200'
- en: '](image/Figure_8.5_B15150.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.5_B15150.jpg)'
- en: Figure 8.5 – The Testing Template-Driven Forms app running on http://localhost:4200
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 - 正在运行的Testing Template-Driven Forms应用程序，网址为http://localhost:4200
- en: Now that we have the app running locally, let's see the steps involved in this
    recipe in the next section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用程序，让我们在下一节中看看这个配方涉及的步骤。
- en: How to do it…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We have the app from the previous recipe that contains a template-driven form
    used to create release logs. The form also has validations applied to the inputs.
    Let''s start looking into how we can test this form:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有来自上一个配方的应用程序，其中包含用于创建发布日志的模板驱动表单。该表单还对输入应用了验证。让我们开始研究如何测试这个表单：
- en: 'First of all, run the following command to run the unit tests:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，运行以下命令来运行单元测试：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once the command is run, you should see a new instance of the Chrome window
    being opened that runs the unit tests. One test out of the six we have has failed.
    You will probably see something like the following in the automated Chrome window:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，您应该看到打开一个新的Chrome窗口来运行单元测试。我们六个测试中的一个测试失败了。您可能会在自动化的Chrome窗口中看到类似以下内容：
- en: '![Figure 8.6 – Unit tests with Karma and Jasmine running in an automated Chrome
    window'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.6 - 使用Karma和Jasmine在自动化Chrome窗口中运行单元测试'
- en: '](image/Figure_8.6_B15150.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.6_B15150.jpg)'
- en: Figure 8.6 – Unit tests with Karma and Jasmine running in an automated Chrome
    window
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 - 使用Karma和Jasmine在自动化Chrome窗口中运行单元测试
- en: 'The `ReleaseFormComponent > should create` test is failing because we don''t
    have `FormsModule` added to the tests. Notice the `Export of name ''ngForm'' not
    found` error. Let''s import `FormsModule` into the testing module''s configuration
    in `release-form.component.spec.ts` as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ReleaseFormComponent > should create`测试失败了，因为我们没有将`FormsModule`添加到测试中。注意`Export
    of name ''ngForm'' not found`错误。让我们在`release-form.component.spec.ts`中的测试模块配置中导入`FormsModule`，如下所示：'
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you look at the tests now, you should see all the tests passing as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在查看测试，您应该看到所有测试都通过了，如下所示：
- en: '![Figure 8.7 – All tests pass after importing FormsModule into the appropriate
    test'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7 - 在适当的测试中导入FormsModule后，所有测试都通过了'
- en: '](image/Figure_8.7_B15150.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.7_B15150.jpg)'
- en: Figure 8.7 – All tests pass after importing FormsModule into the appropriate
    test
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 - 在适当的测试中导入FormsModule后，所有测试都通过了
- en: To test the form correctly, we'll add a couple of tests, one for successful
    input and one for each invalid input. For that, we need to access the form in
    our component since we're writing unit tests.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确测试表单，我们将添加一些测试，一个用于成功的输入，一个用于每个无效的输入。为此，我们需要访问我们组件中的表单，因为我们正在编写单元测试。
- en: 'Let''s access the `#releaseForm` in our component class using the `@ViewChild()`
    decorator in the `release-form.component.ts` file as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`release-form.component.ts`文件中使用`@ViewChild()`装饰器来访问我们组件类中的`#releaseForm`，如下所示：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s add a new test now. We''ll write a test that should validate the case
    for when both the inputs have valid values. Add the test to the `release-form.component.spec.ts`
    file as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们添加一个新的测试。我们将编写一个测试，用于验证当两个输入都具有有效值时的情况。将测试添加到`release-form.component.spec.ts`文件中，如下所示：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The new test is failing so far. Let''s try to fill the values in the form,
    submit the button, and make sure that our `@Output` emitter named `newReleaseLog`
    emits the correct value from `releaseForm`. The content of the test should look
    as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，新的测试失败了。让我们尝试填写表单中的值，提交按钮，并确保我们的`@Output`发射器命名为`newReleaseLog`从`releaseForm`中发射出正确的值。测试的内容应该如下所示：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When you save the file, you should see the new test passing with the expected
    values. It should appear as follows in the Chrome tab:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当你保存文件时，你应该看到新的测试通过了预期的值。它应该出现在Chrome标签页中如下所示：
- en: '![Figure 8.8 – New test for successful form submission passing'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8 - 成功提交表单的新测试通过'
- en: '](image/Figure_8.8_B15150.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.8_B15150.jpg)'
- en: Figure 8.8 – New test for successful form submission passing
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 - 成功提交表单的新测试通过
- en: 'Let''s add a test for the case when we have an incorrect version provided in
    the form. The submit button should be disabled and we should have an error thrown
    by the `formSubmit` method. Add a new test to your `release-form.component.spec.ts`
    file as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为表单中提供了不正确版本的情况添加一个测试。提交按钮应该被禁用，并且`formSubmit`方法应该抛出错误。在`release-form.component.spec.ts`文件中添加一个新的测试，如下所示：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s add our final test, which makes sure that the submit button is disabled
    when we have not selected an app for the release log. Add a new test to the `release-form.component.spec.ts`
    file as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加最后一个测试，确保当我们没有为发布日志选择应用程序时，提交按钮被禁用。在`release-form.component.spec.ts`文件中添加一个新的测试，如下所示：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you look at the Karma tests window, you should see all the new tests passing
    as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看Karma测试窗口，你应该看到所有新的测试都通过了，如下所示：
- en: '![Figure 8.9 – All tests passing for the recipe'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9 - 针对该配方的所有测试都通过'
- en: '](image/Figure_8.9_B15150.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.9_B15150.jpg)'
- en: Figure 8.9 – All tests passing for the recipe
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 - 针对该配方的所有测试都通过
- en: Awesome! You now know a bunch of techniques for testing your template-driven
    forms. Some of these techniques might still require some explanation. See the
    next section to understand how it all works.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在你已经掌握了一堆测试模板驱动表单的技巧。其中一些技巧可能仍需要一些解释。请查看下一节，了解它是如何工作的。
- en: How it works…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Testing template-driven forms can be a bit of a challenge as it depends on
    how complex the form is, what use cases you want to test, and how complex those
    use cases are. In our recipe, the first thing we did was to include `FormsModule`
    in the imports of the test file for `ReleaseFormComponent`. This makes sure that
    the tests know the `ngForm` directive and do not throw relevant errors. For the
    test with all the successful inputs, we spied on the `newReleaseLog` emitter''s
    `emit` event defined in the `ReleaseFormComponent` class. This is because we know
    that when the inputs are correct, the user should be able to click the submit
    button, and as a result, inside the `formSubmit` method, the `emit` method of
    the `newReleaseLog` emitter will be called. Note that we''re using `fixture.whenStable()`
    in each of our tests. This is to make sure that Angular has done the compilation
    and our `ngForm`, named `#releaseForm`, is ready. For the `should disable the
    submit button when version is incorrect` test, we rely on `formSubmit` to throw
    an error. This is because we know that an invalid version will cause an error
    in the `constructor` of the `ReleaseLog` class when creating a new release log.
    One interesting thing in this test is that we use the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 测试模板驱动表单可能有点挑战，因为它取决于表单的复杂程度，您想要测试的用例以及这些用例的复杂程度。在我们的配方中，我们首先在`ReleaseFormComponent`的测试文件的导入中包含了`FormsModule`。这确保了测试知道`ngForm`指令，并且不会抛出相关错误。对于所有成功输入的测试，我们对`ReleaseFormComponent`类中定义的`newReleaseLog`发射器的`emit`事件进行了监听。这是因为我们知道当输入正确时，用户应该能够点击提交按钮，因此在`formSubmit`方法内，`newReleaseLog`发射器的`emit`方法将被调用。请注意，我们在每个测试中都使用了`fixture.whenStable()`。这是为了确保Angular已经完成了编译，我们的`ngForm`，命名为`#releaseForm`，已经准备就绪。对于`当版本不正确时应禁用提交按钮`的测试，我们依赖于`formSubmit`抛出错误。这是因为我们知道无效的版本将在创建新的发布日志时导致`ReleaseLog`类的`constructor`中出错。这个测试中有一个有趣的地方是我们使用了以下代码：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The interesting thing here is that we needed to call the `formSubmit` method
    ourselves with `releaseForm`. We couldn't just do it by writing `expect(component.formSubmit(component.releaseForm)).toThrowError(expectedError);`
    because that would rather call the function directly there and would result in
    the error. So, we need to pass an anonymous function here that Jasmine will call
    and would expect this anonymous function to throw an error. And finally, we make
    sure that our submit button is enabled or disabled by first getting the button
    using a `querySelector` on `fixture.nativeElement`. We then check the `disabled`
    attribute on the submit button using `submitButton.hasAttribute('disabled')`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的是，我们需要自己调用 `formSubmit` 方法，并使用 `releaseForm`。我们不能只写 `expect(component.formSubmit(component.releaseForm)).toThrowError(expectedError);`，因为那样会直接调用函数并导致错误。所以，我们需要在这里传递一个匿名函数，Jasmine
    将调用这个匿名函数，并期望这个匿名函数抛出一个错误。最后，我们通过在 `fixture.nativeElement` 上使用 `querySelector`
    来获取按钮，然后使用 `submitButton.hasAttribute('disabled')` 检查提交按钮上的 `disabled` 属性，以确保我们的提交按钮是启用还是禁用的。
- en: See also
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Testing template-driven forms: [https://angular.io/guide/forms-overview#testing-template-driven-forms](https://angular.io/guide/forms-overview#testing-template-driven-forms)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试模板驱动表单：[https://angular.io/guide/forms-overview#testing-template-driven-forms](https://angular.io/guide/forms-overview#testing-template-driven-forms)
- en: Creating your first Reactive form
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个响应式表单
- en: You've learned about template-driven forms in the previous recipes and are now
    confident in building Angular apps with them. Now guess what? Reactive forms are
    even better. Many known engineers and businesses in the Angular community recommend
    using Reactive forms. The reason is their ease of use when it comes to building
    complex forms. In this recipe, you'll build your first Reactive form and will
    learn its basic usage.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，您已经了解了模板驱动表单，并且现在有信心使用它们构建 Angular 应用程序。现在猜猜？响应式表单甚至更好。许多知名的工程师和企业在
    Angular 社区推荐使用响应式表单。原因是在构建复杂表单时，它们的易用性。在这个配方中，您将构建您的第一个响应式表单，并学习其基本用法。
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter08/start_here/reactive-forms`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的项目位于 `chapter08/start_here/reactive-forms` 中：
- en: Open the project in Visual Studio Code.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行 `npm install` 来安装项目的依赖项。
- en: Once done , run `ng serve -o`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行 `ng serve -o`。
- en: 'Click on the name of the first user and you should see the following view:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击第一个用户的名称，您应该看到以下视图：
- en: '![Figure 8.10 – The Reactive Form app running on http://localhost:4200'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.10 – 响应式表单应用程序在 http://localhost:4200 上运行'
- en: '](image/Figure_8.10_B15150.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.10_B15150.jpg)'
- en: Figure 8.10 – The Reactive Form app running on http://localhost:4200
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 – 响应式表单应用程序在 http://localhost:4200 上运行
- en: Now that we have the app running locally, let's see the steps involved in this
    recipe in the next section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用程序，让我们在下一节中看看这个配方涉及的步骤。
- en: How to do it…
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'So far, we have an app that has `ReleaseLogsComponent`, which shows a bunch
    of release logs that we create. We also have `ReleaseFormComponent`, which has
    a form by means of which the release logs will be created. We now have to make
    our current form a Reactive form using the Reactive forms API. Let''s get started:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个具有 `ReleaseLogsComponent` 的应用程序，它显示了我们创建的一堆发布日志。我们还有 `ReleaseFormComponent`，它通过表单创建发布日志。现在我们需要使用
    Reactive forms API 将当前表单变成一个响应式表单。让我们开始吧：
- en: 'First of all, we need to import `ReactiveFormsModule` into the imports of our
    `AppModule`. Let''s do it by modifying the `app.module.ts` file as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将 `ReactiveFormsModule` 导入到我们的 `AppModule` 的导入中。让我们通过修改 `app.module.ts`
    文件来做到这一点：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s create the Reactive form now. We''ll create a `FormGroup` in our `ReleaseFormComponent`
    class with the required controls. Modify the `release-form.component.ts` file
    as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在创建响应式表单。我们将在`ReleaseFormComponent`类中创建一个带有所需控件的`FormGroup`。修改`release-form.component.ts`文件如下：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we have the form named `releaseForm` in place, let''s bind it to the
    form by using it in the template. Modify the `release-form.component.html` file
    as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有了名为`releaseForm`的表单，让我们在模板中使用它来绑定表单。修改`release-form.component.html`文件如下：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Great! Now that we have the form group bound, we can also bind the individual
    form controls so that when we finally submit the form, we can get the value out
    for each individual form control. Modify the `release-form.component.html` file
    further as follows:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太棒了！现在我们已经绑定了表单组，我们还可以绑定单个表单控件，这样当我们最终提交表单时，我们可以获取每个单独表单控件的值。进一步修改`release-form.component.html`文件如下：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s decide what will happen when we submit this form. We''ll call a method
    named `formSubmit` in the template and pass `releaseForm` in it when the form
    is submitted. Modify the `release-form.component.html` file as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们决定当我们提交这个表单时会发生什么。我们将在模板中调用一个名为`formSubmit`的方法，并在表单提交时传递`releaseForm`。修改`release-form.component.html`文件如下：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `formSubmit` method doesn''t yet exist. Let''s create it now in the `ReleaseFormComponent`
    class. We''ll also log the value on the console and emit the value using an `@Output`
    emitter. Modify the `release-form.component.ts` file as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`formSubmit`方法目前还不存在。让我们现在在`ReleaseFormComponent`类中创建它。我们还将在控制台上记录该值，并使用`@Output`发射器发射该值。修改`release-form.component.ts`文件如下：'
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you refresh the app now, complete the form, and hit **Submit**, you should
    see a log on the console as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在刷新应用程序，填写完表单，然后点击**提交**，您应该在控制台上看到如下日志：
- en: '![Figure 8.11 – Log displaying the values submitted using the Reactive form'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.11 - 显示使用响应式表单提交的值的日志'
- en: '](image/Figure_8.11_B15150.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.11_B15150.jpg)'
- en: Figure 8.11 – Log displaying the values submitted using the Reactive form
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 - 显示使用响应式表单提交的值的日志
- en: 'Since we''ve emitted the value of the newly created release log via the `newReleaseLog`
    output emitter, we can listen to this event in the `version-control.component.html`
    file and add the new log accordingly. Let''s modify the file as follows:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们通过`newReleaseLog`输出发射器发射了新创建的发布日志的值，我们可以在`version-control.component.html`文件中监听此事件，并相应地添加新日志。让我们修改文件如下：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Refresh the app and you should see the new release log being added to the release
    logs view. You should see the logs on the console as well, as shown in the following
    screenshot:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新应用程序，您应该看到新的发布日志被添加到发布日志视图中。您还应该在控制台上看到日志，如下面的截图所示：
- en: '![Figure 8.12 – New logs being added to the logs view on form submission'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.12 - 在表单提交时添加到日志视图的新日志'
- en: '](image/Figure_8.12_B15150.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.12_B15150.jpg)'
- en: Figure 8.12 – New logs being added to the logs view on form submission
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 - 在表单提交时添加到日志视图的新日志
- en: Awesome! So, now you know how to create a basic Reactive form using the Reactive
    forms API. Refer to the next section to understand how it all works.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在你知道如何使用响应式表单API创建基本的响应式表单了。请参考下一节，了解它是如何工作的。
- en: How it works…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The recipe begins with having a basic HTML form in our Angular app with no Angular
    magic bound to it. We first started importing `ReactiveFormsModule` in the `AppModule`.
    If you're using the Angular Language Service with the editor of your choice, you
    might see an error as you import `ReactiveFormsModule` into the app and don't
    bind it with a Reactive form, in other words, with a `FormGroup`. Well, that's
    what we did. We created a reactive form using the `FormGroup` constructor and
    created the relevant form controls using the `FormControl` constructor. We then
    listened to the `ngSubmit` event on the `<form>` element to extract the value
    of `releaseForm`. Once done, we emitted this value using the `@Ouput()` named
    `newReleaseLog`. Notice that we also defined the type of the value that this emitter
    will emit as `IReleaseLog`; it is good practice to define those. This emitter
    was required because `ReleaseLogsComponent` is a sibling of `ReleaseFormComponent`
    in the component's hierarchy. Therefore, we're communicating through the parent
    component, `VersionControlComponent`. Finally, we listen to the `newReleaseLog`
    event's emission in the `VersionControlComponent` template and add a new log to
    the `releaseLogs` array via the `addNewReleaseLog` method. And this `releaseLogs`
    array is being passed to `ReleaseLogsComponent`, which displays all the logs as
    they're added.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 该食谱始于我们的Angular应用程序中有一个基本的HTML表单，没有与之绑定的Angular魔法。我们首先在 `AppModule` 中导入了 `ReactiveFormsModule`。如果您正在使用所选编辑器的Angular语言服务，当您导入
    `ReactiveFormsModule` 到应用程序中并且没有将其与响应式表单绑定时，您可能会看到一个错误，换句话说，没有与 `FormGroup` 绑定。好吧，这就是我们做的。我们使用
    `FormGroup` 构造函数创建了一个响应式表单，并使用 `FormControl` 构造函数创建了相关的表单控件。然后，我们监听了 `<form>`
    元素上的 `ngSubmit` 事件，以提取 `releaseForm` 的值。完成后，我们使用 `@Ouput()` 命名为 `newReleaseLog`
    发射了这个值。请注意，我们还定义了此发射器将发射的值的类型为 `IReleaseLog`；定义这些是一个好习惯。这个发射器是必需的，因为 `ReleaseLogsComponent`
    是组件层次结构中 `ReleaseFormComponent` 的兄弟组件。因此，我们通过父组件 `VersionControlComponent` 进行通信。最后，我们在
    `VersionControlComponent` 模板中监听 `newReleaseLog` 事件的发射，并通过 `addNewReleaseLog` 方法向
    `releaseLogs` 数组添加新日志。并且这个 `releaseLogs` 数组被传递给 `ReleaseLogsComponent`，它会显示所有添加的日志。
- en: See also
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Angular''s guide to Reactive forms: [https://angular.io/guide/reactive-forms](https://angular.io/guide/reactive-forms)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular的响应式表单指南：[https://angular.io/guide/reactive-forms](https://angular.io/guide/reactive-forms)
- en: Form validation with Reactive forms
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用响应式表单进行表单验证
- en: In the previous recipe, you learned how to create a Reactive form. Now, we're
    going to learn how to test them. In this recipe, you'll learn some basic principles
    of testing Reactive forms. We're going to use the same example from the previous
    recipe (the release logs app) and will implement a number of test cases.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇食谱中，您学会了如何创建一个响应式表单。现在，我们将学习如何测试它们。在这个食谱中，您将学习一些测试响应式表单的基本原则。我们将使用上一篇食谱中的相同示例（发布日志应用程序），并实现多个测试用例。
- en: Getting ready
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter08/start_here/validating-reactive-forms`
    inside the cloned repository:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的项目位于克隆存储库中的 `chapter08/start_here/validating-reactive-forms` 中：
- en: Open the project in Visual Studio Code.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行 `npm install` 来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行 `ng serve -o`。
- en: 'This should open the app in a new browser tab and you should see it as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器标签中打开应用程序，您应该会看到它如下所示：
- en: '![Figure 8.13 – The Validating Reactive Forms  app running on http://localhost:4200'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.13 – 在 http://localhost:4200 上运行的验证响应式表单应用程序'
- en: '](image/Figure_8.13_B15150.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.13_B15150.jpg)'
- en: Figure 8.13 – The Validating Reactive Forms app running on http://localhost:4200
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 – 在 http://localhost:4200 上运行的验证响应式表单应用程序
- en: Now that we have the app running locally, let's see the steps involved in this
    recipe in the next section.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用程序，让我们在下一节中看看这个配方涉及的步骤。
- en: How to do it…
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For this recipe, we''re using the Release Logs application that has the Reactive
    form implemented already, although we don''t have any sort of validation on the
    inputs so far. If you just select an app and submit the form, you''ll see an error
    on the console as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们使用的是已经实现了响应式表单的发布日志应用程序，尽管到目前为止我们还没有任何输入验证。如果你只是选择一个应用程序并提交表单，你会在控制台上看到以下错误：
- en: '![Figure 8.14 – Error when submitting the Reactive form app without form validations'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.14 - 在没有表单验证的情况下提交响应式表单应用程序时出错'
- en: '](image/Figure_8.14_B15150.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.14_B15150.jpg)'
- en: Figure 8.14 – Error when submitting the Reactive form app without form validations
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 - 在没有表单验证的情况下提交响应式表单应用程序时出错
- en: 'We''re going to incorporate some form validations to enhance the user experience
    and to make sure that the form can''t be submitted with invalid input. Let''s
    begin:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加入一些表单验证来增强用户体验，并确保表单不能使用无效输入提交。让我们开始：
- en: 'We''ll first add some validations from the `@angular/forms` package, which
    are part of the Reactive Forms API. We''ll apply the `required` validator on both
    inputs and the `pattern` validator on the `version` form control. Update the `release-form.component.ts`
    file as follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从`@angular/forms`包中添加一些验证，这些验证是响应式表单API的一部分。我们将在两个输入上应用`required`验证器，并在`version`表单控件上应用`pattern`验证器。更新`release-form.component.ts`文件如下：
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we''ll add the hints to the view to show the user errors when an invalid
    input is selected. Modify the `release-form.component.html` file as follows:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将在视图中添加提示，以在选择无效输入时向用户显示错误。修改`release-form.component.html`文件如下：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We''ll also add some styles to show the errors with a better UI. Add the following
    styles to the `release-form.component.scss` file:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将添加一些样式来以更好的UI显示错误。将以下样式添加到`release-form.component.scss`文件中：
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Refresh the app and you should see the inputs with red borders when the input
    values are wrong. The errors once you enter or select an invalid input will look
    as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新应用程序，当输入值错误时，你应该看到带有红色边框的输入。一旦输入或选择无效输入，错误将如下所示：
- en: '![Figure 8.15 – Red borders shown on invalid input values'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.15 - 显示无效输入值的红色边框'
- en: '](image/Figure_8.15_B15150.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.15_B15150.jpg)'
- en: Figure 8.15 – Red borders shown on invalid input values
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 - 显示无效输入值的红色边框
- en: 'Finally, let''s make the validation around the form submission. We''ll disable
    the **Submit** button if the inputs do not have valid values. Let''s modify the
    template in `release-form.component.html` as follows:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们围绕表单提交进行验证。如果输入无效，我们将禁用**提交**按钮。让我们修改`release-form.component.html`模板如下：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you refresh the app now, you'll see that the submit button is disabled whenever
    one or more inputs are invalid.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在刷新应用程序，你会看到只要一个或多个输入无效，提交按钮就会被禁用。
- en: And that concludes the recipe. Let's look at the next section to see how it
    works.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了这个配方。让我们看看下一节，看看它是如何工作的。
- en: How it works…
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We started the recipe by adding the validators, and Angular has got a bunch
    of validators out of the box, including `Validators.email`, `Validators.pattern`,
    and `Validators.required`. We used the `required` validator with the `pattern`
    validator in our recipe for the inputs for the app name and the version, respectively.
    After that, to show the hints/errors for invalid inputs, we added some conditional
    styles to show a border-bottom on the inputs. We also added some `<div>` elements
    with `class="alert alert-danger"`, which are basically Bootstrap alerts to show
    the errors on invalid values for the form controls. Notice that we''re using the
    following pattern to hide the error elements:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加验证器开始了这个教程，Angular已经提供了一堆验证器，包括`Validators.email`、`Validators.pattern`和`Validators.required`。我们在教程中分别为应用程序名称和版本的输入使用了`required`验证器和`pattern`验证器。之后，为了显示无效输入的提示/错误，我们添加了一些条件样式，以在输入上显示底部边框。我们还添加了一些`<div>`元素，带有`class="alert
    alert-danger"`，这些基本上是Bootstrap警报，用于显示表单控件的无效值的错误。请注意，我们使用以下模式来隐藏错误元素：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We're using the condition with `.pristine` to make sure that as soon as the
    user selects the correct input and the input is modified, we hide the error again
    so that it doesn't show while the user is typing in the input or making another
    selection. Finally, we made sure that the form cannot even be submitted if the
    values of the form controls are invalid. We disabled the submit button using `[disabled]="releaseForm.invalid"`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`.pristine`条件来确保一旦用户选择了正确的输入并修改了输入，我们再次隐藏错误，以便在用户输入或进行其他选择时不显示错误。最后，我们确保即使表单控件的值无效，表单也无法提交。我们使用`[disabled]="releaseForm.invalid"`来禁用提交按钮。
- en: See also
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'Angular docs for validating Reactive forms: [https://angular.io/guide/reactive-forms#validating-form-input](https://angular.io/guide/reactive-forms#validating-form-input)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular验证响应式表单的文档：[https://angular.io/guide/reactive-forms#validating-form-input](https://angular.io/guide/reactive-forms#validating-form-input)
- en: Creating an asynchronous validator function
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个异步验证器函数
- en: Form validations are pretty straightforward in Angular, the reason being the
    super-awesome validators that Angular provides out of the box. These validators
    are synchronous, meaning that as soon as you change the input, the validators
    kick in and provide you with information about the validity of the values right
    away. But sometimes, you might rely on some validations from a backend API, for
    instance. These situations would require something called asynchronous validators.
    In this recipe, you're going to create your first asynchronous validator.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，表单验证非常简单，原因在于Angular提供了超级棒的验证器。这些验证器是同步的，意味着一旦您更改输入，验证器就会启动并立即提供有关值有效性的信息。但有时，您可能会依赖于后端API的一些验证。这些情况需要一种称为异步验证器的东西。在本教程中，您将创建您的第一个异步验证器。
- en: Getting ready
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter08/start_here/asynchronous-validator`
    inside the cloned repository:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的项目位于克隆存储库中的`chapter08/start_here/asynchronous-validator`中：
- en: Open the project in Visual Studio Code.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`以安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab and you should see something
    like the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在新的浏览器选项卡中打开应用程序，您应该看到类似以下内容的内容：
- en: '![Figure 8.16 – Asynchronous validators app running on http://localhost:4200'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.16 - 异步验证器应用程序在http://localhost:4200上运行'
- en: '](image/Figure_8.16_B15150.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.16_B15150.jpg)'
- en: Figure 8.16 – Asynchronous validators app running on http://localhost:4200
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16 - 异步验证器应用程序在http://localhost:4200上运行
- en: Now that we have the app running, let's see the steps involved in this recipe
    in the next section.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序正在运行，让我们在下一节中看看这个配方涉及的步骤。
- en: How to do it…
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'We already have some things set up in the release logs app. We have a `data.json`
    file residing in the `src/assets` folder that holds the versions for each of our
    target apps for the release logs. We''ll create an async validator to make sure
    that the new releases for each of the applications have a greater version than
    that specified in the `data.json` file. Let''s begin:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在发布日志应用程序中设置了一些内容。我们在`src/assets`文件夹中有一个`data.json`文件，其中包含发布日志的每个目标应用程序的版本。我们将创建一个异步验证器，以确保每个应用程序的新版本都比`data.json`文件中指定的版本大。让我们开始：
- en: 'First, we''re going to create the async validator function for the recipe.
    Let''s create a method named `versionValidator` in the `VersionService` class
    in the `version.service.ts` file as follows:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将为该配方创建异步验证器函数。让我们在`version.service.ts`文件的`VersionService`类中创建一个名为`versionValidator`的方法，如下所示：
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We''ll now define the content of the validator function. Let''s modify the
    `versionValidator` method as follows:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将定义验证器函数的内容。让我们修改`versionValidator`方法如下：
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that we have the validator function in place, let''s add that to the form
    control for the version number. Let''s modify the `release-form.component.ts`
    file as follows:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有了验证器函数，让我们将其添加到版本号的表单控件中。修改`release-form.component.ts`文件如下：
- en: '[PRE39]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We will now use the validator to enhance the user''s experience of the form
    by modifying the `release-form.component.html` file. For ease of usage, let''s
    wrap the content inside an `<ng-container>` element using the `*ngIf` directive,
    and create a variable within the template for the version form control as follows:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将使用验证器来增强表单的用户体验，修改`release-form.component.html`文件。为了方便使用，让我们使用`*ngIf`指令将内容包装在`<ng-container>`元素中，并在模板中创建一个变量用于版本表单控件，如下所示：
- en: '[PRE40]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s now add the error message. We''ll use our custom error, `newVersionRequired`,
    from the validator function to show the error when the specified version isn''t
    newer than the previous version. Modify the `release-form.component.html` file
    as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们添加错误消息。我们将使用我们的自定义错误`newVersionRequired`，从验证器函数中显示错误，当指定的版本不比先前的版本更新时。修改`release-form.component.html`文件如下：
- en: '[PRE41]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Try to select an app and add a lower version number and you should now see
    the error as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试选择一个应用程序并添加一个较低的版本号，现在您应该看到以下错误：
- en: '![Figure 8.17 – Error being shown when a lower version number is provided'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.17 - 提供较低版本号时显示的错误'
- en: '](image/Figure_8.17_B15150.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.17_B15150.jpg)'
- en: Figure 8.17 – Error being shown when a lower version number is provided
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17 - 提供较低版本号时显示的错误
- en: 'One issue right now is that we are able to submit the form while the asynchronous
    validation is in progress. That''s because Angular, by default, marks the error
    as `null` until the validation is done. To tackle this, we can show a loading
    message instead of the **submit** button in the template. Modify the `release-form.component.html`
    file as follows:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前的一个问题是，我们能够在异步验证进行时提交表单。这是因为 Angular 默认情况下会将错误标记为“null”，直到验证完成。为了解决这个问题，我们可以在模板中显示一个加载消息，而不是**提交**按钮。修改`release-form.component.html`文件如下：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you refresh the app, select an app, and type a valid version, you should
    see the **Please wait…** message as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您刷新应用程序，选择一个应用程序，并输入一个有效的版本号，您应该看到以下**请稍候...**消息：
- en: '![Figure 8.18 – Loader message while async validation is in progress'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.18 - 异步验证进行时的加载消息'
- en: '](image/Figure_8.18_B15150.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.18_B15150.jpg)'
- en: Figure 8.18 – Loader message while async validation is in progress
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18 - 异步验证进行时的加载消息
- en: 'We still have an issue where the user can type and press *Enter* quickly to
    submit the form. To prevent this from happening, let''s add a check in our `formSubmit`
    method in the `release-form.component.ts` file as follows:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然有一个问题，即用户可以快速输入并按*Enter*提交表单。为了防止这种情况发生，让我们在`release-form.component.ts`文件的`formSubmit`方法中添加一个检查，如下所示：
- en: '[PRE43]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, we have another issue to handle. If we select a valid version number
    and change the app, we can still submit the form with the entered version number
    although it is logically wrong. To handle this, we should update the validation
    of the `''version''` form control whenever the value of the `''app''` form control
    changes. To do that, modify the `release-form.component.ts` file as follows:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还有另一个问题要处理。如果我们选择了一个有效的版本号并更改了应用程序，尽管逻辑上是错误的，我们仍然可以提交带有输入版本号的表单。为了处理这个问题，我们应该在`'app'`表单控件的值发生变化时更新`'version'`表单控件的验证。为此，请按照以下方式修改`release-form.component.ts`文件：
- en: '[PRE44]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Cool! So, you now know how to create an asynchronous validator function in Angular
    for form validation within Reactive forms. Since you've finished the recipe, refer
    to the next section to see how this works.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！现在你知道如何在Angular中为响应式表单创建异步验证器函数了。既然你已经完成了这个示例，请参考下一节，看看它是如何工作的。
- en: How it works…
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Angular provides a really easy way to create async validator functions, and
    they're pretty handy too. In this recipe, we started by creating the validator
    function named `versionValidator`. Notice that we have an argument named `appNameControl`
    for the validator function. This is because we want to get the app name for which
    we are validating the version number. Also notice that we have the return type
    set to `AsyncValidatorFn`, which is required by Angular. The validator function
    is supposed to return an `AsyncValidatorFn`, which means it will return a function
    (let's call it the **inner function**), which receives an `AbstractControl` and
    returns an `Observable` of `ValidatorErrors`. Inside the inner function, we use
    the `getVersionLog()` method from `VersionService` to fetch the `data.json` file
    using the `HttpClient` service. Once we get the version from `data.json` for the
    specific app selected, we compare the version entered in the form with the value
    from `data.json` to validate the input. Notice that instead of just returning
    a `ValidationErrors` object with the `newVersionRequired` property set to `true`,
    we actually set it to `previousVersion` so that we can use it later to show it
    to the user.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了一种非常简单的方法来创建异步验证器函数，它们也非常方便。在这个示例中，我们首先创建了名为`versionValidator`的验证器函数。请注意，我们为验证器函数命名了一个名为`appNameControl`的参数。这是因为我们想要获取正在验证版本号的应用程序名称。还要注意，我们将返回类型设置为`AsyncValidatorFn`，这是Angular所要求的。验证器函数应该返回一个`AsyncValidatorFn`，这意味着它将返回一个函数（让我们称之为**内部函数**），该函数接收一个`AbstractControl`并返回一个`ValidatorErrors`的`Observable`。在内部函数中，我们使用`VersionService`的`getVersionLog()`方法，使用`HttpClient`服务获取`data.json`文件。一旦我们从`data.json`中获取了特定应用程序的版本，我们就将表单中输入的版本与`data.json`中的值进行比较，以验证输入。请注意，我们并不只是返回一个`ValidationErrors`对象，其中`newVersionRequired`属性设置为`true`，而是实际上将其设置为`previousVersion`，以便稍后向用户显示。
- en: After creating the validator function, we attached it to the form control for
    the version name by using the `FormControl.setAsyncValidators()` method in the
    `ReleaseFormComponent` class. We then used the validation error named `newVersionRequired`
    in the template to show the error message, along with the version from the `data.json`
    file.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 创建验证器函数后，我们通过在`ReleaseFormComponent`类中使用`FormControl.setAsyncValidators()`方法将其附加到版本名称的表单控件上。然后我们在模板中使用名为`newVersionRequired`的验证错误来显示错误消息，以及来自`data.json`文件的版本。
- en: We also needed to handle the case that while the validation is in progress,
    the form control is valid until the validation is finished. This allows us to
    submit the form while the validation for the version name was in progress. We
    handle it by hiding the submit button during the validation process by checking
    whether the value of `FormControl.status` is `'PENDING'`. We hide the submit button
    in that case and show the **Please wait…** message in the meantime. Note that
    we also add some logic in the `formSubmit` method of the `ReleaseFormComponent`
    class to check whether `FormControl.status` is `'PENDING'` for the version number,
    in which case, we just do a `return;`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要处理这样一种情况，即在验证进行中，表单控件在验证完成之前是有效的。这使我们能够在版本名称的验证正在进行时提交表单。我们通过检查`FormControl.status`的值是否为`'PENDING'`来处理这个问题，在这种情况下，我们隐藏提交按钮，并在此期间显示**请等待…**消息。请注意，我们还在`ReleaseFormComponent`类的`formSubmit`方法中添加了一些逻辑，以检查版本号的`FormControl.status`是否为`'PENDING'`，在这种情况下，我们只需执行`return;`。
- en: One more interesting thing in the recipe is that if we added a valid version
    number and changed the app, we could still submit the form. We handle that by
    adding a subscription to `.valueChanges` of the `'app'` form control, so whenever
    that happens, we trigger another validation on the `'version'` form control using
    the `.updateValueAndValidity()` method.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱中的另一个有趣之处是，如果我们添加了一个有效的版本号并更改了应用程序，我们仍然可以提交表单。我们通过向`'app'`表单控件的`.valueChanges`添加订阅来处理这个问题，因此每当这种情况发生时，我们使用`.updateValueAndValidity()`方法在`'version'`表单控件上触发另一个验证。
- en: See also
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'AsyncValidator Angular docs: [https://angular.io/api/forms/AsyncValidator#provide-a-custom-async-validator-directive](https://angular.io/api/forms/AsyncValidator#provide-a-custom-async-validator-directive)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AsyncValidator Angular文档：[https://angular.io/api/forms/AsyncValidator#provide-a-custom-async-validator-directive](https://angular.io/api/forms/AsyncValidator#provide-a-custom-async-validator-directive)
- en: Testing Reactive forms
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试响应式表单
- en: To make sure we build robust and bug-free forms for end users, it is a really
    good idea to have tests around your forms. It makes the code more resilient and
    less prone to errors. In this recipe, you'll learn how to test your template-driven
    forms using unit tests.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们为最终用户构建健壮且无错误的表单，围绕您的表单编写测试是一个非常好的主意。这使得代码更具弹性，更不容易出错。在这个食谱中，您将学习如何使用单元测试测试您的模板驱动表单。
- en: Getting ready
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'The project for this recipe resides in `chapter08/start_here/testing-reactive-forms`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的项目位于`chapter08/start_here/testing-reactive-forms`：
- en: Open the project in Visual Studio Code.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab, and you should see the app as
    follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签中打开应用程序，您应该看到应用程序如下：
- en: '![Figure 8.19 – The Testing Reactive Forms app running on http://localhost:4200'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.19 - 在http://localhost:4200上运行的测试响应式表单应用程序'
- en: '](image/Figure_8.19_B15150.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.19_B15150.jpg)'
- en: Figure 8.19 – The Testing Reactive Forms app running on http://localhost:4200
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19 - 在http://localhost:4200上运行的测试响应式表单应用程序
- en: Now that we have the app running locally, let's see the steps involved in this
    recipe in the next section.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序在本地运行，让我们在下一节中看看这个食谱涉及的步骤。
- en: How to do it…
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We have the Release Logs application that has a Reactive form implemented with
    some validations. In this recipe, we''re going to implement some tests for the
    forms. Let''s get started:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个使用一些验证实现的响应式表单的Release Logs应用程序。在这个食谱中，我们将为表单实现一些测试。让我们开始吧：
- en: 'First of all, run the following command to run the unit tests in a separate
    terminal window:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在单独的终端窗口中运行以下命令来运行单元测试：
- en: '[PRE45]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Once the command is run, you should see a new instance of the Chrome window
    being opened that runs the tests as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，你应该看到一个新的Chrome窗口实例被打开，运行测试如下：
- en: '![Figure 8.20 – Unit tests with Karma and Jasmine running in an automated Chrome
    window'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.20 - 单元测试与Karma和Jasmine在自动化Chrome窗口中运行'
- en: '](image/Figure_8.20_B15150.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20 - 单元测试与Karma和Jasmine在自动化Chrome窗口中运行
- en: Figure 8.20 – Unit tests with Karma and Jasmine running in an automated Chrome
    window
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20 - 单元测试与Karma和Jasmine在自动化Chrome窗口中运行
- en: 'Let''s add our first test for the case when all the inputs have a valid value.
    In this case, we should have the form submitted and the form''s value emitted
    through the emitter of the `newReleaseLog` output. Modify the `release-form.component.spec.ts`
    file as follows:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为所有输入都有有效值的情况添加第一个测试。在这种情况下，我们应该提交表单，并通过`newReleaseLog`输出的发射器发出表单的值。修改`release-form.component.spec.ts`文件如下：
- en: '[PRE46]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you look at the tests now, you should the new test passing as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在查看测试，你应该看到新的测试通过如下：
- en: '![Figure 8.21 – Test case passing for the successful input'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.21 - 成功输入的测试用例通过'
- en: '](image/Figure_8.21_B15150.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.21_B15150.jpg)'
- en: Figure 8.21 – Test case passing for the successful input
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.21 - 成功输入的测试用例通过'
- en: 'Let''s add a test for the case when we have an incorrect version provided in
    the form. The **submit** button should be disabled and we should have an error
    thrown by the `formSubmit` method. Add a new test to your `release-form.component.spec.ts`
    file as follows:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '让我们为表单中提供了不正确版本的情况添加一个测试。**提交**按钮应该被禁用，并且`formSubmit`方法应该抛出错误。在你的`release-form.component.spec.ts`文件中添加一个新的测试，如下所示： '
- en: '[PRE47]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s add our final test, which makes sure that the **submit** button is disabled
    when we have not selected an app for the release log. Add a new test to the `release-form.component.spec.ts`
    file as follows:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加我们的最终测试，确保当我们没有为发布日志选择应用程序时，**提交**按钮被禁用。在`release-form.component.spec.ts`文件中添加一个新的测试，如下所示：
- en: '[PRE48]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you look at the Karma tests window, you should see all the new tests passing
    as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看Karma测试窗口，你应该看到所有新的测试都通过了如下：
- en: '![Figure 8.22 – All tests passing for the recipe'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.22 - 所有测试通过了食谱'
- en: '](image/Figure_8.22_B15150.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.22_B15150.jpg)'
- en: Figure 8.22 – All tests passing for the recipe
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.22 - 所有测试用例通过了食谱'
- en: Great! You now know how to write some essential tests for Reactive forms. Refer
    to the next section to understand how it all works.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在你知道如何为响应式表单编写一些基本的测试了。请参考下一节，了解它是如何工作的。
- en: How it works…
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Testing Reactive forms doesn''t even require importing `ReactiveFormsModule`
    into the test module as of Angular 10\. For all the tests in our recipe, we spied
    on the `newReleaseLog` emitter''s `emit` event defined in the `ReleaseFormComponent`
    class. This is because we know that when the inputs are correct, the user should
    be able to click the **submit** button, and as a result, inside the `formSubmit`
    method, the `emit` method of the `newReleaseLog` emitter will be called. For the
    test covering the validity of the `''version''` form control, we rely on `formSubmit`
    to throw an error. This is because we know that an invalid version will cause
    an error in the `constructor` of the `ReleaseLog` class when creating a new release
    log. One interesting thing in this test is that we use the following code:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 测试响应式表单甚至不需要在Angular 10中将`ReactiveFormsModule`导入测试模块。对于我们食谱中的所有测试，我们都对`ReleaseFormComponent`类中定义的`newReleaseLog`发射器的`emit`事件进行了监听。这是因为我们知道当输入正确时，用户应该能够单击**提交**按钮，因此在`formSubmit`方法内，将调用`newReleaseLog`发射器的`emit`方法。对于涵盖`'version'`表单控件有效性的测试，我们依赖于`formSubmit`抛出错误。这是因为我们知道无效的版本将在创建新的发布日志时导致`ReleaseLog`类的`constructor`中出错。在这个测试中有一个有趣的地方是我们使用了以下代码：
- en: '[PRE49]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The interesting thing here is that we needed to call the `formSubmit` method
    ourselves with `releaseForm`. We couldn't just do it by writing `expect(component.formSubmit(component.releaseForm)).toThrowError(expectedError);`
    because that would rather call the function directly there and would result in
    an error. So we need to pass an anonymous function here that Jasmine will call
    and would expect this anonymous function to throw an error. And finally, we make
    sure that our **submit** button is enabled or disabled by first getting the button
    using `querySelector` on `fixture.nativeElement`. And then we check the `disabled`
    attribute on the **submit** button using `submitButton.hasAttribute('disabled')`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们需要自己调用`formSubmit`方法来调用`releaseForm`。我们不能只写`expect(component.formSubmit(component.releaseForm)).toThrowError(expectedError);`，因为那样会直接调用函数并导致错误。所以我们需要在这里传递一个匿名函数，Jasmine会调用这个匿名函数，并期望这个匿名函数抛出一个错误。最后，我们通过在`fixture.nativeElement`上使用`querySelector`来获取按钮，然后使用`submitButton.hasAttribute('disabled')`来检查**提交**按钮上的`disabled`属性，确保我们的**提交**按钮是启用还是禁用。
- en: See also
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Testing Reactive forms: [https://angular.io/guide/forms-overview#testing-reactive-forms](https://angular.io/guide/forms-overview#testing-reactive-forms)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试响应式表单：[https://angular.io/guide/forms-overview#testing-reactive-forms](https://angular.io/guide/forms-overview#testing-reactive-forms)
- en: Using debounce with Reactive form control
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用反弹与响应式表单控件
- en: If you're building a medium-to large-scale Angular app with Reactive forms,
    you'll surely encounter a scenario where you might want to use a debounce on a
    Reactive form. It could be for performance reasons, or for saving HTTP calls.
    So, in this recipe, you're going to learn how to use debounce on a Reactive form
    control.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建一个中到大型规模的Angular应用程序，并使用响应式表单，那么您肯定会遇到一种情况，您可能希望在响应式表单上使用反弹。这可能是出于性能原因，或者为了节省HTTP调用。因此，在这个示例中，您将学习如何在响应式表单控件上使用反弹。
- en: Getting ready
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter08/start_here/using-debounce-with-rfc`
    inside the cloned repository:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要处理的项目位于克隆存储库中的`chapter08/start_here/using-debounce-with-rfc`中：
- en: Open the project in Visual Studio Code.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`以安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab and you should see it as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在新的浏览器选项卡中打开应用程序，并且您应该看到如下所示：
- en: '![Figure 8.23 – The Using debounce with Reactive Form Control app running on
    http://localhost:4200'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.23 - 使用反弹与响应式表单控件应用程序正在http://localhost:4200上运行'
- en: '](image/Figure_8.23_B15150.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.23_B15150.jpg)'
- en: Figure 8.23 – The Using debounce with Reactive Form Control app running on http://localhost:4200
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23 - 使用反弹与响应式表单控件应用程序正在http://localhost:4200上运行
- en: 'Right now, you''ll notice that for each character we type into the input, we
    send a new HTTP request to the API shown as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您会注意到每输入一个字符，我们就会向API发送一个新的HTTP请求，如下所示：
- en: '![Figure 8.24 – Multiple HTTP calls sent as we type in the input'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.24 - 在输入时发送的多个HTTP调用'
- en: '](image/Figure_8.24_B15150.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.24_B15150.jpg)'
- en: Figure 8.24 – Multiple HTTP calls sent as we type in the input
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24 - 在输入时发送的多个HTTP调用
- en: Now that we have the app running locally, let's see the steps involved in this
    recipe in the next section.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序在本地运行，让我们在下一节中看看这个示例涉及的步骤。
- en: How to do it…
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'For this recipe, we''re using an application that uses the RandomUser.me API
    to get users. As you see in *Figure 8.24*, we send a new HTTP call for every change
    in the input. Let''s begin with the recipe to avoid doing that:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们使用一个使用RandomUser.me API获取用户的应用程序。如*图8.24*所示，我们在输入变化时发送新的HTTP调用。让我们开始避免这样做的示例：
- en: 'Adding the debounce to the form is super easy. Let''s use the `debounceTime`
    operator in the `home.component.ts` file as follows:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将防抖功能添加到表单中非常容易。让我们在`home.component.ts`文件中使用`debounceTime`操作符，如下所示：
- en: '[PRE50]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Well, it's funny that this is it for the recipe as far as the task is concerned.
    But I do want to give you more out of this book. So we're going to write some
    interesting tests.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，有趣的是，就任务而言，这就是本节的全部内容。但我确实希望能给您带来更多。因此，我们将编写一些有趣的测试。
- en: 'We''ll add a test now to make sure that our `searchUsers` method isn''t called
    before `searchDebounceTime` has passed. Add the following test to the `home.component.spec.ts`
    file:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将添加一个测试，以确保在`searchDebounceTime`过去之前不会调用我们的`searchUsers`方法。在`home.component.spec.ts`文件中添加以下测试：
- en: '[PRE51]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we''ll add a test for the case when `searchDebounceTime` has passed and
    the `searchUsers()` method should have been called. Add a new test to the `home.component.spec.ts`
    file as follows:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将为`searchDebounceTime`过去并且应该已调用`searchUsers()`方法的情况添加一个测试。在`home.component.spec.ts`文件中添加以下新测试：
- en: '[PRE52]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If you refresh the Karma test Chrome window, you''ll see all the tests passing
    as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果刷新Karma测试Chrome窗口，您将看到所有测试都通过了，如下所示：
- en: '![Figure 8.25 – All tests passing for the recipe'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.25 - 本节所有测试都通过'
- en: '](image/Figure_8.25_B15150.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.25_B15150.jpg)'
- en: Figure 8.25 – All tests passing for the recipe
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25 - 本节所有测试都通过
- en: 'Now, run the `npm start` command to spin up the app again. Then, monitor the
    network calls while you type an input into the search box. You''ll see that the
    `debounceTime` operator causes only 1 call once you stop typing for 300 milliseconds,
    as shown in the following screenshot:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行`npm start`命令再次启动应用程序。然后，在输入到搜索框时监视网络调用。您会看到`debounceTime`操作符在您停止输入300毫秒后只调用1次，如下截图所示：
- en: '![Figure 8.26 – Only one network call sent after a 300ms debounce'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.26 - 在300毫秒防抖后仅发送一个网络调用'
- en: '](image/Figure_8.26_B15150.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.26_B15150.jpg)'
- en: Figure 8.26 – Only one network call sent after a 300ms debounce
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.26 - 在300毫秒防抖后仅发送一个网络调用
- en: Awesome! So, now you know how to use debounce with a Reactive form control and
    also how to write tests to check whether things work fine with the debounce. And
    that concludes the recipe. Let's refer to the next section to see how it works.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，您知道如何在响应式表单控件中使用防抖，以及如何编写测试来检查防抖是否正常工作。这就结束了本节。让我们参考下一节，看看它是如何工作的。
- en: How it works…
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The main task for the recipe was quite easy. We just used the `debounceTime`
    operator from the `rxjs` package and used it with our Reactive form control's
    `.valueChanges` Observable. Since we're using it within the `.pipe()` operator
    before the `.subscribe()` method, every time we change the value of the input,
    either by entering a value or by pressing the backspace key, it waits for `300ms`
    according to the `searchDebounceTime` property and then calls the `searchUsers()`
    method.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的主要任务非常简单。我们只是从`rxjs`包中使用了`debounceTime`操作符，并将其与我们的响应式表单控件的`.valueChanges`
    Observable一起使用。由于我们在`.subscribe()`方法之前在`.pipe()`操作符中使用它，所以每当我们改变输入的值，无论是输入值还是按下退格键，它都会根据`searchDebounceTime`属性等待`300ms`，然后调用`searchUsers()`方法。
- en: 'We also wrote some tests in this recipe. Notice that we spy on the `searchUsers()`
    method since that is what it''s supposed to be called whenever we change the value
    of the `''username''` form control. We''re wrapping the test functions inside
    the `fakeAsync` method so we can control the asynchronous behavior of the use
    cases in our tests. We then set the value of the form control using the `FormControl.setValue()`
    method, which should trigger the method provided as an argument to the `.subscribe()`
    method after the time according to `searchDebounceTime` has passed. We then used
    the `tick()` method with the value of `searchDebounceTime` so it simulates an
    asynchronous passage of time. Then we write our `expect()` block to check whether
    the `searchUsers()` method should or shouldn''t have been called. Finally, at
    the end of the tests, we use the `discardPeriodicTasks()` method. We use this
    method so that we don''t face the `Error: 1 periodic timer(s) still in the queue.`
    error and our tests work.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还在这个食谱中编写了一些测试。请注意，我们对`searchUsers()`方法进行了间谍，因为每当我们更改`''username''`表单控件的值时，它就应该被调用。我们将测试函数包装在`fakeAsync`方法中，这样我们就可以控制测试中用例的异步行为。然后我们使用`FormControl.setValue()`方法设置表单控件的值，这应该在经过`searchDebounceTime`的时间后触发作为`.subscribe()`方法参数提供的方法。然后我们使用`tick()`方法和`searchDebounceTime`的值，这样就模拟了时间的异步流逝。然后我们编写我们的`expect()`块来检查`searchUsers()`方法是否应该被调用。最后，在测试结束时，我们使用`discardPeriodicTasks()`方法。我们使用这个方法是为了避免出现`Error:
    1 periodic timer(s) still in the queue.`错误，以及我们的测试工作。'
- en: See also
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'RxJS DebounceTime operator: [https://rxjs-dev.firebaseapp.com/api/operators/debounceTime](https://rxjs-dev.firebaseapp.com/api/operators/debounceTime)'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJS DebounceTime操作符：[https://rxjs-dev.firebaseapp.com/api/operators/debounceTime](https://rxjs-dev.firebaseapp.com/api/operators/debounceTime)
- en: Writing your own custom form control using ControlValueAccessor
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ControlValueAccessor编写自定义表单控件
- en: Angular forms are great. While they support the default HTML tags like input,
    textarea etc., sometimes, you would want to define your own components that take
    a value from the user. It would be great if the variables of those inputs were
    a part of the Angular form you're using already.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Angular表单很棒。虽然它们支持默认的HTML标签，如input、textarea等，但有时，您可能希望定义自己的组件，以从用户那里获取值。如果这些输入的变量是您已经在使用的Angular表单的一部分，那就太好了。
- en: In this recipe, you'll learn how to create your own custom Form Control using
    the ControlValueAccessor API, so you can use the Form Control with both Template
    Driven forms and Reactive Forms.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您将学习如何使用ControlValueAccessor API创建自己的自定义表单控件，这样您就可以在模板驱动表单和响应式表单中使用表单控件。
- en: Getting ready
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter08/start_here/custom-form-control`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的项目位于`chapter08/start_here/custom-form-control`中：
- en: Open the project in Visual Studio Code.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`以安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab and you should see the following
    view:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器标签中打开应用程序，您应该会看到以下视图：
- en: '![Figure 8.27 – Custom form control app running on http://localhost:4200'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.27 - 自定义表单控件应用程序在http://localhost:4200上运行'
- en: '](image/Figure_8.27_B15150.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.27_B15150.jpg)'
- en: Figure 8.27 – Custom form control app running on http://localhost:4200
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.27 - 自定义表单控件应用程序在http://localhost:4200上运行
- en: Now that we have the app running locally, let's see the steps involved in this
    recipe in the next section.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序在本地运行，让我们在下一节中看看这个食谱涉及的步骤。
- en: How to do it…
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We have a simple Angular app. It has two inputs and a **Submit** button. The
    inputs are for a review and they ask the user to provide a value for the rating
    of this imaginary item and any comments the user wants to provide. We''ll convert
    the Rating input into a custom Form Control using the ControlValueAccessor API.
    Let''s get started:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个简单的Angular应用。它有两个输入和一个**提交**按钮。输入用于评论，要求用户为这个虚构物品的评分和任何评论提供价值。我们将使用ControlValueAccessor
    API将评分输入转换为自定义表单控件。让我们开始吧：
- en: 'Let''s create a component for our custom form control. Open the terminal in
    the project root and run the following command:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为我们的自定义表单控件创建一个组件。在项目根目录中打开终端并运行以下命令：
- en: '[PRE53]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We''ll now create the stars UI for the rating component. Modify the `rating.component.html`
    file as follows:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将为评分组件创建星星UI。修改`rating.component.html`文件如下：
- en: '[PRE54]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Add the styles for the rating component to the `rating.component.scss` file
    as follows:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`rating.component.scss`文件中为评分组件添加样式如下：
- en: '[PRE55]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We also need to modify the `RatingComponent` class to introduce the necessary
    methods and properties. Let''s modify the `rating.component.ts` file as follows:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要修改`RatingComponent`类来引入必要的方法和属性。让我们修改`rating.component.ts`文件如下：
- en: '[PRE56]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now we need to use this rating component instead of the input that we already
    have in the `home.component.html` file. Modify the file as follows:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要在`home.component.html`文件中使用这个评分组件而不是已有的输入。修改文件如下：
- en: '[PRE57]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If you refresh the app now and hover on the stars, you can see the color changing
    as you hover over the stars. The selected rating is also highlighted as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在刷新应用并悬停在星星上，你会看到颜色随着悬停而改变。选定的评分也会被突出显示如下：
- en: '![Figure 8.28 – Rating component with hovered stars'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.28 - 悬停在星星上的评分组件'
- en: '](image/Figure_8.28_B15150.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.28_B15150.jpg)'
- en: Figure 8.28 – Rating component with hovered stars
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.28 - 悬停在星星上的评分组件
- en: 'Let''s now implement the `ControlValueAccessor` interface for our rating component.
    It requires a couple of methods to be implemented and we''ll start with the `onChange()`
    and `onTouched()` methods. Modify the `rating.component.ts` file as follows:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们为我们的评分组件实现`ControlValueAccessor`接口。它需要实现一些方法，我们将从`onChange()`和`onTouched()`方法开始。修改`rating.component.ts`文件如下：
- en: '[PRE58]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We''ll now add the required methods to disable the input when required and
    to set the value of the form control, in other words, the `setDisabledState()`
    and `writeValue()` methods. We''ll also add the `disabled` and `value` properties
    to our `RatingComponent` class as follows:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将添加必要的方法来在需要时禁用输入并设置表单控件的值，换句话说，`setDisabledState()`和`writeValue()`方法。我们还将在`RatingComponent`类中添加`disabled`和`value`属性如下：
- en: '[PRE59]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We need to use the `disabled` property to prevent any UI changes when it is
    `true`. The value of the `value` variable shouldn''t be updated either. Modify
    the `rating.component.ts` file to do so as follows:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要使用`disabled`属性来防止在其值为`true`时进行任何UI更改。`value`变量的值也不应该被更新。修改`rating.component.ts`文件如下：
- en: '[PRE60]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s make sure that we send the value of the `value` variable to `ControlValueAccessor`
    because that''s what we want to access later. Also, let''s set the `disabled`
    property back to `false`. Update the `selectRating` method in the `RatingComponent`
    class as follows:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们确保将`value`变量的值发送到`ControlValueAccessor`，因为这是我们以后要访问的内容。同时，让我们将`disabled`属性设置回`false`。修改`RatingComponent`类中的`selectRating`方法如下：
- en: '[PRE61]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We need to tell Angular that our `RatingComponent` class has a value accessor,
    otherwise using the `formControlName` attribute on the `<app-rating>` element
    will throw errors. Let''s add an `NG_VALUE_ACCESSOR` provider to the `RatingComponent`
    class''s decorator as follows:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要告诉Angular，我们的`RatingComponent`类有一个值访问器，否则在`<app-rating>`元素上使用`formControlName`属性会抛出错误。让我们向`RatingComponent`类的装饰器添加一个`NG_VALUE_ACCESSOR`提供者，如下所示：
- en: '[PRE62]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If you refresh the app now, select a rating, and hit the **Submit** button,
    you should see the values being logged as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在刷新应用程序，选择一个评分，然后点击**提交**按钮，你应该看到以下值被记录：
- en: '![Figure 8.29 – Form value logged using the custom form control'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.29-使用自定义表单控件记录的表单值'
- en: '](image/Figure_8.29_B15150.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.29_B15150.jpg)'
- en: Figure 8.29 – Form value logged using the custom form control
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.29-使用自定义表单控件记录的表单值
- en: Voilà! You just learned how to create a custom form control using `ControlValueAccessor`.
    Refer to the next section to understand how it works.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 看吧！你刚刚学会了如何使用`ControlValueAccessor`创建自定义表单控件。请参考下一节以了解它是如何工作的。
- en: How it works…
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We started the recipe by creating a component that we can use to provide a
    rating for the review we have to submit. We started off by adding the template
    and the styles for the rating component. Notice that we are using an `[ngClass]`
    directive on each of the star elements to add the `rating__star--active` class
    conditionally. Let''s discuss each condition now:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个组件来开始这个配方，我们可以用它来为我们必须提交的评论提供评分。我们首先添加了评分组件的模板和样式。请注意，我们在每个星元素上都使用了`[ngClass]`指令，以有条件地添加`rating__star--active`类。现在让我们讨论每个条件：
- en: '`(isMouseOver && hoveredRating >= star)`: This condition relies on the `isMouseOver`
    and `hoveredRating` variables. The `isMouseOver` variable becomes `true` as soon
    as we mouse over any star and is turned back to `false` when we move away from
    the star. This means that it is only `true` when we''re hovering over a star.
    `hoveredRating` tells us which star we''re hovering over at the moment and is
    assigned the star''s value, in other words, a value from `1` to `5`. So, this
    condition is only true when we''re doing a mouseover, and the hovered star''s
    rating is greater than the value of the current star. So, if we''re hovering over
    the fourth star, all the stars from value `1` to `4` will be highlighted as they''ll
    have the `rating__star--active` class conditionally assigned to them.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(isMouseOver && hoveredRating >= star)`: 这个条件依赖于`isMouseOver`和`hoveredRating`变量。`isMouseOver`变量在我们悬停在任何星星上时立即变为`true`，当我们离开星星时又变回`false`。这意味着只有在我们悬停在星星上时它才为`true`。`hoveredRating`告诉我们我们当前悬停在哪颗星星上，并且被赋予星星的值，换句话说，一个从`1`到`5`的值。因此，只有当我们悬停时，且悬停星星的评分大于当前星星的值时，这个条件才为真。因此，如果我们悬停在第四颗星星上，所有值从`1`到`4`的星星都会被高亮显示，因为它们会有`rating__star--active`类有条件地分配给它们。'
- en: '`(!isMouseOver && value >= star)`: This condition relies on the `isMouseOver`
    variable that we discussed previously and the `value` variable. The `value` variable
    holds the value of the selected rating, which is updated when we click on a star.
    So, this condition is applied when we''re not doing a mouseover and we have the
    value of the `value` variable greater than the current star. This is especially
    beneficial when you have a greater value assigned to the `value` variable and
    try to hover over a star with a lesser value, in which case, all the stars with
    values greater than the hovered star will not be highlighted.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(!isMouseOver && value >= star)`: 这个条件依赖于我们之前讨论过的`isMouseOver`变量和`value`变量。`value`变量保存了所选评分的值，在我们点击星星时更新。因此，当我们没有鼠标悬停并且`value`变量的值大于当前星星时，应用这个条件。当`value`变量被赋予一个较大的值，并且尝试悬停在一个值较小的星星上时，所有值大于悬停星星的星星都不会被高亮显示，这是特别有益的。'
- en: 'Then we used three events on each star: `mouseenter`, `mouseleave`, and `click`,
    and then used our `onRatingMouseEnter`, `onRatingMouseLeave`, and `selectRating`
    methods, respectively, for these events. All of this was designed to ensure that
    the entire UI is fluent and has a good user experience. We then implemented the
    `ControlValueAccessor` interface for our rating component. When we do that, we
    need to define the `onChange` and `onTouched` methods as empty methods, which
    we did as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在每个星星上使用了三个事件：`mouseenter`，`mouseleave`和`click`，然后分别使用我们的`onRatingMouseEnter`，`onRatingMouseLeave`和`selectRating`方法。所有这些都是为了确保整个UI流畅，并具有良好的用户体验。然后我们为我们的评分组件实现了`ControlValueAccessor`接口。当我们这样做时，我们需要定义`onChange`和`onTouched`方法为空方法，我们如下所示：
- en: '[PRE63]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then we used the `registerOnChange` and `registerOnTouched` methods from `ControlValueAccessor`
    to assign our methods as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`ControlValueAccessor`中的`registerOnChange`和`registerOnTouched`方法将我们的方法分配如下：
- en: '[PRE64]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We registered these functions because whenever we do a change in our component
    and want to let `ControlValueAccessor` know that the value has changed, we need
    to call the `onChange` method ourselves. We do that in the `selectRating` method
    as follows, which makes sure that when we select a rating, we set the form control''s
    value to the value of the selected rating:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注册了这些函数，因为每当我们在组件中进行更改并希望让`ControlValueAccessor`知道值已更改时，我们需要自己调用`onChange`方法。我们在`selectRating`方法中这样做，以确保当我们选择评分时，我们将表单控件的值设置为所选评分的值：
- en: '[PRE65]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The other way around is when we need to know when the form control''s value
    is changed from outside the component. In this case, we need to assign the updated
    value to the `value` variable. We do that in the `writeValue` method from the
    `ControlValueAccessor` interface as follows:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种情况是当我们需要知道表单控件的值是从组件外部更改的。在这种情况下，我们需要将更新后的值分配给`value`变量。我们在`ControlValueAccessor`接口的`writeValue`方法中这样做：
- en: '[PRE66]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: What if we don't want the user to provide a value for the rating? In other words,
    we want the rating form control to be disabled. For this, we did two things. First,
    we used the `disabled` property as an `@Input()`, so we can pass and control it
    from the parent component when needed. Secondly, we used the `setDisabledState`
    method from the `ControlValueAccessor` interface, so whenever the form control's
    `disabled` state is changed, apart from `@Input()`, we set the `disabled` property
    ourselves.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望用户为评分提供值怎么办？换句话说，我们希望评分表单控件被禁用。为此，我们做了两件事。首先，我们将`disabled`属性用作`@Input()`，这样我们可以在需要时从父组件传递和控制它。其次，我们使用了`ControlValueAccessor`接口的`setDisabledState`方法，因此每当表单控件的`disabled`状态发生变化时，除了`@Input()`之外，我们自己设置`disabled`属性。
- en: 'Finally, we wanted Angular to know that this `RatingComponent` class has a
    value accessor. This is so that we can use the Reactive forms API, specifically,
    the `formControlName` attribute with the `<app-rating>` selector, and use it as
    a form control. To do that, we provide our `RatingComponent` class as a provider
    to its `@Component` definition decorator using the `NG_VALUE_ACCESSOR` injection
    token as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望Angular知道这个`RatingComponent`类具有值访问器。这样我们就可以使用响应式表单API，特别是使用`<app-rating>`选择器的`formControlName`属性，并将其用作表单控件。为此，我们使用`NG_VALUE_ACCESSOR`注入令牌将我们的`RatingComponent`类作为提供者提供给其`@Component`定义装饰器，如下所示：
- en: '[PRE67]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Note that we''re using the `useExisting` property with the `forwardRef()` method
    providing our `RatingComponent` class in it. We need to provide `multi: true`
    because Angular itself registers some value accessors using the `NG_VALUE_ACCESSOR`
    injection token, and there may also be third-party form controls.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，我们在其中使用`forwardRef()`方法的`useExisting`属性提供了我们的`RatingComponent`类。我们需要提供`multi:
    true`，因为Angular本身使用`NG_VALUE_ACCESSOR`注入令牌注册一些值访问器，还可能有第三方表单控件。'
- en: 'Once we''ve set everything up, we use `formControlName` on our rating component
    in the `home.component.html` file as follows:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置好了一切，我们可以在`home.component.html`文件中如下使用`formControlName`来使用我们的评分组件：
- en: '[PRE68]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: See also
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Custom form control in Angular by Thoughtram: [https://blog.thoughtram.io/angular/2016/07/27/custom-form-controls-in-angular-2.html](https://blog.thoughtram.io/angular/2016/07/27/custom-form-controls-in-angular-2.html)'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Thoughtram在Angular中自定义表单控件：[https://blog.thoughtram.io/angular/2016/07/27/custom-form-controls-in-angular-2.html](https://blog.thoughtram.io/angular/2016/07/27/custom-form-controls-in-angular-2.html)
- en: 'ControlValueAccessor docs: [https://angular.io/api/forms/ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor)'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ControlValueAccessor文档：[https://angular.io/api/forms/ControlValueAccessor](https://angular.io/api/forms/ControlValueAccessor)
