- en: Chapter 2. JSX in Depth
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 JSX 深入
- en: In the first chapter, we built our first component using React. We saw how using
    JSX makes the development easy. In this chapter, we will dive deep into JSX.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们使用 React 构建了我们的第一个组件。我们看到了使用 JSX 如何使开发变得简单。在本章中，我们将深入探讨 JSX。
- en: '**JavaScript XML** (**JSX**) is an XML syntax that constructs the markup in
    React components. React works without JSX, but using JSX makes it easy to read
    and write the React components as well as structure them just like any other HTML
    element.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript XML** (**JSX**) 是一种 XML 语法，用于在 React 组件中构建标记。React 可以不使用 JSX 工作，但使用
    JSX 可以使阅读和编写 React 组件以及对其结构化变得容易，就像任何其他 HTML 元素一样。'
- en: 'In this chapter, we will cover following points:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下要点：
- en: Why JSX?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么使用 JSX？
- en: Transforming JSX into JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 JSX 转换为 JavaScript
- en: Specifying HTML tags and React components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定 HTML 标签和 React 组件
- en: Multiple components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个组件
- en: Different types of JSX tags
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的 JSX 标签
- en: Using JavaScript expressions inside JSX
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 JSX 中使用 JavaScript 表达式
- en: Namespaced components
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间组件
- en: Spread attributes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性展开
- en: CSS styles and JSX
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS 样式和 JSX
- en: JSX Gotchas
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX 的注意事项
- en: At the end of the chapter, we will get familiar with the JSX syntax, how it
    should be used with React, and best practices of using it. We will also study
    some of the corner cases that one can run into while using JSX.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将熟悉 JSX 语法，如何与 React 一起使用它，以及使用它的最佳实践。我们还将研究一些在使用 JSX 时可能会遇到的一些边缘情况。
- en: Why JSX?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用 JSX？
- en: Shawn had a great first day and he was just getting started with the next one
    at Adequate Consulting. With a mug of coffee, he startled Mike.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 肖恩第一天过得很愉快，他在 Adequate Consulting 正在开始新的一天。拿着一杯咖啡，他惊醒了迈克。
- en: '"Hey Mike, I saw that we used JSX for building our first component. Why should
    we use JSX when React has `React.createElement`?"'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '"嗨，迈克，我看到我们用 JSX 构建了我们的第一个组件。为什么我们要使用 JSX，当 React 有 `React.createElement` 时呢？"'
- en: '"You can use React without using JSX. But JSX makes it easy to build React
    components. It reduces the amount of code required to write. It looks like HTML
    markup. Its syntax is simple and concise and it''s very easy to visualize the
    components that are getting built."'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '"您可以在不使用 JSX 的情况下使用 React。但 JSX 使构建 React 组件变得容易。它减少了编写代码所需的数量。它看起来像 HTML 标记。其语法简单简洁，并且很容易可视化正在构建的组件。"'
- en: '"Take an example of the render function of a component without using JSX."'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '"以一个不使用 JSX 的组件的渲染函数为例。"'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '"With JSX, it looks much better."'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '"有了 JSX，看起来好多了。"'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '"Compared to the previous non-JSX example, the JSX code is much more readable,
    easy to understand, and close to the actual HTML markup."'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '"与之前的非 JSX 示例相比，JSX 代码的阅读性更好，易于理解，并且接近实际的 HTML 标记。"'
- en: '"The similarity between JSX and HTML markup means that non-developers such
    as UI and UX designers in the team can contribute to a project using JSX. Having
    XML-like tag syntax also makes reading large component trees easier compared to
    the function calls or object literals in JavaScript." explained Mike.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '"JSX 和 HTML 标记之间的相似性意味着团队中的非开发者，如 UI 和 UX 设计师，可以使用 JSX 为项目做出贡献。拥有类似 XML 的标签语法也使得阅读大型组件树比
    JavaScript 中的函数调用或对象字面量更容易。" 迈克解释道。'
- en: '"Yeah. The syntax does look familiar. We will be using JSX all the way in our
    projects right?"'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的，语法看起来很熟悉。我们将在我们的项目中全程使用 JSX，对吧？"'
- en: '"Yes, we will", remarked Mike.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的，我们会"，迈克说道。'
- en: Transforming JSX into JavaScript
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 JSX 转换为 JavaScript
- en: '"Shawn, as I mentioned, the JSX is transformed to the native JavaScript syntax."'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，正如我提到的，JSX 被转换成原生 JavaScript 语法。"'
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '"This will eventually get transformed to"'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '"这最终会被转换成"'
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for this book from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户中下载本书的示例代码文件。如果您在其他地方购买了此书，您可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 并注册以直接将文件通过电子邮件发送给您。
- en: 'You can download the code files by following these steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下步骤下载代码文件：
- en: Log in or register to our website using your e-mail address and password.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您的电子邮件地址和密码登录或注册我们的网站。
- en: Hover the mouse pointer on the **SUPPORT** tab at the top.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将鼠标指针悬停在顶部的 **SUPPORT** 选项卡上。
- en: Click on **Code Downloads & Errata**.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击 **代码下载与勘误**。
- en: Enter the name of the book in the **Search** box.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **搜索** 框中输入书籍名称。
- en: Select the book for which you're looking to download the code files.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择您想要下载代码文件的书籍。
- en: Choose from the drop-down menu where you purchased this book from.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择您购买此书的来源。
- en: Click on **Code Download**.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击**代码下载**。
- en: 'Once the file is downloaded, please make sure that you unzip or extract the
    folder using the latest version of:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 文件下载后，请确保使用最新版本解压或提取文件夹：
- en: WinRAR / 7-Zip for Windows
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WinRAR / 7-Zip for Windows
- en: Zipeg / iZip / UnRarX for Mac
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zipeg / iZip / UnRarX for Mac
- en: 7-Zip / PeaZip for Linux
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7-Zip / PeaZip for Linux
- en: '"If you would like to see this live in action, try this example at [https://babeljs.io/repl/](https://babeljs.io/repl/).
    It''s a live REPL that can transform a JSX code to the native JavaScript code."'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '"如果你想看到这个实时演示，请尝试这个示例[https://babeljs.io/repl/](https://babeljs.io/repl/)。这是一个实时REPL，可以将JSX代码转换为原生JavaScript代码。"'
- en: '"There is another editor available for converting HTML to JSX. You can check
    it out at [http://facebook.github.io/react/html-jsx.html](http://facebook.github.io/react/html-jsx.html).
    This allows you to paste an arbitrary HTML code that gets converted to JSX with
    extraction of styles, classes, and other information and then create a component
    on top of it." said Mike.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '"还有一个编辑器可以将HTML转换为JSX。你可以在[http://facebook.github.io/react/html-jsx.html](http://facebook.github.io/react/html-jsx.html)查看它。这允许你粘贴任意HTML代码，该代码会被转换为JSX，并提取样式、类和其他信息，然后在此基础上创建一个组件。"
    迈克说。'
- en: '"Pretty handy. However, this is just for ease of development, right? What happens
    when we deploy our code?" asked Shawn.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '"非常方便。然而，这只是为了开发方便，对吧？当我们部署我们的代码时会发生什么？" 肖恩问道。'
- en: '"JSX is not meant to be compiled at runtime. Though there is a JSX transformer
    that converts JSX to JavaScript in a browser. Using it to compile JSX at runtime
    in the browser would slow down our application. We will use tools such as Babel,
    which is a JavaScript transpiler to convert our JSX code to the native JavaScript
    code before deploying the application."'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '"JSX不是用来在运行时编译的。尽管有一个JSX转换器可以在浏览器中将JSX转换为JavaScript。在浏览器中用它来编译JSX会减慢我们的应用程序。我们将使用像Babel这样的工具，它是一个JavaScript编译器，在部署应用程序之前将我们的JSX代码转换为原生JavaScript代码。"'
- en: HTML tags vs React components
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML标签与React组件
- en: '"Mike, I am intrigued by one more thing. In JSX, we are mixing the React components
    as if they are simple HTML tags. We did this in our first component."'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '"迈克，我对另一件事很感兴趣。在JSX中，我们就像简单的HTML标签一样混合React组件。我们在第一个组件中就是这样做的。"'
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '"The `App` tag is not a valid HTML tag here. But this still works."'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '"这里的`App`标签不是一个有效的HTML标签。但这仍然有效。"'
- en: '"Yes. That''s because we can specify both HTML tags and React components in
    JSX. There is a subtle difference though. HTML tags start with a lowercase letter
    and React components start with an uppercase letter." Mike explained.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的。这是因为我们可以在JSX中指定HTML标签和React组件。不过，这里有一个细微的区别。HTML标签以小写字母开头，而React组件以大写字母开头。"
    迈克解释道。'
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '"That''s the primary difference. JSX uses this convention to differentiate
    between the local component classes and HTML tags."'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '"这是主要区别。JSX使用这个约定来区分本地组件类和HTML标签。"'
- en: Self closing tag
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自闭合标签
- en: '"Another thing that you must have noticed is how the component tag is closed
    in `ReactDOM.render`" added Mike.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '"迈克补充说，你肯定注意到了在`ReactDOM.render`中组件标签是如何关闭的。"'
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '"As JSX is based on XML, it allows adding a self-closing tag. All the component
    tags must be closed either with self-closing format or with a closing tag."'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '"由于JSX基于XML，它允许添加自闭合标签。所有组件标签都必须以自闭合格式或闭合标签结束。"'
- en: '"Thanks Mike! Things make much more sense now."'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '"谢谢迈克！现在事情变得更有意义了。"'
- en: Multiple components
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个组件
- en: '"Shawn, let''s get back to our application. We are using almost the same code
    from last time but you can set up a new JSBin. We have included the latest React
    library and bootstrap library in the HTML tab. We have also added a container
    element, which we will render our React app."'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，让我们回到我们的应用程序。我们几乎使用了上次相同的代码，但你可以设置一个新的JSBin。我们在HTML标签中包含了最新的React库和bootstrap库。我们还添加了一个容器元素，我们将在这里渲染我们的React应用程序。"'
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '"Right now, we are only using a single component to display the data from the
    recent changes API."'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '"目前，我们只使用单个组件来显示最近更改API的数据。"'
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '"Let''s split this single component into small composable components. These
    simple modular components will use other modular components with well-defined
    self-contained interfaces."'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '"让我们将这个单个组件拆分成小的可组合组件。这些简单的模块化组件将使用其他模块化组件，这些组件具有定义良好的自包含接口。"'
- en: '"Got it" said Shawn.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '"明白了" 肖恩说。'
- en: '"Ok. The first step is trying to identify the different components that are
    present in our single component."'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '"好的。第一步是尝试识别我们单个组件中存在的不同组件。"'
- en: '"Currently, our render method lists `tableHeadings` and `tableRows` as the
    children of table element."'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '"目前，我们的渲染方法将`tableHeadings`和`tableRows`作为表格元素的子元素列出。"'
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '"I guess we will make the components for the headings and rows?" Shawn asked.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '"我想我们将为标题和行创建组件？" 肖恩问道。'
- en: '"Yes. But we can go one step further. Both headings and rows are lists of still
    smaller units, a `Heading` and a `Row` tag, respectively. It can be visualized
    as follows:"'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的。但我们可以更进一步。标题和行都是更小单元的列表，分别是`Heading`和`Row`标签。它可以这样可视化："'
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '"Makes sense, Mike. Let me try to create `Heading` now."'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '"有道理，迈克。我现在尝试创建`Heading`。"'
- en: '"Sure, go ahead."'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '"当然，继续吧。"'
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '"Mike, I think this will work, except the heading. I am not sure how to render
    the actual heading in the `<th>` tag."'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '"迈克，我认为这会起作用，除了标题。我不确定如何在`<th>`标签中渲染实际的标题。"'
- en: '"Don''t worry about it. Let''s just assume that it will be passed as props
    to the `Heading` component."'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '"不用担心。我们只需假设它将被作为props传递给`Heading`组件。"'
- en: '"Sure. Here is the `Heading` component then:"'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '"当然。这是`Heading`组件的代码："'
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '"Perfect! The `Row` component will also be similar to `Heading`. It will get
    the `changeSet` object in its props"'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '"太好了！`Row`组件也将类似于`Heading`。它将在其props中获取`changeSet`对象。"'
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '"Shawn, we are done with lowest-level components. Now, it''s time to move up
    a level. Let''s build `Headings` first."'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，我们已经完成了最低级别的组件。现在，是时候提升一个层次了。让我们先构建`Headings`。"'
- en: '"Similar to how a `Heading` component will get its title in props, `Headings`
    will get a list of titles passed to it."'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '"类似于`Heading`组件将通过props获取其标题，`Headings`将获取传递给它的标题列表。"'
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '"We are iterating over the list of titles and converting them into a list of
    the `Heading` components. The `Headings` component is controlling how the props
    are passed to the individual `Heading` components. In a sense, individual `Heading`
    components are owned by `Headings`." explained Mike.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们正在遍历标题列表，并将它们转换为`Heading`组件的列表。`Headings`组件控制如何将props传递给单个`Heading`组件。从某种意义上说，单个`Heading`组件是`Headings`的拥有者。"
    迈克解释道。'
- en: '"In React, an owner is the component that sets props of other components. We
    can also say that if the X component is present in the `render()` method of the
    Y component, then Y owns X." Mike further added.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '"在React中，拥有者是指设置其他组件props的组件。我们也可以说，如果X组件存在于Y组件的`render()`方法中，那么Y就拥有X。" 迈克进一步补充道。'
- en: '"Shawn, go ahead and build the Rows component similar to `Headings`."'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，去构建一个类似于`Headings`的`Rows`组件。"'
- en: '"Here you go:"'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '"给你："'
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '"There is just one issue. You can''t render the rows as it''s a collection
    of components. Remember that the `render()` function can only render one tag"
    Mike said.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '"只有一个问题。你不能渲染行，因为它是一组组件的集合。记住，`render()`函数只能渲染一个标签。" 迈克说。'
- en: '"I guess I should wrap the rows in a `<tbody>` tag.", Shawn."'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '"我想我应该将行包裹在`<tbody>`标签中。" 肖恩说。'
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '"Perfect. We have almost everything now. Let''s finish it by adding the top-level
    `App` component."'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '"太好了。我们现在几乎有了所有东西。让我们通过添加顶级的`App`组件来完成它。"'
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '"Here''s how our complete code looks now:"'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '"现在我们的完整代码看起来是这样的："'
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '"Shawn, I think you have understood the power of composability of components
    now. It makes our UI easy to reason with and easy to reuse and compose. We will
    be using this philosophy throughout with React."'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，我想你现在已经理解了组件的可组合性力量。这使得我们的UI易于推理和重用以及组合。我们将在整个React中使用这种哲学。"'
- en: '"I agree. Every component does one thing right and in the end, all of them
    get composed together so that the whole application is built. Different parts
    of the code get separated in such a way that they don''t interfere with each other."'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '"我同意。每个组件都做了一件事，最终，它们都被组合在一起，从而构建了整个应用程序。代码的不同部分被分离，这样它们就不会相互干扰。"'
- en: JavaScript expressions
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript表达式
- en: '"Shawn, let''s discuss a bit about how we have rendered the `Rows` and `Headings`
    tag."'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，让我们讨论一下我们是如何渲染`Rows`和`Headings`标签的。"'
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '"We are rendering `{headings}`, which is a list of React components, directly
    by adding them in curly braces as children of the `<tr>` tag. These expressions
    that are used to specify the child components are called child expressions."'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们正在直接通过在`<tr>`标签的子元素中添加花括号来渲染`{headings}`，这是一个React组件列表。用于指定子组件的表达式被称为子表达式。"'
- en: '"There is another category of expressions called as JavaScript expressions.
    These are simple expressions used for passing props or evaluating some JavaScript
    code that can be used as an attribute value."'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '"还有一种称为 JavaScript 表达式的表达式类别。这些是用于传递 props 或评估一些可以用作属性值的 JavaScript 代码的简单表达式。"'
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '"Anything that is present in curly braces is evaluated by JSX. It works for
    both children expressions as well as JavaScript expressions," added Mike.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '"任何在花括号中的内容都会被 JSX 评估。它适用于子表达式以及 JavaScript 表达式。" 迈克补充道。'
- en: '"Thanks for the detailed explanation. I have a query though. Is there any way
    to write comments in the JSX code? I mean, we may not need it all the time, but
    knowing how to add comments might be handy," Shawn asked.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '"感谢详细的解释。不过，我有一个疑问。在 JSX 代码中写注释有办法吗？我的意思是，我们可能并不总是需要它，但知道如何添加注释可能很有用。" 肖恩问道。'
- en: '"Remember the curly braces rule. Comments are simply just JavaScript expressions.
    When we are in a child element, just wrap the comments in the curly braces."'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '"记住花括号规则。注释只是简单的 JavaScript 表达式。当我们处于子元素中时，只需将注释放在花括号中。"'
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '"You can also add comments in a JSX tag. There is no need to wrap them in curly
    braces in this case," Mike added.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '"你还可以在 JSX 标签中添加注释。在这种情况下，没有必要将它们放在花括号中。" 迈克补充道。'
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Namespaced components
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间组件
- en: '"Shawn, you must have used modules and packages in languages such as Ruby and
    Java. The idea behind these concepts is to create a namespace hierarchy of code
    such that the code from one module or package doesn''t interfere with another."'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，你一定在 Ruby 和 Java 等语言中使用过模块和包。这些概念背后的想法是创建一个代码的命名空间层次结构，使得一个模块或包中的代码不会干扰另一个模块或包。"'
- en: '"Yes. Is something like this available with React?" Shawn asked.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的。React 中有类似的东西吗？" 肖恩问道。'
- en: '"Yes. React allows creating components that are namespaced under a parent component
    so that they don''t interfere with other components or global functions."'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的。React 允许创建在父组件下命名的组件，这样它们就不会干扰其他组件或全局函数。"'
- en: '"We are using very generic names such as Rows and Headings that can be used
    later in other parts of the app too. So it makes sense to namespace them now,
    rather than later." explained Mike.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们正在使用非常通用的名称，如 Rows 和 Headings，这些名称可以在应用程序的其他部分使用。因此，现在命名空间它们比以后命名空间它们更有意义。"
    迈克解释说。'
- en: '"Agreed. Let''s do it right away," Shawn.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '"同意。我们立刻这么做。" 肖恩说。'
- en: '"We need to represent the top-level component as custom component rather than
    using the `<table>` element."'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们需要将顶层组件表示为自定义组件，而不是使用 `<table>` 元素。"'
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '"Now, we can replace the `App` component to use `RecentChangesTable` instead
    of `<table>.`"'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '"现在，我们可以将 `App` 组件替换为使用 `RecentChangesTable` 而不是 `<table>`。"'
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '"Hang on, Mike. We just replaced `<table>` with a custom component. All it
    does is just render `this.props.children`. How does it get all the headings and
    rows?" Shawn asked.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '"等等，迈克。我们刚刚用自定义组件替换了 `<table>`。它所做的只是渲染 `this.props.children`。它是如何获取所有标题和行的？"
    肖恩问道。'
- en: '"Ah! Nice observation. React, by default, captures all the child nodes between
    open and close tags of a component in an array and adds it to the props of that
    component as `this.props.children`. So we can render it using `{this.props.children}`.
    We will get all Headings and Rows as `this.props.children` in the `RecentChangesTable`
    component. The output is the same as before, when we used the `<table>` tag directly."'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '"啊！很好的观察。React 默认情况下，会捕获组件打开和关闭标签之间的所有子节点，并将它们作为一个数组添加到该组件的 props 中，作为 `this.props.children`。因此，我们可以使用
    `{this.props.children}` 来渲染它。在 `RecentChangesTable` 组件中，我们将得到所有标题和行作为 `this.props.children`。输出与之前使用
    `<table>` 标签时相同。"'
- en: '"Awesome!" exclaimed Shawn.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '"太棒了！" 肖恩兴奋地喊道。'
- en: '"Cool. Let''s move on next step by namespacing all other components under `RecentChangesTable`."'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '"太好了。让我们继续下一步，将所有其他组件在 `RecentChangesTable` 下命名空间。"'
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '"We will also need to update the `App` component to use namespaced components
    now."'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们现在还需要更新 `App` 组件，以使用命名空间组件。"'
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '"We are now done. Everything is namespaced under `RecentChangesTable` now",
    said Mike.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们现在完成了。现在，所有内容都在 `RecentChangesTable` 的命名空间下。" 迈克说。'
- en: Spread attributes
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性展开
- en: Shawn learned a lot of things about JSX but when he was reflecting on the previous
    steps, he came up with another question.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 肖恩学到了很多关于 JSX 的知识，但在反思之前的步骤时，他又提出了另一个问题。
- en: '"Mike, as of now we are just passing two props to the `App` component: `headings`
    and `changesets`. However, tomorrow these props can increase to any number. Passing
    them one by one would be cumbersome. Especially, when we have to pass some data
    from the recent changes API directly. It will be hard to a keep track of the structure
    of the incoming data and pass it accordingly in the props. Is there a better way?"'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '"迈克，到目前为止，我们只是向 `App` 组件传递了两个 props：`headings` 和 `changesets`。然而，明天这些 props
    可以增加到任意数量。逐个传递它们可能会很繁琐。特别是，当我们需要直接从最近更改的 API 传递一些数据时。这将很难跟踪传入数据的结构，并相应地在 props
    中传递。有没有更好的方法？"'
- en: '"Another excellent question, Shawn. True, it might be cumbersome passing a
    large number of attributes to the component one by one. But we can solve this
    using the `spread` attributes."'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '"另一个出色的问题，肖恩。是的，逐个传递大量属性给组件可能会有些繁琐。但我们可以使用 `spread` 属性来解决这个问题。"'
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '"In this case, all the properties of object are passed as props to the `App`
    component. We can pass any object that can contain any number of key value pairs
    and all of them will be passed as props to the component" explained Mike.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '"在这种情况下，对象的所有属性都作为 props 传递给 `App` 组件。我们可以传递任何可以包含任意数量键值对的任何对象，并且所有这些都会作为 props
    传递给组件" 迈克解释道。'
- en: '"Very cool. Is the `(…)` operator present only in JSX?"'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '"非常酷。`(…)` 运算符只存在于 JSX 中吗？"'
- en: '"Nope. It is actually based on the spread attribute feature in ES2015, which
    is the next JavaScript standard. ES2015, or ES6 as it is called, introduces some
    new features in JavaScript language and React is taking advantage of these developing
    standards in order to provide a cleaner syntax in JSX" added Mike.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '"不，它实际上是基于 ES2015 中的扩展属性特性，这是下一个 JavaScript 标准。ES2015，或称为 ES6，在 JavaScript
    语言中引入了一些新特性，React 正在利用这些发展中的标准，以便在 JSX 中提供更干净的语法" 迈克补充道。'
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: ES2015 already supports spread operator for arrays at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
    There is also a proposal for objects at [https://github.com/sebmarkbage/ecmascript-rest-spread](https://github.com/sebmarkbage/ecmascript-rest-spread).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015 已经支持数组使用扩展运算符，详情请见 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator)。对于对象也有一个提案，请见
    [https://github.com/sebmarkbage/ecmascript-rest-spread](https://github.com/sebmarkbage/ecmascript-rest-spread)。
- en: '"Not only this, spread attributes can be used multiple times or it can be combined
    with other attributes. The order of the attributes is important though. Newer
    attributes override previous ones."'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '"不仅如此，散列属性可以多次使用，或者可以与其他属性结合使用。不过，属性的顺序很重要。新属性会覆盖之前的属性。"'
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '"Instead of showing **When**, **Who**, and **Description**, **Updated at**,
    **Author**, and **Change** will be shown as the headings in this case" Mike explained.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '"在这种情况下，将显示 **When**、**Who** 和 **Description**，而 **Updated at**、**Author**
    和 **Change** 将作为标题显示" 迈克解释说。'
- en: '![Spread attributes](img/4730_02_01.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![散列属性](img/4730_02_01.jpg)'
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: ES2015 or ES6 is the latest version JavaScript standard. It has a lot of features,
    which are used by React, similar to the spread attributes. We will be using lot
    more ES2015 or ES6 code in the upcoming chapters.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015 或 ES6 是最新的 JavaScript 标准版本。它有很多特性，这些特性被 React 使用，类似于扩展运算符。在接下来的章节中，我们将使用更多的
    ES2015 或 ES6 代码。
- en: Styles in JSX
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX 中的样式
- en: '"Mike, all of the things that we did today are very cool. When do we start
    adding styles? How can I make this page look pretty? Right now it''s a bit dull."
    Shawn asked.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '"迈克，我们今天所做的一切都非常酷。我们什么时候开始添加样式？我怎样才能让这个页面看起来更漂亮？现在它有点单调。" 肖恩问道。'
- en: '"Ah, right. Let''s do that. React allows us to pass styles to the components
    the same way props can be passed. For example, we want our headings to be of the
    floral white color and maybe we want to change the font size. We will represent
    it in a typical CSS way as follows:"'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '"啊，对了。我们就这样做。React 允许我们以与传递 props 相同的方式传递样式。例如，我们想让我们的标题颜色为花白色，也许我们还想改变字体大小。我们将以典型的
    CSS 方式表示如下："'
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '"We can represent this as a JavaScript object in the CamelCase fashion."'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们可以用驼峰式表示法将其表示为一个 JavaScript 对象。"'
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Then, we can use it in each Heading component as a JavaScript object."
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在每个标题组件中将其用作一个 JavaScript 对象。"
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '"Similarly, let''s change the rows to have their own styles."'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '"同样，让我们改变行以拥有它们自己的样式。"'
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '"We now have some shiny new headings and rows sprinkled by CSS styling" Mike
    added.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们现在有一些闪闪发光的新标题和行，它们被 CSS 样式所点缀" 迈克补充道。'
- en: '![Styles in JSX](img/4730_02_02.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![JSX 中的样式](img/4730_02_02.jpg)'
- en: '"Nice. The name of the attribute to pass these styles must be ''style'', right?"
    Shawn asked.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '"好的。传递这些样式的属性名必须是 ''style''，对吧？" 肖恩问道。'
- en: '"Yes. Also the keys of this style object need to be CamelCased, for example,
    `backgroundColor`, `backgroundImage`, `fontSize`, and so on."'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的。此外，这个样式对象的键也需要使用驼峰式命名，例如，`backgroundColor`、`backgroundImage`、`fontSize`
    等等。"'
- en: '"Mike, I understood the inline styling, however, how to add the CSS classes?"'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '"迈克，我理解了内联样式，但是如何添加 CSS 类？"'
- en: '"Ah right. We can pass the class name as an attribute to the DOM tags. Let''s
    extract the styling to a new `recentChangesTable` CSS class."'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '"啊，对了。我们可以将类名作为属性传递给 DOM 标签。让我们将样式提取到一个新的 `recentChangesTable` CSS 类中。"'
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '"Now, to apply this class to our component, all we need to do is pass it to
    the component using the expalined `className` prop."'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '"现在，为了将这个类应用到我们的组件上，我们只需要使用解释过的 `className` 属性将其传递给组件。"'
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '"As we have seen previously, React makes use of the CamelCase attributes. Here,
    the `className` prop will be converted to a normal class attribute when React
    renders the actual HTML."'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '"正如我们之前所看到的，React 使用驼峰式属性。在这里，当 React 渲染实际的 HTML 时，`className` 属性将被转换为正常的类属性。"'
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '"We can also pass multiple classes to the `className` prop."'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们也可以将多个类传递给 `className` 属性。"'
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '"That''s it! We can simply start using the styles freely in our components.
    This makes it trivial to integrate React with existing CSS styles."'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '"就这样！我们可以在我们的组件中自由地使用样式。这使得将 React 与现有的 CSS 样式集成变得非常简单。"'
- en: JSX Gotchas
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX 的注意事项
- en: The day was heading to an end. Mike and Shawn were still discussing about this
    shiny new thing—JSX. Mike decided that it was time to tell Shawn about the issues
    with using JSX.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '"那天即将结束。迈克和肖恩还在讨论这个闪亮的新事物——JSX。迈克决定是时候告诉肖恩使用 JSX 的问题了。"'
- en: '"Shawn, so how do you feel about using JSX?"'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，你对使用 JSX 感觉如何？"'
- en: '"I liked it so far. It''s very similar to the HTML markup. I can pass attributes,
    styles, and even classes. I can also use all the DOM elements" explained Shawn.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '"到目前为止，我很喜欢它。它与 HTML 标记非常相似。我可以传递属性、样式，甚至类。我还可以使用所有的 DOM 元素。" 肖恩解释说。'
- en: '"Yes. But JSX is not HTML. We have to always remember this. Otherwise, we will
    run into trouble."'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的。但是 JSX 不是 HTML。我们一定要记住这一点。否则，我们可能会遇到麻烦。"'
- en: '"For example, if you want to pass some custom attribute that does not exist
    in the HTML specification, then React will simply ignore it."'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '"例如，如果你想传递一些在 HTML 规范中不存在的自定义属性，那么 React 将简单地忽略它。"'
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '"It must be passed as a data attribute so that React will render it."'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '"它必须作为数据属性传递，这样 React 才会渲染它。"'
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '"We may also run into some issues while rendering the HTML content dynamically.
    In the JSX tags, we can add a valid HTML entity directly."'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '"在动态渲染 HTML 内容时，我们可能会遇到一些问题。在 JSX 标签中，我们可以直接添加一个有效的 HTML 实体。"'
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '"But if we render it in a dynamic expression, it will then escape the ampersand."'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '"但是如果我们用动态表达式渲染它，它就会逃逸掉 ampersand。"'
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '"It happens as React escapes all the strings in order to prevent XSS attacks
    by default. To overcome it, we can directly pass the Unicode character of `&amp;`
    or we can use arrays of strings and JSX elements." Mike explained.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '"React 默认会转义所有字符串，以防止 XSS 攻击。为了克服这个问题，我们可以直接传递 `&amp;` 的 Unicode 字符，或者我们可以使用字符串数组和
    JSX 元素。" 迈克解释说。'
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '"Wow. It can get pretty messed up" expressed Shawn.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '"哇。这可能会变得相当混乱" 肖恩表示。'
- en: '"Well, yes, but if we remember the rules, then it''s pretty simple. Also, as
    a last resort, React also allows to render raw HTML using a special `dangerouslySetInnerHTML`
    prop."'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '"嗯，是的，但是如果我们记住规则，那么这很简单。而且，作为最后的手段，React 也允许使用特殊的 `dangerouslySetInnerHTML`
    属性来渲染原始 HTML。"'
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '"Although this option should be used after consideration about what is getting
    rendered to prevent XSS attacks" Mike explained.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '"迈克解释说，尽管这个选项应该在考虑了渲染内容之后使用，以防止 XSS 攻击。"'
- en: Conditionals in JSX
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX 中的条件
- en: '"React embraces the idea of tying markup and logic that generates the markup
    together. This means that we can use the power of JavaScript for loops and conditionals."'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '"React 赞同将标记和生成标记的逻辑联系在一起的想法。这意味着我们可以使用 JavaScript 的循环和条件语句的强大功能。"'
- en: '"But if/else logic is a bit hard to express in markup. Therefore, in JSX, we
    can''t use conditional statements such as if/else."'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '"但是，在标记中表达 if/else 逻辑有点困难。因此，在 JSX 中，我们不能使用 if/else 这样的条件语句。"'
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '"Instead, we can use a ternary operator for specifying the if/else logic."'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '"相反，我们可以使用三元运算符来指定 if/else 逻辑。"'
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '"But ternary operator gets cumbersome with large expressions when we want to
    use the React component as a child. In this case, it''s better to offload the
    logic to a block or maybe a function" Mike added.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '"但是，当我们要使用React组件作为子组件时，大型表达式使用三元运算符会变得繁琐。在这种情况下，将逻辑卸载到块或函数中会更好。" 迈克补充说。'
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Non-DOM attributes
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非DOM属性
- en: '"Alright Shawn, it''s time to take a detailed look at our application again.
    If you closely see the console output, you will see a few warnings related to
    Keys."'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '"好吧，肖恩，是时候再次详细查看我们的应用程序了。如果你仔细查看控制台输出，你会看到一些与键相关的警告。"'
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '"In the `render()` method of `Rows`, we are rendering collection of the `Row`
    components."'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '"在`Rows`组件的`render()`方法中，我们正在渲染`Row`组件的集合。"'
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '"During the rendering of list items, a component may move up or down in the
    DOM tree based on the user interaction. For example, in case of search or sorting,
    the items in the list can change their position. New items can also get added
    to the front of the list in case new data gets fetched. In such cases, React may
    remove and recreate components based on the diff algorithm. But if we provide
    a unique identifier for each element in the list, then React will intelligently
    decide whether to destroy it or not. This will improve the rendering performance.
    This can be achieved by passing a unique `key` prop to every item in the list."'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '"在渲染列表项期间，根据用户交互，组件可能在DOM树中上下移动。例如，在搜索或排序的情况下，列表中的项可以改变其位置。如果获取到新数据，新项也可以添加到列表的前面。在这种情况下，React可能会根据diff算法删除并重新创建组件。但如果我们为列表中的每个元素提供一个唯一的标识符，那么React将智能地决定是否销毁它。这将提高渲染性能。这可以通过将唯一的`key`属性传递给列表中的每个项来实现。"'
- en: In our case, the number of rows is currently fixed. But later on, we want to
    show the updates page as the new data is being fetched from the API. The situation
    gets complicated when children are added or removed dynamically as the state and
    identity of each component must be maintained in every render pass. The `key`
    prop will help React to uniquely identify the component in such cases. Go ahead
    and use the index of the `Row` component for this purpose as it will be unique
    as of now" Mike further explained.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个例子中，行数目前是固定的。但稍后，我们希望在从API获取新数据时显示更新页面。当动态添加或删除子组件时，情况会变得复杂，因为每个组件的状态和标识必须在每次渲染过程中保持不变。`key`属性将帮助React在这种情况下唯一地识别组件。迈克进一步解释说：“继续使用`Row`组件的索引来完成这个目的，因为现在它是唯一的。”
- en: '"Cool. So let me try adding the `key` prop to `Rows`. I noticed same issue
    with the `Headings` component too, therefore, I will add a key for `Headings`
    as well." said Shawn.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '"很好。那么让我尝试给`Rows`组件添加`key`属性。我也注意到`Headings`组件也存在相同的问题，因此，我将为`Headings`也添加一个键。"
    肖恩说。'
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '"Perfect. Note that the value of keys for a given list should be unique. We
    will get to know more about the keys when we start updating the DOM based on dynamic
    data. But this is good enough for now" said Mike.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '"完美。请注意，给定列表的键值应该是唯一的。当我们开始根据动态数据更新DOM时，我们将了解更多关于键的信息。但这对现在来说已经足够了。" 迈克说。'
- en: '"Makes sense. Are there any more such keywords/identifiers available for us?"'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '"有道理。还有其他这样的关键字/标识符可供我们使用吗？"'
- en: '"Yes. Along with key, there is also refs or references. It allows the parent
    component to keep a reference of a child component. Right now, we can''t access
    the child components outside the `render()` method of the component. But having
    `ref` allows us to use the child component anywhere in the component, not just
    the `render()` method."'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的。除了键，还有引用或refs。它允许父组件保持对子组件的引用。目前，我们无法在组件的`render()`方法之外访问子组件。但拥有`ref`允许我们在组件的任何地方使用子组件，而不仅仅是`render()`方法。"'
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '"Now, we can access these references outside the render method too."'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '"现在，我们可以在`render`方法之外访问这些引用了。"'
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '"It''s pretty useful when we want to inform a component to change something
    at runtime. We will discuss and use `refs` in more detail later when we deal with
    event handlers" Mike added.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '"当我们想要在运行时通知组件更改某些内容时，这非常有用。我们将在处理事件处理程序时详细讨论和使用`refs`。" 迈克补充说。'
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we dived deep into JSX. We discussed why using JSX makes development
    with React easy and how JSX gets transformed into the plain native JavaScript.
    We split big the single React component into small, focused components and understood
    the advantages of reusable, modular components. We saw different JSX tags, JavaScript
    expressions, and how React is taking advantages of ES6 features such as spread
    attributes. In the end, we discussed advanced topics such as namespaced components
    and some gotchas that we should keep in mind while using JSX.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了 JSX。我们讨论了为什么使用 JSX 使得使用 React 进行开发变得容易，以及 JSX 如何被转换成纯原生 JavaScript。我们将大的单个
    React 组件拆分成小而专注的组件，并理解了可重用、模块化组件的优势。我们看到了不同的 JSX 标签、JavaScript 表达式，以及 React 如何利用
    ES6 特性，如扩展属性。最后，我们讨论了高级主题，例如命名空间组件和一些在使用 JSX 时应该注意的陷阱。
- en: In the next chapter, we will focus on data flow and models to access data and
    component life cycle and their use.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重点关注数据流和模型，以访问数据和组件生命周期及其使用。
