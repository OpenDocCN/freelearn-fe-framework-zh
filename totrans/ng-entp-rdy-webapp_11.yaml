- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recipes – Reusability, Routing, and Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next two chapters, we will complete the majority of the implementation
    of LemonMart and round out our coverage of the router-first approach. In this
    chapter, I will reinforce the idea of a decoupled component architecture through
    the creation of a reusable and routable component that also supports data binding.
    We use Angular directives to reduce boilerplate code and leverage classes, interfaces,
    enums, validators, and pipes to maximize code reuse with TypeScript and ES features.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we will create a multi-step form that architecturally scales well
    and supports a responsive design. Then, we will differentiate between user controls
    and components by introducing a lemon rater and a reusable form part that encapsulates
    the name object.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to have your **lemon-mart-server** up and running as you implement
    the recipes mentioned in this chapter. Refer to *Chapter 10*, *RESTful APIs and
    Full-Stack Implementation*, for more information.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers a lot of ground. It is organized in recipe format, so you
    can quickly refer to a particular implementation when you are working on your
    projects. I will cover the architecture, design, and major components of the implementations.
    I will highlight important pieces of code to explain how the solution comes together.
    Leveraging what you've learned so far, I expect the reader to fill in routine
    implementation and configuration details. However, you can always refer to the GitHub
    project if you get stuck.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP PUT requests with caching service responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-step responsive forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusing repeating template behavior with directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalable form architecture with reusable form parts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input masking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom controls with `ControlValueAccessor`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layouts using grid list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the repository linked shortly. The repository contains the final and completed
    state of the code. You can verify your progress at the end of this chapter by
    looking at the end-of-chapter snapshot of the code under the `projects` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get set up for this chapter, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Clone the repo at [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm install` on the root folder to install the dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code sample for this chapter is available under the following subfolder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the Angular app for this chapter, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run Angular unit tests for this chapter, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run Angular e2e tests for this chapter, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To build a production-ready Angular app for this chapter, execute the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `dist/ch11` folder at the root of the repository will contain
    the compiled result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Beware that the source code in the book or on GitHub may not always match the
    code generated by the Angular CLI. There may also be slight differences in implementation
    between the code in the book and what's on GitHub because the ecosystem is ever-evolving.
    It is natural for the sample code to change over time. Also on GitHub, expect
    to find corrections, fixes to support newer versions of libraries, or side-by-side
    implementations of multiple techniques for the reader to observe. The reader is
    only expected to implement the ideal solution recommended in the book. If you
    find errors or have questions, please create an issue or submit a pull request
    on GitHub for the benefit of all readers.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about updating Angular in *Appendix C*, *Keeping Angular and
    Tools Evergreen*. You can find this appendix online from [https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.)
    or at [https://expertlysimple.io/stay-evergreen](https://expertlysimple.io/stay-evergreen).
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with implementing a user service to retrieve data, so we can build
    out a form to display and edit profile information. Later, we will refactor this
    form to abstract out its reusable parts.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a user service with GET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to implement a user profile, we need a service that can perform CRUD
    operations on `IUser`. We will be creating a user service that implements the
    following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Before creating the service, make sure to start the **lemon-mart-server** and
    set your application's `AuthMode` to `CustomServer`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will implement the `getUser` and `updateUser` functions.
    We will implement `getUsers` in *Chapter 12*, *Recipes – Master/Detail, Data Tables,
    and NgRx*, to support pagination with a data table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating the user service:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `UserService` under `src/app/user/user`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare the `IUserService` interface from the preceding snippet, excluding the
    `getUsers` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend the `UserService` class with `CacheService` and implement `IUserService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inject the `HttpClient` in the constructor as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `getUser` function as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We provide a `getUser` function that can load any user's profile information.
    Note that the security for this function is provided in the server implementation
    with the authenticate middleware. The requestor can either get their own profile
    or they'll need to be a manager. We use `getUser` with a resolve guard later in
    the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing PUT with caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implement `updateUser`, which accepts an object that implements the `IUser`
    interface, so the data can be sent to a PUT endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the cache service with `setItem` to save user-entered data in
    case the `put` call fails. When the call succeeds, we remove the cached data using
    `removeItem`. Also note how we hydrate a user coming from the server as a `User`
    object with `map(User.Build)`, which calls the constructor of `class User`.
  prefs: []
  type: TYPE_NORMAL
- en: Hydrate is a common term that refers to populating an object with data from
    a database or a network request. For example, the `User` JSON object we pass between
    components or receive from the server fits the `IUser` interface, but it is not
    of the `class User` type. We serialize objects to JSON using the `toJSON` method.
    When we hydrate and then instantiate a new object from JSON, we do the reverse
    and deserialize the data.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to highlight that you should always stick to interfaces, and
    not concrete implementations like `User`, when passing data around. This is the
    **D** in **SOLID** – the Dependency Inversion Principle. Depending on concrete
    implementations creates a lot of risk, because they change a lot, whereas an abstraction
    such as `IUser` will seldom change. After all, you wouldn't solder a lamp directly
    to the electrical wiring in the wall. Instead, you would first solder the lamp
    to a plug and then use the plug to get the electricity you need.
  prefs: []
  type: TYPE_NORMAL
- en: With this code completed, `UserService` can now be used for basic CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-step responsive forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overall forms are a different beast than the rest of your application and they
    require special architectural considerations. I don't recommend over-engineering
    your form solution with dynamic templates or route-enabled components. By definition,
    the different parts of a form are tightly coupled. From the perspectives of maintainability
    and ease of implementation, creating one giant component is a better strategy
    than using some of the aforementioned strategies and over-engineering.
  prefs: []
  type: TYPE_NORMAL
- en: We will be implementing a multi-step input form to capture user profile information
    in a single component. I will be covering my recommended technique to split forms
    up into multiple components later in the chapter in the *Reusable form parts and
    scalability* section.
  prefs: []
  type: TYPE_NORMAL
- en: Since the implementation of the form changes dramatically between this section
    and later in the chapter, you can find the code for the initial version on GitHub
    at `projects/ch11/src/app/user/profile/profile.initial.component.ts` and `projects/ch11/src/app/user/profile/profile.initial.component.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also make this multi-step form responsive for mobile devices using
    media queries:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding some helper data that will help us display an input
    form with options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add new validation rules to `common/validations.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, implement `profile.component.ts` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Upon load, we request the current user from `authService`, but this might take
    a while, so we first build an empty form with `this.buildForm()` as the first
    statement. We also store the user's ID in the `currentUserId` property, which
    we will need later when implementing the `save` functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we filter out users that are `null` or `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will implement a resolve guard to load a user based
    on their `userId` provided on a route to increase the reusability of this component.
  prefs: []
  type: TYPE_NORMAL
- en: Form controls and form groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may recall, `FormControl` objects are the most elemental parts of a form,
    usually representing a single input field. We can use `FormGroup` to group together
    a collection of related `FormControl` objects, such as the individual first, middle,
    and last parts of a person's name. `FormGroup` objects can also group together
    a mix of `FormControl`, `FormGroup`, and `FormArray` objects, the latter of which
    allows us to have dynamically repeating elements. `FormArray` is covered later
    in the chapter in the *Dynamic form arrays* section.
  prefs: []
  type: TYPE_NORMAL
- en: Our form has many input fields, so we will use a `FormGroup` created by `this.formBuilder.group`
    to house our various `FormControl` objects. Additionally, children `FormGroup`
    objects will allow us to maintain the correct shape of the data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Since the implementation of the form changes dramatically between this section
    and later in the chapter, you can find the code for the initial version on GitHub
    at `projects/ch11/src/app/user/profile/profile.initial.component.ts` and `projects/ch11/src/app/user/profile/profile.initial.component.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start building the `buildForm` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`buildForm` optionally accepts an `IUser` to prefill the form, otherwise, all
    fields are set to their default values. The `formGroup` property itself is the
    top-level `FormGroup`. Various `FormControls` are added to it, such as `email`,
    with validators attached to them as needed. Note how `name` and `address` are
    their own `FormGroup` objects. This parent-child relationship ensures the proper
    structure of the form data, when serialized to JSON, which fits the structure
    of `IUser` in a manner that the rest of our application and server-side code can
    utilize.'
  prefs: []
  type: TYPE_NORMAL
- en: You will be completing the implementation of the `formGroup` independently by
    following the sample code provided for the chapter. I will be going over sections
    of the code piece by piece over the next few sections to explain certain key capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Stepper and responsive layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular Material''s stepper ships with the `MatStepperModule`. The stepper
    allows for form inputs to be broken up into multiple steps so that the user is
    not overwhelmed with processing dozens of input fields all at once. The user can
    still track their place in the process and, as a side effect, as the developer,
    we break up our `<form>` implementation and enforce validation rules on a step-by-step
    basis or create optional workflows where certain steps can be skipped or required.
    As with all Material user controls, the stepper has been designed with a responsive
    UX in mind. In the next few sections, we will implement three steps covering different
    form-input techniques in the process:'
  prefs: []
  type: TYPE_NORMAL
- en: Account information
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input validation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Responsive layout with media queries
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculated properties
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: DatePicker
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Contact information
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Typeahead support
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic form arrays
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read-only views
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and clearing data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s prep the `UserModule` for some new Material modules:'
  prefs: []
  type: TYPE_NORMAL
- en: As we start adding sub-Material modules, it makes sense to rename our root `material.module.ts`
    file to `app-material.modules.ts` in line with how `app-routing.module.ts` is
    named. Going forward, I will be using the latter convention.
  prefs: []
  type: TYPE_NORMAL
- en: Rename the `src/app/material.modules.ts` file to `app-material.module.ts`, and
    then rename the `MaterialModule` class to `AppMaterialModule`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `user-material.module.ts` file containing the following Material modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ensure `user.module.ts` correctly imports the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new `user-material.module`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The baseline `app-material.module`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The required `ReactiveFormsModule` and `FlexLayoutModule`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implement a horizontal stepper with a form containing the first step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the implementation of the form changes dramatically between this section
    and later in the chapter, you can find the code for the initial version on GitHub
    at `projects/ch11/src/app/user/profile/profile.initial.component.ts` and `projects/ch11/src/app/user/profile/profile.initial.component.html`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, start implementing the `name` row of the `Account Information` step in
    place of the ellipses in the preceding step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Take care to understand how the stepper and the form configuration work so far.
    You should see the first row render, pulling in data from **lemon-mart-server**:![](img/B14094_11_01.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.1: Multi-step form – Step 1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that adding `fxLayout.lt-sm="column"` to a row with `fxLayout="row"` enables
    a responsive layout of the form, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_11_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Multi-step form on mobile'
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to how to implement the **Date of Birth** ﬁeld, let's reevaluate
    our strategy by implementing error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing repeating template behavior with directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we implemented a `mat-error` element for every validation
    error for every field part of the `name` object. This quickly adds up to seven
    elements for three fields. In *Chapter 8*, *Designing Authentication and Authorization*,
    we implemented `common/validations.ts` to reuse validation rules. We can reuse
    the behavior we implement within `mat-error`, or any other `div` for that matter,
    using an attribute directive.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute directives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In *Chapter 1*, *Introduction to Angular and Its Concepts*, I mentioned that
    Angular components represent the most basic unit of an Angular app. With components,
    we define our own HTML elements that can reuse features and functionality represented
    by a template and some TypeScript code. On the other hand, a directive augments
    the capabilities of an existing element or component. In a sense, a component
    is a super directive that augments basic HTML capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this view in mind, we can define three kinds of directives:'
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attribute directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basically, components are directives with templates, and this is the most common
    type of directive you will use. Structural directives modify the DOM by adding
    or removing elements, `*ngIf` and `*ngFor` being the canonical examples. Finally,
    attribute directives allow you to define new attributes that you can add to HTML
    elements or components to add new behavior to them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's implement an attribute directive that can encapsulate field-level error
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Field error attribute directive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imagine how we could use a directive to reduce repetitive elements to display
    field errors. Consider the following example using the first name field as an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the standard layout structure for a material form field, but there''s
    only a single `mat-error` element. There are three new properties on `mat-error`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`input` binds to the HTML input element that was tagged with `#name` using
    a template reference variable, so that we can tap into the blur event of the input
    element and be able to read the `placeholder`, `aria-label`, and `formControlName`
    properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`group` binds to the parent form group object that contains the form control,
    so using the `formControlName` property from input, we can retrieve the `formControl`
    object, while avoiding extra code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`appFieldError` binds to an array of validation errors that need to be checked
    against the `formControl` object, such as `required`, `minlength`, `maxlength`,
    and `invalid`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the preceding information, we can craft a directive that can render one
    or more lines of error messages inside the `mat-error` element, effectively replicating
    the verbose method we used in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and create an attribute directive named `FieldErrorDirective`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create `FieldErrorDirective` under `src/app/user-controls`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the directive''s selector as a bindable attribute named `appFieldError`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Outside of the directive, define a new type named `ValidationError`, which
    defines the kinds of error conditions we will deal with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similar to the way we grouped validations, let''s define two sets of commonly
    occurring error conditions, so we don''t have to type them out over and over again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s define the `@Input` targets for the directive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we already went over the purpose of the top three attributes. `fieldControl`
    and `fieldLabel` are optional attributes. If `input` and `group` are specified,
    the optional attributes can be auto-populated. Since they are class-wide variables,
    it made sense to expose them, in case the user wants to override the default behavior
    of the directive. This is an easy win for creating flexible and reusable controls.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import the element reference in the `constructor`, which can be later used
    by a `renderErrors` function display error in the inner HTML of the `mat-error`
    element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement a function that can return canned error messages depending on the
    error type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we can extract the required `minlength` or `maxlength` amount dynamically
    from the `fieldControl`, greatly reducing the number of custom messages we need
    to generate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the algorithm that can loop through all the elements in `appFieldError`
    and the errors that need to be displayed in an array using the `getStandardErrorMessage`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the end, we can display the error messages using the `renderErrors` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note the use of function delegates. Since this piece of code will execute hundreds
    of times a minute, it is important to avoid unnecessary invocations. Function
    delegates help organize our code better, while deferring the execution of their
    logic unless absolutely necessary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, initialize the `fieldControl` property, which represents a `formControl`.
    We will listen to the `valueChanges` events of the control and, if the validation
    status is invalid, then we execute our custom `updateErrorMessage` logic to display
    error messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that, since we're subscribing to `valueChanges`, we must also unsubscribe.
    We unsubscribe once with `ngOnDestroy` and again right before subscribing. This
    is because `initFieldControl` may be called multiple times. If we don't clear
    the prior subscription, it will result in a memory leak and related performance
    issues.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Additionally, if we can't bind to a `fieldControl`, we throw an error message,
    since this usually points to a coding error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we configure all major attributes with the `ngOnChanges` event, which
    triggers any time an `@Input` attribute is updated. This ensures that in the case
    where form elements could be dynamically added or removed, we will always consider
    the newest values. We call `initFieldControl` to start listening to value changes,
    we implement an `onblur` event handler that triggers `updateErrorMessage()` for
    the HTML input element, and we assign the value of `fieldLabel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that if we can't bind to an HTML `input` element, this usually means that
    the developer simply forgot to wire things up correctly. In this case, we throw
    a new `Error` object, which generates a helpful stack trace in the console, so
    you can pinpoint the location in the template where the error is happening.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This wraps up the implementation of the directive. Now, we need to package
    the directive in a module named `field-error.module.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now go ahead and use the directive in our existing forms:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the module in `app.module.ts` and `user.module.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `profile.component.html` with the new directive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `login.component.html` with the new directive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure to define `ErrorSets` as a public property variable in the `component`
    class so that you can use it in the template.
  prefs: []
  type: TYPE_NORMAL
- en: Test your forms to ensure that our validation messages are being displayed as
    expected and that there are no console errors.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You've learned how you can inject new behavior into other elements
    and components using directives. By doing this, we are able to avoid a lot of
    repeated code and standardize error messages across our app.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on, finish implementation of the form by looking at the implementation
    on GitHub. You can find the code for the form template at `projects/ch11/src/app/user/profile/profile.initial.component.html`
    and the `component` class at `projects/ch11/src/app/user/profile/profile.initial.component.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Do not include the `app-lemon-rater` and `app-view-user` elements, and remove
    the `mask` attribute from the phone number, which we will implement later in the
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see the User Profile as it will appear on LemonMart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_11_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: Profile component in a mostly completed state'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's continue going over the `profile` component and see how the **Date
    of Birth** ﬁeld works.
  prefs: []
  type: TYPE_NORMAL
- en: Calculated properties and DatePicker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can display calculated properties based on user input. For example, to display
    a person''s age based on their date of birth, introduce class properties that
    calculate the age and display it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To validate a date within the last hundred years, implement a `minDate` class
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage of the calculated properties in the template looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the highlighted `[min]` and `[max]` attributes in the preceding snippet
    for the application of the hundred-year date range.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DatePicker` in action looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_11_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: Selecting a date with DatePicker'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that dates beyond April 26, 2020 are grayed out. After the date is selected,
    the calculated age is displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_11_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: Calculated age property'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next step, **Contact Information**, and see how we
    can enable a convenient way to display and input the state portion of the address
    field.
  prefs: []
  type: TYPE_NORMAL
- en: Typeahead support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `buildForm`, we set a listener on `address.state` to support a typeahead
    filtering drop-down experience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'On the template, implement `mat-autocomplete`, bound to the filtered states
    array with an `async` pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how it looks when a user enters the `V` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_11_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.6: Dropdown with typeahead support'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let's enable the input of multiple phone numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic form arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Note that `phones` is an array, potentially allowing for many inputs. We can
    implement this by building a `FormArray` with the `this.formBuilder.array` function.
    We also define several helper functions to make it easier to build the `FormArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`buildPhoneFormControl` helps to build `FormGroup` objects of individual entries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buildPhoneArray` creates as many `FormGroup` objects as needed or, if the
    form is empty, it creates an empty entry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addPhone` adds a new empty `FromGroup` object to the `FormArray`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get phonesArray()` is a convenient property to get the `phones` control from
    the form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see how the implementation comes together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`buildPhoneArray` supports initialization of a form with a single phone input
    or filling it with the existing data, working in tandem with `buildPhoneFormControl`.
    The latter function comes in handy when a user clicks on an **Add** button to
    create a new row for the entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `phonesArray` property getter is a common pattern to make it easier to
    access certain form properties. However, in this case, it is also necessary because
    `get(''phones'')` must be typecast to `FormArray` so that we can access the `length`
    property on it on the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note the highlighted `convertTypeToPhoneType` function, which converts a `string`
    to `enum PhoneType`.
  prefs: []
  type: TYPE_NORMAL
- en: Also highlighted in the preceding code block, note how the `remove` function
    is implemented inline in the template, making it easier to read and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how the dynamic array should be working:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_11_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: Multiple inputs using FormArray'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we're done with inputting data, we can move on to the last step of
    the stepper, **Review**. However, as was mentioned earlier, the **Review** step
    uses the `<app-view-user>` directive to display its data. Let's build that view
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Creating shared components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here's a minimal implementation of the `<app-view-user>` directive that is a
    prerequisite for the **Review** step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `viewUser` component under the `user` module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The preceding component uses input binding with `@Input` to get user data, compliant
    with the `IUser` interface, from an outside component. We implement the `ngOnChanges`
    event, which fires whenever the bound data changes. In this event, we hydrate
    the simple JSON object stored in the `user` property as an instance of the `User`
    class with `User.Build`.
  prefs: []
  type: TYPE_NORMAL
- en: We then define a read-only `BehaviorSubject`, named `this.currentUser$`, so
    we can asynchronously push updates to it using the next function. This flexibility
    will come in handy when we later make this component reusable in multiple contexts.
    Even if we wanted to, we couldn't directly bind to `user`, because calculated
    properties such as `fullName` will only work if the data is hydrated into an instance
    of the `User` class.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to complete the multi-step form.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing and saving form data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On the last step of the multistep form, users should be able to review and
    then save the form data. As a good practice, a successful `POST` request will
    return the data that was saved back to the browser. We can then reload the form
    with the information received back from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note that `updateUser` returns the saved value of the user. It is possible that
    the database returns a different version of `user` than what we had before, so
    we use `formGroup.patchValue` to update the data powering the form. The form automatically
    updates to reflect any changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are errors when saving the data, they''ll be set to `userError` to
    be displayed on the form. And before saving the data, we present it in a compact
    format with the reusable `app-view-user` component that we can bind the form data
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use `formGroup.getRawValue()` to extract the JSON of the form data.
    See how we bind `userError` to display error messages. Also, the **Reset** button
    uses `stepper.reset()`, which can conveniently reset all the user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the final product should appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_11_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.8: Review step'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the user profile input is done, we are about halfway to our eventual
    goal of creating a master/detail view where a **Manager** can click on a user
    and view their profile details. We still have a lot more code to add, and along
    the way, we have fallen into a pattern of adding lots of boilerplate code to load
    the requisite data for a component.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's refactor our form to make our code reusable and scalable, so even
    if our form has dozens of fields, the code is still maintainable and we don't
    introduce an exponential cost increase to make changes.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling architecture with reusable form parts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the introduction to the *Multi-step responsive forms* section,
    forms are tightly coupled beasts that can grow large, and using the wrong architectural
    pattern to scale your implementation can cause significant issues when implementing
    new features or maintaining existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how you can break up your form into multiple parts, we will
    refactor the form to extract the highlighted section in the following screenshot,
    the name form group, as its own component. The technique to accomplish this is
    the same as you''d use when you want to put each step of your form into a separate
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_11_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.9: User profile''s name part highlighted'
  prefs: []
  type: TYPE_NORMAL
- en: By making the name form group reusable, you will also learn about how you can
    reuse the business logic that you build into that form group in other forms. We
    will extract the name form group logic into a new component named `NameInputComponent`.
    In doing so, we also have an opportunity to extract some reusable form functionality
    to a `BaseFormComponent` as an `abstract class`.
  prefs: []
  type: TYPE_NORMAL
- en: There are going to be several components that are working together here, including
    `ProfileComponent`, `ViewUserComponent`, and `NameInputComponent`. We need all
    the values in these three components to be up to date as the user enters them.
  prefs: []
  type: TYPE_NORMAL
- en: '`ProfileComponent` will own the master form to which we''ll need to register
    any child form. Once we do this, all the form validation techniques you''ve learned
    so far will still apply.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a key way to make your form able to scale across many components and
    continue to be easy to work with, without introducing unnecessary validation overhead.
    Hence, it is useful to review the different interactions between these objects
    to solidify your understanding of the asynchronous and decoupled nature of their
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_11_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.10: Form component interactions'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we bring together a lot of the different concepts that you've
    learned over the course of the book. Utilize the preceding diagram to understand
    how the various form components interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, properties in bold indicate data binding. Underlined
    function elements indicate event registrations. Arrows show the points of connection
    between the components.
  prefs: []
  type: TYPE_NORMAL
- en: The workflow begins with the instantiation of `ProfileComponent`. The `OnInit`
    event of the component begins building the `formGroup` object, while asynchronously
    loading any potential `initialData` that may need to be patched into the forms.
    Refer to the preceding diagram for a visual representation of `initialData` coming
    in from a service or cache.
  prefs: []
  type: TYPE_NORMAL
- en: '`NameInputComponent` is used in the `ProfileComponent` form as `<app-name-input>`.
    In order to synchronize `initialData` with the `NameInputComponent`, we bind a
    `nameInitialData$` subject using the `async` pipe, since `initialData` is coming
    in asynchronously.'
  prefs: []
  type: TYPE_NORMAL
- en: '`NameInputComponent` implements the `OnChanges` life cycle hook, so whenever
    `nameInitialData$` updates, its value is patched into the `NameInputComponent`
    form.'
  prefs: []
  type: TYPE_NORMAL
- en: Like `ProfileComponent`, `NameInputComponent` also implements the `OnInit` event
    to construct its `formGroup` object. Since this is an asynchronous event, `NameInputComponent`
    needs to expose a `formReady` event that `ProfileComponent` can subscribe to.
    Once the `formGroup` object is ready, we emit the event, and the `registerForm`
    function on `ProfileComponent` triggers. `registerForm` adds the `formGroup` object
    of `NameInputComponent` as a child element to the parent `formGroup` on `ProfileComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewUserComponent` is used in the `ProfileComponent` form as `<app-view-user>`.
    When the values in the parent form change, we need `<app-view-user>` to stay up
    to date. We bind to the `user` property on `ViewUserComponent`, which implements
    `OnChanges` to receive updates. Every time there is an update, the `User` object
    is hydrated from the `IUser` object, so that calculated fields such as `fullName`
    can continue to work. The updated `User` is pushed to `currentUser$`, which is
    bound to the template with an `async`.'
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by building a `BaseFormComponent`, which `NameInputComponent`
    and `ProfileComponent` will then implement.
  prefs: []
  type: TYPE_NORMAL
- en: Base form component as an abstract class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can share common functionality and standardize the implementation of all
    components that implement a form by implementing a base abstract class. An abstract
    class cannot be instantiated on its own because it wouldn't make sense to do so,
    since it will not have a template, making it useless on its own.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `BaseFormComponent` is just a `class` and not an Angular component.
  prefs: []
  type: TYPE_NORMAL
- en: '`BaseFormComponent` will standardize the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Input initialData`, and disable as binding targets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Output formReady` event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`formGroup`, the `FormGroup` to be used in the template''s `buildForm` function
    to build the `formGroup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the preceding assumptions, the base class can provide some generic functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '`patchUpdatedData`, which can update the data (partially or fully) in the `formGroup`
    without having to rebuild it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`registerForm` and `deregisterForm` can register or deregister child forms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deregisterAllForms` can automatically deregister any registered child form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasChanged` can determine whether `initialData` has changed given a `SimpleChange`
    object provided by the `ngOnChange` event handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`patchUpdatedDataIfChanged` leverages `hasChanged` and uses `patchUpdatedData`
    to update the data if, and only if, there has been an update to `initialData`
    and `formGroup` is already initialized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a new class, `BaseFormComponent`, under `src/common` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Let's implement `NameInputComponent` using the `BaseFormComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a reusable form part
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start by identifying the name form group in the `profile` component code and
    template files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the name form group implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that when we move these validation rules to a new component, we still want
    them to be in effect when determining the overall validation status of the parent
    form. We achieve this by using the `registerForm` function we implemented in the
    previous section. Once our new `FormGroup` is registered with the existing one,
    they work exactly the same way before our refactor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next is the name form group template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will be moving most of this code to the new component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new `NameInputComponent` under the `user` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend the class from `BaseFormComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inject `FormBuilder` in the `constructor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For components with small or limited pieces of functionality, I prefer creating
    them with an inline template and styling, so it is easier to change the code from
    one place.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember that the base class already implements `formGroup`, `initialData`,
    `disable`, and `formReady` properties, so you don't need to redefine them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that we are forced to implement the `buildForm` function since it was defined
    as abstract. This is a great way to enforce standards across developers. Also,
    note that any base function provided can be overridden by the implementing class
    by simply redefining the function. You'll see this in action when we refactor
    the `ProfileComponent`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Implement the `buildForm` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `name` property part of the `formGroup` in `ProfileComponent` to `null`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the template by bringing over the content from `ProfileComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `ngOnInit` event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is critical to get the implementation of the `ngOnInit` event handler right
    in every implementation of `BaseFormComponent`. The preceding example is fairly
    standard behavior for any `child` component you may implement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the implementation in `ProfileComponent` will be a bit different.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the `ngOnChanges` event handler, leveraging the base `patchUpdatedDataIfChanged`
    behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that in `patchUpdatedDataIfChanged`, setting `onlySelf` to `false` will
    cause the parent form to also update. If you'd like to optimize this behavior,
    you may override the function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now you have a fully implemented `NameInputComponent` that you can integrate
    into `ProfileComponent`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To verify your `ProfileComponent` code going forward, refer to `projects/ch11/src/app/user/profile/profile.component.ts`
    and `projects/ch11/src/app/user/profile/profile.component.html`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before you begin using `NameInputComponent`, perform the following refactors:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Refactor `ProfileComponent` to extend `BaseFormComponent` and conform to its
    default values as needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a readonly `nameInitialData$` property with the `BehaviorSubject<IName>`
    type and initialize it with empty strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the content in `ProfileComponent` with the new `<app-name-input>` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the base form component function, `registerForm`, is leveraged here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Ensure that your `ngOnInit` is implemented correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that there are some additional refactors present on the updated `ProfileComponent`,
    such as the `patchUser` function seen in the following snippet. Don't miss these
    updates when you update your component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is important to update the current form's data with `pathUpdatedData`, as
    well as `nameInitialData$`, when there's an update to `initialData`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Ensure that `ngOnDestroy` is implemented correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Always remember to unsubscribe from subscriptions, which you can do so easily
    with the `SubSink` package. You can also leverage the base class functionality
    to automatically deregister from all child forms.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's learn about masking user input to increase the quality of our data.
  prefs: []
  type: TYPE_NORMAL
- en: Input masking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Masking user input is an input UX tool, as well as a data quality one. I''m
    a fan of the **ngx-mask** library, which makes it really easy to implement input
    masking in Angular. We will demonstrate input masking by updating the phone number
    input field so we can ensure that users input a valid phone number, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_11_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.11: Phone number field with input masking'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up your input masking as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the library via npm with `npm i ngx-mask`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `forRoot` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the module in the `user` feature module as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `number` field in `ProfileComponent` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And it's that simple. You can learn more about the module and its capabilities
    on GitHub at [https://github.com/JsDaddy/ngx-mask](https://github.com/JsDaddy/ngx-mask).
  prefs: []
  type: TYPE_NORMAL
- en: Custom controls with ControlValueAccessor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've learned about forms using standard form controls and input controls
    provided by Angular Material. However, it is possible for you to create custom
    user controls. If you implement the `ControlValueAccessor` interface, then your
    custom controls will play nicely with forms and the `ControlValueAccessor` interface's
    validation engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be creating the custom rater control shown in the following screenshot,
    and will place it as a control on the first step of `ProfileComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_11_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.12: The lemon rater user control'
  prefs: []
  type: TYPE_NORMAL
- en: User controls are inherently highly reusable, tightly coupled, and customized
    components to enable rich user interactions. Let's implement one.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a custom rating control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The lemon rater will highlight the number of lemons selected dynamically as
    the user interacts with the control in real time. As such, creating a high-quality
    custom control is an expensive endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: The Lemon Rater is a modified version of Jennifer Wadella's Galaxy Rating App
    sample found at [https://github.com/tehfedaykin/galaxy-rating-app](https://github.com/tehfedaykin/galaxy-rating-app).
    I highly recommend that you watch Jennifer's Ng-Conf 2019 talk on `ControlValueAccessor`,
    linked in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up your custom rating control as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate a new component called `LemonRater` under the `user-controls` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `LemonRaterModule` in the same folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare and export the component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `LemonRater`, implement the `ControlValueAccess` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `NG_VALUE_ACCESSOR` provider with the `multi` property set to `true`.
    This will register our component with the form''s change events, so form values
    can be updated when the user interacts with the rater:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement a custom rating scheme with a function to allow for setting the selected
    rating based on user input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that by using `@ViewChild`, we're getting the HTML element named `#displayText`
    (highlighted in the following template). Using `setSelectText`, we replace the
    `textContent` of the element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the template, referring to the sample code for the contents of the
    `svg` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The three most important attributes in the template are `mouseover`, `mouseout`,
    and `click`. `mouseover` displays the text for the rating that the user is currently
    hovering over, `mouseout` resets the display text to the selected value, and `click`
    calls the `setRating` method we implemented to record the user's selection. However,
    the control can have even richer user interactivity by highlighting the number
    of lemons when the user hovers over a rating or selects it. We will accomplish
    this via some CSS magic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the `css` for the user control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The most interesting bit is with `.lemons .lemon:hover~.lemon #fill-area`.
    Note that the operator `~` or the general sibling combinator is used to select
    a range of elements so that a dynamic number of lemons will be highlighted as
    the user hovers over them.'
  prefs: []
  type: TYPE_NORMAL
- en: '`#fill-area` refers to a `<path>` defined within the lemon `svg`, which allows
    for the lemon''s color to be adjusted dynamically. I had to manually inject this
    ID field into the `svg` file.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how you can use this new user control in a form.
  prefs: []
  type: TYPE_NORMAL
- en: Using custom controls in forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the lemon rater in the `profile` component to record the Limoncu
    level of the employee.
  prefs: []
  type: TYPE_NORMAL
- en: Limoncu, meaning a person who grows or sells lemons in Turkish, is Lemon Mart's
    proprietary employee engagement and performance measurement system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s integrate the lemon rater:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by importing the `LemonRaterModule` in `UserModule`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that the level form control is initialized in `buildForm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Insert the lemon rater as the last element of the first `mat-step`, inside
    the `form` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We simply integrate with the custom control by implementing `formControlName`
    as you would with any other control.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You should have a working custom control that is integrated
    with your form.
  prefs: []
  type: TYPE_NORMAL
- en: Layouts using grid list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Angular Flex Layout library is great for laying out content using CSS Flexbox.
    Angular Material provides another mechanism to lay out content by using CSS Grid
    with its Grid List functionality. A good way to demonstrate this functionality
    is by implementing a helpful list for fake login information in the `LoginComponent`,
    demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_11_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.13: Login helper with the grid list'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement your list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by defining a `roles` property that is an array of all the roles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import `MatExpansionModule` and `MatGridListModule` into `AppMaterialModule`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement a new `mat-card-content` below the existing one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the new `mat-card-content`, put in a label to display the authentication
    mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Beneath the label, implement an expansion list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After `mat-expansion-panel-header`, in the area marked with ellipses in the
    preceding step, implement a table of roles and email addresses, along with some
    hint text regarding password length using `mat-grid-list`, shown in the following
    code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use `colspan` to control the width of each row and cell. We leverage `fxLayoutAlign`
    to right-align the contents of the **E-mail** column. We use `*ngIf; else` to
    selectively display content. Finally, a **Fill** button helps us to populate the
    login form with fake login information.
  prefs: []
  type: TYPE_NORMAL
- en: In your application, you can use an expansion panel to communicate password
    complexity requirements to your users.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about expansion panels at [https://material.angular.io/components/expansion](https://material.angular.io/components/expansion)
    and Grid List at [https://material.angular.io/components/grid-list/overview](https://material.angular.io/components/grid-list/overview).
  prefs: []
  type: TYPE_NORMAL
- en: Restoring cached data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the beginning of the chapter, when implementing the `updateUser` method
    in `UserService`, we cached the `user` object in case of any errors that may wipe
    out user-provided data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Consider a scenario where the user may be temporarily offline when they attempt
    to save their data. In this case, our `updateUser` function will save the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can restore this data in `ProfileComponent` when loading
    the user profile:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding functions named `loadFromCache` and `clearCache` to the `ProfileComponent`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After loading the data, we parse the data into a JSON object, using `JSON.parse`,
    and then hydrate the `User` object with `User.Build`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the template to call the `clearCache` function, so when the user resets
    the form, we also clear the cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `ngOnInit` to conditionally load data from cache or the latest `currentUser$`
    from `authService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We leverage the `combineLatest` operator to combine the outputs of `loadFromCache`
    and `currentUser$`. We check to see that one of the streams is returning a non-null
    value. If a cached user exists, it takes precedence over the value received from
    `currentUser$`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test your cache by setting the network status of your browser to be
    offline, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_11_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.14: Offline network status'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the network status of your browser to offline as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In Chrome DevTools, navigate to the **Network** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Offline** in the dropdown marked as **2** in the preceding screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a change to your form, such as the name, and hit **Update**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll see an error reading **An unknown error has occurred** displayed at the bottom
    of the form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Network** tab, you'll see that your PUT request has failed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, refresh your browser window and observe that the new name you entered is
    still present.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refer to the following screenshot, which shows the toast notification you get
    after loading data from the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14094_11_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.15: Data loaded from cache'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a great UX around caching is incredibly challenging. I provided
    a rudimentary method to show what is possible. However, there are many edge cases
    that can impact how caching in your application works.
  prefs: []
  type: TYPE_NORMAL
- en: In my case, the cache stubbornly sticks around until we successfully save the
    data to the server. This may be frustrating for some users.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You've successfully implemented a sophisticated form to capture
    data from your users!
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Further enhance the `login` component to add a login helper for `AuthMode.CustomServer`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered forms, directives, and user control-related functionality
    for LemonMart. We created reusable components that can be embedded within another
    component using data binding. We showed that you can use PUT to send data to the
    server and cache data input by the user. We also created a multistep input form
    that is responsive to changing screen sizes. We removed the boilerplate code from
    our components by leveraging reusable form parts, a base form class to house common
    functionality, and an attribute directive to encapsulate field-level error behavior
    and messages.
  prefs: []
  type: TYPE_NORMAL
- en: We created dynamic form elements with a date picker, typeahead support, and
    form arrays. We implemented interactive controls with input masking and the lemon
    rater. Using the `ControlValueAccessor` interface, we integrated the lemon rater
    seamlessly with our form. We showed that we can scale the size and complexity
    of our forms linearly by extracting the name as its own form section. Additionally,
    we covered building layouts using grid list.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will further enhance our components so that we can orchestrate
    them using the router. We will also implement a master/detail view and a data
    table, and explore NgRx as an alternative to using RxJS/BehaviorSubject.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Reactive forms*, 2020, available at [https://angular.io/guide/reactive-forms](https://angular.io/guide/reactive-forms
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Attribute directives*, 2020, available at [https://angular.io/guide/attribute-directives](https://angular.io/guide/attribute-directives
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*rxweb: Good way to show the error messages in Angular Reactive Forms*, Ajay
    Ojha, 2019, available at [https://medium.com/@oojhaajay/rxweb-good-way-to-show-the-error-messages-in-angular-reactive-forms-c27429f51278](https://medium.com/@oojhaajay/rxweb-good-way-to-show-the-error-messages-in-angular-reactive-forms-c2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Control Value Accessor*, Jennifer Wadella, 2019, available at [https://www.youtube.com/watch?v=kVbLSN0AW-Y](https://www.youtube.com/watch?v=kVbLSN0AW-Y)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CSS Combinators*, 2020, available at [https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors#Combinators](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors#Combinators
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Answer the following questions as best as you can to ensure that you've understood
    the key concepts from this chapter without Googling. Do you need help answering
    the questions? See *Appendix D*, *Self-Assessment Answers* online at [https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf)
    or visit [https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment).
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between a component and a user control?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an attribute directive?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `ControlValueAccessor` interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are serialization, deserialization, and hydration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does it mean to patch values on a form?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you associate two independent `FormGroup` objects with each other?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
