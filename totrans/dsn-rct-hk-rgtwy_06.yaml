- en: '*Chapter 6*: Use Memo to Boost Performance'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we learned how the `useEffect` hook is designed and
    how to use it to manage a side effect in *React*. In this chapter, we will change
    to an optimization topic for reusing the last assignment. We will first introduce
    how we can run into performance degradation in a typical web application. Then,
    we will walk through the design and source code behind `useMemo` and describe
    various ways of reusing a value conditionally. We''ll then apply the optimization
    technique to two common cases: clicking to search and debouncing the search. At
    the end, the chapter also includes two bonus topics in the *Appendix* section,
    *Not a Classical Memorization* and *Skipping a Child Update*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following main topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance degradation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the `useMemo` design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusing a last assignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-Driving `useMemo`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useMemo` examples'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions and answers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Appendix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance degradation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we build a site, we normally start it with a draft or prototype version
    where a couple of pages are laid out with the sample data and the preliminary
    logic. The idea is to start small and see whether the site has any potential to
    grow. Though this is a very common approach, interestingly, most of the performance-related
    issues do not show up at this point. When the site with the real business logic
    grows, we start to experience performance degradation issues. Understanding how
    these issues are created in the first place is valuable since it helps us plan
    for the growth of the site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build such a case from scratch. A variable defined inside the body of
    a function component is evaluated when it gets invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `a` variable is assigned with a `1` constant. Storing
    a number like this shouldn't cost us much when `a` is reassigned every time when
    the `text` prop changes. But what if we need to calculate something heavy, such
    as matching a text in a large array?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Say the preceding `matchTextInArray` function takes an average of 200 *milliseconds*
    to complete, which is a bit costly. We can argue that the `found` variable only
    gets assigned when `text` changes, so if `text` doesn't get changed often, we
    don't have to worry about `found` getting assigned too often. Let's ponder over
    this a bit.
  prefs: []
  type: TYPE_NORMAL
- en: A function component can be invoked for various reasons. In *React*, the update
    of a function component is mostly triggered by a state change. However, the state
    could be from inside the `Title` component or from the parent (or grandparent)
    of the `Title` component. Therefore, we can't just assume the update frequency
    of a component by looking at it.
  prefs: []
  type: TYPE_NORMAL
- en: Just imagine if the user decides to refresh the page; it should cause all the
    components of this page to update. In a way, the component can only determine
    what gets updated but can't entirely decide when it gets updated. In other words,
    when it comes to the update, the component also depends on its parent's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `Title` component gets another `flag` prop. Thus,
    whenever the `flag` prop flips, it renders and spends 200 milliseconds on calculating
    `a`. You can imagine the flag as a user voting button from a parent component.
  prefs: []
  type: TYPE_NORMAL
- en: If the user keeps clicking the button, multiple 200 milliseconds can quickly
    stack up to become a second or two, and the performance of the app is essentially
    now tied directly to how quickly the user flips the flag. When this happens, to
    use a gaming term here, it causes a lag, or a frame drop. The user should start
    to feel a laggy response and lose confidence in using the site.
  prefs: []
  type: TYPE_NORMAL
- en: When this happens in a game, what do we do? Well, that's the time the gamer
    needs to upgrade their gaming hardware. But it could also be a time for developers
    to exploit an opportunity for optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing a previous assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, what do we do in the situation of performance degradation? Let''s take
    a look at what we have following the current timeline. When either the `flag`
    or the `text` prop changes, the `found` variable gets a new assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So, in our case, there's something we want to acknowledge, that is, the `matchTextInArray`
    does not even depend on the `flag` because the function doesn't take input arguments
    other than `text`.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we want to perform a new assignment when the previous assignment could
    still be valid? Can't we skip assignments when the `flag` prop changes?
  prefs: []
  type: TYPE_NORMAL
- en: 'We learned in [*Chapter 5*](B17963_05_Epub.xhtml#_idTextAnchor157), *Use Effect
    to Handle Side Effects,* that an effect can be used to listen to a value change.
    In our case, can we listen to the `text` prop change to make an assignment while
    ignoring other values? Let''s give it a shot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we use the dependency array from `useEffect` to act
    upon the `text` change and dispatch to update the `found` state after `matchTextInArray`.
    This is confirmed by the following timeline sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The solution works out of the box. The flag flips back and forth lots of times
    (six times), but we only have three new assignments due to the text change. Thus,
    the assignment isn't tied to the flip. This is wonderful because we manage to
    overcome potential performance degradation.
  prefs: []
  type: TYPE_NORMAL
- en: Though the solution works, we would like to improve upon it because it uses
    a side effect to handle the assignment, and we can see this assignment doesn't
    have to be a side effect. Since a side effect gets collected later after the update,
    it must wait till the next update. This means the assignment behaves very differently
    from a direct assignment, such as `a = 1`. Last but not least, a `found` state
    is used to hold the assignment value, and the value does not have to be a state.
    It's better if we can address all these issues.
  prefs: []
  type: TYPE_NORMAL
- en: '*React* adds a `useMemo` hook to do exactly that without other hurdles. The
    job of the hook is to allow us to reuse the previous assignment in an update.
    Let''s take a look at the `useMemo` design first.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the useMemo design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React provides a `useMemo` hook to support a value assignment through a function
    that can either return a new value or an old value from the previous update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `useMemo` function takes a `create` function as its first input argument.
    This function returns a new value if invoked. The second parameter is a `deps`
    dependency array, similar to `deps` in `useEffect`. In the preceding case, `"Hello
    World"` is assigned to a `label` variable only once after the mount.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s no additional data structure required for `useMemo` other than the
    basic hook support, as shown in *Figure 6.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Data structure for useMemo'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.1_B17963.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Data structure for useMemo
  prefs: []
  type: TYPE_NORMAL
- en: The hook's state persists between updates, and it's up to each hook function
    to define what (or in which format) it wants to persist. For instance, a `useState`
    hook stores a state array, a `useEffect` hook stores an effect object, and now
    a `useMemo` hook stores things related to an assignment. In fact, `useMemo` takes
    the form of the assigned value and the dependency array as `[value, deps]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code of `useMemo` is structured with `mountMemo` and `updateMemo`
    in a typical hook setup, depending on whether the fiber is under mount or the
    update via the `isFiberMounting` flag, as explained in [*Chapter 3*](B17963_03_Epub.xhtml#_idTextAnchor080),
    *Hooking into React*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `useMemo` hook accepts the `create` assignment function and the `deps` dependency
    array as inputs. The `name`, `create`, indicates that it creates a new value when
    it gets invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'When under the mount, it first gets the hook object by creating one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If `deps` is not given at all, it's converted to `null` by default, and the
    initial value is stored by invoking the `create` assignment function. Before returning
    the value, both the initial value and its dependency are stored in the `state`
    property under the hook using an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'When under the update, it gets the hook by cloning one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the hook, it gets `prevState` from the hook's `state`, which is
    an array of the previous value and the previous dependency array.
  prefs: []
  type: TYPE_NORMAL
- en: 'It checks whether the dependency has changed with `areDepsEqual`. If there''s
    no change, it simply returns the previous value. And if there is a change, it
    invokes the `create` assignment function again to update into the new `value`.
    Before we return the value, both the value and the dependency are stored in the
    hook''s `state`. Here is the summarized `useMemo` workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – useMemo workflow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.2_B17963.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – useMemo workflow
  prefs: []
  type: TYPE_NORMAL
- en: Compared to `useState` and `useEffect`, `useMemo` is quite straightforward.
    It doesn't have any dispatch or effect involved. Instead, you can think of it
    as a special assignment statement. When the `deps` dependency is met, it then
    creates a value and returns it as the current value. In all cases, the current
    value is returned. So, to be precise, *an assignment is made in all cases; when
    the condition isn't met, an old value is reused*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how `useMemo` is designed, let's walk you through all the scenarios
    that this special assignment can do.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing a last assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reusing a value and memorizing a value sometimes refer to similar behavior.
    However, it's worth noting that the `useMemo` hook can only remember one value
    from the past, the last value.
  prefs: []
  type: TYPE_NORMAL
- en: A single *JavaScript* variable, by default, serves a purpose that, unless overwritten
    by a new assignment, holds the previously assigned value. So, take caution when
    reading the word "memo" here. If you take the word "memo" as a single value instead
    of memorizing all values, it could help you visualize it the right way as *React*
    designed it. If you are interested in classical memorization, check out the *Appendix
    A – Not a classical memorization* section at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How `useMemo` reuses the previous assignment is controlled by a `deps` dependency
    array, and it uses the `areDepsEqual` utility function to compare two dependency
    arrays between the previous and current update. We have already examined this
    function in [*Chapter 5*](B17963_05_Epub.xhtml#_idTextAnchor157), *Use Effect
    to Handle Side Effects*. We will skip the source code here and jump straight to
    the scenarios that correspond to each dependency array configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we get three cases here, no dependency, empty dependency, and some
    dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`useMemo` without a dependency provided is not common, but it''s easy to see
    how a `useMemo` hook statement and a direct assignment can replace each other
    very quickly, as they share the assignment statement in `...`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deps` array is provided but with no element inside, it means the value doesn''t
    depend on anything. Therefore, the value is created only once after the mount:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you want to hold a static value for all updates, this is a good use of it.
    You might wonder why we can't take a static value declaration outside of the component.
    It's because the assignment can still use the variables inside the component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`useMemo`. When the elements of `deps` are not empty, it compares each element
    between the previous and next dependencies to determine the change:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If any of the elements change, the value gets assigned again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's one thing to make a note of – in all of the cases mentioned, the assignment
    is performed for all updates. Though sometimes the assignment seems to be skipped,
    what we really mean here is that the assignment is reused from the last time when
    the conditions met.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment value type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The type of value that returns from the assignment can be in any format – a
    string, a number, an object, or even a function. That makes `useMemo` a bit flexible
    to meet all cases that require reusing values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding usage of `useMemo` adds a `3` number to `b` and assigns the result
    to `a` when `b` changes. Similarly, we can construct a usage for using an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding usage, an object with a `name` property is assigned to `obj`
    when `name` changes. We can even construct a usage for a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we constructed an assignment to create a function instance
    after being mounted. To make things a bit easier to understand, we can take `useMemo`
    out to see what the raw assignment is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There's some subtlety when it comes to the usage of `useMemo` applying to a
    non-primitive value, such as an object, an array, or a function. When creating
    any of these values, you get a new value pointing to a new memory space. This
    means that when the dependency conditions are not met, old memory space is used
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, the `useMemo` hook can be used as a special assignment to return
    any type of value.
  prefs: []
  type: TYPE_NORMAL
- en: The myth of skipping an update
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We may all be thinking from the use of the word "memo" that, maybe, `useMemo`
    can help us skip an update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, since the `a` variable doesn't get a new value after
    the mount, maybe the `Child` component doesn't get any new updates either. Unfortunately,
    this is not the case.
  prefs: []
  type: TYPE_NORMAL
- en: The answer to this question harks back to what makes an update in *React*. We
    mentioned at the beginning of this chapter that a state change from the `Title`
    component or its parent can make a new update, but the `a` variable is not a state
    and no one makes a dispatch for updating this value either.
  prefs: []
  type: TYPE_NORMAL
- en: In a way, the `useMemo` hook has no direct relationship with an update. It doesn't
    carry any functionalities in terms of hooking into the update as either `useState`
    or `useEffect` does. In fact, `useMemo` doesn't do anything more than an assignment,
    except the assignment is conditional.
  prefs: []
  type: TYPE_NORMAL
- en: Skipping an update based on the prop change can be done with a `memo` function
    provided by `React`. And `memo` and `useMemo` are two different things; we do
    not discuss `memo` in this book. If you really want to skip an update with the
    `useMemo` hook, we provide a special usage in the *Appendix B – Skipping a child
    update* section at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what `useMemo` is and what it can and cannot do, let's give
    it a test drive.
  prefs: []
  type: TYPE_NORMAL
- en: Test-Driving useMemo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s improve the example that we saw at the beginning of the chapter with
    the `useMemo` hook to gain some performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code replaces `useState` and `useEffect` with `useMemo`. Let''s
    take a look at the timeline to see what difference it makes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: A new value is created in the `"created"` series when the `text` changes, independent
    of the `flag` flips. Even better this time, there's no delay between assigning
    the `found` value and receiving the `text` change because it's a direct assignment
    under the same update now.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that with or without `useMemo`, there's no big code structure
    change introduced to address the performance issue. In fact, to switch back to
    the non-optimized version, we can either omit the dependency or simply remove
    the `useMemo` usage with only one or two lines.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, we have now seen how the `useMemo` hook is used. Next, let's take a look
    at two examples of how we can apply it to some real performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: useMemo examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `useMemo` hook tends to be a hook that we use when we want to optimize the
    site for either resolving site performance and/or improving user experience. Thus,
    it normally tends to be used to address problems. In the following sections, we
    will go through two examples relating to a search to demonstrate the application
    of `useMemo` as an optimization tool.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking to search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Say you have a list of fruits and you'd like to search it to find the matched
    fruit using an input box and a button. For example, typing `"bl"` should return
    us blackberries and blueberries from a list of fruits.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Clicking on the search UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.3_B17963.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – Clicking on the search UI
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a list of fruits defined in a `fruits` global variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a `text` state to store the string that the user types in at the moment.
    When the user clicks the `text` is sent to a `query` state as the current search
    query string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `fruits` list is filtered against the `query` string to find our `matched`
    fruits. The preceding code works out of the box. But, after we send this piece
    to production, we get some feedback that the *UI* chokes a bit and can become
    quite laggy when a user types on the keyboard quickly or corrects their typos
    frequently.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we dug into the issue, we found out that the problem is caused by the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can take a look at the timelines to help us visualize the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Every keystroke the user types translates into an update where the `matched`
    value is created. This is the exact same problem we talked about in our introduction,
    except that `text` and `query` are both states instead of props. The nature of
    the problem is the same though.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the solution here is to see whether we can limit the `matched` values to
    be created only upon the `query` change. This way, when the user types, we do
    not need to constantly make new `matched` values. Let''s try this idea with `useMemo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we added `query` to the `deps` change dependency array. If other
    things changed – for example, the user type – it shouldn''t touch the `matched`
    values. Let''s confirm it with the following timeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, we get a lower amount of new `matched` values, and the performance isn't
    tied to how the user types the keystroke anymore. This is great as we can all
    type quickly these days.
  prefs: []
  type: TYPE_NORMAL
- en: Playground – Click to Search
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/OJjmjBv](https://codepen.io/windmaomao/pen/OJjmjBv).
  prefs: []
  type: TYPE_NORMAL
- en: Click and search is one of the classic examples of user experience, and it serves
    as a solid pattern when it comes to performing a search on the web. While this
    approach is still being used, these days, users expect more from a responsive
    website, so there exists a more popular approach of improving the user experience
    with this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Debouncing the search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We all have used *Google* to search for something at some point. When we type
    in the search bar, a dropdown slides down to provide the closest matches following
    the user input. It''s a very smooth user experience, as *Google* has trained all
    of us to get used to it for decades, as shown in *Figure 6.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Debouncing the search UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.4_B17963.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Debouncing the search UI
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s no search button the user can click anymore; all the user needs to
    do is to keep typing. And when the user stops typing, the matched list is revealed.
    So, how do we implement this? Let''s first remove the **Search** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Although we don't have the button to click, the nature of this click-to-search
    doesn't change. Somehow, we still need a moment of this "click" when the user
    is about to finish typing and expect a search to happen. So, the idea here is
    to find the right "click" moment.
  prefs: []
  type: TYPE_NORMAL
- en: How exactly can we know such timing, when something is about to happen but has
    not happened yet? Actually, there's a perfect analogy for this problem. Ever wondered
    how an elevator waits for all people to get inside before it closes its door?
    How does the door know when is the right time to close it? How does it anticipate
    whether no one else is going to get squeezed in at the next second?
  prefs: []
  type: TYPE_NORMAL
- en: Given an `fn` function, if a request to invoke it arrives, it doesn't do it
    right away. Instead, it waits for a certain amount of time. During that period,
    if no request comes in to invoke it anymore, it then invokes at the end of the
    period. This behavior is called **Debouncing**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debouncing was introduced for mechanical switches and relays – coincidence?
    To resolve hitting the key too frequently, the processor in a keyboard defers
    the hitting by "combining" them across time into a single hit. Quite a few libraries
    implement the `debounce` function; instead of reinventing the wheel, this book
    borrows one from a library called *Lodash*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `debounce` function takes the original `fn` function and a `dt` duration
    to wait before invoking `fn`; it returns a new `debouncedFn` function with the
    debouncing behavior. Instead of invoking `fn`, we invoke `debouncedFn` now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s apply it to find the right moment of "click":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding change, upon each user typing, a debounced `setDebouncedQuery`
    version gets invoked. But not all typing updates the query via `setQuery`; instead,
    it waits 300 *milliseconds* to make sure the user happens to stop the typing,
    and that moment is our moment of "click." Multiple user keystrokes are combined
    into a single `setQuery`. As we have set up, after each `query` change, the `useMemo`
    hook creates a new search.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s only one small issue left to get everything working; the `setDebouncedQuery`
    function is created as a new instance upon each user keystroke, which is not what
    we wanted. Instead, we want to have one instance of `setDebouncedQuery` so that
    all the keystrokes can be debounced to the same `setQuery` function. How do we
    reuse the last function instance? Yes – with the `useMemo` hook we just learned
    about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we improved `setDebouncedQuery` with the usage of the
    `useMemo` hook, and inside we inserted `debounce` for `setQuery`. Now, let''s
    confirm with the following timeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! For two groups of user sessions, it performs two searches. Comparing
    this timeline with the previous timeline as in the classical clicking to search,
    you can see they are quite similar. The physical button click is replaced with
    an imaginary "click," and we get a nicer user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Playground – Debouncing the Search
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/xxLdPga](https://codepen.io/windmaomao/pen/xxLdPga).
  prefs: []
  type: TYPE_NORMAL
- en: With these two examples, we should now know how `useMemo` can be applied effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first learned about a new hook, `useMemo`. We first briefly
    went over what can cause performance degradation in general, and then we learned
    about the `useMemo` design and read line by line how an optimization scheme is
    constructed to reuse the last value without creating a new one every time. Then,
    we went through all scenarios of reusing a value based on a dependency array.
    We took `useMemo` for a spin, and at the end, we saw how it's applied to two classic
    examples, clicking to search and debouncing the search.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will get into another hook in the *React* family where
    a state change can be dispatched to multiple locations for an are update.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some questions and answers to refresh your knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: What is `useMemo`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `useMemo` hook is an assignment statement where a new value is created when
    one of the dependencies changes. It can be used to minimize the creation of a
    value, so it behaves like that sometimes when an assignment is "skipped."
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What's the common usage of `useMemo`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's mainly used as an optimization to avoid heavy operation on every render
    otherwise. If a certain evaluation is excessively used, thus blocking the *UI*,
    it is the right time to think about using `useMemo` to limit the usage to only
    relevant conditions. For instance, if typing isn't related to that task, we can
    take it out of the dependency list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How do you use `useMemo` for memorization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`useMemo` doesn''t remember all past values and only remembers the last created
    value. So, the best usage of it is to use it as a special assignment replacement,
    instead of a caching mechanism.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Appendix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Appendix A – Not a Classical Memorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's very easy to confuse `useMemo` with a **Memorization** used in computer
    science, as the name indicates.
  prefs: []
  type: TYPE_NORMAL
- en: Memorization is an optimization technique in computer programs, primarily designed
    to speed up the process by storing the results of expensive operations and returning
    the cached result if it has been computed under the same condition before. The
    last part, "under the same condition before," is the part that makes it special.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Fibonacci* sequence is a classical memorization problem. If it''s written
    using a recursive algorithm, it can be very costly; therefore, we tend to use
    cache storage to store all past calculated values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code gives a specialized `fib` function; if you call it sequentially
    from `1`, `2`, and so on, it can give you the next number without too much effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say in the *React* app, we start with `n=0`; unless `n` moves to the next number,
    we don''t want to calculate a new value. We could add `useMemo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we quickly find out is that it actually reuses the `fib` function,
    which means their functionalities don't overlap at all. In another way, `useMemo`
    doesn't do what `fib` does. Amazing!
  prefs: []
  type: TYPE_NORMAL
- en: 'Another discovery is that what the `Title` component does is to ensure that
    when another `text` prop changes, it doesn''t calculate `f` again. But if we change
    `n` from `3` to `2`, it still creates a new number. This means the code can be
    reduced to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Haha, this is a bit funny now. We literally removed `useMemo`. Why? Because
    the saved calculation is already implemented by `fib`, the classical memorization.
    Moreover, the `useMemo` hook doesn't provide any of that kind of storage.
  prefs: []
  type: TYPE_NORMAL
- en: '`useMemo` has one memoized storage built for *a last value*. If you can take
    advantage of this, that''s great. Otherwise, you just over-complicate things.'
  prefs: []
  type: TYPE_NORMAL
- en: Don't expect `useMemo` to give you more values, since it doesn't even have a
    key/value map for multiple values. *React* itself is a big state machine; given
    a change, it moves to a new state. All it cares about is the current and next
    scene it's going into. Moving from `t-1` to `t` is what *React* is good at, but
    not at moving from `t` to `t-2`. Therefore, `useMemo` can't fit in the memorization
    context, which is normally what caching is about.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix B – Skipping a Child Update
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use a profiler chart provided by *React Developer Tools* to inspect
    the React component hierarchies inside the browser, as shown in *Figure 6.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Profiler render with Child bailout failed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.05_B17963.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – Profiler render with Child bailout failed
  prefs: []
  type: TYPE_NORMAL
- en: What a profiler chart provides is a topology overview of all the fibers visited
    in one update. The topology speaks for itself on how they are wired like a tree.
    Moreover, we can tell what happened to them based on their colors.
  prefs: []
  type: TYPE_NORMAL
- en: A bar with a solid color stands for an update from this component. On the other
    hand, if the color is shaded gray, it means that *React* decides to skip updating
    the component, termed as a bailout.
  prefs: []
  type: TYPE_NORMAL
- en: The chart is useful when we get to study the performance of the site because
    it can tell us in a given update how many fibers are replaced and how many are
    reused, and whether a particular fiber has been visited or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'A value created by `useMemo` can be used for any purpose. For it to impact
    a child component, it can be wired with a prop to send the info deeper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If we get a previous `assignment` of the a variable wiring to the `Child` component
    via a prop, does that mean we can have a conditional update of `Child`? This is
    a good question.
  prefs: []
  type: TYPE_NORMAL
- en: From the profiler chart corresponding to all components when the `Title` updates
    (see *Figure 6.5*), we quickly find out the answer is no. The preceding code can't
    make a skip of the `Child` update because, when the `Title` parent updates, it
    generates a new set of props through the reconciliation of the `Child` fiber.
    In other words, it triggers the update of `Child` regardless of whether an individual
    prop, such as `a`, has a new value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, how exactly can we use `useMemo` to skip a child update manually? Let''s
    try something different. Keep in mind what `useMemo` is designed to do – to hold
    a value from the last update until the condition is met again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding `useMemo` code, instead of returning a string, we use it to
    hold the `<Child />` component instance. What is `<Child />`? It''s an element
    object returned from the `Child` function component. So, as long as the element
    stays the same, we expect the screen to be the same. Let''s confirm this approach
    with the profiler chart, as shown in *Figure 6.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Profiler render with Child bailout successful'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.06_B17963.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – Profiler render with Child bailout successful
  prefs: []
  type: TYPE_NORMAL
- en: After the mount, as the `[]` dependency array indicates, `child` holds the same
    `Child` update from the last time. Now, when the `Title` component gets updated,
    it doesn't update the `Child` component. This is because, to React, there's no
    dispatched change from under the `Title` component, so it bails out everything
    underneath it.
  prefs: []
  type: TYPE_NORMAL
