- en: '*Chapter 9*: Use Custom Hooks to Reuse Logic'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：使用自定义钩子重用逻辑'
- en: In the previous chapter, we learned how the `useRef` hook is designed and how
    to use a ref for a state without updating the screen. In this chapter, we will
    gather all the hooks we have learned about so far and see how to create a custom
    hook for our own needs. We will introduce what a custom hook is and then write
    some custom hooks step by step, including `useToggle`, `useWindow`, `useAsync`,
    `useDebounced`, `useClickOutside`, `useCurrent`, and `useProxy`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了 `useRef` 钩子的设计和如何使用引用来更新状态而不刷新屏幕。在这一章中，我们将汇集到目前为止所学的所有钩子，并看看如何创建一个自定义钩子来满足我们的需求。我们将介绍什么是自定义钩子，然后逐步编写一些自定义钩子，包括
    `useToggle`、`useWindow`、`useAsync`、`useDebounced`、`useClickOutside`、`useCurrent`
    和 `useProxy`。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Reviewing React hooks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复习 React 钩子
- en: '`useToggle`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useToggle`'
- en: '`useWindow`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useWindow`'
- en: '`useAsync`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useAsync`'
- en: '`useDebounced`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useDebounced`'
- en: '`useClickOutside`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useClickOutside`'
- en: '`useCurrent`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useCurrent`'
- en: '`useProxy`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useProxy`'
- en: Questions and answers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题和答案
- en: Reviewing React hooks
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习 React 钩子
- en: 'We have seen quite a few hooks provided by *React*. Let''s take a moment to
    review what we have learned so far:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 *React* 提供的许多钩子。让我们花点时间回顾一下我们到目前为止学到了什么：
- en: Update a state with the `useState` hook.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useState` 钩子更新状态。
- en: Handle a side effect with the `useEffect` hook.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useEffect` 钩子处理副作用。
- en: Reuse the last value with the `useMemo` hook.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useMemo` 钩子重用最后一个值。
- en: Update an area with the `useContext` hook.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useContext` 钩子更新区域。
- en: Hide stuff from display with the `useRef` hook.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useRef` 钩子隐藏显示内容。
- en: The `useState` hook is the most popular one, which is used to define a state
    and make it dispatchable to trigger a *UI* update. *React* wants us to use this
    as the main mechanism to be in sync with the screen. A mental picture of using
    it is that, as long as the state changes, the *UI* should produce an outcome accordingly.
    Otherwise, the *UI* should stay intact. Essentially, what that is saying is to
    make something happen on the screen, design a state and wire it with elements.
    This is the *React* way. If you take this as a baseline, it can help you understand
    anything else.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState` 钩子是最受欢迎的，用于定义状态并使其可触发 *UI* 更新。*React* 希望我们使用这个作为与屏幕同步的主要机制。使用它的一个心理图像是，只要状态发生变化，*UI*
    就应该相应地产生结果。否则，*UI* 应保持不变。本质上，这意味着要在屏幕上发生某些事情，设计一个状态并将其与元素连接起来。这是 *React* 的方式。如果你以此为基准，可以帮助你理解其他任何东西。'
- en: The `useEffect` hook allows us to listen to state changes, and based on that,
    we can perform an action such as a side effect. Therefore, with it, you are equipped
    with two ways to make something happen on the screen, that is, either listen to
    an event or a state change. The subtlety here is that the side effect doesn't
    get applied until all the *DOM* elements settle after the update. Also, don't
    forget to clean up the side effect, if any.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect` 钩子允许我们监听状态变化，基于此，我们可以执行一个动作，例如副作用。因此，有了它，你就有两种方式在屏幕上产生某些事情，即监听事件或状态变化。这里的微妙之处在于，副作用不会在更新后所有
    *DOM* 元素都稳定下来之前应用。另外，别忘了清理副作用，如果有的话。'
- en: The `useMemo` hook serves as an optimization so that we can use a value evaluated
    in a previous update. The basic setup is that, if a state has changed, it should
    drive another round of update. And in that update, all component variables should
    get updated. But if we intentionally reuse an old value, the value can seem to
    be "skipped" from the update. This way, we can suppress some high-frequency action
    that is not relevant to the update of the component.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo` 钩子作为一个优化，使我们能够使用在之前更新中评估的值。基本设置是，如果状态已更改，它应该驱动另一轮更新。在那个更新中，所有组件变量都应该得到更新。但如果我们有意重用旧值，值似乎会“跳过”更新。这样，我们可以抑制一些与组件更新无关的高频动作。'
- en: The `useContext` hook is a must-have when it comes to an area update. A `useState`
    hook can dispatch a state to one place, but it lacks two things. One, it needs
    to use props to send a state further down to the children, and two, it needs to
    know which children it sends props to. A context, once established, can be consumed
    by any child underneath it no matter how deep the level is. And it supports on-demand
    usage – you use it when you consume it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到区域更新时，`useContext` 钩子是必不可少的。一个 `useState` 钩子可以将状态发送到某个地方，但它缺少两件事。一是需要使用属性将状态进一步发送到子组件，二是需要知道它将属性发送给哪些子组件。一旦建立上下文，任何在其下的子组件都可以消费它，无论层级有多深。并且它支持按需使用——你消费时才使用它。
- en: The `useRef` hook is a *React*-supported way to bypass the *React* engine. By
    default, *React* will want to react to all state changes. The `useRef` hook allows
    you to continue persisting this value without the update capability. So the `useRef`
    hook can become very handy in places that *React* can't or doesn't allow us to
    reach.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`useRef` 钩子是 *React* 支持的一种绕过 *React* 引擎的方式。默认情况下，*React* 会希望对所有的状态变化做出反应。`useRef`
    钩子允许你继续持久化这个值，而不需要更新能力。因此，`useRef` 钩子可以在 *React* 无法或不允许我们触及的地方变得非常有用。'
- en: 'The preceding hooks aren''t the entire *React* collection of hooks. In fact,
    *React* has more than a dozen built-in hooks; to name some others: `useCallback`,
    `useLayoutEffect`, `useTransition`, and `useDeferredValue`, and some of them are
    also in the experimental stage for the future concurrent mode of *React*.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的钩子并不是 *React* 钩子集合的全部。实际上，*React* 有十几个内置的钩子；例如，`useCallback`、`useLayoutEffect`、`useTransition`
    和 `useDeferredValue`，其中一些也处于 *React* 未来并发模式的实验阶段。
- en: There's one thing unique about the hooks we have covered so far. Each hook is
    unique and each is designed for an atomic purpose. There's not much overlapping
    in between. This provides a solid foundation when we want to mix and match them
    in our application, as we have already seen in previous chapters.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所涵盖的钩子有一个独特之处。每个钩子都是独特的，并且每个钩子都是为了一个原子目的而设计的。它们之间没有太多的重叠。当我们想要在我们的应用程序中混合和匹配它们时，这为我们提供了一个坚实的基础，正如我们在前面的章节中已经看到的。
- en: When it comes to building a website, there might be times when you want to create
    custom logic that might not be covered by these built-in hooks. You might think
    about extending some of the hooks, or you might even want to rewrite one or two.
    In that case, what option do we have? The answer to this question is in the next
    section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到构建网站时，可能会有时候你想创建一些可能不被这些内置钩子覆盖的自定义逻辑。你可能考虑扩展一些钩子，或者你可能甚至想重写一个或两个。在这种情况下，我们有什么选择？这个问题的答案在下一节中。
- en: Making a new hook
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的钩子
- en: Can we make a new hook? In each of the previous chapters, we have asked you
    to read the source code, so by now, you should be familiar with how each is implemented
    under the hood. So can we follow the same process and create one? Unfortunately,
    it's not that easy, mostly because this process isn't open for extension on the
    fly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否创建一个新的钩子？在每一章的前面，我们都要求你阅读源代码，所以到现在，你应该熟悉每个钩子是如何在底层实现的。那么，我们能否遵循同样的过程并创建一个呢？不幸的是，这并不那么容易，主要是因为这个过程并不允许即时扩展。
- en: Using a game engine as an analogy, it allows you to work with animations, materials,
    lights, and even game logic, but it doesn't allow you to change the engine. For
    instance, you can't add a custom identity type that is not animation nor materials
    and still expect the game engine to pick it up. You might ask "why not?" This
    is because a custom identity type requires additional implementations for the
    engine to support it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 用游戏引擎作类比，它允许你处理动画、材质、灯光，甚至游戏逻辑，但它不允许你更改引擎。例如，你不能添加一个既不是动画也不是材质的自定义身份类型，并仍然期望游戏引擎能够识别它。你可能会问“为什么不能？”这是因为自定义身份类型需要引擎进行额外的实现以支持它。
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '*React* is an open source project, which means anyone can contribute to the
    engine. The source code is also actively maintained by the *Facebook React* team,
    and they are constantly looking for new proposals and feature requests.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*React* 是一个开源项目，这意味着任何人都可以为引擎做出贡献。源代码也由 *Facebook React* 团队积极维护，他们一直在寻找新的提案和功能请求。'
- en: 'Although the engine is not easily to be extended, the door of creating a custom
    hook isn''t closed. Most of the time, we do not need a new hook type, instead,
    we want to have a hook with extended behavior. Let''s take a look at an example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然引擎不容易扩展，但创建自定义钩子的门并没有关闭。大多数时候，我们不需要新的钩子类型，而是希望有一个具有扩展行为的钩子。让我们来看一个例子：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Given the preceding function, we can easily encapsulate it in a new function:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 给定前面的函数，我们可以轻松地将其封装在一个新的函数中：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A hook is a function. If a hook has been designed to manage a state, whenever
    we need a state, we don't need to re-invent it; similarly, if a hook has been
    designed to handle a side effect, whenever we need a side effect, we can adopt
    these functionalities by invoking it. So, as long as the hook we designed so far
    is useful and usable enough, we should be able to just use it in our own function.
    This is the basic idea of reusability.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子是一个函数。如果一个钩子被设计用来管理状态，每次我们需要状态时，我们就不需要重新发明它；同样，如果一个钩子被设计用来处理副作用，每次我们需要副作用时，我们可以通过调用它来采用这些功能。所以，只要我们设计的钩子足够有用和可用，我们就应该能够直接在我们的函数中使用它。这就是可重用性的基本思想。
- en: 'Let''s take a look at the following example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的例子：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding function, `useUsername` uses the `useState` hook twice, and
    the output includes a joint `fullname` from two states, `firstName` and `lastName`,
    as well as two separate dispatch functions to update each of them.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，`useUsername`使用了两次`useState`钩子，输出包括来自两个状态`firstName`和`lastName`的联合`fullname`，以及两个单独的派发函数来更新它们。
- en: Let's examine the `useUsername` function a bit more closely, because `useUsername`
    is a custom hook.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地检查一下`useUsername`函数，因为`useUsername`是一个自定义钩子。
- en: Writing a custom hook
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写自定义钩子
- en: 'We can now use the `userUsername` function we just created as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用我们刚刚创建的`useUsername`函数如下：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Comparing the preceding two versions with or without the `useUsername` hook,
    we can see that the `useUsername` function is more or less an extracted utility
    function through a code refactoring where the interface for the new `useUsername`
    function emerges as two strings as input arguments and an object with a string
    and two functions as the return value.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面两个版本与或没有`useUsername`钩子的版本进行比较，我们可以看到`useUsername`函数基本上是通过代码重构提取的一个实用函数，其中新`useUsername`函数的接口以两个字符串作为输入参数，以及一个包含字符串和两个函数的对象作为返回值。
- en: This is just how we create a new function in the first place. We create a function
    because we need it or because we see some duplication in our code, and we can
    avoid the duplication by doing some refactoring. This way, not only does the code
    get cleaner afterward, but the function can also be used in some other places
    in the future. Refactoring is more like a one-stone-shooting-two-birds kind of
    approach, as long as there're multiple birds to shoot.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们最初创建新函数的方式。我们创建函数是因为我们需要它，或者因为我们看到代码中存在一些重复，我们可以通过一些重构来避免重复。这样，代码不仅会变得整洁，而且函数还可以在未来的其他地方使用。重构更像是一种一石二鸟的方法，只要有多只鸟要打。
- en: This is Computer Science 101, and the custom hook we created so far is one demonstration
    of it. OK, let's go over some of the basics of the custom hook.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是计算机科学101，我们迄今为止创建的自定义钩子是它的一个演示。好，让我们回顾一下自定义钩子的一些基本概念。
- en: 'The reason why we call `useUsername` a custom hook is that it meets the following
    requirements:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以称`useUsername`为自定义钩子，是因为它满足以下要求：
- en: It is a function.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个函数。
- en: It is named with the prefix `use`.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它以`use`为前缀命名。
- en: It consumes at least one built-in hook.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它至少消耗了一个内置钩子。
- en: 'Apparently, we can write a function and arbitrarily give it a name with the
    prefix `use`, but does it qualify as a custom hook? Let''s take a look at the
    following function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以编写一个函数并随意给它一个以`use`为前缀的名字，但这样的函数是否算作自定义钩子呢？让我们看看下面的函数：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A function like `useNotAHook` in the preceding setup is not a hook! Don't we
    keep saying a hook is a function? Yes, but not all functions are hooks, even when
    it gets invoked inside a functional component, such as in the `Title` component.
    The `useNotAHook` is merely a plain function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的设置中像`useNotAHook`这样的函数不是钩子！我们不是一直在说钩子是一个函数吗？是的，但并非所有函数都是钩子，即使它在功能组件内部被调用，比如在`Title`组件中。`useNotAHook`仅仅是一个普通函数。
- en: 'You might be thinking "Okay, we need to make a function a bit more complicated
    to qualify as a custom hook." Let''s try with the following function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“好吧，我们需要让函数变得更复杂才能算作自定义钩子。”让我们尝试以下函数：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are only two lines in the preceding function, so it's not complicated.
    It takes the first part of the `useState` hook and returns the state only. That's
    it. But is it a custom hook? Yes, it is. So, a custom hook doesn't have to be
    complicated!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数中只有两行，所以它并不复杂。它只取`useState`钩子的第一部分并返回状态。就是这样。但它是自定义钩子吗？是的，它是。所以，自定义钩子不必很复杂！
- en: Hopefully, by now, you don't feel dizzy from looking at these mind-bending examples.
    In short, by convention, a custom hook needs to meet all the requirements listed
    earlier.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到现在为止，你看这些令人费解的例子时不会感到头晕。简而言之，按照惯例，一个自定义钩子需要满足之前列出的所有要求。
- en: Technically, the only thing that separates the custom hook from a regular function
    is that it uses at least one of the built-in hooks at least once. What's so special
    about the built-in hooks? The built-in hooks hook into *React* and provide functionalities
    that you can't make without opening the engine. The functionalities here mostly
    refer to managing a persistent state. This is where the name "custom" comes from,
    to distinguish the hook you created and the built-in ones.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，自定义钩子和常规函数之间唯一的区别是它至少使用了一次内置钩子。内置钩子有什么特别之处呢？内置钩子“钩入React”并提供了一些你无法在不打开引擎的情况下实现的功能。这里的功能主要指的是管理持久状态。这就是“自定义”这个名字的由来，用来区分你创建的钩子和内置钩子。
- en: Before we move into creating a custom hook, there's also one more unique thing
    worth pointing out. Most of the custom hooks are designed without any visual representation
    attached to them. So, a custom hook is essentially a piece of reusable algorithm.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建自定义钩子之前，还有另一个值得注意的独特之处。大多数自定义钩子都是没有附带任何视觉表示的。因此，自定义钩子本质上是一段可重用的算法。
- en: This is how the *React* team envisioned the hooks can bring to us. Hooks "let
    you reuse logic between components." Keep this in mind when you create custom
    hooks. If the logic smells generic enough to you, or at least you think there's
    one more location where you could apply the same logic, it's time for us to experiment
    with the idea of using a custom function, and if it turns out it uses one of the
    built-in hooks, then here you go, you create a custom hook.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是React团队构想的钩子可以为我们带来的。钩子“让你可以在组件之间重用逻辑。”当你创建自定义钩子时，请记住这一点。如果你觉得逻辑足够通用，或者至少你认为还有其他地方可以应用相同的逻辑，那么是我们尝试使用自定义函数的时候了。如果它最终使用了内置钩子之一，那么你就可以创建一个自定义钩子了。
- en: Now with the basic idea in mind, retrospectively, if we review the code we have
    written in this book so far, we would spot that we might have hopped on this boat
    without knowing it. Let's revisit it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基本的概念，回顾一下，如果我们回顾这本书中迄今为止所写的代码，我们会发现我们可能在不自知的情况下上了这艘船。让我们重新审视它。
- en: useToggle
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useToggle
- en: 'Hooks used in this custom hook: `useState`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个自定义钩子中使用的钩子：`useState`
- en: 'Taking one example, we have had this idea of switching a state between `true`
    and `false` for a while. We use it in switchable cases, such as toggling a checkbox,
    hovering over a text, raising an error, or anything that simulates a light switch.
    See *Figure 9.1* for one of the usages:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个例子为例，我们已经有在`true`和`false`之间切换状态的想法有一段时间了。我们用它来处理可切换的情况，比如切换复选框、悬停在文本上、引发错误，或者任何模拟开关灯的行为。参见*图9.1*中的一个用法：
- en: '![Figure 9.1 – useToggle'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – useToggle'
- en: '](img/Figure_9.1_B17963.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.1_B17963.jpg)'
- en: Figure 9.1 – useToggle
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – useToggle
- en: 'Can we abstract this idea to provide such boolean state as well as the toggle
    functionality? Let''s start refactoring:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否将这个想法抽象化，提供这样的布尔状态以及切换功能？让我们开始重构：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code block, the `useToggle` custom hook takes an `initialStatus`
    as the input argument with `false` as the default value, and it returns the `status`
    and a `toggle` function. Invoking the `toggle` function flips the `status` from
    `false` to `true`, or `true` to `false`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，`useToggle`自定义钩子接受一个`initialStatus`作为输入参数，默认值为`false`，并返回`status`和一个`toggle`函数。调用`toggle`函数会将`status`从`false`切换到`true`，或者从`true`切换到`false`。
- en: 'The `useToggle` hook has a very nice function designed with well-defined input
    arguments and a return value and looks handy for supporting the toggle between
    a boolean status. There''s a small improvement we can make here. Sometimes, we
    also want to toggle into a specific status instead of the flip:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`useToggle`钩子有一个设计得很好的函数，具有定义明确的输入参数和返回值，看起来非常适合支持布尔状态的切换。这里我们可以做一些小的改进。有时，我们还想切换到特定的状态，而不仅仅是翻转：'
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding revised version of `toggle`, when a `newStatus` is given,
    it toggles to that specific status, otherwise, it flips as in the old `toggle`.
    Notice we use a double arrow in a row, as in `() => () => {}`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`toggle`的前一个修订版本中，当给出`newStatus`时，它会切换到该特定状态，否则，它会像旧的`toggle`一样翻转。注意我们使用了一行中的双箭头，如`()
    => () => {}`：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If we were to write it slowly, we could use the preceding equivalent version
    where you can clearly see an inline function is returned from a function, since
    in this case, we expect what's returned from the `toggle` to be an event handler.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们慢慢写，我们可以使用前面的等效版本，其中可以清楚地看到从函数中返回了一个内联函数，因为在这种情况下，我们期望`toggle`返回的是一个事件处理器。
- en: A function returning a function is very common in **Functional Programming**
    (**FP**). Although this book does not cry out for FP (or maybe it already did),
    it's just natural to use FP in *React* code, especially when working with a function
    component.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 返回函数的函数在**函数式编程**（**FP**）中非常常见。尽管这本书并没有强烈要求使用FP（或者可能已经做到了），但在*React*代码中使用FP是很自然的，尤其是在处理函数组件时。
- en: Okay, now we have the custom hook designed, let's give it a spin.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经设计了自定义钩子，让我们来试一试。
- en: Usages
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用法
- en: 'Say we apply this `useToggle` hook to an `Avatar` component where an `error`
    can be toggled. The `Avatar` component was introduced in [*Chapter 4*](B17963_04_Epub.xhtml#_idTextAnchor113),
    *Use State to Jumpstart Components*:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将这个`useToggle`钩子应用到可以切换`error`状态的`Avatar`组件中。`Avatar`组件在[*第4章*](B17963_04_Epub.xhtml#_idTextAnchor113)中介绍，*使用状态启动组件*：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Interesting! Though there's no drastic difference before and after applying
    the `useToggle`, the logic becomes quite clear in that an `error` state gets toggled
    after the image loading runs into an error.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 很有趣！尽管在应用`useToggle`前后没有太大的差异，但在图像加载遇到错误后，`error`状态被切换的逻辑变得相当清晰。
- en: Playground – Avatar with useToggle
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 使用useToggle的Avatar
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/yLozOJQ](https://codepen.io/windmaomao/pen/yLozOJQ).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎自由地在这个在线示例中尝试[https://codepen.io/windmaomao/pen/yLozOJQ](https://codepen.io/windmaomao/pen/yLozOJQ)。
- en: 'Let''s try to apply `useToggle` in another place, such as the `Tooltip` component,
    also introduced in [*Chapter 4*](B17963_04_Epub.xhtml#_idTextAnchor113), *Use
    State to Jumpstart Components*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在另一个地方应用`useToggle`，比如在也介绍在[*第4章*](B17963_04_Epub.xhtml#_idTextAnchor113)中的`Tooltip`组件中，*使用状态启动组件*：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, we used a `useToggle` to return an `entered` state and
    an `onEntered` function that feeds into the `onMouseEnter` and `onMouseLeave`
    event handler neatly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了`useToggle`来返回一个`entered`状态和一个`onEntered`函数，这个函数可以很好地输入到`onMouseEnter`和`onMouseLeave`事件处理器中。
- en: Playground – Tooltip with useToggle
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 使用useToggle的工具提示
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/QWMqNKx](https://codepen.io/windmaomao/pen/QWMqNKx).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎自由地在这个在线示例中尝试[https://codepen.io/windmaomao/pen/QWMqNKx](https://codepen.io/windmaomao/pen/QWMqNKx)。
- en: The concept of having a toggle mechanism is revealed vividly via the `useToggle`
    hook. The function can be tested separately and can be extended with relatively
    little effort. If we use this hook often, the cost of creating it and maintaining
    it can become even cheaper.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`useToggle`钩子，切换机制的概念得到了生动的揭示。函数可以单独测试，并且可以相对容易地扩展。如果我们经常使用这个钩子，创建和维护它的成本甚至可以更低。
- en: References
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'There are a number of people who have written similar hooks to `useToggle`
    on the internet. Here is a list of some of them as references in case you''d like
    to learn more about this custom hook:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上，有许多人编写了类似于`useToggle`的类似钩子。以下是一些供你参考的列表，以便你了解更多关于这个自定义钩子的信息：
- en: '`useToggle`: [https://usehooks.com/useToggle/](https://usehooks.com/useToggle/).'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useToggle`: [https://usehooks.com/useToggle/](https://usehooks.com/useToggle/).'
- en: '`react-use-toggle`: [https://github.com/bsonntag/react-use-toggle](https://github.com/bsonntag/react-use-toggle).
    It has a good test written.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-use-toggle`: [https://github.com/bsonntag/react-use-toggle](https://github.com/bsonntag/react-use-toggle).
    它有一个很好的测试。'
- en: useWindow
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useWindow
- en: 'Hooks used in this custom hook: `useState` and `useEffect`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在此自定义钩子中使用的钩子：`useState`和`useEffect`
- en: A text or image can adjust its appearance based on the current browser window
    size. We experimented with this idea in [*Chapter 5*](B17963_05_Epub.xhtml#_idTextAnchor157),
    *Use Effect to Handle Side Effects*. See *Figure 9.2*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 文本或图像可以根据当前浏览器窗口大小调整其外观。我们在[*第5章*](B17963_05_Epub.xhtml#_idTextAnchor157)中实验了这个想法，*使用Effect处理副作用*。见*图9.2*。
- en: '![Figure 9.2 – useWindow custom hook'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 – useWindow自定义钩子'
- en: '](img/Figure_9.2_B17963.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.2_B17963.jpg)'
- en: Figure 9.2 – useWindow custom hook
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – useWindow自定义钩子
- en: 'Now the question is: can we abstract this idea out and apply it to anything
    on the screen as in a responsive design? Let''s refactor the code a bit to come
    up with a custom `useWindow` hook:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是：我们能否将这个想法抽象出来，并将其应用于屏幕上的任何地方，就像响应式设计一样？让我们稍微重构一下代码，以提出一个自定义的`useWindow`钩子：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding `useWindow` hook is taken out of our previous code and returns
    the current width of the screen. A `useEffect` is used to handle the initialization
    and cleanup of the system event upon a browser `resize`. During each screen resize,
    the window's `innerWidth` is stored in the `width` state.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `useWindow` 钩子是从我们之前的代码中提取出来的，并返回屏幕的当前宽度。使用 `useEffect` 来处理浏览器 `resize`
    事件上的初始化和清理系统事件。在每次屏幕调整大小时，窗口的 `innerWidth` 被存储在 `width` 状态中。
- en: In order to make it easy to use, we can provide the input argument `size` to
    this custom hook, so that it can also tell us whether the `width` is beyond that
    `size`, telling us whether the screen is wide enough to support a large-sized
    version.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其易于使用，我们可以向这个自定义钩子提供输入参数 `size`，这样它也可以告诉我们 `width` 是否超过了那个 `size`，从而告诉我们屏幕是否足够宽以支持大尺寸版本。
- en: Usages
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用法
- en: 'Let''s apply this custom hook to a text that can adjust to a large version
    when the screen size reaches beyond 600 *px*:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个自定义钩子应用到当屏幕尺寸达到 600 *px* 时可以调整为大版本的文本：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This looks very easy to use, and moreover, the functionalities pertaining to
    detecting the window size are entirely taken out and outsourced to the `useWindow`
    hook, therefore reducing the code quite a bit.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来非常容易使用，而且更重要的是，与检测窗口尺寸相关的功能完全被提取出来并外包给 `useWindow` 钩子，因此大大减少了代码量。
- en: Playground – Responsive with useWindow
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 使用 useWindow 响应式
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/zYdEqog](https://codepen.io/windmaomao/pen/zYdEqog).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎自由地在这个在线示例中玩耍 [https://codepen.io/windmaomao/pen/zYdEqog](https://codepen.io/windmaomao/pen/zYdEqog).
- en: 'There''s one unique thing about this custom hook. Unlike a classical `media-query`
    supported by *CSS*, the `wide` flag returned from `useWindow` is used to change
    the layout entirely. This means we can support a very drastic screen change to
    accommodate the screen size:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自定义钩子有一个独特之处。与 *CSS* 支持的经典 `media-query` 不同，`useWindow` 返回的 `wide` 标志用于完全更改布局。这意味着我们可以支持非常剧烈的屏幕变化以适应屏幕尺寸：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, `HeaderWide` and `HeaderMini` are two completely different
    layout components to display a header for screen sizes of less than `725` and
    larger than `725`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`HeaderWide` 和 `HeaderMini` 是两个完全不同的布局组件，用于显示小于 `725` 和大于 `725` 的屏幕尺寸的标题。
- en: One thing we learned from making this custom hook is that the functionalities
    can be tailored to your own purpose. Here, we export a flag, `width > size`, because
    we believe it's useful for the current project. However, the responsiveness setting
    isn't fixed, and it can vary from project to project. This doesn't stop us from
    creating something useful at the moment. And this is the point of code refactoring,
    to improve the quality of the code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从制作这个自定义钩子的过程中，我们学到的一点是，功能可以根据您的目的进行定制。在这里，我们导出一个标志，`width > size`，因为我们认为它对当前项目很有用。然而，响应性设置不是固定的，它可以因项目而异。这并不会阻止我们在当前时刻创建一些有用的东西。这正是代码重构的意义，即提高代码质量。
- en: References
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Our version of `useWindow` monitors the window width only, but we can track
    both the width and height of the screen, as implemented in the following references:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们版本的 `useWindow` 只监控窗口宽度，但我们也可以跟踪屏幕的宽度和高度，如下面的参考实现所示：
- en: '`useWindowSize`: [https://usehooks.com/useWindowSize/](https://usehooks.com/useWindowSize/)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useWindowSize`: [https://usehooks.com/useWindowSize/](https://usehooks.com/useWindowSize/)'
- en: '`useWindowSize`: [https://github.com/jaredLunde/react-hook/tree/master/packages/window-size](https://github.com/jaredLunde/react-hook/tree/master/packages/window-size)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useWindowSize`: [https://github.com/jaredLunde/react-hook/tree/master/packages/window-size](https://github.com/jaredLunde/react-hook/tree/master/packages/window-size)'
- en: useAsync
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useAsync
- en: 'Hooks used in this custom hook: `useState`, `useEffect`, `useRef`, and `useMemo`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在此自定义钩子中使用的钩子：`useState`, `useEffect`, `useRef`, 和 `useMemo`
- en: 'One hook everyone wants to get their hands dirty with is `useAsync`, which
    is used to fetch an async resource as we introduced in [*Chapter 5*](B17963_05_Epub.xhtml#_idTextAnchor157),
    *Use Effect to Handle Side Effects*. See *Figure 9.3*:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都希望尝试的钩子之一是 `useAsync`，它用于获取异步资源，正如我们在[*第五章*](B17963_05_Epub.xhtml#_idTextAnchor157)中介绍的，*使用
    Effect 处理副作用*。参见 *图 9.3*：
- en: '![Figure 9.3 – useAsync hook'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.3 – useAsync 钩子'
- en: '](img/Figure_9.3_B17963.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.3_B17963.jpg)'
- en: Figure 9.3 – useAsync hook
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – useAsync 钩子
- en: 'As simple as it sounds, everyone comes with different requirements and implementations
    for their projects. Here are a few features that we would like to have:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然听起来很简单，但每个人对他们的项目都有不同的要求和实现。以下是我们希望拥有的几个功能：
- en: Support a loading indicator.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持加载指示器。
- en: Can execute on demand.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可按需执行。
- en: Support error handling.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持错误处理。
- en: Can cancel async call.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以取消异步调用。
- en: Can cache async data.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以缓存异步数据。
- en: The feature list can go on and on. In this book, I will provide a basic version
    that supports the first two items.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 功能列表可以一直继续。在这本书中，我将提供一个支持前两项的基本版本。
- en: 'At any point, the call should be aware of the `loading` state, and when the
    resource is resolved, the `data` should be available to use. Also, we''d like
    to keep a handle on the `execute` function in case we want to fetch the resource
    again. Let''s design it in a custom hook:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，调用都应该知道`loading`状态，并且当资源解析完成后，`data`应该可用以供使用。此外，我们希望保留对`execute`函数的引用，以防我们想要再次获取资源。让我们通过自定义钩子来设计它：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code block, the `useAsync` hook takes three input arguments,
    `asyncFunc`, `initialParams`, and `immediate`, and returns three properties, `execute`,
    `loading`, and `data`. The `asyncFunc` function is a user-provided async function,
    such as a *Promise*, defined as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码块中，`useAsync`钩子接受三个输入参数，`asyncFunc`、`initialParams`和`immediate`，并返回三个属性，`execute`、`loading`和`data`。`asyncFunc`函数是一个用户提供的异步函数，例如一个*Promise*，如下定义：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding `fn` promise, an `id` is sent as the input argument. This
    is where the second input argument of `useAsync` becomes useful, and it can be
    used to provide the `initialParams` in key/value pairs as in `{ id: 3 }`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '在先前的`fn`承诺中，一个`id`作为输入参数发送。这就是`useAsync`的第二个输入参数变得有用的地方，它可以用来以键/值对的形式提供`initialParams`，例如`{
    id: 3 }`。'
- en: The `useAsync` hook also supports an optional flag, `immediate`, and when set
    as `true`, it invokes the async call immediately after the component mount. Although
    this is the most popular case, we can set it as `false` so we manually invoke
    `execute` later.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`useAsync`钩子还支持一个可选的标志`immediate`，当设置为`true`时，它会在组件挂载后立即调用异步调用。尽管这是最常见的情况，但我们也可以将其设置为`false`，这样我们就可以稍后手动调用`execute`。'
- en: 'Inside the hook, we use states to model `loading` and `data`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在钩子内部，我们使用状态来模拟`loading`和`data`：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A `useRef` is used for `mountedRef` to know when this component is dismounted;
    we explained this in [*Chapter 8*](B17963_08_Epub.xhtml#_idTextAnchor278), *Use
    Ref to Hide Stuff*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`useRef`来为`mountedRef`提供信息，以知道何时这个组件被卸载；我们已在[*第8章*](B17963_08_Epub.xhtml#_idTextAnchor278)，“使用Ref隐藏内容”中解释了这一点。
- en: 'To provide the capability of fetching the resource on demand, an `execute`
    function is created and accepts a `params` object:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供按需获取资源的能力，我们创建了一个`execute`函数，它接受一个`params`对象：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding `execute` function sets the `loading` to `true` so that if we
    have a spinner wired with it, it can start to spin. And then it invokes the `asyncFunc`
    with the combination of `params` and `initialParams` so the `params` can overwrite
    any keys set by `initialParams`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的`execute`函数中，将`loading`设置为`true`，这样如果我们将一个加载指示器与之连接，它就可以开始旋转。然后它使用`params`和`initialParams`的组合调用`asyncFunc`，这样`params`就可以覆盖`initialParams`设置的任何键。
- en: When the resource is resolved and returned, we first check if the component
    is still mounted by `mountedRef`, and if not, we skip to avoid the memory leak.
    Otherwise, it sets the `data` accordingly and dismisses the spinner by setting
    `loading` to `false`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当资源解析并返回时，我们首先通过`mountedRef`检查组件是否仍然挂载，如果不是，我们跳过以避免内存泄漏。否则，它将根据需要设置`data`，并通过将`loading`设置为`false`来关闭加载指示器。
- en: 'There''s also a subtlety here that we want to use one version of this `execute`
    function instead of a new instance in each update, therefore, we can apply `useMemo`
    here to make that happen:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个细微之处，我们希望使用这个`execute`函数的一个版本，而不是在每次更新时使用一个新的实例，因此，我们可以在这里应用`useMemo`来实现这一点：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When `immediate` is set to `true`, we want to invoke the fetch right after
    the mount and this is supported through a `useEffect` hook:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当`immediate`设置为`true`时，我们希望在挂载后立即调用获取操作，这通过`useEffect`钩子得到支持：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To make sure we don''t run into a memory leak, we also need to set the `mountedRef`
    to `false` when it''s unmounted. This is done through another `useEffect`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们不遇到内存泄漏，我们还需要在组件卸载时将`mountedRef`设置为`false`。这是通过另一个`useEffect`来完成的：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With these changes, this custom `useAsync` hook is quite feature-rich for fetching
    a resource in general. Let's give it a spin.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，这个自定义的`useAsync`钩子对于一般资源获取来说功能丰富。让我们试一试。
- en: Usages
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用法
- en: 'Now let''s apply the `useAsync` custom hook to a `Title` component and see
    how we can preload some info from an *API*:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将`useAsync`自定义钩子应用到`Title`组件上，看看我们如何可以预加载一些来自*API*的信息：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code, the async function is invoked immediately. After the
    mount, it displays `null`, and during the fetching, it displays `loading...`,
    and displays `loaded` after the fetch is successful. In this simple case, we added
    two short circuit pathways:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，异步函数立即被调用。在挂载后，它显示`null`，在获取过程中显示`loading...`，在获取成功后显示`loaded`。在这个简单的情况下，我们添加了两个短路路径：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Upon loading, we switch to a loading status; this is the place where you can
    install a pretty (inline) loader or spinner:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载时，我们切换到加载状态；这是你可以安装一个漂亮的（内联）加载器或旋转器的位置：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Regardless of whether the loading hasn''t started or the fetch has failed,
    as long as the data isn''t available, we display nothing on the screen:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 无论加载是否尚未开始或获取失败，只要数据不可用，我们就在屏幕上不显示任何内容：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This logic is effective to prevent the user from seeing any incomplete or wrong
    data.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这种逻辑可以有效地防止用户看到任何不完整或错误的数据。
- en: Playground – Fetch with useAsync
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Playground – 使用useAsync获取
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/jOLaOxO](https://codepen.io/windmaomao/pen/jOLaOxO).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎在线尝试这个示例[https://codepen.io/windmaomao/pen/jOLaOxO](https://codepen.io/windmaomao/pen/jOLaOxO)。
- en: 'Okay, let''s try a case without fetching initially. Instead, we fetch a resource
    of an arbitrary `id` from a user interaction, such as a **Delete** button in a
    table row:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们尝试一个初始不进行获取的案例。相反，我们从用户交互中获取一个任意的`id`资源，例如表格行中的**删除**按钮：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding example, the `fetch` promise is amended to accept `id` as input.
    We used `execute` manually inside an event handler, `onClick`, where we fetched
    the resource with a given `id`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`fetch`承诺被修改为接受`id`作为输入。我们在事件处理程序`onClick`内部手动使用`execute`，其中使用给定的`id`获取资源。
- en: Playground – Manual Fetch with useAsync
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Playground – 使用useAsync手动获取
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/GRvOgoa](https://codepen.io/windmaomao/pen/GRvOgoa).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎在线尝试这个示例[https://codepen.io/windmaomao/pen/GRvOgoa](https://codepen.io/windmaomao/pen/GRvOgoa)。
- en: References
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'The `useAsync` hook we provided here serves as a basic template for learning
    purposes. If you are interested in more functionalities to serve your project
    needs, you can find more at the following references:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供的`useAsync`钩子作为学习目的的基本模板。如果你对你的项目需要更多功能，你可以在以下参考资料中找到更多：
- en: '`useAsync`: [https://usehooks.com/useAsync/](https://usehooks.com/useAsync/)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useAsync`: [https://usehooks.com/useAsync/](https://usehooks.com/useAsync/)'
- en: 'Hooks Async: [https://github.com/dai-shi/react-hooks-async](https://github.com/dai-shi/react-hooks-async)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Hooks Async: [https://github.com/dai-shi/react-hooks-async](https://github.com/dai-shi/react-hooks-async)'
- en: 'Fetching Library: [https://github.com/marcin-piela/react-fetching-library](https://github.com/marcin-piela/react-fetching-library)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取库：[https://github.com/marcin-piela/react-fetching-library](https://github.com/marcin-piela/react-fetching-library)
- en: 'Vercel SWR: [https://swr.vercel.app/](https://swr.vercel.app/) – supports caching
    and server integration'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Vercel SWR: [https://swr.vercel.app/](https://swr.vercel.app/) – 支持缓存和服务器集成'
- en: 'React Query: [https://github.com/tannerlinsley/react-query](https://github.com/tannerlinsley/react-query)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'React Query: [https://github.com/tannerlinsley/react-query](https://github.com/tannerlinsley/react-query)'
- en: useDebounced
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useDebounced
- en: 'Hooks used in this custom hook: `useState`, `useEffect`, and `useRef`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在此自定义钩子中使用的钩子：`useState`、`useEffect`和`useRef`
- en: In [*Chapter 6*](B17963_06_Epub.xhtml#_idTextAnchor203), *Use Memo to Boost
    Performance*, we ran into a very interesting implementation where we debounced
    the user keystroke so that we don't invoke a heavy operation (such as search)
    too frequently.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B17963_06_Epub.xhtml#_idTextAnchor203)，“使用Memo提升性能”中，我们遇到了一个非常有趣的实现，其中我们防抖了用户的按键，这样我们就不太频繁地调用重操作（如搜索）。
- en: '![Figure 9.4 – useDebounced hook'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4 – useDebounced钩子'
- en: '](img/Figure_9.4_B17963.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.4_B17963.jpg)'
- en: Figure 9.4 – useDebounced hook
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – useDebounced钩子
- en: 'A pattern that emerged is that for a given state, whenever we change it via
    dispatch, we want to wait for a period of time before we are assured that it''s
    the right time to act upon it. So essentially we want to design a new state as
    a debounced version of a given state. Let''s try to capture this pattern in a
    custom `useDebounced` hook:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 出现的一个模式是，对于给定状态，无论我们通过分发来改变它，我们都需要等待一段时间，以确保这是采取行动的正确时机。因此，本质上我们想要设计一个新的状态，作为给定状态的防抖版本。让我们尝试在自定义的`useDebounced`钩子中捕捉这个模式：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code block, the `useDebounced` hook is designed to take two
    input arguments, the `oldState` and the time `duration` for the debounce duration.
    The hook returns a new `state` with a debounced value.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，`useDebounced` 钩子被设计为接受两个输入参数，即 `oldState` 和防抖持续时间的 `duration`。钩子返回一个新的带有防抖值的
    `state`。
- en: It actually can't reuse the `debounce` function from the *Lodash* library, so
    the `debounce` functionality is recreated here. The frequency of the new state
    is controlled by a `useEffect`. Upon each change from `oldState`, it kicks off
    a `setTimeout`, which is asking to run a callback after a certain `duration`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上不能重用 *Lodash* 库中的 `debounce` 函数，因此在这里重新创建了 `debounce` 功能。新状态频率由 `useEffect`
    控制。每当 `oldState` 发生变化时，它都会启动一个 `setTimeout`，要求在一定的 `duration` 后运行回调函数。
- en: Here, we used a `useRef` to make sure we can keep track of a persistent function
    handle for `setTimeout` during the lifetime of the component. Between now and
    the duration ends, if another change comes in, it cancels the previous `setTimeout`
    via `clearTimeout`, thus preventing the change to apply to the `state`. Only when
    one of the `setTimeout` manages to get invoked does the change of `oldState` get
    applied to `state`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `useRef` 确保我们可以在组件的生命周期内跟踪 `setTimeout` 的持久函数处理。在现在和持续时间结束之间，如果另一个变化发生，它将通过
    `clearTimeout` 取消之前的 `setTimeout`，从而防止变化应用到 `state` 上。只有当其中一个 `setTimeout` 成功调用时，`oldState`
    的变化才会应用到 `state` 上。
- en: In a way, the `oldState` and the `state` lags a bit in between. Let's give it
    a spin and see how we can use this `useDebounced` hook.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，`oldState` 和 `state` 之间会有一点滞后。让我们试一试，看看我们如何使用这个 `useDebounced` 钩子。
- en: Usages
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用法
- en: 'Let''s take a look at how it''s used in the `Title` component where we need
    to perform a search based on the user typing:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它如何在需要根据用户输入执行搜索的 `Title` 组件中使用：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding code, a `text` state is sent to `useDebounced` to form a new
    `query` state:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，一个 `text` 状态被发送到 `useDebounced` 以形成一个新的 `query` 状态：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Because the `query` state is less frequently updated, we can wire it to the
    `filter` via `useMemo`, since otherwise, the `text` state can get updated very
    rapidly via `onChange`. In a way, we created a state event out of `query` so the
    *UI* updates according to two data streams with different frequencies.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `query` 状态更新频率较低，我们可以通过 `useMemo` 将其连接到 `filter`，因为否则 `text` 状态可以通过 `onChange`
    非常快速地更新。从某种意义上说，我们通过 `query` 创建了一个状态事件，以便根据不同频率的两个数据流更新 *UI*。
- en: Playground – Search with useDebounced
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 使用 useDebounced 进行搜索
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/bGrYNmB](https://codepen.io/windmaomao/pen/bGrYNmB).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎您在此在线示例中自由尝试 [https://codepen.io/windmaomao/pen/bGrYNmB](https://codepen.io/windmaomao/pen/bGrYNmB)。
- en: From this `useDebounced` custom hook, we can see an artificial event created
    out of listening to a state change that can be as useful as a physical event.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个 `useDebounced` 自定义钩子中，我们可以看到一个由监听状态变化而创建的人工事件，其作用可以与物理事件一样有用。
- en: References
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'To learn more about the `useDebounced` hook, here are the reference links for
    you:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 `useDebounced` 钩子的信息，这里为您提供了参考链接：
- en: '`useDebounce`: [https://usehooks.com/useDebounce/](https://usehooks.com/useDebounce/).'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useDebounce`: [https://usehooks.com/useDebounce/](https://usehooks.com/useDebounce/).'
- en: '`useDebounce`: [https://github.com/xnimorz/use-debounce](https://github.com/xnimorz/use-debounce).
    This supports all debounce options.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useDebounce`: [https://github.com/xnimorz/use-debounce](https://github.com/xnimorz/use-debounce).
    该功能支持所有防抖选项。'
- en: useClickOutside
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useClickOutside
- en: 'Hooks used in this custom hook: `useEffect`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在此自定义钩子中使用的钩子：`useEffect`
- en: In [*Chapter 8*](B17963_08_Epub.xhtml#_idTextAnchor278), *Use Ref to Hide Stuff*,
    we learned about a case where we can detect when a user clicks outside a component.
    This feature is pretty generic and we want to take advantage of this in various
    parts of the project, such as dismissing a modal or tooltip – see *Figure 9.5*.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 8 章*](B17963_08_Epub.xhtml#_idTextAnchor278)，*使用 Ref 隐藏内容* 中，我们了解了一个可以检测用户点击组件外部的案例。这个功能相当通用，我们想在项目的各个部分利用这个功能，例如关闭模态或工具提示
    – 见 *图 9.5*。
- en: '![Figure 9.5 – useClickOutside hook'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.5 – useClickOutside 钩子'
- en: '](img/Figure_9.5_B17963.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_9.5_B17963.jpg)'
- en: Figure 9.5 – useClickOutside hook
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – useClickOutside 钩子
- en: 'Let''s see if we can refactor the old code a bit and turn it into a custom
    `useClickOutside` hook:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们能否对旧代码进行一些重构，并将其转换为自定义的 `useClickOutside` 钩子：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `useClickOutside` hook accepts two input arguments, the first one is a `ref`
    to the element, and the second is the callback `handler` to invoke after detecting
    clicking outside. Notice the hook doesn't return any value.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`useClickOutside`钩子接受两个输入参数，第一个是一个元素的`ref`，第二个是在检测到外部点击后要调用的回调`handler`。注意这个钩子不返回任何值。'
- en: A `useEffect` is used to manage a `mousedown` event, and if the click is inside
    the component, the handler is prevented from being invoked. We basically take
    our old code into a separate function. Let's give it a spin.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`useEffect`来管理一个`mousedown`事件，如果点击在组件内部，则阻止处理程序被调用。我们基本上将我们的旧代码放入一个单独的函数中。让我们试试看。
- en: Usages
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用法
- en: 'We can try out the `useClickOutside` on a `Menu` component:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一个`Menu`组件上尝试`useClickOutside`：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This time we set up the `Menu` to support two input arguments. One is the `on`
    flag and the other is the `dismiss` function. Both are provided via props so the
    `Menu` can be driven by the parent component:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们设置了`Menu`以支持两个输入参数。一个是`on`标志，另一个是`dismiss`函数。这两个都通过props提供，以便`Menu`可以被父组件驱动：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding `App` component, we used an `on` state from a custom hook we
    just built earlier to provide us with a boolean as well as a `toggle` function.
    We used them to drive a `Menu`. Cool, we started using our own custom hook in
    no time. Initially, the `on` is set to `true`, indicating the `Menu` is displayed.
    Clicking anywhere outside of it would dismiss it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`App`组件中，我们使用了一个自定义钩子中之前构建的`on`状态，为我们提供了一个布尔值以及一个`toggle`函数。我们使用它们来驱动一个`Menu`。太棒了，我们立刻开始使用自己的自定义钩子。最初，`on`被设置为`true`，表示`Menu`被显示。点击其外部任何地方都会使其消失。
- en: Playground – Menu with useClickOutside
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Playground – 使用useClickOutside的Menu
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/qBXVdOe](https://codepen.io/windmaomao/pen/qBXVdOe).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎在此在线示例[https://codepen.io/windmaomao/pen/qBXVdOe](https://codepen.io/windmaomao/pen/qBXVdOe)中玩耍。
- en: References
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'To learn more about the `useClickOutside` hook, here are some reference links
    for you:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`useClickOutside`钩子的信息，这里有一些参考链接供您参考：
- en: '`useOnClickOutside`: [https://usehooks.com/useOnClickOutside/](https://usehooks.com/useOnClickOutside/)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useOnClickOutside`：[https://usehooks.com/useOnClickOutside/](https://usehooks.com/useOnClickOutside/)'
- en: '`useClickOutside`: [https://github.com/ElForastero/use-click-outside](https://github.com/ElForastero/use-click-outside)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useClickOutside`：[https://github.com/ElForastero/use-click-outside](https://github.com/ElForastero/use-click-outside)'
- en: useCurrent
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useCurrent
- en: 'Built-in hooks used in this custom hook: `useState`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在此自定义钩子中使用的内置钩子：`useState`
- en: 'When using the `useState`, we encountered quite a few issues that prevented
    a newcomer     from understanding how to use it properly, mainly from the inherited laggy behavior
    due to the fact that the state value does not change right after the dispatch.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`useState`时，我们遇到了很多问题，阻止了新用户正确理解如何使用它，主要是由于继承的滞后行为，因为状态值在分发后不会立即改变。
- en: '[PRE32]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding line, if we understand the `dispatchState` function is to
    dispatch and request a change, then there''s not much we need to do because that''s
    how *React* designs the `useState`. However, most often we tend to think differently:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行，如果我们理解`dispatchState`函数是用来分发和请求更改的，那么我们不需要做太多，因为这就是*React*设计`useState`的方式。然而，我们通常倾向于有不同的想法：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding `setState` name is the main reason we push ourselves into trouble,
    because here we would expect the `state` to change right after the `setState`
    statement.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`setState`名称是我们陷入麻烦的主要原因，因为在这里我们期望`state`在`setState`语句之后立即改变。
- en: 'In [*Chapter 8*](B17963_08_Epub.xhtml#_idTextAnchor278), *Use Ref to Hide Stuff*,
    we used a `useRef` to locate the current value. There are two different ways to
    solve this problem: one is to design a container to keep pointing to the current
    value, the other is to design an access function to give us the current one when
    needed. Let''s give the second method a shot this time:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B17963_08_Epub.xhtml#_idTextAnchor278)，“使用Ref隐藏内容”，我们使用了一个`useRef`来定位当前值。解决这个问题有两种不同的方法：一种是为保持指向当前值设计一个容器，另一种是为在需要时提供一个获取当前值的访问函数。这次让我们尝试第二种方法：
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding custom `useCurrent` hook, it stores the state under a `state`
    property of an `obj`. When you need to find out the state, you can invoke `getState`
    function, and when you need to update the state, you perform `dispatch` as used
    to be. Here, we have to manage the `obj` manually, and if we find out the `newState`
    is not different than the current `obj.state`, we skip this dispatch.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的自定义`useCurrent`钩子中，它将状态存储在`obj`的`state`属性下。当你需要找出状态时，你可以调用`getState`函数，当你需要更新状态时，你执行`dispatch`，就像以前一样。在这里，我们必须手动管理`obj`，如果我们发现`newState`与当前的`obj.state`没有不同，我们就跳过这个分发。
- en: Usages
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用法
- en: 'Let''s give it a spin for our 3-second-delayed clicks example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的3秒延迟点击示例试一试：
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding code shows that this time, the code is simplified a bit since
    we don't need a ref to track the current value. Instead, we use a custom `useCurrent`
    to manage the state. The big difference is that anytime we need to find out the
    `count`, we need to invoke `getCount` returned from the hook. The plus side is
    that we don't have to always wonder what the current `count` is anymore.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示，这次代码简化了一些，因为我们不需要引用（ref）来跟踪当前值。相反，我们使用自定义的`useCurrent`来管理状态。最大的不同之处在于，每次我们需要找出`count`时，我们需要调用从钩子返回的`getCount`。好处是我们不再需要总是想知道当前的`count`是什么了。
- en: Playground – Current State with useCurrent
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 使用`useCurrent`的当前状态
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/VwzrvBX](https://codepen.io/windmaomao/pen/VwzrvBX).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎尝试这个在线示例：[https://codepen.io/windmaomao/pen/VwzrvBX](https://codepen.io/windmaomao/pen/VwzrvBX)。
- en: References
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Check these links out to see how people approach this problem from different
    angles:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这些链接，了解人们从不同角度如何解决这个问题：
- en: 'Use Ref State: [https://scastiel.dev/posts/2019-02-19-react-hooks-get-current-state-back-to-the-future/.](https://scastiel.dev/posts/2019-02-19-react-hooks-get-current-state-back-to-the-future/'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用引用状态：[https://scastiel.dev/posts/2019-02-19-react-hooks-get-current-state-back-to-the-future/](https://scastiel.dev/posts/2019-02-19-react-hooks-get-current-state-back-to-the-future/)
- en: )
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '`useStateRef`: [https://github.com/Aminadav/react-useStateRef](https://github.com/Aminadav/react-useStateRef)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useStateRef`: [https://github.com/Aminadav/react-useStateRef](https://github.com/Aminadav/react-useStateRef)'
- en: '`useRefState`: [https://github.com/alex-cory/urs](https://github.com/alex-cory/urs).'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useRefState`: [https://github.com/alex-cory/urs](https://github.com/alex-cory/urs).'
- en: "Use Safe State: [https://ahooks.js.org/hooks/advanced/use-safe-state/](https://ahooks.js.org/hooks/advanc\uFEFF\
    ed/use-safe-state/). This implements a safe state."
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用安全状态：[https://ahooks.js.org/hooks/advanced/use-safe-state/](https://ahooks.js.org/hooks/advanced/use-safe-state/).
    这实现了安全状态。
- en: useProxy
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useProxy
- en: 'Built-in hooks used in this custom hook: `useState`, `useEffect`, and `useRef`'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在此自定义钩子中使用的内置钩子：`useState`、`useEffect`和`useRef`
- en: 'The thinking behind either fixing or improving the *React* state never ends.
    One cool idea originates from the question "why can''t we just do a plain assignment
    for states instead of using the dispatch approach?" One of the technical issues
    blocking us is that the assignment can''t be done unless there''s an object or
    something to hold the state. So, if we were to allow the storing of properties
    under an object like so:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复或改进*React*状态背后的思考永无止境。一个有趣的想法来自这个问题：“为什么我们不能直接对状态进行普通的赋值，而不是使用分发方法？”阻碍我们的一个技术问题是我们不能在没有对象或某些东西来保存状态的情况下进行赋值。因此，如果我们允许在类似以下方式的对象下存储属性：
- en: '[PRE36]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then we could turn a dispatch into an assignment like the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将一个分发（dispatch）转换为一个如下所示的赋值（assignment）：
- en: '[PRE37]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s take a look at how we can design such things with the help of the *Proxy*
    introduced by *ES6*:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何借助*ES6*引入的*Proxy*来设计这样的东西：
- en: '[PRE38]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding custom `useProxy` hook takes a similar approach as the `useCurrent`
    hook and stores the `initialObj` into a state but at the same time creates another
    special object with the Proxy. Without going into too much detail about the Proxy
    usage, the special object basically captures the moment of reading and writing
    any property into two function calls, `get` and `set`. Here, we don''t really
    care about the `get` so it reverts to the default behavior, whereas the `set`
    overrides the default behavior with a new version:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 上述自定义`useProxy`钩子采用了与`useCurrent`钩子类似的方法，将`initialObj`存储到状态中，但同时也创建了一个带有Proxy的特殊对象。不深入探讨Proxy的使用细节，这个特殊对象基本上捕捉了读取和写入任何属性的读写时刻，通过两个函数调用，`get`和`set`。在这里，我们并不关心`get`，所以它回退到默认行为，而`set`则用新版本覆盖了默认行为：
- en: '[PRE39]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding code gets invoked for any statement like `obj.prop = value`. The
    implementation is quite similar to that of the `getCurrent` hook, where it checks
    if the new `value` is any different than the stored `obj[prop]` and makes a dispatch
    if that's the case.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码会在任何类似 `obj.prop = value` 的语句中被调用。其实现与 `getCurrent` 钩子非常相似，它会检查新的 `value`
    是否与存储的 `obj[prop]` 不同，并在必要时进行分派。
- en: 'Since we are tracking a couple of states under the properties with an object,
    it''s worthwhile adding a `mountRef` flag in case things go wrong after the component
    is dismounted:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在跟踪对象属性下的几个状态，因此添加一个 `mountRef` 标志以防组件卸载后出现问题是有意义的：
- en: '[PRE40]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Given a `mountRef`, we can modify the `set` to disable it to avoid a memory
    leak:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个 `mountRef`，我们可以修改 `set` 来禁用它以避免内存泄漏：
- en: '[PRE41]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Okay, with all these features built, let's put them together and give them a
    spin.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，有了所有这些功能，让我们将它们组合起来并试一试。
- en: Usages
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用法
- en: 'The `useProxy` hook is a lot more powerful , but it requires you to put all
    values under an object and it can be really useful especially for form handling:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`useProxy` 钩子功能更强大，但它要求你将所有值放在一个对象下，这对于表单处理特别有用：'
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the preceding `Form` component, we define a `form` object to hold two states,
    `count` and `text`. Let''s first take a look how we can increment a number now:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `Form` 组件中，我们定义了一个 `form` 对象来保存两个状态，`count` 和 `text`。让我们先看看我们如何现在增加一个数字：
- en: '[PRE43]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the preceding code, the count is displayed from `form.count`, but when it
    comes to incrementing it, we simply do `++form.count`. Essentially, this is equivalent
    to either of the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，计数是从 `form.count` 显示的，但在增加它时，我们只需简单地做 `++form.count`。本质上，这相当于以下任何一个：
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: From the usage experience, we don't have to remember what a dispatch is; all
    we need to do is a plain assignment. The custom `useProxy` hook takes care of
    the dispatch for us.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 从使用体验来看，我们不需要记住什么是分派；我们只需要进行一个普通的赋值。自定义的 `useProxy` 钩子会为我们处理分派。
- en: 'There''s another advantage coming from this custom hook, that is, from now
    on, both `set` and `get` are done through the same object, `form`. This means
    if we need to ask a child to handle one form element, we do not have to send two
    pieces as we normally do. Let''s take a look at one example with the other `text`
    state:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自定义钩子带来的另一个优点是，从现在起，`set` 和 `get` 都是通过同一个对象 `form` 完成的。这意味着如果我们需要让子组件处理一个表单元素，我们就不需要像通常那样发送两个部分。让我们看看另一个使用其他
    `text` 状态的例子：
- en: '[PRE45]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the preceding example, we define a `Text` component to handle the text input.
    Notice we only need to send the `form` through a prop. And inside the `Text` component,
    both the display and assignment of this text are managed via `form.text`. Crazily
    handy, isn't it?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了一个 `Text` 组件来处理文本输入。注意我们只需要通过属性传递 `form`。在 `Text` 组件内部，文本的显示和赋值都是通过
    `form.text` 管理的。非常方便，不是吗？
- en: Playground – Form with useProxy
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏场 – 使用 useProxy
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/eYEeZmL](https://codepen.io/windmaomao/pen/eYEeZmL).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎在 [https://codepen.io/windmaomao/pen/eYEeZmL](https://codepen.io/windmaomao/pen/eYEeZmL)
    上尝试这个在线示例。
- en: The `useProxy` hook does ask us to use an object to manage states, but once
    you are onboard with this approach, you might feel more like coding normally without
    the *React* state hassle.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`useProxy` 钩子确实要求我们使用一个对象来管理状态，但一旦你接受了这种方法，你可能会觉得像平常一样编码，而无需处理 *React* 状态的麻烦。'
- en: References
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考
- en: 'Valtio: [https://github.com/pmndrs/valtio](https://github.com/pmndrs/valtio)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Valtio：[https://github.com/pmndrs/valtio](https://github.com/pmndrs/valtio)
- en: 'Use State Proxy: [https://github.com/beenotung/use-state-proxy](https://github.com/beenotung/use-state-proxy)'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态代理：[https://github.com/beenotung/use-state-proxy](https://github.com/beenotung/use-state-proxy)
- en: 'Proxy States: [https://github.com/windmaomao/proxy-state](https://github.com/windmaomao/proxy-state)'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理状态：[https://github.com/windmaomao/proxy-state](https://github.com/windmaomao/proxy-state)
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we summarized all the *React* built-in hooks that we've introduced
    so far and then went on to how to create a custom hook. Then, once we understood
    the concept, we went over all the code we wrote in this book and turned some of
    it into custom hooks, including `useToggle`, `useWindow`, `useAsync`, `useDebounced`,
    `useClickOutside`, `useCurrent`, and `useProxy`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们总结了迄今为止我们介绍的所有 *React* 内置钩子，然后继续介绍如何创建自定义钩子。然后，一旦我们理解了这个概念，我们就回顾了本书中编写的所有代码，并将其中一些转换成了自定义钩子，包括
    `useToggle`、`useWindow`、`useAsync`、`useDebounced`、`useClickOutside`、`useCurrent`
    和 `useProxy`。
- en: In the next chapter, we will get to know how *React* pulls together all different
    types of web resources and orchestrates them to build a website.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解 *React* 如何将所有不同类型的网络资源整合起来，并协调它们来构建一个网站。
- en: Questions and answers
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问答
- en: 'Here are some questions and answers to refresh your knowledge:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些问答来帮助你巩固知识：
- en: What are *React* built-in hooks?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 *React* 内置钩子？
- en: '*React* built-in hooks refers to all hooks designed by *React*, including `useState`,
    `useEffect`, and so on. You can''t create a built-in hook on the fly, but you
    can contribute your idea and send a pull request to the *React* core team to review.'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*React* 内置钩子指的是由 *React* 设计的所有钩子，包括 `useState`、`useEffect` 等等。你无法即时创建一个内置钩子，但你可以提出你的想法并向
    *React* 核心团队发送拉取请求以供审查。'
- en: What is a custom hook?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是自定义钩子？
- en: We can create a custom hook by consuming one of the *React* built-in hooks and
    giving the hook name prefixed with `use`. A custom hook can be as powerful as
    a built-in hook. The purpose of the built-in hook is to address atomic core capability
    whereas the custom hook is normally created to address practical project problems.
    There're hundreds of custom hooks on the internet you might find useful or inspiring.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过消耗一个 *React* 内置钩子并给钩子命名时以 `use` 为前缀来创建一个自定义钩子。自定义钩子可以像内置钩子一样强大。内置钩子的目的是解决原子核心能力，而自定义钩子通常是为了解决实际项目问题而创建的。互联网上有数百个自定义钩子可能对你有用或具有启发性。
- en: What's the best practice for creating a hook?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建钩子的最佳实践是什么？
- en: A custom hook can be, and most times is, created naturally out of the code refactoring
    process. As long as you feel a bundle of code can be reused involving a hook,
    that's the time you can extract those functionalities out and make it generic
    to be referenced by other parts of the project. In a way, you can think of a custom
    hook as a utility function, except it involves a built-in hook.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自定义钩子可以是，并且大多数情况下是，在代码重构过程中自然产生的。只要你觉得一束代码可以包含钩子并被复用，那么你就可以提取这些功能并使其通用，以便其他项目部分可以引用。从某种意义上说，你可以将自定义钩子视为一个实用函数，只不过它涉及内置钩子。
