# 10

# 构建微前端时需要避免的常见陷阱

我们已经走了很长的路！我们已经学会了如何构建微前端，如何将它们部署到原生云，以及如何在生产中管理它们。

当我们开始使用微前端时，我们将会犯错误，但我们会从错误中学习，并最终建立我们自己的最佳实践集，发现对我们用例最有效的方法。然而，从他人的错误中学习始终是一个明智的选择。在本章中，我们将介绍早期团队在处理微前端时遇到的一些陷阱。

我们将教你一些常见的陷阱以及如何避免它们，如下所述：

+   不要让你的微应用太小

+   避免过度使用常见的共享代码/库

+   避免在微前端中使用多个框架

+   无法部署单个微应用

+   过度依赖状态

+   避免在构建时编译来组装微前端

+   避免将微应用打包到 NPM 包中

到本章结束时，你将了解到开发者从单页应用过渡到微前端时可能会陷入的各种陷阱。

# 不要让你的微应用太小

我们在本书的开头提到了这一点，但重要的是再次强调。太多的开发者认为，在微前端架构中，微应用需要非常小。这并不正确，因为创建非常小的微应用会大大增加复杂性和维护难题，而不会带来任何好处。

在尝试确定你的微应用合适的尺寸时，我们发现考虑以下因素是有帮助的：

1.  这是否是可以独立存在的可能最大的微应用？

1.  这是否是单个敏捷 Scrum 团队拥有的可能最大的微应用？

1.  这个应用是否经历了与其他应用不同步的速度的变化和更新？

1.  另一个需要考虑的点是基于领域驱动设计原则，从领域角度思考，以确定一个特定的微应用应该支持或不应支持哪些业务功能。

如果你对所有前面的问题的回答都是肯定的，那么微应用的尺寸是合适的。如果对任何一个问题的回答是否定的，那么要么是我们没有正确地分解微应用，要么是微前端可能不是正确的架构选择。

另一个帮助确定应用合适尺寸的指南是查看原子设计模式（[`bradfrost.com/blog/post/atomic-web-design/`](https://bradfrost.com/blog/post/atomic-web-design/)），它定义了组件在应用中的结构。

![图 10.1 – 生命体和模板可以被转换为微应用](img/Figure_10.01_B18987.jpg)

图 10.1 – 生命体和模板可以被转换为微应用

如果您查看*图 10.1*中的原子设计模式，将您的应用程序分解成微应用的理想级别将是生物体级别或模板级别；其他任何级别都可能是太小或太大。

将应用程序分解成适当大小的微应用是构建高性能和可扩展的微前端架构的关键，而且投入更多时间来确保这一点，随着我们向前发展，将会带来巨大的回报。

# 避免过度使用共享组件代码

当涉及到构建微服务或微前端时，团队独立性是最高的优先级。任何使一个团队依赖另一个团队的事情都应该被强烈反对。

在我们作为软件开发者的经验中，我们始终会遇到诸如**可重用性**、**不要重复自己**（**DRY**）等原则。事实上，大多数高级开发者都在不断寻找如何创建通用工具、辅助共享组件等，以帮助团队提高生产力。

然而，当涉及到微服务和微前端的世界时，过度使用这些共享库可能导致所谓的“依赖地狱”或“分布式单体”，这是两种情况的糟糕结合。

这对微前端来说很不利，因为使用共享库或代码立即剥夺了团队的独立性，因为现在两个或更多团队需要依赖对这个共享库的更新或错误修复，才能继续前进。

随着越来越多的团队开始使用共享库，它往往会变得越来越大，因为它现在需要适应不同团队的使用案例。此外，还存在一个持续的风险，即对这个共享代码的更改或更新可能会破坏一个或多个团队的功能。

因此，当涉及到微前端时，我们需要严格避免陷入这个陷阱。作为一个经验法则，我们应该避免创建任何业务或应用程序逻辑作为共享通用代码。一个理想上可以在微应用之间共享的项目是 UI 组件库，因为我们希望确保所有微应用都有一致的外观和感觉。另一个可以放入共享库的项目是任何不包含业务逻辑的低级实用函数。这些示例包括 HTTP 客户端、错误处理实用工具或其他用于格式化日期或操作字符串的实用工具。

记住，在单仓库中，与处理分布式单体的挑战相比，“查找和替换”要容易得多。

虽然最初将团队独立性优先于代码重用的整个想法可能听起来像是一种反模式，并不是一个明智的做法，但从经验来看，这是您希望团队快速行动并频繁将代码部署到生产环境时需要牢记的第二个重要点。

# 避免在微前端中使用多个框架

微前端的一个好处是，从技术上讲，每个应用都可以使用不同的框架构建。然而，尽管这是可能的，但这并不意味着你必须这样做。在单个微前端中使用多个框架存在许多缺点：

+   随着团队成员可能随着时间的推移从一个团队切换到另一个团队，认知负荷非常高。

+   由于每个框架都附带自己的 JavaScript 包，并且每个框架都将使用不同的 NPM 模块集，因此传输到用户设备上的 JavaScript 代码量将很高。因此，我们无法充分利用浏览器缓存或服务工作者缓存，因为每个应用都使用自己的包。

+   不同的框架将面临不同的性能挑战和问题，每个团队都必须单独处理这些问题，而无法利用更广泛团队中的集体知识。

话虽如此，在评估新框架或逐步升级到新版本时，拥有多个框架或它们的多个版本作为短暂的过渡阶段是可以接受的。总的来说，将多个框架作为架构原则应该避免。

# 无法部署单个微应用

采用微前端架构的一个主要原因是允许应用程序的某些部分独立更新，而不会影响其余部分。

这显然意味着我们需要有能力独立构建和部署每个微应用。如果你的 DevOps 构建和发布管道无法做到这一点，那么选择**单页应用**（**SPA**）架构会更好。

在过去，许多 DevOps 工具还不够成熟，无法与 monorepos 或 microfrontends 协同工作；然而，大多数最新的工具都配备了更好的功能，能够检测哪些文件夹已更改，并且只触发必要的应用构建。

因此，当你在微前端架构上工作时，至关重要的是你必须彻底思考，包括它的部署方式，因为这会影响你为 DevOps 管道或 monorepo 选择的工具。

例如，如果你的 DevOps 管道可以根据哪个微应用已更改进行条件触发，那么你可以自由选择任何 monorepo 工具。

然而，如果你的 DevOps 管道无法检测到更改，或者你被限制为为所有微前端使用单个管道，那么选择具有内置更改检测功能的单仓库工具，如 Nx，将更为合适。

# 过度依赖状态

随着 React 的出现，状态管理成为了一件事，随之而来的是像 Redux 这样的工具的流行，这些工具提倡使用单一中央数据存储来管理状态。随着时间的推移，开发者似乎对状态管理变得着迷，过度依赖这些状态管理库。当开发者从 SPA 转向微前端时，他们继续对状态着迷，花费大量时间尝试持久化状态，使其在不同的微应用之间工作。在 SPA 和微前端中，重要的是要谨慎使用这些应用级状态。在处理微前端时，我们鼓励探索 Pub/Sub 或事件发射器方法等概念，以在不同的微应用之间共享数据。或者，可以考虑使用原生的浏览器数据存储，如会话存储、IndexedDB 或本地存储来管理持久状态，或者如果这些都不适用，那么可以探索轻量级的状态管理库，如 Zustand 或 React 的 Context API。

如您现在可能已经意识到的，在构建微前端时，涉及相当多的重新学习和学习，尤其是如果您已经构建了很长时间的 SPA。在微前端中使用状态管理是需要理解和掌握的，也是一些开发者偶尔必须应对的最困难的变化，尤其是那些习惯了过度依赖状态的开发者。

# 避免在构建时间编译以组装微前端

前端社区中目前有一个趋势，即将尽可能多的任务移动到应用程序编译的构建时间阶段，而不是运行时。这些例子包括静态站点生成，其中 HTML 页面是在构建时生成的，或者在 Angular 中的**提前编译**（**AoT**），这可以提高应用程序的整体性能。

虽然，总的来说，构建时间编译是一种良好的实践，可以在运行时阶段减少浏览器和 JavaScript 引擎的负载，但在组装微前端时并没有帮助。这是因为每次任何微前端发生变化时，都需要重新构建组装层，这违背了独立微应用部署的原则。

我们可以选择让单个微应用在构建时间做更多的工作（例如，生成静态页面），但微应用或模块联邦的组装始终应该在服务器或运行时进行。

这是需要记住的另一个关键点，以确保我们不会盲目跟随“流行趋势”。始终记住您架构模式的关键原则，并且您已经全面思考了您的模式，从端到端，一直到它如何部署到生产环境。

# 避免将微应用打包进 NPM 包

在单页应用（SPA）的世界中，另一个常见的趋势是将任何可共享的模块转换为 NPM 包，以便更容易地分发，然后将其导入到其他应用中。

根据我们的经验，我们见过一些团队在将微应用程序打包和版本化为 NPM 模块后，再将其导入到宿主或组装应用程序中。我们强烈反对这种做法，主要原因在于每次发布一个新的微应用程序版本作为 npm 模块时，所有使用该微应用程序的宿主都需要更新他们的`package.json`文件，并重新构建和重新部署他们的应用程序，这违背了独立部署的基本原则。我们已在*第二章*“微前端的关键原则和组件”中的“*偏好运行时*集成”部分对此进行了详细说明。

# 摘要

有了这些，我们就来到了本章的结尾。作为一个相对较新的架构模式，微前端的概念和最佳实践正在不断演变。

在本章中，我们看到了一些团队在构建微前端时常见的陷阱——例如，无法确定将应用程序拆分为微应用程序的正确层级，过度使用状态管理库，在微应用程序中使用多个框架，无法单独部署微应用程序，过度使用共享通用代码，以及最终导致构建时集成。希望本章能帮助你避免重蹈覆辙，你的同行在过去犯过的错误。

另一个需要记住的重要点是理解这些最佳实践背后的原因，通过你具体用例的视角来看待它们。遵循适用于你用例的最佳实践，并调整那些不太适合的实践。

正如那句著名的话所说，“*对于每一个架构问题，答案都是…* *视具体情况而定*”

在下一章中，我们将探讨微前端世界中的一些新兴趋势，这些趋势是你应该关注的。
