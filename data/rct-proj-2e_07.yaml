- en: '*Chapter 7*: Building a Full-Stack E-Commerce Application with Next.js and
    GraphQL'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 7 章*：使用 Next.js 和 GraphQL 构建全栈电商应用'
- en: If you're reading this, this means you've reached the last chapter of this book
    that is focused on building web applications with React. In the preceding chapters,
    you've already used the core features of React, such as rendering components,
    state management with Context, and Hooks. You've learned how to add routing to
    your React application, or SSR with Next.js. Also, you know how to add testing
    to a React application with Jest and Enzyme. Let's make this experience full stack
    by adding GraphQL to the list of things you've learned about so far.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读此内容，这意味着你已经到达了本书的最后一章，该章节专注于使用 React 构建网络应用。在前面的章节中，你已经使用了 React 的核心功能，例如渲染组件、使用
    Context 和 Hooks 进行状态管理。你已经学习了如何为你的 React 应用添加路由或使用 Next.js 进行 SSR。此外，你还知道如何使用
    Jest 和 Enzyme 为 React 应用添加测试。让我们通过添加 GraphQL 到你迄今为止所学的内容列表中，使这次体验成为全栈的。
- en: In this chapter, you will not only build the frontend of an application, but
    also the backend. For this, GraphQL will be used, which can best be defined as
    a query language for APIs. Using mock data, you'll create a GraphQL server in
    Next.js that exposes a single endpoint for your React application. On the frontend
    side, this endpoint will be consumed using Apollo Client, which helps you handle
    sending requests to the server and state management for this data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你不仅将构建应用的前端，还将构建后端。为此，我们将使用 GraphQL，它最好被定义为一个针对 API 的查询语言。使用模拟数据，你将在 Next.js
    中创建一个 GraphQL 服务器，该服务器为你的 React 应用提供了一个端点。在前端方面，这个端点将通过 Apollo Client 进行消费，它帮助你处理向服务器发送请求以及对此数据的状态管理。
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将涵盖以下主题：
- en: Creating a GraphQL server with Next.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Next.js 创建 GraphQL 服务器
- en: Consuming GraphQL with Apollo Client
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Apollo Client 消费 GraphQL
- en: Handling authentication in GraphQL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GraphQL 中处理身份验证
- en: Project overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, we will create a full stack e-commerce application in Next.js
    that has a GraphQL server as a backend and consumes this server in React using
    Apollo Client. For the frontend, an initial application is available to get you
    started quickly.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Next.js 创建一个全栈电商应用，该应用的后端是一个 GraphQL 服务器，并通过 Apollo Client 在 React
    中消费这个服务器。对于前端，有一个初始应用可供快速入门。
- en: The build time is 3 hours.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 构建时间为 3 小时。
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'The project that we''ll create in this chapter builds upon an initial version
    that you can find on GitHub: [https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter07-initial](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter07-initial).
    The complete source code can also be found on GitHub: [https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter07).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将创建的项目基于你可以在 GitHub 上找到的初始版本：[https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter07-initial](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter07-initial)。完整的源代码也可以在
    GitHub 上找到：[https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter07)。
- en: 'The initial project consists of a boilerplate application based on Next.js
    to get you started quickly. This application requires the installation of several
    dependencies, which you can do by running the following commands:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 初始项目基于 Next.js 的样板应用，旨在快速入门。此应用需要安装几个依赖项，你可以通过运行以下命令来完成：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command will install all the dependencies that are needed to run the React
    application with Next.js, such as `react`, `next`, and `styled-components`. Once
    the installation process has finished, both the GraphQL server and the React application
    will be started.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将安装运行 Next.js 上的 React 应用所需的全部依赖，例如 `react`、`next` 和 `styled-components`。一旦安装过程完成，GraphQL
    服务器和 React 应用都将启动。
- en: Getting started with the initial React application
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用初始 React 应用入门
- en: 'Since the React application is created with Next.js, it can be started with
    `npm run dev` and will be available at `http://localhost:3000/`. This initial
    application doesn''t show any data as it still needs to be connected to the GraphQL
    server, which you''ll do later in this chapter. At this point, the application
    will, therefore, just render a header with the title **E-Commerce Store** and
    a subheader as well, which looks something like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该 React 应用程序是用 Next.js 创建的，因此可以使用 `npm run dev` 启动，并在 `http://localhost:3000/`
    上可用。这个初始应用程序不显示任何数据，因为它还需要连接到 GraphQL 服务器，您将在本章的后面完成这项工作。因此，此时应用程序将仅渲染一个标题为 **E-Commerce
    Store** 的页眉以及一个副标题，看起来大致如下：
- en: ':'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ':'
- en: '![Figure 7.1 – The initial application'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 – 初始应用程序'
- en: '](img/Figure_7.1_B17390.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.1_B17390.jpg)'
- en: Figure 7.1 – The initial application
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 初始应用程序
- en: 'The structure of this initial React application built with Next.js is as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Next.js 构建的此初始 React 应用程序的结构如下：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the `pages` directory, you'll find all the routes for this application. The
    route `/` is rendered by `pages/index.js`, and the routes `/cart`, `/login`, and
    `/products` are rendered by the `.js` files in those respective directories. All
    routes will be wrapped within `pages/_app.js`. In this file, the header for all
    pages is constructed for example. All routes will also contain a `SubHeader` component,
    with a `Button` to go back to the previous page or a `Button` to the `Cart` component.
    The `utils` directory contains two files with methods that you'll be needing later
    in this chapter. Also, this application will have a REST endpoint available under
    `http://localhost:3000/api/hello` coming from the `pages/api/hello.js` file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `pages` 目录中，您可以找到此应用程序的所有路由。路由 `/` 由 `pages/index.js` 渲染，而路由 `/cart`、`/login`
    和 `/products` 由相应目录中的 `.js` 文件渲染。所有路由都将包含在 `pages/_app.js` 中。在这个文件中，构建了所有页面的页眉。所有路由也将包含一个
    `SubHeader` 组件，以及一个 `Button` 用于返回上一页或一个 `Button` 用于 `Cart` 组件。`utils` 目录包含两个文件，其中包含您在本章后面需要使用的方法。此外，此应用程序将在
    `http://localhost:3000/api/hello` 下提供一个 REST 端点，该端点来自 `pages/api/hello.js` 文件。
- en: Building a full stack e-commerce application with React, Apollo, and GraphQL
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React、Apollo 和 GraphQL 构建全栈电子商务应用程序
- en: In this section, you'll connect the React web application to the GraphQL server.
    A GraphQL Server on a Next.js API Route is used to create a single GraphQL endpoint
    that uses dynamic mock data as a source. Apollo Client is used by React to consume
    this endpoint and handle state management for your application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将连接 React 网络应用程序到 GraphQL 服务器。Next.js API 路由上的 GraphQL 服务器用于创建一个使用动态模拟数据作为源的单一
    GraphQL 端点。React 使用 Apollo Client 消费此端点并处理应用程序的状态管理。
- en: Creating a GraphQL server with Next.js
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Next.js 创建 GraphQL 服务器
- en: 'In [*Chapter 3*](B17390_03_Final_NM_ePub.xhtml#_idTextAnchor039), *Building
    a Dynamic Project Management Board*, we already created a React application with
    Next.js, in which it was already mentioned that you can also use it to create
    API endpoints. By looking at the files in our directory for this chapter, you
    can see that the `pages` directory contains a directory called `api` with a file
    called `hello.js`. All the directories and files that you create in the `pages`
    directory become available as a route in the browser, but if you create them under
    the `api` directory in `pages`, they are called API routes. The `hello.js` file
    is such an API route, which is available under `http://localhost:3000/api/hello`.
    This endpoint returns a JSON blob with the following contents:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 3 章*](B17390_03_Final_NM_ePub.xhtml#_idTextAnchor039) 中，*构建动态项目管理板*，我们已经使用
    Next.js 创建了一个 React 应用程序，其中已经提到您也可以用它来创建 API 端点。通过查看本章目录中的文件，您可以看到 `pages` 目录中有一个名为
    `api` 的目录，其中包含一个名为 `hello.js` 的文件。您在 `pages` 目录中创建的所有目录和文件都将作为浏览器中的路由可用，但如果您在
    `pages` 目录下的 `api` 目录中创建它们，它们被称为 API 路由。`hello.js` 文件就是这样一条 API 路由，它位于 `http://localhost:3000/api/hello`
    下。此端点返回一个包含以下内容的 JSON 块：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a REST endpoint, which we've also explored in the previous chapters
    of this book. In this chapter, we'll be using a GraphQL endpoint instead, as GraphQL
    is a popular format for APIs that are used by web and mobile applications.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 REST 端点，我们也在本书的前几章中进行了探索。在本章中，我们将使用 GraphQL 端点，因为 GraphQL 是 Web 和移动应用程序使用的
    API 的流行格式。
- en: GraphQL is best described as a query language for APIs and is defined as a convention
    for retrieving data from an API. Often, GraphQL APIs are compared to RESTful APIs,
    which is a well-known convention for sending HTTP requests that are dependent
    on multiple endpoints that will all return a separate data collection. As opposed
    to the well-known RESTful APIs, a GraphQL API will provide a single endpoint that
    lets you query and/or mutate data sources such as a database. You can query or
    mutate data by sending a document containing either a query or mutation operation
    to the GraphQL server. Whatever data is available can be found in the schema of
    the GraphQL server, which consists of types that define what data can be queried
    or mutated.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL最好描述为API的查询语言，它被定义为从API检索数据的一种约定。通常，GraphQL API与RESTful API相比较，后者是发送依赖于多个端点的HTTP请求的一种知名约定，这些端点将返回各自的数据集合。与知名的RESTful
    API相反，GraphQL API将提供一个单一端点，允许您查询和/或突变数据源，如数据库。您可以通过向GraphQL服务器发送包含查询或突变操作的文档来查询或突变数据。无论什么数据可用，都可以在GraphQL服务器的模式中找到，该模式由定义可以查询或突变的数据的类型组成。
- en: 'Before creating the GraphQL endpoint, we need to set up the server in Next.js.
    Therefore, we need to install the following dependencies that are needed to do
    so:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建GraphQL端点之前，我们需要在Next.js中设置服务器。因此，我们需要安装以下依赖项，这些依赖项是设置所必需的：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `graphql` library is needed to use GraphQL in our application, while `express-graphql`
    is a tiny implementation of GraphQL Server for Node.js. Both `@graphql-tools/schema`
    and `@graphql-tools/mock` are open source libraries that helps you create GraphQL
    servers. We can also delete the `pages/api/hello.js` file as we won't be using
    this API route.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中使用GraphQL需要`graphql`库，而`express-graphql`是Node.js的GraphQL服务器的一个小型实现。`@graphql-tools/schema`和`@graphql-tools/mock`都是开源库，可以帮助您创建GraphQL服务器。我们还可以删除`pages/api/hello.js`文件，因为我们不会使用这个API路由。
- en: 'To set up the GraphQL server, we must create a new file, `pages/api/graphql/index.js`,
    that will contain the single GraphQL endpoint for our application. We need to
    import `graphqlHTTP` to create the server. The schema for the GraphQL server is
    written under a variable called `typeDefs`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置GraphQL服务器，我们必须创建一个新的文件，`pages/api/graphql/index.js`，它将包含我们应用程序的单个GraphQL端点。我们需要导入`graphqlHTTP`来创建服务器。GraphQL服务器的模式是在名为`typeDefs`的变量下编写的：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Below the schema, we can initiate the GraphQL server using the `graphqlHTTP`
    instance and pass the schema to it. We also configure the server to create mocks
    for all the values in our schema. At the bottom of the file, we return the `handler`
    that is used by Next.js to make the GraphQL server available at the route `http://localhost:3000/api/graphql`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在模式下方，我们可以使用`graphqlHTTP`实例启动GraphQL服务器，并将模式传递给它。我们还配置服务器为我们的模式中的所有值创建模拟。在文件底部，我们返回`handler`，这是Next.js用来在路由`http://localhost:3000/api/graphql`上使GraphQL服务器可用的：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After making sure you've run the application again, the GraphQL API becomes
    available on `http://localhost:3000/api/graphql`. On this page in the browser,
    the GraphiQL playground will be displayed, and here is where you can use and explore
    the GraphQL server.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 确保再次运行应用程序后，GraphQL API在`http://localhost:3000/api/graphql`上可用。在浏览器页面上，GraphiQL游乐场将显示，这里您可以使用和探索GraphQL服务器。
- en: With this playground, you can send queries and mutations to the GraphQL server,
    which you can type on the left-hand side of this page. The queries and mutations
    that you're able to send can be found in **DOCS** for this GraphQL server, which
    you can find by clicking on the green button labeled **DOCS**. This button will
    open an overview with all the possible return values of the GraphQL server.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个游乐场，您可以向GraphQL服务器发送查询和突变，这些可以在页面的左侧键入。您可以发送的查询和突变可以在该GraphQL服务器的**文档**中找到，您可以通过点击标记为**文档**的绿色按钮来查找。此按钮将打开一个概述，其中包含GraphQL服务器所有可能的返回值。
- en: '![Figure 7.2 – Using the GraphiQL playground'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 – 使用GraphiQL游乐场'
- en: '](img/Figure_7.2_B17390.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.2_B17390.jpg)'
- en: Figure 7.2 – Using the GraphiQL playground
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 使用GraphiQL游乐场
- en: 'Whenever you describe a query or mutation on the left-hand side of this page,
    the output that is returned by the server will be displayed on the right-hand
    side of the playground. The way a GraphQL query is constructed will determine
    the structure of the returned data since GraphQL follows the principle of *ask
    for what you need, get exactly that*. Since GraphQL queries always return predictable
    results, we can have a query that looks like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在此页面的左侧描述查询或突变时，服务器返回的输出将在演示场的右侧显示。GraphQL 查询的构建方式将决定返回数据的结构，因为 GraphQL 遵循
    *需要什么，就得到什么* 的原则。由于 GraphQL 查询总是返回可预测的结果，我们可以有一个如下所示的查询：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will return an output that will follow the same structure of the query
    that''s defined in the document that you sent to the GraphQL server. Sending this
    document with a query to the GraphQL server will return an array consisting of
    objects with product information, which has a limit of 10 products by default.
    The result will be returned in JSON format and will consist of different products
    every time you send the requests since the data is mocked by the GraphQL server.
    The response has the following format:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个输出，其结构将与您发送到 GraphQL 服务器的文档中定义的查询结构相同。将此文档与查询一起发送到 GraphQL 服务器将返回一个对象数组，其中包含产品信息，默认情况下限制为
    10 个产品。结果将以 JSON 格式返回，并且每次发送请求时都会包含不同的产品，因为数据是由 GraphQL 服务器模拟的。响应格式如下：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Applications using GraphQL are often fast and stable because they control the
    data they get, not the server. With GraphQL we can also create relations between
    certain fields in our data, for example, by adding a category field to our products.
    This is done by adding the following to the GraphQL schema in `pages/api/graphql/index.js`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GraphQL 的应用程序通常快速且稳定，因为它们控制着获取的数据，而不是服务器。使用 GraphQL，我们还可以在我们的数据中创建某些字段之间的关系，例如，通过在我们的产品中添加一个类别字段。这是通过在
    `pages/api/graphql/index.js` 中的 GraphQL 模式中添加以下内容来完成的：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And we can also add a query for `type Category` by adding it to the schema:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过将其添加到模式中来添加对 `type Category` 的查询：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The products will now have a new field called `category`, but you can also
    query a list of categories on its own. As all the data for the GraphQL server
    is currently mocked, you don''t need to connect a data source that makes the category
    information available. But we can specify how certain fields should be mocked,
    for example, by adding a thumbnail to our products. Therefore, we need to create
    a variable called `mocks` that sets the field thumbnail on the `Product` type
    to be a URL to [https://picsum.photos](https://picsum.photos). This is a free
    server for generating mock images on the fly:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 产品现在将有一个名为 `category` 的新字段，但您也可以单独查询类别列表。由于 GraphQL 服务器的所有数据目前都是模拟的，您不需要连接一个提供类别信息的数据库。但我们可以指定某些字段应该如何模拟，例如，通过为我们的产品添加缩略图。因此，我们需要创建一个名为
    `mocks` 的变量，将 `Product` 类型的字段缩略图设置为指向 [https://picsum.photos](https://picsum.photos)
    的 URL。这是一个用于实时生成模拟图像的免费服务器：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In addition to mocking the `thumbnail` field on the `Product` type, we also
    want to mock all the values of fields with the `Int` or `Float` type everywhere.
    Both fields are now often negative values, which is incorrect for its usage as
    an identifier or price. The `Int` type is used to define identifiers, while the
    `Float` type is used for prices. We can also mock these by adding the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 `Product` 类型上模拟 `thumbnail` 字段外，我们还想模拟所有具有 `Int` 或 `Float` 类型的字段值。这两个字段现在通常是负值，这对其用作标识符或价格是不正确的。`Int`
    类型用于定义标识符，而 `Float` 类型用于价格。我们也可以通过添加以下内容来模拟这些字段：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can check this by trying the following query that also requests a category
    and the thumbnail for the products:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过尝试以下查询来检查此操作，该查询还请求产品的类别和缩略图：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can insert the preceding query in the GraphQL playground to get the response,
    which will look something like the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将前面的查询插入到 GraphQL 演示场中，以获取响应，其外观将类似于以下截图：
- en: '![Figure 7.3 – Sending a query to the GraphQL server'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.3 – 向 GraphQL 服务器发送查询'
- en: '](img/Figure_7.3_B17390.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.3_B17390.jpg)'
- en: Figure 7.3 – Sending a query to the GraphQL server
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 向 GraphQL 服务器发送查询
- en: As the data is mocked by the GraphQL Server, the values will change every time
    you send a new request with this query. But you can get the same response by sending
    the query in the body of an HTTP request, from either the command line or from
    a React application with `fetch`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GraphQL服务器模拟了数据，因此每次您使用此查询发送新的请求时，值都会发生变化。但您可以通过在HTTP请求的正文发送查询来获得相同的响应，无论是从命令行还是从使用`fetch`的React应用程序。
- en: You can also use a library such as Apollo Client to make this more intuitive.
    This will be explained in the next section of this chapter, where you'll connect
    the GraphQL server to the React web application using Apollo and send documents
    to the server from your application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用像Apollo Client这样的库来使这个过程更加直观。这将在本章的下一节中解释，您将使用Apollo将GraphQL服务器连接到React
    Web应用程序，并从您的应用程序向服务器发送文档。
- en: Consuming GraphQL with Apollo Client
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Apollo Client消费GraphQL
- en: With the GraphQL server in place, let's move on to the part where you make requests
    to this server from a React application. For this, you'll use Apollo packages
    that help you add an abstraction layer between your application and the server.
    That way, you don't have to worry about sending documents to the GraphQL endpoint
    yourself by using, for example, `fetch`, and can send documents directly from
    a component.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好GraphQL服务器后，让我们继续到从React应用程序向该服务器发送请求的部分。为此，您将使用Apollo包，这些包可以帮助您在应用程序和服务器之间添加一个抽象层。这样，您就不必担心自己使用例如`fetch`这样的方法将文档发送到GraphQL端点，可以直接从组件中发送文档。
- en: Setting up Apollo Client
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置Apollo Client
- en: 'As we mentioned previously, you can use Apollo to connect to the GraphQL server;
    for this, Apollo Client will be used. With Apollo Client, you can set up the connection
    with the server, handle queries and mutations, and enable caching for data that''s
    been retrieved from the GraphQL server, among other things. You can add Apollo
    Client to your application by following these steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，您可以使用Apollo连接到GraphQL服务器；为此，将使用Apollo Client。使用Apollo Client，您可以设置与服务器的连接，处理查询和突变，并为从GraphQL服务器检索的数据启用缓存，以及其他功能。您可以通过以下步骤将Apollo
    Client添加到应用程序中：
- en: 'To install Apollo Client and its related packages, you need to run the following
    command from the `client` directory where the React application is initialized:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装Apollo Client及其相关包，您需要从React应用程序初始化的`client`目录中运行以下命令：
- en: '[PRE13]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will install Apollo Client as well as the other dependencies you need to
    use Apollo Client and GraphQL in your React application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装Apollo Client以及您在React应用程序中使用Apollo Client和GraphQL所需的其他依赖项。
- en: Note
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Normally, we also need to install `graphql` when installing Apollo Client, but
    this library is already present in our application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在安装Apollo Client时，我们还需要安装`graphql`，但这个库已经存在于我们的应用程序中。
- en: 'These packages should be imported into the `pages/_app.js` file, where you
    want to create the Apollo Provider that wraps our application with the connection
    to the GraphQL server:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些包应该导入到您想要创建包含与GraphQL服务器连接的Apollo Provider的`pages/_app.js`文件中：
- en: '[PRE14]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now you can define the `client` constant using the `ApolloClient` class, and
    pass the location of the local GraphQL server to it:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以使用`ApolloClient`类来定义`client`常量，并将本地GraphQL服务器的位置传递给它：
- en: '[PRE15]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Within the `return` function for the `MyApp` component, you need to add `ApolloProvider`
    and pass the `client` you''ve just created as a prop:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MyApp`组件的`return`函数中，您需要添加`ApolloProvider`并将您刚刚创建的`client`作为属性传递：
- en: '[PRE16]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After these steps, all the components that are nested within `ApolloProvider`
    can access this `client` and send documents with queries and/or mutations to the
    GraphQL server. In Next.js, all the page components are rendered under `Component`
    based on the route. The method for getting data from `ApolloProvider` is similar
    to the context API that we've used before.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些步骤之后，所有嵌套在`ApolloProvider`内的组件都可以访问此`client`，并通过查询和/或突变将文档发送到GraphQL服务器。在Next.js中，所有页面组件都是基于路由在`Component`下渲染的。从`ApolloProvider`获取数据的方法与我们之前使用的上下文API类似。
- en: Sending GraphQL queries with React
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用React发送GraphQL查询
- en: Apollo Client doesn't only export a Provider, but also methods to consume the
    value from this Provider. That way, you can easily get any value using the client
    that was added to the Provider. One of those methods is `Query`, which helps you
    to send a document containing a query to the GraphQL server without having to
    use a `fetch` function, for example.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo Client不仅导出了一个Provider，还导出了从该Provider中消耗值的方法。这样，你可以轻松地使用添加到Provider中的客户端获取任何值。其中一种方法是`Query`，它可以帮助你发送一个包含查询的文档到GraphQL服务器，而无需使用`fetch`函数，例如。
- en: Since a `Query` component should always be nested inside an `ApolloProvider`
    component, they can be placed in any component that's been rendered within `App`.
    One of those is the `Products` component in `pages/product/index.js`. This component
    is being rendered for the `/` route and should display products that are available
    in the e-commerce store.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Query`组件应该始终嵌套在`ApolloProvider`组件内部，它们可以放置在`App`中渲染的任何组件中。其中之一是`pages/product/index.js`中的`Products`组件。该组件正在为`/`路由渲染，应显示电子商务店中可用的产品。
- en: 'To send a document from the `Products` component, follow these steps, which
    will guide you in the process of sending documents using `react-apollo`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`Products`组件发送文档，请按照以下步骤操作，这将指导你使用`react-apollo`发送文档的过程：
- en: 'In the `Products` page component, you can import the `useQuery` Hook from `@apollo/client`
    and define a constant for the named `getProducts` query. Also, you need to import
    `gql` to use the GraphQL query language inside your React file as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Products`页面组件中，你可以从`@apollo/client`导入`useQuery`钩子，并为命名查询`getProducts`定义一个常量。此外，你需要导入`gql`，以便在你的React文件中使用GraphQL查询语言，如下所示：
- en: '[PRE17]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The imported `useQuery` Hook can be called from `Products` and handle the data
    fetching process based on the query that you pass to it. In the same way as the
    context API, `useQuery` can consume the data from the Provider by returning a
    `data` variable. You can iterate over the `products` field from this object and
    return a list of `ProductItem` components already imported into this file. Also,
    a `loading` variable is returned that will be `true` when the GraphQL server hasn''t
    returned the data yet:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Products`组件中导入的`useQuery`钩子可以调用并处理基于传递给它的查询的数据获取过程。与上下文API类似，`useQuery`可以通过返回一个`data`变量来从Provider中消耗数据。你可以遍历此对象中的`products`字段，并返回已导入此文件的`ProductItem`组件列表。此外，还会返回一个`loading`变量，当GraphQL服务器尚未返回数据时，该变量将为`true`：
- en: '[PRE18]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will send a document with the `GET_PRODUCTS` query to the GraphQL server
    when your application mounts and subsequently display the product information
    in the list of `ProductItem` components. After adding the logic to retrieve the
    product information from the GraphQL server, your application will look similar
    to the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的应用程序挂载时发送一个包含`GET_PRODUCTS`查询的文档到GraphQL服务器，并随后在`ProductItem`组件列表中显示产品信息。在添加从GraphQL服务器检索产品信息的逻辑后，你的应用程序将类似于以下所示：
- en: '![Figure 7.4 – Rendering products from GraphQL'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4 – 从GraphQL渲染产品'
- en: '](img/Figure_7.4_B17390.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4_B17390.jpg](img/Figure_7.4_B17390.jpg)'
- en: Figure 7.4 – Rendering products from GraphQL
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 从GraphQL渲染产品
- en: By clicking on the button in the top-right corner of this page, you'll navigate
    to the `/cart` route, which also needs to query data from the GraphQL server.
    As we don't have a query to retrieve the cart yet, we need to add it to the GraphQL
    server in `pages/api/graphql/index.js`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击此页面的右上角按钮，你将导航到`/cart`路由，该路由也需要从GraphQL服务器查询数据。由于我们还没有检索购物车的查询，我们需要将其添加到`pages/api/graphql/index.js`中的GraphQL服务器。
- en: 'We can create a mutable variable using `let` because there is no connected
    data source for the GraphQL server. This is an object that we want to update later,
    for example, when we add products to the cart:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于GraphQL服务器没有连接的数据源，我们可以使用`let`创建一个可变变量。这是一个我们希望稍后更新的对象，例如，当我们向购物车添加产品时：
- en: '[PRE19]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the schema, we need to define a type for `Cart` and add this type to the
    list of queries for our GraphQL server:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模式中，我们需要为`Cart`定义一个类型，并将此类型添加到我们GraphQL服务器的查询列表中：
- en: '[PRE20]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the `pages/cart/index.js` file, the components to render the products in
    the cart are already imported. We do have to import the `useQuery` Hook and `gql`
    from `@apollo/client` and create the query constant:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pages/cart/index.js`文件中，已经导入了用于在购物车中渲染产品的组件。我们确实需要从`@apollo/client`导入`useQuery`钩子和`gql`，并创建查询常量：
- en: '[PRE21]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `Cart` component, we need to get the data that we want to display using
    the `useQuery` Hook. After getting the data, we can return a list of products
    that are added to the cart together with the button to check out:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Cart` 组件中，我们需要使用 `useQuery` 钩子获取我们想要显示的数据。在获取数据后，我们可以返回一个列表，其中包含添加到购物车中的产品以及结账按钮：
- en: '[PRE22]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This won''t show any products yet as the cart is empty; the cart will be filled
    with products in the next section. However, let''s proceed by adding a `useQuery`
    Hook to the button that navigates to the cart in `SubHeader`, which is rendered
    on routes other than `/cart` itself. A new file called `CartButton.js` can be
    created in the `components` directory. In this file, a `useQuery` Hook will return
    data from a query that requests the total number of products in the cart. Also,
    we can add a value to the `Button` component by adding the following code to this
    file:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于购物车为空，这不会显示任何产品；在下一节中，购物车将被产品填充。然而，让我们通过将 `useQuery` 钩子添加到导航到 `SubHeader`
    中按钮中，继续操作，`SubHeader` 在除 `/cart` 本身以外的路由上渲染。可以在 `components` 目录中创建一个名为 `CartButton.js`
    的新文件。在这个文件中，`useQuery` 钩子将返回一个查询的数据，该查询请求购物车中产品的总数。此外，我们还可以通过向此文件添加以下代码来向 `Button`
    组件添加一个值：
- en: '[PRE23]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This `CartButton` component replaces `Button`, which is now being displayed
    with a placeholder count for the number of products in the cart, in the `components/SubHeader.js`
    file:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个 `CartButton` 组件替换了 `Button`，现在在 `components/SubHeader.js` 文件中以购物车中产品数量的占位符形式显示：
- en: '[PRE24]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With all the components that show either a product or cart information connected
    to the GraphQL server, you can proceed by adding mutations that add products to
    the cart. How to add mutations to the application and send document container
    mutations to the GraphQL server will be shown in the next part of this section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在将显示产品或购物车信息的组件连接到 GraphQL 服务器后，你可以通过添加将产品添加到购物车的变更来继续操作。如何在应用程序中添加变更以及如何将文档容器变更发送到
    GraphQL 服务器将在本节下一部分中展示。
- en: Handling mutations in GraphQL
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理 GraphQL 中的变更
- en: Mutating data makes using GraphQL more interesting because when data is mutated,
    some side effects should be executed. For example, when a user adds a product
    to their cart, the data for the cart should be updated throughout the component
    as well. This is quite easy when you're using Apollo Client since the Provider
    handles this in the same way as the context API.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 变更数据使得使用 GraphQL 更有趣，因为当数据被变更时，应该执行一些副作用。例如，当用户将产品添加到他们的购物车时，购物车的数据应该在整个组件中更新。当你使用
    Apollo Client 时，这相当简单，因为 Provider 以与上下文 API 相同的方式处理这一点。
- en: 'The GraphQL server now only has queries, but no operations as yet. Adding mutations
    is quite like how we''ve added queries to the schema before, but for the mutation,
    we also need to add resolvers. Resolvers are where the magic happens in GraphQL
    and where the schema is linked to logic to get the data, possibly from a data
    source. The addition of mutations is done in the `pages/api/graphql/index.js`
    file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的 GraphQL 服务器只有查询，还没有操作。添加变更与之前我们添加查询到模式的方式类似，但对于变更，我们还需要添加解析器。解析器是 GraphQL
    中的魔法所在，也是模式与获取数据逻辑（可能来自数据源）链接的地方。变更的添加是在 `pages/api/graphql/index.js` 文件中完成的。
- en: 'The first step is to add the mutation to add a product to the cart to the schema.
    This mutation takes `productId` as an argument. Also, we need to mock a list of
    types later:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是将添加产品到购物车的变更添加到模式中。此变更以 `productId` 作为参数。此外，我们还需要在稍后模拟一个类型列表：
- en: '[PRE25]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'So far, all the values for our schema are mocked the GraphQLServer, but normally
    you would add resolvers for every type in the schema. These resolvers will contain
    the logic to get something from a data source. As we want to store the values
    for the `Cart` type in the `cart` object that is created at the top of this file,
    we need to add a resolver for the `addToCart` mutation:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们模式中的所有值都是由 GraphQLServer 模拟的，但通常你会在模式中的每个类型上添加解析器。这些解析器将包含从数据源获取数据的逻辑。由于我们希望将
    `Cart` 类型的值存储在此文件顶部创建的 `cart` 对象中，因此我们需要为 `addToCart` 变更添加一个解析器：
- en: '[PRE26]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When creating the `graphqlHTTP` instance, we need to pass the resolver that
    we created to it in order for our changes to become effective:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建 `graphqlHTTP` 实例时，我们需要传递我们为其创建的解析器，以便我们的更改生效：
- en: '[PRE27]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can already test this mutation by trying it out on the GraphQL playground
    that''s available at `http://localhost:3000/api/graphql`. Here, you''d need to
    add the mutation in the upper-left box of this page. The variable that you want
    to include in this mutation for `productId` must be placed in the bottom-left
    box of this page, called **QUERY VARIABLES**. This would result in the following
    output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在`http://localhost:3000/api/graphql`可用的GraphQL playground中尝试此突变来测试它。在这里，您需要在页面左上角的框中添加突变。您想要包含在此突变中的`productId`变量必须放置在页面左下角的框中，称为**查询变量**。这将产生以下输出：
- en: '![Figure 7.5 – Using mutations in the GraphiQL playground'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – 在GraphiQL playground中使用突变'
- en: '](img/Figure_7.5_B17390.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.5_B17390.jpg)'
- en: Figure 7.5 – Using mutations in the GraphiQL playground
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 在GraphiQL playground中使用突变
- en: 'Every time you send a document to the GraphQL server with this mutation, a
    new product will be added to the list. Also, the `count` field will be incremented
    by `1`. But, when you want to retrieve this information using the query for the
    `Cart` type, the values will still be mocked by the GraphQL Server. To return
    the `cart` object instead, we also need to add a resolver for the query to get
    the cart information:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 每次您使用此突变将文档发送到GraphQL服务器时，列表中都会添加一个新的产品。此外，`count`字段将增加`1`。但是，当您想要使用`Cart`类型的查询检索此信息时，值仍然将由GraphQL服务器模拟。为了返回`cart`对象，我们还需要为获取购物车信息的查询添加一个解析器：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The response that will now be returned after using the `addToCart` mutation
    will reflect what you can retrieve with the cart query.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`addToCart`突变返回的响应将反映您可以使用购物车查询检索的内容。
- en: 'To be able to use this mutation from our React application, we will need to
    make the following changes:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够从我们的React应用程序中使用此突变，我们需要进行以下更改：
- en: 'Currently, there''s no button to add a product to the cart yet, so you can
    create a new file in the `components` directory and call this `AddToCartButton.js`.
    In this file, you can add the following code:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，还没有按钮可以将产品添加到购物车中，因此您可以在`components`目录中创建一个新文件，并命名为`AddToCartButton.js`。在这个文件中，您可以添加以下代码：
- en: '[PRE29]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This new `AddToCartButton` takes `productId` as a prop and has a `useMutation`
    Hook from `@apollo/client`, which uses the mutation we've created earlier. The
    output of `Mutation` is the actual function to call this mutation, which takes
    an object containing the inputs as an argument. Clicking on the `Button` component
    will execute the mutation and pass the `productId` to it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`AddToCartButton`将`productId`作为属性，并使用来自`@apollo/client`的`useMutation` Hook，该Hook使用我们之前创建的突变。`Mutation`的输出是调用此突变的实际函数，该函数接受一个包含输入参数的对象作为参数。点击`Button`组件将执行突变并将`productId`传递给它。
- en: 'This button should be displayed next to the products in the list on the `/`
    or `/products` routes, where each product is displayed in a `ProductItem` component.
    This means that you will need to import `AddCartButton` in `components/ProductItem.js`
    and pass a `productId` prop to it by using the following code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此按钮应显示在`/`或`/products`路由上的产品列表旁边，其中每个产品都通过`ProductItem`组件显示。这意味着您需要在`components/ProductItem.js`中导入`AddCartButton`，并通过以下代码向其传递一个`productId`属性：
- en: '[PRE30]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, when you open the React application in the browser, a button will be displayed
    next to the product titles. If you click this button, the mutation will be sent
    to the GraphQL server, and the product will be added to the cart. However, you
    won't see any changes to the button that displays `SubHeader` component.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您在浏览器中打开React应用程序时，将在产品标题旁边显示一个按钮。如果您点击此按钮，突变将被发送到GraphQL服务器，产品将被添加到购物车中。然而，您不会看到显示`SubHeader`组件的按钮有任何变化。
- en: 'Executing this query after sending the mutation can be done by setting a value
    for the `refetchQueries` option of the `useMutation` Hook in `components/AddToCartButton.js`.
    This option takes an array of objects with information about the queries that
    should be requested. In this case, it''s only the `GET_CART_TOTAL` query, which
    is executed by `CartButton`. To do this, make the following changes:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在发送突变后执行此查询可以通过在`components/AddToCartButton.js`中的`useMutation` Hook的`refetchQueries`选项中设置值来完成。此选项接受一个包含应请求的查询信息的对象数组。在这种情况下，它仅是`GET_CART_TOTAL`查询，由`CartButton`执行。为此，进行以下更改：
- en: '[PRE31]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When you click on `CartButton`, we''ll navigate to the `/cart` route, where
    the products that we have in the cart are displayed. On here, `AddToCartButton`
    is also rendered, as this is defined in the `ProductItem` component. Let''s change
    this by going to the `components/ProductItem.js` file and add the following lines
    of code, which will render this button conditionally:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你点击 `CartButton` 时，我们将导航到 `/cart` 路由，在这里显示我们购物车中的产品。在这里，`AddToCartButton` 也会被渲染，因为这是在
    `ProductItem` 组件中定义的。让我们通过访问 `components/ProductItem.js` 文件并添加以下代码行来更改这一点，这将条件性地渲染此按钮：
- en: '[PRE32]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'From the `Products` page component, we need to pass the `addToCart` prop to
    render the button on this page:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Products` 页面组件中，我们需要传递 `addToCart` 属性来渲染此页面上的按钮：
- en: '[PRE33]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, every time you send a mutation in a document to the GraphQL server from
    this component, the `GET_CART_TOTAL` query will be sent as well. If the results
    have changed, the `CartButton` and `Cart` components will be rendered with this
    new output. Therefore, the `CartButton` component will be updated to display `AddToCartButton`
    component:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次你从这个组件向 GraphQL 服务器发送文档突变时，都会发送 `GET_CART_TOTAL` 查询。如果结果已更改，`CartButton`
    和 `Cart` 组件将使用这个新的输出进行渲染。因此，`CartButton` 组件将被更新以显示 `AddToCartButton` 组件：
- en: '![Figure 7.6 – Updating the products in the cart'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6 – 更新购物车中的产品'
- en: '](img/Figure_7.6_B17390.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6 – 更新购物车中的产品](img/Figure_7.6_B17390.jpg)'
- en: Figure 7.6 – Updating the products in the cart
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 更新购物车中的产品
- en: In this section, we've learned how to set up Apollo Client and use it to send
    documents to the GraphQL server. In the next section of this chapter, we'll expand
    on this by handling authentication.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何设置 Apollo 客户端并使用它向 GraphQL 服务器发送文档。在本书的下一节中，我们将通过处理身份验证来扩展这一点。
- en: Handling authentication in GraphQL
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 GraphQL 中处理身份验证
- en: Until now, we've created a GraphQL server that can be consumed by an application
    built with Next.js and React. Using queries and mutation, we can view a list of
    products and add them to a shopping cart. But we haven't added logic to check
    out that cart yet, which we'll do in this section.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个可以被使用 Next.js 和 React 构建的应用程序消费的 GraphQL 服务器。通过查询和突变，我们可以查看产品列表并将它们添加到购物车中。但我们还未添加检查购物车的逻辑，这将在本节中完成。
- en: When users have added products to the cart, you want them to be able to check
    out; but before that, the users should be authenticated as you want to know who's
    buying the product.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户将产品添加到购物车后，你希望他们能够进行结账；但在那之前，用户应该进行身份验证，因为你想要知道谁在购买该产品。
- en: For authentication in frontend applications, most of the time, **JSON Web Tokens**
    (**JWTs**) are used, which are encrypted tokens that can easily be used to share
    user information with a backend. The JWT will be returned by the backend when
    the user is successfully authenticated and often, this token will have an expiration
    date. With every request that the user should be authenticated for, the token
    should be sent so that the backend server can determine whether the user is authenticated
    and allowed to take this action. Although JWTs can be used for authentication
    since they're encrypted, no private information should be added to them since
    the tokens should only be used to authenticate the user. Private information can
    only be sent from the server when a document with the correct JWT has been sent.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前端应用程序中的身份验证，大多数情况下使用 **JSON Web Tokens**（JWTs），这些是加密的令牌，可以轻松地用于与后端共享用户信息。JWT
    将在用户成功认证后由后端返回，并且通常，此令牌将有一个过期日期。对于用户应该进行身份验证的每个请求，都应该发送此令牌，以便后端服务器可以确定用户是否已认证并且允许执行此操作。尽管
    JWT 可以用于身份验证，因为它们是加密的，但不应将任何私人信息添加到其中，因为令牌仅应用于认证用户。只有当发送了包含正确 JWT 的文档时，服务器才能发送私人信息。
- en: 'Before we can add the checkout process to the React application, we need to
    make it possible for customers to authenticate. This consists of multiple steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够将结账过程添加到 React 应用程序之前，我们需要使客户能够进行身份验证。这包括多个步骤：
- en: 'We need to create a new type in the schema that defines a user and a mutation
    to log in a user, which we can do in `pages/api/graphql/index.js`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在模式中创建一个新的类型，该类型定义了用户和用于登录用户的突变，我们可以在 `pages/api/graphql/index.js` 中完成：
- en: '[PRE34]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With the mutation defined in the schema, it can be added to the resolvers.
    In the `utils/authentication.js` file, a method to check the `username` and `password`
    combination is already present. This method will return a valid token together
    with the username if that combination is correct. From this file, we also import
    a method to check whether a token is valid:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模式中定义突变后，可以将其添加到解析器中。在 `utils/authentication.js` 文件中，已经存在一个用于检查 `username`
    和 `password` 组合的方法。如果这个组合是正确的，该方法将返回一个有效的令牌以及用户名。从这个文件中，我们还导入了一个用于检查令牌是否有效的方法：
- en: '[PRE35]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'From the GraphiQL playground, we can now check whether this mutation is working
    by entering the username `test` and the password `test`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从GraphiQL游乐场，我们现在可以通过输入用户名 `test` 和密码 `test` 来检查这个突变是否工作：
- en: '![Figure 7.7 – Creating a JWT with GraphQL'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7 – 使用GraphQL创建JWT'
- en: '](img/Figure_7.7_B17390.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.7_B17390.jpg)'
- en: Figure 7.7 – Creating a JWT with GraphQL
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 使用GraphQL创建JWT
- en: 'In the `pages/login/index.js` file, we can add the logic to use the input from
    a form to send a document with the `loginUser` mutation to the GraphQL server.
    The `Login` page component is already using `useState` Hooks to control the value
    of the input fields for `username` and `password`. The `useMutation` Hook can
    be imported from `@apollo/client`:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `pages/login/index.js` 文件中，我们可以添加逻辑来使用表单的输入来发送包含 `loginUser` 变化的文档到GraphQL服务器。`Login`
    页面组件已经使用 `useState` 钩子来控制 `username` 和 `password` 输入字段的值。可以从 `@apollo/client`
    导入 `useMutation` 钩子：
- en: '[PRE36]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After creating the `loginUser` function, this can be added to the `onSubmit`
    event from the `form` element, and the values for `username` and `password` should
    be passed to this function as variables:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建 `loginUser` 函数后，我们可以将其添加到 `form` 元素的 `onSubmit` 事件中，并将 `username` 和 `password`
    的值作为变量传递给此函数：
- en: '[PRE37]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Clicking the `Button` will send the document containing the `username` and
    `password` values to the GraphQL server and, if successful, it returns the JWT
    for this user. This token should also be stored in the session storage so that
    it can be used later. Also, we want to redirect the user back to the home page
    when logged in. To do this, we need to import a `useEffect` Hook from React that
    watches for changes in the data. When the token is present, we can use a `router`
    object obtained from a `useRouter` Hook that we need to import from Next.js:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `Button` 将会发送包含 `username` 和 `password` 值的文档到GraphQL服务器，如果成功，它将返回该用户的JWT。此令牌也应存储在会话存储中，以便以后使用。此外，我们希望在用户登录后将其重定向回主页。为此，我们需要从React导入一个
    `useEffect` 钩子来监视数据的变化。当令牌存在时，我们可以使用从 `useRouter` 钩子获得的 `router` 对象，我们需要从Next.js导入这个钩子：
- en: '[PRE38]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Every time a customer logs in via the `/login` route, the token is stored in
    the session storage in the browser. You can delete the token from the session
    storage by going to the `Bearer`, since this is how a JWT is recognized. This
    requires us to make multiple changes to `pages/_app.js`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次客户通过 `/login` 路由登录时，令牌都会存储在浏览器中的会话存储中。您可以通过访问 `Bearer` 来从会话存储中删除令牌，因为这就是JWT被识别的方式。这需要我们对
    `pages/_app.js` 进行多次修改：
- en: '[PRE39]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: On every request to the GraphQL server, the token will now be added to the headers
    of the HTTP request.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在对GraphQL服务器的每个请求中，现在都会将令牌添加到HTTP请求的头部。
- en: 'The GraphQL Server can now get the token from the HTTP request headers and
    store them in the context. The context is an object that you use to store data
    that you want to use in your resolvers, such as a JWT. This can be done in `pages/api/graphql/index.js`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GraphQL服务器现在可以从HTTP请求头部获取令牌并将它们存储在上下文中。上下文是一个对象，您可以使用它来存储您想在解析器中使用的数据，例如JWT。这可以在
    `pages/api/graphql/index.js` 中完成：
- en: '[PRE40]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, we can also create a mutation to check out the items. This mutation
    should empty the card and, in a production environment, redirect the customer
    to a payment provider. In this scenario, we''ll just empty the card and display
    a message that the order has been created successfully. To aid the checkout process,
    we need to make the following changes:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以创建一个用于检查项目的突变。这个突变应该清空卡片，在生产环境中，将客户重定向到支付服务提供商。在这种情况下，我们只需清空卡片并显示订单已成功创建的消息。为了帮助检查过程，我们需要进行以下修改：
- en: 'We require a new mutation in the schema of our GraphQL server in `pages/api/graphql/index.js`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在我们的GraphQL服务器 `pages/api/graphql/index.js` 的模式中添加一个新的突变：
- en: '[PRE41]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'With the mutation defined in the schema, it can be added to the resolvers.
    The mutation needs to clear the products in the cart, set the `count` field to
    `0`, and the `complete` field to `true`. Also, it should check whether the user
    has a token stored in the context and whether this is a valid token. To check
    the token, we can use the previously imported `isTokenValid` method:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模式中定义的突变可以被添加到解析器中。这个突变需要清除购物车中的产品，将 `count` 字段设置为 `0`，并将 `complete` 字段设置为
    `true`。此外，它应该检查用户是否在上下文中存储了一个令牌，以及这个令牌是否有效。为了检查令牌，我们可以使用之前导入的 `isTokenValid` 方法：
- en: '[PRE42]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the `pages/cart/index.js` file, we need to import this Hook from `@apollo/client`
    and import `useRouter` from Next.js to redirect the user to the `/login` page
    if they are not authenticated. Also, the mutation to complete the cart can be
    added here:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `pages/cart/index.js` 文件中，我们需要从 `@apollo/client` 导入这个 Hook，并从 Next.js 导入 `useRouter`
    以将未认证的用户重定向到 `/login` 页面。此外，可以在这里添加完成购物车的突变：
- en: '[PRE43]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the return statement of the `Cart` component, there is a button to check
    out. This button will need to call a function created by a `useMutation` Hook
    that takes this new mutation. This mutation completes the cart and clears its
    content. If the user isn''t authenticated, it should redirect the user to the
    `/login` page:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Cart` 组件的返回语句中，有一个用于结账的按钮。这个按钮需要调用由 `useMutation` Hook 创建的函数，该函数接受这个新的突变。这个突变完成购物车并清除其内容。如果用户未认证，它应该将用户重定向到
    `/login` 页面：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This concludes the checkout process for the application and thereby this chapter,
    where you've used React and GraphQL to create an e-commerce application.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了应用程序的结账过程，从而结束了这一章，在这一章中，你使用了 React 和 GraphQL 来创建一个电子商务应用程序。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you've created a full stack React application that uses GraphQL
    as its backend. Using a GraphQL server and mock data, the GraphQL server was created
    within Next.js using API routes. This GraphQL server takes queries and mutations
    to provide you with data and lets you mutate that data. This GraphQL server is
    used by a React application that uses Apollo Client to send and receive data from
    the server.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你创建了一个全栈 React 应用程序，该应用程序使用 GraphQL 作为其后端。使用 GraphQL 服务器和模拟数据，在 Next.js
    中使用 API 路由创建了 GraphQL 服务器。这个 GraphQL 服务器接收查询和突变，为你提供数据，并允许你突变这些数据。这个 GraphQL 服务器被一个使用
    Apollo 客户端的 React 应用程序使用，以从服务器发送和接收数据。
- en: That's it! You've completed the seventh chapter of this book and have already
    created seven web applications with React. By now, you should feel comfortable
    with React and its features and be ready to learn some more. In the next chapter,
    you'll be introduced to React Native and learn how you can use your React skills
    to build a mobile application by creating an animated game with React Native and
    Expo.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你已经完成了这本书的第七章，并且已经用 React 创建了七个网络应用程序。到现在为止，你应该对 React 和其特性感到很舒适，并且准备好学习更多。在下一章中，你将介绍
    React Native，并学习如何通过使用 React Native 和 Expo 创建一个动画游戏来利用你的 React 技能构建一个移动应用程序。
- en: Further reading
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Next.js API routes: [https://nextjs.org/docs/api-routes/introduction](https://nextjs.org/docs/api-routes/introduction)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Next.js API 路由：[https://nextjs.org/docs/api-routes/introduction](https://nextjs.org/docs/api-routes/introduction)
- en: 'GraphQL: [https://graphql.org/learn/](https://graphql.org/learn/)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL：[https://graphql.org/learn/](https://graphql.org/learn/)
- en: 'Apollo Client: [https://www.apollographql.com/docs/react/](https://www.apollographql.com/docs/react/)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apollo 客户端：[https://www.apollographql.com/docs/react/](https://www.apollographql.com/docs/react/)
