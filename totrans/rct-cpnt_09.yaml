- en: Chapter 9. Thinking of Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at a couple of design patterns that we could
    use to build our applications. There are reasons for and against the use of Flux
    and Redux, but they generally improve the structure of React applications.
  prefs: []
  type: TYPE_NORMAL
- en: A good structure is essential for any large-scale application. Cobbling things
    together may work for small experiments, but design patterns are an integral part
    of maintaining anything larger. They do not say much in the way of creating extendable
    components, though. In this chapter, we're going to look at a few ways that we
    can use to make our components extendable by replacing them, injecting functionality,
    and composing interfaces from dynamic lists of components.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to review a few related software design concepts and take a look
    at how they can assist us (and others) when we want to replace parts of our application
    with modified components and alternative implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection and service location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Dependency injection* and *service location* are interesting concepts that
    are not limited to React development. To really understand them, let''s move away
    from components for a while. For a moment, imagine that we wanted to create a
    sitemap. To do this, we could perhaps use code resembling the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `createSitemap` has two dependencies. Firstly, we fetch pages
    from `backend`. This is a kind of global storage object. We used something similar
    to this when we looked at the Flux architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The second dependency is to the `SitemapFormatter` implementation. We use it
    to take a list of pages and return some kind of markup, summarizing these pages
    in the list. We're hardcoding both of these dependencies in a way that is okay
    in small doses, but they are problematic as the application expands.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, what if we wanted to use this sitemap generator with multiple
    backends? What if we also wanted to try alternative implementations of the formatter?
    Right now, we've coupled the sitemap generator to a single backend and a single
    formatter implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection and service location are two possible solutions to this
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve already used dependency injection, in subtle ways. This looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Dependency injection is all about moving dependencies out of the functions and
    classes that use them. This is not about avoiding their use; but rather it is
    creating new instances outside and passing them in through function parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of dependency injection: constructor injection and setter
    injection. This may illustrate the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can inject dependencies through the constructor and assign them to properties,
    or we can create setters for them. We saw constructor injection a few times already,
    but setter injection is another valid means of injecting dependencies. We could
    also use normal functions to inject dependencies, but then we wouldn't be able
    to set or get them through object properties.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when we define component properties, we're essentially injecting
    these property values as constructor dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Factories and service locators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An alternative solution would be to encapsulate the logic to create new instances
    and use references to this factory-like object when looking for dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can then pass around an instance of the `Factory` class, or even inject this
    as a dependency. In other dynamic languages, such as PHP, this has become a common
    practice. We can then use these factories to create new instances that are based
    on some initial criteria. We can have a factory to create new database connections
    and connect to MySQL or SQLite, which is based on a connection type that we specify.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative would be to create a number of objects and store them inside
    a common service locator object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, we can inject the locator as a dependency and fetch the actual dependencies,
    as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Fold
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fortunately, we do not need to build and maintain factories, dependency injectors,
    and service locators. There are already many to choose from, especially in JavaScript.
    We will discuss one in particular. Remember when we discussed rendering React
    components on the server? We looked at an MVC application framework, called AdonisJS.
  prefs: []
  type: TYPE_NORMAL
- en: The creator of AdonisJS also maintains a dependency injection container, called
    *Fold*. Some of the things that Fold does is interesting, and we want to share
    them with you.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install Fold using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In previous chapters, we created a workflow to run ES6 code through Node.js.
    We recommend that you re-create this setup for some of the code in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then start to use it to register and resolve objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fold introduces a global `use` function, so we could use it without needing
    to import `Ioc` each time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `bind` to assign an alias to a factory-like function. When this alias
    is *used*, this factory function will be called and the result returned. This
    becomes even more powerful when we have large dependency graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can compose calls to `bind` and `use`. In this example, creating a new `App/Authenticator`
    will in turn resolve `App/UserRepository` and `App/Crypto` from the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s more is that we can use Fold to load class files automatically. So,
    let''s suppose that we have an `Authenticator` class file resembling the following
    (in `src/Authenticator.js`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually we export classes or functions with `export default ...`; but in this
    case, we're just assigning the class to `module.exports`. This makes it easier
    for Fold to do more interesting things with our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can autoload this with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use regular classes as singletons with a slightly different binding
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `use` works in the same way, whether you use `bind` or `singleton`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fold really shines when it comes to resolving dependencies recursively. Let''s
    change `Authenticator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use getters (a feature of ES6) to overload property access for a static
    `inject` property. This just means that a function will be run whenever we write
    `Authenticator.inject`. Fold uses this static array property to work out which
    dependencies to resolve. Therefore, we can create `Repository` (in `src/Repository.js`),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create `Crypto` (in `src/Crypto.js`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The function of these classes isn''t important. What is important is how Fold
    connects them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates a link between the `App/` class prefix and the class
    files that we want to load. Therefore, a class in `src/Foo/Bar.js` will be loaded
    when we create `App/Foo/Bar`. Similarly, aliases defined in the static inject
    array property will be connected to their relevant constructor parameters when
    we use `Ioc.make`.
  prefs: []
  type: TYPE_NORMAL
- en: Why this matters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we inject dependencies, we can easily replace one part of an application
    with another because dependencies aren't named within the classes that depend
    on them. These classes aren't responsible for creating new instances, only receiving
    instances created on the outside.
  prefs: []
  type: TYPE_NORMAL
- en: If we use a service locator (especially one that resolves dependencies recursively),
    we can avoid a lot of boilerplate during a bootstrapping phase.
  prefs: []
  type: TYPE_NORMAL
- en: What do we gain from being able to replace parts of our application?
  prefs: []
  type: TYPE_NORMAL
- en: 'We allow other developers to inject behavior into our application by replacing
    core parts of the application. Imagine we have the following `Authenticator` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now imagine that we want to add logging to all authentication. We can change
    the `Authenticator` class directly. This is easy if we *own* the code, but we
    often use third-party libraries. We can create a decorator (in `src/AuthenticatorLogger.js`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Decorators are classes that augment the functionality of other classes, usually
    by composing an instance of the class that they augment. You can learn more about
    this pattern at [https://en.wikipedia.org/wiki/Decorator_pattern](https://en.wikipedia.org/wiki/Decorator_pattern).
  prefs: []
  type: TYPE_NORMAL
- en: 'This new class expects an `Authenticator` dependency and adds transparent logging
    to the `authenticate` method. We can override the default (autoload) behavior
    by rebinding `App/Authenticator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s think about this in terms of components. Imagine that we have a list
    of pages that are presented to us by a `PagesComponent` component (in `src/Page.js`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can autoload this using Fold, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, imagine that another developer came along and wanted to add some extra
    chrome around the list of pages. They could dig into the `node_modules` folder
    and directly edit the component, but this would be messy. Instead (and as we''re
    using a dependency injection container), they can override the alias to `App/PagesComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Things get a bit tricky when it comes to the `React.Component` subclasses versus
    instances of these subclasses. The `ReactDOM.render` and `ReactDOMServer.renderToString`
    expect instances are created when we use `<SomeComponent/>` in JSX. This may be
    helpful to register both forms in the container: bindings for a class reference
    and bindings for factory functions that create instances of these classes. We''ve
    suffixed the latter with `{}`, which we can use directly in a `render` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It may be a little easier to understand this last part by making the following
    small change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this way, we allow other developers to replace parts of the application with
    custom classes or component decorators. There's definitely some work to be done
    in terms of creating a team standard for this pattern, but the basic idea is solid.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about Fold at [http://adonisjs.com/docs/2.0/ioc-container](http://adonisjs.com/docs/2.0/ioc-container).
  prefs: []
  type: TYPE_NORMAL
- en: Extending with callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another method to create more pluggable components is to expose (and act on)
    event callbacks. We saw something similar already, but let''s take a look at this
    anyway. Suppose we have a `PageEditorComponent` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is another bit of code that would run best through one of the workflows
    that we created earlier (that allow rendering components in the browser) or [https://jsbin.com](https://jsbin.com).
    We're interested in looking at some dynamic behavior, so it's important that we
    can click on things!
  prefs: []
  type: TYPE_NORMAL
- en: As we saw earlier, we can pass `onSave` and `onCancel` callbacks through properties
    from some higher component. Each React component can have a `ref` callback. A
    reference to the DOM node is passed to this callback, so we can use methods such
    as `focus` and properties such as `value`. This works well to synchronize state
    with a common backend or store. However, what can we do to add some custom validation?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add optional callback properties (and `propTypes`) and incorporate these
    in our `onSave` and `onCancel` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then define additional steps at key points in the component''s behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `onSave` method checks whether an optional `onBeforeSave` property is defined.
    If so, this callback is run. If the callback returns `false`, we can use this
    as a way to prevent the default component save behavior. We still need the default
    save or cancel behavior to work, so these properties are required. The others
    are optional but useful.
  prefs: []
  type: TYPE_NORMAL
- en: Stores, reducers, and components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building on these concepts, the final thing that we want you to look at is how
    this all fits together inside a Redux architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you've skipped ahead to this chapter, make sure that you have a firm understanding
    of Redux by reading the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with a `PageComponent` class (for individual pages, in a list):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Dummy*Component` classes can be anything, really. We created a few "empty"
    components in the source code that goes with this chapter. The main thing is that
    `PageComponent` composes a few other components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nothing too fancy here: we compose a few components and hook into the usual
    Redux stuff. This is complemented by some new service location stuff:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re using a new `combineReducers` method, which takes an array of reducers
    and produces a new mega-reducer. Let''s make the order and inclusion of the child
    components configurable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Two interesting things are happening here:'
  prefs: []
  type: TYPE_NORMAL
- en: In ES6, the `Array.prototype.map` method passes a second parameter to the callback.
    This is the numeric index for the current iteration of the array that is being
    mapped. We can use this as the `key` parameter when we're creating a list of child
    components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use dynamic component names. Pay careful attention to the capitalization
    of `Component`. If the component name variable starts with a lowercase letter,
    React will assume a literal value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we''re building a dynamic list of components, we can move the default
    list out of this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then replace this list in `PageComponent.render`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Building on what we learned earlier about Fold, we can override this list when
    we want to add plugins! We can include a plugin to e-mail a snapshot of a page
    to someone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This new plugin configuration can be miles away from the core definition of
    `PageComponent`, and we don''t have to change any core code to make this work.
    We can add new reducers in exactly the same way (thereby altering our store or
    dispatcher behavior):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this way, other developers can create entirely new components and reducers
    and apply them effortlessly to the system that we've already built.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at a few methods that we could use to make our components
    (and general architecture) open to extension without requiring core modification.
    There's a lot to take in here and not nearly enough community standardization
    for this to be the final word on pluggable components. Hopefully, there's enough
    here for you to design the right plugin architecture for your application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at various ways to test the components and
    classes that we've built so far. We'll continue to see the benefits of things,
    such as dependency injection and service location, while also learning about a
    few new tools.
  prefs: []
  type: TYPE_NORMAL
