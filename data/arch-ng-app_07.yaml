- en: RxJS Advanced
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJS高级
- en: We just finished our last chapter that taught us more about what operators exist
    and how to utilize them effectively. Armed with this knowledge, we will now go
    into this subject in more depth. We will go from learning about what parts exist,
    to actually understanding the nature of RxJS. Knowing the nature of RxJS involves
    understanding more about what makes it tick. To uncover this, we need to cover
    topics such as what the differences are between hot, warm, and cold Observables;
    knowing about Subjects and what they are good for; and the sometimes ignored topic
    of Schedulers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成了最后一章，本章让我们更多地了解了有哪些操作符以及如何有效地利用它们。有了这些知识，我们现在将更深入地探讨这个主题。我们将从了解存在哪些部分，到真正理解RxJS的本质。了解RxJS的本质涉及到了解是什么让它运转。为了揭示这一点，我们需要涵盖诸如热、温、冷观测量之间的区别；了解主题及其用途；以及有时被忽视的主题——调度器。
- en: There are also other aspects of working with Observables that we want to cover,
    namely, how to deal with errors and how to test your Observables.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想要涵盖与Observable一起工作的其他方面，特别是如何处理错误以及如何测试您的观测量。
- en: 'In this chapter, you will learn about:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解以下内容：
- en: Hot, cold, and warm Observables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 热观测量、冷观测量和温观测量
- en: 'Subjects: how they differ from Observables, and when to use them'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题：它们与Observable的区别，以及何时使用它们
- en: Pipeable operators, a recent addition to the RxJS library, and how they affect
    how you compose Observables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可管道操作符，RxJS库中的最新增项，以及它们如何影响您组合观测量的方式
- en: Marble testing, the testing machinery in place that helps you with testing your
    Observables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大理石测试，这是帮助您测试观测量的测试设备
- en: Hot, cold, and warm Observables
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热观测量、冷观测量和温观测量
- en: 'There are hot, cold, and warm Observables. What do we actually mean by that?
    For starters, let''s say that most things you will deal with are cold Observables.
    Not helping? If we say that cold Observables are lazy, does that help? No? OK,
    let''s talk about Promises for a second. Promises are hot. They are hot because
    when we execute their code, it happens straight away. Let''s see an example of
    that:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着热、冷、温观测量。我们实际上是什么意思呢？首先，让我们说，您将处理的大部分内容都是冷观测量。这有帮助吗？如果没有帮助？那么，让我们先谈谈Promise。Promise是热的。它们之所以是热的，是因为当我们执行它们的代码时，它会立即发生。让我们看看一个例子：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you come from a non-RxJS background, you will most likely, at this point,
    think: OK, yes, that''s what I expected. This is the point we are trying to make,
    though: Calling `getData()` makes your code run straight away. This differs from
    RxJS in the sense that similar RxJS code will actually not run until there is
    a listener/subscriber that cares about the result. RxJS answers the old philosophical
    question: Does a tree make a sound when it falls in the forest if no one is there
    to listen? In the case of Promises, it does. In the case of an Observable, it
    doesn''t. Let''s clarify what we just said with a similar code example using RxJS
    and Observables:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您来自非RxJS背景，您在这个时候可能会想：好吧，是的，这正是我预期的。不过，我们想要表达的观点是：调用`getData()`会使您的代码立即运行。这与RxJS不同，因为在RxJS中，类似的代码实际上只有在存在一个关心结果的监听器/订阅者时才会运行。RxJS回答了古老的哲学问题：如果森林里没有人来听，树倒下会发出声音吗？在Promise的情况下，会。在Observable的情况下，则不会。让我们用一个类似的代码示例来澄清我们刚才所说的，使用RxJS和Observable：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In RxJS, code like this is considered cold, or lazy. We need a subscriber for
    something to actually happen. We can add a subscriber like so:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxJS中，这样的代码被认为是冷的，或者说是懒的。我们需要一个订阅者才能使某些事情真正发生。我们可以添加一个订阅者，如下所示：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is a major difference in how Observables behave versus Promises, and it''s
    important to know. This is a cold Observable; so, what is a hot Observable? It
    would be easy to think, at this point, that a hot Observable is something that
    executes straight away; there is more to it than that, however. One of the official
    explanations of what a hot Observable is, is that anything that subscribes to
    it will share the Producer with other Subscribers. The Producer is what spouts
    out values internally inside the Observable. This means that the data is shared.
    Let''s look at a cold Observable subscription scenario and contrast that with
    a hot Observable subscription scenario. We will start with the cold scenario:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Observables与Promises行为之间的一大区别，了解这一点很重要。这是一个冷Observables；那么，什么是热Observables呢？在这个时候，人们可能会认为热Observables是立即执行的东西；然而，这不仅仅是那样。关于什么是热Observables的官方解释之一是，任何订阅它的东西都会与其他订阅者共享生产者。生产者是Observables内部内部产生值的来源。这意味着数据是共享的。让我们看看冷Observables订阅场景，并将其与热Observables订阅场景进行对比。我们将从冷场景开始：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we have three different subscribers that receive their
    own copy of emitted values. The values start from the beginning, every time we
    add a new subscriber. That might be expected when looking at the two first subscribers.
    As for the third one, it is added as a subscriber after two seconds. Yes, even
    that subscriber receives its own set of values. The explanation is that each subscriber
    receives its own Producer upon subscription.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有三个不同的订阅者，它们各自接收发出的值的副本。每次我们添加一个新的订阅者时，值都是从开始处开始的。当我们查看前两个订阅者时，这可能是个预期。至于第三个订阅者，它是在两秒后作为订阅者添加的。是的，甚至那个订阅者也会收到它自己的值集。解释是每个订阅者在订阅时都会收到它自己的生产者。
- en: 'With hot Observables, there is just one producer, which means the scenario
    above will play out differently. Let''s write down the code for a hot Observable
    scenario:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在热Observables的情况下，只有一个生产者，这意味着上述场景将会有不同的表现。让我们写下热Observables场景的代码：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The reason the third subscriber is outputting only the value `2` is that the
    other values have been emitted already. The third subscriber wasn't around to
    see that happen. On the third value emit, it is around, and that is the reason
    it receives the value `2`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个订阅者只输出值`2`的原因是其他值已经发出。第三个订阅者没有看到这一发生。在第三个值发出时，它出现了，这就是它接收值`2`的原因。
- en: Making a stream hot
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使流变热
- en: 'This `hotStream$`, how can it be created? You did say that most of the streams
    being created are cold? We have an operator for doing just that, or two operators,
    in reality. We can make a stream go from cold to hot by using the operators `publish()`
    and `connect()`. Let''s start with a cold Observable and add the mentioned operators,
    like so:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`hotStream$`是如何创建的呢？你确实说过大多数创建的流都是冷的吗？我们有一个操作符专门用于此，实际上有两个操作符。我们可以通过使用`publish()`和`connect()`操作符将流从冷变为热。让我们从一个冷Observables开始，并添加提到的操作符，如下所示：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can see from the preceding code that we create our Observable and instruct
    it to emit values, one value per second. Furthermore, it should stop after five
    emitted values. We then call the operator `publish()`. This puts us in ready mode.
    We then set up a few subscriptions to happen after two seconds and three seconds,
    respectively. This is followed by us calling `connect()` on the stream. This will
    make the stream go from hot to cold. Thereby, our stream starts emitting values,
    and any subscriber, whenever it starts subscribing, will share a producer with
    any future subscriber. Lastly, we add a subscriber to happen straight after the
    call to `connect()`. Let''s show what the output becomes with the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中我们可以看到，我们创建了一个Observable，并指示它每秒发出一个值。此外，它应该在发出五个值后停止。然后我们调用`publish()`操作符。这使我们处于准备模式。然后我们设置在两秒和三秒后分别发生的几个订阅。然后我们调用流上的`connect()`。这将使流从热变为冷。因此，我们的流开始发出值，任何订阅者，无论何时开始订阅，都将与任何未来的订阅者共享生产者。最后，我们在`connect()`调用后立即添加一个订阅者。让我们通过以下截图来展示输出结果：
- en: '![](img/ee47651c-91e2-4dba-be28-5072cf65726e.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee47651c-91e2-4dba-be28-5072cf65726e.png)'
- en: Our first subscriber is emitting values after one second. Our second subscriber
    kicks in after yet another second. This time its value is `1`; it has missed out
    on the first value. After yet another second, the third subscriber has been attached.
    The first value that subscriber emits is `2`; it missed out on the two first values.
    We clearly see how the operators `publish()` and `connect()` help to create our
    hot Observable, but also how it matters when you start subscribing to a hot Observable.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一位订阅者在1秒后开始发出值。第二位订阅者在又过了1秒后开始工作。这次它的值是`1`，它错过了第一个值。又过了1秒，第三位订阅者被附加。该订阅者发出的第一个值是`2`，它错过了前两个值。我们清楚地看到`publish()`和`connect()`运算符如何帮助我们创建热可观察对象，同时也看到开始订阅热可观察对象的重要性。
- en: Why on earth would I want a hot Observable? What's the area for application?
    Well, imagine you have a live stream, a football game that you stream to many
    subscribers/viewers. They wouldn't want to see what happens from the first minute
    of the game when they arrive late, but, rather, where the match is right now,
    at the time of subscription (when they park themselves in front of the television).
    So, there definitely exist cases where hot Observables are the way to go.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我为什么要用热可观察对象呢？它的应用领域在哪里？嗯，想象一下你有一个实时流，一场足球比赛，你将其流式传输给许多订阅者/观众。他们不想看到比赛开始的第一分钟发生的事情，而是想看到比赛当前的状态，在订阅的时间（当他们坐在电视机前的时候）。所以，确实存在一些情况下，热可观察对象是最佳选择。
- en: Warm streams
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 温流
- en: 'So far, we have been describing and discussing cold Observables and hot Observables,
    but there is a third kind: the warm Observable. A warm Observable can be thought
    of as being created as a cold Observable, but turning into a hot Observable under
    certain conditions. Let''s look at such a case by introducing the `refCount()`
    operator:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在描述和讨论冷可观察对象和热可观察对象，但还有一种第三种类型：温可观察对象。温可观察对象可以想象成是一个冷可观察对象，但在某些条件下变成了热可观察对象。让我们通过引入`refCount()`运算符来看一个这样的例子：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'OK, so we started to use the operator `publish()`, and it looks like we are
    about to use our `connect()` operator and that we have a hot Observable, right?
    Well, yes, but instead of calling `connect()`, we call `refCount()`. This operator
    will warm our Observable up so that when the first subscriber arrives, it will
    act like a cold Observable. OK? That just sounds like a cold Observable, right?
    Let''s have a look at the output first:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以我们开始使用`publish()`运算符，看起来我们即将使用`connect()`运算符，并且有一个热可观察对象，对吧？嗯，是的，但我们的做法不是调用`connect()`，而是调用`refCount()`。这个运算符会加热我们的可观察对象，使得当第一个订阅者到来时，它会表现得像冷可观察对象。好吗？这听起来就像一个冷可观察对象，对吧？让我们先看看输出结果：
- en: '![](img/db091650-11ef-4095-b8e9-65cd305e6bef.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db091650-11ef-4095-b8e9-65cd305e6bef.png)'
- en: 'To answer the preceding question, yes, it''s correct that it just behaves like
    a cold Observable; we aren''t missing out on any emitted values. The interesting
    thing happens when we get a second subscriber. Let''s add that second subscriber
    and see what the effects are:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答前面的问题，是的，它确实表现得就像一个冷的可观察对象；我们没有错过任何发出的值。有趣的事情发生在我们得到第二个订阅者的时候。让我们添加第二个订阅者，看看会有什么效果：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our second subscriber is added; now, let''s have a look at what the result
    is:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第二位订阅者被添加；现在，让我们看看结果是什么：
- en: '![](img/152ed024-9bf4-44ae-89a5-96fb02bf1d4f.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/152ed024-9bf4-44ae-89a5-96fb02bf1d4f.png)'
- en: What we can see from the results above is that the first subscriber is alone
    in receiving the number `0`. When the second subscriber arrives, its first value
    is `1`, which proves the stream has gone from acting like a cold Observable to
    a hot Observable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的结果中我们可以看到，第一位订阅者是唯一接收数字`0`的人。当第二位订阅者到来时，它的第一个值是`1`，这证明了流从表现得像冷可观察对象转变为热可观察对象。
- en: 'There is another way we can do warm Observables, and that is through using
    the `share()` operator. The `share()` operator can be seen as more of a smart
    operator that allows our Observable to go from cold to hot, depending on the situation.
    That can be a really great idea sometimes. So, there are the following situations
    for Observables:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用`share()`运算符来做温可观察对象。`share()`运算符可以看作是一个更智能的运算符，它允许我们的可观察对象根据情况从冷状态变为热状态。有时候这确实是个好主意。所以，对于可观察对象有以下几种情况：
- en: Created as a hot Observable; the stream hasn't completed, and none of the subscribers
    are more than one
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为热可观察对象创建；流还没有完成，而且没有任何订阅者的订阅次数超过一次
- en: Falls back into being a cold Observable; any previous subscription has had time
    to end before a new subscription arrives
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回退为冷可观察对象；在新的订阅到达之前，任何之前的订阅都已经结束
- en: Created as a cold Observable; the Observable itself has had time to complete
    before the subscription happens
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为冷可观察对象（cold Observable）创建；在订阅发生之前，可观察对象本身已经完成
- en: 'Let''s try to show in code how the first bullet can happen:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用代码来展示第一点可以发生的情况：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding code describes a situation where we defined a stream with a subscription
    that happens straight away. The second subscription happens after one second.
    Now, according to the definition of the `share()` operator, this means that the
    stream will be created as a cold Observable, but will, at the time of the second
    subscriber, be turned into a hot Observable, as there is a pre-existing subscriber
    and the stream has yet to complete. Let''s inspect our output to verify that this
    is the case:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码描述了一种情况，我们定义了一个带有立即发生的订阅的流。第二个订阅在一秒后发生。现在，根据`share()`操作符的定义，这意味着流将作为一个冷可观察对象创建，但在第二个订阅者到达时，它将变成热可观察对象，因为有一个预先存在的订阅者，并且流尚未完成。让我们检查我们的输出以验证这一点：
- en: '![](img/3bef68a1-abca-490f-9274-b52f2a7be5d1.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3bef68a1-abca-490f-9274-b52f2a7be5d1.png)'
- en: The first subscriber seems to be clearly alone in the values it gets. When the
    second subscriber arrives, it seems to share the producer, as it doesn't start
    from zero, but, rather, it starts listening where the first subscriber is.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个订阅者似乎在它得到的值中是明显独立的。当第二个订阅者到达时，它似乎与生产者共享，因为它不是从零开始，而是从第一个订阅者所在的位置开始监听。
- en: Subjects
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主题（Subjects）
- en: 'We are used to using Observables in a certain way. We construct them from something
    and we start listening to values that they emit. There is usually very little
    we can do to affect what is being emitted after the point of creation. Sure, we
    can change it and filter it, but it is next to impossible to add more to our `Observable`
    unless we merge it with another stream. Let''s have a look at when we are really
    in control of what is being emitted when it comes to Observables, using the `create()`
    operator:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们习惯于以某种方式使用可观察对象（Observables）。我们从某个东西构建它们，并开始监听它们发出的值。通常，我们几乎无法在创建点之后影响正在发出的内容。当然，我们可以改变和过滤它，但除非我们将它与其他流合并，否则几乎不可能向我们的`Observable`添加更多内容。让我们看看当我们真正控制可观察对象（Observables）发出内容时的情况，使用`create()`操作符：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We see the Observable acting as a wrapper around the thing that really emits
    our values, the Observer. In our Observer instance, the Observer is calling `next()`,
    with a parameter to emit values – values that we listen to in our `subscribe()`
    method.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到可观察对象（Observable）就像一个包装器，围绕真正发出我们值的对象——观察者（Observer）。在我们的观察者实例中，观察者正在调用`next()`，并传递一个参数来发出值——这些值是我们通过`subscribe()`方法监听的。
- en: 'This section is about the Subject. The Subject differs from the Observable
    in that it can affect the content of the stream after its creation. Let''s have
    a look at just that with the following piece of code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是关于主题（Subject）的。主题与可观察对象（Observable）的不同之处在于它可以在创建后影响流的内容。让我们通过以下代码片段来看看这一点：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first thing we notice is how we just call the constructor instead of using
    a factory method like `create()` or `from()` or similar, as we do on an Observable.
    The second thing we notice is how we subscribe to it on the second line, and only
    on the last line do we emit values by calling `next()`. Why is the code written
    in this order? Well, if we didn''t write it this way and have the `next()` call
    happen as the second thing, our subscription wouldn''t be there, and the value
    would have been emitted straight away. We know two things for sure, though: we
    are calling `next()`, and we are calling `subscribe()`, which makes `Subject`
    a double nature. We did mention another thing the `Subject` was capable of: changing
    the stream after creation. Our call to `next()` is literally doing that. Let''s
    add a few more calls so we ensure we really get the idea:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先注意到的是，我们只是调用构造函数，而不是像在可观察对象（Observable）上那样使用`create()`或`from()`等工厂方法。第二件事是我们注意到在第二行我们订阅了它，而只有在最后一行我们才通过调用`next()`来发出值。为什么代码要按照这种顺序编写呢？好吧，如果我们不这样写，并且`next()`调用发生在第二件事，我们的订阅就不会存在，值会立即发出。尽管如此，我们知道两件事是确定的：我们正在调用`next()`，我们正在调用`subscribe()`，这使得`Subject`具有双重性质。我们之前还提到`Subject`能够做到的另一件事：在创建后改变流。我们的`next()`调用实际上就是在做这件事。让我们添加更多的调用，以确保我们真正理解这个概念：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we stated before, all the calls we make to the `next()` method enable us
    to affect the stream; we see in our `subscribe()` method that every call to `next()`
    leads to the `subscribe()` being hit, or, technically, the first function we pass
    into it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所述，我们对`next()`方法的每一次调用都能影响流；我们在`subscribe()`方法中看到，每次对`next()`的调用都会触发`subscribe()`，或者技术上，我们传递给它的第一个函数。
- en: Using Subject for cascading lists
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用主题进行级联列表
- en: 'So, what''s the point? Why should we use Subjects over Observables? That''s
    actually a quite deep question. There are many ways of solving most streaming-related
    problems; problems where it is tempting to use a Subject can often be solved through
    some other way. Let''s have a look at what you could be using it for, though.
    Let''s talk about cascading drop-down lists. What we mean by that is that we want
    to know what restaurants exist in a city. Imagine, therefore, that we have a drop-down
    list that allows us to select what country we are interested in. Once we select
    a country, we should select the city we are interested in from a drop-down list
    of cities. Thereafter, we get to select from a list of restaurants, and, finally,
    pick the restaurant that interests us. In the markup, it most likely looks like
    this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，重点是什么？为什么我们应该使用主题而不是可观察对象？这实际上是一个相当深刻的问题。解决大多数与流相关的问题有很多方法；对于那些诱使我们使用主题的问题，通常可以通过其他方式解决。尽管如此，让我们看看我们可以用它来做什么。让我们来谈谈级联下拉列表。我们所说的意思是，我们想知道一个城市中存在哪些餐馆。想象一下，因此，我们有一个下拉列表，允许我们选择我们感兴趣的国家。一旦我们选择了一个国家，我们应该从城市下拉列表中选择我们感兴趣的城市。然后，我们可以从餐馆列表中进行选择，最后选择我们感兴趣的餐馆。在标记中，它可能看起来像这样：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At the start of the application, we haven''t selected anything, and the only
    drop-down list that is selected is the first one, and it is filled with countries.
    Imagine that we therefore set up the following code in JavaScript:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开始时，我们还没有选择任何内容，唯一被选中的下拉列表是第一个，它填充了国家。想象一下，因此，我们在JavaScript中设置了以下代码：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At this point, we have established that we want to listen to the selected events
    of each drop-down list, and we want, in the cases of countries or cities droplist,
    filter the upcoming droplist. Say we select a specific country then we want to
    repopulate/filter the cities droplist so that it only shows cities for the selected
    country. For the restaurant drop-down list, we want to perform a booking based
    on our restaurant selection. Sounds pretty simple, right? We need some subscribers.
    The cities drop-down list needs to listen to changes in the countries drop-down
    list. So we add that to our code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经确定我们想要监听每个下拉列表的选择事件，并且我们想要在国家和城市下拉列表的情况下过滤即将到来的下拉列表。比如说我们选择了一个特定的国家，那么我们希望重新填充/过滤城市下拉列表，使其只显示所选国家的城市。对于餐馆下拉列表，我们希望根据我们的餐馆选择进行预订。听起来很简单，对吧？我们需要一些订阅者。城市下拉列表需要监听国家下拉列表的变化。因此，我们将此添加到我们的代码中：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, here, we have a behavior of performing an AJAX request when we select a
    country; we get a filtered list of cities, and we introduce the new subject instance
    `cities$`. We call the `next()` method on it with our filtered cities as a parameter.
    Finally, we listen to changes to the `cities$` stream by calling the `subscribe()`
    method on the stream. As you can see, when data arrives, we rebuild our cities
    drop-down list there.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，当我们选择一个国家时，我们有一个执行AJAX请求的行为；我们得到一个过滤后的城市列表，并引入新的主题实例`cities$`。我们用过滤后的城市作为参数调用它的`next()`方法。最后，我们通过在流上调用`subscribe()`方法来监听`cities$`流的变化。如您所见，当数据到达时，我们在那里重建我们的城市下拉列表。
- en: 'We realize that our next step is to react to changes from us doing a selection
    in the cities drop-down list. So, let''s set that up:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们意识到我们的下一步是响应我们在城市下拉列表中进行选择时的变化。所以，让我们设置一下：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, we added some code to react to a selection being made
    in our cities drop-down list. We also added some code to listen to changes in
    the `restaurants$` stream, which finally led to our restaurants drop-down list
    being repopulated. The last step is to listen to changes on us selecting a restaurant
    in the restaurants drop-down list. What should happen here is up to you, dear
    reader. A suggestion is that we query some API for the selected restaurant''s
    opening hours, or its menu. Use your creativity. We will leave you with some final
    subscription code, though:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了一些代码来响应我们城市下拉列表中的选择。我们还添加了一些代码来监听`restaurants$`流的变化，这最终导致了我们的餐厅下拉列表被重新填充。最后一步是监听我们在餐厅下拉列表中选择餐厅时的变化。这里应该发生什么取决于你，亲爱的读者。一个建议是查询一些API以获取所选餐厅的营业时间或菜单。发挥你的创造力。不过，我们将给你一些最终的订阅代码：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This became a quite long code example, and it should be said that this is not
    the best way of solving a problem like this, but it does demonstrate how a Subject
    works: it can add value to the stream when it wants, and it can be subscribed
    to.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例相当长，应该指出的是，这并不是解决这类问题的最佳方式，但它确实展示了Subject的工作原理：它可以在想要的时候向流中添加值，并且可以被订阅。
- en: BehaviorSubject
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BehaviorSubject
- en: 'So far, we have been looking at the default type of Subject, and we have uncovered
    a little of its secrets. However, there are many more types of Subjects. One such
    interesting type of Subject is the `BehaviorSubject`. So, why do we need a `BehaviorSubject`,
    and for what? Well, when dealing with a default Subject, we are able to add values
    to the stream, as well as subscribe to the stream. The `BehaviorSubject` gives
    us some added capabilities, in the form of:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在查看Subject的默认类型，并揭露了一些它的秘密。然而，还有许多其他类型的Subject。其中一种有趣的Subject类型是`BehaviorSubject`。那么，为什么我们需要`BehaviorSubject`，它有什么用呢？好吧，当我们处理默认Subject时，我们能够向流中添加值，以及订阅流。`BehaviorSubject`给我们提供了一些额外的能力，形式如下：
- en: A starter value, which is great if we are able to show something to the UI while
    waiting for an AJAX call to finish
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个起始值，如果我们能在等待AJAX调用完成时向UI展示一些内容，那就太好了
- en: We can query on the latest value; in some situations, it is interesting to know
    what the last emitted value was
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以查询最新值；在某些情况下，知道最后一个发出的值是什么很有趣
- en: 'To address the first bullet, let''s write some code and showcase this capability:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 针对第一个要点，让我们编写一些代码并展示这一功能：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ReplaySubject
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReplaySubject
- en: 'With a normal Subject, it matters when we start subscribing. If we start emitting
    values before our subscription is set up, those values are simply lost. If we
    have a `BehaviorSubject`, we have a somewhat better scenario. Even if we are late
    in subscribing, so a value has already been emitted, the very last emitted value
    is still possible to gain access to. Then the following question arises: What
    if two or more values are emitted before a subscription happens and we care about
    those values – what then?'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个普通的Subject，我们开始订阅的时间很重要。如果我们在我们设置订阅之前开始发出值，这些值就会简单地丢失。如果我们有一个`BehaviorSubject`，我们有一个稍微好一点的场景。即使我们订阅得晚，已经发出了一个值，我们仍然可以访问到最后一个发出的值。那么，接下来的问题是：如果在订阅发生之前发出了两个或更多值，而我们又关心这些值，那么会发生什么？
- en: 'Let''s illustrate this scenario and see what happens with a Subject and `BehaviorSubject`,
    respectively:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个场景来展示Subject和`BehaviorSubject`分别会发生什么：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'What we can see from the preceding code is that Subject is not a good candidate
    if we care about values prior to us subscribing. The `BehaviorSubject` constructors
    are slightly better for that scenario, but if we really care about prior values,
    and a lot of them, then we should have a look at the `ReplaySubject`. The `ReplaySubject`
    has the ability to specify two things: a buffer size and a window size. A buffer
    size is simply the amount of values it should remember from the past, and the
    window size specifies for how long it should remember them for. Let us demonstrate
    this in code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中我们可以看到，如果我们关心在我们订阅之前的值，Subject不是一个好的选择。`BehaviorSubject`构造函数在这种情况下稍微好一些，但如果我们真的关心之前的值，而且有很多这样的值，那么我们应该看看`ReplaySubject`。`ReplaySubject`有能力指定两件事：缓冲大小和窗口大小。缓冲大小简单地说是它应该记住过去多少个值，窗口大小指定了它应该记住它们多长时间。让我们通过代码来展示这一点：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we can see how we emit `2` and `3`, that is, the two
    latest emitted values. This is due to the fact that we specify the buffer size
    in the `ReplaySubject` constructor to be 2\. The only value we loose out on is
    1\. Had we, on the other hand, specified a 3 in our constructor, all three values
    would have reached the subscriber. So much for the buffer size and how that works;
    what about the window size property? Let''s illustrate how that works with the
    following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们发射了 `2` 和 `3`，即最后两个发射的值。这是因为我们在 `ReplaySubject` 构造函数中指定了缓冲区大小为
    2。我们唯一丢失的值是 1。相反，如果我们构造函数中指定了 3，那么所有三个值都会到达订阅者。关于缓冲区大小及其工作原理就这么多；那么窗口大小属性呢？让我们用以下代码来说明它是如何工作的：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we specify the window size as 2,000 milliseconds; that is how long the
    values should be held in the buffer. We can see below that we delay the creation
    of our subscription to occur after 2,010 milliseconds. The end result of this
    is that no values will be emitted, as the buffer will have been emptied before
    the subscription has time to occur. A higher value of the window size would have
    fixed this issue.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将窗口大小指定为 2,000 毫秒；这就是值应该在缓冲区中保持多长时间。我们可以在下面看到，我们延迟订阅的创建，使其在 2,010 毫秒后发生。结果是，不会发射任何值，因为缓冲区在订阅发生之前就已经清空了。窗口大小的更高值本可以解决这个问题。
- en: AsyncSubject
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AsyncSubject
- en: 'The `AsyncSubject` has a capacity of one, which means we can emit a ton of
    values, but only the latest one is something that is stored. It isn''t really
    lost, either, but you won''t see it unless you complete the stream. Let''s look
    at a piece of code that illustrates just this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncSubject` 的容量为 1，这意味着我们可以发射大量的值，但只有最新的一个值会被存储。实际上，它也没有真正丢失，除非你完成流。让我们看看一段代码，它正好说明了这一点：'
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Earlier, we had fours values being emitted, but nothing seems to reach the
    subscriber. At this point, we don''t know whether this is because it just acts
    like a subject and throws away all emitted values that happen before a subscription
    or not. Let''s therefore call the `complete()` method and see how that plays out:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们发射了四个值，但似乎没有任何东西到达订阅者。在这个时候，我们不知道这是因为它就像一个主题，扔掉了在订阅之前发生的所有发射的值，还是不是这样。因此，让我们调用
    `complete()` 方法，看看结果如何：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will emit a `4` due to the fact that `AsyncSubject` only remembers the
    last value and we are calling the `complete()` method, thereby signaling the completion
    of the stream.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发射一个 `4`，因为 `AsyncSubject` 只记得最后一个值，而我们正在调用 `complete()` 方法，从而发出流完成的信号。
- en: Error handling
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: Error handling is a very big topic. It is an area that is easy to underestimate.
    Normally, when coding, we could be led to believe we just need to do certain things,
    such as ensure we don't have syntax errors or runtime errors. With streams, we
    mostly think of runtime errors. The question is, how should we act when an error
    occurs? Should we pretend like it rains and just throw the error away? Should
    we hope for a different outcome if we try the same code some time in the future,
    or should we maybe just give up when a certain type of error exists? Let's try
    to collect our thoughts and look at the different error approaches that exist
    within RxJS.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理是一个非常大的话题。这是一个容易被低估的领域。通常，在编码时，我们可能会认为我们只需要做某些事情，比如确保我们没有语法错误或运行时错误。对于流来说，我们主要考虑运行时错误。问题是，当发生错误时，我们应该怎么做？我们应该假装下雨，只是扔掉错误吗？我们应该希望在未来尝试相同的代码时得到不同的结果，或者当存在某种类型的错误时，我们可能只是放弃？让我们尝试整理我们的思路，看看
    RxJS 中存在的不同错误处理方法。
- en: Catch and continue
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获并继续
- en: 'Sooner or later, we will have a stream that will throw an error. Let''s see
    what that can look like:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 总有一天，我们会遇到一个会抛出错误的流。让我们看看它可能是什么样子：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding code, we set up a scenario where we first emit a value, followed
    by emitting an error. The first value is captured in our first callback in our
    subscribe method. The second emitted thing, the error, is captured by our error
    callback. The third emitted value does not get emitted to our subscriber because
    our stream has been interrupted by the error. There is something we can do here,
    and that is to use the `catch()` operator. Let''s apply that to our stream and
    see what happens:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们设置了一个场景，首先发射一个值，然后发射一个错误。第一个值被捕获在我们的 `subscribe` 方法中的第一个回调中。第二个发射的内容，即错误，被我们的错误回调捕获。第三个发射的值没有发送给我们的订阅者，因为我们的流已经被错误中断。我们可以在这里做的是使用
    `catch()` 操作符。让我们将其应用到我们的流中，看看会发生什么：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we capture our error with the `catch()` operator. In the `catch()` operator,
    we take our error and emit it as a normal Observable using the `of()` operator.
    What happens to the `2` we emit, though? Still no luck with that one. The `catch()`
    operator is able to take our error and turn it into a normal emitted value; instead
    of an error, we don't get all the values from the stream.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`catch()`操作符捕获错误。在`catch()`操作符中，我们取我们的错误，并使用`of()`操作符将其作为正常的Observable发出。那么我们发出的`2`会发生什么呢？仍然没有成功。`catch()`操作符能够将我们的错误转换为一个正常的发出值；而不是错误，我们不会从流中获得所有值。
- en: 'Let''s have a look at a scenario when we are dealing with multiple streams:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们处理多个流时的一个场景：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the scenario above, we merge three streams. The first stream emits the number
    `1` and nothing else gets emitted. This is due to our second stream tearing everything
    down, as it emits an error. Let''s try to apply our newfound `catch()` operator
    and see what happens:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述场景中，我们合并了三个流。第一个流只发出数字`1`，没有其他任何东西被发出。这是因为我们的第二个流将所有内容都拆除了，因为它发出了一个错误。让我们尝试应用我们新发现的`catch()`操作符，看看会发生什么：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We run the above code and we notice that the `1` is emitted, the error is emitted
    as a normal value, and, finally, even the `2` is emitted. Our conclusion here
    is that it is a good idea to apply a `catch()` operator to a stream before it
    is being merged with our streams.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行上述代码，并注意到`1`被发出，错误作为一个正常值被发出，最后甚至`2`也被发出了。我们的结论是，在流被合并到我们的流之前应用一个`catch()`操作符是一个好主意。
- en: As before, we can also conclude that the `catch()` operator is able to stop
    the stream from just erroring out, but that other values that would have been
    emitted after the error are effectively lost.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们也可以得出结论，`catch()`操作符能够阻止流仅仅因为错误而停止，但错误之后本应发出的其他值实际上已经丢失了。
- en: Ignoring the error
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽略错误
- en: 'As we saw in the former section, the `catch()` operator does a good job of
    ensuring that a stream that errors out doesn''t cause any problems when being
    merged with another stream. The `catch()` operator enables us to take the error,
    investigate it, and create a new Observable that will emit a value as though nothing
    happened. Sometimes, however, you don''t want to even deal with streams that error
    out. For such a scenario, there is a different operator, called `onErrorResumeNext()`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`catch()`操作符在确保一个发生错误的流在与其他流合并时不会引起任何问题方面做得很好。`catch()`操作符使我们能够捕获错误，调查它，并创建一个新的Observable，它将发出一个值，就像什么都没发生一样。然而，有时你甚至不想处理发生错误的流。对于这样的场景，有一个不同的操作符，称为`onErrorResumeNext()`：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The implication of using the `onErrorResumeNext()` operator is that the second
    stream, the one that emits an error, gets completely ignored, and the values `1`
    and `2` get emitted. This is a very nice operator to use if your scenario is only
    about caring for the streams that do not error out.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`onErrorResumeNext()`操作符的含义是，第二个流，即发出错误的那个流，被完全忽略，而值`1`和`2`被发出。如果你的场景只是关心不发生错误的流，这是一个非常好的操作符。
- en: Retry
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重试
- en: 'There are different reasons why you would want to retry a stream. It''s easier
    to imagine why you would want to if your stream is dealing with AJAX calls. Network
    connections may be unreliable at times with the local network you are on, or the
    service you are trying to hit may be temporarily down for some reason. Regardless
    of the reason, you have a situation where hitting that endpoint will some of the
    time reply with an answer, and some of the time return a 401 error. What we are
    describing here is the business case for adding retry logic to your streams. Let''s
    have a look at a stream designed to fail:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能出于不同的原因想要重试一个流。如果你的流正在处理AJAX调用，更容易想象为什么你想要这样做。有时，你所在的本地网络可能不可靠，或者你试图调用的服务可能因为某些原因暂时关闭。无论原因如何，你都会遇到一种情况，即调用该端点有时会回复答案，有时会返回401错误。我们在这里描述的是在流中添加重试逻辑的业务案例。让我们看看一个设计来失败的流：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output of the code above is the value `1` being emitted four times, followed
    by our error. What happens is that our streams'' values are retried three times
    before the error callback is hit in the subscribe. Using the `retry()` operator
    delays when the error is actually treated as an error. The preceding example doesn''t
    make sense to retry, though, as the error will always occur. Therefore, let''s
    take a better example – an AJAX call where the network connection may come and
    go:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出是值`1`被发出四次，然后是我们的错误。发生的情况是我们流的值在错误回调被触发之前被重试了三次。使用`retry()`操作符延迟了错误实际上被视为错误的时间。然而，前面的例子没有重试的必要，因为错误总是会发生的。因此，让我们看看更好的例子——一个网络连接可能会来也可能去的AJAX调用：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, we are attempting an AJAX request towards a file that doesn''t seem to
    exist. Having a look at the console, we are faced with the following result:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们尝试对似乎不存在的文件发起一个AJAX请求。查看控制台，我们遇到了以下结果：
- en: '![](img/1abf96ff-ea61-4bd1-a20b-f276d562a645.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1abf96ff-ea61-4bd1-a20b-f276d562a645.png)'
- en: 'What we see in the above logging are four failed AJAX requests that lead to
    an error. We have essentially just switched our simple stream to a more credible
    AJAX request stream, with the same behavior. Should the file suddenly start to
    exist, we may have a scenario with two failed attempts and one successful attempt.
    Our approach has a flaw, though: we retry our AJAX attempts far too often. If
    we are actually dealing with an intermittent network connection, we need to have
    some kind of delay between attempts. It is reasonable to set a delay between attempts
    of at least 30 seconds or more. We can accomplish that by using a slightly different
    retry operator that takes milliseconds rather than a number of attempts as an
    argument. It looks like the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的日志中，我们看到有四个失败的AJAX请求导致了错误。我们实际上已经将我们的简单流转换成了一个更可靠的AJAX请求流，具有相同的行为。如果文件突然开始存在，我们可能会遇到两次失败尝试和一次成功尝试的情况。然而，我们的方法有一个缺陷：我们过于频繁地重试我们的AJAX尝试。如果我们实际上在处理间歇性网络连接，我们需要在尝试之间设置某种延迟。尝试之间至少设置30秒或更长时间的延迟是合理的。我们可以通过使用一个稍微不同的重试操作符来实现这一点，该操作符接受毫秒数而不是尝试次数作为参数。它看起来如下所示：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What we do here is use the operator `retryWhen()`. The `retryWhen()` operator's
    mission in life is to return a stream. At this point, you can manipulate the stream
    it returns by appending a `.delay()` operator that takes a number of milliseconds.
    The result from doing so is that it will retry the AJAX call for all eternity,
    which may not be what you want.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的是`retryWhen()`操作符。`retryWhen()`操作符在其生命周期中的任务是返回一个流。在这个点上，你可以通过附加一个`.delay()`操作符来操作它返回的流，该操作符接受毫秒数。这样做的结果是它将无限期地重试AJAX调用，这可能不是你想要的。
- en: Advanced Retry
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级重试
- en: 'What we most likely want is to combine the delay between retry attempts with
    being able to specify how many times we want to retry the stream. Let''s have
    a look at how we can accomplish that:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最可能想要的是将重试尝试之间的延迟与指定我们想要重试流多少次的能力结合起来。让我们看看我们如何实现这一点：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The interesting part here is that we use the operator `.take()`. We specify
    the number of emitted values we want from this inner Observable. We have now accomplished
    a nice approach in which we are able to control the number of retries and the
    delay between retries. There is an aspect to this that we haven''t tried, namely,
    how we want all the retries to end when it finally gives up. In the preceding
    code, the stream just completes after the stream is retried after *x* number of
    times with no successful result. However, we may want the stream to error out
    instead. We can accomplish this by just adding an operator to the code, like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的部分是我们使用了`.take()`操作符。我们指定了从这个内部可观察对象中想要发出的值的数量。我们现在已经实现了一种很好的方法，使我们能够控制重试次数和重试之间的延迟。这个方法有一个我们没有尝试的方面，即我们希望所有重试何时结束。在前面的代码中，流在经过*x*次重试并且没有成功结果后只是完成了。然而，我们可能希望流出错。我们可以通过向代码中添加一个操作符来实现这一点，如下所示：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we are adding a `concat()` operator that adds a stream that just fails.
    So we are guaranteed, after three failed attempts, to have an error happen. This
    is usually a better approach than having the stream silently complete after *x*
    number of failed attempts.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个`concat()`操作符，它添加了一个只失败的流。因此，我们保证在三次失败尝试后会发生错误。这通常比在*x*次失败尝试后流默默地完成要好。
- en: This isn't a perfect approach, though; imagine that you want to investigate
    what type of error you get back. In the case of AJAX requests being made, it matters
    whether we get a 400-something error or a 500-something error back as HTTP status
    code. They mean different things. With 500 errors, something is very wrong on
    the backend, and we probably want to give up straight away. With a 404 error,
    however, this implies the resource isn't there, but in the case with an intermittent
    network connection, this means the resource can't be reached due to our connection
    being offline. For that reason, a 404 error might be worth retrying. To solve
    that in code, we need to inspect the value being emitted to determine what to
    do. We can inspect values using the `do()` operator.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是一个完美的方法；想象一下，你想调查你得到什么类型的错误。在 AJAX 请求的情况下，我们得到的 HTTP 状态码是 400 多还是 500 多，这很重要。它们意味着不同的事情。对于
    500 错误，后端可能出了大问题，我们可能想立即放弃。然而，对于 404 错误，这表明资源不存在，但在间歇性网络连接的情况下，这意味着由于我们的连接离线，资源无法访问。因此，404
    错误可能值得重试。要在代码中解决这个问题，我们需要检查发出的值以确定要做什么。我们可以使用 `do()` 操作符来检查值。
- en: 'In the following code, we investigate the type of HTTP status of the response
    and determine how to handle it:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们调查响应的 HTTP 状态类型并确定如何处理它：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Marble testing
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Marble 测试
- en: Testing asynchronous code can be challenging. For one, we have the time factor.
    The way we specify what operators to use for our crafted algorithm leads to the
    algorithm taking anywhere from 2 seconds to 30 minutes to execute. Therefore,
    it will at first feel like there is no point in testing it, because it can't be
    done within a reasonable time. We have a way to test RxJS, though; it is called
    Marble testing and it allows us to control how fast time passes so we have a test
    that can execute it in milliseconds.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 测试异步代码可能具有挑战性。一方面，我们有时间因素。我们指定用于我们精心设计的算法的操作符的方式导致算法执行时间从 2 秒到 30 分钟不等。因此，一开始可能会觉得测试它没有意义，因为它无法在合理的时间内完成。尽管如此，我们有一种测试
    RxJS 的方法；它被称为 Marble 测试，它允许我们控制时间流逝的速度，以便我们可以在毫秒内执行测试。
- en: The idea of a Marble is known to us. We can represent one or many streams and
    the effect an operator has one two or more streams. We do this by drawing the
    streams as a line and values as circles on the lines. The operator is shown as
    verb below the input streams. Following operator is a third stream, the result
    of taking the input streams and applying the operator, a so - called marble diagram.
    The line represents a continuous timeline. We take this concept and bring it to
    testing. What this means is that we can express our incoming values as a graphical
    representation and apply our algorithm to it and assert on the result.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道了 Marble 的概念。我们可以表示一个或多个流以及操作符对一或多个流产生的影响。我们通过将流绘制成线条，将值绘制成线条上的圆圈来实现这一点。操作符显示在输入流下面的动词。接下来的操作符是一个第三流，即通过将输入流应用操作符得到的结果，也就是所谓的
    marble 图。线条代表一个连续的时间线。我们采用这个概念并将其应用于测试。这意味着我们可以将我们的输入值表示为图形表示，并对其应用我们的算法，然后对结果进行断言。
- en: Set up
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: 'Let''s set up our environment correctly so we can write marble tests. We need
    the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们正确设置我们的环境，以便我们可以编写 marble 测试。我们需要以下内容：
- en: The NPM library jasmine-marbles
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPM 库 jasmine-marbles
- en: A scaffolded Angular application
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搭建 Angular 应用程序
- en: 'With that we scaffold our Angular project, like so:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们搭建了我们的 Angular 项目，如下所示：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After the project has been scaffolded, it''s time to add our NPM library, like
    so:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目搭建完成后，是时候添加我们的 NPM 库了，如下所示：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now we have finished the setup, so the time has come to write tests.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了设置，所以是时候编写测试了。
- en: Writing your first marble test
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你的第一个 marble 测试
- en: 'Let''s create a new file `marble-testing.spec.ts`. It should look like the
    following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的文件 `marble-testing.spec.ts`。它应该看起来像以下这样：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A lot of interesting things are happening here. We import the function `cold()`
    from the NPM library marble-testing. Thereafter we set up a test suite by calling
    `describe()`, followed by a test specification, by calling `it()`. Then we call
    our `cold()` function and provide it a string. Let''s have a close look at that
    function call:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里正在发生许多有趣的事情。我们从 NPM 库 marble-testing 中导入 `cold()` 函数。之后，我们通过调用 `describe()`
    来设置测试套件，然后通过调用 `it()` 来指定测试规范。然后我们调用我们的 `cold()` 函数并给它提供一个字符串。让我们仔细看看这个函数调用：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The above code set up a stream that expects to values to be emitted followed
    by the stream ending. How do we know that? It's time to explain what `x-x|` means.
    `x` is just any value, the hyphen `-` means time has passed. The pipe `|` means
    our stream has ended. The second argument in the cold function is a mapping object
    that tells us what the x means. In this case, it has come to mean the value 1\.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码设置了一个期望发出两个值然后流结束的流。我们如何知道这一点？现在是时候解释 `x-x|` 的含义了。`x` 是任何值，横线 `-` 表示时间已经过去。管道
    `|` 表示我们的流已经结束。在 `cold` 函数的第二个参数是一个映射对象，它告诉我们 `x` 的含义。在这种情况下，它已经意味着值 1。
- en: 'Moving on, let''s have a look at the next line:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看下一行：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding code applies the operator `.map()` and increased the value with
    one for each value emitted in the stream. Thereafter, we call the `.toBeObservable()`
    helper method and verify it against an expected condition,
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应用了 `.map()` 操作符，并将每个在流中发出的值增加了一个。之后，我们调用 `.toBeObservable()` 辅助方法，并验证它是否满足预期的条件，
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The previous condition states that we expect the stream to should emit two values,
    but that the values should now have the number 2\. This makes sense, as our `map()`
    function performs just that.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的状态表明我们期望流应该发出两个值，但这两个值现在应该具有数字 2。这很有道理，因为我们的 `map()` 函数正是这样做的。
- en: Fleshing out with more tests
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过更多的测试来完善
- en: 'Let''s write one more test. This time we will be testing the `filter()` operator.
    This one is interesting, as it filters away values that does not fulfill a certain
    condition. Our test file should now look like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再写一个测试。这次我们将测试 `filter()` 操作符。这个操作符很有趣，因为它会过滤掉不满足特定条件的值。我们的测试文件现在应该看起来像下面这样：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This test is set up in pretty much the same way as our first test. This time
    we use the `filter()` operator but what stands out is our expected stream:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的设置基本上和我们的第一个测试一样。这次我们使用 `filter()` 操作符，但突出的是我们期望的流：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`--y`, means that our first values is removed. Based on how the filter condition
    is defined, we are not surprised. The reason for the double hyphen, `-`, though,
    is that time still passes, but instead of an emitted value a hyphen takes its
    place.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`--y` 表示我们的第一个值被移除了。根据过滤器条件的定义，我们并不感到惊讶。然而，双横线 `-` 的原因是因为时间仍在流逝，但取而代之的是横线本身代替了发出的值。'
- en: To learn more about Marble testing, have a look at the following link from the
    official documentation, [https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md](https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Marble 测试的信息，请查看官方文档中的以下链接，[https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md](https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md)
- en: Pipeable operators
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可连接的操作符
- en: 'We haven''t mentioned it much so far, but the RxJS library weighs in quite
    heavily when used in an app. In today''s world of mobile first, every kilobyte
    counts when it comes to libraries that you include in your app. They count because
    the user may be on a 3G connection, and if it takes too long to load, your user
    may leave, or just may end up not liking your app, as it feels slow to load, and
    this may cause you to have bad reviews or lose users. So far, we have used two
    different ways of importing RxJS:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有过多地提到它，但 RxJS 库在应用中使用时相当重。在当今以移动为先的世界里，当你将库包含到你的应用中时，每个千字节都很重要。这是因为用户可能在使用
    3G 连接，如果加载时间过长，用户可能会离开，或者最终可能不喜欢你的应用，因为它感觉加载缓慢，这可能会导致你收到差评或失去用户。到目前为止，我们已经使用了两种不同的方式来导入
    RxJS：
- en: Importing the whole library; this one is quite costly in terms of size
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入整个库；这在大小方面相当昂贵
- en: Importing only the operators we need; this ensures that the bundle decreases
    significantly
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只导入我们需要的操作符；这确保了包的大小显著减小
- en: 'The different options have looked like this, for importing the whole library
    and all its operators:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的选项看起来是这样的，用于导入整个库及其所有操作符：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Or like this, to only import what we need:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 或者像这样，只导入我们需要的：
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'That looks good, right? Well, yes, but it is a flawed approach. Let''s explain
    what happens when you type:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不错，是吗？嗯，是的，但这是一种有缺陷的方法。让我们解释一下当你输入以下内容时会发生什么：
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'By typing the preceding, we add to the prototype of the `Observable`. Looking
    in the source code for RxJS, it looks like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入上述代码，我们向 `Observable` 的原型中添加了内容。查看 RxJS 的源代码，它看起来像这样：
- en: '[PRE45]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As you can see from the preceding code, we import the `Observable` as well
    as the operator in question and we add the operator to the prototype by assigning
    it to a `map` property on the prototype. What''s flawed with that, you might wonder?
    The problem is tree shaking, a process we use to get rid of unused code. Tree
    shaking has a hard time determining what you use and don''t use, respectively.
    You may actually import a `map()` operator and it gets added to the Observable.
    As the code changes over time, you may end up not using it anymore. You may argue
    that you should remove the import at that point, but you might have a lot of code,
    and it is easy to overlook. It would be better if only used operators were included
    in the final bundle. It is, as we mentioned before, hard for the tree-shaking
    process to know what is used and what is not, with the current approach. For that
    reason, a big rewrite has happened in RxJS, adding something called pipeable operators,
    which help us with the above problem. There is also another downside to patching
    the prototype, and that is the fact that it creates a dependency. If the library
    changes and the operator is no longer added when we patch it (calling the import),
    then we have a problem. We won''t detect the problem until runtime. We would rather
    be told that the operator has gone through us importing and explicitly using it,
    like so:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码中看到的，我们导入了`Observable`以及相关的操作符，并将操作符添加到原型上，通过将其分配给原型的`map`属性。这有什么问题呢？您可能会想知道？问题是摇树优化，这是我们用来去除未使用代码的过程。摇树优化在确定您使用和未使用的内容方面有困难。您实际上可能导入了`map()`操作符，并将其添加到`Observable`中。随着时间的推移，代码发生变化，您可能不再使用它。您可能会争辩说，在那个时刻您应该移除导入，但是您可能有大量的代码，很容易忽略。如果只有使用的操作符包含在最终的包中会更好。正如我们之前提到的，使用当前方法，摇树优化过程很难知道什么被使用，什么没有被使用。因此，RxJS进行了一次大规模的重写，添加了所谓的可管道操作符，这有助于我们解决上述问题。修补原型的另一个缺点是，它创建了一个依赖。如果库发生变化，当我们修补它（调用导入）时，操作符不再被添加，那么我们就会遇到问题。我们不会在运行时检测到这个问题。我们更愿意被告知操作符已经通过我们导入并显式使用它，如下所示：
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Creating reusable operators with let()
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用let()创建可重用操作符
- en: 'The `let()` operator lets you have the whole operator and operate on it, rather
    than just manipulating the values as you would do with the `map()` operator, for
    example. Using the `let()` operator could look like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`let()`操作符让您拥有整个操作符并对其操作，而不仅仅是像使用`map()`操作符那样操纵值。使用`let()`操作符可能看起来像这样：'
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the preceding example, we were able to define a group of operators such as
    `addAndFilter` and `sub3` and use them on the stream with the `let()` operator.
    This enables us to create composable and reusable operators. It is with this very
    knowledge that we now move on to the concept of pipeable operators.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们能够定义一组操作符，如`addAndFilter`和`sub3`，并使用`let()`操作符在流上使用它们。这使得我们能够创建可组合和可重用的操作符。正是基于这种知识，我们现在继续探讨可管道操作符的概念。
- en: Shifting to pipeable operators
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转向可管道操作符
- en: 'As we mentioned already, pipeable operators are here, and you can find them
    by importing the respective operators from the `rxjs/operators` directory, like
    so:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，可管道操作符已经在这里了，你可以通过从`rxjs/operators`目录导入相应的操作符来找到它们，如下所示：
- en: '[PRE48]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To use it, we are now relying on the `pipe()` operator that we use as the parent
    operator, if you will. Using the preceding operators will therefore look like
    this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，我们现在依赖于作为父操作符的`pipe()`操作符。因此，使用前面的操作符将看起来像这样：
- en: '[PRE49]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has taken us deep into RxJS by covering topics such as hot, cold,
    and warm Observables, and what that generally means in terms of when to subscribe
    to a stream and how they share their Producer under certain conditions. Next up,
    we covered Subjects, and the fact that Observable isn't the only thing you can
    subscribe to. Subjects also allow as to append values to the stream whenever we
    want, and we also learned that there exist different types of Subjects, depending
    on the situation at hand.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过涵盖诸如热、冷和温Observables等主题，深入探讨了RxJS，并讨论了在一般情况下何时订阅流以及它们在特定条件下如何共享生产者。接下来，我们介绍了Subjects，并指出Observable并不是唯一可以订阅的东西。Subjects还允许我们在任何时候向流中追加值，我们还了解到存在不同类型的Subjects，这取决于具体情况。
- en: We ventured deeper into an important topic, testing, and tried to explain the
    difficulty in testing asynchronous code. We talked about the current state of
    the testing situation and what libraries to use here and now for your testing
    scenarios. Lastly, we covered pipeable operators, and our new preferred way of
    importing and composing operators to ensure we end up with the smallest possible
    bundle size.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入探讨了一个重要主题——测试，并尝试解释测试异步代码的难度。我们讨论了当前的测试状况以及现在可以用于测试场景的库。最后，我们介绍了可管道操作符，以及我们新推荐的方式来导入和组合操作符，以确保我们最终得到尽可能小的包大小。
- en: With all this RxJS knowledge, it is now time to take on the Redux pattern and
    its core concepts in the coming chapter, so we are ready to tackle NgRx in the
    final chapter of this book. It's time to get excited, if you weren't before.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了所有这些 RxJS 知识之后，现在是时候在下一章中接受 Redux 模式及其核心概念了，这样我们就可以在本书的最后一章中处理 NgRx。如果你之前还没有感到兴奋，现在是时候激动起来了。
