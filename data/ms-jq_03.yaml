- en: Chapter 3. Organizing Your Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。组织你的代码
- en: To organize or not organize, that's the question…
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 是否组织代码，这是问题…
- en: 'In our journey so far, we''ve covered the various means of downloading jQuery
    and seen how we can override core functionality with custom code, but—to misquote
    that famous detective: how should we organize our code?'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今的旅程中，我们已经涵盖了下载jQuery的各种方式，以及如何用自定义代码覆盖核心功能，但是——误引用那位著名的侦探：我们应该如何组织我们的代码？
- en: Okay, you might think I'm losing the plot here, but bear with me on this; mastering
    a language such as jQuery is not just about producing complex code but about producing
    code that is well structured, concise, and clear to read.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你可能会认为我在这里搞疯了，但请跟我坚持下去；精通jQuery这样的语言不仅仅是制作复杂的代码，而是编写结构良好、简洁、易于阅读的代码。
- en: 'In this chapter, we''re going back to the basics with an introduction to some
    of the design patterns that are available within jQuery. We''ll see how some of
    the techniques discussed in this chapter will help improve your code formatting
    and make you a better coder. In this chapter, we''ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将回到基础，介绍jQuery中可用的一些设计模式。我们将看到本章讨论的一些技术如何帮助改善您的代码格式，并使您成为更好的编码人员。在本章中，我们将涵盖以下主题：
- en: Introducing design patterns and why we should use them
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍设计模式以及为什么我们应该使用它们
- en: Dissecting the structure of a design pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分解设计模式的结构
- en: Exploring some examples of the different design patterns available and the benefits
    of using them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索不同设计模式的一些示例以及使用它们的好处
- en: Exploring the use of patterns within the jQuery library
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索jQuery库中的模式使用
- en: Ready to get started? Let's begin…
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好开始了吗？让我们开始…
- en: Introducing design patterns
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍设计模式
- en: How many times have you viewed a website to stand in awe at the beautiful design,
    only to find that the code looks like the proverbial dog's dinner? A commonly
    held misconception is that appearance is the domain of the designer; this is not
    true, as the design of the code plays an equally important part as well.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少次你看网站时对美丽的设计感到惊叹，只是发现代码看起来像传说中的一团糟？一个常见的误解是外观是设计师的领域；这并不正确，因为代码的设计同样重要。
- en: How can we get around this? Easy, we can use a **design pattern** or a set of
    constructs that help provide a solution and allow us to concentrate more on the
    functionality we want to provide within our project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何绕过这个问题？很简单，我们可以使用**设计模式**或一组构造，帮助提供解决方案，并让我们更专注于项目中想要提供的功能。
- en: 'First created in 1977 by the architect Christopher Alexander, engineers have
    since used the early principles and developed them into what we now know as design
    patterns. This work was further promoted by the **Gang of Four** (**GoF**) in
    their iconic book *Design Patterns: Elements of Reusable Object-Oriented Software*,
    published in 1995.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最初是由建筑师克里斯托弗·亚历山大于1977年创立的，工程师们自那时以来一直使用这些早期原则，并发展成我们现在知道的设计模式。这项工作后来在1995年由**四人组**（GoF）在他们标志性的书籍*设计模式：可复用的面向对象软件元素*中进一步推广。
- en: They helped to not only push the use of design patterns further afield but also
    provided some design techniques and pitfalls; they were also instrumental in providing
    the twenty-three core patterns that are frequently used today (of which, we will
    be covering those that are used within jQuery development). We'll take a look
    at some of the patterns that are in use today, but first, let's answer a simple
    question. What do we really mean by a design pattern and how do they help us to
    write clear and concise code, which reduces unnecessary duplication?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不仅推动了设计模式的应用范围，还提供了一些设计技巧和陷阱；它们还对提供今天经常使用的二十三种核心模式起到了重要作用（其中，我们将涵盖在jQuery开发中常用的模式）。我们将看看今天正在使用的一些模式，但首先，让我们回答一个简单的问题。设计模式真正意味着什么，它们如何帮助我们编写清晰简洁的代码，从而减少不必要的重复？
- en: Defining design patterns
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义设计模式
- en: At a basic level, design patterns take the format of predefined templates or
    a set of reusable principles that help classify different approaches, as part
    of supporting good design.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本层面上，设计模式采用预定义模板或一组可重用原则的格式，帮助对不同方法进行分类，作为支持良好设计的一部分。
- en: 'Why use them? Simple, there are three main benefits to incorporating a design
    pattern into our project:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用它们？很简单，将设计模式纳入我们的项目有三大好处：
- en: '**Design patterns are proven solutions**: They are based on solid approaches
    to solving an issue in software development and are based on the experience of
    developers who help create the pattern being used'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计模式是经过验证的解决方案**：它们基于解决软件开发中问题的坚实方法，并基于帮助创建所使用模式的开发人员的经验'
- en: '**Patterns can be reused**: Although they often represent an out-of-the-box
    solution, they can be easily adapted as per our needs'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式可重用**：尽管它们通常代表一个现成的解决方案，但它们可以根据我们的需求轻松适应。'
- en: '**Patterns are expressive**: They contain a set structure and vocabulary to
    help you express large solutions clearly and elegantly'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式是表达性的**：它们包含一组结构和词汇，帮助您清晰而优雅地表达大型解决方案'
- en: At this point, you may be forgiven for thinking that patterns must be an exact
    science, where we're constrained by the framework of the pattern we're using.
    It's not so; they are not an exact solution but merely a scheme to help provide
    a solution.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能会原谅以为模式必须是一门精确的科学，我们受到所使用模式框架的限制。事实并非如此；它们并不是一个确切的解决方案，而仅仅是一个帮助提供解决方案的方案。
- en: 'Taking it further, there are a number of other reasons why we should consider
    using design patterns in our work:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步地，我们应考虑在工作中使用设计模式的其他几个原因：
- en: We can effectively code out or prevent minor issues that might cause us major
    problems later in the development process—using tried and tested techniques eliminates
    the need to worry about the structure of our code and allows us to concentrate
    on the quality of our solution.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以有效地编写或预防可能在开发过程中稍后造成重大问题的小问题——使用经过验证的技术消除了对我们代码结构的担忧，并使我们能够专注于我们解决方案的质量。
- en: Patterns are designed to provide generalized solutions that don't tie them to
    a specific problem but can be applied to improve the structure of our code.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式旨在提供通用解决方案，不将其限制在特定问题上，而是可应用于改善我们代码的结构。
- en: Some patterns, if chosen wisely, can help reduce the amount of code by avoiding
    repetition; they encourage us to look at our code carefully, to reduce duplication
    and keep to using **Don't Repeat Yourself** (**DRY**) principles that are one
    of the tenets of jQuery.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些模式，如果明智地选择，可以帮助减少代码量，避免重复；它们鼓励我们仔细查看我们的代码，减少重复，并坚持使用**不要重复自己**（**DRY**）原则，这是jQuery的基本原则之一。
- en: Patterns are not a one-shot, point-in-time solution; our work may help improve
    existing designs or even provide scope for creating new patterns! This constant
    improvement helps ensure that patterns become more robust over time.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式不是一次性、一时半刻的解决方案；我们的工作可能有助于改善现有设计，甚至提供创造新模式的范围！这种持续改进有助于确保模式随着时间的推移变得更加健壮。
- en: Irrespective of its purpose, one of the key tenets of design patterns is that
    they are not always considered a design pattern, unless they have been rigorously
    tested by the pattern community. Many might appear to be a pattern; in reality,
    they are more likely to be a proto-pattern or a pattern that has been created
    but not yet been sufficiently tested to be classed as a true pattern.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不论其目的如何，设计模式的一个关键原则是，除非它们经过模式社区的严格测试，否则它们并不总被视为设计模式。许多可能看起来像是模式；实际上，它们更可能是原型模式或者一个已经被创建但尚未被充分测试以被视为真正模式的模式。
- en: The core principle of any design pattern is based on Alexander's belief that
    they should always represent a process and an output. The latter term is deliberately
    meant to be vague; it should represent something visual but the exact context
    of what that visual output is will depend on the chosen pattern.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 任何设计模式的核心原则都基于亚历山大的信念，即它们应始终代表一个过程和一个产出。后一术语被故意地设定得模糊一些；它应该代表一些可视的东西，但具体的视觉输出内容将取决于所选模式的上下文。
- en: So, now that we've seen what a design pattern is, let's discuss what they look
    like. Are they made up of specific elements or constructs? Before we take a look
    at some examples, let's first consider the makeup of a design pattern and how
    we can use it to good effect.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，既然我们已经看到了设计模式是什么，让我们讨论一下它们是什么样子的。它们由特定的元素或结构组成吗？在我们查看一些示例之前，让我们首先考虑一下设计模式的组成和我们如何有效使用它。
- en: Dissecting the structure of a design pattern
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解剖设计模式的结构
- en: 'If you take a look at any design pattern in detail, you will find that it is
    made up of a rule that establishes a relationship between the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细查看任何设计模式，您会发现它由一个规则组成，该规则建立了以下内容之间的关系：
- en: A context
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种上下文
- en: A system of forces that arises in that context
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在该上下文中产生的一系列力量
- en: A configuration that allows these forces to resolve themselves in the context
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许这些力量在上下文中自行解决的配置
- en: 'These three key aspects can be further broken down into a number of different
    elements, in addition to a pattern name and description:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个关键方面可以进一步分解为许多不同的元素，除了模式名称和描述之外：
- en: '| Element | Purpose or function |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 元素 | 目的或功能 |'
- en: '| --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Context outline | The context in which the pattern is effective in responding
    to the users'' needs. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 上下文概述 | 模式有效的上下文，以响应用户的需求。 |'
- en: '| Problem statement | A statement of the problem being addressed, so we can
    understand the intent of the pattern. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 问题陈述 | 解决的问题陈述，以便我们了解模式的意图。 |'
- en: '| Solution | A description of how the user''s problem is being solved in a
    list of steps and perceptions that are easy to understand. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 解决方案 | 描述用户问题如何在易于理解的步骤和感知列表中解决。 |'
- en: '| Design | A description of the pattern''s design and, in particular, the user''s
    behavior when interacting with it. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 设计 | 模式设计的描述，特别是用户与其交互时的行为。 |'
- en: '| Implementation | A guide to how the pattern will be implemented. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 实现 | 模式将如何实现的指南。 |'
- en: '| Illustrations | A visual representation of the classes in the pattern, such
    as a UML diagram. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 插图 | 模式中类的可视化表示，如 UML 图表。 |'
- en: '| Examples | An implementation of the pattern in a minimal form. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 示例 | 模式的最小形式实现。 |'
- en: '| Corequisites | What other patterns may be needed to support the use of the
    pattern being described? |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 先决条件 | 用于支持描述的模式使用的其他模式是什么？ |'
- en: '| Relations | Does this pattern resemble (or mimic) any existing ones? |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 关系 | 这种模式是否类似（或模仿）任何现有模式？ |'
- en: '| Known usage | Is the pattern already being used in the wild? If so, where
    and how? |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 已知用法 | 这种模式是否已经在实际应用中使用？如果是，是在哪里以及如何使用？ |'
- en: '| Discussions | The team or the author''s thoughts on the benefits of using
    the pattern. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 讨论 | 团队或作者关于使用模式的好处的想法。 |'
- en: The beauty about using patterns is that while they may entail a degree of effort
    during the planning and documentation stages, they are useful tools that help
    to get all the developers in a team on the same page.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模式的美妙之处在于，虽然在规划和文档编制阶段可能需要一定的努力，但它们是有用的工具，有助于使团队中的所有开发人员保持一致。
- en: It is worth taking a look at the existing patterns first, before creating new
    ones—there may be one in use already, which reduces the need to design from scratch
    and go through a lengthy process of testing before being accepted by other developers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新模式之前，先看看现有模式是值得的——可能已经有人在使用，这样就减少了从头设计并经过漫长的测试过程的必要性，才能被其他开发人员接受。
- en: Categorizing patterns
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式分类
- en: 'Now that we''ve seen the structure of a typical design pattern, let''s take
    a moment to consider the types of patterns that are available. Patterns are usually
    grouped into one of the following three categories, which are the most important
    ones:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了典型设计模式的结构，让我们花点时间考虑一下可用的模式类型。模式通常分为以下三类，这是最重要的类别之一：
- en: '**Creational patterns**: These focus on how we can create objects or classes.
    Even though this might sound simple (and in some aspects, like common sense),
    they can be really effective in large applications that need to control the object
    creation process. Examples of creational patterns include Abstract, Singleton,
    or Builder.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建型模式**：这些模式关注我们如何创建对象或类。虽然这听起来可能很简单（在某些方面，比如常识），但它们在需要控制对象创建过程的大型应用程序中可能非常有效。创建型模式的示例包括抽象、单例或建造者。'
- en: '**Structural design patterns**: These focus on ways to manage relationships
    between objects so that your application is architected in a scalable way. A key
    aspect of structural patterns is to ensure that a change in one part of your application
    does not affect all the other parts. This group covers patterns such as Proxy,
    Adapter, or Façade.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构设计模式**：这些模式关注如何管理对象之间的关系，以使您的应用程序以可扩展的方式构建架构。结构模式的一个关键方面是确保应用程序的一个部分的更改不会影响到所有其他部分。该组涵盖了诸如代理、适配器或外观等模式。'
- en: '**Behavioral patterns**: These focus on communication between objects and include
    the Observer, Iterator, and Strategy patterns.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为模式**：这些模式关注对象之间的通信，包括观察者、迭代器和策略模式。'
- en: With this in mind, let's take a moment to explore some of the more commonly
    used designs, beginning with the **Composite Pattern**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，让我们花点时间探索一些常用的设计，从**组合模式**开始。
- en: The Composite Pattern
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合模式
- en: 'If you''ve spent time developing with jQuery, how often have you written code
    similar to this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花时间用 jQuery 开发，你有多频繁地编写类似于这样的代码：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Without realizing it, we're using two instances of the Composite Pattern—a member
    of the Structural group of patterns; it allows you to apply the same treatment
    to a single object or a group of objects in the same manner, irrespective of how
    many items we're targeting.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 没有意识到的是，我们正在使用组合模式的两个实例——它是结构模式组中的一个成员；它允许您以相同的方式对单个对象或一组对象应用相同的处理，而不管我们要定位多少个项目。
- en: In a nutshell, when we apply methods to an element, or a group of elements,
    a jQuery object is applied; this means that we can treat either set in a uniform
    manner.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，当我们对一个元素或一组元素应用方法时，会应用一个 jQuery 对象；这意味着我们可以以统一的方式处理任何一个集合。
- en: 'So, what does this mean? Let''s take a look at a couple of other examples:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这意味着什么？让我们看看另外一些例子：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The beauty of using Composite Patterns is that we can use the same method in
    each instance but apply different values to each element; it presents a uniform
    interface to the end user while applying the change seamlessly in the background.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组合模式的优点在于，我们可以在每个实例中使用相同的方法，但对每个元素应用不同的值；它为最终用户提供了一个统一的界面，同时在后台无缝应用更改。
- en: Advantages and disadvantages of the Composite Pattern
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合模式的优缺点
- en: 'Using Composite Patterns can be as simple or complex as we make it; there are
    advantages and drawbacks to using this pattern, which we should consider:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组合模式可以简单也可以复杂；使用这种模式有优点和缺点，我们应该考虑：
- en: We can call a single function on a top-level object and have it apply the same
    results to any or all of the nodes within the structure
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以对顶级对象调用一个函数，并将其应用于结构中的任何一个或所有节点，产生相同的结果。
- en: All the objects in the composite design are loosely coupled, as they all follow
    the same interface
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合设计中的所有对象都是松散耦合的，因为它们都遵循相同的接口。
- en: The composite design gives a nice structure to the objects, without the need
    to keep them in an array or as separate variables
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合设计为对象提供了一个良好的结构，而不需要将它们保存在数组中或作为单独的变量。
- en: 'There are some drawbacks to using composite patterns; the following are the
    key ones to be considered:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组合模式也有一些缺点；以下是需要考虑的主要问题：
- en: We can't always tell whether we're dealing with a single item or multiple items;
    the API uses the same pattern for both
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们并不总是能够确定我们正在处理单个项还是多个项；API 对单个项和多个项使用相同的模式。
- en: The speed and performance of your site will be affected, if the composite pattern
    grows beyond a certain size
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果组合模式超出一定大小，您的站点的速度和性能将受到影响。
- en: Let's move on and take a look at some more patterns; the next one up is the
    **Adapter Pattern**.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看更多的模式；接下来是**适配器模式**。
- en: The Adapter Pattern
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器模式
- en: We can use jQuery to switch classes assigned to selectors; in some cases though,
    this may be an overkill for our needs, or assigning a class to a selector may
    present issues that we need to avoid. Fortunately, we can use the `.css()` function
    to directly apply styles to our elements—this is a great example of using an Adapter
    Pattern in jQuery.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 jQuery 来切换分配给选择器的类；但在某些情况下，这可能会过于复杂，或者给选择器分配类可能会出现我们需要避免的问题。幸运的是，我们可以使用
    `.css()` 函数直接将样式应用于我们的元素——这是在 jQuery 中使用适配器模式的一个很好的例子。
- en: 'A pattern based on the Structural design pattern, the Adapter Pattern, translates
    the interface for an element in jQuery into an interface that is compatible with
    a specific system. In this case, we can assign a CSS style to our chosen element,
    using an adapter in the form of `.css()`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 基于结构设计模式的一种模式，适配器模式将 jQuery 中元素的接口转换为与特定系统兼容的接口。在这种情况下，我们可以使用 `.css()` 形式的适配器为我们选择的元素分配
    CSS 样式：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The beauty of this is that once the style is set, we can use the same command
    to get the style value.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的美妙之处在于一旦样式设置好了，我们可以使用相同的命令获取样式值。
- en: Advantages and disadvantages of the Adapter Pattern
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 适配器模式的优缺点
- en: There are several key benefits of using the Adapter design pattern; the key
    one being its ability to link two incompatible interfaces, which would otherwise
    have had to remain independent.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适配器设计模式有几个关键优点；其中一个关键优点是它能够链接两个不兼容的接口，否则这两个接口将必须保持独立。
- en: 'In addition, it is worth making a note of the following additional benefits:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，值得注意以下额外的好处：
- en: The Adapter pattern can be used to create a shell around an existing block of
    code, such as a class, without affecting its core functionality
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器模式可用于在不影响其核心功能的情况下创建一个外壳，比如一个类，围绕现有的代码块。
- en: This pattern helps makes the code reusable; we can adapt the shell to include
    additional functionality or modify the existing code if circumstances dictate
    a need to do so
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种模式有助于使代码可重用；如果情况需要，我们可以调整外壳以包含额外的功能或修改现有代码。
- en: 'Using an Adapter Pattern presents some drawbacks, if we''re not careful:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适配器模式会带来一些缺点，如果我们不小心的话：
- en: There is a performance cost in using keywords such as `.css()`—do we really
    need to use them? Or, can we apply a style class or selector and move CSS styling
    into the style sheet instead?
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用关键字如 `.css()` 存在性能成本 —— 我们真的需要使用它们吗？或者，我们可以应用一个样式类或选择器，并将 CSS 样式移到样式表中吗？
- en: 'Using keywords, such as `.css()`, to manipulate the DOM can lead to a performance
    hit if we have not simplified our selectors and if we''ve used something like
    this:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用关键字，比如 `.css()`，来操作 DOM，如果我们没有简化选择器，并且如果我们使用了像这样的东西，会导致性能受损：
- en: '[PRE3]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This likely to not be noticeable on a small site or where such manipulation
    is only lightly used; it will be noticeable on a larger site!
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这在小型站点或仅轻度使用此类操作的地方可能不明显；但在较大的站点上，它将是显而易见的！
- en: Adapter patterns allow you to chain jQuery commands; although this will help
    reduce the amount of code that needs to be written, it comes with a trade-off
    in terms of legibility. Chaining commands will make it harder to debug code at
    a later date, particularly if there is a change in the developer involved; there's
    something to be said for keeping code simple and clean, if only to help maintain
    one's sanity!
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器模式允许您链接 jQuery 命令；尽管这将有助于减少需要编写的代码量，但这将以可读性为代价。链式命令会使得在以后的日期更难调试代码，特别是如果涉及到开发人员的变更；保持代码简单和清晰是有意义的，即使只是为了保持理智！
- en: Let's move on and take another look at another pattern, namely the **Façade
    Pattern**.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续并再次看看另一种模式，即**外观模式**。
- en: The Facade Pattern
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外观模式
- en: Originally from French, façade translates as *frontage* or *face*—this is a
    perfect description for this next pattern; its outward appearance can be very
    deceptive, in just the amount of code that can be hidden!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 起源于法语，"façade" 翻译为 *正面* 或 *面貌* ——这是对下一个模式的完美描述；它的外观可能非常具有迷惑性，就隐藏的代码量而言！
- en: The **Façade Pattern**, another member of the Structural group of patterns,
    provides a simple interface to a larger, more complex body of code; in a sense,
    it abstracts some of the complexity, leaving us with simple definitions that we
    can manipulate at will. Notable examples of Façade Patterns are DOM manipulation,
    animation, and, of course, the perennial favorite, AJAX!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**外观模式**，结构模式组的另一个成员，为更大、更复杂的代码提供了一个简单的接口；在某种意义上，它抽象了一些复杂性，留下了我们可以随意操纵的简单定义。外观模式的显著示例包括
    DOM 操作、动画，当然还有那个经典的 AJAX！'
- en: 'As an example, simple AJAX methods such as `$.get` and `$.post` both call the
    same parameters:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，简单的 AJAX 方法，比如 `$.get` 和 `$.post` 都调用相同的参数：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These are façades to two more functions in their own right:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在本身就是另外两个函数的外观：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Which in turn are façades to a huge amount of complex code! The complexity in
    this instance stems from the need to iron out cross-browser differences for XHR
    and make it a cinch to work with actions, such as `get`, `post`, `deferred`, and
    `promises` in jQuery.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这反过来是对大量复杂代码的伪装！这种情况下的复杂性源自于需要解决 XHR 的跨浏览器差异，并且使得使用 jQuery 中的 `get`、`post`、`deferred`
    和 `promises` 等操作变得轻而易举。
- en: Creating a simple animation
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个简单的动画
- en: 'At a very simple level, the `$.fn.animate` function is an example of a façade
    function in jQuery, as it uses multiple internal functions to achieve the desired
    result. So, here''s a simple demo that uses animation code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常简单的层面上，`$.fn.animate` 函数是 jQuery 中的一个外观函数的例子，因为它使用多个内部函数来实现所需的结果。因此，这是一个使用动画代码的简单演示：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code will produce this animation effect:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下动画效果：
- en: '![Creating a simple animation](img/image00346.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的动画](img/image00346.jpeg)'
- en: 'We can make use of the function shown in the following screenshot within the
    core library:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在核心库中使用下图中显示的函数：
- en: '![Creating a simple animation](img/image00347.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的动画](img/image00347.jpeg)'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The code for the demo in this section is available in the code download link
    that accompanies this book, as the `animation.html` file; you will need to extract
    the whole code folder for this demo to work correctly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本节演示的代码在本书附带的代码下载链接中作为 `animation.html` 文件提供；要使此演示工作正常，您需要解压整个代码文件夹。
- en: Now that you've seen the Façade Pattern in use, let's consider some of the benefits
    of using it in our code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了外观模式的应用，请考虑一下在我们的代码中使用它的好处。
- en: Advantages and disadvantages of the Façade Pattern
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外观模式的优缺点
- en: 'Using the Façade pattern to hide complex code is a really useful technique;
    in addition to being easy to implement, there are other advantages of using this
    pattern, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用外观模式隐藏复杂代码是一种非常有用的技术；除了易于实现之外，使用这种模式还有其他优点，如下所示：
- en: Enhances security of your web application
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强您的 Web 应用程序的安全性
- en: Works well in combination with other patterns
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他模式结合使用效果很好
- en: Makes it easy to patch internal code
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使内部代码容易修补
- en: Provides a simpler public interface to the end user
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为最终用户提供简单的公共接口
- en: In contrast to other patterns, there are no real notable drawbacks when using
    this pattern; it provides a unified set of interfaces to us as end users, so we're
    not forced to make any compromises. It is worth noting that there is a cost involved
    in implementation, when abstracting code—this is something that we should always
    bear in mind when using façade patterns.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他模式相比，在使用这种模式时没有真正显著的缺点；它为我们作为最终用户提供了统一的接口集，因此我们不必做出任何妥协。 值得注意的是，在抽象代码时，实施中会有成本—在使用外观模式时，这是我们在心中始终要记住的事情。
- en: The Observer Pattern
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察者模式
- en: Since it is a member of the Behavioral group of patterns, we will already be
    familiar with this next pattern—if you spend time creating custom events, then
    you are already using the **Observer Pattern**.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是行为模式组的一部分，我们将已经熟悉下一个模式——如果您花时间创建自定义事件，那么您已经在使用**观察者模式**。
- en: 'A key part of developing with jQuery is using its well-established publishing/subscribing
    system to create custom events—access to these events is possible using `.trigger()`,
    `.on()`, or `.off()`. We can define Observer Patterns as those patterns where
    specific objects are subscribed to others and can be notified by them when a particular
    event takes place:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 jQuery 开发的一个关键部分是使用其经过验证的发布/订阅系统来创建自定义事件—通过使用 `.trigger()`, `.on()`, 或 `.off()`
    可以访问这些事件。 我们可以将观察者模式定义为当特定对象订阅其他对象并在特定事件发生时被通知时的模式：
- en: '![The Observer Pattern](img/image00348.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![观察者模式](img/image00348.jpeg)'
- en: 'For a moment, let''s say we have the following HTML:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 试想一下，我们有以下 HTML：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We want the inner `<div>` elements to trigger an event called `customEvent`;
    this will happen when they are clicked on:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望内部的 `<div>` 元素触发一个名为 `customEvent` 的事件；当它们被点击时，就会发生这种情况：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s make the document element subscribe to `customEvent`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使文档元素订阅 `customEvent`：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When the custom event is triggered by one of the `div` elements, the observer/subscriber
    is notified and a message is logged to the console.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 `div` 元素之一触发自定义事件时，观察者/订阅者会收到通知，并且消息将记录到控制台中。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注：
- en: For purists, some of you may prefer to use a typical publish/subscribe model—an
    example is available at [https://gist.github.com/cowboy/661855](https://gist.github.com/cowboy/661855).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于纯粹主义者来说，你们可能更喜欢使用典型的发布/订阅模型——在 [https://gist.github.com/cowboy/661855](https://gist.github.com/cowboy/661855)
    中提供了一个示例。
- en: Let's consider some of the benefits of using this pattern and where you may
    need to make allowances in your code in order to avoid falling into some of the
    traps associated with using this design pattern.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下使用这种模式的好处以及在代码中可能需要做些让步来避免陷入与使用这种设计模式相关的一些陷阱。
- en: Advantages and disadvantages of the Observer Pattern
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 观察者模式的优缺点
- en: 'Using the Observer Pattern forces us to consider the relationship between the
    various components of an application, at a far greater level than we might otherwise
    have been used to considering. It is also great at doing the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用观察者模式强迫我们考虑应用程序各个部分之间的关系，远远超过我们可能习惯于考虑的水平。 它还非常擅长以下几点：
- en: Promoting loose coupling in jQuery, where each component knows what it is responsible
    for and doesn't care about other modules—this encourages reusable code.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 促进 jQuery 中的松耦合，其中每个组件都知道自己负责什么，不关心其他模块——这鼓励可重用代码。
- en: Allowing you to follow the separation of concerns principle; if code blocks
    are self-contained, they can be reused with little difficulty in new projects.
    We can then subscribe to single events and not worry about what happens in each
    block.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让您遵循关注点分离原则；如果代码块是自包含的，它们可以在新项目中轻松重用。然后，我们可以订阅单个事件，而不必担心每个块中会发生什么。
- en: Helping us to pinpoint where the dependencies are within our project, as a potential
    basis for determining whether these dependencies can be reduced or eliminated
    altogether with a little effort.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助我们准确定位项目中的依赖关系所在，作为确定这些依赖关系是否可以通过一点努力来减少或完全消除的潜在依据。
- en: There are drawbacks to using the Observer Pattern though; the key drawbacks
    are the switching of a subscriber from one publisher to another can be costly
    in terms of code, and it becomes harder to maintain the integrity of our code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用观察者模式也有缺点；主要缺点是将一个订阅者从一个发布者转换到另一个发布者可能在代码方面代价高昂，并且难以维护我们代码的完整性。
- en: To illustrate this, let's take a brief look at a simple example, where we can
    see at least one instance of where we've had to make extra allowances for the
    switch of publisher.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们简要地看一下一个简单的例子，我们可以看到至少一个我们不得不为发布者的切换做出额外让步的实例。
- en: Creating a basic example
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个基本示例
- en: 'Getting our heads around how the Observer Pattern works is critical; it is
    one of the patterns that is more in-depth and provides more opportunity than a
    simple set of protocols, such as the Façade design pattern. With this mind, let''s
    run through a quick working demo to illustrate how it works, as shown here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 弄清楚观察者模式的工作原理至关重要；它是更深入的模式之一，并提供了比简单的协议集更多的机会，比如外观设计模式。考虑到这一点，让我们运行一个快速的演示来说明它的工作原理，如下所示：
- en: Let's start by downloading and extracting copies of the code for this chapter—we
    need the `observer.html` file, along with the `css` and `js` folders
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们首先下载并提取本章的代码副本——我们需要`observer.html`文件，以及`css`和`js`文件夹。
- en: 'If you run the demo, you should see two labels in red, which you can click;
    if you try clicking them, you will see the counts increase, as shown in this screenshot:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您运行演示，您应该会看到两个标签变为红色，您可以单击它们；如果您尝试单击它们，您将看到计数增加，如此屏幕截图所示：
- en: '![Creating a basic example](img/image00349.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个基本示例](img/image00349.jpeg)'
- en: 'At this point, let''s consider the code—the key functionality is in the `observer.js`
    file, which I have reproduced in full here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，让我们考虑一下代码——关键功能在`observer.js`文件中，我在此处完整复制了它：
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice how there is a single event handler for the `.click` class. We've used
    a callback here to allow jQuery to execute the next click, even though it may
    not have finished completing the previous execution. In this instance, it's not
    going to be too much of an issue, but if we had to update a number of different
    statements or apply more changes (through the use of additional functions), then
    the callback will prevent errors from being generated in our code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一下，对于`.click`类，有一个单独的事件处理程序。我们在这里使用了一个回调函数，以允许jQuery执行下一个点击，即使它可能尚未完成前一个执行。在这种情况下，这不会是太大的问题，但如果我们必须更新多个不同的语句或应用更多的更改（通过使用额外的函数），那么回调将防止我们的代码产生错误。
- en: Here, we subscribe to the observable, which—in this instance—are the two **Click
    Me** statements; the `.click` event handler allows us to update both the click
    counts and the **Last element clicked** statement, without throwing an error.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们订阅可观察对象，这在这种情况下是两个**点击我**语句；`.click`事件处理程序允许我们更新点击计数和**最后点击的元素**语句，而不会引发错误。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about the intricacies of using callbacks in jQuery, you may want
    to browse through the API documentation, which can be viewed at [http://api.jquery.com/jquery.callbacks/](http://api.jquery.com/jquery.callbacks/).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于在jQuery中使用回调的复杂性，您可能需要浏览API文档，可以在[http://api.jquery.com/jquery.callbacks/](http://api.jquery.com/jquery.callbacks/)查看。
- en: In the meantime, let's change focus and take a look at a different pattern.
    We all know that jQuery is famed for its DOM manipulation abilities; up next is
    the Iterator pattern, which is based on this particular feature of jQuery.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，让我们改变焦点，看看不同的模式。我们都知道jQuery以其DOM操作能力而闻名；接下来是迭代器模式，它基于jQuery的这一特定功能。
- en: The Iterator Pattern
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器模式
- en: Now, how many times have you heard, or read, that jQuery is famed for its DOM
    manipulation? I bet that it's a fair few times and that the `.each()` keyword
    is used at some point in those examples.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你听过或读过多少次jQuery以其DOM操作而闻名？我敢打赌，有相当多次，而且`.each()`关键字在这些示例中某个时候被使用过。
- en: 'DOM manipulation in jQuery uses a special variation of the Iterator Pattern,
    from the Behavioral group of patterns—this is as it sounds; we can use this pattern
    to traverse (or iterate) through all the elements of a collection, leaving jQuery
    to handle the internal workings. A simple example of such a pattern might look
    like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery中的DOM操作使用了行为组模式中的特殊变体——这就是它的用途；我们可以使用这种模式来遍历（或迭代）集合的所有元素，让jQuery处理内部工作。这种模式的一个简单示例可能是这样的：
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In both the cases, we've used the `.each` function to iterate through either
    the array or each instance of the `li` selector; there is no need to worry about
    the internal workings of the iterator.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们都使用了`.each`函数来遍历数组或`li`选择器的每个实例；无需担心迭代器的内部工作原理。
- en: 'Our examples contain minimal code, in order to iterate through each selector
    or class within the page; it''s worth taking a look at the amount of code that
    is behind `jQuery.fn.each()` function, within the core library:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例代码包含最少的代码，以便遍历页面中的每个选择器或类；值得一提的是，查看核心库中`jQuery.fn.each()`函数的代码量：
- en: '![The Iterator Pattern](img/image00350.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![迭代器模式](img/image00350.jpeg)'
- en: 'This, in turn, calls the `jQuery.each()` function—the first one is for internal
    use only, as shown in the following screenshot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这反过来调用了`jQuery.each()`函数——第一个函数仅供内部使用，如下图所示：
- en: '![The Iterator Pattern](img/image00351.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![迭代器模式](img/image00351.jpeg)'
- en: 'This is then supplemented by a special fast case, that is, for the most common
    use of the `.each()` function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这又得到了一个特殊的快速情况，即对`.each()`函数最常见用法的补充：
- en: '![The Iterator Pattern](img/image00352.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![迭代器模式](img/image00352.jpeg)'
- en: Advantages and disadvantages of the Iterator Pattern
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代器模式的优缺点
- en: 'The ability to iterate over elements in the DOM is one of the key elements
    of jQuery—as a critical part of the Iterator pattern; these are some benefits
    of using this pattern:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在DOM中遍历元素的能力是jQuery的关键要素之一——作为迭代器模式的关键部分；使用这种模式有以下一些好处：
- en: The Iterator pattern hides much of the functionality required to iterate through
    a collection, without the need to understand the inner workings of the code providing
    this functionality
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器模式隐藏了遍历集合所需的大部分功能，而无需理解提供此功能的代码的内部工作原理
- en: We can use the same consistent pattern to iterate through any object or set
    of values
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用相同的一致模式来遍历任何对象或一组值
- en: Using the Iterator process can also help to reduce or eliminate typical `for`
    loop syntax across our code, making the code easier to read
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迭代器过程还可以帮助减少或消除我们代码中典型的`for`循环语法，使代码更易读
- en: Unlike other patterns, there are very few disadvantages of using this pattern.
    It's a key facet of jQuery, so provided it is not abused by having to iterate
    over an excessive number of objects, this simple pattern will prove to be very
    useful!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他模式不同，使用这种模式几乎没有什么缺点。它是jQuery的一个关键方面，所以只要不被迭代过多的对象滥用，这个简单的模式将证明非常有用！
- en: The Lazy Initialization Pattern
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 惰性初始化模式
- en: Hehe, this sounds like something I might follow on a Sunday morning! Okay, I
    know that was a terrible joke, but all jokes aside, this creational-based pattern
    allows you to postpone expensive processes until they are needed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 呵呵，这听起来像是我周日早晨可能会遵循的东西！好吧，我知道那是一个糟糕的笑话，但是开玩笑归开玩笑，这种基于创建的模式允许您推迟昂贵的过程，直到它们被需要。
- en: 'At its simplest level, we might configure a plugin with a number of different
    options, such as the number of images to be displayed, whether we should show
    an overlay, or how each image is displayed. Sounds simple, right? So, where does
    the lazy initialization part come in? Aha! This is simpler than you might think.
    Take the example of the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的层面上，我们可能会使用多个不同选项来配置插件，比如要显示的图像数量，是否应该显示叠加层，或者每个图像如何显示。听起来很简单，对吧？那么，惰性初始化在哪里呢？啊哈！这比你想象的简单。以以下代码为例：
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our example used the initialization command for the WOW Slider (available from
    [http://www.wowslider.com](http://www.wowslider.com))—the key to using this pattern
    is in the initialization process; it is not fired until the first moment it is
    needed on our page.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例使用了 WOW Slider 的初始化命令（可在 [http://www.wowslider.com](http://www.wowslider.com)
    上获取）—使用这种模式的关键在于初始化过程；直到第一次在我们的页面上需要时才触发它。
- en: 'A more complex example of the lazy initialization pattern is a callback; these
    won''t be processed until the DOM is ready:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 懒惰初始化模式的一个更复杂的示例是回调；这些不会在 DOM 准备好之前进行处理：
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We might make use of this example directly in our code; it is more likely that
    we will use it within a lazy loading plugin, such as the version by Mika Tuupola
    at [http://www.appelsiini.net/projects/lazyload](http://www.appelsiini.net/projects/lazyload).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会直接在我们的代码中使用这个示例；更可能的是我们会在懒加载插件中使用它，比如 Mika Tuupola 在 [http://www.appelsiini.net/projects/lazyload](http://www.appelsiini.net/projects/lazyload)
    上的版本。
- en: Advantages and disadvantages of the Lazy Initialization Pattern
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 懒惰初始化模式的优缺点
- en: 'The key benefit of using this design pattern is simple: to delay the loading
    of expensive resources until they are needed; this helps to speed up access to
    a site and to reduce bandwidth usage (at least initially).'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种设计模式的关键优势很简单：延迟加载昂贵资源的加载；这有助于加快对站点的访问速度，并减少带宽使用（至少最初是如此）。
- en: 'However, there are some drawbacks of using this method, which include the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，使用这种方法还存在一些缺点，包括以下：
- en: It needs careful management by the setting of a flag to test whether the summoned
    object is ready for use; if not, then a race condition can be generated in multithreaded
    code
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要通过设置标志来进行仔细管理，以测试所召唤对象是否准备好使用；如果不是，那么在多线程代码中可以生成竞争条件
- en: The prior use of any lazy variable or object will bypass the initialization
    on the first access principle and mean that we lose any benefit of not loading
    these large objects or variables
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何懒变量或对象的先前使用都将绕过首次访问时的初始化原则，并意味着我们失去了不加载这些大对象或变量的任何好处。
- en: This method requires the use of a map to store instances so that you get the
    same instance when you next ask for one with the same parameter as the one previously
    used
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法需要使用映射来存储实例，以便在下次以前使用相同参数向存储实例请求时得到相同的实例
- en: There is a time penalty involved with using this pattern, if large objects need
    to be loaded; the pattern only really works if these objects are not loaded initially
    and if there is a good chance that they will not be used
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这种模式涉及时间成本，如果需要加载大型对象；如果最初不加载这些对象，并且有很大的可能性它们不会被使用，那么这种模式才真正起作用
- en: Ultimately, using this pattern needs some consideration and careful planning;
    it will work well, provided we've chosen not to load the right objects, so to
    speak! Talking of strategy, let's move on and take a look at another pattern that
    helps us determine what will happen when changing states on objects or variables,
    namely the **Strategy Pattern**.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，使用这种模式需要一些考虑和仔细规划；只要我们选择了不加载正确的对象，它就能很好地工作！说到策略，让我们继续，看看帮助我们确定在对象或变量状态改变时会发生什么的另一个模式，即**策略模式**。
- en: The Strategy Pattern
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略模式
- en: Cast your mind back a few years, when using Flash to animate content on sites
    was the latest design fad; there were some really well-designed examples, although
    all too often sites were slow and not always as effective as they should be! Moving
    forward, CSS animations are preferred now—they don't need a browser plugin to
    operate, can be stored in a style sheet, and are less resource hungry than Flash.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下几年前，使用 Flash 在网站上做动画内容是最新的设计潮流；有些设计得非常好，尽管经常情况下网站速度慢，并且并不总是像它们应该的那样有效！而现在，CSS
    动画更受欢迎—它们不需要浏览器插件来运行，可以存储在样式表中，比 Flash 更节约资源。
- en: '"Why are we talking about animations?", I hear you ask, when this chapter is
    about design patterns. That''s a good question; the answer is simple, though:
    some of you may not realize it but animations are a perfect example of our next
    design pattern. At a basic level, animations are all about changing from one state
    to another—this forms the basis of the Strategy pattern, from the Behavioral group
    of patterns.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '"为什么我们在讨论动画？"，我听到你问道，当这一章是关于设计模式时。这是一个很好的问题；答案很简单：尽管有些人可能没有意识到，但动画是我们接下来的设计模式的一个完美示例。在基本层面上，动画都是关于从一个状态变化到另一个状态—这构成了行为模式组中的策略模式的基础。'
- en: 'Also known as the policy or state pattern, the Strategy pattern allows you
    to select the appropriate behavior at runtime. In a nutshell, this is what the
    pattern does:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 也被称为策略或状态模式，策略模式允许您在运行时选择适当的行为。简而言之，这就是模式的作用：
- en: Defines a family of algorithms (or functions) used to determine what should
    happen at runtime
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个用于确定运行时应发生什么的算法（或函数）族
- en: Encapsulates each algorithm (or function) into its self-contained unit and makes
    each algorithm interchangeable within that family
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个算法（或函数）封装到其自包含的单元中，并使每个算法在该族内可互换
- en: A good example of where strategy patterns can be used is in the validation of
    entries in a form—we need some rules in place to determine what is valid or invalid
    content; we clearly won't know what the outcome will be until that content is
    entered!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式可以应用的一个很好的例子是在表单条目的验证中——我们需要一些规则来确定什么是有效或无效的内容；在输入内容之前，我们显然不会知道结果会是什么！
- en: The key point here is that the rules for validation can be encapsulated in their
    own block (potentially as an object in their own right); we can then pull in the
    relevant block (or rule), once we know what the user wants us to validate.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点在于验证规则可以封装在自己的块中（可能作为自己的对象）；一旦我们知道用户想要我们验证什么，我们就可以拉入相关的块（或规则）。
- en: 'At a more basic level, though, there is a simpler example of a strategy pattern;
    it takes the form of animating content, such as using `.toggle()`, where we switch
    from one state to another or back again:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在更基本的层面上，有一个策略模式的更简单的例子；它采用动画内容的形式，比如使用`.toggle()`，我们在不同状态之间或者回到原状态之间进行切换：
- en: '[PRE14]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Each resulting state can be set as a class in its own right; they will be called
    at the appropriate time, once we know what the requested action should be. To
    help set the context, let's knock up a simple demo in order to see this in action.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每个生成的状态都可以设置为自己的类；一旦我们知道请求的操作应该是什么，它们将在适当的时间被调用。为了帮助设置上下文，让我们创建一个简单的演示来看看它的运作方式。
- en: Building a simple toggle effect
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建一个简单的切换效果
- en: Okay, granted that this is jQuery 101, but why complicate matters when it shows
    what we need perfectly?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，虽然这是jQuery 101，但当它完美地展示了我们所需要的内容时，为什么要把事情复杂化呢？
- en: In this demo, we perform a simple toggle action to show or hide two `<p>` statements—the
    key point here is that we don't know what is going to happen next, until the button
    is pressed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在此演示中，我们执行一个简单的切换动作来显示或隐藏两个`<p>`语句——关键点在于在按下按钮之前我们不知道接下来会发生什么。
- en: 'To see this in action, download a copy of the `code` folder for this chapter;
    run the `strategy.html` demo and then click on **Toggle ''em** to see the `<p>`
    statements appear or disappear, as shown here:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此操作，请下载本章的`code`文件夹的副本；运行`strategy.html`演示，然后单击**切换它们**以查看`<p>`语句的显示或隐藏，如下所示：
- en: '![Building a simple toggle effect](img/image00353.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![构建一个简单的切换效果](img/image00353.jpeg)'
- en: 'The magic takes place in this function; it''s a simple use of the `.toggle()`
    command to switch the visibility of each `<p>` statement as required:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 魔术发生在这个函数中；它是使用`.toggle()`命令来根据需要切换每个`<p>`语句的可见性的简单用法：
- en: '[PRE15]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, we can easily abstract the function contained in the click event handler
    into a separate IIFE and then simply call the function in our code, as shown here:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们可以轻松地将点击事件处理程序中包含的函数抽象为一个单独的IIFE，然后在我们的代码中简单地调用该函数，如下所示：
- en: '[PRE16]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The code is already easier to read—we've removed the bulk of the original action
    away from the event handler; this removes the need to edit the event handler if
    we need to change the code at a later date.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 代码已经更容易阅读——我们已经将大部分原始操作从事件处理程序中移除；这消除了以后需要更改代码时编辑事件处理程序的需要。
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are interested in learning more about IIFEs, then you may want to take
    a look at Wikipedia's entry for more details, which is available at [https://en.wikipedia.org/wiki/Immediately-invoked_function_expression](https://en.wikipedia.org/wiki/Immediately-invoked_function_expression).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对立即调用的函数表达式(IIFEs)感兴趣，那么你可能想要查看维基百科的条目以获取更多细节，该条目位于[https://en.wikipedia.org/wiki/Immediately-invoked_function_expression](https://en.wikipedia.org/wiki/Immediately-invoked_function_expression)。
- en: Switching between actions
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在不同动作之间切换
- en: Although we've concentrated on animations in our example, the observant amongst
    us might be wondering whether the same techniques will apply to commands such
    as `switch()`. The answer is yes; we've not discussed it here as it is a pure
    JavaScript command, but you can apply the same principles as an alternative to
    use it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在示例中集中讨论了动画，但我们中敏锐的人可能想知道同样的技术是否也适用于诸如 `switch()` 等命令。答案是肯定的；我们没有在这里讨论它，因为它是一个纯粹的
    JavaScript 命令，但是你可以将相同的原则应用作为它的替代方案。
- en: Advantages and disadvantages of the Strategy Pattern
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 策略模式的优缺点
- en: 'Defining a sensible strategy is the key to successful coding; these are some
    benefits that we can gain by using the Strategy pattern:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个明智的策略是成功编码的关键；通过使用策略模式，我们可以获得一些好处：
- en: The code is easier to read; if we abstract functions into their own class, we
    can move them away from the decision-making process, either as separate blocks
    of code in the same file or even as separate files in their own right
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码更易于阅读；如果我们将函数抽象成它们自己的类，我们可以将它们从决策过程中分离出来，要么作为同一文件中的独立代码块，要么甚至作为自己文件中的独立文件
- en: The code is easier to maintain; we only need to go to the class to change or
    refactor the code, and we only need to make minimal changes to the core code in
    order to add links to new classes or object event handlers
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码更易于维护；我们只需要进入类来更改或重构代码，而且我们只需要对核心代码进行最小的更改，以便为新的类或对象事件处理程序添加链接
- en: We can maintain the separation of concerns—each independent class or object
    that we abstract retains no awareness of the other components, but when provided
    with each strategy object's responsibility and the same interface, they can communicate
    with other objects
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以保持关注点的分离——我们抽象的每个独立类或对象都不会意识到其他组件，但是当提供了每个策略对象的责任和相同的接口时，它们可以与其他对象通信
- en: Using the Strategy pattern allows you to take advantage of the open/closed principle;
    the behavior of each abstracted class or object can be altered by initiating a
    new class or object instance of the existing behaviors
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用策略模式可以让你利用开放/封闭原则；每个抽象类或对象的行为可以通过启动现有行为的新类或对象实例来改变
- en: Tip
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more details about the open/closed principle, please refer to [http://en.wikipedia.org/wiki/Open/closed_principle](http://en.wikipedia.org/wiki/Open/closed_principle).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 关于开放/封闭原则的更多细节，请参阅 [http://en.wikipedia.org/wiki/Open/closed_principle](http://en.wikipedia.org/wiki/Open/closed_principle)。
- en: 'These are some of the disadvantages that we need to be mindful of, though:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们需要注意的一些缺点：
- en: Use of the Strategy pattern allows you to respect the open/closed principle,
    but at the same time, you may end up initiating a new class or object of code
    that contains a lot of unnecessary functions or actions that make your code more
    cumbersome
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用策略模式可以让你遵守开放/封闭原则，但同时，你可能会启动一个包含许多不必要函数或动作的新类或对象的代码，从而使你的代码变得更加繁琐
- en: There may be instances where using the Strategy pattern won't suit your purposes;
    if your code only contains a small number of functions, the effort required to
    abstract them may outweigh the benefits of doing so
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些情况下使用策略模式可能不适合你的目的；如果你的代码只包含少量函数，那么将它们抽象化所需的工作量可能会超过所带来的好处
- en: Using the Strategy pattern will increase the number of objects within our code,
    making it more complex and potentially requiring more resources to manage
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用策略模式将增加代码中的对象数量，使其变得更加复杂，并且可能需要更多资源来管理
- en: Enough strategizing for the moment; let's move on and take a look at a different
    protocol, in the form of the **Proxy** design pattern.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 策略讨论够多了；让我们继续看一个不同的协议，以**代理**设计模式的形式
- en: The Proxy Pattern
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理模式
- en: When working with jQuery, there will be occasions where you might want to write
    a generic event handler that takes care of managing styles on certain elements—a
    good example might be switching from active to disabled state, or even selected
    state; we can then style these using normal CSS.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 jQuery 时，可能会有这样的情况，你可能想编写一个通用事件处理程序来管理某些元素上的样式——一个很好的例子可能是从活动状态切换到禁用状态，或者甚至是选定状态；然后我们可以使用普通的
    CSS 来为这些样式编写样式。
- en: 'Using this approach, this is how a generic event handler might look:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，一个通用的事件处理程序可能如下所示：
- en: '[PRE17]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'At face value, this will work perfectly well, but what if we were to introduce
    a delay before changing the style class? We would normally use a `setTimeOut()`
    function to achieve this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这样做完全可以正常运行，但是如果我们在更改样式类之前引入延迟会怎么样？我们通常会使用 `setTimeOut()` 函数来实现这一点：
- en: '[PRE18]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Did anyone spot a small but rather crucial problem here? Passing any function
    to `setTimeout` will give you the wrong value—it will refer to the window object,
    not the object being passed!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有人发现这里有一个小但相当关键的问题吗？将任何函数传递给`setTimeout`都会给出错误的值—它将引用窗口对象，而不是传递的对象！
- en: 'A workaround for this is jQuery''s `proxy()` function; we can use this function
    to implement a Proxy pattern, or a go-between, in order to ensure that the right
    value is passed through to the `.addClass()` method in the right context. We can
    adapt our previous example as shown in the following code snippet:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的一种方法是使用jQuery的`proxy()`函数；我们可以使用此函数来实现代理模式或中间层，以确保正确的值通过到`.addClass()`方法的正确上下文中。我们可以调整我们之前的示例，如下代码片段所示：
- en: '[PRE19]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The last `this` parameter we're passing tells `$.proxy()` that our DOM element
    is the value we want `this` to refer to—in this instance, it's the checkbox and
    not the window.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递的最后一个`this`参数告诉`$.proxy()`我们的DOM元素是我们想要`this`引用的值—在这种情况下，它是复选框，而不是窗口。
- en: Advantages and disadvantages of the Proxy Pattern
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代理模式的优缺点
- en: Proxy patterns are useful designs from the Structural group, which can help
    with optimizing and maintaining fast sites; at its core, the pattern is based
    on the principle of not loading expensive elements until absolutely necessary.
    (and then ideally not loading at all, if it can be helped!)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式是来自结构组的有用设计，可以帮助优化和维护快速站点；在其核心，该模式基于不加载昂贵元素直到绝对必要的原则。（最好根本不加载，如果可以的话！）
- en: 'There are some benefits we can gain by using this design pattern, as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种设计模式可以获得一些好处，如下所示：
- en: We can use a proxy pattern to provide a placeholder for more expensive objects
    that are yet to be loaded or which may never be loaded; this includes objects
    that may be loaded from outside the application
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用代理模式为尚未加载或可能永远不会加载的更昂贵的对象提供占位符；这包括可能从应用程序外部加载的对象
- en: Using a proxy can act as a wrapper, providing delegation to the real object,
    while also protecting it from undue complexity
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代理可以充当包装器，为真实对象提供委托，同时保护它免受不必要的复杂性
- en: Incorporating proxy patterns into our page can help reduce the perceived slowness
    or lack of responsive from code-heavy sites
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代理模式纳入我们的页面中可以帮助减少代码繁重站点的感知速度慢或响应不足。
- en: 'The downsides to using this pattern include the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式的缺点包括以下内容：
- en: There is a risk that a proxy pattern can hide the life cycle and state of a
    volatile resource from its client; this means that the code has to wait until
    the right resource becomes available again or produces an error. It needs to know
    that it is interacting with the original resource and not with another resource
    that may appear similar to the original.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理模式存在一个风险，即代理模式可能会将易变资源的生命周期和状态隐藏在其客户端之外；这意味着代码必须等待正确的资源再次可用，或者产生错误。它需要知道它正在与原始资源交互，而不是与可能与原始资源类似的另一个资源交互。
- en: If we are using proxy patterns to represent a remote resource, this will disguise
    the use of communication between the two; communication with a remote resource
    should be treated differently to that of a local one.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们正在使用代理模式来表示远程资源，则这将掩盖两者之间的通信使用；与本地资源的通信应与远程资源的通信区别对待。
- en: With care, proxy patterns can prove very useful, provided we're sensible about
    what we decide to load or not load into our pages. Let's change tack and look
    at another design pattern; this one is based on how we may need to construct one
    or more elements dynamically; this concept is at the core of the **Builder Pattern**.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 经过谨慎的使用，代理模式可以证明非常有用，只要我们对我们决定加载或不加载到我们的页面中的内容保持理性。让我们改变方向，看看另一种设计模式；这个模式基于我们可能需要动态构建一个或多个元素的方式；这个概念是**生成器模式**的核心。
- en: Builder Pattern
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器模式
- en: During the development of any project, there may be occasions where we need
    to create new elements dynamically; this can range from building a single `<div>`
    element to a complex mix of elements.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何项目的开发过程中，都可能会出现需要动态创建新元素的情况；这可以是构建单个`<div>`元素，也可以是各种元素的复杂组合。
- en: We might want the flexibility of defining the final markup directly in our code,
    which can get messy, or we can separate out the elements into a standalone mechanism
    that allows us to simply build those elements, ready for use later in the code.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望在代码中直接定义最终的标记，这可能会变得混乱，或者我们可以将元素分离成一个独立的机制，允许我们简单地构建这些元素，以便稍后在代码中使用。
- en: The latter, or the Builder Pattern to give it its technical name, is preferable;
    it's easier to read and allows you to keep a clear distinction between variables
    and the rest of your code. This particular pattern falls into the Creational group
    of patterns and is one of the few common examples you will see of this type of
    pattern.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 后者，或者称为建造者模式的技术名称，更可取； 它更容易阅读，并允许您清晰区分变量和代码的其他部分。 此特定模式属于创建模式组，并且是您将看到此类模式的少数常见示例之一。
- en: Note
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may see references to the **Abstract Pattern** online, or in books—it is
    very similar in style to the Builder Pattern.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会在网上或书籍中看到对**抽象模式**的引用——它与建造者模式非常相似。
- en: 'We can use jQuery''s dollar sign to build our objects; we can either pass the
    complete markup for an element, partial markup and content, or simply use jQuery
    for construction, as shown here:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 jQuery 的美元符号来构建我们的对象； 我们可以传递完整的元素标记，部分标记和内容，或者简单地使用 jQuery 进行构造，如下所示：
- en: '[PRE20]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once created, we can cache these objects using variables and reduce the number
    of requests to the server.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，我们可以使用变量缓存这些对象，并减少对服务器的请求次数。
- en: It's worth noting that design patterns are not exclusive to script code; they
    can be applied to plugins using similar principles. We will cover more design
    patterns for jQuery plugins in [Chapter 11](part0098.xhtml#aid-2TEN41 "Chapter 11. Authoring
    Advanced Plugins"), *Authoring Advanced jQuery Plugins*.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，设计模式不仅限于脚本代码； 它们可以应用于使用类似原则的插件。 我们将在[第 11 章](part0098.xhtml#aid-2TEN41
    "第 11 章。编写高级插件") 中介绍更多适用于 jQuery 插件的设计模式，*编写高级 jQuery 插件*。
- en: Advantages and disadvantages of the Builder Pattern
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建造者模式的优缺点
- en: 'Using a builder pattern won''t suit all circumstances; it is worth noting the
    benefits that can be gained by using it in order to see if these will suit your
    requirements. These benefits include the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用建造者模式并不适用于所有情况；值得注意的是，通过使用它可以获得的好处，以便查看这些是否符合您的要求。 这些好处包括：
- en: We can construct the markup needed to create objects dynamically within jQuery,
    without the need to explicitly create each object
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在 jQuery 内动态构建创建对象所需的标记，而无需显式创建每个对象
- en: We can cache the markup, which can then be separated from the main functionality
    and which makes it easier to read the code and reduce requests to the server
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以缓存标记，然后将其与主要功能分离，这样可以更轻松地阅读代码并减少对服务器的请求
- en: The core markup will remain immutable, but we can apply different functions
    to it in order to alter values or its appearance
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心标记将保持不可变，但我们可以对其应用不同的功能以改变值或外观
- en: We can go further and turn our Builder pattern into a state machine or a mechanism
    to expose public methods or events, while still maintaining private constructor
    or destructor methods
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以进一步将我们的建造者模式转换为状态机或公开方法或事件的机制，同时仍保留私有构造函数或析构函数方法
- en: 'There are some disadvantages of using the Builder pattern; the key disadvantage
    is the abuse of the use of chaining, but we should also consider the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用建造者模式有一些缺点； 关键缺点是滥用链接的使用，但我们还应考虑以下方面：
- en: There is scope to define markup that can't be easily reused; this means that
    we may need to create a handful of the variables that contain markup, all of which
    will take resources that should be used elsewhere.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有可能定义无法轻松重用的标记； 这意味着我们可能需要创建一些包含标记的变量，所有这些变量都将占用应该用于其他用途的资源。
- en: 'Take an example of the following code snippet:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是一个代码片段的示例：
- en: '[PRE21]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The use of the Builder pattern allows actions to be chained, provides a consistent
    API, and follows the Builder pattern. However, the main drawback of this pattern
    is that it makes the code harder to read and, therefore, harder to debug.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用建造者模式允许链接操作，提供一致的 API，并遵循建造者模式。 但是，这种模式的主要缺点是使代码更难阅读，因此更难调试。
- en: We've explored a number of different design pattern types at a conceptual level;
    for some, it may still prove difficult to relate this back to what we know as
    the jQuery Core.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在概念层面上探讨了许多不同的设计模式类型； 对于一些人来说，将其与我们所知的 jQuery 核心联系起来可能仍然会很困难。
- en: The beauty though is that jQuery uses these patterns throughout—to help put
    some of what you've learned into practice, let's take a moment to examine the
    core library and see some examples of how these patterns are used internally.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，美妙之处在于 jQuery 在整个代码库中都使用这些模式——为了帮助您将所学的一些知识付诸实践，让我们花一点时间来检查核心库并看看这些模式是如何在内部使用的一些示例。
- en: Exploring the use of patterns within the jQuery library
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 jQuery 库中模式的使用
- en: 'Now, you''re probably thinking: I''m still not sure how these patterns relate
    to my work. Right?'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会想：我仍然不确定这些模式与我的工作有何关联。是吗？
- en: Thought so. Throughout this chapter, we've spent time examining some of the
    more commonly used patterns, as a means of going back to basics; after all, the
    secret of improving oneself is not just through writing code!
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我想是的。在本章中，我们花时间研究了一些常用的模式，作为回归基础的一种方式；毕竟，提高自己的秘诀不仅仅是通过编写代码！
- en: 'The key point here is that if you spend time developing with jQuery, then you
    are already using design patterns; to help reinforce what you learned, let''s
    take a look at a few examples from within the jQuery library itself:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点在于，如果你花时间用 jQuery 开发，那么你已经在使用设计模式；为了加强你所学的内容，让我们来看看 jQuery 库本身的一些示例：
- en: Note
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the purposes of this demo, I've used jQuery 2.1.1; if you use a different
    version, then you may find that some of the line numbers have changed.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我使用了 jQuery 2.1.1；如果你使用不同版本，那么你可能会发现一些行号已经改变了。
- en: Start by opening up a copy of `jquery.js` within a text editor of your choice—we'll
    begin with the classic `document.ready()` function, which uses the Façade pattern
    and is run from this function at or around line **3375**, as shown in the following
    screenshot:![Exploring the use of patterns within the jQuery library](img/image00354.jpeg)
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在你选择的文本编辑器中打开`jquery.js`的一个副本——我们将从经典的`document.ready()`函数开始，它使用 Façade 模式，并且在大约**3375**行附近运行此函数，如下面的屏幕截图所示：![探索
    jQuery 库中模式的使用](img/image00354.jpeg)
- en: How many times have you toggled the state of an element in your page? I'm guessing
    it will be a fair few times; the `toggle` command is a classic example of a Strategy
    design pattern, where we decide the state of an element, as shown here:![Exploring
    the use of patterns within the jQuery library](img/image00355.jpeg)
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你有多少次切换页面中元素的状态？我猜可能会有很多次；`toggle`命令是策略设计模式的一个典型例子，我们在这里决定一个元素的状态，如下所示：![探索
    jQuery 库中模式的使用](img/image00355.jpeg)
- en: Now, I'm sure you've clicked on countless elements or used the `click` event
    handler, right? I hope so, as it is one of the first event handlers we are likely
    to have started with when first learning about jQuery. It's also a good example
    of the Observer pattern. Here's the relevant code in jQuery, from around line
    **7453**:![Exploring the use of patterns within the jQuery library](img/image00356.jpeg)
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我确定你已经点击过无数个元素或使用过`click`事件处理程序，对吗？我希望是的，因为这是我们在学习 jQuery 时可能开始使用的第一个事件处理程序。它也是观察者模式的一个很好的例子。以下是
    jQuery 中相关的代码，大约在**7453**行附近：![探索 jQuery 库中模式的使用](img/image00356.jpeg)
- en: There are plenty more examples of how design patterns are used within the jQuery
    core library; hopefully, this shows the benefit of using them within your own
    code and that they should not be limited to the source code for jQuery itself!
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 核心库中有更多设计模式的使用示例；希望这能展示它们在你自己的代码中的好处，并且它们不应该局限于 jQuery 本身的源代码！
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: Phew! We certainly covered a lot of theory on design patterns; let's take a
    breather and recap what you've learned throughout this chapter.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！我们确实涵盖了很多关于设计模式的理论；让我们稍事休息，回顾一下你在本章学到的东西。
- en: We kicked off with an introduction to what design patterns are and how they
    came about; we then moved on to exploring the benefits of using them and why we
    should consider using them within our projects.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从介绍设计模式是什么以及它们是如何产生的开始；然后我们继续探讨了使用它们的好处以及为什么我们应该考虑在我们的项目中使用它们。
- en: Next up came a look at the structure of a design pattern, where we broke down
    a typical design into its different elements and saw what role each element plays
    in the scheme of the design. We also looked at how to categorize design patterns
    into different types, namely Creational, Structural, and Behavioral.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一下设计模式的结构，我们将一个典型的设计拆分成其不同的元素，并看到每个元素在设计方案中扮演的角色。我们还看到了如何将设计模式分类为不同类型，即创建型、结构型和行为型。
- en: We then moved on to take a look at a number of common design patterns, where
    we went through what each type does and examined some examples of how we will
    use them. We then looked at the benefits and drawbacks of each of the design patterns
    covered throughout this chapter, before finishing up with a look at how some of
    these patterns are actually used within the jQuery library itself, and not just
    within our own code.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着来看一些常见的设计模式，我们将了解每种类型的作用，并且检视一些我们将如何使用它们的示例。然后，我们将审视本章涵盖的每个设计模式的优缺点，最后看看其中一些模式在
    jQuery 库内是如何实际运用的，而不仅仅是在我们自己的代码中。
- en: I think that's enough theory for now; let's move on and get practical. In the
    next chapter, we'll see how to take your form development skills up a notch with
    some techniques to master form development.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为现在的理论已经足够了；让我们继续并且实践起来。在下一章中，我们将学习如何通过一些技巧来精通表单开发，将你的表单开发技能提升一个档次。
