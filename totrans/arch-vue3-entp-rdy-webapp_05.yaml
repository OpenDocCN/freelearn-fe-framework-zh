- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Introduction to GraphQL, Queries, Mutations, and RESTful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we explored different libraries and methods to develop
    large-scale enterprise applications using Vue 3\. In this chapter, we will first
    understand what GraphQL is and how it is different from REST. Next, we will explore
    GraphQL, GraphQL Apollo Server 2, queries, and mutations, and how to integrate
    these technologies into your Vue.js 3 application. In addition, you will learn
    how to utilize GraphQL to deliver scalable and high-performing applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to GraphQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding queries and mutations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating GraphQL Apollo Client with Vue 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, in this chapter, you will learn how to integrate GraphQL into Vue 3 and
    structure it properly following the law of predictability by implementing a login
    and register authentication system using the GraphQL Apollo client and Vue 3.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started with this chapter, we recommend you read through [*Chapter 4*](B17237_04.xhtml#_idTextAnchor112),
    *Architecture for Large-Scale Web Applications*, where we explored building large-scale
    enterprise applications with different industry-standard structuring, architecture,
    and standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the code files for this chapter can be found at: [https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-5](https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-5).'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GraphQL is the new buzzword in the API development industry. While REST remains
    the most popular way to expose data from a server, it comes with many limitations
    that GraphQL tends to solve.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL is a query language created and maintained by Facebook. The purpose
    of creating GraphQL is to build client applications based on intuitive and flexible
    syntax for describing their data requirements and interactions.
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of GraphQL is that we have a single endpoint to access all
    data from the server instead of having multiple endpoints in REST.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore everything you need to know about GraphQL,
    the different unique features of GraphQL, and why you should consider GraphQL
    instead of the RESTful API design pattern. Lastly, we will work you through creating
    and setting up your first GraphQL server with Express.
  prefs: []
  type: TYPE_NORMAL
- en: What is GraphQL?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As per the official documentation (https://graphql.org/),
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL is a query language for APIs and a runtime for fulfilling those queries
    with your existing data. GraphQL provides a complete and understandable description
    of the data in your API, gives clients the power to ask for exactly what they
    need and nothing more, makes it easier to evolve APIs over time, and enables powerful
    developer tools.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL is a server-side runtime for executing queries using the type system
    you define for your data. Also, GraphQL is not tied to any specific database or
    storage engine but instead backed by your existing code and data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – A diagram explaining GraphQL (Source: https://www.wallarm.com/what/what-is-graphql-definition-with-example)](img/Figure_5.01_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1 – A diagram explaining GraphQL (Source: https://www.wallarm.com/what/what-is-graphql-definition-with-example)'
  prefs: []
  type: TYPE_NORMAL
- en: The GraphQL type system defines various data types that can be used in a GraphQL
    application. This type system helps to define the schemas that will be used in
    the GraphQL application.
  prefs: []
  type: TYPE_NORMAL
- en: To create a GraphQL service, you need to start by defining schema types and
    creating fields on those types, then providing functions to be executed on each
    field.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can define a new schema type called `Photo` in the following
    code snippet to demonstrate how types work in GraphQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now we have an idea of GraphQL and have seen how to define a GraphQL schema
    type. Next, let’s explore the features of GraphQL before we dive deeper into creating
    GraphQL queries and resolvers.
  prefs: []
  type: TYPE_NORMAL
- en: Features of GraphQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GraphQL comes with excellent features. We are going to explore a few of the
    features of GraphQL in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Easy to get started
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The learning curve of GraphQL is easy, especially for developers who are familiar
    with building APIs with RESTful design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Users can get started with GraphQL with small queries for fetching data right
    away and learn about the advanced features a bit later.
  prefs: []
  type: TYPE_NORMAL
- en: Built for interactive apps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GraphQL is built for real-time and interactive applications because changes
    between the client and the server happen almost immediately, giving a swift response.
  prefs: []
  type: TYPE_NORMAL
- en: Small and flexible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GraphQL allows users to request and receive the exact data that was requested.
    This feature solves the problem of over- and under-fetching with RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Universally compatible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GraphQL Apollo is built to be compatible with any build setup, any GraphQL server,
    and any GraphQL schema.
  prefs: []
  type: TYPE_NORMAL
- en: Incrementally adoptable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GraphQL is built to make integrating into a new or existing project effortless
    without breaking any changes. It is easily adaptable.
  prefs: []
  type: TYPE_NORMAL
- en: Why use GraphQL instead of REST?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will identify some properties of GraphQL and discuss why
    you should use GraphQL for your subsequent API development instead of RESTful
    APIs. We will discuss a few of these properties. Additionally, we will get into
    a detailed comparison of these technologies with the GraphQL versus RESTful API
    guide in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The following subsections mention the top five reasons why you should use GraphQL
    instead of RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: Strongly-typed schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In GraphQL, **Schema Definition Language** (**SDL**) is used to define the contract
    between the client and the server and to define how the client accesses the data
    in the server. GraphQL uses a strong type system to define the capabilities of
    the API. All the APIs exposed to the client are written down in a schema called
    the SDL.
  prefs: []
  type: TYPE_NORMAL
- en: Once these schemas are defined, both the frontend and the backend can communicate
    separately without any further changes or assistance since the frontend knows
    that the data in the schema is always going to be in sync or consistent across
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: This solves the data inconsistency problem in REST. The frontend expects a specific
    dataset but retrieves a different one due to changes since no consistent schema
    is defined.
  prefs: []
  type: TYPE_NORMAL
- en: No over-fetching or under-fetching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The issue of over- or under-fetching is a known problem with RESTful APIs where
    clients download data by hitting endpoints that return fixed data structures or
    retrieve either excessive amounts of data or less than what they expected.
  prefs: []
  type: TYPE_NORMAL
- en: Over-fetching is the problem of fetching more data than what is required in
    the app. It can also mean fetching more data than what is required to fulfill
    the request. With a RESTful API, you have to fetch all the user’s details or create
    a new endpoint that returns only the names of all the users of your application
    just to display only the name of the user on your frontend application. While
    in GraphQL, you can use just a single query to return only the name of all the
    users or any other details by creating a separate query or endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Under-fetching is rare, but it happens when the specific endpoint does not provide
    all the required information. The client must make additional requests to access
    the other information as needed.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL solves this problem by providing a medium for the client to specify
    the information needed, and it returns exactly the required information.
  prefs: []
  type: TYPE_NORMAL
- en: Saving time and bandwidth
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The problem of over-fetching can result in higher bandwidth consumption for
    clients, which may, in time, cause lagging in your application. Using RESTful
    API design patterns, it is more time-consuming to sort out the information needed
    from an enormous payload.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL allows you only to select what you need, thereby reducing the amount
    of payload transferred over the network.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple endpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the significant problems of RESTful APIs is having too many endpoints
    to access information. For instance, if a client wants to access a particular
    user by their ID, you will be presented with `/users/1`. Also, if you’re going
    to access that user’s photos, you will have to send a request to another endpoint,
    `/users/1/photos`.
  prefs: []
  type: TYPE_NORMAL
- en: In GraphQL, you have a single endpoint, and you don’t need to send multiple
    requests to retrieve different information about the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'With GraphQL, you can access all the user’s information in a single request,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding script will only access `name` of the user and `title` and `url`
    of all the user’s `photos`.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning is not required
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Versioning is a feature of RESTful APIs where different versions are assigned
    to an API when changes and updates are made to it. This is done to avoid breaking
    changes in production that might cause issues for the user.
  prefs: []
  type: TYPE_NORMAL
- en: If we want users to use our new features in the latest version, we have to force
    them to update the application, which is not a good user experience.
  prefs: []
  type: TYPE_NORMAL
- en: In GraphQL, there is no need to worry about versioning and forcing users to
    update their application to use the new changes since it happens automatically,
    and clients only implement the features available in the SDL.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have discussed the different features and benefits of using GraphQL
    and why you should consider using GraphQL instead of RESTful APIs. In the next
    section, we will further discuss the difference between GraphQL and RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between GraphQL and RESTful APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core difference between GraphQL and REST is that GraphQL is a specification
    and a query language, while REST APIs are an architectural concept for network-based
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Both concepts play an important role in creating and maintaining scalable microservices
    and large-scale enterprise applications.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, choosing a particular technology to go with will depend on your level
    of expatriation in each technology, which one your team is comfortable with, and
    which one makes your product development easier and faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following points show you the other differences you might want to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL is a query language used to solve problems by integrating APIs, while
    REST API is an architectural style that describes the conventional standard for
    designing APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, with GraphQL, you can use a single endpoint to access all the
    data in your server without the need for multiple endpoints, while REST API allows
    multiple endpoints and a set of URLs that each exposes a single resource, which
    can be confusing to understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL uses a client-driven architecture and lacks an in-built caching mechanism,
    while REST API uses a server-driven architecture and uses caching automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No API versioning is required in GraphQL, and its response is only in JSON format,
    while REST APIs support multiple API versioning and allow response output in XML,
    JSON, or YAML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL offers type safety and auto-generated documentation and it also allows
    schema stitching and remote data fetching, while REST API doesn’t offer type safety
    or auto-generated documentation, and simplifying work with multiple endpoints
    requires expensive custom middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL is also an application-layer server-side technology used for executing
    queries with existing data, while REST is a software architectural style used
    to define a set of constraints for creating web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL can be organized in terms of a schema, while REST is not arranged or
    organized in schemas but is arranged in terms of endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The development speed in GraphQL is faster when compared with REST APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The message format for GraphQL mutations should be a string, while the message
    format for REST APIs can be anything
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL uses metadata for query validation, while REST does not have cacheable
    machine-readable metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have explored the difference between GraphQL and REST API to give you an
    insight into which is better for your enterprise application. We will allow you
    to make a choice, but we will explore GraphQL in more depth in the following sections.
    In the next section, we will discuss queries and mutations, expanding more on
    how to create your first query and mutation.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding queries and mutations in GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Queries and mutations are vital in GraphQL because they are the only way to
    access or send data to the GraphQL server from your frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Using queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GraphQL queries define all the queries that a client can run on the GraphQL
    API. If you’re familiar with REST APIs, it is synonymous with the popular `GET`
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: You can define GraphQL queries in many ways, but defining a root query to wrap
    all your queries is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows you how to define a root query called `RootQuery`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also define individual queries for `User` and `Photo` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding queries, we have successfully defined endpoints to retrieve
    users and photos corresponding to how it can be done with REST API using the `GET`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore how to create or update data on our GraphQL API using
    mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Using mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mutations in GraphQL are used to create, update, and delete data from our GraphQL
    API, and are synonymous with REST API’s `POST`, `PUT`, and `DELETE` methods, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating mutations in GraphQL is simple; take a look at the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet shows how to create mutations. Furthermore, we have created
    `createUser`, `updateUser`, and `removeUser` to create, update, and delete users
    from the GraphQL API.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, for GraphQL to connect to our database and carry out the operations
    in both queries and mutations, we need to define a resolver, which we will cover
    in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Resolvers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A GraphQL resolver connects our queries and mutations to the right methods for
    execution. It informs GraphQL what to do when each of these queries/mutations
    is requested. It is a basic function that does the hard work of hitting the database
    layer to do the CRUD operations, hitting an internal REST endpoint, or calling
    a microservice to fulfill the client’s request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s map the queries/mutations we have created in the preceding sections to
    a resolver that will be called when any of the queries/mutations are requested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To foster understanding, we imported our model from `sequelize`, which is a
    database **object-relational mapping** (**ORM**) to manipulate database tables
    with defined methods.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we created and exported a `resolver` function, which returns an object
    containing `RootQuery` and `RootMutation`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, inside the `RootQuery` and `RootMutation` objects, we resolve each of
    the methods with the appropriate business logic to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when a client requests all users, the GraphQL frontend client will
    call the user’s queries defined in the `sequelize` ORM. The same logic applies
    to all the mutations.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explained of how GraphQL works and how you can create your
    own GraphQL API to understand the best way to structure your GraphQL client in
    the frontend for enterprise projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to explore the best way to structure your
    enterprise Vue.js application with GraphQL for scalability and faster team adoption.
    Remember the law of predictability for your teams that we discussed in [*Chapter
    3*](B17237_03.xhtml#_idTextAnchor087)*, Scaling Performance in* *Vue.js 3*.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating GraphQL Apollo Client with Vue 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is tempting to ask what the best way to integrate GraphQL client into Vue
    3 is and how to structure it in an enterprise project to foster faster adoption
    by team members, including new team members.
  prefs: []
  type: TYPE_NORMAL
- en: In my career as a full-stack software engineer, I recently joined a fintech
    company using Vue 3 and GraphQL to disrupt the fintech industry in Germany, and
    I was so impressed at the arrangement of such a large code base and how easy it
    was for me to jump right into solving my first task.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to structure your Vue 3 project with GraphQL, but I want
    to outline the best way I have seen that works for small- or large-scale enterprise
    projects, including the fintech one I worked on.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL Apollo Client is a JavaScript library used to connect to the GraphQL
    server to interchange data. With the library, you can connect to the server, send
    requests, and receive responses from the server.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will start by listing and installing the necessary packages for GraphQL
    and the GraphQL client in Vue 3.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to install all the necessary packages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type in the following commands to install `graphql`, `graphql-tag`, `apollo-composable`,
    and `apollo client`. These are the recommended libraries from the official documentation
    used to communicate with the GraphQL server using Vue 3:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After installation, we will create a new file called `apollo.config.js` inside
    our `plugins` folder from the folder structure we created in [*Chapter 3*](B17237_03.xhtml#_idTextAnchor087)*,
    Scaling Performance in Vue.js 3* and add the following scripts to configure the
    `graphql` client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]js'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: import { ApolloClient, createHttpLink, InMemoryCache } from '@apollo/client/core'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // HTTP connection to the API
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: const httpLink = createHttpLink({
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // You should use an absolute URL here
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'uri: ''http://localhost:3020/graphql'','
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Cache implementation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: const cache = new InMemoryCache()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Create the apollo client
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: const apolloClient = new ApolloClient({
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'link: httpLink,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cache,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: export default apolloClient
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, inside your Vue 3 `main.js` file, add the following script to the existing
    one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]js'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: import { createApp, provide, h } from 'vue'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: import apolloClient from "./plugins/apollo.config";
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: import { DefaultApolloClient } from '@vue/apollo-composable'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: const app = createApp({
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: setup () {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: provide(DefaultApolloClient, apolloClient)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'render: () => h(App),'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding steps, we demonstrated how to install the GraphQL client and
    completely set it up with the other libraries in our Vue 3 enterprise application.
    In the next section, we will discuss the best practices for structuring our Vue
    3 application with GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring GraphQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After successfully installing and configuring Apollo Client with Vue 3, let’s
    structure our queries and mutations around the law of predictability to enable
    old and new team members to easily adapt to the project.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder inside the `src` folder called `graphql`. This new folder
    will contain all our queries and mutations grouped in to different directories
    according to the features of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take an example from the schema we developed in the previous section.
    From the schema, it is clear that our project has `User` and `Photo` features,
    so we will create different folders inside the general `graphql` folder for these
    specific features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create new folders using the following command line or manually from your code
    editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You should have a new folder structure, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The folder structure after installing and setting up GraphQL](img/Figure_5.02_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – The folder structure after installing and setting up GraphQL
  prefs: []
  type: TYPE_NORMAL
- en: After installing and setting up GraphQL, your folder structure should look like
    the preceding screenshot, containing each feature with its corresponding queries
    and mutations file.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring your GraphQL API this way makes it easy for your team to automatically
    understand where to find anything related to GraphQL queries or mutations and
    in which feature they are looking for them.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our folder structure figured out for predictability, in the
    next section, we will demonstrate with a practical exercise using the structure
    we learned about in the previous sections to authenticate a user into our application
    using GraphQL Apollo Client and JWT installed on our GraphQL server.
  prefs: []
  type: TYPE_NORMAL
- en: JWT authentication for sign in/sign up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the structure we have on the ground, it becomes easy to add new features
    and write our queries/mutations without scattering them in the code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s demonstrate how to implement the login and register authentication process
    with GraphQL and Vue 3 by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, create a new folder called `auth` inside the `graphql` folder and
    add `mutations.js` inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the newly created mutation file, add the following script for registration
    and login endpoints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, export the mutation inside the `graphql/index.js` file we created earlier
    to make it available throughout our Vue application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `export` script makes importing our GraphQL queries and mutations a lot
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at how to call the authentication mutation inside the Vue
    3 component and retrieve the user’s information.
  prefs: []
  type: TYPE_NORMAL
- en: With the `vue-composable` library we installed earlier, we can use different
    GraphQL hooks, such as `useMutation` and `useQuery`, to manipulate the GraphQL
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `login` component inside the `organisms` folder and add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first code snippet shows the template and the view part of the component;
    it has a form component with four child components, including `TextField`, `CheckField`,
    and `Button`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The script section of the component performs the business logic; it has many
    properties and a function called `Login`, which performs the authentication process
    for your application.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding snippet shows how to implement the login functionality for our
    project. You can implement the registration component or take a look at the repository
    ([https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-5](https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-5))
    for the complete code base for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.3 – A screenshot sh\uFEFFowing the implementation of a login form](img/Figure_5.03_B17237.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – A screenshot showing the implementation of a login form
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter delved deeper into GraphQL, GraphQL Apollo Server 2, queries, mutations,
    and how to integrate these technologies into your Vue.js 3 application. In addition,
    we learned how to utilize GraphQL to deliver scalable and high-performing applications.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered in detail how to integrate GraphQL into Vue 3 and properly structure
    it following the law of predictability.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we demonstrated how to implement a login and register authentication
    system using GraphQL Apollo Client and Vue 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to build a complete Pinterest clone
    with Vue 3 and GraphQL. You will utilize your knowledge of GraphQL to develop
    and deliver an enterprise application such as Pinterest using Vue 3 and GraphQL.
  prefs: []
  type: TYPE_NORMAL
