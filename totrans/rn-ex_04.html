<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Advanced Functionality with the Expenses App</h1>
            </header>

            <article>
                
<p>In the last chapter, we began working on an expense tracking app simply titled <kbd>Expenses</kbd>. After getting some basic functionality written for the app, our next goal is to continue working on the app and add new features to it that will make the app feature-complete. This chapter will cover the following topics:</p>
<ul>
<li>Utilizing the <kbd>react-native-vector-icons</kbd> library to utilize icons in our app</li>
<li>Learning how to use the <kbd>Picker</kbd> component to render a dropdown, such as an interface that can accept any array of items for user selection</li>
<li>Updating our list view to show the expense category icons and show the current amount spent with a progress bar</li>
<li>Creating a second view that renders the previous months' expenses</li>
<li>Using the <kbd>Icon.TabBarIOS</kbd> component to toggle between the current month's and the previous month's view</li>
<li>Allowing deletion of added expenses for both the current month and the previous ones</li>
</ul>
<div class="packt_figure packt_infobox">Due to the extensive features in this chapter, the section on making modifications for this app to run on an Android device has been moved to <a href="c9cb084b-5c75-4683-94c3-9b2124e8ecb0.xhtml">Chapter 9</a>, <em>Additional React Native Components</em>.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Using vector icons</h1>
            </header>

            <article>
                
<p>In <a href="6ac206f7-d3d2-4b39-89ab-a6fdcf124e02.xhtml">Chapter 3</a>, <em>Our Second Project - The Budgeting App</em>, we mentioned that upon tapping that button, the user should be shown a modal that allows them to input details for their expenses: the name, amount, date the purchase was made on, and an icon to categorize the item. The modal should <kbd>allow</kbd> the user to either cancel or save the entry they make.</p>
<p>For our first exercise, we should do the following things:</p>
<ul>
<li>Begin by writing a utilities file for handling icons:
<ul>
<li>This file should contain an object that contains the stringified names of categories and their icon names from our vector icon library.</li>
<li>This file should also contain a method that takes in the name, desired size, and color of an icon and returns that icon as a component. Treat this as a stateless functional component.</li>
</ul>
</li>
</ul>
<p>Let's look at how we can utilize the vector icon library that we installed in the last chapter.</p>
<p>We can import <kbd>react-native-vector-icons</kbd> with the following statement:</p>
<pre>
import Icon from '                                                                                                                                                                                                                                                                                                                                   react-native-vector-icons/FontAwesome'; 
</pre>
<p>This maps a reference of <kbd>Icon</kbd> to a component that uses the Font Awesome icon set.</p>
<p>To utilize it, you can render an <kbd>Icon</kbd> component like this:</p>
<pre>
&lt;Icon name="rocket" size={ 30 } color="#900" /&gt; 
</pre>
<p>The <kbd>name</kbd> property tells the library which icon to pull from its collection. You can find a list of all the icons that Font Awesome contains at <a href="http://fontawesome.io"><span class="URLPACKT">http://fontawesome.io</span></a>.</p>
<p>Our app will contain the following 12 icons:</p>
<ul>
<li><kbd>home</kbd></li>
<li><kbd>shopping-cart</kbd></li>
<li><kbd>cutlery</kbd></li>
<li><kbd>film</kbd></li>
<li><kbd>car</kbd></li>
<li><kbd>coffee</kbd></li>
<li><kbd>plane</kbd></li>
<li><kbd>shopping-bag</kbd></li>
<li><kbd>book</kbd></li>
<li><kbd>beer</kbd></li>
<li><kbd>gamepad</kbd></li>
<li><kbd>plug</kbd></li>
</ul>
<p>The categories that these icons represent will be (in order) the following ones:</p>
<ul>
<li>Home</li>
<li>Grocery</li>
<li>Restaurant</li>
<li>Entertainment</li>
<li>Car</li>
<li>Coffee</li>
<li>Travel</li>
<li>Shopping</li>
<li>Books</li>
<li>Drinks</li>
<li>Hobby</li>
<li>Utilities</li>
</ul>
<p>With these in mind, we should create a helper file that will let us render an icon.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Icon methods</h1>
            </header>

            <article>
                
<p>The <kbd>iconMethods</kbd> file will be a lot simpler than our previous helper methods. With <kbd>iconMethods</kbd>, our goal is to keep an object that maps category names and icons and then, export a function that will help us return the <kbd>react-native-vector-icon</kbd> components.</p>
<pre>
import React from 'react'; <br/><br/>import Icon from 'react-native-vector-icons/FontAwesome'; <br/><br/>const expenses = [ <br/>  { amount: '4', category: 'coffee', description: 'Latte' }, <br/>  { amount: '1.50', category: 'books', description: 'Sunday Paper' }, <br/>  { amount: '35', category: 'car', description: 'Gas' }, <br/>  { amount: '60', category: 'restaurant', description: 'Steak dinner' } <br/>];  
</pre>
<p>The <kbd>categories</kbd> object lets us quickly access both the category and icon name:</p>
<pre>
export const getIconComponent = (categoryName, size, color) =&gt; { <br/>  return ( <br/>    &lt;Icon <br/>      name={ categories[categoryName].iconName } <br/>      size={ size || 30 } <br/>      color={ color || '#3D4A53' }  <br/>    /&gt; <br/>  ); <br/>} 
</pre>
<p>Here, we have a stateless function, <kbd>getIconComponent</kbd>, that accepts the <kbd>name</kbd> of a category along with an optional <kbd>size</kbd> and <kbd>color</kbd>, then returns an <kbd>Icon</kbd> component for our app.</p>
<p>Now that we have our <kbd>iconMethods</kbd> file built out, it's time to create a <kbd>Picker</kbd> component to select a category.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Picker</h1>
            </header>

            <article>
                
<p>So far in this book, we have used <kbd>DatePickerIOS</kbd> and <kbd>DatePickerAndroid</kbd> for users to select dates. Each platform also has access to a native <kbd>Picker</kbd> component, where we can populate an array of choices and allow our users to interact with it.</p>
<p>Building a <kbd>Picker</kbd> is easy. We start by writing a <kbd>Picker</kbd> in the <kbd>render</kbd> method of a component and populate it with <kbd>Picker.Item</kbd> children:</p>
<pre>
&lt;Picker&gt; <br/>  &lt;Picker.Item  <br/>    label='Hello' <br/>    value='hello' <br/>  /&gt; <br/>&lt;/Picker&gt;  
</pre>
<p>Then, we can give the <kbd>Picker</kbd> some props. The following ones are used in this exercise:</p>
<ul>
<li><kbd>onValueChange</kbd>: This is a callback fired when an item has been selected. It passes two arguments: <kbd>itemValue</kbd> and <kbd>itemPosition</kbd></li>
<li><kbd>selectedValue</kbd>: This is a reference to the current value of the <kbd>Picker</kbd> list</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Selecting a category</h1>
            </header>

            <article>
                
<p>We will modify our existing <kbd>AddExpensesModal</kbd> component to add the following functionality:</p>
<ul>
<li>Create a <kbd>Button</kbd> right below the <kbd>ExpandableCell</kbd>/<kbd>DatePickerIOS</kbd> component to select a category for our expense.</li>
<li>On press, that button should render a <kbd>Picker</kbd> component for the user to interact with. This <kbd>Picker</kbd> should have the following features:
<ul>
<li>Contain the list of twelve categories that we are using in our app as <kbd>Picker</kbd> items by mapping the array instead of hardcoding each of the twelve categories.</li>
<li>Have a callback that sets the selected value as the selected category for our expense. Next:
<ul>
<li>Render this <kbd>Picker</kbd> as a child of an <kbd>ExpandableCell</kbd> component within <kbd>AddExpensesModal</kbd> so that it can be collapsed when not in use.</li>
<li>Render the preceding <kbd>ExpandableCell</kbd> component between the date and save/cancel buttons within <kbd>AddExpensesModal</kbd>.</li>
<li>Use the <kbd>getIconComponent</kbd> function from <kbd>iconMethods</kbd> to render the selected category's icon, if applicable, and style it so that it appears on the page in the same row as the <kbd>ExpandableCell</kbd> for our <kbd>Picker</kbd> component.</li>
<li>Modify <kbd>AddExpensesModal</kbd> so that its submit button is also disabled if a category has not been set by the user.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The <kbd>AddExpensesModal</kbd> component and its styles underwent a significant number of changes since the last time we looked at them in the last chapter.</p>
<pre>
// Expenses/app/components/AddExpensesModal/index.js <br/><br/>...<br/>import { <br/>  ... <br/>  Picker, <br/>  ... <br/>} from 'react-native'; <br/>... <br/>import * as iconMethods from '../../utils/iconMethods'; <br/>... <br/>export default class AddExpensesModal extends Component { <br/>  ... <br/>  constructor (props) { <br/>    super (props); <br/><br/>    this.state = { <br/>      amount: '', <br/>      category: undefined, <br/>      categoryPickerExpanded: false, <br/>      date: new Date(), <br/>      description: '', <br/>      datePickerExpanded: false <br/>    } <br/>  } 
</pre>
<p>The <kbd>expanded</kbd> key is replaced by two separate Booleans for each <kbd>ExpandableCell</kbd>.</p>
<p>The <kbd>expandableCellTitle</kbd> is replaced by one string for each <kbd>ExpandableCell</kbd>:</p>
<pre>
  render () { <br/>    const expandableCellDatePickerTitle = ... <br/>    const expandableCellCategoryPickerTitle = 'Category: ' +<br/>      (this.state.category ? iconMethods.categories<br/>      [this.state.category].name : 'None (tap to change)') 
</pre>
<p>The rendering of the original <kbd>ExpandableCell</kbd> has been modified to accommodate the changes in variable and function names to make it more specific to its child component:</p>
<pre>
    return ( <br/>      &lt;Modal <br/>        animationType={ 'slide' } <br/>        transparent={ false } <br/>        visible={ this.props.modalVisible } <br/>      &gt; <br/>        &lt;ScrollView style={ styles.modalContainer }&gt; <br/>          ... <br/>          &lt;View style={ [styles.expandableCellContainer,<br/>          { height: this.state.datePickerExpanded ? this.state.<br/>          datePickerHeight : 40 }]}&gt; <br/>            &lt;ExpandableCell <br/>              expanded={ this.state.datePickerExpanded } <br/>              onPress={ () =&gt; this._onDatePickerExpand() } <br/>              title={ expandableCellDatePickerTitle }&gt; <br/>              &lt;DatePickerIOS <br/>                date={ this.state.date } <br/>                mode={ 'date' } <br/>                onDateChange={ (date) =&gt; this._onDateChange(date) } <br/>                onLayout={ (event) =&gt; this._getDatePickerHeight(event) <br/>                } <br/>              /&gt; <br/>            &lt;/ExpandableCell&gt; <br/>          &lt;/View&gt; <br/>          &lt;View style={ [styles.expandableCellContainer, <br/>          { height: this.state.categoryPickerExpanded ? 200 : 40 }]}&gt; <br/>            &lt;View style={ styles.categoryIcon }&gt; <br/>              { this.state.category &amp;&amp; iconMethods.<br/>              getIconComponent(this.state.category) } <br/>            &lt;/View&gt;
</pre>
<p>This is the newly-added <kbd>ExpandableCell</kbd> component, rendering a <kbd>Picker</kbd> underneath it:</p>
<pre>
            &lt;ExpandableCell <br/>              expanded={ this.state.categoryPickerExpanded } <br/>              onPress={ () =&gt; this._onCategoryPickerExpand() } <br/>              title={ expandableCellCategoryPickerTitle }&gt; <br/>                &lt;Picker <br/>                onValueChange={ (value, index) =&gt;<br/>                this._setItemCategory(value) } <br/>                selectedValue={ this.state.category }&gt; <br/>                { this._renderCategoryPicker() } <br/>              &lt;/Picker&gt; <br/>            &lt;/ExpandableCell&gt; <br/>          &lt;/View&gt; 
</pre>
<p>The <kbd>Button</kbd> component used to save an expense has been modified to check for the presence of a category to allow its saving:</p>
<pre>
          &lt;Button <br/>            color={ '#86B2CA' } <br/>            disabled={ !(this.state.amount &amp;&amp; <br/>            this.state.description &amp;&amp; this.state.category) } <br/>            onPress={ () =&gt; this._saveItemToBudget() } <br/>            title={ 'Save Expense' } <br/>          /&gt;  <br/>          ... <br/>        &lt;/ScrollView&gt; <br/>      &lt;/Modal&gt; <br/>    ) <br/>  } 
</pre>
<p>The <kbd>_clearFieldsAndCloseModal</kbd> method has been updated for the new fields:</p>
<pre>
  ... <br/>  _clearFieldsAndCloseModal () { <br/>    this.setState({ <br/>      amount: '', <br/>      category: undefined, <br/>      categoryPickerExpanded: false, <br/>      date: new Date(), <br/>      datePickerExpanded: false, <br/>      description: '' <br/>    }); <br/><br/>    this.props.toggleModal() <br/>  } 
</pre>
<p>The <kbd>_onDatePickerExpand</kbd> method is just a renaming of the old <kbd>_onExpand</kbd> method, while <kbd>_onCategoryPickerExpand</kbd> is specific to the <kbd>Picker</kbd> category:</p>
<pre>
  ... <br/>  _onCategoryPickerExpand () { <br/>    this.setState({ <br/>      categoryPickerExpanded: !this.state.categoryPickerExpanded <br/>    }) <br/>  } <br/><br/>  _onDatePickerExpand () { <br/>    this.setState({ <br/>      datePickerExpanded: !this.state.datePickerExpanded <br/>    }); <br/>  } 
</pre>
<p>Render each <kbd>Picker.Item</kbd> by mapping the array of category names to a new element:</p>
<pre>
  _renderCategoryPicker () { <br/>    var categoryNames = Object.keys(iconMethods.categories); <br/><br/>    return categoryNames.map((elem, index) =&gt; { <br/>      return ( <br/>        &lt;Picker.Item <br/>          key={ index } <br/>          label={ iconMethods.categories[elem].name } <br/>          value={ elem } <br/>        /&gt; <br/>      ) <br/>    }) <br/>  } 
</pre>
<p>The <kbd>_setItemCategory</kbd> function is fired in the <kbd>onValueChange</kbd> callback of our <kbd>Picker</kbd> category:</p>
<pre>
  _setItemCategory (category) { <br/>    this.setState({ <br/>      category <br/>    }); <br/>  } 
</pre>
<p>Save the <kbd>category</kbd> property to storage as part of <kbd>_saveItemToBudget</kbd>:</p>
<pre>
  async _saveItemToBudget () { <br/>    const expenseObject = { <br/>      amount: this.state.amount, <br/>      category: this.state.category, <br/>      date: moment(this.state.date).format('ll'), <br/>      description: this.state.description <br/>    }; <br/><br/>    await storageMethods.saveItemToBudget(this.props.month, <br/>    this.props.year, expenseObject); <br/><br/>    this._clearFieldsAndCloseModal(); <br/>  } <br/>} 
</pre>
<p><span>This is how the new <kbd>Picker</kbd> component should look:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1443 image-border" height="358" src="assets/image_04_001-1.png" width="209"/></div>
<p class="CDPAlignLeft CDPAlign">I added styling for <kbd>categoryIcon</kbd>:</p>
<pre>
// Expenses/app/components/AddExpensesModal/styles.js <br/><br/>import { Dimensions, Navigator, StyleSheet } from 'react-native'; <br/><br/>const styles = StyleSheet.create({ <br/>  ... <br/>  categoryIcon: { <br/>    flex: 1, <br/>    marginLeft: Dimensions.get('window').width - 50, <br/>    position: 'absolute' <br/>  }, 
</pre>
<p>The preceding code uses the <kbd>Dimensions</kbd> API to set <kbd>marginLeft</kbd> to the width <span>of </span><span>the screen minus</span> <kbd>50</kbd> <span>pixels.</span></p>
<pre>
  ... <br/>  expandableCellContainer: { <br/>    flex: 1, <br/>    flexDirection: 'row' <br/>  }, <br/>  ... <br/>}); <br/><br/>export default styles; 
</pre>
<p>The preceding code has updated styling to contain a <kbd>flexDirection</kbd> of <kbd>row</kbd>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Updating CurrentMonthExpenses and ExpenseRow</h1>
            </header>

            <article>
                
<p>Up to this point, we have been rendering the <kbd>CurrentMonthExpenses</kbd> and <kbd>ExpenseRow</kbd> components without a category as one did not exist previously. Let's update them with the following goals in mind:</p>
<ul>
<li><kbd>CurrentMonthExpenses</kbd> should access each item's category and pass it to <kbd>ExpenseRow</kbd></li>
<li><kbd>ExpenseRow</kbd> should render the appropriate category's assigned icon in the row of expenses so that our users can quickly visualize what it is that they spent part of their budget on</li>
</ul>
<ul>
<li>We should use the <kbd>resetAsyncStorage</kbd> method created in <kbd>StorageMethods</kbd> to clear any current list of expenses before modifying <kbd>ExpenseRow</kbd> so that the previous expenses without a category assigned will not cause any issues</li>
</ul>
<p>Once you have updated these components, check out my solution, which is as follows:</p>
<pre>
// Expenses/app/App.js <br/><br/>... <br/>export default class App extends Component { <br/>  ... <br/>  componentWillMount () { <br/>    storageMethods.resetAsyncStorage(); <br/>    ... <br/>  } <br/>  ... <br/>}
</pre>
<p>The preceding code used one time (and not saved in the file afterwards) to clear storage.</p>
<p>Then, I updated the <kbd>CurrentMonthExpenses</kbd> component to pass in the <kbd>category</kbd> an expense was assigned as a prop to the <kbd>ExpenseRow</kbd> component:</p>
<pre>
// Expenses/app/components/CurrentMonthExpenses/index.js <br/><br/>... <br/>export default class CurrentMonthExpenses extends Component { <br/>  ... <br/>  _renderRowData (rowData, rowID) { <br/>    if (rowData) { <br/>      return ( <br/>        &lt;ExpenseRow <br/>          amount={ rowData.amount } <br/>          category={ rowData.category } <br/>          description={ rowData.description } <br/>        /&gt; <br/>      ) <br/>    } <br/>  } <br/>  ... <br/>}; 
</pre>
<p>After that, I created a new <kbd>View</kbd> to render the category icon:</p>
<pre>
// Expenses/app/components/ExpenseRow/index.js <br/><br/>... <br/>import * as iconMethods from '../../utils/iconMethods'; <br/>... <br/>export default (props) =&gt; { <br/>  return ( <br/>    &lt;View style={ styles.expenseRowContainer }&gt; <br/>      &lt;View style={ styles.icon }&gt; <br/>        { iconMethods.getIconComponent(props.category) } <br/>      &lt;/View&gt; <br/>      ... <br/>    &lt;/View&gt; <br/>  ) <br/>} 
</pre>
<p>For styling, the following <kbd>icon</kbd> property was added:</p>
<pre>
// Expenses/app/components/ExpenseRow/styles.js <br/><br/>const styles = StyleSheet.create({ <br/>  ... <br/>  icon: { <br/>    flex: 1, <br/>    marginLeft: 10 <br/>  } <br/>}); 
</pre>
<p>Here is how your app should look after icons have been added:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1444 image-border" height="393" src="assets/image_04_002-1.png" width="225"/></div>
<p>Great job on the updates! In the next section, we should give the user a visualization of their remaining budget using a progress indicator.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Updating App.js with ProgressViewIOS</h1>
            </header>

            <article>
                
<p>When planning this app in the last chapter, we wrote that this list should also prominently display the user's set budget for the month along with a progress indicator showing how close they are to hitting their budget.</p>
<p>Using <kbd>ProgressViewIOS</kbd>, we can depict our user's progress toward their monthly limit. The following props will be used in this project:</p>
<ul>
<li><kbd>progress</kbd>: This is a number between <kbd>0</kbd> and <kbd>1</kbd> that tracks the value of the progress bar</li>
<li><kbd>progressTintColor</kbd>: This is a string that sets the color of the progress bar</li>
</ul>
<p>You can render a <kbd>ProgressViewIOS</kbd> component like this:</p>
<pre>
&lt;View&gt; <br/>  &lt;ProgressViewIOS <br/>    progress={ 0.75 } <br/>    progressTintColor={ '#86B2CA' } <br/>  /&gt; <br/>&lt;/View&gt; 
</pre>
<p>In this section, we should update <kbd>Expenses</kbd> to do the following things:</p>
<ul>
<li>First, we should modify the <kbd>checkCurrentMonthBudget</kbd> function from <kbd>storageMethods</kbd> to also return the amount spent for the month</li>
<li>Then, <kbd>App.js</kbd> should have its <kbd>_updateBudget</kbd> function updated to account for the amount spent being returned by <kbd>checkCurrentMonthBudget</kbd></li>
<li>Finally, add a <kbd>ProgressViewIOS</kbd> component to <kbd>CurrentMonthExpenses</kbd>:
<ul>
<li>It should have a function to calculate its <kbd>progress</kbd> prop</li>
<li>It should also show the dollar amount currently spent as a string</li>
</ul>
</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">ProgressViewIOS example</h1>
            </header>

            <article>
                
<p>To begin, we will need to make an addition to our <kbd>storageMethods</kbd> file to grab the current month's spent amount so that we can calculate the <kbd>progress</kbd> prop for <kbd>ProgressViewIOS</kbd>. This can be done by modifying <kbd>checkCurrentMonthBudget</kbd>:</p>
<pre>
// Expenses/app/utils/storageMethods.js <br/><br/>export const checkCurrentMonthBudget = async () =&gt; { <br/>  let year = dateMethods.getYear(); <br/>  let month = dateMethods.getMonth(); <br/><br/>  let response = await getAsyncStorage(); <br/><br/>  if (response === null || !response.hasOwnProperty(year) ||<br/>  !response[year].hasOwnProperty(month)) { <br/>    return false; <br/>  } <br/><br/>  let details = response[year][month]; <br/><br/>  return { <br/>    budget: details.budget, <br/>    spent: details.spent <br/>  } <br/>} 
</pre>
<p>Here, we are returning an object containing both the <kbd>budget</kbd> and <kbd>spent</kbd> amounts as opposed to just the <kbd>budget</kbd>. This means that we will also need to modify how the <kbd>App</kbd> component's <kbd>_updateBudget</kbd> method receives our response data.</p>
<p>The following addition to the <kbd>App</kbd> component just shows the <kbd>_updateBudget</kbd> asynchronous method since it is the only part modified to accommodate <kbd>storageMethods'</kbd> <kbd>checkCurrentMonthBudget</kbd> method's changes:</p>
<pre>
// Expenses/app/App.js <br/><br/>... <br/>  async _updateBudget () { <br/>    let response = await storageMethods.checkCurrentMonthBudget(); <br/><br/>    if (response !== false) { <br/>      this.setState({ <br/>        budget: response.budget, <br/>        spent: response.spent <br/>      }); <br/><br/>      return; <br/>    } <br/><br/>    this._renderEnterBudgetComponent(); <br/>  } 
</pre>
<p>The text block that renders the budget as a string has been modified to display the current amount spent:</p>
<pre>
// Expenses/app/components/CurrentMonthExpenses/index.js <br/><br/>... <br/>import { <br/>  ProgressViewIOS, <br/>  ... <br/>} from 'react-native'; <br/>... <br/>export default class CurrentMonthExpenses extends Component { <br/>  ... <br/>  render () { <br/>    ... <br/>    return ( <br/>      &lt;View style={ styles.currentMonthExpensesContainer }&gt; <br/>        &lt;View style={ styles.currentMonthExpensesHeader }&gt; <br/>          ... <br/>          &lt;Text style={ styles.subText }&gt; <br/>            { this.props.spent } of { this.props.budget } spent <br/>          &lt;/Text&gt; 
</pre>
<p>A <kbd>ProgressViewIOS</kbd> component is also mounted right after the preceding text block, pointing its <kbd>progress</kbd> prop to a function called <kbd>_getProgressViewAmount</kbd>, which calculates it for us:</p>
<pre>
          &lt;ProgressViewIOS <br/>            progress={ this._getProgressViewAmount() } <br/>            progressTintColor={ '#A3E75A' } <br/>            style={ styles.progressView } <br/>          /&gt; <br/>        &lt;/View&gt; <br/>        ... <br/>      &lt;/View&gt; <br/>    ) <br/>  } 
</pre>
<p>The following code is a simple division to grab the percentage:</p>
<pre>
  _getProgressViewAmount () { <br/>    return this.props.spent/this.props.budget; <br/>  } <br/>  ... <br/>}; 
</pre>
<p>Set <kbd>margin</kbd> to <kbd>10</kbd> so that it does not reach the edge of the screen:</p>
<pre>
// Expenses/app/components/CurrentMonthExpenses/styles.js <br/><br/>... <br/>const styles = StyleSheet.create({ <br/>  ... <br/>  progressView: { <br/>    margin: 10 <br/>  }, <br/>  ... <br/>}); <br/><br/>export default styles; 
</pre>
<p>Reduce the <kbd>fontSize</kbd> of both the properties to <kbd>16</kbd> and set <kbd>alignSelf</kbd> to <kbd>center</kbd>:</p>
<pre>
// Expenses/app/components/ExpenseRow/styles.js <br/><br/>... <br/>const styles = StyleSheet.create({ <br/>  amountText: { <br/>    alignSelf: 'center', <br/>    color: '#86B2CA', <br/>    flex: 1, <br/>    fontSize: 16, <br/>    marginRight: 10, <br/>    textAlign: 'right' <br/>  }, 
</pre>
<pre>
  descriptionText: { <br/>    alignSelf: 'center', <br/>    color: '#7D878D', <br/>    fontSize: 16, <br/>    textAlign: 'left' <br/>  }, <br/>}); <br/><br/>export default styles; 
</pre>
<p>As a result of these changes, your app should now have a progress indicator showing the user how close they are to hitting their budget for the month.</p>
<p>Thanks to the <kbd>_updateCurrentMonthExpenses</kbd> function in <kbd>App.js</kbd>, saving new expenses for the month will result in the amount spent and progress indicator being updated accordingly without any new logic having to be written:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1445 image-border" height="332" src="assets/image_04_003-1.png" width="184"/></div>
<p>This looks great! Our next step is to create a second view that will let us look at all the months' expenses, which in turn will have us using a TabBar to toggle between the two.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">A view for prior months' expenses</h1>
            </header>

            <article>
                
<p>Our view for the previous months' expenses should be one that renders a list of the existing months in our budget. It should give us the month, the budget allocated for the month, and have the years separated by some sort of a header. Then, on tap, it should go to the summary for each month to show us our previous months' expenses that were input.</p>
<p>We should create some functions in a new utilities file, named <kbd>mockDataMethods</kbd>, to help us mock the data for the previous months and populate our app:</p>
<pre>
// Expenses/app/utils/mockDataMethods.js <br/><br/>import { setAsyncStorage } from './storageMethods'; <br/><br/>const years = ['2017', '2016', '2015']; <br/>const months = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12']; <br/><br/>const expenses = [ <br/>  { amount: '4', category: 'coffee', description: 'Latte' }, <br/>  { amount: '1.50', category: 'books', description: 'Sunday Paper' }, <br/>  { amount: '35', category: 'car', description: 'Gas' }, <br/>  { amount: '60', category: 'restaurant', description: 'Steak dinner' } <br/>]; 
</pre>
<p>Above, arrays for years, months, and expenses are created and populated with data.</p>
<pre>
const mockObject = { <br/>  budget: 500, <br/>  expenses: expenses, <br/>  spent: 100.5 <br/>}; 
</pre>
<p>I created a mocked object to be assigned to each month:</p>
<pre>
export const mockPreviousMonthExpenses = async () =&gt; { <br/>  let mockedPreviousMonthsExpensesObject = {}; <br/>  years.forEach((year) =&gt; { <br/>    mockedPreviousMonthsExpensesObject[year] = {}; <br/><br/>    months.forEach((month) =&gt; { <br/>      if (year === '2017' &amp;&amp; (parseInt(month) &gt; 1)) { <br/>        return; <br/>      } <br/><br/>      mockedPreviousMonthsExpensesObject[year][month] = <br/>      Object.assign({}, mockObject); <br/>    }); <br/>  }); <br/><br/> setAsyncStorage(mockedPreviousMonthsExpensesObject); <br/>} 
</pre>
<p>This function loops through the <kbd>years</kbd> array and creates an empty object within that year's property. It then does another loop within it to create a similar object for the <kbd>month</kbd> within that <kbd>year</kbd> and assigns the <kbd>mockObject</kbd> to it. Along the way, it also stops the function if we attempt to create any mocked expenses for months past January 2017.</p>
<p>Then, we use our <kbd>setAsyncStorage</kbd> function to assign our mocked expenses object to be the source of truth for our application:</p>
<pre>
// Expenses/app/App.js <br/><br/>import { mockPreviousMonthExpenses } from './utils/mockDataMethods'; <br/>... <br/>export default class App extends Component { <br/>  ... <br/>  componentWillMount () { <br/>    mockPreviousMonthExpenses(); <br/>    storageMethods.logAsyncStorage(); <br/>    ... <br/>  } <br/>  ... <br/>} 
</pre>
<p>Within the <kbd>componentWillMount</kbd> life cycle of <kbd>App.js</kbd>, we can call on the <kbd>mockPreviousMonthExpenses</kbd> function we created in <kbd>mockDataMethods</kbd> to populate our local storage with this mocked data.</p>
<p>Additionally, we use the <kbd>logAsyncStorage</kbd> method from <kbd>storageMethods</kbd> in order to log the information to the console so that we can see that our mocked data has been saved to storage for later use.</p>
<p>Once this step is completed, you should remove the <kbd>mockPreviousMonthExpenses</kbd> function from <kbd>App.js</kbd> since it does not need to be continuously called. Here is how our mocked expenses will look. You can view your own results by calling <kbd>console.table</kbd> on the object and opening up Chrome developer tools:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="446" src="assets/image_04_004.png" width="521"/></div>
<p>After this step has been completed, we should create a new component that will show these details. Since we want a list that contains some sort of headers to separate the years, we will be rendering a <kbd>ListView</kbd> and using the <kbd>renderSectionHeader</kbd> prop to create sections in our app.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">ListView with section headers</h1>
            </header>

            <article>
                
<p>To set up our <kbd>ListView</kbd> to accommodate section headers, we need to make some modifications to the way we've been creating <kbd>ListViews</kbd>.</p>
<p>First, when we instantiate a new <kbd>ListView DataSource</kbd>, we'll be passing it a second callback, <kbd>sectionHeaderHasChanged</kbd>. Like <kbd>rowHasChanged</kbd>, this one checks to see whether a section header has changed. In your code, it looks something like this:</p>
<pre>
 this.state = { <br/>   ds: new ListView.DataSource({ <br/>   rowHasChanged: (r1, r2) =&gt; r1 !== r2, <br/>   sectionHeaderHasChanged: (s1, s2) =&gt; s1 !== s2 <br/>    }), <br/>  } 
</pre>
<p>Then, instead of calling <kbd>cloneWithRows</kbd>, we call the similarly named <kbd>cloneWithRowsAndSections</kbd> function:</p>
<pre>
const dataSource = this.state.ds.cloneWithRowsAndSections<br/>(this.state.listOfExpenses); 
</pre>
<p>Finally, your <kbd>ListView</kbd> component should now accept a function as its <kbd>renderSectionHeader</kbd> prop, which will render the section header for your application:</p>
<pre>
&lt;ListView <br/>  ... <br/>  renderSectionHeader={ (sectionData, sectionID) =&gt; <br/>  this._renderSectionHeader(sectionData, sectionID) } <br/>/&gt; <br/><br/>_renderSectionHeader (sectionData, sectionID) { <br/>  return ( <br/>    &lt;View&gt; <br/>      &lt;Text&gt;{ sectionID }&lt;/Text&gt; <br/>    &lt;/View&gt; <br/>  ) <br/>} 
</pre>
<p>Now that you have an overview of how to apply a section header to your <kbd>ListView</kbd> component, it's time to apply that knowledge. Let's create a new component, <kbd>PreviousMonthsList</kbd>. This component should do the following things:</p>
<ul>
<li>For the time being, replace the rendering of <kbd>CurrentMonthExpenses</kbd> in <kbd>App.js</kbd> with your <kbd>PreviousMonthsList</kbd> component so that you can view your progress while writing the component.</li>
<li>Grab the list of expenses from <kbd>AsyncStorage</kbd> and save it to the component state</li>
<li>Render a <kbd>ListView</kbd> with section headers, which displays the name of the month as a string along with that month's numerical budget and a section header for each year that our <kbd>mocked</kbd> expenses provided</li>
<li>Style the rows and section headers to have a different look from each other</li>
</ul>
<p>Once you have built your version of this component, check for the one that I built:</p>
<pre>
// Expenses/app/App.js <br/><br/>... <br/>import PreviousMonthsList from './components/PreviousMonthsList'; <br/><br/>export default class App extends Component { <br/>  ... <br/>  render () { <br/>    return ( <br/>      &lt;View style={ styles.appContainer }&gt; <br/>        &lt;PreviousMonthsList /&gt; <br/>        ... <br/>      &lt;/View&gt; <br/>    ) <br/>  } <br/>  ... <br/>} 
</pre>
<p>The first thing I did was import <kbd>PreviousMonthsList</kbd> into <kbd>App.js</kbd> and replace where <kbd>CurrentMonthExpenses</kbd> was being mounted in its <kbd>render</kbd> method with <kbd>PreviousMonthsList</kbd> instead. This made it simpler for me to work on the component, knowing that any changes I made would be immediately noticeable.</p>
<p>After this component was completed, I reverted <kbd>App.js</kbd> back to its original state (before the <kbd>PreviousMonthsList</kbd> component was created):</p>
<pre>
// Expenses/app/components/PreviousMonthsList/index.js <br/><br/>import React, { Component } from 'react'; <br/><br/>import { <br/>  ListView, <br/>  Text, <br/>  View <br/>} from 'react-native'; <br/><br/>import styles from './styles'; <br/>import * as dateMethods from '../../utils/dateMethods'; <br/>import * as storageMethods from '../../utils/storageMethods'; <br/><br/>export default class PreviousMonthsList extends Component { <br/>  constructor (props) { <br/>    super (props); <br/><br/>    this.state = { <br/>      ds: new ListView.DataSource({ <br/>        rowHasChanged: (r1, r2) =&gt; r1 !== r2, <br/>        sectionHeaderHasChanged: (s1, s2) =&gt; s1 !== s2 <br/>      }), <br/>      listOfExpenses: {} <br/>    }; <br/>  } 
</pre>
<p>The <kbd>DataSource</kbd> instance saved into component state has the new <kbd>sectionHeaderHasChanged</kbd> function passed into it.</p>
<p>During the <kbd>componentWillMount</kbd> life cycle event, I am asynchronously calling the <kbd>getAsyncStorage</kbd> function from <kbd>storageMethods</kbd> and saving its result into the <kbd>listOfExpenses</kbd> property in the component state:</p>
<pre>
  async componentWillMount () { <br/>    let result = await storageMethods.getAsyncStorage(); <br/><br/>    this.setState({ <br/>      listOfExpenses: result <br/>    }); <br/>  } 
</pre>
<p>The <kbd>dataSource</kbd> constant is being assigned with the <kbd>cloneWithRowsAndSections</kbd> method of the <kbd>ListView.DataSource</kbd> instance saved in the component state so that the section header for our list of expenses is available in the app:</p>
<pre>
   render () { <br/>    const dataSource = this.state.ds.cloneWithRowsAndSections<br/>    (this.state.listOfExpenses); <br/><br/>    return ( <br/>      &lt;View style={ styles.previousMonthsListContainer }&gt; <br/>        &lt;ListView <br/>          automaticallyAdjustContentInsets={ false } <br/>          dataSource={ dataSource } <br/>          renderRow={ (rowData, sectionID, rowID) =&gt; this._<br/>          renderRowData(rowData, rowID) } <br/>          renderSectionHeader={ (sectionData, sectionID) =&gt; this._<br/>          renderSectionHeader(sectionData, sectionID) } <br/>          renderSeparator={ (sectionID, rowID) =&gt; this._<br/>          renderRowSeparator(sectionID, rowID) } <br/>        /&gt; <br/>      &lt;/View&gt; <br/>    ) <br/>  } 
</pre>
<p>There is nothing special in the three stateless functions that handle the rendering of our row data, section header, and separator.</p>
<pre>
  _renderRowData (rowData, rowID) { <br/>    return ( <br/>      &lt;View style={ styles.rowDataContainer }&gt; <br/>        &lt;Text style={ styles.rowMonth }&gt; <br/>          { dateMethods.getMonthString(rowID) } <br/>        &lt;/Text&gt; <br/>        &lt;Text style={ styles.rowBudget }&gt; <br/>          { rowData.budget } <br/>        &lt;/Text&gt; <br/>      &lt;/View&gt; <br/>    ) <br/>  } <br/><br/>_renderRowSeparator (sectionID, rowID) { <br/>    return ( <br/>      &lt;View <br/>        key={ sectionID + rowID } <br/>        style={ styles.rowSeparator } <br/>      /&gt; <br/>    ) <br/>  } <br/><br/>  _renderSectionHeader (sectionData, sectionID) { <br/>    return ( <br/>      &lt;View style={ styles.sectionHeader }&gt; <br/>        &lt;Text style={ styles.sectionText }&gt; <br/>          { sectionID } <br/>        &lt;/Text&gt; <br/>      &lt;/View&gt; <br/>    ) <br/>  } <br/>} 
</pre>
<p>The <kbd>rowDataContainer</kbd> style is given a <kbd>flexDirection</kbd> property set to <kbd>row</kbd> so that the two strings being rendered within it are on the same line:</p>
<pre>
// Expenses/app/components/PreviousMonthsList/styles.js <br/><br/>import { StyleSheet } from 'react-native'; <br/><br/>const styles = StyleSheet.create({ <br/>  previousMonthsListContainer: { <br/>    flex: 1 <br/>  }, <br/>  rowBudget: { <br/>    color: '#86B2CA', <br/>    flex: 1, <br/>    fontSize: 20, <br/>    marginRight: 10, <br/>    textAlign: 'right' <br/>  }, <br/>  rowDataContainer: { <br/>    flex: 1, <br/>    flexDirection: 'row', <br/>    marginTop: 10, <br/>    height: 30 <br/>  }, 
</pre>
<p>The <kbd>sectionHeader</kbd> gets its own styling so that a specified <kbd>height</kbd> and <kbd>backgroundColor</kbd> can be set to visually distinguish it from the rows of data in the <kbd>PreviousMonthsList</kbd> component:</p>
<pre>
  rowMonth: { <br/>    color: '#7D878D', <br/>    flex: 1, <br/>    fontSize: 20, <br/>    marginLeft: 10, <br/>    textAlign: 'left' <br/>  }, <br/>  rowSeparator: { <br/>    backgroundColor: '#7D878D', <br/>    flex: 1, <br/>    height: StyleSheet.hairlineWidth, <br/>    marginLeft: 15, <br/>    marginRight: 15 <br/>  }, <br/>  sectionHeader: { <br/>    height: 20, <br/>    backgroundColor: '#86B2CA' <br/>  }, <br/>  sectionText: { <br/>    color: '#7D878D', <br/>    marginLeft: 10 <br/>  } <br/>}); <br/><br/>export default styles; 
</pre>
<p>At this point, by temporarily rendering <kbd>PreviousMonthsList</kbd> to where <kbd>CurrentMonthExpenses</kbd> previously belonged, we have a view that looks like this:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1446 image-border" height="293" src="assets/image_04_005-1.png" width="161"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">The previous month's expenses</h1>
            </header>

            <article>
                
<p>The next step that we want to carry out is to create a view that shows us the expenses for each month and then allows the user to enter that view by tapping on one of these months. This view should be navigated to when the user long presses on a month in the <kbd>PreviousMonthsList</kbd> component.</p>
<p>Thankfully, we already have a component that can handle this for us. In the last chapter, we built the <kbd>CurrentMonthExpenses</kbd> component that renders the expenses for a given month.</p>
<p>So far in our app, <kbd>CurrentMonthExpenses</kbd> is being rendered in just one place--<kbd>App.js</kbd>. The container that it renders within has a top margin offset to accommodate the navigation bar.</p>
<p>If we want to reuse the <kbd>CurrentMonthExpenses</kbd> component to render any month's expenses, we should build some logic to selectively include a top margin offset equal to the navigation bar's height if the component is being navigated to by <kbd>PreviousMonthsList</kbd>.</p>
<p>This can be achieved by having <kbd>CurrentMonthExpenses</kbd> accept an optional Boolean as a prop to then append its <kbd>currentMonthExpensesContainer</kbd> style with its top margin being set to the navigation bar's height:</p>
<pre>
// Expenses/app/components/CurrentMonthExpenses/index.js <br/><br/>... <br/>import { <br/>  ... <br/>  Navigator, <br/>} from 'react-native'; <br/>... <br/>export default class CurrentMonthExpenses extends Component { <br/>  static propTypes = { <br/>    ... <br/>    isPreviousMonth: PropTypes.bool, <br/>  } <br/><br/>  ... <br/>  render () { <br/>    ... <br/>    return ( <br/>      &lt;View style={ [styles.currentMonthExpensesContainer, <br/>        this.props.isPreviousMonth ? {marginTop: Navigator.<br/>        NavigationBar.Styles.General.TotalNavHeight} : {}] }&gt; <br/>        ... <br/>      &lt;/View&gt; <br/>    ) <br/>  } <br/>  ... <br/>}; 
</pre>
<p>The <kbd>Navigator</kbd> is being imported so that we have access to its navigation bar height. The <kbd>CurrentMonthExpenses</kbd> component's <kbd>propTypes</kbd> have been updated to expect an optional Boolean titled <kbd>isPreviousMonth</kbd>.</p>
<p>Then, the <kbd>render</kbd> method of <kbd>CurrentMonthExpenses</kbd> checks to see whether the <kbd>isPreviousMonth</kbd> Boolean has been passed to the component. If it has, it adds the <kbd>marginTop</kbd> property to the <kbd>currentMonthExpensesContainer</kbd> style equal to the height of the navigation bar.</p>
<p>Now it is time to link each row from <kbd>PreviousMonthsList</kbd> to navigate to the <kbd>CurrentMonthExpenses</kbd> component. Modify your <kbd>PreviousMonthsList</kbd> component so that it does the following things:</p>
<ul>
<li>Importing and wrapping a <kbd>TouchableHighlight</kbd> component over each row being rendered.</li>
<li>When one of the rows is pressed, your app should navigate to <kbd>CurrentMonthExpenses</kbd>.</li>
<li>As part of this navigation to <kbd>CurrentMonthExpenses</kbd>, your app's navigator should pass it all the props that it expects (as specified in the <kbd>propTypes</kbd> object of <kbd>CurrentMonthExpenses</kbd>), along with the optional <kbd>isPreviousMonth</kbd> prop set to <kbd>true</kbd>.</li>
</ul>
<p>When you complete this step, check out the solution that I came up with:</p>
<pre>
// Expenses/app/components/PreviousMonthsList/index.js <br/><br/>... <br/>import { <br/>  ... <br/>  TouchableHighlight, <br/>} from 'react-native'; <br/><br/>import CurrentMonthExpenses from '../CurrentMonthExpenses'; <br/>... <br/><br/>export default class PreviousMonthsList extends Component { <br/>  ... <br/>  _renderRowData (rowData, sectionID, rowID) { <br/>    return ( <br/>      &lt;View style={ styles.rowDataContainer }&gt; <br/>        &lt;TouchableHighlight <br/>          onPress={ () =&gt; this._renderSelectedMonth(rowData,<br/>          sectionID, rowID) } <br/>          style={ styles.rowDataTouchableContainer }&gt; <br/>          ... <br/>        &lt;/TouchableHighlight&gt; <br/>      &lt;/View&gt; <br/>    ) <br/>  } 
</pre>
<p>I modified the <kbd>_renderRowData</kbd> method of <kbd>PreviousMonthsList</kbd> to wrap a <kbd>TouchableHighlight</kbd> component around the row of text. Since <kbd>TouchableHighlight</kbd> can only accept one immediate child component, I wrapped the two text elements around a <kbd>View</kbd>.</p>
<p>The <kbd>_renderSelectedMonth</kbd> method pushes <kbd>CurrentMonthExpenses</kbd> to the navigator and passes it all the expected props for that component. I used the <kbd>Number.toString</kbd> prototype method to convert the <kbd>rowData.budget</kbd> number to a string as <kbd>CurrentMonthExpenses</kbd> expects a string as its <kbd>budget</kbd> prop:</p>
<pre>
  ... <br/>  _renderSelectedMonth (rowData, sectionID, rowID) { <br/>    this.props.navigator.push({ <br/>      component: CurrentMonthExpenses, <br/>      title: dateMethods.getMonthString(rowID) + ' ' + sectionID, <br/>      passProps: { <br/>        budget: rowData.budget.toString(), <br/>        expenses: rowData.expenses, <br/>        isPreviousMonth: true, <br/>        month: rowID, <br/>        spent: rowData.spent, <br/>        year: sectionID <br/>      } <br/>    }) <br/>  } <br/>} 
</pre>
<p>I gave the <kbd>rowDataTouchableContainer</kbd> style a <kbd>height</kbd> of <kbd>30</kbd> pixels and set the <kbd>flexDirection</kbd> property of <kbd>textRow</kbd> to <kbd>row</kbd> so that the two <kbd>Text</kbd> components within it will render properly:</p>
<pre>
// Expenses/app/components/PreviousMonthsList/styles.js <br/><br/>... <br/>const styles = StyleSheet.create({ <br/>  ... <br/>  rowDataTouchableContainer: { <br/>    flex: 1, <br/>    height: 30 <br/>  }, <br/>  ... <br/>  textRow: { <br/>    flex: 1, <br/>    flexDirection: 'row' <br/>  } <br/>}); <br/>... 
</pre>
<p>When the user presses on the name of a previous month, they will now see the following view:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1447 image-border" height="366" src="assets/image_04_006-1.png" width="202"/></div>
<p>Now, we have two different paths for our users to take in the app: they can view add expenses to the current month's list in <kbd>App.js</kbd>, or they can view the archives of all of their previous months' expenses. In the next section, we will learn how to implement a tab bar to show these two views.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Implementing TabBarIOS</h1>
            </header>

            <article>
                
<p><kbd>TabBarIOS</kbd> renders a tabbed navigation bar at the bottom of the screen. The bar can contain multiple icons, each responsible for a different view.</p>
<p>The different tabs that <kbd>TabBarIOS</kbd> renders are considered items of the tab bar. They are declared as <kbd>TabBarIOS.Item</kbd> components and are nested as children within <kbd>TabBarIOS</kbd>.</p>
<p>However, with the <kbd>react-native-vector-icons</kbd> library we imported, we would like to use Font Awesome icons for our navigation. Instead of rendering the <kbd>TabBarIOS.Item</kbd> components as children for our <kbd>TabBarIOS</kbd> component, we will substitute them for <kbd>Icon.TabBarItemIOS</kbd>.</p>
<p><kbd>Icon.TabBarItemIOS</kbd> is a component that behaves in the exact same way that <kbd>TabBarIOS.Item</kbd> does, but with a couple of extra props that are specific to it. We will be using the following props for our implementation:</p>
<ul>
<li><kbd>onPress</kbd>: This is a callback that fires when the tab is tapped on by the user. This should always at least set the selected component to a Boolean in your state.</li>
<li><kbd>selected</kbd>: This is a Boolean that determines whether a specific tab is in the forefront of the application or not.</li>
<li><kbd>title</kbd>: This is a string that shows the text that appears underneath your icon.</li>
</ul>
<ul>
<li><kbd>iconName</kbd>: This is a string that maps to the icon you wish to display.</li>
<li><kbd>iconSize</kbd>: This is a number that dictates the size of the icon.</li>
</ul>
<p>The <kbd>iconColor</kbd> and <kbd>selectedIconColor</kbd> will need to have <kbd>renderAsOriginal</kbd> set to <kbd>true</kbd> so that these child-level settings override the parent <kbd>TabBarIOS</kbd> component's <kbd>tintColor</kbd> and <kbd>unselectedTintColor</kbd> props.</p>
<p>Here's how a sample <kbd>TabBarIOS</kbd> component can look:</p>
<pre>
&lt;TabBarIOS&gt; <br/>  &lt;Icon.TabBarItemIOS <br/>    iconName={ 'home' } <br/>    iconSize={ 20 } <br/>    onPress={ () =&gt; this._setSelectedTab('home') } <br/>    selected={ this.state.selectedTab === 'home' } <br/>    title={ 'home' } <br/>  &gt; <br/>    { this._renderHomeView() } <br/>  &lt;/Icon.TabBarItemIOS&gt; <br/>&lt;/TabBarIOS&gt; 
</pre>
<p>As you can see, <kbd>TabBarIOS</kbd> wraps around the <kbd>Icon.TabBarItemIOS</kbd> child components. Each of these child components handle their own icon type, size, and title. They also wrap around a function that renders their respective views.</p>
<p>Now, it's time for you to give it a try. Let's build a <kbd>TabBarIOS</kbd> component into our app by doing the following things:</p>
<ul>
<li>Separate the app into c<em>urrent month</em> and <em>previous month's</em> expenses using <kbd>TabBarIOS</kbd>. Choose a suitable icon for each one!</li>
<li>Adjust styling as you see fit to adjust any dimensions needed to accommodate <kbd>TabBarIOS</kbd>.</li>
<li>Give each <kbd>PreviousMonthsList</kbd> its own <kbd>NavigatorIOS</kbd> component so that the <kbd>TabBarIOS</kbd> component does not disappear when <kbd>PreviousMonthsList</kbd> navigates to a previous month's list of expenses.</li>
<li>Remove the navigation bar from the root-level <kbd>NavigatorIOS</kbd> component found in <kbd>index.ios.js</kbd> so that the navigation components for <kbd>PreviousMonthsList</kbd> do not render a second navigation bar.</li>
</ul>
<p>Once you have built tabbed navigation for the app, come back and check out the version I wrote:</p>
<pre>
// Expenses/index.ios.js <br/><br/>... <br/>export default class Expenses extends Component { <br/>  render() { <br/>    return ( <br/>      &lt;NavigatorIOS <br/>        ... <br/>        navigationBarHidden={ true } <br/>      /&gt; <br/>    ); <br/>  } <br/>} <br/>... 
</pre>
<p>The only change made to the <kbd>index.ios.js</kbd> root file is the addition of the <kbd>navigationBarHidden</kbd> prop for our root <kbd>NavigatorIOS</kbd> component, set to <kbd>true</kbd> so that the navigation bar does not appear.</p>
<pre>
// Expenses/app/App.js <br/><br/>... <br/>import { <br/>  NavigatorIOS, <br/>  ... <br/>} from 'react-native'; <br/><br/>...
</pre>
<p>In the <kbd>App.js</kbd> component, I am now explicitly setting items in state to default values so that components that are dependent on that prop don't throw an error when the prop is not defined. Additionally, the <kbd>expenses</kbd> key has been modified to be an object--this will be the full object returned by the <kbd>getAsyncStorage</kbd> method in <kbd>StorageMethods</kbd>, not just for the current month:</p>
<pre>
export default class App extends Component { <br/>  constructor (props) { <br/>    super(); <br/><br/>    this.state = { <br/>      budget: '', <br/>      expenses: {}, <br/>      selectedTab: 'currentMonth', <br/>    } <br/>  }
</pre>
<p>The entire <kbd>expenses</kbd> object will be passed into <kbd>PreviousMonthsList</kbd>, allowing it to render all expense data and update whenever a new item is added to a previous month through the <kbd>AddExpenses</kbd> component.</p>
<p>The old <kbd>expenses</kbd> array, which references just the current month, is now explicitly labeled as <kbd>currentMonthExpenses</kbd>.</p>
<p>There is also a new item in the component's state--<kbd>selectedTab</kbd>. This defaults to <kbd>currentMonth</kbd>, which is the leftmost tab that we intend on rendering.</p>
<pre>
  componentWillMount () { <br/>    this.setState({ <br/>      spent: 0, <br/>      currentMonthExpenses: [], <br/>      month: dateMethods.getMonth(), <br/>      year: dateMethods.getYear() <br/>    }); <br/><br/>    ... <br/>  } 
</pre>
<p>The render method for <kbd>App.js</kbd> has been completely overhauled. It now returns a <kbd>TabBarIOS</kbd> component and two <kbd>Icon.TabBarItemIOS</kbd> children components that render a different view each:</p>
<pre>
  render () { <br/>    return ( <br/>      &lt;TabBarIOS&gt; <br/>        &lt;Icon.TabBarItemIOS <br/>          iconName={ 'usd' } <br/>          iconSize={ 20 } <br/>          onPress={ () =&gt; this._setSelectedTab('currentMonth') } <br/>          title={ 'Current Month' } <br/>          selected={ this.state.selectedTab === 'currentMonth' } <br/>        &gt; <br/>          { this._renderCurrentMonthExpenses(this.state.<br/>          currentMonthExpenses) } <br/>        &lt;/Icon.TabBarItemIOS&gt; <br/>        &lt;Icon.TabBarItemIOS <br/>          iconName={ 'history' } <br/>          iconSize={ 20 } <br/>          onPress={ () =&gt; this._setSelectedTab('previousMonths') } <br/>          title={ 'Previous Months' } <br/>          selected={ this.state.selectedTab === 'previousMonths' } <br/>        &gt; <br/>          { this._renderPreviousMonthsList(this.state.expenses) } <br/>        &lt;/Icon.TabBarItemIOS&gt; <br/>      &lt;/TabBarIOS&gt; <br/>    ) <br/>  } 
</pre>
<p>The <kbd>_renderCurrentMonthExpenses</kbd> method contains the old <kbd>render</kbd> method for this component:</p>
<pre>
  _renderCurrentMonthExpenses () { <br/>    return ( <br/>      &lt;View style={ styles.appContainer }&gt; <br/>        &lt;CurrentMonthExpenses <br/>          budget={ this.state.budget } <br/>          expenses={ this.state.currentMonthExpenses } <br/>          month={ this.state.month } <br/>          spent={ this.state.spent } <br/>          year={ this.state.year } <br/>        /&gt; <br/>        &lt;AddExpenses <br/>          month={ this.state.month } <br/>          updateExpenses={ () =&gt; this._updateExpenses() } <br/>          year={ this.state.year } <br/>        /&gt; <br/>      &lt;/View&gt; <br/>    ) <br/>  } 
</pre>
<p>The <kbd>_renderPreviousMonthsList</kbd> method returns a <kbd>NavigatorIOS</kbd> component whose initial route is <kbd>PreviousMonthsList</kbd>. The <kbd>expenses</kbd> key in <kbd>App.js'</kbd> state is passed in to <kbd>PreviousMonthsList</kbd> via <kbd>passProps</kbd>:</p>
<pre>
  ...  <br/>  _renderPreviousMonthsList () { <br/>    return ( <br/>      &lt;NavigatorIOS <br/>        initialRoute={{ <br/>          component: PreviousMonthsList, <br/>          title: 'Previous Months', <br/>          passProps: { <br/>            expenses: this.state.expenses <br/>          } <br/>        }} <br/>        style={ styles.previousMonthsContainer } <br/>      /&gt; <br/>    ) <br/>  } 
</pre>
<p>The <kbd>_setSelectedTab</kbd> function changes the <kbd>selectedTab</kbd> property in the <kbd>App.js'</kbd> component state to the argument passed to it. This is the callback fired by the <kbd>onPress</kbd> props of the <kbd>Icon.TabBarItemIOS</kbd>:</p>
<pre>
  ...  <br/>  _setSelectedTab (selectedTab) { <br/>    this.setState({ <br/>      selectedTab <br/>    }); <br/>  } 
</pre>
<p>The last change is that <kbd>_updateCurrentMonthExpenses</kbd> now calls <kbd>getAsyncStorge</kbd> from <kbd>storageMethods.js</kbd> instead of <kbd>getMonthObject</kbd> and has been renamed as <kbd>_updateExpenses</kbd> to reflect its new functionality:</p>
<pre>
  ... <br/>  async _updateBudget () { <br/>      ... <br/>      this._updateExpenses(); <br/>      ... <br/>    } <br/>    ... <br/>  } <br/><br/>  async _updateExpenses () { <br/>    let response = await storageMethods.getAsyncStorage(); <br/><br/>    if (response) { <br/>      let currentMonth = response[this.state.year][this.state.month]; <br/><br/>      this.setState({ <br/>        budget: currentMonth.budget, <br/>        currentMonthExpenses: currentMonth.expenses, <br/>        expenses: response, <br/>        spent: currentMonth.spent <br/>      }); <br/>    } <br/>  } <br/>} 
</pre>
<p>The <kbd>previousMonthsContainer</kbd> style is applied to the <kbd>NavigatorIOS</kbd> instance that renders <kbd>PreviousMonthsList</kbd>. It does not contain a top margin equal to the navigation bar's height since this will cause the navigation bar itself to have a top margin equal to its own height:</p>
<pre>
// Expenses/app/styles.js <br/><br/>... <br/>const styles = StyleSheet.create({ <br/>  ... <br/>  previousMonthsContainer: { <br/>    flex: 1, <br/>    marginBottom: 48 <br/>  } <br/>}); <br/><br/>export default styles; 
</pre>
<p>Minor changes to <kbd>PreviousMonthsList</kbd> are that I'm now checking for the <kbd>expenses</kbd> object to be passed to it and the <kbd>cloneWithRowsAndSections</kbd> call in the <kbd>render</kbd> method is now updated to reflect this.</p>
<p>Additionally, the <kbd>componentWillMount</kbd> life cycle has been entirely removed since we are now getting all our data as a prop.</p>
<pre>
// Expenses/app/components/PreviousMonthsList/index.js <br/><br/>import React, { Component, PropTypes } from 'react'; <br/>... <br/>export default class PreviousMonthsList extends Component { <br/>  static propTypes = { <br/>    expenses: PropTypes.object.isRequired <br/>  } <br/>  ...  <br/>  render () { <br/>    const dataSource = this.state.ds.cloneWithRowsAndSections<br/>    (this.props.expenses); <br/>    ... <br/>  } <br/>  ...  <br/>} 
</pre>
<p>The <kbd>marginTop</kbd> property for <kbd>previousMonthsListContainer</kbd> in this component has been set to the navigation bar height:</p>
<pre>
// Expenses/app/components/PreviousMonthsList/styles.js <br/><br/>import { Navigator, StyleSheet } from 'react-native'; <br/><br/>const styles = StyleSheet.create({ <br/>  previousMonthsListContainer: { <br/>    ...  <br/>    marginTop: Navigator.NavigationBar.Styles.General.TotalNavHeight, <br/>  }, <br/>  ... <br/>}); <br/><br/>export default styles; 
</pre>
<p>Finally, the <kbd>AddExpenses</kbd> component has been tweaked to reflect changing the <kbd>_updateCurrentExpenses</kbd> function name to <kbd>_updateExpenses</kbd>:</p>
<pre>
// Expenses/app/AddExpenses/index.js <br/><br/>... <br/>export default class AddExpenses extends Component { <br/>  static propTypes = { <br/>    ... <br/>    updateExpenses: PropTypes.func.isRequired, <br/>    ... <br/>  } <br/>  ... <br/>  _toggleModal (boolean) { <br/>    ... <br/>    this.props.updateExpenses(); <br/>  } <br/>} 
</pre>
<p>Here is how your app should look with <kbd>TabBarIOS</kbd> implemented:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1448 image-border" height="366" src="assets/image_04_007-1.png" width="199"/></div>
<p>There is one last thing we should do with the app, and it is to let users delete expenses.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Deleting expenses</h1>
            </header>

            <article>
                
<p>For users to delete expenses from any month, we need to do the following things:</p>
<ul>
<li>Add a method to <kbd>storageMethods</kbd> to update an <kbd>expenses</kbd> object. It should accept the month, year, and array of expenses. Then, it should override the array of expenses for that specific month and year combination in <kbd>AsyncStorage</kbd> with this new array, and recalculate the amount spent.</li>
<li>Wrap a <kbd>TouchabbleHighlight</kbd> component around each row that, when long pressed, opens an alert that asks the user whether they wish to delete the item.</li>
<li>If the user confirms that they would like to delete the item, then we should delete it. A new array of expenses for the current month should be created without the deleted item, and it should be saved using the <kbd>storageMethods</kbd> function we made.</li>
<li>When an expense is deleted, we should update the current view to reflect the item being deleted and the updated spent amount.</li>
<li>If the user cancels, the alert should close and no changes should be made.</li>
</ul>
<p>Take some time to build this feature; when you're finished, check out the code I wrote for this part.</p>
<p>First, I modified the <kbd>StorageMethods</kbd> file:</p>
<pre>
// Expenses/app/utils/StorageMethods.js <br/><br/>... <br/>export const saveItemToBudget = async (month, year, expenseObject) =&gt; { <br/>  let response = await getAsyncStorage(); <br/><br/>  let newExpensesArray = [ <br/>    ...response[year][month].expenses, <br/>    expenseObject <br/>  ]; <br/><br/>  return updateMonthExpensesArray(month, year, newExpensesArray); <br/>} <br/><br/>export const updateMonthExpensesArray = async (month, year, array) =&gt; { <br/>  let response = await getAsyncStorage(); <br/><br/>  let newTotal = getTotalSpentForMonth(array); <br/><br/>  response[year][month].expenses = array; <br/>  response[year][month].spent = newTotal; <br/><br/>  await setAsyncStorage(response); <br/>  return true; <br/>} 
</pre>
<p>The first thing I did was write the <kbd>updateMonthExpensesArray</kbd> method. As I was writing it, I noticed that much of the code was similar to what <kbd>saveItemToBudget</kbd> was executing, so I refactored <kbd>saveItemToBudget</kbd> to call the new <kbd>updateMonthExpensesArray</kbd> method. This allows me to reuse some code in my file instead of writing it twice.</p>
<p>When the <kbd>CurrentMonthExpenses</kbd> component deletes an item, <kbd>App.js</kbd> <kbd>_updateExpenses</kbd> method should be executed so that <kbd>AsyncStorage</kbd> is updated with a new array for the month and year that does not contain the deleted expense:</p>
<pre>
// Expenses/app/App.js <br/><br/>... <br/>export default class App extends Component { <br/>  ... <br/>  _renderCurrentMonthExpenses () { <br/>    return ( <br/>      &lt;View style={ styles.appContainer }&gt; <br/>        &lt;CurrentMonthExpenses <br/>          ... <br/>          updateExpenses={ () =&gt; this._updateExpenses() } <br/>        /&gt; <br/>        ... <br/>      &lt;/View&gt; <br/>    ) <br/>  } 
</pre>
<p>The <kbd>_updateExpenses</kbd> method is also passed into the <kbd>PreviousMonthsList</kbd> component so that it can propagate it down to its own rendering of <kbd>CurrentMonthExpenses</kbd> for the previous months:</p>
<pre>
  _renderPreviousMonthsList () { <br/>    return ( <br/>      &lt;NavigatorIOS <br/>        initialRoute={{ <br/>          ... <br/>          passProps: { <br/>            ... <br/>            updateExpenses: () =&gt; this._updateExpenses() <br/>          } <br/>        }} <br/>      /&gt; <br/>    ) <br/>  } <br/>  ... <br/>} 
</pre>
<p>The <kbd>PreviousMonthsList</kbd> gets a minor tweak to support the addition of the <kbd>updateExpenses</kbd> function:</p>
<pre>
// Expenses/app/components/PreviousMonthsList/index.js <br/><br/>... <br/>export default class PreviousMonthsList extends Component { <br/>  static propTypes = { <br/>    ... <br/>    updateExpenses: PropTypes.func.isRequired <br/>  } <br/>  ... <br/>  _renderSelectedMonth (rowData, sectionID, rowID) { <br/>    this.props.navigator.push({ <br/>      ... <br/>      passProps: { <br/>        ... <br/>        updateExpenses: () =&gt; this.props.updateExpenses(), <br/>      } <br/>    }); <br/>  } <br/>} 
</pre>
<p>The <kbd>render</kbd> method has been changed to set the <kbd>dataSource</kbd> constant of <kbd>ListView</kbd> to accept the expenses value of the <kbd>CurrentMonthExpenses</kbd> state in case it is present--this will be used to visually update the component to exclude a deleted item once a deletion occurs.</p>
<p>This is necessary because <kbd>PreviousMonthsList</kbd> is the initial route of its own <kbd>NavigatorIOS</kbd> instance and therefore does not receive updated props from <kbd>App.js</kbd>:</p>
<pre>
// Expenses/app/components/CurrentMonthExpenses/index.js <br/><br/>... <br/>import { <br/>  Alert, <br/>  ... <br/>} from 'react-native'; <br/>... <br/>export default class CurrentMonthExpenses extends Component { <br/>  static propTypes = { <br/>    ... <br/>    updateExpenses: PropTypes.func.isRequired, <br/>  } <br/>  ... <br/>  render () { <br/>    const dataSource = this.state.ds.cloneWithRows<br/>    (this.state.expenses || this.props.expenses || []); <br/>    ... <br/>  } 
</pre>
<p>The <kbd>_cancelAlert</kbd> method closes the <kbd>Alert</kbd> dialogue that appears:</p>
<pre>
  ... <br/><br/>  _cancelAlert () { <br/>    return false; <br/>  } 
</pre>
<p>The following conditional blocks deal with the possibility that a user may want to delete more than one item from a list:</p>
<pre>
  async _deleteItem (rowID) { <br/>    let newExpensesArray; <br/><br/>    if (this.state.expenses) { <br/>      newExpensesArray = [...this.state.expenses]; <br/>    } <br/><br/>    if (!this.state.expenses) { <br/>      newExpensesArray = [...this.props.expenses]; <br/>    } 
</pre>
<p>The <kbd>_deleteItem</kbd> method takes in the ID of the row being deleted, clones the expenses array, uses the <kbd>splice</kbd> method of the <kbd>Array</kbd> prototype to remove that specific index from it, and then removes it from <kbd>AsyncStorage</kbd> with the <kbd>updateMonthExpensesArray</kbd> method I created in the <kbd>StorageMethods</kbd> file.</p>
<p>Then, I set an <kbd>expenses</kbd> value in the local state to equal the new expenses array and call the <kbd>updateExpenses</kbd> method from <kbd>App.js</kbd> to update the data in the app:</p>
<pre>
    newExpensesArray.splice(rowID, 1); <br/><br/>    await storageMethods.updateMonthExpensesArray<br/>    (this.props.month, this.props.year, newExpensesArray); <br/><br/>    this.setState({ <br/>      expenses: newExpensesArray <br/>    }); <br/><br/>    this.props.updateExpenses(); <br/>  }
</pre>
<p>Each <kbd>ExpenseRow</kbd> component will be passed in this <kbd>_onLongPress</kbd> method, which takes in its <kbd>rowID</kbd> and creates an alert prompt for the user. Based on the selected option, it either cancels the alert or deletes the row selected:</p>
<pre>
  ... <br/>  _onLongPress (rowID) { <br/>    const alertOptions = [ <br/>      {text: 'Cancel', onPress: () =&gt; this._cancelAlert() }, <br/>      {text: 'Delete', style: 'destructive', onPress: () =&gt; <br/>      this._deleteItem(rowID)} <br/>    ]; <br/><br/>    Alert.alert('Delete Item', 'Do you wish to delete<br/>    this item?', alertOptions) <br/>  } 
</pre>
<p>The <kbd>_renderRowData</kbd> method has been changed to pass in the <kbd>onLongPress</kbd> prop to <kbd>ExpenseRow</kbd>:</p>
<pre>
  _renderRowData (rowData, rowID) { <br/>    if (rowData) { <br/>      return ( <br/>        &lt;ExpenseRow <br/>          ... <br/>          onLongPress={ () =&gt; this._onLongPress(rowID) } <br/>        /&gt; <br/>      ) <br/>    } <br/>  } <br/>  ... <br/>}; 
</pre>
<p>The <kbd>TouchableHighlight</kbd> component of <kbd>ExpenseRow</kbd> has been updated to add an <kbd>onLongPress</kbd> callback that executes the <kbd>onLongPress</kbd> method passed into it as a prop from <kbd>CurrentMonthExpenses</kbd>. This is how the alert is triggered, giving the user the option to delete an added expense:</p>
<pre>
// Expenses/app/components/ExpenseRow/index.js <br/><br/>... <br/>export default (props) =&gt; { <br/>  return ( <br/>    &lt;TouchableHighlight <br/>      onLongPress={ () =&gt; props.onLongPress() } <br/>      ... <br/>    &gt; <br/>    ... <br/>    &lt;/TouchableHighlight&gt; <br/>  ) <br/>} 
</pre>
<p>This concludes our work on the iOS version of this app! Since this was a large app to build, I don't wish to drag you through the Android modifications in this chapter. Instead, the modifications I will make to this app to build it on an Android device can be found at the end of <a href="c9cb084b-5c75-4683-94c3-9b2124e8ecb0.xhtml">Chapter 9</a>, <em>Additional React Native Components</em>.</p>
<p>In the next chapter, we will begin working on an entirely new project.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>In this chapter, we finished building our expense tracking app by utilizing the vector icon library we installed earlier to visually display the user's expenses. We also built a second view to look at the previous months' expenses and wrote a function to mock the data needed to visually verify that our app worked as intended. Then, we separated these two views using tabbed navigation and allowed users to delete expenses from the app.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>