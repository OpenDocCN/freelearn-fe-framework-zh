- en: Chapter 4. Getting Started with Angular Components and Directives
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：Angular组件和指令入门
- en: By this point, we're already familiar with the core building blocks that Angular
    provides for the development of single-page applications and the relations between
    them. However, we've touched only the surface by introducing the general idea
    behind Angular's concepts and the basic syntax used for their definition. In this
    chapter, we'll take a deep dive into Angular's components and directives.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经熟悉了Angular为开发单页应用程序提供的核心构建块及其之间的关系。然而，我们只是触及了表面，通过介绍Angular概念背后的基本思想和定义它们所使用的语法的基本语法。在本章中，我们将深入探讨Angular的组件和指令。
- en: 'In the following sections, we will cover these topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将涵盖以下主题：
- en: Enforced separation of concerns of the building blocks that Angular provides
    for developing applications.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制分离Angular为开发应用程序提供的构建块的关注点。
- en: The appropriate use of directives or components when interacting with the DOM.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与DOM交互时，适当使用指令或组件。
- en: Built-in directives and developing custom ones.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置指令和自定义指令的开发。
- en: An in-depth look at components and their templates.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解组件及其模板。
- en: Content projection.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容投影。
- en: View children versus content children.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图子代与内容子代。
- en: The component's life cycle.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的生命周期。
- en: Using template references.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板引用。
- en: Configuring Angular's change detection.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Angular的变更检测。
- en: The "Hello world!" application in Angular
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular中的“Hello world!”应用程序
- en: 'Now, let''s build our first "Hello world!" application in Angular. In order
    to get everything up and running as easy and quickly as possible, for our first
    application, we will use the ECMAScript 5 syntax with the transpiled bundle of
    Angular. First, create the `index.html` file with the following content:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在Angular中构建我们的第一个“Hello world!”应用程序。为了尽可能轻松和快速地启动一切，对于我们的第一个应用程序，我们将使用Angular的转译包中的ECMAScript
    5语法。首先，创建一个包含以下内容的`index.html`文件：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the examples in this book are built with Angular 2.2.0\. In case you're
    using a newer version of the framework there might be slight differences. For
    further information take a look at the changelog at [https://github.com/angular/angular/blob/master/CHANGELOG.md](https://github.com/angular/angular/blob/master/CHANGELOG.md).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本书中的示例是用Angular 2.2.0构建的。如果您使用的是框架的新版本，可能会有细微的差异。有关更多信息，请查看[https://github.com/angular/angular/blob/master/CHANGELOG.md](https://github.com/angular/angular/blob/master/CHANGELOG.md)的变更日志。
- en: 'The preceding HTML file defines the basic structure of our page. Just before
    closing the `body` tag, we have references to a few script files: polyfills (zone.js
    and reflect-metadata) required by the framework, RxJS, the ES5 bundles of different
    packages of Angular, and the file that contains the application we''re going to
    build.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的HTML文件定义了我们页面的基本结构。在关闭`body`标签之前，我们有对几个脚本文件的引用：框架所需的polyfills（zone.js和reflect-metadata）、RxJS、Angular不同包的ES5包，以及包含我们将要构建的应用程序的文件。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: RxJS is used by Angular's core in order to allow us to empower the reactive
    programming paradigm in our applications. In the following content, we will take
    only a shallow look at how we can take advantage of observables. For further information,
    you can visit the RxJS GitHub repository at [https://github.com/ReactiveX/rxjs](https://github.com/ReactiveX/rxjs)
    .
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS 被Angular的核心使用，以便我们能够在我们的应用程序中启用响应式编程范式。在以下内容中，我们将仅简要探讨我们如何利用观察者。有关更多信息，您可以访问RxJS的GitHub仓库[https://github.com/ReactiveX/rxjs](https://github.com/ReactiveX/rxjs)。
- en: 'In the same directory where your `index.html` resides, create a file called
    `app.js` and enter the following content inside it:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`index.html`文件所在的同一目录下，创建一个名为`app.js`的文件，并在其中输入以下内容：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding snippet, we defined a component called `App` with an `my-app`
    selector. The component has the following template:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了一个名为`App`的组件，具有`my-app`选择器。该组件具有以下模板：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This syntax should already be familiar to you from AngularJS. When compiled
    in the context of the given component, the preceding snippet will interpolate
    the template with the result of the expression inside the curly brackets. In our
    case, the expression is simply the `target` variable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法应该已经从AngularJS中熟悉了。在给定组件的上下文中编译时，前面的代码片段将使用花括号内表达式的结果来插值模板。在我们的例子中，这个表达式仅仅是`target`变量。
- en: To `Class`, we pass an object literal, which has a single method called `constructor`.
    This **DSL** (**domain-specific language**) provides an alternative way to define
    classes in ECMAScript 5\. In the body of the `constructor` function, we add a
    property called `target` with a value of the `"world"` string. Right after that,
    we define our `AppModule` class. Note that every component on our application
    must be associated with a module. Inside the module, as explained in [Chapter
    2](ch02.html "Chapter 2. The Building Blocks of an Angular Application"), *The
    Building Blocks of an Angular Application*, we define the declarations, imports,
    and the bootstrap component.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`Class`传递一个对象字面量，它有一个名为`constructor`的方法。这个**DSL**（**领域特定语言**）为在ECMAScript
    5中定义类提供了一种替代方法。在`constructor`函数的主体中，我们添加一个名为`target`的属性，其值为字符串`"world"`。紧接着，我们定义我们的`AppModule`类。请注意，我们应用程序中的每个组件都必须与一个模块相关联。在模块内部，如[第2章](ch02.html
    "第2章。Angular应用程序的构建块")《Angular应用程序的构建块》中所述，我们定义了声明、导入和引导组件。
- en: At the last line of the snippet, we invoke the `bootstrapModule` method of the
    object returned by the invocation of `ng.platformBrowserDynamic()`. As argument
    of `bootstrapModule`, we pass the `AppModule` we just defined.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段的最后一行，我们调用`ng.platformBrowserDynamic()`调用返回的对象的`bootstrapModule`方法。作为`bootstrapModule`的参数，我们传递我们刚刚定义的`AppModule`。
- en: Note that `bootstrapModule` is under the `ng.platformBrowserDynamic` namespace.
    This is due to the fact that the framework is built with different platforms in
    mind, such as the browser, NativeScript, and so on. By placing the bootstrap methods
    used by the different platforms under a separate namespace, Angular can implement
    different logic to initialize the application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`bootstrapModule`位于`ng.platformBrowserDynamic`命名空间下。这是因为框架是考虑到不同的平台而构建的，例如浏览器、NativeScript等等。通过将不同平台使用的引导方法放在单独的命名空间下，Angular可以实现不同的逻辑来初始化应用程序。
- en: 'Now, if you open `index.html` with your browser, you should see some errors,
    as shown in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你用浏览器打开`index.html`，你应该会看到一些错误，如下面的截图所示：
- en: '![The "Hello world!" application in Angular](img/B06166_04_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Angular中的"Hello world!"应用程序](img/B06166_04_01.jpg)'
- en: Figure 1
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图1
- en: 'This happened because we missed something quite important. We didn''t use the
    root component anywhere inside `index.html`. In order to finish the application,
    add the following HTML element after the open tag of the body element:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们遗漏了一些相当重要的东西。我们在`index.html`内部任何地方都没有使用根组件。为了完成应用程序，在`<body>`元素的打开标签之后添加以下HTML元素：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, you can refresh your browser to see the following result:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以刷新你的浏览器来查看以下结果：
- en: '![The "Hello world!" application in Angular](img/2.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![Angular中的"Hello world!"应用程序](img/2.jpg)'
- en: Figure 2
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图2
- en: Using TypeScript
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TypeScript
- en: Although we already have an Angular application running, we can do much better!
    We didn't use any package manager or module loader. We spent all of [Chapter 3](ch03.html
    "Chapter 3. TypeScript Crash Course"), *TypeScript Crash Course*, talking about
    TypeScript; however, we didn't write a single line of it in the preceding application.
    Although it is not required that you use TypeScript with Angular, it's more convenient
    to take advantage of all the bonuses that static typing provides. By using TypeScript,
    we can also use the Ahead-of-Time compilation in Angular.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经有了一个运行的Angular应用程序，但我们可以做得更好！我们没有使用任何包管理器或模块加载器。我们在[第3章](ch03.html "第3章。TypeScript快速入门")《TypeScript快速入门》中花了很多时间讨论TypeScript；然而，在前面的应用程序中我们没有写一行TypeScript。虽然使用TypeScript与Angular不是必需的，但利用静态类型提供的所有好处会更方便。通过使用TypeScript，我们还可以在Angular中使用提前编译。
- en: Setting up our environment
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的环境
- en: The core team of Angular developed a brand new CLI tool for Angular, which allows
    us to bootstrap our applications with a few commands. Although we will introduce
    it in the final chapter, by then, in order to boost our learning experience, we
    will use the code located at [https://github.com/mgechev/getting-started-with-angular](https://github.com/mgechev/getting-started-with-angular).
    This repository includes all the examples in this book, in one big application.
    It has all the required dependencies declared in `package.json`, the definition
    of basic gulp tasks, such as the development server, the transpilation of your
    TypeScript code to ECMAScript 5, live-reload, and so on.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的核心团队为 Angular 开发了一个全新的 CLI 工具，它允许我们通过几个命令来启动我们的应用程序。虽然我们将在最后一章介绍它，但在此之前，为了增强我们的学习体验，我们将使用位于
    [https://github.com/mgechev/getting-started-with-angular](https://github.com/mgechev/getting-started-with-angular)
    的代码。这个仓库包含了本书中的所有示例，在一个大应用中。它声明了 `package.json` 中所有必需的依赖项，定义了基本 gulp 任务，如开发服务器、将您的
    TypeScript 代码转换为 ECMAScript 5、实时重载等。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The project that contains all the examples for this book is based on angular-seed
    ([https://github.com/mgechev/angular-seed](https://github.com/mgechev/angular-seed)),
    which allows us to quickly bootstrap an Angular application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 包含本书所有示例的项目基于 angular-seed ([https://github.com/mgechev/angular-seed](https://github.com/mgechev/angular-seed))，它允许我们快速启动
    Angular 应用程序。
- en: In order to set up the `getting-started-with-angular` project, you'll need Git,
    Node.js v6.x.x, and npm up and running on your computer. If you have a different
    version of the Node.js installed, I recommend that you take a look at nvm (the
    Node.js version manager, which is available at [https://github.com/creationix/nvm](https://github.com/creationix/nvm))
    or n ( [https://www.npmjs.com/package/n](https://www.npmjs.com/package/n) ). Using
    these tools, you'll be able to have multiple versions of Node.js on your machine
    and switch between them with a single command via the command line.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置 `getting-started-with-angular` 项目，您需要在您的计算机上安装 Git、Node.js v6.x.x 和运行 npm。如果您安装了不同版本的
    Node.js，我建议您查看 nvm（Node.js 版本管理器，可在 [https://github.com/creationix/nvm](https://github.com/creationix/nvm)
    获取）或 n（[https://www.npmjs.com/package/n](https://www.npmjs.com/package/n)）。使用这些工具，您可以在您的机器上拥有多个
    Node.js 版本，并通过命令行使用单个命令在它们之间切换。
- en: Installing the sample project repository
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装示例项目仓库
- en: 'Let''s start by setting up the `getting-started-with-angular` project. Open
    your terminal and enter the following commands:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置 `getting-started-with-angular` 项目开始。打开您的终端并输入以下命令：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first line will clone the `getting-started-with-angular` project into a
    directory called `getting-started-with-angular`; after that we enter that directory.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将 `getting-started-with-angular` 项目克隆到名为 `getting-started-with-angular` 的目录中；之后我们进入该目录。
- en: The last step before being able to run the seed project is to install all the
    required dependencies using npm. This step may take a while depending on your
    Internet connection, so be patient and do not interrupt it. If you encounter any
    problems, do not hesitate to raise the issues at [https://github.com/mgechev/getting-started-with-angular/issues](https://github.com/mgechev/getting-started-with-angular/issues).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够运行种子项目之前，需要使用 npm 安装所有必需的依赖项。这一步骤可能需要一段时间，具体取决于您的网络连接，所以请耐心等待，不要中断它。如果您遇到任何问题，请不要犹豫，在
    [https://github.com/mgechev/getting-started-with-angular/issues](https://github.com/mgechev/getting-started-with-angular/issues)
    上提出问题。
- en: 'The last step left is to start the development server:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是启动开发服务器：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the process of the transpilation is completed, your browser will automatically
    open with `http://localhost:5555/dist/dev`. You should now see a view similar
    to what is shown in the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当转换过程完成后，您的浏览器将自动打开到 `http://localhost:5555/dist/dev`。现在您应该看到一个类似于以下截图的视图：
- en: '![Installing the sample project repository](img/3.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![安装示例项目仓库](img/3.jpg)'
- en: Figure 3
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3
- en: Playing with Angular and TypeScript
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Angular 和 TypeScript 中玩耍
- en: 'Now, let''s play around with the files we already have. Navigate to the `app/ch4/ts/hello-world`
    directory inside `getting-started-with-angular`. Then, open `app.ts` and replace
    its content with the following snippet:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来玩一玩我们已有的文件。导航到 `getting-started-with-angular` 中的 `app/ch4/ts/hello-world`
    目录。然后，打开 `app.ts` 并将其内容替换为以下片段：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s take a look at the code line by line:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看代码：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Initially, we import the `@Component` and `@NgModule` decorators from the `@angular/core`
    module, `BrowserModule` from `@angular/platform-browser` and the `platformBrowserDynamic` object
    from `@angular/platform-browser-dynamic`. Later, we use `@Component` to decorate
    the `App` class. To the `@Component` decorator, we pass the same object literal
    that we used in the ECMAScript 5 version of the application, but this time we
    reference to an external template.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们从 `@angular/core` 模块导入 `@Component` 和 `@NgModule` 装饰器，从 `@angular/platform-browser`
    模块导入 `BrowserModule`，以及从 `@angular/platform-browser-dynamic` 模块导入 `platformBrowserDynamic`
    对象。稍后，我们使用 `@Component` 装饰 `App` 类。向 `@Component` 装饰器传递与 ECMAScript 5 版本的应用程序中使用的相同对象字面量，但这次我们引用外部模板。
- en: As a next step, we define the view of the component. However, note that in this
    case, we use `templateUrl` instead of simply inlining the component's template.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，我们定义组件的视图。然而，请注意，在这种情况下，我们使用 `templateUrl` 而不是简单地内联组件的模板。
- en: Open `app.html` and replace the file's content with `<h1>Hello {{target}}!</h1>`.
    The content of `app.html` should be the same as the inlined template we have used
    previously. Since we can use a template by both inlining it (with `template`)
    and setting its URL (`templateUrl`), in some sense, the component's API is similar
    to the AngularJS directives API.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `app.html` 并将文件内容替换为 `<h1>Hello {{target}}!</h1>`。`app.html` 的内容应与之前使用的内联模板相同。由于我们可以通过内联（使用
    `template`）和设置其 URL（`templateUrl`）两种方式使用模板，从某种意义上说，组件的 API 与 AngularJS 指令 API
    类似。
- en: In the last line of the snippet, we bootstrap the application by providing the
    root module.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段的最后行，我们通过提供根模块来引导应用程序。
- en: 'Now, let''s take a look at `index.html` in order to get a sense of what goes
    on when we start the application:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下 `index.html` 以了解启动应用程序时发生了什么：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that inside the body of the page, we use the `my-app` element with content
    a text node with value `"Loading..."`. The `"Loading..."` label will be visible
    until the application gets bootstrapped and the main component gets rendered.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在页面主体内部，我们使用 `my-app` 元素，其内容是一个具有值 `"Loading..."` 的文本节点。这个 `"Loading..."`
    标签将在应用程序启动并渲染主组件之前可见。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are template placeholders `<%= INIT %>`  and `<-- inject:js...` that inject
    content that is specific to individual demos. They are not Angular specific, but
    instead aim to prevent code duplications in the code samples attached to the book
    because of the shared structure between them. In order to see how this specific
    HTML file has been transformed, open `/dist/dev/ch4/ts/hello-world/index.html`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 存在模板占位符 `<%= INIT %>` 和 `<-- inject:js...`，它们注入针对单个演示特定内容。它们不是 Angular 特有的，而是旨在防止由于它们之间的共享结构而在书籍附带的代码示例中重复代码。为了查看这个特定的
    HTML 文件是如何被转换的，请打开 `/dist/dev/ch4/ts/hello-world/index.html`。
- en: Using Angular directives
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Angular 指令
- en: We have already built our simple "Hello world!" app. Now, let's start building
    something that is closer to a real-life application. By the end of this section,
    we'll have a simple application that lists a number of items we need to do and
    greets us at the header of the page.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了简单的 "Hello world!" 应用程序。现在，让我们开始构建更接近真实应用程序的东西。在本节结束时，我们将拥有一个简单的应用程序，该应用程序列出了我们需要完成的多个项目，并在页面的页眉中向我们打招呼。
- en: 'Let''s start by developing our `app` component. The two modifications from
    the preceding example that we need to make are renaming the `target` property
    to `name` and adding a list of `todos` to the component''s controller definition:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们开发我们的 `app` 组件。与前一个示例相比，我们需要进行的两个修改是将 `target` 属性重命名为 `name`，并将 `todos`
    列表添加到组件的控制器定义中：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The only thing left is to update the template in order to consume the provided
    data. We're already familiar with the `ng-repeat` directive from AngularJS. It
    allows us to loop over a list of items using a microsyntax, which is later interpreted
    by AngularJS. However, the directive doesn't carry enough semantics, so it is
    hard to build tools that perform static code analysis and help us improve our
    development experience. Since the `ng-repeat` directive is quite useful, Angular
    kept the idea and improved it further in order to allow more sophisticated tooling
    by introducing further semantics on top of it. It allows IDEs and text editors
    to perform better static code analysis. Such support will prevent us from making
    typos in the code we write and allow us to have a smoother development experience.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情就是更新模板以消费提供的数据。我们已经熟悉了 AngularJS 中的 `ng-repeat` 指令。它允许我们使用微语法遍历一个项目列表，该语法随后由
    AngularJS 解释。然而，该指令的语义不够丰富，因此很难构建执行静态代码分析并帮助我们改进开发体验的工具。由于 `ng-repeat` 指令非常有用，Angular
    保留了这一想法，并通过在其之上引入更多的语义来进一步改进它，以允许更复杂的工具。它允许 IDE 和文本编辑器执行更好的静态代码分析。这种支持将防止我们在编写的代码中犯拼写错误，并允许我们拥有更流畅的开发体验。
- en: 'In `app.html`, add the following content:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app.html` 中添加以下内容：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `template` element is a place where we can hold markup and make sure that
    it won't be rendered by the browser. This is quite useful if we need to embed
    the templates of our application directly into the markup of the page and let
    the template engine we're using to process them at some point. In the current
    example, this means that if the Angular's DOM compiler doesn't process the DOM
    tree, we will not see the list item inside the `ul` element.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`template` 元素是我们可以存放标记并确保它不会被浏览器渲染的地方。如果我们需要将应用程序的模板直接嵌入到页面的标记中，并让我们在某个时刻使用模板引擎处理它们，这非常有用。在当前示例中，这意味着如果
    Angular 的 DOM 编译器不处理 DOM 树，我们就不会在 `ul` 元素内看到列表项。'
- en: 'Now, after you refresh your browser, you should see the following result:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你刷新浏览器后，你应该看到以下结果：
- en: '![Using Angular directives](img/4-2.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Angular 指令](img/4-2.jpg)'
- en: Figure 4
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4
- en: So far, so good! The only new things left in the preceding snippets are the
    attributes of the `template` element that we're not familiar with, such as `ngFor`,
    `let-todo`, and `[ngForOf]`. Let's take a look at them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利！前面片段中剩下的新东西只是我们不熟悉的 `template` 元素的属性，例如 `ngFor`、`let-todo` 和 `[ngForOf]`。让我们来看看它们。
- en: The ngFor directive
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ngFor 指令
- en: The `ngFor` directive is a directive that allows us to loop over a collection
    of items and does exactly what `ng-repeat` does in AngularJS, but it brings some
    extra semantics. Note that the `ngForOf` attribute is surrounded by brackets.
    At first, these brackets may seem like invalid HTML. However, according to the
    HTML specification, their use is permitted in attribute names. The only thing
    the W3C validator will complain about is the fact that the `template` element
    doesn't own such attributes; however, browsers won't have problems processing
    the markup.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngFor` 指令是一个允许我们遍历项目集合的指令，它确实做了 AngularJS 中 `ng-repeat` 的工作，但它带来了一些额外的语义。请注意，`ngForOf`
    属性被括号包围。起初，这些括号可能看起来像是无效的 HTML。然而，根据 HTML 规范，它们在属性名称中的使用是允许的。W3C 验证器唯一会抱怨的是 `template`
    元素没有这样的属性；然而，浏览器在处理标记时不会有问题。'
- en: The semantics behind these brackets is that the value of the attribute surrounded
    by them is an expression, which needs to be evaluated.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些括号背后的语义是，它们包围的属性值是一个需要评估的表达式。
- en: Improved semantics of the directives syntax
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令语法的改进语义
- en: 'In [Chapter 1](ch01.html "Chapter 1. Get Going with Angular"), *Get Going with
    Angular*, we mentioned the opportunity for improved tooling in Angular. A big
    issue in AngularJS is the different ways in which we can use directives. This
    requires an understanding of the attribute values, which can be literals, expressions,
    callbacks, or a microsyntax. Starting with Angular 2, this problem is eliminated
    by introducing a few simple conventions that are built into the framework:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](ch01.html "第 1 章。开始使用 Angular") 中，*开始使用 Angular*，我们提到了在 Angular 中改进工具的机会。AngularJS
    中的一个重大问题是我们可以使用指令的不同方式。这需要理解属性值，这些值可以是字面量、表达式、回调或微语法。从 Angular 2 开始，通过在框架中引入一些简单的约定来解决这个问题：
- en: '`propertyName="value"`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`propertyName="value"`'
- en: '`[propertyName]="expression"`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[propertyName]="expression"`'
- en: '`(eventName)="handler()"`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(eventName)="handler()"`'
- en: In the first line, the `propertyName` attribute accepts a string literal as
    a value. Angular will not process the attribute's value any further; it will use
    it the way it is set in the template.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，`propertyName` 属性接受一个字符串字面量作为值。Angular 不会进一步处理属性值；它将按模板中设置的方式使用它。
- en: The second syntax, `[propertyName]="expression"`, gives a hint to Angular that
    the value of the attributes should be handled as an expression. When Angular finds
    an attribute surrounded by brackets, it will interpret the expression in the context
    of the component associated with the template. In short, if we want to set a nonstring
    value or the result of an expression as value of given property, we will need
    to use this syntax.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种语法 `[propertyName]="expression"` 给 Angular 提供了一个提示，即属性值应被视为表达式。当 Angular
    发现被括号包围的属性时，它将在与模板关联的组件的上下文中解释该表达式。简而言之，如果我们想设置非字符串值或表达式的结果作为给定属性的值，我们需要使用这种语法。
- en: The last example shows how we can bind to events. The semantics behind `(eventName)="handler()"`
    is that we want to handle all events called `eventName` that are triggered by
    the given component with the `handler()` expression.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例展示了我们如何绑定到事件。`(eventName)="handler()"` 的语义是，我们希望处理由给定组件触发的所有名为 `eventName`
    的事件，使用 `handler()` 表达式。
- en: We will discuss more examples later in this chapter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论更多示例。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Angular provides alternative canonical syntax, which allows us to define the
    bindings of the elements without using brackets. For instance, the property binding
    can be expressed using the following code: `<input [value]="foo">`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 提供了替代的规范语法，允许我们定义元素的绑定而不使用括号。例如，属性绑定可以用以下代码表达：`<input [value]="foo">`
- en: 'It can also be expressed using this: `<input bind-value="foo">`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以用这种方式表达：`<input bind-value="foo">`
- en: 'Similarly, we can express the event bindings with the following code: `<button
    (click)="handle()">Click me</button>`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以用以下代码表达事件绑定：`<button (click)="handle()">点击我</button>`
- en: 'They can also be expressed using this: `<button on-click="handle()">Click me</button>`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以用以下方式表达：`<button on-click="handle()">点击我</button>`
- en: Declaring variables inside a template
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模板内声明变量
- en: The last thing left from the preceding template is the `let-todo` attribute.
    Using this syntax, we are telling Angular that we want to declare a new variable
    called `todo` and bind it to the individual items from the collection we get from
    the evaluation of the expression set as a value of `[ngForOf]`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个模板中剩下的最后一件事是 `let-todo` 属性。使用这种语法，我们告诉 Angular 我们想要声明一个名为 `todo` 的新变量，并将其绑定到
    `[ngForOf]` 设置为值的表达式的评估结果中的单个项目。
- en: Using syntax sugar in templates
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模板中使用语法糖
- en: Although the template syntax provides much more meaning of the code to the IDEs
    or text editors we use, it is quite verbose. Angular provides an alternative syntax,
    which will be desugared to the one shown in the preceding snippet.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然模板语法为我们使用的 IDE 或文本编辑器提供了代码的更多意义，但它相当冗长。Angular 提供了一种替代语法，它将被转换为前面片段中显示的语法。
- en: 'There are a few Angular directives that require the usage of a template element,
    for example, `ngForOf`, `ngIf`, and `ngSwitch`. Since such directives are used
    often, there''s an alternative syntax for them. Instead of typing down the entire
    template element explicitly, we can simply prefix the directive with `*`. This
    will allow us to turn our `ngForOf` directive syntax usage into the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些 Angular 指令需要使用模板元素，例如 `ngForOf`、`ngIf` 和 `ngSwitch`。由于这些指令经常使用，因此存在它们的替代语法。我们不需要显式地输入整个模板元素，只需在指令前加上
    `*` 前缀即可。这将允许我们将 `ngForOf` 指令语法的使用转换为以下形式：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Later, this template will be desugared by Angular to the more verbose syntax
    described earlier. Since the less verbose syntax is easier to read and write,
    its use is considered as the best practice.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，Angular 将将这个模板转换为前面描述的更冗长的语法。由于较简洁的语法更容易阅读和编写，因此其使用被认为是最佳实践。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `*` character allows us to remove the `template` element and put the directive
    directly on the top-level child element of the `template` (in the preceding example,
    the list item, `li`).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 字符允许我们移除 `template` 元素，并将指令直接放在 `template` 的顶级子元素上（在先前的示例中，是列表项，`li`）。'
- en: Defining Angular directives
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 Angular 指令
- en: Now that we've built a simple Angular component, let's continue our journey
    by understanding the Angular directives.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了一个简单的 Angular 组件，让我们继续我们的旅程，了解 Angular 指令。
- en: Using Angular directives, we can apply different behavioral or structural changes
    over the DOM. In this example, we will build a simple tooltip directive.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Angular指令，我们可以在DOM上应用不同的行为或结构变化。在这个例子中，我们将构建一个简单的tooltip指令。
- en: In contrast to components, directives do not have views and templates. Another
    core difference between these two concepts is that the given HTML element may
    have only a single component but multiple directives on it. In other words, directives
    augment the elements compared to components that are the actual elements in our
    views.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与组件相比，指令没有视图和模板。这两个概念之间的另一个核心区别是，给定的HTML元素可能只有一个组件，但可以有多个指令。换句话说，与我们在视图中实际使用的组件相比，指令增强了元素。
- en: 'Angular''s official style guide''s recommendation is to use directives as attributes,
    prefixed with a namespace. Keeping this in mind, we will use the tooltip directive
    in the following way:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的官方风格指南建议使用带有命名空间的前缀的指令作为属性。牢记这一点，我们将在以下方式中使用tooltip指令：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding snippet, we use the tooltip directive over the `div` element.
    As a namespace, its selector uses the `sa` string.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在`div`元素上使用了tooltip指令。作为一个命名空间，它的选择器使用了`sa`字符串。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since the focus of the book is an efficient and intuitive learning of Angular's
    concepts, the code snippets may not completely align with the Angular style guide.
    However, for production applications, following best practices is essential. You
    can find the official Angular style guide at [https://angular.io/styleguide](https://angular.io/styleguide)
    .
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书的重点是高效直观地学习Angular的概念，代码片段可能不会完全符合Angular风格指南。然而，对于生产应用程序，遵循最佳实践是至关重要的。您可以在[https://angular.io/styleguide](https://angular.io/styleguide)找到官方的Angular风格指南。
- en: 'Now, let''s develop a tooltip directive! Before implementing it, we need to
    import a couple of symbols from `@angular/core`. Open a new TypeScript file called
    `app.ts` and enter the following content; we''ll fill the placeholders later:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开发一个tooltip指令！在实现它之前，我们需要从`@angular/core`导入几个符号。打开一个名为`app.ts`的新TypeScript文件，并输入以下内容；我们稍后会填充占位符：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding line, we import the following definitions:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的行中，我们导入了以下定义：
- en: '`ElementRef`: This allows us to inject the element reference (we''re not limited
    to the DOM only) to the host element. In the sample usage of the preceding tooltip,
    we get an Angular wrapper of the `div` element, which holds the `saTooltip` attribute.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ElementRef`：这允许我们将元素引用（我们不仅限于DOM）注入到宿主元素中。在前面的tooltip的示例使用中，我们得到了一个Angular的`div`元素包装器，它持有`saTooltip`属性。'
- en: '`Directive`: This decorator allows us to add the metadata required for the
    new directives we define.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Directive`：这个装饰器允许我们添加我们定义的新指令所需的元数据。'
- en: '`HostListener(eventname)`: This is a method decorator that accepts an event
    name as an argument. During initialization of the directive, Angular will add
    the decorated method as an event handler for the `eventname` events fired by the
    host element.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HostListener(eventname)`：这是一个方法装饰器，它接受一个事件名称作为参数。在指令初始化期间，Angular会将装饰的方法作为事件处理程序添加到由宿主元素触发的`eventname`事件。'
- en: 'Let''s look at the directive''s implementation:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看指令的实现：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Setting the directive's inputs
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置指令的输入
- en: In the preceding example, we declared a directive with the `saTooltip` selector.
    Note that Angular's HTML compiler is case sensitive, which means that it will
    distinguish the `[satooltip]` and `[saTooltip]` selectors. After that, we declare
    the input of the directive using the `@Input` decorator over the `saTooltip` property.
    The semantics behind this code is that we declare a property called `saTooltip`
    and bind it to the value of the result that we got from the evaluation of the
    expression passed to the `saTooltip` attribute.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们声明了一个带有`saTooltip`选择器的指令。请注意，Angular的HTML编译器是区分大小写的，这意味着它会区分`[satooltip]`和`[saTooltip]`选择器。之后，我们使用`@Input`装饰器在`saTooltip`属性上声明指令的输入。此代码背后的语义是，我们声明一个名为`saTooltip`的属性并将其绑定到传递给`saTooltip`属性的评估表达式的结果值。
- en: The `@Input` decorator accepts a single argument, that is, the name of the attribute
    we want to bind to. In case we don't pass an argument, Angular will create a binding
    between the attribute with the same name as the property itself. We will explain
    the concept of input and output in detail later in this chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Input`装饰器接受一个参数，即我们想要绑定的属性的名称。如果我们不传递参数，Angular将创建一个与属性本身同名属性的绑定。我们将在本章后面详细解释输入和输出的概念。'
- en: Understanding the directive's constructor
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解指令的构造函数
- en: 'The constructor declares two private properties: `el` of the `ElementRef` type
    and `overlay` of the `Overlay` type. The `Overlay` class implements logic to manage
    the tooltips'' overlays and will be injected using the DI mechanism of Angular.
    In order to declare it as available for injection, we will need to declare the
    top-level component in the following way:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数声明了两个私有属性：`el`为`ElementRef`类型，`overlay`为`Overlay`类型。`Overlay`类实现了管理工具提示覆盖的逻辑，并将通过Angular的DI机制注入。为了将其声明为可注入的，我们需要以下方式声明顶级组件：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will take a look at the dependency injection mechanism of Angular in the
    next chapter, where we will explain the way in which we can declare the dependencies
    of our services, directives, and components. The implementation of the `Overlay`
    class is not important for the purpose of this chapter. However, if you're interested
    in it, you can find the implementation at `ch4/ts/tooltip/app.ts`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中探讨Angular的依赖注入机制，我们将解释我们如何声明我们的服务、指令和组件的依赖关系。`Overlay`类的实现对于本章的目的并不重要。然而，如果你对此感兴趣，你可以在`ch4/ts/tooltip/app.ts`中找到实现。
- en: Better encapsulation of directives with NgModules
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用NgModules更好地封装指令
- en: 'In order to make the tooltip directive available to the Angular''s compiler,
    we will need to explicitly declare where we intend to use it. For instance, take
    a look at the `AppModule` class at `ch4/ts/tooltip/app.ts`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使工具提示指令对Angular编译器可用，我们需要明确声明我们打算在哪里使用它。例如，查看`AppModule`类在`ch4/ts/tooltip/app.ts`中的内容：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To the `@NgModule` decorator, we pass an object literal that has the `declarations` property.
    This property contains a list of all the directives that will be available in
    all component subtrees with roots any of the components listed in the `bootstrap`
    array. Another way to extend the list of available directives is to import a module.
    For instance, the module `BrowserModule` includes some very commonly used directives
    for the browser environment.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`@NgModule`装饰器，我们传递一个具有`declarations`属性的文本对象。此属性包含所有将在`bootstrap`数组中列出的组件的所有子组件中可用的指令列表。另一种扩展可用指令列表的方法是导入一个模块。例如，`BrowserModule`模块包含一些在浏览器环境中非常常用的指令。
- en: At first, it might seem annoying that you should explicitly declare all the
    directives that are used in your modules; however, this enforces better encapsulation.
    In AngularJS, all directives are in a global namespace. This means that all the
    directives defined in the application are accessible in all the templates. This
    brings in some problems, for example, name collision. In order to deal with this
    issue, we introduced naming conventions, for instance, the `"ng-"` prefix of all
    the directives defined by AngularJS and `"ui-"` for all directives coming with
    the Angular UI.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，你可能觉得必须明确声明模块中使用的所有指令可能会很烦人；然而，这强制了更好的封装。在AngularJS中，所有指令都在全局命名空间中。这意味着应用程序中定义的所有指令都可以在所有模板中访问。这带来了一些问题，例如名称冲突。为了处理这个问题，我们引入了命名约定，例如，AngularJS定义的所有指令的`"ng-"`前缀和随Angular
    UI一起提供的所有指令的`"ui-"`前缀。
- en: Currently, by explicitly declaring all the directives that are used within a
    given module, we create a namespace specific to the individual components' subtrees
    (that is, the directives will be visible to the given root component and all of
    its successor components). Preventing name collisions is not the only benefit
    we get; it also helps us with better semantics of the code that we produce, since
    we're always aware of the directives accessible by the given component when we
    know in which module it's declared. We can find all the accessible directives
    of the given component by following the path from the component to the top module and
    taking the union of all the values of `declarations` and the declarations of the
    modules' `imports`. Given that components are extended from directives, we need
    to explicitly declare all the used components as well.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，通过明确声明给定模块中使用的所有指令，我们为各个组件的子树创建了一个特定的命名空间（即，指令将只对给定的根组件及其所有后续组件可见）。防止名称冲突不是我们得到的唯一好处；它还帮助我们更好地理解我们产生的代码的语义，因为我们总是知道给定组件在哪个模块中声明时可以访问哪些指令。我们可以通过从组件到顶级模块的路径找到给定组件的所有可访问指令，并取所有`declarations`值和模块`imports`声明的并集。鉴于组件是从指令扩展的，我们需要明确声明所有使用的组件。
- en: Since Angular defines a set of built-in directives, `BrowserModule` exports
    them by exporting the module `CommonModule`, which contains them. This list of
    predefined directives includes `NgClass`, `NgFor`, `NgIf`, `NgStyle`, `NgSwitch`,
    `NgSwitchWhen`, and `NgSwitchDefault`. Their names are quite self-explanatory;
    we'll take a look at how we can use some of them later in this chapter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Angular定义了一套内置指令，`BrowserModule`通过导出包含它们的模块`CommonModule`来导出它们。这个预定义指令列表包括`NgClass`、`NgFor`、`NgIf`、`NgStyle`、`NgSwitch`、`NgSwitchWhen`和`NgSwitchDefault`。它们的名字相当直观；我们将在本章后面看看我们如何使用其中的一些。
- en: Using NgModules for declaring reusable components
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用NgModules声明可重用组件
- en: With NgModules, we can achieve a good degree of encapsulation. By explicitly
    exporting the public components, directives, pipes, and services, we can hide
    some of the implementation details of our modules. This way we can implement reusable
    modules and expose only their public interface, and we do not reveal any low-level
    components to the user of the module.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NgModules，我们可以实现良好的封装度。通过显式导出公共组件、指令、管道和服务，我们可以隐藏我们模块的一些实现细节。这样我们可以实现可重用模块，仅暴露它们的公共接口，并且不对模块的用户透露任何底层组件。
- en: 'In order to get a better idea, let''s take a look at the following example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，让我们看看以下示例：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding snippet, we declare the components `Zippy`, `ZippyHeader`,
    and `App`. `Zippy` is a component that has a header and a content; we can toggle
    the visibility of the content by clicking on the header. In the component `ZippyHeader`,
    we can implement some logic for handling the click events and/or visualizing the
    header. In the `App` component, we use the `Zippy` component by passing text for
    it's header and content.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了组件`Zippy`、`ZippyHeader`和`App`。`Zippy`是一个具有标题和内容的组件；我们可以通过点击标题来切换内容的可见性。在`ZippyHeader`组件中，我们可以实现一些处理点击事件和/或可视化标题的逻辑。在`App`组件中，我们通过传递文本给它的标题和内容来使用`Zippy`组件。
- en: 'In order to create a working Angular application, we will need to declare an
    NgModule, which somehow references all the three components. We can approach this
    in two main ways:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个可工作的Angular应用程序，我们需要声明一个NgModule，它以某种方式引用了所有三个组件。我们可以通过两种主要方式来处理：
- en: Declare a single NgModule and include all the three components inside of its
    list of declarations.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个单独的NgModule，并在其声明列表中包含所有三个组件。
- en: 'Declare two NgModules:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个NgModules：
- en: One that declares the `Zippy` and `ZippyHeader` components, called `ZippyModule`.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个声明了`Zippy`和`ZippyHeader`组件，称为`ZippyModule`。
- en: Another one that declares the `App` component and imports the module `ZippyModule`.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个声明了`App`组件并导入了模块`ZippyModule`。
- en: The second approach has a couple of advantages: in `ZippyModule`, we can declare
    both `Zippy` and `ZippyHeader`, but we can export only `Zippy` because `ZippyHeader`
    is used internally, within `Zippy`, and we don't have to expose it to the user.
    By declaring the module `ZippyModule`, we can import it into other modules in
    our application where we want to reuse the `Zippy` component, or we can even extract
    it as a separate npm module and reuse it in multiple applications.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法有几个优点：在`ZippyModule`中，我们可以声明`Zippy`和`ZippyHeader`，但我们只能导出`Zippy`，因为`ZippyHeader`是在`Zippy`内部使用的，我们不需要将其暴露给用户。通过声明模块`ZippyModule`，我们可以将其导入到我们应用程序中的其他模块，以便重用`Zippy`组件，或者我们甚至可以将其提取为单独的npm模块，并在多个应用程序中重用它。
- en: 'The second approach will look like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法看起来是这样的：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding example, in the module `ZippyModule`, we declare both `Zippy`
    and `ZippyHeader`, but we export only `Zippy`. We also import the module `CommonModule`
    from `@angular/common` in order to reuse Angular's built-in directives (for instance, `NgIf`
    is exported by the `CommonModule`).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，在模块`ZippyModule`中，我们声明了`Zippy`和`ZippyHeader`，但我们只导出了`Zippy`。我们还从`@angular/common`中导入了模块`CommonModule`，以便重用Angular的内置指令（例如，`NgIf`是由`CommonModule`导出的）。
- en: In the `AppModule`, all we need to do is to import `ZippyModule`, and this way,
    we'll be able to use all of its exports and providers. We'll discuss providers
    further in the next chapter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AppModule`中，我们只需要导入`ZippyModule`，这样我们就能使用它的所有导出和提供者。我们将在下一章进一步讨论提供者。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that good practices suggest that we should implement each individual component
    into a separate file. For the sake of simplicity in the examples for this book,
    we've violated this practice. For a list of best practices, visit [https://angular.io/styleguide](https://angular.io/styleguide).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，良好的实践建议我们应该将每个单独的组件实现到单独的文件中。为了简化本书的示例，我们违反了这一实践。有关最佳实践的列表，请访问[https://angular.io/styleguide](https://angular.io/styleguide)。
- en: Using custom element schema
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义元素模式
- en: 'Now, let''s suppose we want to add a timer to our page and reuse a Web Component
    that we have already built. In this case, our application can look something like
    this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们想在页面上添加一个计时器，并重用我们已构建的Web组件。在这种情况下，我们的应用程序可能看起来像这样：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, if we run our application, we''ll get the following error:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行我们的应用程序，我们将得到以下错误：
- en: '![Using custom element schema](img/B06166_04_05.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![使用自定义元素模式](img/B06166_04_05.jpg)'
- en: Figure 5
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图5
- en: When Angular parses the template of the `App` component, it will find the `<simple-timer></simple-timer>`.
    It is not an element defined by the HTML specification and it doesn't match any
    of the selectors of the directives declared or imported in the `AppModule`, so
    the framework will throw an error.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当Angular解析`App`组件的模板时，它将找到`<simple-timer></simple-timer>`。它不是由HTML规范定义的元素，也不匹配`AppModule`中声明或导入的任何指令的选择器，因此框架将抛出错误。
- en: 'So, how we can use Angular with custom components? The solution is to use the
    `schemas` property of the object literal we pass to `@NgModule`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何使用Angular和自定义组件呢？解决方案是使用我们传递给`@NgModule`的对象字面量的`schemas`属性：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This way we change the default schema that Angular uses for the validation of
    the elements and their attributes during parsing.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就改变了Angular在解析元素及其属性时用于验证的默认模式。
- en: By default, the framework will throw an error if it finds an element that doesn't
    match the element selector of any of the imported or declared directive, or an
    element defined by the HTML5 spec.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果框架发现一个不匹配任何导入或声明的指令的元素选择器，或者由HTML5规范定义的元素，它将抛出错误。
- en: Creating custom Angular components
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义Angular组件
- en: Now, let's build a simple to-do application in order to demonstrate the syntax
    to define components further.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建一个简单的待办事项应用程序，以演示进一步定义组件的语法。
- en: 'Our to-do items will have the following format:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的待办事项将具有以下格式：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s start by importing everything we will need:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先导入我们将需要的所有内容：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s declare the component and the metadata associated with it:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们声明组件及其相关的元数据：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we specify that the selector of the `Todo` component will be the `todo-app`
    element. Later, we add the template URL, which points to the `app.html` file.
    After that, we use the `styles` property; this is the first time we encounter
    it. As we can guess from its name, it is used to set the styles of the component.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定`Todo`组件的选择器将是`todo-app`元素。稍后，我们添加模板URL，它指向`app.html`文件。然后，我们使用`styles`属性；这是我们第一次遇到它。从其名称中我们可以猜测，它用于设置组件的样式。
- en: Introducing the component's view encapsulation
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍组件的视图封装
- en: As we know, Angular is inspired from Web Components, whose core feature is the
    shadow DOM. The shadow DOM allows us to encapsulate the styles of our Web Components
    without allowing them to leak outside the component's scope; Angular provides
    this feature. If we want Angular's renderer to use the shadow DOM, we can use
    `ViewEncapsulation.Native`. However, at the time of writing this book, the shadow
    DOM was not supported by all browsers; if we want to have the same level of encapsulation
    without using the shadow DOM, we can use `ViewEncapsulation.Emulated`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，Angular受到了Web Components的启发，其核心特性是shadow DOM。shadow DOM允许我们在不使其泄漏到组件作用域之外的情况下封装我们的Web组件的样式；Angular提供了这一特性。如果我们想让Angular的渲染器使用shadow
    DOM，我们可以使用`ViewEncapsulation.Native`。然而，在撰写本书时，shadow DOM并不被所有浏览器支持；如果我们想在不使用shadow
    DOM的情况下达到相同级别的封装，我们可以使用`ViewEncapsulation.Emulated`。
- en: If we don't want to have any encapsulation at all, we can use `ViewEncapsulation.None`.
    By default, the renderer uses encapsulation of the type `Emulated`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想有任何封装，我们可以使用`ViewEncapsulation.None`。默认情况下，渲染器使用`Emulated`类型的封装。
- en: Implementing the component's controllers
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现组件的控制器
- en: 'Now, let''s continue with the implementation of the application:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续实现应用程序：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here is part of the implementation of the controller associated with the template
    of the `Todo` application. Inside the class declaration, we initialized the `todos`
    property to an array with two `todo` items.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Todo`应用程序模板相关控制器实现的一部分。在类声明中，我们将`todos`属性初始化为一个包含两个`todo`项的数组。
- en: 'Now, let''s update the template and render these items. Here''s how this is
    done:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新模板并渲染这些项。这是如何完成的：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding template, we iterate over all the `todo` items inside the
    `todos` property of the controller. For each `todo` item, we create a checkbox
    that can `toggle` the item''s completion status; we also render the `todo` item''s
    label with the interpolation directive. Here, we can note a syntax that was explained
    earlier:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板中，我们遍历控制器中`todos`属性内的所有`todo`项。对于每个`todo`项，我们创建一个可以`toggle`项完成状态的复选框；我们还使用插值指令渲染`todo`项的标签。在这里，我们可以注意到一个之前解释过的语法：
- en: We bind to the change event of the checkbox using `(change)="statement"`.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`(change)="statement"`绑定到复选框的更改事件。
- en: We bind to the property of the `todo` item using `[checked]="expr"`.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`[checked]="expr"`绑定到`todo`项的属性。
- en: 'In order to have a line across the completed `todo` items, we bind to the `class.completed`
    property of the element. Since we want to apply the `completed` class to all the
    completed to-do items, we use `[class.completed]="todo.completed"`. This way,
    we declare that we want to apply the `completed` class depending on the value
    of the `todo.completed` expression. Here is how our application looks now:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在已完成的`todo`项上有一条横线，我们绑定到元素的`class.completed`属性。由于我们希望将`completed`类应用于所有已完成的待办事项，我们使用`[class.completed]="todo.completed"`。这样，我们声明我们希望根据`todo.completed`表达式的值来应用`completed`类。现在，我们的应用程序看起来是这样的：
- en: '![Implementing the component''s controllers](img/6-5.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![实现组件的控制器](img/6-5.jpg)'
- en: Figure 6
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图6
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Similar to the class binding syntax, Angular allows us to bind to the element''s
    styles and attributes. For instance, we can bind to the `td` element''s `colspan`
    attribute using the following line of code: `<td [attr.colspan]="colspanCount"></td> `'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与类绑定语法类似，Angular 允许我们绑定到元素的样式和属性。例如，我们可以使用以下代码行绑定到`td`元素的`colspan`属性：`<td [attr.colspan]="colspanCount"></td>`
- en: 'In the same way, we can bind to any `style` property using this line of code:
     `<div [style.backgroundImage]="expression"></td>`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用此行代码绑定到任何`style`属性：`<div [style.backgroundImage]="expression"></td>`
- en: Handling user actions
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理用户操作
- en: 'So far, so good! Now, let''s implement the `toggleCompletion` method. This
    method accepts the index of the to-do item as an argument:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利！现在，让我们实现`toggleCompletion`方法。这个方法接受待办事项的索引作为参数：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In `toggleCompletion`, we simply toggle the `completed` boolean value associated
    with the current to-do item, which is specified by the index passed as an argument
    to the method.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在`toggleCompletion`中，我们简单地切换与当前待办事项关联的`completed`布尔值，该值由传递给方法的索引指定。
- en: 'Now, let''s add a text input to add the new to-do items:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个文本输入来添加新的待办事项：
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The input here defines a new variable called `newtodo`. Now, we can reference
    the input element using the `newtodo` identifier inside the template. Once the
    user clicks on the button, the `addTodo` method defined in the controller will
    be invoked with the value of the `newtodo` input as an argument. Inside the statement
    that is passed to the `(click)` attribute, we also reset the value of the `newtodo`
    input by setting it to the empty string.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的输入定义了一个名为`newtodo`的新变量。现在，我们可以在模板中使用`newtodo`标识符引用输入元素。一旦用户点击按钮，控制器中定义的`addTodo`方法将被调用，并将`newtodo`输入的值作为参数。在传递给`(click)`属性的语句中，我们还通过将其设置为空字符串来重置`newtodo`输入的值。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that directly manipulating DOM elements is not considered as the best practice
    since it will prevent our component from running properly outside the browser
    environment. We will explain how we can migrate this application to Web Workers
    in [Chapter 8](ch08.html "Chapter 8. Tooling and Development Experience"),  *Tooling
    and Development Experience*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，直接操作DOM元素不被认为是最佳实践，因为它将阻止我们的组件在浏览器环境之外正确运行。我们将在[第8章](ch08.html "第8章。工具和开发经验")中解释如何将此应用程序迁移到Web
    Workers，*工具和开发经验*。
- en: 'Now, let''s define the `addTodo` method:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义`addTodo`方法：
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Inside it, we create a new to-do item using the object literal syntax.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，我们使用对象字面量语法创建一个新的待办事项。
- en: The only thing left out of our application is to implement removal of the existing
    to-do items. Since it is quite similar to the functionality used to toggle the
    completion of the to-do items, I'll leave its implementation as a simple exercise
    for the reader.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序中唯一缺少的是实现删除现有待办事项的功能。由于它与用于切换待办事项完成状态的功能相当相似，我将将其实现留给读者作为一个简单的练习。
- en: Using inputs and outputs
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用输入和输出
- en: 'By refactoring our `todo` application, we will demonstrate how we can take
    advantage of the directives'' inputs and outputs:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重构我们的 `todo` 应用程序，我们将展示如何利用指令的输入和输出：
- en: '![Using inputs and outputs](img/B06166_04_07.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![使用输入和输出](img/B06166_04_07.jpg)'
- en: Figure 7
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图7
- en: We can think of the inputs as properties (or even arguments) that the given
    directive accepts. The outputs could be considered as events that it triggers.
    When we use a directive provided by a third-party library, mostly, we care about
    its inputs and outputs because they define its API.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将输入视为给定指令接受的属性（甚至参数）。输出可以被视为它触发的事件。当我们使用第三方库提供的指令时，我们主要关心其输入和输出，因为它们定义了其API。
- en: Inputs refer to values that parameterize the directive's behavior and/or view.
    On the other hand, outputs refer to events that the directive fires when something
    special happens.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 输入指的是参数化指令行为和/或视图的值。另一方面，输出指的是当发生特殊事件时指令引发的事件。
- en: Determining of the inputs and outputs
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定输入和输出
- en: 'Now, let''s divide our monolithic to-do application into separate components
    that communicate with each other. In the following screenshot, you can see the
    individual components, which when composed together, implement the functionality
    of the application:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们的单体待办事项应用程序分解成相互通信的单独组件。在下面的屏幕截图中，您可以看到单个组件，当它们组合在一起时，实现了应用程序的功能：
- en: '![Determining of the inputs and outputs](img/8-1.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![确定输入和输出](img/8-1.jpg)'
- en: Figure 8
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图8
- en: The outer rectangle represents the entire `Todo` application. The first nested
    rectangle contains the component that is responsible for entering labels of the
    new to-do items, and the one below it lists the individual items stored in the
    root component.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 外部矩形代表整个 `Todo` 应用程序。第一个嵌套矩形包含负责输入新待办事项标签的组件，下面的矩形列出了存储在根组件中的单个事项。
- en: 'Having said this, we can define these three components as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们可以将这些三个组件定义为以下内容：
- en: '`TodoApp`: This is responsible for maintaining the list of to-do items (adding
    new items and toggling the completion status).'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TodoApp`：负责维护待办事项列表（添加新事项和切换完成状态）。'
- en: '`InputBox`: This is responsible for entering the label of the new to-do item.
    It has the following inputs and outputs:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputBox`：负责输入新待办事项的标签。它具有以下输入和输出：'
- en: 'Inputs: a placeholder for the textbox and a label for the submit button.'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入：文本框的占位符和提交按钮的标签。
- en: 'Outputs: the content of the textbox once the submit button is clicked.'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出：点击提交按钮后文本框的内容。
- en: '`TodoList`: This is responsible for rendering the individual to-do items. It
    has the following inputs and outputs:'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TodoList`：负责渲染单个待办事项。它具有以下输入和输出：'
- en: 'Inputs: a list of to-do items.'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入：待办事项列表。
- en: Outputs: the completion status of a to-do item.
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出：待办事项的完成状态。
- en: Now, let's begin with the implementation!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始实现吧！
- en: Defining the inputs and outputs
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义输入和输出
- en: 'Let''s use a bottom-up approach, and start with the `InputBox` component. Before
    that, we need a couple of imports from Angular''s `@angular/core` package:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们采用自下而上的方法，从 `InputBox` 组件开始。在此之前，我们需要从 Angular 的 `@angular/core` 包中导入一些内容：
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, we import the `@Component`, `@Input`, and `@Output` decorators
    and the `EventEmitter` class. As their names state, `@Input` and `@Output` are
    used for declaring the directive's inputs and outputs. `EventEmitter` is a generic
    class (that is, accepting a type parameter), which when combined with the `@Output`
    decorator helps us emit outputs.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们导入了 `@Component`、`@Input`、`@Output` 装饰器和 `EventEmitter` 类。正如它们的名称所示，`@Input`
    和 `@Output` 用于声明指令的输入和输出。`EventEmitter` 是一个通用类（即接受类型参数），当与 `@Output` 装饰器结合使用时，有助于我们发出输出。
- en: 'As the next step, let''s take a look at the `InputBox` component''s declaration:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，让我们看一下 `InputBox` 组件的声明：
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that in the template, we declare a text input and keep a reference to
    it using the `todoInput` identifier, and set its placeholder property to the value
    that we got from the evaluation of the `inputPlaceholder` expression. The value
    of the expression is the value of the `inputPlaceholder` property defined in the
    component''s controller. This is the first input that we need to declare:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在模板中，我们声明一个文本输入，并使用 `todoInput` 标识符保持对其的引用，并将其占位符属性设置为从 `inputPlaceholder`
    表达式评估得到的值。该表达式的值是组件控制器中定义的 `inputPlaceholder` 属性的值。这是我们需要声明的第一个输入：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Similarly, we declare the other input of the `buttonLabel` component, which
    we use as a value of the label of the button:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们声明 `buttonLabel` 组件的另一个输入，并将其用作按钮标签的值：
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding template, we bind the click event of the button to this  `emitText(todoInput.value);
    todoInput.value = '''';` statement. The `emitText` method should be defined in
    the component''s controller; once it is invoked, it should emit the value of the
    text input. Here is how we can implement this behavior:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板中，我们将按钮的点击事件绑定到这个 `emitText(todoInput.value); todoInput.value = '';` 语句。`emitText`
    方法应该在组件的控制器中定义；一旦调用，它应该发出文本输入的值。以下是实现此行为的方法：
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Initially, we declare an output called `inputText`. As its value, we set a new
    instance of the type `EventEmitter<string>` that we create.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们声明一个名为 `inputText` 的输出。将其值设置为创建的新实例 `EventEmitter<string>` 类型。
- en: Note
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that all the outputs of all the components need to be instances of `EventEmitter`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有组件的所有输出都需要是 `EventEmitter` 的实例。
- en: Inside the `emitText` method, we invoke the `emit` method of the `inputText` and
    as its argument we pass the value of the text input.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `emitText` 方法内部，我们调用 `inputText` 的 `emit` 方法，并将其文本输入的值作为参数传递。
- en: 'Now, let''s define the `TodoList` component in the same fashion:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们以同样的方式定义 `TodoList` 组件：
- en: '[PRE34]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Since the value of the object literal passed to the `@Component` decorator is
    not essential for the purpose of this section, we omitted it. The complete implementation
    of this example can be found at `ch4/ts/inputs-outputs/app.ts`. Let's take a look
    at the body of the `TodoList` class. Similarly, to the `InputBox` component, we
    define the `todos` input. We also define the `toggle` output by declaring the
    `toggle` property, setting its value to a new instance of the type `EventEmitter<Todo>`
    and decorating it with the `@Output` decorator.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于传递给 `@Component` 装饰器的对象字面值对于本节的目的不是必需的，所以我们省略了它。本例的完整实现可以在 `ch4/ts/inputs-outputs/app.ts`
    中找到。让我们看看 `TodoList` 类的主体。同样，与 `InputBox` 组件一样，我们定义 `todos` 输入。我们还通过声明 `toggle`
    属性，将其值设置为新的 `EventEmitter<Todo>` 类型实例，并用 `@Output` 装饰器对其进行装饰。
- en: Passing inputs and consuming the outputs
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递输入并消费输出
- en: Now, let's combine the components we defined in the preceding section and implement
    our complete application.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将前面定义的组件组合起来，实现我们的完整应用程序。
- en: 'The last component we need to take a look at is `TodoApp`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要查看的最后一个组件是 `TodoApp`：
- en: '[PRE35]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Initially, we define the `TodoApp` class and decorate it with the `@Component`
    decorator. Note that in order to use the `InputBox` and `TodoList` components,
    we will need to include them in the `declarations` property of the decorator of
    the module, which declares `TodoApp`. The magic of how these components collaborate
    together happens in the template:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们定义 `TodoApp` 类，并用 `@Component` 装饰器对其进行装饰。注意，为了使用 `InputBox` 和 `TodoList`
    组件，我们需要将它们包含在声明 `TodoApp` 的模块装饰器的 `declarations` 属性中。这些组件之间协作的魔法发生在模板中：
- en: '[PRE36]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: First, we use the `InputBox` component and pass values to the inputs `inputPlaceholder`
    and `buttonLabel`. Note that just like we saw earlier, if we want to pass an expression
    as a value to any of these inputs, we will need to surround them with brackets
    (that is, `[inputPlaceholder]="expression"`). In this case, the expression will
    be evaluated in the context of the component that owns the template, and the result will
    be passed as an input to the component that owns the given property.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `InputBox` 组件，并将值传递给输入 `inputPlaceholder` 和 `buttonLabel`。注意，就像我们之前看到的，如果我们想将这些输入中的任何一个作为值传递一个表达式，我们需要用括号将其包围（即
    `[inputPlaceholder]="expression"`）。在这种情况下，该表达式将在拥有模板的组件的上下文中进行评估，并将结果作为输入传递给拥有给定属性的组件。
- en: Right after we pass the value for the `buttonLabel` input, we consume the `inputText`
    output by setting the value of the `(inputText)` attribute to the `addTodo($event)`
    expression. *The value of* `$event` *will equal the value we passed to the* `emit`
    *method of the* `inputText` *object inside the* `emitText` *method of* `InputBox`
    (in case we bind to a native event, the value of the event object will be the
    native event object itself).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在传递`buttonLabel`输入值之后，我们通过将`(inputText)`属性的值设置为`addTodo($event)`表达式来消费`inputText`输出。`$event`的值将等于我们传递给`emit`方法的`inputText`对象在`emitText`方法中的值（如果我们绑定到原生事件，事件对象的值将是原生事件对象本身）。
- en: 'In the same way, we pass the input of the `TodoList` component and handle its
    toggle output. Now, let''s define the logic behind the `TodoApp` component:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们传递`TodoList`组件的输入并处理其切换输出。现在，让我们定义`TodoApp`组件背后的逻辑：
- en: '[PRE37]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the `addTodo` method, we simply push a new to-do item to the `todos` array.
    The implementation of `toggleCompletion` is even simpler: we toggle the value
    of the completed flag that is passed as an argument to the to-do item. Now, we
    are familiar with the basics of the components'' inputs and outputs.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addTodo`方法中，我们只是简单地将一个新的待办事项推送到`todos`数组。`toggleCompletion`的实现甚至更简单：我们切换作为参数传递给待办事项的完成标志的值。现在，我们已经熟悉了组件的输入和输出基础知识。
- en: Event bubbling
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件冒泡
- en: 'In Angular, we have the same bubbling behavior we''re used to in the DOM. For
    instance, let''s suppose we have the following template:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，我们有与DOM中相同的冒泡行为。例如，假设我们有以下模板：
- en: '[PRE38]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The declaration of `input-box` looks like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`input-box`的声明如下：'
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Once the user clicks on the button defined within the template of the `input-box`
    component, the `handleClick($event)` expression will be evaluated.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击模板中定义的按钮时，`handleClick($event)`表达式将被评估。
- en: Further, the `target` property of the first argument of `handleClick` will be
    the button itself, but the `currentTarget` property will be the `input-box` element.
    The event will bubble the same way if we're not using Angular. At some point,
    it will reach the document unless a handler along the way doesn't stop its propagation.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`handleClick`的第一个参数的`target`属性将是按钮本身，但`currentTarget`属性将是`input-box`元素。如果我们不使用Angular，事件将以相同的方式冒泡。在某个时刻，它将到达文档，除非在传播过程中有处理程序阻止其传播。
- en: In contrast, if we have a custom `@Output`, the event will not bubble and instead
    of a DOM event, the value of the `$event` variable will be the value that we pass
    to the emit method of the output.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，如果我们有一个自定义的`@Output`，事件将不会冒泡，并且`$event`变量的值将是我们传递给输出emit方法的值，而不是DOM事件。
- en: Renaming the inputs and outputs
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重命名输入和输出
- en: 'Now, we will explore how we can rename the directives'' inputs and outputs.
    Let''s suppose that we have the following definition of the `TodoList` component:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨如何重命名指令的输入和输出。假设我们有以下`TodoList`组件的定义：
- en: '[PRE40]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output of the component is called `toggle`; the method that handles changes
    in the checkboxes responsible for toggling completion of the individual to-do
    items is also called `toggle`. This code will not be compiled, as in the `TodoList`
    controller we have two identifiers named in the same way. We have two options
    here:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的输出称为`toggle`；处理复选框变化以切换单个待办事项完成状态的方法也称为`toggle`。此代码将无法编译，因为在`TodoList`控制器中，有两个以相同方式命名的标识符。我们有两个选择：
- en: We can rename the method.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以重命名方法。
- en: We can rename the property.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以重命名属性。
- en: 'If we rename the property, this will change the name of the component''s output
    as well. So, the following line of code will no longer work:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重命名属性，这将改变组件输出的名称。因此，以下代码行将不再工作：
- en: '[PRE41]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'What we can do instead is rename the `toggle` property and explicitly set the
    name of the output using the `@Output` decorator:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的另一件事是重命名`toggle`属性，并使用`@Output`装饰器显式设置输出的名称：
- en: '[PRE42]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This way, we will be able to trigger the `toggle` output using the `toggleEvent`
    property.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们将能够通过`toggleEvent`属性触发`toggle`输出。
- en: Note
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that such renames could be confusing and are not considered as best practices.
    For a complete set of best practices, visit [https:// angular.io/styleguide](https://angular.io/styleguide)
    .
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这样的重命名可能会造成混淆，并且不被视为最佳实践。有关最佳实践的完整集合，请访问[https:// angular.io/styleguide](https://angular.io/styleguide)
    。
- en: 'Similarly, we can rename the component''s inputs using the following code snippet:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们可以使用以下代码片段重命名组件的输入：
- en: '[PRE43]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, it doesn''t matter that we renamed the input and output properties of
    `TodoList`; it still has the same public interface:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们重命名了`TodoList`的输入和输出属性并不重要；它仍然具有相同的公共接口：
- en: '[PRE44]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: An alternative syntax to define inputs and outputs
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义输入和输出的另一种语法
- en: 'The `@Input` and `@Output` decorators are syntax sugar for easier declaration
    of the directive''s inputs and outputs. The original syntax for this purpose is
    as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Input`和`@Output`装饰器是用于简化指令输入和输出声明的语法糖。用于此目的的原始语法如下：'
- en: '[PRE45]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Using `@Input` and `@Output`, the preceding syntax is equivalent to this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Input`和`@Output`，上述语法等同于以下内容：
- en: '[PRE46]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Although both have the same semantics, according to the best practices, we should
    use the latter one, because it is easier to read and understand.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两者具有相同的语义，但根据最佳实践，我们应该使用后者，因为它更容易阅读和理解。
- en: Explaining Angular's content projection
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释Angular的内容投影
- en: Content projection is an important concept when developing user interfaces.
    It allows us to project pieces of content into different places of the user interface
    of our application. Web Components solve this problem with the `content` element.
    In AngularJS, it is implemented with the infamous transclusion.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 内容投影是开发用户界面时的重要概念。它允许我们将内容片段投影到我们应用程序用户界面的不同位置。Web组件通过`content`元素解决了这个问题。在AngularJS中，它通过臭名昭著的转包含实现。
- en: Angular is inspired by modern Web standards, especially Web Components, which
    led to the adoption of some of the methods of content projection used there. In
    this section, we'll look at them in the context of Angular using the `ng-content`
    directive.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Angular受到现代Web标准的启发，特别是Web组件，这导致了在那里采用一些内容投影方法。在本节中，我们将使用`ng-content`指令在Angular的上下文中查看它们。
- en: Basic content projection in Angular
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular的基本内容投影
- en: 'Let''s suppose we''re building a component called `fancy-button`. This component
    will use the standard HTML button element and add some extra behavior to it. Here
    is the definition of the `fancy-button` component:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在构建一个名为`fancy-button`的组件。此组件将使用标准的HTML按钮元素并添加一些额外的行为。以下是`fancy-button`组件的定义：
- en: '[PRE47]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Inside of the `@Component` decorator, we set the inline template of the component
    together with its selector. Now, we can use the component with the following markup:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在`@Component`装饰器内部，我们设置了组件的内联模板及其选择器。现在，我们可以使用以下标记使用该组件：
- en: '[PRE48]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: On the screen, we will see a standard HTML button that has a label with the
    content **Click me**. This is not a very flexible way to define reusable UI components.
    Most likely, the users of the fancy button will need to change the content of
    the label to something, depending on their application.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上，我们将看到一个带有**点击我**标签的标准HTML按钮。这不是定义可重用UI组件的非常灵活的方式。很可能会出现，花哨按钮的用户需要根据他们的应用程序更改标签的内容。
- en: 'In AngularJS, we were able to achieve this result with `ng-transclude`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularJS中，我们能够通过`ng-transclude`实现这个结果：
- en: '[PRE49]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the new Angular, we have the `ng-content` element:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的Angular中，我们有`ng-content`元素：
- en: '[PRE50]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we can pass custom content to the fancy button by executing this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过执行以下操作将自定义内容传递给花哨的按钮：
- en: '[PRE51]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As a result, the content between the opening and the closing `fancy-button`
    tags will be placed where the `ng-content` directive resides.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`fancy-button`标签的开启和关闭标签之间的内容将被放置在`ng-content`指令所在的位置。
- en: Projecting multiple content chunks
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 投影多个内容块
- en: Another typical use case of content projection is when we pass content to a
    custom Angular component or AngularJS directive and we want different parts of
    this content to be projected to different locations in the template.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 内容投影的另一个典型用例是将内容传递给自定义Angular组件或AngularJS指令，并且我们希望将此内容的不同部分投影到模板的不同位置。
- en: 'For instance, let''s suppose we have a `panel` component that has a title and
    a body, and we can use it in the following way:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个具有标题和正文的`panel`组件，我们可以按以下方式使用它：
- en: '[PRE52]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The template of our `panel` component looks like this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`panel`组件模板如下所示：
- en: '[PRE53]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In AngularJS 1.5, we are able to do this using multi-slot transclusion, which
    was implemented in order to allow us to have a smoother transition to Angular
    2 and later versions. Let''s take a look at how we can proceed in Angular in order
    to define such a `panel` component:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularJS 1.5中，我们能够通过多插槽转包含来实现这一点，这是为了允许我们更平滑地过渡到Angular 2及以后的版本。让我们看看在Angular中如何定义这样的`panel`组件：
- en: '[PRE54]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We have already described the `selector` and `styles` properties, so let's take
    a look at the component's template. We have a `div` element with the `panel` class,
    which wraps the two nested `div` elements, respectively – one for the title of
    `panel` and one for the content of `panel`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经描述了`selector`和`styles`属性，现在让我们看看组件的模板。我们有一个带有`panel`类的`div`元素，它分别包裹着两个嵌套的`div`元素——一个用于`panel`的标题，另一个用于`panel`的内容。
- en: In order to project the content of the `section` element with class name `panel-title` to
    where the title should be, we will need to use the `ng-content` element. As its
    `selector` attribute, we will need to use a CSS selector, which matches the element
    whose content we want to project (in this case, the selector should be `.panel-title` or
    `section.panel-title`).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将具有类名`panel-title`的`section`元素的内容投影到标题应该出现的地方，我们需要使用`ng-content`元素。作为其`selector`属性，我们需要使用一个CSS选择器，该选择器匹配我们想要投影内容的元素（在这种情况下，选择器应该是`.panel-title`或`section.panel-title`）。
- en: In case we set the value of the `selector` attribute to `.panel-title`, it will
    match all the elements with classes `.panel-title`  that reside inside the target
    `panel` element. After this, `ng-content` will grab their content and set them
    as its own content.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`selector`属性的值设置为`.panel-title`，它将匹配所有位于目标`panel`元素内部的具有类`.panel-title`的元素。之后，`ng-content`将获取它们的内容并将它们设置为它自己的内容。
- en: Nesting components
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套组件
- en: 'We''ve already built a few simple applications as a composition of components
    and directives. We saw that components are basically directives with views, so
    we can implement them by nesting or composing other directives and components.
    The following figure illustrates this with a structural diagram:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了一些简单应用，它们是组件和指令的组合。我们看到了组件基本上是带有视图的指令，因此我们可以通过嵌套或组合其他指令和组件来实现它们。以下图示通过结构图说明了这一点：
- en: '![Nesting components](img/B06166_04_09.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![嵌套组件](img/B06166_04_09.jpg)'
- en: Figure 9
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图9
- en: 'The composition could be achieved by nesting directives and components within
    the components'' templates, taking advantage of the nested nature of the used
    markup. For instance, let''s say we have a component with the `sample-component`
    selector, which has the following definition:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在组件的模板内嵌套指令和组件，可以利用所使用的标记的嵌套特性来实现组合。例如，假设我们有一个具有`sample-component`选择器的组件，其定义如下：
- en: '[PRE55]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The template of the `Sample` component has a single-child element with the tag
    name `view-child`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sample`组件的模板有一个带有`view-child`标签名的单一子元素。'
- en: 'On the other hand, we can use the `Sample` component inside the template of
    another component, and since it can be used as an element, we can also nest other
    components or directives inside of it:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可以在另一个组件的模板中使用`Sample`组件，并且由于它可以作为一个元素使用，我们也可以在其中嵌套其他组件或指令：
- en: '[PRE56]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This way, the `sample-component` component has two different types of successors:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`sample-component`组件有两种不同类型的后继者：
- en: Successors defined within its template.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其模板内定义的后继者。
- en: Successors passed as nested elements between its opening and closing tags.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为嵌套元素传递给其开标签和闭标签之间的后继者。
- en: In the context of Angular, the direct children elements defined within the component's
    template are called **view children** and the ones nested between its opening
    and closing tags are called **content children**.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular的上下文中，组件模板内定义的直接子元素被称为**视图子元素**，而嵌套在其开标签和闭标签之间的元素被称为**内容子元素**。
- en: Using ViewChildren and ContentChildren
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ViewChildren和ContentChildren
- en: 'Let''s take a look at the implementation of the `Tabs` component, which uses
    the following structure:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Tabs`组件的实现，它使用了以下结构：
- en: '[PRE57]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The preceding structure is composed of three components:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的结构由三个组件组成：
- en: '`Tab` component'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tab`组件'
- en: '`TabTitle` component'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TabTitle`组件'
- en: '`TabContent` component'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TabContent`组件'
- en: 'Let''s take a look at the implementation of the `TabTitle` component:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`TabTitle`组件的实现：
- en: '[PRE58]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There's nothing new in this implementation. We define a `TabTitle` component,
    which has a single property called `tabSelected`. It is of the type `EventEmitter`
    and will be triggered once the user clicks on the tab title.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中没有什么新的内容。我们定义了一个名为`TabTitle`的组件，它有一个名为`tabSelected`的单个属性。它是一个`EventEmitter`类型，当用户点击标签标题时将被触发。
- en: 'Now, let''s take a look at the `TabContent` component:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`TabContent`组件：
- en: '[PRE59]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This has an even simpler implementation – all we do is project the DOM passed
    to the `tab-content` element inside `ng-content` and hide it once the value of
    the `isActive` property becomes `false`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个更简单的实现 - 我们所做的一切就是将传递给 `tab-content` 元素的 DOM 投影到 `ng-content` 中，一旦 `isActive`
    属性的值变为 `false`，就隐藏它。
- en: 'The interesting part of the implementation is the `Tabs` component itself:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 实现中的有趣部分是 `Tabs` 组件本身：
- en: '[PRE60]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In this implementation, we have a decorator that we haven''t used yet: the
    `@ContentChildren` decorator. The `@ContentChildren` property decorator fetches
    the content children of the given component. This means that we can get references
    to all `TabTitle` and `TabContent` instances from within the instance of the `Tabs`
    component and get them in the order in which they are declared in the markup.
    There''s an alternative decorator called `@ViewChildren`, which fetches all the
    view children of the given element. Let''s take a look at the difference between
    view children versus content children before we explain the implementation further.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们有一个尚未使用的装饰器：`@ContentChildren` 装饰器。`@ContentChildren` 属性装饰器获取给定组件的内容子组件。这意味着我们可以从
    `Tabs` 组件的实例中获取所有 `TabTitle` 和 `TabContent` 实例的引用，并按它们在标记中声明的顺序获取它们。还有一个名为 `@ViewChildren`
    的替代装饰器，它获取给定元素的所有视图子组件。在我们进一步解释实现之前，让我们看看视图子组件与内容子组件之间的区别。
- en: ViewChild versus ContentChild
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ViewChild` 与 `ContentChild`'
- en: 'Although both concepts sound similar, they have quite different semantics.
    In order to understand them better, let''s take a look at the following example:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个概念听起来很相似，但它们的语义相当不同。为了更好地理解它们，让我们看看以下示例：
- en: '[PRE61]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here, we''ve defined two components: `UserBadge` and `UserRating`. Let''s define
    a parent component, which comprises both the components:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了两个组件：`UserBadge` 和 `UserRating`。让我们定义一个父组件，它包含这两个组件：
- en: '[PRE62]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Note that the template of the view of `UserPanel` contains only the `UserBadge`
    component''s selector. Now, let''s use the `UserPanel` component in our application:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`UserPanel` 视图的模板中只包含 `UserBadge` 组件的选择器。现在，让我们在我们的应用程序中使用 `UserPanel` 组件：
- en: '[PRE63]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The template of our main `App` component uses the `UserPanel` component and
    nests the `UserRating` component inside it. Now, let''s suppose we want to get
    a reference to the instance of the `UserRating` component that is used inside
    the `user-panel` element in the `App`''s template and a reference to the `UserBadge`
    component, which is used inside the `UserPanel`''s template. In order to do this,
    we can add two more properties to the `UserPanel` controller and add the `@ContentChild`
    and `@ViewChild` decorators to them with the appropriate arguments:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要 `App` 组件的模板使用 `UserPanel` 组件，并在其中嵌套 `UserRating` 组件。现在，假设我们想在 `App` 模板的
    `user-panel` 元素内部获取 `UserRating` 组件的实例引用，以及在 `UserPanel` 模板的内部获取 `UserBadge` 组件的引用。为了做到这一点，我们可以在
    `UserPanel` 控制器中添加两个额外的属性，并将 `@ContentChild` 和 `@ViewChild` 装饰器添加到它们上，并使用适当的参数：
- en: '[PRE64]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The semantics of the `badge` property declaration is "get the instance of the
    first child component of the type `UserBadge`, which is used inside the `UserPanel`
    template". Accordingly, the semantics of the `rating` property's declaration is
    "get the instance of the first child component of the type `UserRating`, which
    is nested inside the `UserPanel` host element".
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`badge` 属性声明的语义是“获取 `UserPanel` 模板内部类型为 `UserBadge` 的第一个子组件的实例”。相应地，`rating`
    属性声明的语义是“获取嵌套在 `UserPanel` 宿主元素内部的类型为 `UserRating` 的第一个子组件的实例”。'
- en: Now, if you run this code, you'll note that the values of the `badge` and `rating`
    properties are still equal to the `undefined` value inside the controller's constructor.
    This is because they are still not initialized in this phase of the component's
    life cycle. The life cycle hooks that we can use in order to get a reference to
    these child components are `ngAfterViewInit` and `ngAfterContentInit`. We can
    use these hooks simply by adding definitions of the `ngAfterViewInit` and `ngAfterContentInit`
    methods to the component's controller. We will make a complete overview of the
    life cycle hooks that Angular provides shortly.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您运行此代码，您会注意到 `badge` 和 `rating` 属性的值在控制器构造函数中仍然是 `undefined` 值。这是因为它们在这个组件生命周期的这个阶段还没有初始化。我们可以用来获取这些子组件引用的生命周期钩子是
    `ngAfterViewInit` 和 `ngAfterContentInit`。我们可以通过在组件控制器中添加 `ngAfterViewInit` 和 `ngAfterContentInit`
    方法的定义来使用这些钩子。我们将很快对 Angular 提供的生命周期钩子做一个完整的概述。
- en: To recap, we can say that the content children of the given components are the
    child elements that are nested within the component's host element. In contrast,
    the view children directives of the given component are the elements used within
    its template.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们可以这样说，给定组件的内容子组件是嵌套在组件宿主元素内的子元素。相比之下，给定组件的视图子组件指令是用于其模板中的元素。
- en: Note
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In order to get a platform independent reference to a DOM element, again, we
    can use `@ContentChild` and `@ViewChild`. For instance, if we have the following
    template: `<input #todo>` we can get a reference to the `input` by using: `@ViewChild(''todo'')`.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '为了获取一个平台无关的DOM元素的引用，我们再次可以使用`@ContentChild`和`@ViewChild`。例如，如果我们有以下模板：`<input
    #todo>`，我们可以通过以下方式获取`input`的引用：`@ViewChild(''todo'')`。'
- en: Since we are already familiar with the core differences between view children
    and content children now, we can continue with our tabs implementation.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经熟悉了视图子组件和内容子组件之间的核心区别，我们可以继续进行我们的标签实现。
- en: 'In the tabs component, instead of using the `@ContentChild` decorator, we use
    `@ContentChildren`. We do this because we have multiple content children and we
    want to get them all:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在标签组件中，我们不是使用`@ContentChild`装饰器，而是使用`@ContentChildren`。我们这样做是因为我们有多达多个内容子组件，我们想要获取它们全部：
- en: '[PRE65]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Another main difference that we will note is that the types of the `tabTitles`
    and `tabContents` properties are `QueryList` with their respective type parameter
    and not the component's type itself. We can think of the `QueryList` data structure
    as a JavaScript array – we can apply the same high-order functions (`map`, `filter`,
    `reduce`, and so on) over it and loop over its elements; however, `QueryList`
    is also observable, that is, we can observe it for changes.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将注意到的另一个主要区别是，`tabTitles`和`tabContents`属性的类型是带有相应类型参数的`QueryList`，而不是组件本身的类型。我们可以将`QueryList`数据结构视为一个JavaScript数组——我们可以对其应用相同的高阶函数（`map`、`filter`、`reduce`等）并遍历其元素；然而，`QueryList`也是可观察的，也就是说，我们可以观察其变化。
- en: 'As the final step of our `Tabs` definition, let''s take a peek at the implementation
    of the `ngAfterContentInit` and `select` methods:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们的`Tabs`定义的最终步骤，让我们看看`ngAfterContentInit`和`select`方法的实现：
- en: '[PRE66]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In the first line of the method's implementation, we loop all `tabTitles` and
    take the observable's references. These objects have a method called `subscribe`,
    which accepts a callback as an argument. Once the `.emit()` method of the `EventEmitter`
    instance (that is, the `tabSelected` property of any tab) is called, the callback
    passed to the `subscribe` method will be invoked.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法实现的第 一行，我们遍历所有`tabTitles`并获取可观察对象的引用。这些对象有一个名为`subscribe`的方法，它接受一个回调作为参数。一旦调用`EventEmitter`实例的`.emit()`方法（即任何标签的`tabSelected`属性），传递给`subscribe`方法的回调将被调用。
- en: 'Now, let''s take a look at the `select` method''s implementation:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`select`方法实现的代码：
- en: '[PRE67]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In the first line, since `tabContents` is of the type `QueryList<TabContent>`,
    we get its array representation. After that, we set the `isActive` flag of the
    current active tab to `false` and select the next active one. In the last line
    in the `select` method's implementation, we trigger the selected event of the
    `Tabs` component by invoking `this.tabChanged.emit` with the index of the currently
    selected tab.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，由于`tabContents`的类型是`QueryList<TabContent>`，我们得到其数组表示形式。之后，我们将当前活动标签的`isActive`标志设置为`false`，并选择下一个活动标签。在`select`方法实现的最后一行，我们通过调用`this.tabChanged.emit`并传递当前选中标签的索引来触发`Tabs`组件的选中事件。
- en: Hooking into the component's life cycle
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挂钩到组件的生命周期
- en: Components in Angular have a well-defined life cycle, which allows us to hook
    into different phases of it and have further control over our application. We
    can do this by implementing specific methods in the component's controller. In
    order to be more explicit, thanks to the expressiveness of TypeScript, we can
    implement different interfaces associated with the life cycle's phases. Each of
    these interfaces has a single method, which is associated with the phase itself.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中的组件具有明确的生命周期，这使得我们可以挂钩到其不同阶段，并进一步控制我们的应用程序。我们可以通过在组件控制器中实现特定方法来实现这一点。为了更加明确，得益于TypeScript的表达能力，我们可以实现与生命周期阶段相关联的不同接口。每个接口都有一个方法，与该阶段本身相关联。
- en: Although code written with explicit interface implementation will have better
    semantics, since Angular supports ES5 as well, within the component we can simply
    define methods with the same names as the life cycle hooks (but this time, prefixed
    with `ng`) and take advantage of duck typing.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用显式接口实现编写的代码将具有更好的语义，但由于Angular也支持ES5，在组件内部我们可以简单地定义与生命周期钩子相同名称的方法（但这次，前缀为`ng`），并利用鸭子类型。
- en: 'The following diagram shows all the phases we can hook into:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了我们可以挂钩的所有阶段：
- en: '![Hooking into the component''s life cycle](img/B06166_04_10.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![挂钩到组件的生命周期](img/B06166_04_10.jpg)'
- en: Figure 10
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图10
- en: 'Let''s take a look at the different life cycle hooks:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看不同的生命周期钩子：
- en: '`OnChanges`: This hook will be invoked once a change in the input properties
    of a given component is detected. For instance, let''s take a look at the following
    component:'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnChanges`：这个钩子将在检测到给定组件输入属性的变化时被调用。例如，让我们看看以下组件：'
- en: '[PRE68]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can use it like this:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样使用它：
- en: '[PRE69]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Once the value of the expression associated with the `[title]` attribute is
    changed, the `ngOnChanges` hook will be invoked. We can implement it using this
    code snippet:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦与`[title]`属性关联的表达式的值发生变化，`ngOnChanges`钩子将被调用。我们可以使用以下代码片段来实现它：
- en: '[PRE70]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The preceding snippet will display all the changed bindings and their old values.
    In order to be more explicit in the implementation of the hook, we can use interfaces:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段将显示所有已更改的绑定及其旧值。为了在钩子的实现中更加明确，我们可以使用接口：
- en: '[PRE71]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: All the interfaces representing the individual life cycle hooks declare a single
    method with the name of the interface itself prefixed with `ng`. In the upcoming
    list, we'll use the term life cycle hook, both for interface and/or the method,
    except if we won't imply anything specifically for only one of them.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 表示各个生命周期钩子的所有接口都声明了一个以接口本身名称开头并前缀为`ng`的单个方法。在即将到来的列表中，我们将使用术语生命周期钩子，无论是接口还是/或方法，除非我们不会对其中任何一个具体说明。
- en: '`OnInit`: This hook will be invoked once the given component is initialized.
    We can implement it using the `OnInit` interface with its `ngOnInit` method.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnInit`：这个钩子将在给定组件初始化时被调用。我们可以使用`OnInit`接口及其`ngOnInit`方法来实现它。'
- en: '`DoCheck`: This will be invoked when the change detector of the given component
    is invoked. It allows us to implement our own change detection algorithm for the
    given component. Note that `DoCheck` and `OnChanges` should not be implemented
    together on the same directive.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoCheck`：当给定组件的变更检测器被调用时，这将会被调用。它允许我们为给定组件实现自己的变更检测算法。请注意，`DoCheck`和`OnChanges`不应在同一个指令上一起实现。'
- en: '`OnDestroy`: If we implement the `OnDestroy` interface with its `ngOnDestroy`
    method, we can hook into the destroy life cycle phase of a component. This method
    will be invoked once the component is detached from the component tree.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDestroy`：如果我们使用`ngOnDestroy`方法实现`OnDestroy`接口，我们可以挂钩到组件的销毁生命周期阶段。该方法将在组件从组件树中分离时被调用。'
- en: 'Now, let''s take a look at the life cycle hooks associated with the component''s
    content and view children:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看与组件的内容和视图子组件相关的生命周期钩子：
- en: '`AfterContentInit`: If we implement the `ngAfterContentInit` life cycle hook,
    we will be notified when the component''s content is fully initialized. This is
    the phase when the properties decorated with `ContentChild` or `ContentChildren`
    will be initialized.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterContentInit`：如果我们实现了`ngAfterContentInit`生命周期钩子，当组件的内容完全初始化时，我们将被通知。这是装饰了`ContentChild`或`ContentChildren`属性将初始化的阶段。'
- en: '`AfterContentChecked`: By implementing this hook, we''ll be notified each time
    the content of the given component has been checked by the change detection mechanism
    of Angular.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterContentChecked`：通过实现这个钩子，每当给定组件的内容被Angular的变更检测机制检查时，我们都会被通知。'
- en: '`AfterViewInit`: If we implement this life cycle hook with its `ngAfterViewInit` method,
    we will be notified when the component''s view is initialized. This is the phase
    when the properties decorated with `ViewChild` or `ViewChildren` will be initialized.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterViewInit`：如果我们使用`ngAfterViewInit`方法实现这个生命周期钩子，当组件的视图初始化时，我们将被通知。这是装饰了`ViewChild`或`ViewChildren`属性将初始化的阶段。'
- en: '`AfterViewChecked`: This is similar to `AfterContentChecked`. The `AfterViewChecked`
    hook will be invoked once the view of our component is checked.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterViewChecked`：这与`AfterContentChecked`类似。`AfterViewChecked`钩子将在我们的组件视图被检查后调用。'
- en: Order of execution of the life cycle hooks
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期钩子的执行顺序
- en: 'In order to trace the order of execution of the callbacks associated with each
    hook, let''s take a peek at the `ch4/ts/life-cycle/app.ts` example:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 为了追踪与每个钩子关联的回调函数的执行顺序，让我们看一下`ch4/ts/life-cycle/app.ts`的例子：
- en: '[PRE72]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `Panel` component implements all the hooks without explicitly implementing
    the interfaces associated with them.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`Panel`组件实现了所有钩子，而没有明确实现与之相关的接口。'
- en: 'We can use the component in the following template:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下模板中使用该组件：
- en: '[PRE73]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the preceding example, we have a panel and a button. Upon each click of the
    button, the panel will be either removed or appended to the view by the `ngIf`
    directive.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有一个面板和一个按钮。每次点击按钮时，面板将通过`ngIf`指令被移除或附加到视图中。
- en: During the application initialization, if the result of the `"counter % 2 ==
    0"` expression is evaluated to `true`, the `ngOnChanges` method will be invoked.
    This happens because the values of the title and caption properties will be set
    for the first time.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序初始化期间，如果`"counter % 2 == 0"`表达式的结果评估为`true`，将调用`ngOnChanges`方法。这是因为标题和标题属性值将首次被设置。
- en: Right after this, the `ngOnInit` method will be called, since the component
    has been initialized. Once the component's initialization is completed, the change
    detection will be triggered, which will lead to the invocation of the `ngDoCheck`
    method that allows us to hook custom logic for detecting changes in the state.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，将会调用`ngOnInit`方法，因为组件已经被初始化。一旦组件的初始化完成，变更检测将被触发，这将导致调用`ngDoCheck`方法，允许我们挂钩自定义逻辑以检测状态的变化。
- en: Note
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that you are not supposed to implement both `ngDoCheck` and `ngOnChanges`
    methods for the same component, since `ngOnChanges` will keep being called when
    the internal change detector detects changes. The example here does this for learning
    purposes only.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你不应该为同一个组件同时实现`ngDoCheck`和`ngOnChanges`方法，因为当内部变更检测器检测到变化时，`ngOnChanges`方法将会持续被调用。这里给出的例子只是为了学习目的。
- en: After the `ngDoCheck` method, the change detector will perform a check on the
    component's content (`ngAfterContentInit` and `ngAfterContentChecked` will be
    invoked in this order). Right after this, the same will happen for the component's
    view (`ngAfterViewInit` followed by `ngAfterViewChecked`).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ngDoCheck`方法之后，变更检测器将对组件的内容进行检查（将按顺序调用`ngAfterContentInit`和`ngAfterContentChecked`）。在此之后，同样的事情也会发生在组件的视图中（将按顺序调用`ngAfterViewInit`和`ngAfterViewChecked`）。
- en: Once the expression of the `ngIf` directive is evaluated to `false`, the entire
    component will be detached from the view, which will lead to the invocation of
    the `ngOnDestroy` hook.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`ngIf`指令的表达式评估为`false`，整个组件将从视图中分离，这将导致调用`ngOnDestroy`钩子。
- en: On the next click, if the value of the expression of `ngIf` is equal to `true`,
    the same sequence of calls of the life cycle hooks as the one during the initialization
    phase will be executed.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一次点击时，如果`ngIf`表达式的值为`true`，将执行与初始化阶段相同的生命周期钩子调用序列。
- en: Defining generic views with TemplateRef
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`TemplateRef`定义通用视图
- en: We are already familiar with the concepts of inputs, content children, and view
    children, and we also know when we can get a reference to them in the component's
    life cycle. Now, we will combine them and introduce a new concept-`TemplateRef`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了输入、内容子元素和视图子元素的概念，也知道在组件的生命周期中何时可以获取它们的引用。现在，我们将它们结合起来，介绍一个新概念——`TemplateRef`。
- en: 'Let''s take a step back and take a look at the last to-do application we developed
    earlier in this chapter. In the following screenshot, you can see what its UI
    looks like:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下本章前面开发的最后一个待办事项应用程序。在下面的屏幕截图中，你可以看到它的UI界面：
- en: '![Defining generic views with TemplateRef](img/11-1.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![使用`TemplateRef`定义通用视图](img/11-1.jpg)'
- en: Figure 11
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 图11
- en: If we take a look at its implementation in `ch4/ts/inputs-outputs/app.ts`, we'll
    see that the template used to render the individual to-do items is defined inside
    the template of the entire to-do application.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看其实现`ch4/ts/inputs-outputs/app.ts`，我们会看到用于渲染单个待办事项的模板是在整个待办事项应用程序的模板中定义的。
- en: What if we want to use a different layout to render the to-do items? We can
    do this by creating another component called `Todo`, which encapsulates the responsibility
    of rendering them. Then, we can define separate `Todo` components for the different
    layouts we want to support. This way, we need to have *n* different components
    for *n* different layouts, even though we need to change only their templates.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用不同的布局来渲染待办事项呢？我们可以通过创建另一个名为`Todo`的组件来实现，该组件封装了渲染它们的职责。然后，我们可以为想要支持的每个布局定义单独的`Todo`组件。这样，即使我们只需要更改它们的模板，我们也需要为每个布局有*n*个不同的组件。
- en: Angular comes with a more elegant solution. Earlier in this chapter, we have
    already discussed the template element. We said that it allows us to define a
    chunk of HTML that will not be processed by the browser. Angular allows us to
    reference such template elements and use them by passing them as content children.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了一个更优雅的解决方案。在本章的早期部分，我们已经讨论了模板元素。我们提到，它允许我们定义一个块HTML，该块不会被浏览器处理。Angular允许我们引用这样的模板元素，并通过将它们作为内容子元素传递来使用它们。
- en: 'Here is how we can pass the custom layout to our refactored `TodoApp` component:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的是如何将自定义布局传递给重构后的`TodoApp`组件：
- en: '[PRE74]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In the template, we declare a variable called `todo`. Later in the template,
    we can use it to specify the way in which we want to visualize the content.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，我们声明了一个名为`todo`的变量。在模板的后面部分，我们可以使用它来指定我们想要可视化的内容的方式。
- en: 'Now, let''s take a look at how we can get a reference to this template in the
    controller of the `TodoApp` component:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在`TodoApp`组件的控制器中获取这个模板的引用：
- en: '[PRE75]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: All we do here is define a property called `itemsTemplate` and decorate it with
    the `@ContentChild` decorator. During the component's life cycle (more accurately,
    in `ngAfterContentInit`), the value of `itemsTemplate` will be set to a reference
    of the template that we passed as the content of the `todo-app` element.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的只是定义一个名为`itemsTemplate`的属性，并用`@ContentChild`装饰器对其进行装饰。在组件的生命周期中（更准确地说，在`ngAfterContentInit`中），`itemsTemplate`的值将被设置为传递给`todo-app`元素内容的模板的引用。
- en: 'There is one more problem though – we need the template in the `TodoList` component,
    since that''s the place where we render the individual to-do items. What we can
    do is define another input of the `TodoList` component and pass the template directly
    from `TodoApp`:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个问题——我们需要在`TodoList`组件中使用模板，因为那是渲染单个待办事项的地方。我们可以做的是为`TodoList`组件定义另一个输入，并直接从`TodoApp`传递模板：
- en: '[PRE76]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We need to pass it as an input from the template of `TodoApp`:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将其作为从`TodoApp`模板的输入传递：
- en: '[PRE77]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The only thing left is to use this template reference in the template of the
    `TodoList` application:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是要在`TodoList`应用的模板中使用这个模板引用：
- en: '[PRE78]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We have explained the extended syntax of the `ngForOf` directive in the previous
    sections of this chapter. The preceding snippet shows one more property of this
    directive that we can set: the `ngForTemplate` property. By default, the template
    of the `ngForOf` directive is the element it is used on. By specifying a template
    reference to the `ngForTemplate` property, we can use the passed `TemplateRef`
    instead.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本章的前几节中解释了`ngForOf`指令的扩展语法。前面的代码片段显示了我们可以设置的另一个属性：`ngForTemplate`属性。默认情况下，`ngForOf`指令的模板是它所使用的元素。通过指定模板引用到`ngForTemplate`属性，我们可以使用传递的`TemplateRef`。
- en: Understanding and enhancing the change detection
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和增强变化检测
- en: We have already briefly described the change detection mechanism of the framework.
    We said that compared to AngularJS, where it runs in the context of the "scope",
    in Angular 2 and later versions, it runs in the context of the individual components.
    Another concept we mentioned is the zones, which basically intercept all the asynchronous
    calls that we make using the browser APIs and provide execution context for the
    change detection mechanism of the framework. Zones fix the annoying problem that
    we have in AngularJS, where when we use APIs outside of Angular, we needed to
    explicitly invoke the `digest` loop.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经简要描述了该框架的变化检测机制。我们提到，与在“作用域”上下文中运行的AngularJS相比，在Angular 2及以后的版本中，它是在单个组件的上下文中运行的。我们提到的另一个概念是区域，它基本上拦截了我们使用浏览器API所做的所有异步调用，并为框架的变化检测机制提供执行上下文。区域解决了AngularJS中令人烦恼的问题，即当我们使用Angular之外的外部API时，我们需要显式调用`digest`循环。
- en: In [Chapter 1](ch01.html "Chapter 1. Get Going with Angular"), *Get Going with
    Angular* and [Chapter 2](ch02.html "Chapter 2. The Building Blocks of an Angular
    Application"), *The Building Blocks of an Angular Application*, we discussed that
    the code that performs change detection over our components is being generated,
    either runtime (**Just-in-Time**) or as part of our build process (**Ahead-of-Time**).
    AoT compilation works great for environments with strict **CSP** (**Content-Security-Policy**)
    because of the disabled dynamic evaluation of JavaScript; it also provides much
    better performance since Angular will not have to compile the components' templates.
    We will explain it in detail in [Chapter 8](ch08.html "Chapter 8. Tooling and
    Development Experience"), *Tooling and Development Experience*.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。开始使用Angular") *开始使用Angular* 和 [第2章](ch02.html "第2章。Angular应用程序的构建块")
    *Angular应用程序的构建块* 中，我们讨论了执行组件变更检测的代码是生成的，要么是运行时（**即时**）要么是我们构建过程的一部分（**提前**）。由于禁用了JavaScript的动态评估，AoT编译在具有严格**CSP**（**内容安全策略**）的环境中表现良好；它还提供了更好的性能，因为Angular不需要编译组件的模板。我们将在[第8章](ch08.html
    "第8章。工具和开发体验") *工具和开发体验* 中详细解释。
- en: In this section, we'll explore another property of the `@Component` decorator's
    configuration object, which provides us further control over the change detection
    mechanism of the framework by changing its strategy. By explicitly setting the
    strategy, we are able to prevent the change detection mechanism from running over
    a component's subtrees, which in some cases can bring great performance benefits.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨`@Component`装饰器的配置对象的另一个属性，通过改变其策略，我们可以进一步控制框架的变更检测机制。通过显式设置策略，我们能够防止变更检测机制在组件的子树中运行，在某些情况下这可以带来巨大的性能优势。
- en: The order of execution of the change detectors
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变更检测器的执行顺序
- en: Now, let's briefly describe the order in which the change detectors are invoked
    in a given component tree.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简要描述在给定的组件树中变更检测器被调用的顺序。
- en: 'For this purpose, we will use the last implementation of the to-do application
    we have, but this time, we''ll extract the logic to render the individual to-do
    items into a separate component called TodoItem. In the following diagram, we
    can see the application''s structure:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们将使用我们已有的待办应用的最后一个实现，但这次，我们将渲染单个待办事项的逻辑提取到一个单独的组件中，称为TodoItem。在下面的图中，我们可以看到应用程序的结构：
- en: '![The order of execution of the change detectors](img/B06166_04_12.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![变更检测器的执行顺序](img/B06166_04_12.jpg)'
- en: Figure 12
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 图12
- en: 'At the top level is the **TodoApp** component, which has two children: **InputBox**
    and **TodoList**. The **TodoList** component renders the individual to-do items
    using the **TodoItem** components. The implementation details are not important
    for our purpose, so we will ignore them.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶层是**TodoApp**组件，它有两个子组件：**InputBox**和**TodoList**。**TodoList**组件使用**TodoItem**组件来渲染单个待办事项。对于我们的目的来说，实现细节并不重要，所以我们将会忽略它们。
- en: 'Now, we need to realize that there is an implicit dependency between the state
    of the parent component and its children. For instance, the state of the **TodoList**
    component depends completely on the to-do items that are located at its parent:
    the **TodoApp** component. There''s a similar dependency between **TodoItem**
    and **TodoList** since the **TodoList** component passes the individual to-do
    items to a separate instance of the **TodoItem** component. This means that if
    the list of to-do items in **TodoList** changes, this will automatically reflect
    some of the **TodoItem** components:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要意识到父组件的状态与其子组件之间存在隐式依赖关系。例如，**TodoList**组件的状态完全依赖于其父组件：**TodoApp**组件中的待办事项。**TodoItem**和**TodoList**之间也存在类似的依赖关系，因为**TodoList**组件将单个待办事项传递给**TodoItem**组件的一个单独实例。这意味着如果**TodoList**中的待办事项列表发生变化，这将自动反映一些**TodoItem**组件：
- en: '![The order of execution of the change detectors](img/B06166_04_13.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![变更检测器的执行顺序](img/B06166_04_13.jpg)'
- en: Figure 13
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 图13
- en: Owing to our last observation, the order of execution of the change detectors
    attached to the individual components is like the one shown in the preceding figure.
    Once the change detection mechanism run, initially it will perform a check over
    the **TodoApp** component. Right after this, the **InputBox** component will be
    checked for changes, followed by the **TodoList** component. In the end, Angular
    will invoke the change detector of the **TodoItem** component.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的最后一个观察结果，附加到各个组件的变更检测器的执行顺序类似于前面图示中的顺序。一旦变更检测机制运行，最初它将对**TodoApp**组件进行检查。紧接着，将检查**InputBox**组件的变更，然后是**TodoList**组件。最后，Angular将调用**TodoItem**组件的变更检测器。
- en: You can trace the order of execution in the `ch4/ts/change_detection_strategy_order/app.ts`
    example, where each individual component logs a message once its `ngDoCheck` method
    is invoked.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`ch4/ts/change_detection_strategy_order/app.ts`示例中追踪执行顺序，其中每个组件在其`ngDoCheck`方法被调用时都会记录一条消息。
- en: Note
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that only the components have an instance of a change detector attached
    to them; directives use the change detector of their parent component.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有组件才有附加变更检测器的实例；指令使用其父组件的变更检测器。
- en: Understanding Angular's change detection strategies
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Angular的变更检测策略
- en: The change detection strategies that Angular provides are `Default` and `OnPush`.
    We will describe how we can take advantage of `OnPush` in detail, since it is
    very powerful when working with immutable data.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供的变更检测策略有`Default`和`OnPush`。我们将详细描述如何利用`OnPush`，因为它在处理不可变数据时非常强大。
- en: 'Now, let''s import the TypeScript enum, which can be used to configure the
    strategy used for the individual components:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们导入TypeScript枚举，它可以用来配置用于各个组件的策略：
- en: '[PRE79]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, we can configure the `TodoList` component to use the `OnPush` strategy:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以配置`TodoList`组件使用`OnPush`策略：
- en: '[PRE80]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This way, the change detection will be skipped until the component doesn't receive
    inputs that have different values. Note that comparison uses equality check, which
    means that it'll compare primitive types by their value and objects by comparing
    their references. You can go to `http://localhost:5555/dist/dev/ch4/ts/change_detection_strategy_broken/`
    and see the inconsistent behavior of the `TodoList` component. When you add a
    new to-do item in the input and click on the **Add** button, it won't immediately
    appear in the list.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，变更检测将跳过，直到组件不接收具有不同值的输入。请注意，比较使用的是相等检查，这意味着它将通过值比较基本类型，通过引用比较对象。你可以访问`http://localhost:5555/dist/dev/ch4/ts/change_detection_strategy_broken/`来查看`TodoList`组件的不一致行为。当你向输入添加一个新的待办事项并点击**添加**按钮时，它不会立即出现在列表中。
- en: By default, the change detection will always check for changes.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，变更检测将始终检查变更。
- en: Introducing immutable data structures and OnPush
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入不可变数据结构和OnPush
- en: Now, we will describe the `OnPush` change detection strategy. It is extremely
    useful when the result that the given component produces depends only on its inputs.
    In such cases, we can pass an immutable data to its inputs in order to make sure
    that it will not be mutated by any component. This way, by having a component
    that depends only on its immutable inputs and doesn't produce any side effects,
    we can make sure that it produces different user interfaces only once it receives
    different inputs (that is, with different reference).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将描述`OnPush`变更检测策略。当给定组件产生的结果仅依赖于其输入时，它非常有用。在这种情况下，我们可以向其输入传递不可变数据，以确保它不会被任何组件修改。这样，通过拥有仅依赖于其不可变输入且不产生任何副作用组件，我们可以确保它仅在接收到不同的输入（即不同的引用）时产生不同的用户界面。
- en: In this section, we will apply the `OnPush` strategy to the `TodoList` component.
    Since it depends only on its inputs (the `todos` input), we want to make sure
    that its change detection will be performed only once it receives a new reference
    of the `todos` collection.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将`OnPush`策略应用于`TodoList`组件。由于它只依赖于其输入（`todos`输入），我们想要确保其变更检测仅在接收到`todos`集合的新引用时执行。
- en: The essence of an immutable data is that it cannot change. This means that once
    we create the `todos` collection, we cannot change it; instead, the `add` (or,
    in our case, `push`) method will return a new collection-a copy of the initial
    collection with the new item included.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数据的核心是它不能改变。这意味着一旦我们创建了`todos`集合，我们就不能改变它；相反，`add`（或在我们的情况下，`push`）方法将返回一个新的集合——包含新项目的初始集合的副本。
- en: This may seem like a huge overhead-to copy the entire collection on each change.
    In big applications, this may have a big performance impact. However, we don't
    need to copy the entire collection. There are libraries that implement the immutable
    data structure using smarter algorithms, for example, persistent data structures.
    Persistent data structures are out of the scope of the current content. Further
    information about them can be found in most computer science textbooks for advanced
    data structures. The good thing is that we don't have to understand their implementation
    in depth in order to use them. There is a library called *Immutable.js* that implements
    a few commonly used immutable data structures. In our case, we will use the immutable
    list. Generally, the immutable list behaves just like a normal list, but on each
    operation that is supposed to mutate it, it returns a new immutable list.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一个巨大的开销——每次更改时都要复制整个集合。在大型的应用程序中，这可能会对性能产生重大影响。然而，我们不需要复制整个集合。有一些库使用更智能的算法实现不可变数据结构，例如持久数据结构。持久数据结构超出了当前内容的范围。关于它们的信息可以在大多数计算机科学教科书中找到关于高级数据结构的内容。好事是我们不需要深入理解它们的实现就可以使用它们。有一个名为*Immutable.js*的库实现了几个常用的不可变数据结构。在我们的情况下，我们将使用不可变列表。通常，不可变列表的行为就像一个普通列表一样，但在每个应该变异它的操作中，它都会返回一个新的不可变列表。
- en: 'This means that if we have a list called `foo`, which is immutable, and append
    a new item to the list, we will get a new reference:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们有一个名为`foo`的不可变列表，并向列表中添加一个新项目，我们将得到一个新的引用：
- en: '[PRE81]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In order to take advantage of immutability, we will need to install Immutable.js
    using npm.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用不可变性，我们需要使用npm安装Immutable.js。
- en: The library is already a part of the project that contains the code for the
    book. You can find a reference to Immutable.js in `package.json`, located in the
    root of the project. You can take a look at `ch4/ts/change_detection_strategy/app.ts` to
    see how we include the immutable collections in our TypeScript application.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 该库已经是包含书籍代码的项目的一部分。你可以在项目的根目录下的`package.json`中找到对Immutable.js的引用。你可以查看`ch4/ts/change_detection_strategy/app.ts`来了解我们如何在TypeScript应用程序中包含不可变集合。
- en: Now, it's time to refactor our to-do application and make it use immutable data.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候重构我们的待办事项应用程序，使其使用不可变数据。
- en: Using immutable data in Angular
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Angular中使用不可变数据
- en: 'Let''s take a look at how we currently keep the to-do items in the `TodoApp`
    component:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们目前如何在`TodoApp`组件中保持待办事项：
- en: '[PRE82]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We use an array of `Todo` items. The JavaScript array is mutable, which means
    that if we pass it to a component that uses the `OnPush` strategy, it is not safe
    to skip the change detection in case we get the same input reference. For instance,
    we may have two components that use the same list of to-do items. Both components
    can modify the list since it is mutable. This will lead to an inconsistent state
    for any of the components in case their change detection is not performed. That''s
    why we need to make sure that the list that holds the items is immutable. All
    we need to do in the `TodoApp` component in order to make sure that it holds its
    data in an immutable data structure is this:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一系列的`Todo`项目。JavaScript数组是可变的，这意味着如果我们将其传递给使用`OnPush`策略的组件，在得到相同的输入引用时跳过变更检测是不安全的。例如，我们可能有使用相同待办事项列表的两个组件。由于列表是可变的，这两个组件都可以修改列表。如果它们的变更检测没有执行，这将导致任何组件的不一致状态。这就是为什么我们需要确保包含项目的列表是不可变的。为了确保`TodoApp`组件以不可变的数据结构持有其数据，我们只需要做以下操作：
- en: '[PRE83]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In this way, we construct the `todos` property as an immutable list, which contains
    immutable objects; all we need to do is to invoke the function `fromJS` exported
    by Immutable.js. It will recursively turn any JavaScript object into an immutable
    object.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们将`todos`属性构建为一个不可变列表，其中包含不可变对象；我们只需要调用由Immutable.js导出的函数`fromJS`。它将递归地将任何JavaScript对象转换为不可变对象。
- en: 'Next, since the mutation operations of the immutable list return a new list,
    we need to make a slight modification in `addTodo` and `toggleTodoCompletion`:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，由于不可变列表的变异操作返回一个新的列表，我们需要在`addTodo`和`toggleTodoCompletion`中做轻微的修改：
- en: '[PRE84]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The `addTodo` function looks exactly the same as before, except that we set
    the result of the `push` method as a value to the `todos` property.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`addTodo`函数看起来与之前完全相同，只是我们将`push`方法的结果设置为`todos`属性的值。'
- en: In `toggleTodoCompletion`, we use the `update` method of the immutable list.
    As the first argument, we pass the index of the to-do item we want to modify,
    and the second argument is a callback that does the actual modification. Note
    that since we use immutable data in this case, we copy the modified to-do item.
    This is required because it tells the `update` method that the item with the given
    index has been changed (since it is immutable, it is considered as changed only
    when it has a new reference), which means that the entire list has been changed.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在`toggleTodoCompletion`中，我们使用了不可变列表的`update`方法。作为第一个参数，我们传递要修改的任务项的索引，第二个参数是一个回调函数，它执行实际的修改。请注意，由于在这种情况下我们使用不可变数据，我们复制了修改后的任务项。这是必需的，因为它告诉`update`方法，给定索引的项已经被更改（由于它是不可变的，只有当它有一个新的引用时才被认为是更改的），这意味着整个列表已经更改。
- en: 'That was the complex part! Now, let''s take a look at the `TodoList` component''s
    definition:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是复杂的部分！现在，让我们看看`TodoList`组件的定义：
- en: '[PRE85]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Finally, we need to modify the way we access the properties of the immutable
    to-do items inside the templates:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要修改在模板中访问不可变任务项属性的方式：
- en: '[PRE86]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The change we made here is that instead of using direct property access, such
    as `todo.completed`, we invoke the object's `get` method by passing the property
    the value we want to get as a string, in this case `"completed"`.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的更改是，我们不是使用直接属性访问，例如`todo.completed`，而是通过传递我们想要获取的属性值作为字符串来调用对象的`get`方法，在这种情况下是`"completed"`。
- en: Inside the `@Component` decorator, we set the `changeDetection` property to
    the value of the `OnPush` strategy. This means that the component will run its
    change detector only when any of its inputs gets a new reference. Everything else,
    except the property access, inside of the template of the component stays exactly
    the same since `ngForOf` internally uses ES2015 iterators to loop over the items
    in the provided collection. They are supported by Immutable.js, so no changes
    in the template are required.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在`@Component`装饰器内部，我们将`changeDetection`属性设置为`OnPush`策略的值。这意味着组件只有在任何输入获得新的引用时才会运行其变更检测器。除了属性访问之外，组件的模板中的其他所有内容都保持完全相同，因为`ngForOf`内部使用ES2015迭代器遍历提供的集合中的项。它们由Immutable.js支持，因此模板不需要任何更改。
- en: Since we need the index of the changed item instead of its reference (the one
    we use in the `update` method of the `todos` collection in `TodoApp`), we change
    the type of the output of the component to `EventEmitter<number>`. In `toggleCompletion`,
    we emit the index of the changed to-do item.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要更改项的索引而不是其引用（我们在`TodoApp`的`todos`集合的`update`方法中使用的那种），我们将组件输出的类型更改为`EventEmitter<number>`。在`toggleCompletion`中，我们发出更改的任务项的索引。
- en: This is how we optimized our simple to-do application by preventing the change
    detection mechanism from running in the entire right subtree, in case the parent
    component hasn't pushed an input with a new reference.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们通过防止在父组件没有推送新的引用的输入的情况下在整个右子树中运行变更检测机制来优化我们的简单任务应用程序的方式。
- en: Summary
  id: totrans-479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we went through the core building blocks of an Angular application:
    directives and components. We built a couple of sample components, which showed
    us the syntax to be used for the definition of these fundamental concepts. We
    also described the life cycle of each directive and the core set of features the
    given directive and component have. As the next step, we saw how we can enhance
    the performance of our application using the `OnPush` change detection strategy
    with an immutable data.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Angular应用程序的核心构建块：指令和组件。我们构建了一些示例组件，这展示了定义这些基本概念时要使用的语法。我们还描述了每个指令的生命周期以及给定指令和组件的核心功能集。作为下一步，我们看到了如何使用不可变数据通过`OnPush`变更检测策略来提高我们应用程序的性能。
- en: The next chapter is completely dedicated to the Angular services and the dependency
    injection mechanism of the framework. We will take a look at how we can define
    and instantiate custom injectors and how we can take advantage of the dependency
    injection mechanism in our directives and components.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章完全致力于Angular服务和框架的依赖注入机制。我们将探讨如何定义和实例化自定义注入器，以及我们如何在指令和组件中利用依赖注入机制。
