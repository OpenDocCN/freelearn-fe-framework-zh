- en: Falcor Advanced Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Falcor高级概念
- en: Currently, our app has the ability to add, edit, and delete articles, but only
    on the frontend with the help of Redux's reducers. We need to add some full-stack
    mechanism to make this able to perform CRUD operations on the database. We will
    also need to add some security features on the backend so non-authenticated users
    won't be able to perform CRUD operations on the MongoDB collections.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序具有添加、编辑和删除文章的能力，但仅限于前端，借助Redux的reducers。我们需要添加一些全栈机制，以便能够在数据库上执行CRUD操作。我们还需要在后台添加一些安全功能，以便未经认证的用户无法对MongoDB集合执行CRUD操作。
- en: Let's pause coding for a moment. Before we start developing the full-stack Falcor
    mechanism, let's discuss our React, Node, and Falcor setup in more detail.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时停止编码。在我们开始开发全栈Falcor机制之前，让我们更详细地讨论我们的React、Node和Falcor设置。
- en: 'It''s important to understand why we have chosen Falcor in our technical stack.
    In general, at the custom software development company where I work (you can find
    more at [www.ReactPoland.com](http://www.ReactPoland.com)), we use Falcor as it
    has many great advantages for our clients in terms of the productivity of developing
    full-stack mobile/web applications. Some of them are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 理解为什么我们在技术栈中选择了Falcor是很重要的。一般来说，在我工作的定制软件开发公司（你可以在[www.ReactPoland.com](http://www.ReactPoland.com)上找到更多信息），我们使用Falcor，因为它在开发全栈移动/Web应用程序方面为客户带来了许多优势。其中一些如下：
- en: The simplicity of the concept
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概念的简单性
- en: A speedup of over by 30 percent in development in comparison to a RESTful approach
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与RESTful方法相比，开发速度提高30%以上
- en: Shallow learning curve, so a developer who learns Falcor can become effective
    very quickly
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浅度学习曲线，因此学习Falcor的开发者可以非常快速地变得有效
- en: An effective way of fetching data (from backend to the client side) that is
    quite astounding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种非常令人惊叹的数据获取方式（从后端到客户端）
- en: I will keep these four points short and sweet, for now. Later in the chapter,
    you will learn more about problems that you may face when using Falcor and Node.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我将暂时将这些四个要点简短而精炼。在本章的后面部分，你将了解到使用Falcor和Node时可能会遇到的问题。
- en: 'Currently, we have assembled a kind of full-stack starter kit with React, Redux,
    Falcor, Node, Express, and MongoDB. It''s not perfect yet. We will make it our
    focus for this chapter, which will include the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们已经使用React、Redux、Falcor、Node、Express和MongoDB组装了一种全栈入门套件。它还不是完美的。我们将把它作为本章的重点，其中包括以下主题：
- en: Better understanding the big picture of *RESTless data fetching* solutions and
    the similarities and differences between Falcor and Relay/GraphQL
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好地理解*无REST数据获取*解决方案的整体概念，以及Falcor与Relay/GraphQL之间的相似之处和不同之处
- en: How to secure routes in order to authenticate users on the backend
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在后台安全地路由以验证用户
- en: How to handle errors on the backend and send them seamlessly to the frontend
    with the help of errorSelectors
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过errorSelectors在后端处理错误并将其无缝发送到前端
- en: A detailed look at Falcor's sentinels and how exactly `$ref`, `$atom`, and `$error`
    work in Falcor
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细了解Falcor的哨兵以及`$ref`、`$atom`和`$error`在Falcor中是如何工作的
- en: What a JSON graph is and how it works
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON图是什么以及它是如何工作的
- en: What the virtual JSON concept is in Falcor
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Falcor中的虚拟JSON概念是什么
- en: The problem that Falcor aims to solve
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Falcor旨在解决的问题
- en: Before the era of single-page applications, there weren't problems with fetching
    data on the client, as all of the data was always fetched on the server, and even
    then, the server would send the HTML markup to the client. Each time someone clicked
    on a URL (`href`), our browser requested totally new HTML markup from the server.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在单页应用时代之前，客户端获取数据并没有问题，因为所有数据都是始终在服务器上获取的，即使如此，服务器也会将HTML标记发送到客户端。每次有人点击URL（`href`）时，我们的浏览器都会从服务器请求全新的HTML标记。
- en: Based on the preceding principles of non-SPA applications, Ruby on Rails became
    the king of web development's technical stack, but later things changed. Since
    2009-2010, we've been creating more and more JavaScript client applications, which
    are more likely fetched once from the backend as, for example, a `bundle.js` file.
    They're called SPAs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 基于非SPA应用程序的先前原则，Ruby on Rails成为了Web开发技术栈的王者，但后来情况发生了变化。自2009-2010年以来，我们一直在创建越来越多的JavaScript客户端应用程序，它们更有可能从后端一次性获取，例如`bundle.js`文件。它们被称为SPA。
- en: Because of this SP Apps trend, some new problems emerged that weren't known
    to non-SP Apps developers, such as fetching data from the API endpoint on the
    backend in order to consume that JSON data on the client side.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种SP Apps趋势，一些新的问题出现了，这些问题对于非SP Apps开发者来说是未知的，例如从后端的API端点获取数据以在客户端消费这些JSON数据。
- en: 'In general, the old-fashioned workflow for RESTful applications was as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，RESTful应用程序的传统工作流程如下：
- en: Create endpoints on the backend.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在后端创建端点。
- en: Create the fetching mechanism on the frontend.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前端创建获取机制。
- en: Fetch data from the backend by coding POST/GET requests on the frontend based
    on the API's specification.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在前端根据API规范编写POST/GET请求来从后端获取数据。
- en: When you fetch the JSON from the backend to the frontend, you can consume the
    data and use it in order to create the UI view based on a certain use case.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你从后端获取JSON数据到前端时，你可以消费这些数据，并基于特定的用例使用它来创建UI视图。
- en: This process is kind of frustrating if someone such as a client or boss changes
    their mind, because you were implementing the entire code on the backend and frontend.
    Later the backend API endpoints become irrelevant, so you need to start working
    on them from scratch based on the changed requirements.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户或老板等人改变主意，这个过程会变得有些令人沮丧，因为你已经在后端和前端实现了整个代码。后来后端API端点变得不再相关，因此你需要根据变更后的需求从头开始工作。
- en: Virtual JSON - one model everywhere
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟JSON - 一个模型无处不在
- en: For Falcor, one model everywhere is the main tagline of this great library.
    In general, the main purpose of using it is to create a single JSON model that
    is exactly the same on the frontend and backend. What does this mean for us? It
    means that if anything changes, we need to change the model, which is exactly
    the same on the backend and frontend--so in case of any changes, we need to tweak
    our model without worrying about how the data is provided on the backend and fetched
    on the frontend.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Falcor来说，一个模型无处不在是这一伟大库的主要口号。总的来说，使用它的主要目的是创建一个在前端和后端完全相同的单一JSON模型。这对我们意味着什么？这意味着如果任何东西发生变化，我们需要更改模型，这个模型在前后端都是一样的——所以在这种情况下，我们需要调整我们的模型，而不用担心后端如何提供数据以及前端如何获取数据。
- en: 'Falcor''s innovation is to introduce a new concept called virtual JSON (analogical
    to virtual DOM for React). This lets you represent all your remote data sources
    (for example, MongoDB in our case) as a single domain model. The whole idea is
    that you code the same way without caring where your data is: is it on the client-side
    memory cache or on the server? You don''t need to care, as Falcor, with its innovative
    approach, does a lot of the job (for example, querying with `xhr` requests) for
    you.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Falcor的创新之处在于引入了一个名为虚拟JSON（类似于React的虚拟DOM）的新概念。这让你可以将所有远程数据源（例如，在我们的案例中是MongoDB）表示为一个单一的领域模型。整个想法是，你可以以相同的方式编码，而不必关心数据在哪里：是在客户端内存缓存中还是在服务器上？你不需要关心，因为Falcor以其创新的方法为你做了很多工作（例如，使用`xhr`请求进行查询）。
- en: Data fetching is a problem for developers. Falcor is here to help to make it
    simpler. You can fetch data from the backend to the frontend, writing fewer lines
    of code than ever!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数据获取是开发人员面临的问题。Falcor的出现就是为了帮助简化这个问题。你可以从后端获取数据到前端，比以往任何时候都少写代码！
- en: It's May 2016, and the only viable competitors that I see on the horizon are
    the Facebook libraries called Relay (on the client side) and GraphQL (on the backend).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 2016年5月，我看到的唯一可行的竞争对手是Facebook的库，称为Relay（在客户端）和GraphQL（在后端）。
- en: Let's try to compare both.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试比较一下两者。
- en: Falcor versus Relay/GraphQL
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Falcor与Relay/GraphQL的比较
- en: As with any tool, there are always pros and cons.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何工具一样，总有优点和缺点。
- en: For certain, Falcor is always better than Relay/GraphQL in small/mid-sized projects,
    at least unless you have master developers (or you are a master yourself) who
    know Relay/GraphQL very well. Why is that?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Falcor在小/中型项目中总是比Relay/GraphQL更好，至少除非你有精通开发者（或者你就是自己）非常了解Relay/GraphQL。为什么是这样呢？
- en: In general, Relay (for the frontend) and GrapQL (for the backend) are two different
    tools and you must be efficient in order to use properly.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Relay（用于前端）和GrapQL（用于后端）是两种不同的工具，你必须高效地使用它们才能正确使用。
- en: Very often in commercial environments, you don't have too much time to learn
    things from scratch. This is also a reason behind the success of React.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在商业环境中，你往往没有太多时间去从头学习新事物。这也是React成功的一个原因。
- en: Why has React succeeded? React is much easier to grasp in order to be an efficient
    frontend developer. A CTO or technical director hires a newbie developer who knows
    jQuery (for example), and then the CTO can easily project that this junior developer
    will be effective in React in 7 to 14 days; I was teaching junior frontend developers
    with basic knowledge of JavaScript/jQuery, and I found out that they quite quickly
    become efficient in creating client-side apps with React.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么React会成功？React对于成为一个高效的开发者来说更容易掌握。CTO或技术总监雇佣一个了解jQuery（例如）的新手开发者，然后CTO可以轻松地预测这位初级开发者将在7到14天内有效地使用React；我曾教过一些对JavaScript/jQuery有基本知识的初级前端开发者，我发现他们相当快地就能够在React中高效地创建客户端应用程序。
- en: We can find the same situation with Falcor. Falcor, in comparison to Relay +
    GraphQL, is like the simplicity of React compared to the monolithic framework
    of Angular.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Falcor中找到相同的情况。与Relay + GraphQL相比，Falcor就像React的简单性与Angular单体框架的复杂性相比。
- en: This single factor described in the previous few paragraphs means that Falcor
    is better for small/mid-size projects with a limited budget.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几段中描述的单一因素意味着Falcor更适合预算有限的小型/中型项目。
- en: You may find some opportunities to learn Relay/GraphQL in bigger companies with
    much bigger budgets, such as Facebook, when you have 6 months to master a technology.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有6个月的时间掌握一项技术时，你可能会在大公司中找到学习Relay/GraphQL的机会，这些公司拥有庞大的预算，例如Facebook。
- en: FalcorJS can be mastered effectively in two weeks, but GraphQL + Relay cannot.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: FalcorJS可以在两周内有效掌握，但GraphQL + Relay不行。
- en: Big-picture similarities
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大图相似性
- en: Both these tools are trying to solve the same problem. They are efficient by
    design for both developers and the network (trying to optimize the number of queries
    in comparison to a RESTful approach).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个工具都在试图解决相同的问题。它们在设计上对开发者和网络都高效（试图优化与RESTful方法相比的查询数量）。
- en: They have the ability to query the backend server in order to fetch data and
    also have batching ability (so you can fetch more than two different sets of data
    with one network request). Both have some caching abilities.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 他们具有查询后端服务器以获取数据的能力，并且具有批量处理能力（因此你可以通过一个网络请求获取超过两组不同的数据）。两者都有一些缓存能力。
- en: Technical differences - overview
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术差异 - 概述
- en: With a technical overview, we can find out that in general, Relay allows you
    to query an undefined number of items from the GraphQL server. In Falcor, for
    comparison, you need to first ask the backend how many items it has before being
    able to query for the collection objects' details (such as articles, in our book's
    case).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过技术概述，我们可以发现，通常，Relay允许你从GraphQL服务器查询未定义数量的项目。相比之下，在Falcor中，你需要先询问后端它有多少个项目，然后才能查询集合对象的详细信息（例如，在我们的书中，文章的情况）。
- en: 'In general, the biggest difference here is that GraphQL/Relay is a query language
    tool and Falcor is not. What is a query language? It''s one with which you can
    make queries from the frontend similar to SQL, like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这里最大的区别是GraphQL/Relay是一个查询语言工具，而Falcor不是。什么是查询语言？它是一种你可以从前端进行查询的语言，类似于SQL，如下所示：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code can be made a query from the frontend via `Relay.QL`, and
    then GraphQL processes the query in the same way as SQL, like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码可以通过`Relay.QL`从前端进行查询，然后GraphQL以与SQL相同的方式处理查询，如下所示：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Things may get harder if there are, for example, a million articles in the DB
    and you didn't expect so many on the frontend.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库中有，例如，一百万篇文章，而你没有预料到这么多在前端，事情可能会变得更难。
- en: 'In Falcor, you do it differently, as you''ve already learned:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Falcor中，你将采取不同的做法，就像你已经学到的：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding Falcor example, you must first know how many records there
    are in the MongoDB instance.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的Falcor示例中，你必须首先知道MongoDB实例中有多少条记录。
- en: This is one of most important differences and creates some challenges for both
    sides.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最重要的区别之一，并为双方创造了一些挑战。
- en: For GraphQL and Relay, the question is whether the power of those query languages
    is worth the complexity created in the learning curve, because that complexity
    may not be worth it for small/mid-sized projects.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于GraphQL和Relay来说，问题是这些查询语言的力量是否值得学习曲线中产生的复杂性，因为这种复杂性可能对小型/中型项目来说不值得。
- en: Now that the basic differences have been discussed, let's focus on Falcor and
    improving our current publishing app.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经讨论了基本的不同之处，让我们专注于Falcor和改进我们当前的发布应用程序。
- en: Improving our application and making it more reliable
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高我们的应用程序并使其更加可靠
- en: 'We need to improve things such as the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要改进以下事项：
- en: After a login, we shall send user details in each request (the token, username,
    and a role; you can find a screenshot later in the section *Improving our Falcor
    code on the frontend*)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录后，我们应在每个请求中发送用户详情（令牌、用户名和角色；你可以在本节后面的 *改进前端上的 Falcor 代码* 部分找到截图）
- en: The backend needs to be secured so that authorization is checked before running
    add/edit/delete operations on the backend
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端需要得到保护，以便在执行添加/编辑/删除操作之前进行身份验证检查。
- en: We need to provide the ability to catch errors on the backend and give a notification
    to the user on the frontend about something not working correctly
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要在后端提供捕获错误的能力，并在前端通知用户某些操作不正确
- en: Securing the auth required routes
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护需要身份验证的路由
- en: Currently, our app has the ability to add/edit/delete a route. The problem with
    our current implementation is that we don't check whether a client making a CRUD
    operation has the privileges to do so.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序具有添加/编辑/删除路由的能力。我们当前实现的问题是我们没有检查发起 CRUD 操作的客户端是否有权限这样做。
- en: The solution of securing Falcor routes requires some changes to our current
    implementation, so for each request, before performing the operation, we will
    check whether we have got the correct token from the client and whether the user
    making the call has the ability to edit (in our case, it means that if anyone
    has an editor role and is authenticated correctly with his username and password,
    then he can add/edit/delete an article).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 保护 Falcor 路由的解决方案需要对我们当前的实施进行一些更改，因此对于每个请求，在执行操作之前，我们将检查是否从客户端获得了正确的令牌，以及发起调用的用户是否有编辑的能力（在我们的情况下，这意味着如果任何人有编辑角色并且正确地使用用户名和密码进行身份验证，那么他可以添加/编辑/删除文章）。
- en: JSON Graph and JSON envelopes in Falcor
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Falcor 中的 JSON 图和 JSON 封装
- en: As the Falcor documentation states, "JSON Graph is a convention for modeling
    graph information as a JSON object. Applications that use Falcor represent all
    their domain data as a single JSON Graph object."
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如 Falcor 文档所述，“JSON 图是将图信息建模为 JSON 对象的约定。使用 Falcor 的应用程序将它们的所有领域数据表示为一个单一的 JSON
    图对象。”
- en: In general, JSON Graph in Falcor is valid JSON with some new features. To be
    more precise, JSON Graph introduces a new types of data besides strings, numbers,
    and Booleans. The new data type in Falcor is called a **sentinel**. I will try
    to explain it later in the chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，Falcor 中的 JSON 图是有效的 JSON，并具有一些新特性。更精确地说，JSON 图引入了除了字符串、数字和布尔值之外的新数据类型。在
    Falcor 中，这种新数据类型被称为 **哨兵**。我将在本章后面尝试解释它。
- en: Generally, the second most important thing to understand in Falcor are JSON
    envelopes. The great thing is that they work out of the box, so you don't have
    to worry too much about them. But if you want to know what the short and sweet
    answer is, JSON envelopes help send JSON's model via HTTP's protocol. It's a way
    of transferring data from frontend to backend (with the `.call`, `.set`, and `.get`
    methods). In the same way, before the backend (after processing a request's details),
    before sending the improved model's details to the client side, Falcor puts it
    into an *envelope* so that it can be easily transferred via a network.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在 Falcor 中理解第二重要的是 JSON 封装。好事是它们开箱即用，所以你不必过于担心它们。但如果你想知道简短而直接的答案，JSON 封装帮助通过
    HTTP 协议发送 JSON 的模型。这是一种从前端到后端（使用 `.call`、`.set` 和 `.get` 方法）传输数据的方式。同样，在发送改进后的模型详情到客户端之前，在处理请求详情之后，Falcor
    会将其放入一个 *封装* 中，以便通过网络轻松传输。
- en: A good (but not perfect) analogy for JSON envelopes is that you put a written
    list into an envelope because you don't want to send some valuable information
    over from point *A* to point *B*; the network doesn't care what you send in that
    envelope. The most important thing is that the sender and the receiver know the
    context of the application model.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 封装的类比是，你将一份书面清单放入信封中，因为你不想将一些有价值的信息从点 *A* 发送到点 *B*；网络不关心你在这个信封中发送什么。最重要的是，发送者和接收者知道应用程序模型的环境。
- en: You can find more information about the JSON Graph and envelopes at [http://netflix.github.io/falcor/documentation/jsongraph.html](http://netflix.github.io/falcor/documentation/jsongraph.html).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [http://netflix.github.io/falcor/documentation/jsongraph.html](http://netflix.github.io/falcor/documentation/jsongraph.html)
    找到有关 JSON 图和封装的更多信息。
- en: Improving our Falcor code on the frontend
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进前端上的 Falcor 代码
- en: Currently, after a user authorizes himself, all the data is saved into local
    storage. We need to close the loop by sending that data--token, username, and
    role--back to the backend with each request so we can check again whether a user
    is authenticated correctly. If not, then we need to send an authentication error
    with the request and show it back on the frontend.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在用户授权后，所有数据都保存在本地存储中。我们需要通过在每个请求中发送该数据--令牌、用户名和角色--来闭合循环，以便我们可以再次检查用户是否正确认证。如果没有，那么我们需要在请求中发送认证错误并将其显示在前端。
- en: 'The arrangement in the following screenshot is specifically important for security
    reasons so that no unauthorized user can add/edit/delete an article in our database:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图中的排列对于安全原因特别重要，以确保未经授权的用户无法在我们的数据库中添加/编辑/删除文章：
- en: '![](img/00047.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00047.jpeg)'
- en: In the screenshot, you can find out where you can get information about the
    `localStorage` data.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在截图上，你可以找到获取`localStorage`数据信息的地方。
- en: 'The following is our current code in `src/falcorModel.js`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们当前在`src/falcorModel.js`中的代码：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We need to change this to a new, improved version:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将其更改为一个新的、改进的版本：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After you implement the previous code in `falcorModel.js` and a user is logged,
    those variables will be added to each request:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在你在`falcorModel.js`中实现前面的代码并且用户登录后，这些变量将被添加到每个请求中：
- en: '![](img/00048.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00048.jpeg)'
- en: Improving server.js and routes.js
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进`server.js`和`routes.js`
- en: In general, we currently export an array of objects from the `server/routes.js`
    file. We need to improve it, so we will return a function that will modify our
    array of objects so we have control over which route is returned to which user,
    and in case a user does not have a valid token or enough privileges, we will return
    an error. This will improve the security of our whole app.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们目前从`server/routes.js`文件中导出一个对象数组。我们需要改进它，所以我们将返回一个函数，该函数将修改我们的对象数组，以便我们能够控制将哪个路由返回给哪个用户，并且如果用户没有有效的令牌或足够的权限，我们将返回一个错误。这将提高我们整个应用程序的安全性。
- en: 'In the `server/server.js` file, find this old code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server/server.js`文件中，找到以下旧代码：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Replace it with this improved one:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个改进版本替换它：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In our new version, we assume that the `routes` variable is a function with
    the `req` and `res` variables.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新版本中，我们假设`routes`变量是一个带有`req`和`res`变量的函数。
- en: Let's improve the routes itself so we won't return an array anymore, but a function
    that returns an array (so we end up with more flexibility).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进路由本身，这样我们就不再返回一个数组了，而是一个返回数组的函数（这样我们就有了更多的灵活性）。
- en: 'The next step is to improve the `server/routes.js` file in order to make a
    function that receives the `currentSession` object, which stores all the information
    about a request. We need to change this in `routes.js`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是改进`server/routes.js`文件，以便创建一个接收`currentSession`对象的函数，该对象存储有关请求的所有信息。我们需要在`routes.js`中做出以下更改：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Instead of exporting an array of routes, we need to export a function that will
    return routes based on a current request's header details.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是导出一个路由数组，我们需要导出一个函数，该函数将根据当前请求的头部详细信息返回路由。
- en: 'The top part of the `server/routes.js` file (with imports) is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`server/routes.js`文件的上半部分（包含导入）如下所示：'
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Follow this by exporting a new function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后导出一个新的函数：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First of all, we receive the `req` (request details) and `res` (object that
    represents the HTTP response) variables into the arrow functions. Based on the
    information provided by `req`, we get the header details (`let { token, role,
    username } = req.headers;`). Next, we have `userDetailsToHash` and then we check
    what will be the correct `authToken` with `let authSignToken = jwt.sign(userDetailsToHash,
    jwtSecret.secret)`. Afterward, we check whether the user is authorized with `let
    isAuthorized = authSign === token`. Then we create a `sessionObject`, which will
    be reused across all the Falcor routes later (`let sessionObject = {isAuthorized,
    role, username};`).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`req`（请求详情）和`res`（代表HTTP响应的对象）变量接收进箭头函数中。根据`req`提供的信息，我们获取头部详细信息（`let
    { token, role, username } = req.headers;`）。接下来，我们有`userDetailsToHash`，然后我们检查正确的`authToken`（`let
    authSignToken = jwt.sign(userDetailsToHash, jwtSecret.secret)`）。之后，我们检查用户是否被授权（`let
    isAuthorized = authSign === token`）。然后我们创建一个`sessionObject`，它将在之后的所有Falcor路由中被重复使用（`let
    sessionObject = {isAuthorized, role, username};`）。
- en: Currently, we have one route (`articles.length`), which was described in [Chapter
    2](part0058.html#1NA0K0-7870c13caa1244daa9bd53ca5c1e1a42), *Full-Stack Login and
    Registration for Our Publishing App* (so there's nothing new so far).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有一个路由（`articles.length`），这在[第2章](part0058.html#1NA0K0-7870c13caa1244daa9bd53ca5c1e1a42)中已有描述，即“我们发布应用的完整栈登录和注册”（所以目前还没有什么新内容）。
- en: As you can see in the previous code, instead of exporting `PublishingAppRoutes`
    directly, we are exporting with the arrow function `export default (req, res)`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们不是直接导出`PublishingAppRoutes`，而是使用箭头函数`export default (req, res)`进行导出。
- en: 'We need to re-add (under `articles.length`) the second route, called `articles[{integers}]["_id","articleTitle","articleContent"]`,
    with the following code in the `server/routes`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`articles.length`下重新添加第二个路由，称为`articles[{integers}]["_id","articleTitle","articleContent"]`，并在`server/routes`中使用以下代码：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is the route that fetches articles from databases and returns `falcor-route`
    for it. It's exactly the same as introduced before; the only different is that
    now it's part of the function (`export default ( req, res ) => { ... }`).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是获取数据库中文章的路由，并返回`falcor-route`的路由。它与之前介绍的是完全相同的；唯一的区别是现在它是函数的一部分（`export default
    ( req, res ) => { ... }`）。
- en: Before we start to implement add/edit/delete on the backend with `falcor-router`,
    we need to introduce ourselves to the concept of sentinels, as it will be very
    important for the well-being of our full-stack application, the reason for which
    will be explained in a moment.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用`falcor-router`在后台实现添加/编辑/删除功能之前，我们需要先了解哨兵的概念，因为它对我们的全栈应用的健康至关重要，原因将在稍后解释。
- en: Falcor's sentinel implementation
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Falcor的哨兵实现
- en: Let's understand what sentinels are. They are required to make Fullstack's Falcor
    application work. It's a set of tools you have to learn.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解什么是哨兵。它们是使Fullstack的Falcor应用工作所必需的。它是一套你必须学习的工具。
- en: 'They are new primitive value types created exclusively for making data transportation
    between the backend and client side much easier and out of the box (examples of
    new Falcor primitive values are `$error` and `$ref`). Here''s an analogy: you
    have types in a regular JSON such as string, number, and object and. On the other
    hand, in Falcor''s virtual JSON, you can additionally use sentinels such as `$error`,
    `$ref`, or `$atom` alongside the standard JSON types listed previously.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是新原始值类型，专门用于使后端和客户端之间的数据传输更加容易和直接（新Falcor原始值示例包括`$error`和`$ref`）。这里有一个类比：你有一个常规JSON中的类型，如字符串、数字和对象，另一方面，在Falcor的虚拟JSON中，你可以使用与之前列出的标准JSON类型并行的哨兵，如`$error`、`$ref`或`$atom`。
- en: Additional information about sentinels is available at [https://netflix.github.io/falcor/documentation/model.html#sentinel-metadata](https://netflix.github.io/falcor/documentation/model.html#sentinel-metadata).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 关于哨兵的更多信息可在[https://netflix.github.io/falcor/documentation/model.html#sentinel-metadata](https://netflix.github.io/falcor/documentation/model.html#sentinel-metadata)找到。
- en: At this stage, it's important to understand how Falcor's sentinels are working.
    The different types of sentinel in Falcor are explained in the following sections.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，理解Falcor的哨兵是如何工作的是非常重要的。Falcor中不同类型的哨兵将在以下章节中解释。
- en: The $ref sentinel
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`$ref`哨兵'
- en: According to the documentation, "a reference is a JSON object with a `$type`
    key that has a value of `ref` and a `value` key that has a `Path` array as its
    value."
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文档，“一个引用是一个具有`$type`键且其值为`ref`，以及一个`value`键且其值为`Path`数组对象的JSON对象。”
- en: '"A reference is like a symbolic link in the UNIX filesystem," as the documentation
    states, and this comparison is very good.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: “一个引用就像UNIX文件系统中的符号链接，”正如文档所述，这个比较非常恰当。
- en: 'An example of `$ref` is as a follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ref`的一个例子如下：'
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you use `$ref(['articlesById','STRING_ARTCILE_ID_HERE'])`, it's equal to
    the preceding example. The `$ref` sentinel is a function that changes the array's
    details into that `$type` and value's notation object.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`$ref(['articlesById','STRING_ARTCILE_ID_HERE'])`，它与前面的例子是等价的。`$ref`哨兵是一个函数，它将数组的详细信息转换为那种`$type`和值的表示对象。
- en: You can find both approaches in order to deploy/use `$ref` in any Falcor-related
    project, but in our project, we will stick to the `$ref(['articlesById','STRING_ARTCILE_ID_HERE'])`
    convention.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何与Falcor相关的项目中找到部署/使用`$ref`的两种方法，但在我们的项目中，我们将坚持使用`$ref(['articlesById','STRING_ARTCILE_ID_HERE'])`约定。
- en: 'Just to make it clear, this is how to import a `$ref` sentinel in our codebase:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确起见，这是在我们的代码库中导入`$ref`哨兵的方法：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After you import `falcor-json-graph`, you can use the `$ref` sentinel. You
    will already have installed the `falcor-json-graph` library as the installation
    has been described in the previous chapter; if not, use this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在你导入 `falcor-json-graph` 之后，你可以使用 `$ref` 监视器。你已经在上一章中描述了安装过程，已经安装了 `falcor-json-graph`
    库；如果没有，请使用以下内容：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: But what does `articlesById` mean in that whole `$ref` gig? And what does `STRING_ARTICLE_ID_HERE`
    mean in the preceding example? Let's look at an example from our project that
    might make it clearer for you.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 但在那个 `$ref` 大事件中，“`articlesById`”是什么意思？在先前的例子中，“`STRING_ARTICLE_ID_HERE`”又是什么意思？让我们看看我们项目中的一个例子，可能会让你更清楚。
- en: Detailed example of the $ref sentinel
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`$ref` 监视器的详细示例'
- en: 'Let''s assume that we have two articles in our MongoDB instance:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在 MongoDB 实例中有两篇文章：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'So based on our array''s example with mocked articles (IDs `987654` and `123456`),
    the `$ref` will look as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基于我们的带有模拟文章（ID `987654` 和 `123456`）的数组示例，`$ref` 将如下所示：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'An even more detailed answer is this one:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细的答案如下：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: An important thing to note is that `articlesById` is a new route that hasn't
    been created yet (we will do so in a moment).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要事项是，“`articlesById`”是一个尚未创建的新路由（我们将在下一刻这样做）。
- en: But why do we need those `$ref` in our articles?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么在我们的文章中需要那些 `$ref` 呢？
- en: In general, you can keep a reference (like a symbolic link in Unix) in many
    places to one object in the database. In our case, it's an article with a certain`_id`
    in the article's collection.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以在数据库中的许多地方保留对一个对象的引用（就像 Unix 中的符号链接一样）。在我们的例子中，它是一个在文章集合中具有特定 `_id` 的文章。
- en: When do `$ref` sentinels come in handy? Imagine that in our publishing app's
    model, we add a *recently visited* articles feature and provide the ability to
    like an article (like on Facebook).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 何时使用 `$ref` 监视器会很有用？想象一下，在我们的发布应用模型中，我们添加了一个“**最近访问的文章**”功能，并提供了喜欢文章的能力（就像在
    Facebook 上一样）。
- en: 'Based on these two new features, our new model will look as follows (this is
    just an example; don''t code it):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这两个新功能，我们的新模型将如下所示（这只是一个例子；不要编写代码）：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Based on our preceding example's model, if someone likes an article with ID
    `123456`, we will need to update the model in two places. That's exactly where
    `$ref` comes in handy.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们先前示例中的模型，如果有人喜欢了 ID 为 `123456` 的文章，我们将在模型中需要更新两个地方。这正是 `$ref` 发挥作用的地方。
- en: Improving our articles' numberOfLikes with $ref
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `$ref` 改善我们的文章的 `numberOfLikes`
- en: 'Let''s improve our example to the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进我们的例子到以下内容：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In our new improved `$ref` example, you can find the notation where you need
    to tell Falcor the ID of the article you want to have in `articles` or `recentlyVisitedArticles`.
    Falcor on its own will follow the `$ref` sentinel, knowing the route name (the
    `articlesById` route in this case) and ID of the object we are looking for (in
    our example, `123456` or `987654`). We will use it in practice in a moment.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们改进的 `$ref` 示例中，你可以找到需要告诉 Falcor 你想在 `articles` 或 `recentlyVisitedArticles`
    中包含的文章 ID 的标记。Falcor 将会根据路由名称（在这种情况下是 `articlesById` 路由）和我们要查找的对象的 ID（在我们的例子中是
    `123456` 或 `987654`）来跟随 `$ref` 监视器。我们将在稍后将其用于实践。
- en: Understand that this is a simplified version of how it works, but the best analogy
    to use in order to understand `$ref` is UNIX's symbolic links.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这是它工作原理的简化版本，但要理解 `$ref` 的最佳类比是 UNIX 的符号链接。
- en: Practical use of $ref in our project
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的项目中 `$ref` 的实际应用
- en: Okay, that was a lot of theory--let's start coding! We will improve our Mongoose
    model.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，理论讲得够多了——让我们开始编码！我们将改进我们的 Mongoose 模型。
- en: 'Then we''ll add the `$ref` sentinels described before into the `server/routes.js`
    file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将之前描述的 `$ref` 监视器添加到 `server/routes.js` 文件中：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We will also add two Falcor routes, `articlesById` and `articles.add`. On the
    frontend, we will make some improvements to `src/layouts/PublishingApp.js` and
    `src/views/articles/AddArticleView.js`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加两个 Falcor 路由，“`articlesById`”和“`articles.add`”。在前端，我们将对 `src/layouts/PublishingApp.js`
    和 `src/views/articles/AddArticleView.js` 进行一些改进。
- en: Let's start the fun.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Mongoose config improvements
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mongoose 配置改进
- en: 'First thing we will do is open the Mongoose model at `server/configMongoose.js`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的事情是打开 `server/configMongoose.js` 中的 Mongoose 模型：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''ll improve it to this version:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将改进到这个版本：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code, you''ll find we import `new const Schema = mongoose.Schema`.
    Later, we improve our `articleSchema` with `articleContentJSON: Object`. This
    is required, because the state of draft-js will be kept in a JSON object. This
    will be useful if a user creates an article, saves it to the database, and later
    would like to edit the article. In such a case, we''ll use this `articleContentJSON`
    in order to restore the content state of the draft-js editor.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中，你会发现我们导入了`new const Schema = mongoose.Schema`。后来，我们通过添加`articleContentJSON:
    Object`来改进我们的`articleSchema`。这是必需的，因为draft-js的状态将保存在一个JSON对象中。如果用户创建一篇文章，将其保存到数据库中，然后稍后想编辑这篇文章，这将非常有用。在这种情况下，我们将使用这个`articleContentJSON`来恢复draft-js编辑器的状态。'
- en: 'The second thing is providing options with `{ minimize: false }`. This is required
    because by default Mongoose gets rid of all empty objects, such as `{ emptyObject:
    {}, nonEmptyObject: { test: true } }`, so if `minimize: false` isn''t set up then
    we would get incomplete objects in our database (it''s a very important step to
    have this flag here). There are some draft-js objects that are required, but by
    default are empty (specifically the `entityMap` property of a draft-js object).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '第二件事是提供带有`{ minimize: false }`的选项。这是必需的，因为默认情况下Mongoose会移除所有空对象，例如`{ emptyObject:
    {}, nonEmptyObject: { test: true } }`，所以如果不设置`minimize: false`，那么我们数据库中就会得到不完整的对象（这是一个非常重要的步骤，这里要有这个标志）。'
- en: The server/routes.js improvements
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器`routes.js`的改进
- en: 'In the `server/routes.js` file, we need to start using the `$ref` sentinel.
    Your import in that file should look as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server/routes.js`文件中，我们需要开始使用`$ref`哨兵。该文件中的导入应如下所示：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We have added the `$ref` sentinel in our `routes.js` scope. We need to prepare
    a new route, `articlesById[{keys}]["_id","articleTitle","articleContent","articleContentJSON"]`,
    as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`routes.js`作用域中添加了`$ref`哨兵。我们需要准备一个新的路由，`articlesById[{keys}]["_id","articleTitle","articleContent","articleContentJSON"]`，如下所示：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `articlesById[{keys}]` route is defined, and the keys are the IDs of the
    request URL that we need to return in the request, as you can see with `const
    articlesIDs = pathSet[1];`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`articlesById[{keys}]`路由已定义，键是请求URL中我们需要返回的ID，正如您通过`const articlesIDs = pathSet[1];`所看到的那样。'
- en: 'To be more specific regarding `pathSet`, check out this example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要更具体地了解`pathSet`，请查看以下示例：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this case, the `falcor-router` will follow `articlesById`, and in the `pathSet`,
    you will get this (you can see the exact value of the `pathSet`):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`falcor-router`将跟随`articlesById`，在`pathSet`中，您将得到以下内容（您可以看到`pathSet`的确切值）：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The value of the `articlesIDs` from `const articlesIDs = pathSet[1]``;` you
    can find here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`const articlesIDs = pathSet[1]``;`中找到`articlesIDs`的值：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you will find later, we use this `articlesIDs` value next:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您稍后会发现，我们使用这个`articlesIDs`值：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As you can see in `''_id'': { $in: articlesIDs}`, we are passing an array of
    `articlesIDs`. Based on those IDs, we will receive an array of certain articles
    found by IDs (the SQL `WHERE` equivalent). The next step here is iterating over
    received articles:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '如您在`''_id'': { $in: articlesIDs}`中看到的那样，我们正在传递一个`articlesIDs`数组。基于这些ID，我们将接收到一个根据ID找到的特定文章数组（相当于SQL的`WHERE`语句）。接下来的步骤是遍历接收到的文章：'
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Push the object into the `results` array:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象推入`results`数组：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Almost nothing is new in the preceding code snippet. The only new thing is
    this statement:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段中几乎没有新内容。唯一的新内容是这一句：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We are explicitly using the `$atom` sentinel from Falcor here: `$atom(articleResObj.articleContentJSON);`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里明确使用了Falcor的`$atom`哨兵：`$atom(articleResObj.articleContentJSON);`。
- en: JSON Graph atoms
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON图原子
- en: The `$atom` sentinel is metadata attached to values, which has to be handled
    differently by the model. You can very simply return a value of a number type
    or a value of a string type with Falcor. It's more tricky for Falcor to return
    an object. Why?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`$atom`哨兵是附加到值上的元数据，模型必须以不同的方式处理。您可以用Falcor简单地返回数字类型的值或字符串类型的值。为什么返回对象会更复杂？'
- en: Falcor is diffing with heavy usage of JavaScript's objects and arrays, and when
    we tell that an object/array is wrapped by an `$atom` sentinel (such as `$atom(articleResObj.articleContentJSON`)
    in our example), then Falcor knows that it shouldn't go deeper into that array/object.
    It's made that way by design for performance reasons.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Falcor通过大量使用JavaScript的对象和数组进行diff操作，当我们告诉一个对象/数组被`$atom`哨兵（例如，在我们的例子中是`$atom(articleResObj.articleContentJSON)`）包装时，Falcor就知道它不应该深入到那个数组/对象中。这是出于性能考虑而设计成这样的。
- en: 'What performance reasons? For example, if you return an array of 10,000 very
    deep objects without wrapping the array, it may take a very, very long time to
    build and diff the model. Generally, for performance reasons, any objects and
    arrays that you want to return via `falcor-router` to the frontend have to be
    wrapped by an `$atom` before doing so; otherwise, you will get an error like this
    (if you don''t wrap by `$atom` this object):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要考虑性能原因？例如，如果您返回一个未包装的包含10,000个非常深层对象的数组，构建和diff模型可能需要非常长的时间。通常，出于性能考虑，您想要通过`falcor-router`返回到前端的对象和数组必须在这样做之前被`$atom`包装；否则，您将得到这样的错误（如果您没有通过`$atom`包装此对象）：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This error will be shown on the client side while Falcor tries to fetch those
    deeper objects without being wrapped by an `$atom` sentinel beforehand on the
    backend.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当Falcor试图在未在后台事先用`$atom`哨兵包装的情况下获取那些深层对象时，这个错误将在客户端显示。
- en: Improving the articles[{integers}] route
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进`articles[{integers}]`路由
- en: 'We now need to return a `$ref` sentinel to `articlesById` instead of all of
    the articles'' details, so we need to change this old code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要返回一个`$ref`哨兵到`articlesById`而不是所有文章的详细信息，因此我们需要更改以下旧代码：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We''ll improve that to this new code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将改进到以下新代码：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'What has been changed? Look at the route in the old codebase: `articles[{integers}]["_id","articleTitle","articleContent"]`.
    Currently, our `articles[{integers}]` route doesn''t directly return (in the new
    version) the `for["_id","articleTitle","articleContent"]` data, so we had to delete
    it in order to get Falcor know about this fact (the `articlesById` is returning
    detailed information now).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么变化？看看旧代码库中的路由：`articles[{integers}]["_id","articleTitle","articleContent"]`。目前，我们的`articles[{integers}]`路由（在新版本中）并没有直接返回`for["_id","articleTitle","articleContent"]`数据，因此我们必须删除它，以便让Falcor知道这个事实（`articlesById`现在返回详细的信息）。
- en: 'The next thing that has been changed is that we create a new `$ref` sentinel
    with the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个变化是，我们创建了一个新的`$ref`哨兵，如下所示：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you see, by doing this, we are informing (with `$ref`) `falcor-router` that
    if the frontend requests any more information about `article[{integers}]`, then
    the `falcor-router` should follow the `articlesById` route in order to retrieve
    that data from the database.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过这样做，我们通过`$ref`通知`falcor-router`，如果前端请求关于`article[{integers}]`的更多信息，那么`falcor-router`应该遵循`articlesById`路由以从数据库检索该数据。
- en: 'After this, look at this old path''s value:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，看看这个旧路径的值：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You''ll find that it has been replaced by the value of `articleRef`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现它已经被`articleRef`的值所替换：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can probably spot, in the old version we were returning all of the information
    about an article (the `singleArticleObject` variable), but in the new version
    we return only the `$ref` sentinel`(articleRef)`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已注意到，在旧版本中，我们返回了关于一篇文章的所有信息（`singleArticleObject`变量），但在新版本中，我们只返回`$ref`哨兵（`articleRef`）。
- en: The `$ref` sentinels make `falcor-router` automatically follow on the backend,
    so if there are any refs in the first route, Falcor resolves all the `$ref` sentinels
    until it gets all the pending data; after that, it returns the data in a single
    request, which saves a lot of latency (instead of performing several HTTP requests,
    everything followed with `$refs` is fetched in one browser-to-backend call).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ref`哨兵使`falcor-router`在后台自动跟随，所以如果第一个路由中有任何引用，Falcor将解析所有的`$ref`哨兵，直到获取所有挂起的数据；之后，它将数据在一个请求中返回，这大大减少了延迟（而不是执行多个HTTP请求，所有跟随`$refs`的内容都在一个浏览器到后端的调用中获取）。'
- en: 'New route in server/routes.js: articles.add'
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '服务器路由中的新路由：`server/routes.js: articles.add`'
- en: 'The only thing left that we need to do is add into the router a new `articles.add`
    route:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一需要做的事情是将一个新的`articles.add`路由添加到路由器中：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As you can see here, we receive from the frontend a new article''s details
    with `const newArticleObj = args[0];`, and later we create a new `Article` model
    with `var article = new Article(newArticleObj);`. After that, the `article` variable
    has a `.save` method, which is called in the following query. We perform two queries
    that return a promise from Mongoose. Here''s the first:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在此处所见，我们从前端接收到一个新文章的详细信息，使用`const newArticleObj = args[0];`，然后我们使用`var article
    = new Article(newArticleObj);`创建一个新的`Article`模型。之后，`article`变量有一个`.save`方法，在接下来的查询中会被调用。我们执行了两个查询，这两个查询都从Mongoose返回一个promise。以下是第一个查询：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This `.save` method simply helps us insert the document into the database.
    After we have saved the article, we need to count how many there are in our database,
    so we run a second query:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `.save` 方法只是帮助我们将文档插入数据库。在保存文章后，我们需要计算数据库中有多少文章，因此我们运行第二个查询：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After we have saved the article and counted it, we return that information
    (`return { count, data };`). The last thing is to return the new article ID and
    the count number from the backend to the frontend with the help of `falcor-router`,
    so we replace this comment:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存文章并计数后，我们返回该信息（`return { count, data };`）。最后，我们需要使用 `falcor-router` 将新的文章ID和计数数量从后端返回到前端，所以我们替换此注释：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In its place, we''ll have this new code that helps us make things happen:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在其位置，我们将有这段新的代码，帮助我们实现所需的功能：
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the `results` variable, you can find three new paths:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `results` 变量中，您可以找到三个新的路径：
- en: '`path: [''articles'', res.count-1]`: This path builds up the model, so we can
    have all the information in the Falcor model after we receive the response on
    the client side'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path: [''articles'', res.count-1]`：此路径构建模型，因此我们可以在客户端收到响应后，在Falcor模型中拥有所有信息。'
- en: '`path: [''articles'', ''newArticleID'']`: This helps us quickly fetch the new
    ID on the frontend'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path: [''articles'', ''newArticleID'']`：这有助于我们在前端快速获取新的ID。'
- en: '`path: [''articles'', ''length'']`: This, of course, updates the length of
    our articles'' collections, so the frontend''s Falcor model can have up-to-date
    information after we have added a new article'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path: [''articles'', ''length'']`：当然，这会更新我们文章集合的长度，因此前端Falcor模型在添加新文章后可以拥有最新的信息。'
- en: We just have made a backend route for adding an article. Let's now start working
    on the frontend so that we will be able to push all our new articles into the
    database.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚为添加文章创建了一个后端路由。现在让我们开始处理前端，以便我们将所有新文章推入数据库。
- en: Frontend changes in order to add articles
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为了添加文章而进行的客户端更改
- en: 'In the `src/layouts/PublishingApp.js` file, find this code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/layouts/PublishingApp.js` 文件中，找到此代码：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Change it to an improved version with `articleContentJSON`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 改进为带有 `articleContentJSON` 的改进版本：
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The next step is to improve our `_submitArticle` function in `src/views/articles/AddArticleView.js`
    and add a `falcorModel` import:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是改进 `src/views/articles/AddArticleView.js` 中的 `_submitArticle` 函数，并添加 `falcorModel`
    导入：
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Replace this code with the following improved version:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下改进版本替换此代码：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Also, at the top of the `AddArticleView.js` file, add this import; otherwise,
    `async_articleSumbit` won''t work:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 `AddArticleView.js` 文件顶部，添加此导入；否则，`async_articleSumbit` 不会工作：
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As you can see, we have added the `async` keyword before the function name
    (`async _articleSubmit()`). The new thing is this request:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在函数名（`async _articleSubmit()`）之前添加了 `async` 关键字。新的是这个请求：
- en: '[PRE47]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here, we wait for `falcorModel.call`. In the `.call` arguments, we add `newArticle`.
    Then, after the promise is resolved, we check what the `newArticleID` is with
    the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们等待 `falcorModel.call`。在 `.call` 参数中，我们添加 `newArticle`。然后，在承诺解决之后，我们通过以下方式检查
    `newArticleID`：
- en: '[PRE48]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Later, we simply use exactly the same stuff as in the old version:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们简单地使用与旧版本完全相同的内容：
- en: '[PRE49]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This simply pushes the updated `newArticle` with a real ID from MongoDB via
    the `articleActions` into the article's reducer. We also use `setState` with the
    `newArticleID` so you can see that the new article has been created correctly
    with a real Mongo ID.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是通过 `articleActions` 将带有真实MongoDB ID的更新后的 `newArticle` 推送到文章的reducer。我们还使用
    `setState` 与 `newArticleID`，这样您就可以看到新文章已经正确地使用真实的Mongo ID创建。
- en: Important note about route returns
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于路由返回的重要注意事项
- en: 'You should be aware that in every route, we return an object or an array of
    an object; both approaches are fine even with one route to return. Take this,
    for example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该知道，在每条路由中，我们返回一个对象或一个对象数组；即使只有一条路由返回，这两种方法都是可行的。以这个为例：
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This can also return an array with one object, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以返回一个包含一个对象的数组，如下所示：
- en: '[PRE51]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As you can see, even with one `articles.length`, we are returning an array (instead
    of a single object), and this will also work.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，即使只有一个 `articles.length`，我们也是返回一个数组（而不是单个对象），这同样有效。
- en: 'For the same reason as described previously, this is why, in `articlesById`,
    we have pushed multiple routes into the array:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前描述的原因相同，这就是为什么在 `articlesById` 中，我们将多个路由推入数组的原因：
- en: '[PRE52]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This is one thing that may be worth mentioning in the Falcor chapter.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Falcor章节中可能值得提及的一点。
- en: Full-stack - editing and deleting an article
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全栈 - 编辑和删除文章
- en: 'Let''s create a route in the `server/routes.js` file for updating an existing
    document (edit feature):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`server/routes.js`文件中创建一个用于更新现有文档的路由（编辑功能）：
- en: '[PRE53]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As you can see here, we still use the `article.save` approach similar to the
    `articles.add` route. The important thing to note is that Mongoose requires the
    `isNew` flag to be `false` (`article.isNew = false;`). If you don''t give this
    flag, then you will get a Mongoose error similar to this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们仍然使用与`articles.add`路由类似的`article.save`方法。需要注意的是，Mongoose 需要设置`isNew`标志为`false`（`article.isNew
    = false;`）。如果您不提供此标志，那么您将得到类似于以下的 Mongoose 错误：
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The rest of the code is quite simple; we save the article''s model and then
    return the updated model via `falcor-router` with the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分相当简单；我们保存文章的模型，然后通过`falcor-router`返回更新后的模型，具体如下：
- en: '[PRE55]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The new thing is the `invalidate` flag. As it states in the documentation, "invalidate
    method synchronously removes several Paths or PathSets from a Model cache." In
    other words, you need to tell the Falcor model on the frontend that something
    has been changed in the `["articlesById", articleID]` path so that you will have
    synced data on both backend and frontend.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 新的是`invalidate`标志。正如文档中所述，“`invalidate`方法同步地从模型缓存中删除多个路径或路径集。”换句话说，您需要告诉前端上的
    Falcor 模型在`["articlesById", articleID]`路径上已经发生了变化，这样您就可以在前后端都有同步的数据。
- en: For more stuff about `invalidate` in Falcor, you can go to [https://netflix.github.io/falcor/doc/Model.html#invalidate](https://netflix.github.io/falcor/doc/Model.html#invalidate).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Falcor 中`invalidate`的更多信息，您可以访问[https://netflix.github.io/falcor/doc/Model.html#invalidate](https://netflix.github.io/falcor/doc/Model.html#invalidate)。
- en: Deleting an article
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除文章
- en: 'In order to implement the `delete` feature, we need to create a new route:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现`删除`功能，我们需要创建一个新的路由：
- en: '[PRE56]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This also uses `invalidate`, but this time, this is the only thing that we return
    here, as the document has been deleted, so the only thing we need to do is to
    inform the browser's cache that the old article has been invalidated and there
    is nothing to replace it as in the update example.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这也使用了`invalidate`，但这次，这是我们在这里返回的唯一东西，因为文档已经被删除，所以我们唯一需要做的是通知浏览器缓存，旧文章已被失效，没有东西可以替换，就像更新示例中那样。
- en: Frontend - edit and delete
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端 - 编辑和删除
- en: 'We have implemented the `update` and `delete` routes on the backend. Next,
    in the `src/views/articles/EditArticleView.js` file, you need to find this code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在后端实现了`更新`和`删除`路由。接下来，在`src/views/articles/EditArticleView.js`文件中，您需要找到以下代码：
- en: '[PRE57]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Replace it with this `async _articleEditSubmit` function:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个`async _articleEditSubmit`函数替换它：
- en: '[PRE58]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see here, the most important thing is that we implemented the `.call`
    function in the `_articleEditSubmit` function that sends details of an edited
    object with the `editedArticle` variable.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，最重要的是我们在`_articleEditSubmit`函数中实现了`.call`函数，该函数使用`editedArticle`变量发送编辑对象的详细信息。
- en: 'In the same file, find the `_handleDeletion` method:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件中，找到`_handleDeletion`方法：
- en: '[PRE59]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Change it to the new improved version:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 更改为新的改进版本：
- en: '[PRE60]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Similar to the deletion, the only difference is that we only send `articleID`
    of a deleted article with `.call`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 与删除类似，唯一的区别是我们只通过`.call`发送被删除文章的`articleID`。
- en: Securing the CRUD routes
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护 CRUD 路由
- en: 'We need to implement a way to secure all add/edit/delete routes and also make
    a universal **DRY** (**don''t repeat yourself**) way of informing the user of
    errors that occurred on the backend. For example, errors that may occur on the
    frontend, and we need to inform the user with an error message in our React instance''s
    client-side app:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现一种方法来保护所有添加/编辑/删除路由，并创建一个通用的**DRY**（不要重复自己）方式来通知用户后端发生的错误。例如，前端可能发生的错误，我们需要在我们的
    React 实例的客户端应用程序中用错误消息通知用户：
- en: '**Auth error**: You are not authorized to perform the action'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证错误**：您没有权限执行此操作'
- en: '**Timeout error**: For example, you use an external API''s service; we need
    to inform the user of any potential errors'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超时错误**：例如，您使用外部 API 的服务；我们需要通知用户任何潜在的错误'
- en: '**Data doesn''t exist**: There may be a case where a user will call for the
    ID of an article that doesn''t exist in our DB, so let''s inform him'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据不存在**：可能存在用户调用不存在于我们数据库中的文章 ID 的情况，所以让我们通知他'
- en: In general, our goal for now is to create one universal way of moving all potential
    error messages on the backend to the client side so that we can improve the general
    experience of using our application.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们现在的目标是创建一种通用的方法，将所有潜在的错误消息从后端移动到客户端，以便我们可以改善我们应用程序的使用体验。
- en: The $error sentinel basics
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: $error哨兵基础
- en: There is the `$error` sentinel (variable type related to Falcor), which is generally
    an approach to returning errors.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`$error`哨兵（与Falcor相关的变量类型），它通常是一种返回错误的方法。
- en: 'Generally, as you should already know, Falcor batches requests. Thanks to them,
    you can fetch data from different falcor-routes in one HTTP request. The following
    example is what you can fetch in one go:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，正如你应该已经知道的，Falcor会批量处理请求。多亏了它们，你可以在一个HTTP请求中获取来自不同的falcor-routes的数据。以下是一个你可以一次性获取的示例：
- en: '**One dataset**: Complete and ready to retrieve'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个数据集**：完整且准备就绪，可以检索'
- en: '**Second dataset**: Second dataset, may contain an error'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二个数据集**：第二个数据集，可能包含错误'
- en: We don't want to influence the fetching process of one dataset when there is
    an error in the second dataset (you need to remember that the two datasets from
    our example are fetched in one request).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当第二个数据集出现错误时，我们不想影响一个数据集的获取过程（你需要记住，我们示例中的两个数据集是在一个请求中获取的）。
- en: 'Useful parts from the documentation that may help you understand error handling
    in Falcor are available here:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有用的文档部分，可能有助于你理解Falcor中的错误处理：
- en: '[https://netflix.github.io/falcor/doc/Model.html#~errorSelector](https://netflix.github.io/falcor/doc/Model.html#~errorSelector)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://netflix.github.io/falcor/doc/Model.html#~errorSelector](https://netflix.github.io/falcor/doc/Model.html#~errorSelector)'
- en: '[https://netflix.github.io/falcor/documentation/model.html#error-handling](https://netflix.github.io/falcor/documentation/model.html#error-handling)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://netflix.github.io/falcor/documentation/model.html#error-handling](https://netflix.github.io/falcor/documentation/model.html#error-handling)'
- en: '[http://netflix.github.io/falcor/documentation/router.html](http://netflix.github.io/falcor/documentation/router.html)
    (search for `$error` on this page to find more examples from the documentation)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://netflix.github.io/falcor/documentation/router.html](http://netflix.github.io/falcor/documentation/router.html)（在此页面上搜索“$error”以找到更多文档中的示例）'
- en: DRY error management on the client side
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端DRY错误管理
- en: 'Let''s start with improvements to the CoreLayout (`src/layouts/CoreLayout.js`).
    Under `AppBar`, import a new `snackbar` component with this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从对CoreLayout（`src/layouts/CoreLayout.js`）的改进开始。在`AppBar`下，使用以下内容导入一个新的`snackbar`组件：
- en: '[PRE61]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, under the imports, outside the CoreLayout, create a new function and
    export it:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在导入部分，在CoreLayout外部创建一个新的函数并导出它：
- en: '[PRE62]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then find the `CoreLayout` constructor to change it to use the exported function
    called `errorFuncUtil` as a callback in the base in case of an error returned
    by the Falcor `$error` sentinel:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然后找到`CoreLayout`构造函数，将其更改为在Falcor `$error`哨兵返回错误时使用导出的函数`errorFuncUtil`作为回调：
- en: '[PRE63]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here''s the new one:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是新的函数：
- en: '[PRE64]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As you can find here, we have introduced a new `errorValue` state (the default
    state is `null`). Then, on the frontend only (because of `if(typeof window !==
    'undefined')`), we assign `this.handleErrors.bind(this)` to our `errorFuncUtil`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以在这里找到的，我们引入了一个新的`errorValue`状态（默认状态是`null`）。然后，仅在前端（因为`if(typeof window
    !== 'undefined')`），我们将`this.handleErrors.bind(this)`分配给我们的`errorFuncUtil`。
- en: As you will find in a moment, this is so because the exported `errorFuncUtil`
    will be imported in our `falcorModel.js`, where we will use the best possible
    DRY way to inform our CoreLayout about any error occurring on the backend with
    Falcor. The great thing about this is that we will implement it just once, but
    it will be a universal way of informing our client-side app users of any errors
    (and it will also save us development effort in the future, as any error will
    be handled by the approach that we are implementing now).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你很快就会发现的，这是因为导出的`errorFuncUtil`将被导入到我们的`falcorModel.js`中，在那里我们将使用最佳可能的DRY方式通知CoreLayout关于Falcor后端发生的任何错误。这件事的好处是，我们只需实现一次，但它将成为通知我们客户端应用程序用户任何错误的一种通用方式（这也会在未来节省我们的开发工作量，因为任何错误都将通过我们现在正在实施的方法来处理）。
- en: 'We need to add a new function to our CoreLayout called `handleFalcorErrors`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在CoreLayout中添加一个新的函数，称为`handleFalcorErrors`：
- en: '[PRE65]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `handleFalcorErrors` function is setting the new state of our error. We
    will compose our error for the user with an `errMsg` (we create this on the backend,
    as you will learn in a moment) and the `errPath` (optional, but this is the `falcor-route`
    path where the error has occurred).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleFalcorErrors`函数正在设置我们的错误的新状态。我们将使用`errMsg`（我们在后端创建，你很快就会学到）和`errPath`（可选，但这是错误发生的`falcor-route`路径）来组合用户错误。'
- en: 'Okay, we have everything in place; the only thing missing from the `CoreLayout`
    function is the improved render. The new render of the CoreLayout is as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经把所有东西都准备好了；从`CoreLayout`函数中缺失的只有改进后的渲染。CoreLayout的新渲染如下：
- en: '[PRE66]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'As you can find here, the new parts are related to the Material-UI `snackbar`
    component. Take a look at this:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以在这里找到的，新部分与Material-UI的`snackbar`组件相关。看看这个：
- en: '[PRE67]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Make sure `{errorSnackbarJSX}` is placed exactly the same way as in this example.
     Otherwise, you may find some problems during the app's test run. You now have
    completed everything related to the CoreLayout improvements.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`{errorSnackbarJSX}`放置与此示例完全相同的位置。否则，你可能会在应用测试运行期间遇到一些问题。你现在已经完成了与CoreLayout改进相关的一切。
- en: Tweaks - FalcorModel.js on the frontend
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整 - 前端FalcorModel.js
- en: 'In the `src/falcorModel.js` file, identify the following code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/falcorModel.js`文件中，识别以下代码：
- en: '[PRE69]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This code has to be improved by adding a new option to the `falcor.Model`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码需要通过向`falcor.Model`添加一个新选项来改进：
- en: '[PRE70]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The first thing we added is an import of `errorFunc` to the top of that file:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加的是将`errorFunc`导入到该文件顶部的操作：
- en: '[PRE71]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Besides `errorFunc`, we have introduced the `falcorOptions` variable. The source
    stays the same as in the previous version. We have added `errorSelector`, which
    is run every time the client side calls the backend and the `falcor-router` on
    the backend returns an `$error` sentinel.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`errorFunc`之外，我们还引入了`falcorOptions`变量。源代码与上一个版本相同。我们添加了`errorSelector`，它在客户端每次调用后端和后端的`falcor-router`返回一个`$error`哨兵时都会运行。
- en: More details on the error selector can be found at [https://netflix.github.io/falcor/documentation/model.html#the-errorselector-value](https://netflix.github.io/falcor/documentation/model.html#the-errorselector-value).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 关于错误选择器的更多详细信息可以在[https://netflix.github.io/falcor/documentation/model.html#the-errorselector-value](https://netflix.github.io/falcor/documentation/model.html#the-errorselector-value)找到。
- en: Backend implementation of the $error sentinel
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: $error哨兵的后端实现
- en: 'We will perform the backend implementation in two steps:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分两步进行后端实现：
- en: An error example, just to test our client-side code.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个错误示例，仅用于测试我们的客户端代码。
- en: After we are sure that the error handling is working correctly, we will secure
    the endpoints properly.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们确认错误处理正确无误后，我们将正确地保护端点。
- en: Testing our $error-related code
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的与错误相关的代码
- en: 'Let''s start with imports in the `server/routes.js` file:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`server/routes.js`文件中的导入开始：
- en: '[PRE72]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The only new thing is that you need to import the `$error` sentinel from `falcor-json-graph`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的新事物是，你需要从`falcor-json-graph`导入`$error`哨兵。
- en: The goal of our `$error` test is to replace a working route that is responsible
    for fetching articles `(articles[{integers}])`. After we break this route, we
    will be able to test whether our frontend and backend setup is working. After
    we test the errors (refer to the next screenshot), we will delete this breaking
    `$error` code from `articles[{integers}]`. Read on for details.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对$错误进行测试的目标是替换一个负责获取文章的（`articles[{integers}]`）工作路由。在我们破坏这个路由后，我们将能够测试我们的前端和后端设置是否正常工作。在测试了错误（参考下一张截图）后，我们将从`articles[{integers}]`中删除这个破坏性的$错误代码。继续阅读以获取详细信息。
- en: 'Test it with the `article` route:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`article`路由进行测试：
- en: '[PRE73]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As you can see, this is only a test. We will improve this code in a moment,
    but let's test whether the text in the `$error('auth error')` sentinel will be
    shown to the user.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这只是一个测试。我们很快就会改进这段代码，但让我们测试一下`$error('auth error')`哨兵中的文本是否会显示给用户。
- en: 'Run MongoDB:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 运行MongoDB：
- en: '[PRE74]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then, run the server in another terminal:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在另一个终端中运行服务器：
- en: '[PRE75]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'After you run both these, point your browser to `http://localhost:3000`, and
    you will see for this error for 8 seconds:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行这两个命令后，将你的浏览器指向`http://localhost:3000`，你将看到这个错误持续8秒钟：
- en: '![](img/00049.jpeg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00049.jpeg)'
- en: 'As you can see, there is white text on a black background in the bottom of
    the window:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，窗口底部有白色文字在黑色背景上：
- en: '![](img/00050.jpeg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00050.jpeg)'
- en: If you run the app, and on the main page you see the error message as on the
    screenshot, then it tells you that you are good!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行了应用，并在主页上看到截图中的错误消息，那么这表明一切正常！
- en: Cleaning up $error after a successful test
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在成功测试后清理$错误
- en: 'After you are sure that the error handling is working for you, you can replace
    the old code:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在你确信错误处理对你有效后，你可以替换旧代码：
- en: '[PRE76]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Change it to the following, without error returning:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 更改为以下内容，不返回错误：
- en: '[PRE77]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Now, the app will start working normally without throwing an error when you
    try to fetch an article from the backend.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你尝试从后端获取文章时，应用程序将正常启动而不会抛出错误。
- en: Wrapping up the routes' security
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成路由的安全包装
- en: 'We''ve already implemented some logic in `server/routes.js` that checks whether
    a user is authorized, with the following:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`server/routes.js`中实现了一些逻辑，用于检查用户是否有权限，具体如下：
- en: '[PRE78]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In this code, you will find that we can create the following logic in the beginning
    of each role that requires authorization and the editor role:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，你会发现我们可以在每个需要授权和编辑角色的角色开始处创建以下逻辑：
- en: '[PRE79]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: As you can see here, this is only an example (don't change it yet; we will implement
    it in a moment), with `path['HERE_GOES_THE_REAL_FALCOR_PATH']`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这只是一个示例（现在不要更改它；我们很快就会实现它），带有`path['HERE_GOES_THE_REAL_FALCOR_PATH']`。
- en: 'First, we check whether a user is authorized at all with `isAuthorized ===
    false`; if not authorized, he will see an error (with the universal error mechanism
    that we just implemented):'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`isAuthorized === false`检查用户是否完全授权；如果没有授权，他将看到一个错误（使用我们刚刚实现的通用错误机制）：
- en: '![](img/00051.jpeg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00051.jpeg)'
- en: 'In future, we may have more roles in our publishing app, so in case someone
    isn''t an editor, then he will see the following in the error:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，我们可能在我们的发布应用程序中有更多角色，所以如果某人不是编辑，那么他将在错误中看到以下内容：
- en: '![](img/00052.jpeg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00052.jpeg)'
- en: What routes to secure
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要保护哪些路由
- en: 'For routes (`server/routes.js`) that require authorization in our application''s
    articles, add the following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要在我们应用程序文章中授权的路由（`server/routes.js`），添加以下内容：
- en: '[PRE80]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here''s the old code:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这是旧代码：
- en: '[PRE81]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The new code with `auth` checks is as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`auth`检查的新代码如下：
- en: '[PRE82]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: As you can find here, we have added two checks with `isAuthorized === false`
    and role `!== 'editor'`. The following routes content will be almost the same
    (just the path changes a little).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里可以看到的，我们添加了两个检查，`isAuthorized === false`和角色`!== 'editor'`。以下路由内容几乎相同（只是路径略有变化）。
- en: 'Here is the `articles` update:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`articles`更新：
- en: '[PRE83]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This is the old code:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这是旧代码：
- en: '[PRE84]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The new code with the `auth` checks is as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`auth`检查的新代码如下：
- en: '[PRE85]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Find this old code:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 找到以下旧代码：
- en: '[PRE86]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Replace it with this new code with the `auth` checks:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 将其替换为以下带有`auth`检查的新代码：
- en: '[PRE87]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Summary
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As you can see, the returns are almost the same--we can lower the code duplication.
    We can make a helper function for them so there will be less code, but you need
    to remember that you need to set a path similar to the one that you request when
    returning an error. For example, if you are on `articles.update`, then you need
    return an error in the article's path (or if you are on `XYZ.update`, then the
    error goes to the `XYZ` path).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，返回值几乎相同--我们可以减少代码重复。我们可以为它们创建一个辅助函数，这样代码会更少，但你需要记住，当你返回错误时，需要设置一个类似于你请求的路径。例如，如果你在`articles.update`上，那么你需要在该文章的路径上返回错误（或者如果你在`XYZ.update`上，错误将转到`XYZ`路径）。
- en: In the next chapter, we will implement AWS S3 in order to have the ability to
    upload articles' cover photos. Besides that, we will generally improve our publishing
    application with new features.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将实现AWS S3，以便能够上传文章的封面照片。除此之外，我们还将通过新功能一般性地改进我们的发布应用程序。
