["```js\n    import type { URL object and get the q search parameter:\n\n    ```", "```js\n\n    ```", "```js\n    const expenses = await db.expense.findMany({  orderBy: {    createdAt: 'desc',  },  where: {    title: {      contains: searchString ? searchString : '',    },  },});\n    ```", "```js\n    import { useNavigation, Outlet, useLoaderData, useParams, Input component:\n\n    ```", "```js\n\n    ```", "```js\n    <h2 className=\"sr-only\">All expenses</h2><Form q search parameter. For this, we set the form method to GET to perform an HTTP GET request.Conveniently, by default, a form submission appends the form data as search parameters to the request URL. We add the `name` attribute to the input field as only named input fields are part of the submission.We still have one problem to solve: since the search form is rendered on a layout parent route, it is visible on several pages. By default, the form submits and navigates to `/dashboard/expenses`. However, we would like the user to remain on their current page.Since we are not targeting a specific `action` function, we can point the form action to the current URL path. This ensures that a form submission does not redirect users away from their current page.\n    ```", "```js\n    import { Form, Outlet, useLoaderData, useLocation, useNavigation, useParams } from '@remix-run/react';\n    ```", "```js\n    const location = useLocation();\n    ```", "```js\n    <Form method=\"GET\" action={location.pathname}>\n    ```", "```js\n    import { Form, Outlet, useLoaderData, useLocation, useNavigation, useParams, q search parameter in the route component:\n\n    ```", "```js\n\n    Note that the `searchParams` object implements the web's `URLSearchParams` interface that we also use in the `loader` function when accessing the URL's `searchParams`.\n    ```", "```js\n    <Input name=\"q\" type=\"search\" label=\"Search by title\" searchQuery by default, even during server-side rendering:\n    ```", "```js\n    import {  Form,  Outlet,  useLoaderData,  useLocation,  useNavigation,  useParams,  useSearchParams,  useSubmit hook lets us submit forms programmatically. You might remember that useFetcher also offers a submit function. Both useSubmit and useFetcher().submit allow us to submit forms programmatically.Fetcher submissions behave like `fetch` requests and do not trigger global transitions in Remix. They don’t affect the global `useNavigation` state or initiate page navigations. The `useSubmit` hook mimics Remix’s `Form` behavior.In our case, we use Remix’s `Form` component for the search and want to retrigger the `/dashboard/expenses` route module’s `loader` function so that the loader data updates. For such cases, we want to use the `useSubmit` hook.\n    ```", "```js\n      const submit = useSubmit();\n    ```", "```js\n    Replace code example with just this line:onChange={(e) => submit(e.target.form)}\n    ```", "```js\n    import { SearchInput component adds debouncing with a 500-millisecond delay. Refer to the implementation in /app/components/forms.tsx.\n    ```", "```js\n    <SearchInput component uses Remix's useSubmit hook to programmatically submit the form that it is embedded in after a timeout once the user finishes typing.\n    ```", "```js\n    import { createCookieSessionStorage helper function builds on top of Remix’s cookie helpers to store session data in a cookie.Refer to the Remix documentation for alternative session helpers. For example, `createMemorySessionStorage` manages session data in the server’s memory; `createSessionStorage` is more generic and allows us to retrieve session data from a custom storage implementation while storing only the session identifier in a cookie.\n    ```", "```js\n    const sessionSecret = process.env.createCookieSessionStorage helper function to create a session storage object. The object contains three functions to help us manage the lifecycle of our user sessions.The `createCookieSessionStorage` function expects a cookie configuration object to set the session cookie’s lifetime (`maxAge`), its access rules (`secure`, `sameSite`, `path`, and `httpOnly`), and signing secrets (`secrets`). You can refer to the Remix documentation for more information about the configuration options.We set the cookie to expire after 30 days, meaning it will be automatically deleted after that period. By setting `httpOnly` to `true`, we ensure that the cookie cannot be read by the client, enhancing security. We also use secrets to sign the cookie, adding an extra layer of verification.\n    ```", "```js\n    SESSION_SECRET=\"[A secret string]\"\n    ```", "```js\n    export async function createUserSession(user: User, headers = new Headers()) {  const session = await createUserSession to initiate the session cookie after successful registration or login.`createUserSession` expects a user object and an optional `headers` parameter. The function then calls `getSession` to create a new session object for the current user. We add `userId` to the session object and use `commitSession` to parse the object into a cookie value. We set the cookie to the `Headers` object.Note that cookies can only store a small amount of data (a few KB). Hence, we only store `userId`. When storing more data, it might make sense to store the session data in a database and only store a session identifier in the session cookie (for example, using the `createSessionStorage` helper).\n    ```", "```js\n    import { useNavigation } from '@remix-run/react';import { Button } from '~/components/buttons';import { Card } from '~/components/containers';import { Form, Input } from '~/components/forms';import { H1 } from '~/components/headings';export default function Component() {  const navigation = useNavigation();  const isSubmitting = navigation.state !== 'idle' &&    navigation.formAction === '/signup';  return (    <Card>      <Form method=\"POST\" action=\"/signup\">        <H1>Sign Up</H1>        <Input label=\"Name:\" name=\"name\" required />        <Input label=\"Email:\" name=\"email\" type=\"email\" required          />        <Input label=\"Password:\" name=\"password\" type=\"password\"          required />        <Button disabled={isSubmitting} type=\"submit\" isPrimary>          {isSubmitting ? 'Signing you up...' : 'Sign up!'}        </Button>      </Form>    </Card>  );}\n    ```", "```js\n    import type { ActionFunctionArgs } from '@remix-run/node';import { json, redirect } from '@remix-run/node';import { createUserSession, registerUser } from '~/modules/session/session.server';export async function action({ request }: ActionFunctionArgs) {  string. Once the data has been validated, we call the `registerUser` function to create a new user object or throw an error if the user already exists in the database. If the creation is successful, we call `createUserSession` to add the session cookie to the response headers. Otherwise, we return an error response.On success, we redirect the user to the dashboard. On error, we return the error message as action data. Next, let's display the error message to the users.\n    ```", "```js\n    import { useActionData, useNavigation } from '@remix-run/react';\n    ```", "```js\n    const actionData = useActionData<typeof action>();\n    ```", "```js\n    import { InlineError } from '~/components/texts';\n    ```", "```js\n    <InlineError aria-live=\"assertive\">{npm run dev and visiting the /signup page.After form submission, you should be redirected to the dashboard. Great! But what if we want to log out? For now, we can clear the cookie using the developer tools.\n    ```", "```js\n    import { useActionData, useNavigation } from '@remix-run/react';import { Button } from '~/components/buttons';import { Card } from '~/components/containers';import { Form, Input } from '~/components/forms';import { H1 } from '~/components/headings';import { InlineError } from '~/components/texts';export default function Component() {  const navigation = useNavigation();  const isSubmitting = navigation.state !== 'idle' &&    navigation.formAction === '/login';  const actionData = useActionData<typeof action>();  return (    <Card>      <Form method=\"POST\" action=\"/login\">        <H1>Log In</H1>        <Input label=\"Email:\" name=\"email\" type=\"email\" required          />        <Input label=\"Password:\" name=\"password\" type=\"password\"          required />        <Button disabled={isSubmitting} type=\"submit\" isPrimary>          {isSubmitting ? 'Logging you in...' : 'Log in!'}        </Button>        <InlineError aria-live=\"assertive\">{actionData?.error &&          actionData.error}</InlineError>      </Form>    </Card>  );}\n    ```", "```js\n    import type { ActionFunctionArgs } from '@remix-run/node';import { json, redirect } from '@remix-run/node';import { createUserSession, loginUser } from '~/modules/session/session.server';export async function action({ request }: ActionFunctionArgs) {  loginUser helper function. If the user can be found in the database and the password matches, we create the session cookie and add it to the response. Otherwise, we use the error message to return a JSON response.\n    ```", "```js\n    function getUserSession(request: Request) {  return getUserSession function is a helper that we will utilize to access the current session object from the cookie header of a request.Remix’s `getSession` function parses the cookie header and returns a session object we can use to access the stored data. Once we have the session object, we can read from it or destroy it using the `destroySession` life cycle method.\n    ```", "```js\n    export async function logout(logout function parses the current session object from the incoming request and then redirects the user to the login page. The returned response uses the _layout.logout.tsx route module and add the following code:\n\n    ```", "```js\n\n    ```", "```js\n    <RemixLink to=\"/404\">Log out</RemixLink>\n    ```", "```js\n    <Form method=\"POST\" action=\"/logout\">  <button type=\"submit\">Log out</button></Form>\n    ```", "```js\n    export async function getUserId(request: Request) {  createUserSession to write userId to the session cookie. The `getUserId` function expects a `Request` object and returns `userId` from the session cookie if it’s present, or null otherwise. We use `getUserSession` to get the current session object from the cookie header of the `Request` object.We also add a `getUser` function that uses the `getUserId` function under the hood and returns the user object from the database. To avoid exposing the user’s password hash, we ensure not to query the password field from the database.Let’s see how we can use `getUserId` to check whether a user is logged in.\n    ```", "```js\n    import type { LoaderFunctionArgs } from '@remix-run/node';import { redirect } from '@remix-run/node';import { userId exists, then we can be sure that the user has already been authenticated. In this case, we redirect to the dashboard. Otherwise, we show the login or signup page.Note that we return an empty object for our base case in the `loader` function. This is because a `loader` function cannot return `undefined`.\n    ```", "```js\n    import type { LinksFunction, loader export to root.tsx, querying and returning the current user object:\n\n    ```", "```js\n\n    ```", "```js\n    import type { User } from '@prisma/client';import { useRouteLoaderData hook to access the root loader data user object. We also import the type of the root loader function for type inference. We further deserialize the user object to match the User type from @prisma/client without the password property.Note that Remix assigns every route module a unique identifier. The ID of the root route module is \"root\". We must pass `useRouteLoaderData` the ID of the route module of which we want to access the loader data. Remix's route module IDs match the route file name relative to the app folder. You can find more information in the Remix documentation: [https://remix.run/docs/en/2/hooks/use-route-loader-data](https://remix.run/docs/en/2/hooks/use-route-loader-data).We can now call `useUser` throughout our Remix application to access the current user object. You can use the same pattern for any global application state.Let’s try out the hook in action!\n    ```", "```js\n    const user = useUser();\n    ```", "```js\n    {user ? (  <li className=\"ml-auto\">    <NavLink to=\"/dashboard\" prefetch=\"intent\">      Dashboard    </NavLink>  </li>) : (  <>    <li className=\"ml-auto\">      <NavLink to=\"/login\" prefetch=\"intent\">        Log in      </NavLink>    </li>    <li>      <NavLink to=\"/signup\" prefetch=\"intent\">        Sign up      </NavLink>    </li>  </>)}\n    ```", "```js\n    export async function requireUserId(request: Request) {  const session = await getUserSession(request);  const userId = session.get('userId');requireUserId looks similar to getUserId, but this time, we throw a redirect Response if no user session was found.Note that throwing a redirect `Response` does not trigger the `ErrorBoundary` component. Redirects are a special case where we leave the current route module and navigate to another one instead. The final `Response` of a redirect is the document response of the redirected route module.\n    ```", "```js\n    await requireUserId(request);\n    ```", "```js\n    import type { userId, we ensure that a session cookie is present. If no session cookie is present, requireUserId will throw redirect to the login route.We also filter our database queries for user-specific content. We now query for the last expense and invoice objects created by the logged-in user.\n    ```", "```js\n    import { userId to only filter for user-specific data.\n    ```", "```js\n    import { requireUserId } from '~/modules/session/session.server';export async function action({ request }: ActionFunctionArgs) {  userId parameter that was retrieved from the session cookie.\n    ```", "```js\n    export async function loader({ userId cookie value. This ensures that a user can’t visit different expense detail pages and view the content of other users.\n    ```", "```js\n    async function deleteExpense(request: Request, id: string, id and userId. This ensures that a user can only ever delete an expense that was also created by that user.\n    ```", "```js\n    async function updateExpense(formData: FormData, id: string, action function in dashboard.expenses.$id.tsx:\n\n    ```", "```js\n\n    ```"]