<html><head></head><body>
		<div id="_idContainer071">
			<h1 id="_idParaDest-150"><em class="italic"><a id="_idTextAnchor152"/>Chapter 11</em>: Creating Authenticated Experiences</h1>
			<p>Within the context of this book, <strong class="bold">authentication</strong> is the act of verifying that a user is who they say they are within a website. Once their identity has been verified, we can show the individual content that's only meant for them. This might be their profile page, delivery address, bank details, and more. In this chapter, we're going to focus more on how to implement routing for use with authentication services instead of focusing on how to implement authentication services or what content to display when a user is authenticated. We will remind ourselves of how this is done in traditional React applications before applying this knowledge to Gatsby sites with two different client-side implementations.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Routing and authentication in React applications</li>
				<li>Authentication using client-only routes within Gatsby</li>
				<li>Site-wide authentication using context within Gatsby</li>
			</ul>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor153"/>Technical requirements</h1>
			<p>To complete this chapter, you will need to have completed <a href="B15983_10_ePub_RK.xhtml#_idTextAnchor141"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating Gatsby Plugins</em>. You will also need a GitHub account.</p>
			<p>The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter11">https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter11</a>.</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor154"/>Routing and authentication in React applications</h1>
			<p>To achieve authenticated experiences, we will be using <strong class="bold">routing</strong>. Before jumping into how we do this <a id="_idIndexMarker581"/>in Gatsby, let's familiarize ourselves with how routing <a id="_idIndexMarker582"/>works within React applications. Routing is the process of navigating a user around different parts of an application. </p>
			<p>For this example, I will be bootstrapping a React project using <strong class="source-inline">create-react-app</strong>. I have included <a id="_idIndexMarker583"/>steps for its installation but feel free to skip them and <a id="_idIndexMarker584"/>use your own React implementation. <em class="italic">Keep this section's demo separate from your Gatsby project</em>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">In the following example, we will be using the <strong class="source-inline">@reach/router</strong> package for routing. Gatsby uses <strong class="source-inline">@reach/router</strong> under the hood, so by using the package here in React, it will be easy to recognize patterns when we move on to implementing them in Gatsby. </p>
			<p>As React developers, routing is a common part of building applications – let's remind ourselves of the routing basics:</p>
			<ol>
				<li>Create a new folder for this demo. Open a terminal within this new folder and run the following command:<p class="source-code"><strong class="bold">npx create-react-app </strong>.</p></li>
				<li>In the same terminal, run the following command:<p class="source-code"><strong class="bold">npm i @reach/router</strong></p><p>This will install the <strong class="source-inline">@reach/router</strong> package within the project.</p></li>
				<li>Open <strong class="source-inline">src/App.js</strong> and replace it with the following code:<p class="source-code">import { Router, Link } from "@reach/router";</p><p class="source-code">const Nav = () =&gt; (</p><p class="source-code">  &lt;nav&gt;</p><p class="source-code">    &lt;Link to="/"&gt;Homepage&lt;/Link&gt; | &lt;Link</p><p class="source-code">      to="about"&gt;About Me&lt;/Link&gt;</p><p class="source-code">  &lt;/nav&gt;</p><p class="source-code">);</p><p class="source-code">{/* Code continued in next step */}</p><p>Here, we have imported <strong class="source-inline">Router</strong> and <strong class="source-inline">Link</strong> from the <strong class="source-inline">@reach/router</strong> package. We have <a id="_idIndexMarker585"/>also created a <strong class="source-inline">Nav</strong> component that <a id="_idIndexMarker586"/>we can use to access the routes. This <strong class="source-inline">Nav</strong> component utilizes the <strong class="source-inline">Link</strong> component from <strong class="source-inline">@reach/router</strong> to provide navigation between routes.</p></li>
				<li>Append <strong class="source-inline">src/App.js</strong> with the following code:<p class="source-code">const HomePage = () =&gt; (</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">    &lt;Nav /&gt;</p><p class="source-code">    &lt;h1&gt;Homepage&lt;/h1&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">);</p><p class="source-code">const AboutPage = () =&gt; (</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">    &lt;Nav /&gt;</p><p class="source-code">    &lt;h1&gt;About Me&lt;/h1&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">);</p><p class="source-code">{/* Code continued in next step */}</p><p>Here, we have defined a couple of dummy components to route between – a <strong class="source-inline">home</strong> page and an <strong class="source-inline">about</strong> page. This should all be very familiar to you. </p></li>
				<li>Finally, append <strong class="source-inline">src/App.js</strong> with the following code:<p class="source-code">function App() {</p><p class="source-code">  return (</p><p class="source-code">    &lt;Router&gt;</p><p class="source-code">      &lt;HomePage path="/" /&gt;</p><p class="source-code">      &lt;AboutPage path="about" /&gt;</p><p class="source-code">    &lt;/Router&gt;</p><p class="source-code">  );</p><p class="source-code">}</p><p class="source-code">export default App;</p><p>This is where the magic happens. By wrapping the components in a <strong class="source-inline">Router</strong> component, we can <a id="_idIndexMarker587"/>switch out which component is displayed <a id="_idIndexMarker588"/>based on the current URL path. In this instance, if the user is at the <strong class="source-inline">/</strong> path (the route URL) they will see the <strong class="source-inline">HomePage</strong> component, while if <strong class="source-inline">path</strong> is <strong class="source-inline">/about</strong>, they will see the <strong class="source-inline">AboutPage</strong> component. They can use the <strong class="source-inline">Nav</strong> component within these two pages to navigate between the two of them.</p></li>
				<li>Start the project by running <strong class="source-inline">npm start</strong> from the root directory to try it out.</li>
			</ol>
			<p>It's important to remember that navigating between routes is fast because all the routes are loaded when the router renders. As we move into Gatsby, it's important to make sure we only use routers when it is necessary as we might be adding page weight to include components that a user may never have any intention of seeing.</p>
			<p>Now that we have gone through a basic routing example, let's start adding pages that can only be accessed once a user has logged in. We will do this with <strong class="bold">private routes</strong>.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor155"/>Private routes</h2>
			<p>A private route behaves the <a id="_idIndexMarker589"/>same as the other components that are wrapped in a <strong class="source-inline">Router</strong>, except it has an authentication condition. If the condition is not satisfied, instead of seeing the requested content, the user will be redirected to a login screen to authenticate. Let's try this out now by turning our about page that was previously public into a private route:</p>
			<ol>
				<li value="1">First, we are going to need to define our authentication condition. For this example, we are going to keep it simple. To be considered "authenticated," the user must have called the <strong class="source-inline">login</strong> function, which we will trigger via a button on the login page. To achieve <a id="_idIndexMarker590"/>this condition, we are going to create a context that can store the current authentication state. Create a new file called <strong class="source-inline">auth-context.js</strong> and add the following code:<p class="source-code">import React, { useState, useContext } from "react";</p><p class="source-code">import { navigate } from "@reach/router";</p><p class="source-code">const AuthContext = React.createContext();</p><p class="source-code">export const AuthProvider = ({ …props }) =&gt; {</p><p class="source-code">  {/* Code continued in next step */}</p><p class="source-code">};</p><p class="source-code">export const useAuth = () =&gt; useContext(AuthContext);</p><p class="source-code">export default AuthContext;</p><p>Here, we are setting up the boilerplate of our authorization context. We are creating a <strong class="source-inline">useAuth</strong> hook to access the context values that we will be defining in the next step.</p></li>
				<li>Within the <strong class="source-inline">auth-context.js</strong> file's <strong class="source-inline">AuthProvider</strong>, add the following code:<p class="source-code">Const [authenticated, setAuthenticated] =</p><p class="source-code"> useState(false);</p><p class="source-code">  const login = () =&gt; {</p><p class="source-code">    // Make authentication request here and only</p><p class="source-code">       trigger the following if successful.</p><p class="source-code">    setAuthenticated(true);</p><p class="source-code">    navigate("/");</p><p class="source-code">  };</p><p class="source-code">  const logout = () =&gt; {</p><p class="source-code">    setAuthenticated(false);</p><p class="source-code">    navigate("/login");</p><p class="source-code">  };</p><p class="source-code">  return (</p><p class="source-code">    &lt;AuthContext.Provider</p><p class="source-code">      value={{</p><p class="source-code">        login,</p><p class="source-code">        logout,</p><p class="source-code">        authenticated,</p><p class="source-code">      }}</p><p class="source-code">      {...props}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p>Here, we have created a <strong class="source-inline">useState</strong> value called <strong class="source-inline">authenticated</strong> to track whether the user is authenticated or not. We then created a <strong class="source-inline">login</strong> function that sets <strong class="source-inline">authenticated</strong> to <strong class="source-inline">true</strong>. It is within this function that you would make a request to your authentication service and verify the user before authenticating. Most likely, you will also have some information about the user that you could store <a id="_idIndexMarker591"/>in your state or local storage. If you do add additional information, be sure to clear it within the <strong class="source-inline">logout</strong> function. For the time being, the <strong class="source-inline">logout</strong> function just sets <strong class="source-inline">authenticated</strong> to <strong class="source-inline">false</strong> and navigates a user back to the login page. Within <strong class="source-inline">AuthContext.Provider</strong>, we expose the <strong class="source-inline">login</strong> and <strong class="source-inline">logout</strong> functions, as well as the <strong class="source-inline">authenticated</strong> state, to the rest of the application. </p></li>
				<li>Navigate to <a id="_idIndexMarker592"/>your React application's <strong class="source-inline">index.js</strong> file and modify it with the following code:<p class="source-code">import React from "react";</p><p class="source-code">import ReactDOM from "react-dom";</p><p class="source-code">import "./index.css";</p><p class="source-code">import App from "./App";</p><p class="source-code"><strong class="bold">import { AuthProvider } from "./auth-context";</strong></p><p class="source-code">import reportWebVitals from "./reportWebVitals";</p><p class="source-code">ReactDOM.render(</p><p class="source-code">  &lt;React.StrictMode&gt;</p><p class="source-code"><strong class="bold">    &lt;AuthProvider&gt;</strong></p><p class="source-code"><strong class="bold">      &lt;App /&gt;</strong></p><p class="source-code"><strong class="bold">    &lt;/AuthProvider&gt;</strong></p><p class="source-code">  &lt;/React.StrictMode&gt;,</p><p class="source-code">  document.getElementById("root")</p><p class="source-code">);</p><p>Without wrapping our application in <strong class="source-inline">AuthProvider</strong>, we would not be able to access the authentication context within the application. </p></li>
				<li>Our authentication condition is now defined, so we can utilize it to create a private route component. Create a new file called <strong class="source-inline">PrivateRoute.js</strong> and add the following code:<p class="source-code">import React from "react";</p><p class="source-code">import { navigate } from "@reach/router"</p><p class="source-code">import { useAuth } from "./auth-context";</p><p class="source-code">const PrivateRoute = ({</p><p class="source-code">  component: Component,</p><p class="source-code">  ...rest</p><p class="source-code">}) =&gt; {</p><p class="source-code">  const { authenticated } = useAuth();</p><p class="source-code">  if (!authenticated) {</p><p class="source-code">    navigate("/login");</p><p class="source-code">    return null;</p><p class="source-code">  }</p><p class="source-code">  return &lt;Component {...rest} /&gt;;</p><p class="source-code">};</p><p class="source-code">export default PrivateRoute;</p><p>This <strong class="source-inline">PrivateRoute</strong> component uses the <strong class="source-inline">authenticated</strong> state from the <strong class="source-inline">useAuth</strong> hook to conditionally render a given component. If the user is authenticated, the <a id="_idIndexMarker593"/>component will be rendered. If, however, they are not authenticated, the user will be navigated to the <strong class="source-inline">login</strong> route instead. </p></li>
				<li>Return to your <strong class="source-inline">App.js</strong> file and update the file with the following imports:<p class="source-code">import { useAuth } from "./auth-context";</p><p class="source-code">import PrivateRoute from "./PrivateRoute";</p><p>Here, we are importing the <strong class="source-inline">useAuth</strong> hook and our newly created <strong class="source-inline">PrivateRoute</strong> component.</p></li>
				<li>Modify the <strong class="source-inline">HomePage</strong> component with the following code:<p class="source-code">import { Router, Link } from "@reach/router";</p><p class="source-code">// Predefined Nav Component Here.</p><p class="source-code">Const HomePage = () =&gt; {</p><p class="source-code">  <strong class="bold">const { authenticated } = useAuth();</strong></p><p class="source-code">  return (</p><p class="source-code">    &lt;div&gt;</p><p class="source-code">      &lt;Nav /&gt;</p><p class="source-code">      <strong class="bold">&lt;h1&gt;You are {authenticated ? "logged in" :</strong></p><p class="source-code"><strong class="bold">        "logged out"}.&lt;/h1&gt;</strong></p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  );</p><p class="source-code">};</p><p>We can use the <strong class="source-inline">authenticated</strong> state from the <strong class="source-inline">useAuth</strong> hook to give the user some <a id="_idIndexMarker594"/>indication of their authentication status.</p></li>
				<li>Modify the <strong class="source-inline">AboutPage</strong> component with the following code:<p class="source-code">const AboutPage = () =&gt; {</p><p class="source-code">  const { logout } = useAuth();</p><p class="source-code">  return (</p><p class="source-code">    &lt;div&gt;</p><p class="source-code">      &lt;Nav /&gt;</p><p class="source-code">      &lt;h1&gt;About Me&lt;/h1&gt;</p><p class="source-code">      &lt;button onClick={logout}&gt;Logout&lt;/button&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  );</p><p class="source-code">};</p><p>This is the path we intend to make private in this demo. If a user is on this page, we can assume <a id="_idIndexMarker595"/>they have been authenticated and render a logout button to allow them to trigger the <strong class="source-inline">logout</strong> function. </p></li>
				<li>Add a <strong class="source-inline">LoginPage</strong> component to <strong class="source-inline">App.js</strong>:<p class="source-code">const LoginPage = () =&gt; {</p><p class="source-code">  const { login } = useAuth();</p><p class="source-code">  return (</p><p class="source-code">    &lt;div&gt;</p><p class="source-code">      &lt;Nav /&gt;</p><p class="source-code">      &lt;h1&gt;Login Page&lt;/h1&gt;</p><p class="source-code">      &lt;button onClick={login}&gt;Login&lt;/button&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  );</p><p class="source-code">};</p><p>This is a basic implementation that uses the <strong class="source-inline">login</strong> function from <strong class="source-inline">useAuth</strong> to log a user in. In your application, you would probably want to flesh this out with inputs where users enter their email and password. You would then pass this to the <strong class="source-inline">login</strong> function so that it can be used as part of the authorization request.</p></li>
				<li>Finally, update your <strong class="source-inline">App</strong> function so that it includes your <strong class="source-inline">PrivateRoute</strong> component:<p class="source-code">function App() {</p><p class="source-code">  return (</p><p class="source-code">    &lt;Router&gt;</p><p class="source-code">      &lt;HomePage path="/" /&gt;</p><p class="source-code">      &lt;LoginPage path="login" /&gt;</p><p class="source-code">      <strong class="bold">&lt;PrivateRoute component={AboutPage} path="about" /&gt;</strong></p><p class="source-code">    &lt;/Router&gt;</p><p class="source-code">  );</p><p class="source-code">}</p><p class="source-code">export default App;</p></li>
				<li>Start the project by <a id="_idIndexMarker596"/>running <strong class="source-inline">npm start</strong> from the root directory. If you try to navigate to <strong class="source-inline">/about</strong>, you will notice that you will be redirected to <strong class="source-inline">/login</strong> until you have clicked the login button.</li>
			</ol>
			<p>We now have a firm grasp on routing and private routes, so let's take the knowledge we have gained in this section and apply it to Gatsby. </p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor156"/>Authentication using client-only routes within Gatsby</h1>
			<p>While not common practice, we can use routers inside Gatsby pages too. Normally, Gatsby abstracts <a id="_idIndexMarker597"/>all the routing away <a id="_idIndexMarker598"/>so that we don't have to worry about it, but authentication is one example where we need to bring the control over routing back into our hands. We will be creating what is known as client-only routes. To demonstrate this within our project, we are going to create a page at <strong class="source-inline">/private</strong>. As its name might suggest, this path contains a private page that we will lock behind authentication. Let's get started:</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">This example will conflict with the <em class="italic">Site-wide authentication using context within Gatsby</em> section's code. It's best to choose one of these two methods to implement instead of trying to combine them.</p>
			<ol>
				<li value="1">Create a new folder inside <strong class="source-inline">src</strong> called <strong class="source-inline">context</strong>.</li>
				<li>Create a new file called <strong class="source-inline">auth-context.js</strong> and add the following code:<p class="source-code">import React, { useState, useContext } from "react";</p><p class="source-code">import { navigate } from "@reach/router";</p><p class="source-code">const AuthContext = React.createContext();</p><p class="source-code">export const AuthProvider = ({ ...props }) =&gt; {</p><p class="source-code">  {/* Code continued in next step */}</p><p class="source-code">};</p><p class="source-code">export const useAuth = () =&gt; useContext(AuthContext);</p><p>Here, we are <a id="_idIndexMarker599"/>setting up <a id="_idIndexMarker600"/>an authentication context in the same way we did within the example code from the <em class="italic">Routing and authentication in React applications</em> section. Note that we are still importing <strong class="source-inline">navigate</strong> from <strong class="source-inline">@reach/router</strong> instead of the Gatsby library. </p></li>
				<li>Add the following within <strong class="source-inline">AuthProvider</strong>:<p class="source-code">  const [authenticated, setAuthenticated] =</p><p class="source-code">    useState(false);</p><p class="source-code">  const login = async () =&gt; {</p><p class="source-code">    // Make authentication request here and only</p><p class="source-code">       trigger the following if successful.</p><p class="source-code">    setAuthenticated(true);</p><p class="source-code">    navigate("/private")</p><p class="source-code">  };</p><p class="source-code">  const logout = () =&gt; {</p><p class="source-code">    setAuthenticated(false);</p><p class="source-code">  };</p><p class="source-code">  return (</p><p class="source-code">    &lt;AuthContext.Provider</p><p class="source-code">      value={{</p><p class="source-code">        login,</p><p class="source-code">        logout,</p><p class="source-code">        authenticated,</p><p class="source-code">      }}</p><p class="source-code">      {...props}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p>We set <a id="_idIndexMarker601"/>up this <strong class="source-inline">auth-context.js</strong> file <a id="_idIndexMarker602"/>in the same way we did with the React demo, except this time, we navigate to <strong class="source-inline">/private</strong> on a successful login.</p><p class="callout-heading">Important Note</p><p class="callout">Within this section, you will see code that looks very similar to the React demo from the previous section. Please note that while they are similar, they are not the same. Don't be tempted to copy and paste them from the React example.</p></li>
				<li>Add the following to your <strong class="source-inline">gatsby-browser.js</strong> and <strong class="source-inline">gatsby-ssr.js</strong> files:<p class="source-code">import React from "react";</p><p class="source-code">import { AuthProvider } from "./src/context/auth-</p><p class="source-code">  context";</p><p class="source-code">export const wrapPageElement = ({ element }) =&gt; {</p><p class="source-code">  return &lt;AuthProvider&gt;{element}&lt;/AuthProvider&gt;;</p><p class="source-code">};</p><p>We want <a id="_idIndexMarker603"/>to ensure <a id="_idIndexMarker604"/>that the authentication context is available throughout the application. By adding the preceding code to both <strong class="source-inline">gatsby-browser.js</strong> and <strong class="source-inline">gatsby-ssr.js</strong>, we can be sure it is accessible everywhere. </p></li>
				<li>Create a new file within <strong class="source-inline">src/components</strong> called <strong class="source-inline">PrivateRoute.js</strong>.</li>
				<li>Add the following code to the newly created <strong class="source-inline">PrivateRoute.js</strong>:<p class="source-code">import React from "react";</p><p class="source-code">import { navigate } from "gatsby";</p><p class="source-code">import { useAuth } from "../context/auth-context";</p><p class="source-code">const PrivateRoute = ({</p><p class="source-code">  component: Component,</p><p class="source-code">  location,</p><p class="source-code">  basepath,</p><p class="source-code">  ...rest</p><p class="source-code">}) =&gt; {</p><p class="source-code">  const { authenticated } = useAuth();</p><p class="source-code">  if (!authenticated) {</p><p class="source-code">    navigate(basepath + "/login");</p><p class="source-code">    return null;</p><p class="source-code">  }</p><p class="source-code">  return &lt;Component {...rest} /&gt;;</p><p class="source-code">};</p><p class="source-code">export default PrivateRoute;</p><p>This is a Gatsby-friendly implementation of the <strong class="source-inline">PrivateRoute</strong> component. Note that we <a id="_idIndexMarker605"/>are switching <a id="_idIndexMarker606"/>out the <strong class="source-inline">@reach/router</strong> part of <strong class="source-inline">navigate</strong> for Gatsby's implementation. This is because Gatsby's implementation will handle the redirect in a way that is suitable for a Gatsby project. Without this switch, you will be presented with a white screen when <strong class="source-inline">navigate</strong> is called. You will also notice that we are passing in a prop called <strong class="source-inline">basepath</strong>. As our router will not sit at the top of the application, the <strong class="source-inline">PrivateRoute</strong> component must know the router's base path location to ensure it navigates the respective users to it. </p></li>
				<li>Create a new folder inside <strong class="source-inline">src/pages</strong> called <strong class="source-inline">private</strong>.</li>
				<li>Inside this new folder, create a new file called <strong class="source-inline">[...].js</strong>. Using Gatsby's <strong class="bold">file-system-route API</strong>, this format creates a wildcard route that matches anything whose path <a id="_idIndexMarker607"/>begins with <strong class="source-inline">/private</strong>. This step is vitally important as Gatsby does not know the router we will set up, so it needs to understand that if it sees a path beginning with <strong class="source-inline">/private</strong>, such as  <strong class="source-inline">/private/login</strong>, it needs to be handled by this file instead of erroring out with a 404 status code.</li>
				<li>Add the following code to <strong class="source-inline">src/pages/private/[...].js</strong>:<p class="source-code">import React from "react";</p><p class="source-code">import { Router } from "@reach/router";</p><p class="source-code">import Layout from "../components/layout/Layout";</p><p class="source-code">import PrivateRoute from "../components/PrivateRoute";</p><p class="source-code">import { useAuth } from "../context/auth-context";</p><p class="source-code">const LoginPage = () =&gt; {</p><p class="source-code">  const { login } = useAuth();</p><p class="source-code">  return (</p><p class="source-code">    &lt;Layout&gt;</p><p class="source-code">      &lt;h1&gt;Login Page&lt;/h1&gt;</p><p class="source-code">      &lt;button onClick={login}&gt;Login&lt;/button&gt;</p><p class="source-code">    &lt;/Layout&gt;</p><p class="source-code">  );</p><p class="source-code">};</p><p class="source-code">const AuthenticatedPage = () =&gt; {</p><p class="source-code">  const { logout } = useAuth();</p><p class="source-code">  return (</p><p class="source-code">    &lt;Layout&gt;</p><p class="source-code">      &lt;h1&gt;Authenticated Page&lt;/h1&gt;</p><p class="source-code">      &lt;button onClick={logout}&gt;Logout&lt;/button&gt;</p><p class="source-code">    &lt;/Layout&gt;</p><p class="source-code">  );</p><p class="source-code">};</p><p>Here, we <a id="_idIndexMarker608"/>are defining <a id="_idIndexMarker609"/>the two possible paths that will be visible. Either you will be shown <strong class="source-inline">AuthenticatedPage</strong> or, if you are not logged in, you will see the login page. These components both make use of the <strong class="source-inline">useAuth</strong> hook to retrieve the functions they require.</p></li>
				<li>Append the following code to <strong class="source-inline">src/pages/private/[...].js</strong>:<p class="source-code">function PageWithRouter() {</p><p class="source-code">  const basepath = "/private";</p><p class="source-code">  return (</p><p class="source-code">    &lt;Router basepath={basepath}&gt;</p><p class="source-code">      &lt;LoginPage path="login" /&gt;</p><p class="source-code">      &lt;PrivateRoute</p><p class="source-code">        basepath={basepath}</p><p class="source-code">        component={AuthenticatedPage}</p><p class="source-code">        path="/"</p><p class="source-code">      /&gt;</p><p class="source-code">    &lt;/Router&gt;</p><p class="source-code">  );</p><p class="source-code">}</p><p class="source-code">export default PageWithRouter;</p><p>Within this <a id="_idIndexMarker610"/>step, we have <a id="_idIndexMarker611"/>defined our <strong class="source-inline">basepath</strong> – this must match the Gatsby page's path (which, in this instance, is <strong class="source-inline">/private</strong>). We pass this value as a prop both to <strong class="source-inline">Router</strong> and <strong class="source-inline">PrivateRoute</strong>. This example is different from the React example in that the base path is the path that requires authentication. </p></li>
				<li>Start the project by running <strong class="source-inline">npm start</strong> from the root directory. If you try to navigate to <strong class="source-inline">/private</strong>, you will notice that you are redirected to <strong class="source-inline">/private/login</strong>, and clicking the login button will redirect you to <strong class="source-inline">/private</strong>.</li>
			</ol>
			<p>With that, we've <a id="_idIndexMarker612"/>learned how to <a id="_idIndexMarker613"/>add routing within a particular section of our Gatsby site. Now, let's turn our attention to an implementation that you can use when your whole site requires authentication.</p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor157"/>Site-wide authentication using context within Gatsby</h1>
			<p>There may be situations where you want the entirety of your Gatsby site to be behind authentication. For <a id="_idIndexMarker614"/>example, you <a id="_idIndexMarker615"/>may have made a documentation site only meant for employees of your company. Let's look at how we can use context to turn every page into a private route:</p>
			<ol>
				<li value="1">First, let's create a login component in the <strong class="source-inline">components</strong> folder. Call this file <strong class="source-inline">Login.js</strong> and add the following code to it:<p class="source-code">import React from "react";</p><p class="source-code">const Login = ({login}) =&gt; {</p><p class="source-code">  return &lt;button onClick={login}&gt;Login&lt;/button&gt;;</p><p class="source-code">};</p><p class="source-code">export default Login;</p><p>You'll notice that, unlike the last <strong class="source-inline">Login</strong> component we created, we are not retrieving the <strong class="source-inline">login</strong> function from the context. The reason for this will become clear when we create the context.</p></li>
				<li>Create a folder called <strong class="source-inline">context</strong> in <strong class="source-inline">src</strong>.</li>
				<li>Create a file in <strong class="source-inline">context</strong> called <strong class="source-inline">auth-context.js</strong> and add the following code:<p class="source-code">import React, { useState, useContext } from "react";</p><p class="source-code"><strong class="bold">import Login from "../components/Login";</strong></p><p class="source-code">const AuthContext = React.createContext();</p><p class="source-code">export const AuthProvider = ({ ...props }) =&gt; {</p><p class="source-code">{/* Code continued in next step */}</p><p class="source-code">};</p><p class="source-code">export const useAuth = () =&gt; useContext(AuthContext);</p><p class="source-code">export default AuthContext;</p><p>Here, we are <a id="_idIndexMarker616"/>setting up <a id="_idIndexMarker617"/>the authentication context in the same way we did in the <em class="italic">Routing and authentication in React applications</em> section but with one addition. We are now also importing our <strong class="source-inline">Login</strong> component into our authentication context.</p></li>
				<li>Add the following code within <strong class="source-inline">AuthProvider</strong>:<p class="source-code">  const [authenticated, setAuthenticated] =</p><p class="source-code">    useState(false);</p><p class="source-code">  const login = async () =&gt; {</p><p class="source-code">    // Make authentication request here and only</p><p class="source-code">       trigger the following if successful.</p><p class="source-code">    setAuthenticated(true);</p><p class="source-code">  };</p><p class="source-code">  const logout = () =&gt; {</p><p class="source-code">    setAuthenticated(false);</p><p class="source-code">  };</p><p class="source-code">  <strong class="bold">if (!authenticated) {</strong></p><p class="source-code"><strong class="bold">    return &lt;Login login={login} /&gt;;</strong></p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code">  return (</p><p class="source-code">    &lt;AuthContext.Provider</p><p class="source-code">      value={{</p><p class="source-code">        login,</p><p class="source-code">        logout,</p><p class="source-code">        authenticated,</p><p class="source-code">      }}</p><p class="source-code">      {...props}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p>If the user is not authenticated, the provider will return the <strong class="source-inline">Login</strong> component, being sure to pass in the <strong class="source-inline">login</strong> function as a prop. This does not cause a route change, which can be a great benefit. When a user navigates to a page, their requested <a id="_idIndexMarker618"/>path is not lost by <a id="_idIndexMarker619"/>navigating away to a login page and, as such, when the user has successfully logged in, they will jump right back into the application in the place they intended to be. As a developer, this can stop you from having to pass redirect URLs around in the browser, which can be a hassle. </p><p>If, for some reason, you want to keep a few pages public, you can check for the path in this conditional statement and allow some paths to be accessible, even without being authenticated. Note that even on these pages, the <strong class="source-inline">Login</strong> component will be loaded in, despite the fact it is not being used and will add unnecessary page weight.</p></li>
				<li>Add the following to your <strong class="source-inline">gatsby-browser.js</strong> and <strong class="source-inline">gatsby-ssr.js</strong> files:<p class="source-code">import React from "react";</p><p class="source-code">import { AuthProvider } from "./src/context/auth-</p><p class="source-code">  context";</p><p class="source-code">export const wrapPageElement = ({ element }) =&gt; {</p><p class="source-code">  return &lt;AuthProvider&gt;{element}&lt;/AuthProvider&gt;;</p><p class="source-code">};</p><p>We want <a id="_idIndexMarker620"/>to ensure that <a id="_idIndexMarker621"/>the authentication context is available throughout the application. By adding this file to both <strong class="source-inline">gatsby-browser.js</strong> and <strong class="source-inline">gatsby-ssr.js</strong>, we can ensure it is accessible everywhere. </p></li>
				<li>Start the project by running <strong class="source-inline">npm start</strong> from the root directory and navigate to any page on the site. You should find that you are prompted to log in before being able to view the page.</li>
			</ol>
			<p>Now that we have looked at two different ways to achieve authenticated experiences within Gatsby applications, let's summarize what we have learned.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor158"/>Summary</h1>
			<p>In this chapter, we explored routing and authenticated experiences. We reminded ourselves of how routing works in React and created private routes for use with <strong class="source-inline">@reach/router</strong>. Then, we ported this knowledge into Gatsby and created a private page that was only accessible by logging in. Finally, we investigated how we can use context to wrap our whole application in authentication for situations that require it.</p>
			<p>In the next chapter, we will learn about another advanced concept – how to use sockets to create experiences that make use of real-time data.</p>
		</div>
	</body></html>