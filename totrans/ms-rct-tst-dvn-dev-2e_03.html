<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer015">
<h1 class="chapter-number" id="_idParaDest-55"><a id="_idTextAnchor053"/>3</h1>
<h1 id="_idParaDest-56"><a id="_idTextAnchor054"/>Refactoring the Test Suite</h1>
<p>At this point, you’ve written a handful of tests. Although they may seem simple enough already, they can be simpler.</p>
<p>It’s extremely important to build a maintainable test suite: one that is quick and painless to build and adapt. One way to roughly gauge maintainability is to look at the number of lines of code in each test. To give some comparison to what you’ve seen so far, in the Ruby language, a test with more than <em class="italic">three</em> lines is considered a long test!</p>
<p>This chapter will take a look at some of the ways you can make your test suite more concise. We’ll do that by extracting common code into a module that can be reused across all your test suites. We’ll also create a custom Jest matcher.</p>
<p class="callout-heading">When is the right time to pull out reusable code?</p>
<p class="callout">So far, you’ve written one module with two test suites within it. It’s arguably too early to be looking for opportunities to extract duplicated code. Outside of an educational setting, you may wish to wait until the third or fourth test suite before you pounce on any duplication.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Pulling out reusable rendering logic</li>
<li>Creating a Jest matcher using TDD</li>
<li>Extracting DOM helpers</li>
</ul>
<p>By the end of the chapter, you’ll have learned how to approach your test suite with a critical eye for maintainability.</p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor055"/>Technical requirements</h1>
<p>The code files for this chapter can be found here: <a href="https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter03">https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter03</a>.</p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor056"/>Pulling out reusable rendering logic</h1>
<p>In this<a id="_idIndexMarker244"/> section, we will extract a module that initializes a unique DOM container element for each test. Then, we’ll build<a id="_idIndexMarker245"/> a render function that uses this container element.</p>
<p>The two test suites we’ve built both have the same <strong class="source-inline">beforeEach</strong> block that runs before each test:</p>
<pre class="source-code">
let container;
beforeEach(() =&gt; {
  container = document.createElement("div");
  document.body.replaceChildren(container);
});</pre>
<p>Wouldn’t it be great if we could somehow tell Jest that any test suite that is testing a React component should <em class="italic">always</em> use this <strong class="source-inline">beforeEach</strong> block and make the <strong class="source-inline">container</strong> variable available to our tests?</p>
<p>Here, we will extract a new module that exports two things: the <strong class="source-inline">container</strong> variable and<a id="_idIndexMarker246"/> the <strong class="source-inline">initializeReactContainer</strong> function. This won’t save us any typing, but it will hide the pesky <strong class="source-inline">let</strong> declaration and give a descriptive name to the<a id="_idIndexMarker247"/> call to <strong class="source-inline">createElement</strong>.</p>
<p class="callout-heading">The importance of small functions with descriptive names</p>
<p class="callout">Often, it’s helpful to pull out functions that contain just a single line of code. The benefit is that you can then give it a descriptive name that serves as a comment as to what that line of code does. This is preferable to using an actual comment because the name travels with you wherever you use the code.</p>
<p class="callout">In this case, the call to <strong class="source-inline">document.createElement</strong> could be confusing to a future maintainer of your software. Imagine that it is someone who has never done any unit testing of React code. They would be asking, “Why do the tests create a new DOM element for <a id="_idIndexMarker248"/>each and every test?” You can go some way to answer that by giving it a name, such<a id="_idIndexMarker249"/> as <strong class="source-inline">initializeReactContainer</strong>. It doesn’t offer a complete answer as to why it’s necessary, but it does allude to some notion of “initialization.”</p>
<p>Let’s go ahead and<a id="_idIndexMarker250"/> pull out this code:</p>
<ol>
<li>Create a new file called <strong class="source-inline">test/reactTestExtensions.js</strong>. This file will ultimately contain a whole bunch of helper methods that we’ll use in our React component tests.</li>
<li>Add the following content to the file. The function is implicitly updating the <strong class="source-inline">container</strong> variable within the module. That variable is then exported – our test suites can access this variable as if it were a “read-only” constant:<p class="source-code">export let container;</p><p class="source-code">export const initializeReactContainer = () =&gt; {</p><p class="source-code">  container = document.createElement("div");</p><p class="source-code">  document.body.replaceChildren(container);</p><p class="source-code">}</p></li>
<li>Move to <strong class="source-inline">test/AppointmentsDayView.test.js</strong>. Add the following import just below the existing imports:<p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code">  container,</p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>Now, replace the two <strong class="source-inline">beforeEach</strong> blocks – remember that there is one in each <strong class="source-inline">describe</strong> block – with the following code:<p class="source-code">beforeEach(() =&gt; {</p><p class="source-code">  initializeReactContainer();</p><p class="source-code">});</p></li>
<li>Delete the <strong class="source-inline">let container</strong> definition from the top of both <strong class="source-inline">describe</strong> blocks.</li>
<li>Run <strong class="source-inline">npm test</strong> and verify that your tests are still passing.</li>
</ol>
<p>Now, how about continuing with <a id="_idIndexMarker251"/>the <strong class="source-inline">render</strong> function? Let’s move that into <a id="_idIndexMarker252"/>our new module. This time, it’s a straight lift and replace job:</p>
<ol>
<li value="1">Copy the definition of <strong class="source-inline">render</strong> from one of the <strong class="source-inline">describe</strong> blocks.</li>
<li>Paste it into <strong class="source-inline">reactTestExtensions.js</strong>. For reference, here it is again:<p class="source-code">export const render = (component) =&gt;</p><p class="source-code">  act(() =&gt; </p><p class="source-code">    ReactDOM.createRoot(container).render(component)</p><p class="source-code">  );</p></li>
<li>You’ll also need to add these imports at the top of the file:<p class="source-code">import ReactDOM from "react-dom/client";</p><p class="source-code">import { act } from "react-dom/test-utils";</p></li>
<li>Back in your test file, you can now<a id="_idIndexMarker253"/> change the test extensions import so that it includes the new <strong class="source-inline">render</strong> function, and then remove <a id="_idIndexMarker254"/>the <strong class="source-inline">container</strong> import:<p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code"><strong class="bold">  render,</strong></p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>Delete the two <strong class="source-inline">render</strong> definitions from the two test suites.</li>
<li>Run <strong class="source-inline">npm test</strong> and verify that your tests are still passing.</li>
</ol>
<p>So far, we've extracted two functions. We have one more to do: the <strong class="source-inline">click</strong> function. However, we have one more “action” function that we can create: <strong class="source-inline">click</strong>. Let’s do that now:</p>
<ol>
<li value="1">Create <a id="_idIndexMarker255"/>the <strong class="source-inline">click</strong> function in<a id="_idIndexMarker256"/> your test<a id="_idIndexMarker257"/> extensions file, as shown here:<p class="source-code">export const click = (element) =&gt;</p><p class="source-code">  act(() =&gt; element.click());</p></li>
<li>Back in your test file, adjust your import:<p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code">  container,</p><p class="source-code">  render,</p><p class="source-code"><strong class="bold">  click,</strong></p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>In your test suite, replace each invocation of the <strong class="source-inline">click</strong> function with the following line:<p class="source-code">click(button);</p></li>
<li>The <strong class="source-inline">act</strong> import is no longer needed in your test suite. Go ahead and delete that import from your test file.</li>
<li>Run <strong class="source-inline">npm test</strong> and verify that your tests are still passing.</li>
</ol>
<p class="callout-heading">Avoiding the act function in your test code</p>
<p class="callout">The <strong class="source-inline">act</strong> function<a id="_idIndexMarker258"/> causes a fair amount of clutter in tests, which doesn’t help in our quest for conciseness. Thankfully, we can push it out into our extensions module and be done with it. </p>
<p>Remember<a id="_idIndexMarker259"/> the<strong class="bold"> Arrange-Act-Assert </strong>pattern that our tests should always follow? Well, we’ve now extracted everything we can from the <strong class="bold">Arrange</strong> and <strong class="bold">Act</strong> sections.</p>
<p>The approach we’ve taken here, of using an exported <strong class="source-inline">container</strong> variable, isn’t the only approach worth exploring. You could, for example, build a wrapper function for <strong class="source-inline">describe</strong> that automatically includes a <strong class="source-inline">beforeEach</strong> block and builds a <strong class="source-inline">container</strong> variable that’s accessible within the scope of that <strong class="source-inline">describe</strong> block. You could name it something like <strong class="source-inline">describeReactComponent</strong>.</p>
<p>An advantage of this approach is that it involves a lot less code – you won’t be dealing with all those imports, and you could get rid of your <strong class="source-inline">beforeEach</strong> block in the test suites. The downside is that it’s very <em class="italic">clever</em>, which is not always a good thing when it comes to maintainability. There’s something a bit magical about it that requires a certain level of prior <a id="_idIndexMarker260"/>knowledge.</p>
<p>That being said, if this approach appeals to you, I encourage you to try it out. </p>
<p>In the next section, we’ll start to tackle the <strong class="bold">Assert</strong> section of our tests.</p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor057"/>Creating a Jest matcher using TDD</h1>
<p>In our <a id="_idIndexMarker261"/>tests <a id="_idIndexMarker262"/>so far, we’ve used a <a id="_idIndexMarker263"/>variety of <strong class="bold">matchers</strong>. These functions tack on to the end of the <strong class="source-inline">expect</strong> function call:</p>
<pre class="source-code">
expect(appointmentTable()).not.toBeNull();</pre>
<p>In this section, you’ll build a matcher using a test-driven approach to make sure it’s doing the right thing. You’ll learn about the Jest matcher API as you build your test suite.</p>
<p>You’ve seen quite a few matchers so far: <strong class="source-inline">toBeNull</strong>, <strong class="source-inline">toContain</strong>, <strong class="source-inline">toEqual</strong>, and <strong class="source-inline">toHaveLength</strong>. You’ve also seen how they can be negated with <strong class="source-inline">not</strong>.</p>
<p>Matchers are a powerful way of building expressive yet concise tests. You should take some time to learn all the matchers that Jest has to offer.</p>
<p class="callout-heading">Jest matcher libraries</p>
<p class="callout">There are a lot of different matcher libraries available as npm packages. Although we won’t use them in this book (since we’re building everything up from first principles), you should make use of these libraries. See the <em class="italic">Further reading</em> section at the end of this chapter for a list of libraries that will be useful to you when testing React components.</p>
<p>Often, you’ll <a id="_idIndexMarker264"/>want to<a id="_idIndexMarker265"/> build matchers. There<a id="_idIndexMarker266"/> are at least a couple of occasions that will prompt you to do this:</p>
<ul>
<li>An expectation you’re writing is quite wordy, lengthy, or just doesn’t read well in plain language.</li>
<li>Some of the tests are repeating the same group of expectations again and again. This is a sign that you have a business concept that you can encode in a single matcher that will be specific to your project.</li>
</ul>
<p>The second point is an interesting one. If you’re writing the same expectations multiple times across multiple tests, you should treat it just like you would if it was repeated code in your production source code. You’d pull that out into a function. Here, the matcher serves the same purpose, except using a matcher instead of a function helps remind you that this line of code is a special statement of fact about your software: a specification.</p>
<p class="callout-heading">One expectation per test</p>
<p class="callout">You should generally aim for just one expectation per test. "Future you" will thank you for keeping things simple! (In <a href="B18423_05.xhtml#_idTextAnchor079"><em class="italic">Chapter 5</em></a>, <em class="italic">Adding Complex Form Interactions</em>, we’ll look at a situation where multiple expectations are beneficial.)</p>
<p class="callout">You might hear this guideline and be instantly horrified. You might be imagining an explosion of tiny tests. But if you’re ready to write matchers, you can aim for one expectation per test and still<a id="_idIndexMarker267"/> keep the number of tests down.</p>
<p>The matcher we’re going to build in this section is<a id="_idIndexMarker268"/> called <strong class="source-inline">toContainText</strong>. It will replace the following expectation:</p>
<pre class="source-code">
expect(appointmentTable().textContent).toContain("Ashley");</pre>
<p>It will replace it with the following form, which is slightly more readable:</p>
<pre class="source-code">
expect(appointmentTable()).toContainText("Ashley");</pre>
<p>Here’s what <a id="_idIndexMarker269"/>the<a id="_idIndexMarker270"/> output looks <a id="_idIndexMarker271"/>like on the terminal:</p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<img alt="Figure 3.1 – The output of the toContainText matcher when it fails " height="798" src="image/Figure_3.01_B18423.jpg" width="1050"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – The output of the toContainText matcher when it fails</p>
<p>Let’s get started:</p>
<ol>
<li value="1">Create a new directory named <strong class="source-inline">test/matchers</strong>. This is where both the source code and tests for the matchers will live.</li>
<li>Create the new <strong class="source-inline">test/matchers/toContainText.test.js</strong> file.</li>
<li>Write the first test, as shown here. This test introduces a couple of new ideas. First, it shows that <strong class="source-inline">matcher</strong> is a function that takes two parameters: the actual element and the data to match on. Second, it shows that the function returns an object with a <strong class="source-inline">pass</strong> property. This<a id="_idIndexMarker272"/> property is true if the matcher successfully “matched” – in <a id="_idIndexMarker273"/>other <a id="_idIndexMarker274"/>words, it passed:<p class="source-code">import { toContainText } from "./toContainText";</p><p class="source-code">describe("toContainText matcher", () =&gt; {</p><p class="source-code">  it("returns pass is true when text is found in the given DOM element", () =&gt; {</p><p class="source-code">    const domElement = {</p><p class="source-code">      textContent: "text to find"</p><p class="source-code">    };</p><p class="source-code">    const result = toContainText(</p><p class="source-code">      domElement,</p><p class="source-code">      "text to find"</p><p class="source-code">    );</p><p class="source-code">    expect(result.pass).toBe(true);</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Create another new file called <strong class="source-inline">test/matchers/toContainText.js</strong>. This first test is trivial to make pass:<p class="source-code">export const toContainText = (</p><p class="source-code">  received,</p><p class="source-code">  expectedText</p><p class="source-code">) =&gt; ({</p><p class="source-code">  pass: true</p><p class="source-code">});</p></li>
<li>We need<a id="_idIndexMarker275"/> to <a id="_idIndexMarker276"/>triangulate<a id="_idIndexMarker277"/> to get to the real implementation. Write the next test, as shown here:<p class="source-code">it("return pass is false when the text is not found in the given DOM element", () =&gt; {</p><p class="source-code">  const domElement = { textContent: "" };</p><p class="source-code">  const result = toContainText(</p><p class="source-code">    domElement,</p><p class="source-code">    "text to find"</p><p class="source-code">  );</p><p class="source-code">  expect(result.pass).toBe(false);</p><p class="source-code">});</p></li>
<li>Now, continue the implementation for our matcher, as shown here. At this stage, you have a functioning matcher – it just needs to be plugged into Jest:<p class="source-code">export const toContainText = (</p><p class="source-code">  received,</p><p class="source-code">  expectedText</p><p class="source-code">) =&gt; ({</p><p class="source-code">  pass: <strong class="bold">received.textContent.includes(expectedText)</strong></p><p class="source-code">});</p></li>
<li>Before we make use of this, it’s good practice to fill in an expected second property of your return value: <strong class="source-inline">message</strong>. So, go ahead and do that. The following test shows that we expect the message to contain the matcher text itself, as <a id="_idIndexMarker278"/>a<a id="_idIndexMarker279"/> useful<a id="_idIndexMarker280"/> reminder to the programmer:<p class="source-code">it("returns a message that contains the source line if no match", () =&gt; {</p><p class="source-code">  const domElement = { textContent: "" };</p><p class="source-code">  const result = toContainText(</p><p class="source-code">    domElement,</p><p class="source-code">    "text to find"</p><p class="source-code">  );</p><p class="source-code">  expect(</p><p class="source-code">    stripTerminalColor(result.message())</p><p class="source-code">  ).toContain(</p><p class="source-code">    `expect(element).toContainText("text to find")`</p><p class="source-code">  );</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Understanding the message function</p>
<p class="callout">The requirements <a id="_idIndexMarker281"/>for the <strong class="source-inline">message</strong> function are complex. At a basic level, it is a helpful string that is displayed when the expectation fails. However, it’s not just a string – it’s a function that returns a string. This is a performance feature: the value of <strong class="source-inline">message</strong> does not need to be evaluated unless there is a failure. But even more complicated is the fact that the message should change, depending on whether the expectation was negated or not. If <strong class="source-inline">pass</strong> is <strong class="source-inline">false</strong>, then the <strong class="source-inline">message</strong> function should assume that the matcher was called in the “positive” sense – in other words, without a <strong class="source-inline">.not</strong> qualifier. But if <strong class="source-inline">pass</strong> is <strong class="source-inline">true</strong>, and the <strong class="source-inline">message</strong> function ends up being invoked, then it’s safe to assume that it <em class="italic">was</em> negated. We’ll need another test for this negated case, which comes a little later.</p>
<ol>
<li value="8">This<a id="_idIndexMarker282"/> function<a id="_idIndexMarker283"/> uses a <strong class="source-inline">stripTerminalColor</strong> function<a id="_idIndexMarker284"/> that we should now define, above the test suite. Its purpose is to remove any ASCII escape codes that add colors:<p class="source-code">const stripTerminalColor = (text) =&gt;</p><p class="source-code">    text.replace(/\x1B\[\d+m/g, "");</p></li>
</ol>
<p class="callout-heading">Testing ASCII escape codes</p>
<p class="callout">As you’ve seen<a id="_idIndexMarker285"/> already, when Jest prints out test failures, you’ll see a bunch of red and green colorful text. That’s achieved by printing ASCII escape codes within the text string.</p>
<p class="callout">This is a tricky thing to test. Because of that, we’re making a pragmatic choice to not bother testing colors. Instead, the <strong class="source-inline">stripTerminalColor</strong> function strips out these escape codes from the <a id="_idIndexMarker286"/>string so that you can test the text output as if it was plain text.</p>
<ol>
<li value="9">Make that test pass by making use of Jest’s <strong class="source-inline">matcherHint</strong> and <strong class="source-inline">printExpected</strong> functions, as <a id="_idIndexMarker287"/>shown here. It isn’t particularly clear how the <strong class="source-inline">matcherHint</strong> function <a id="_idIndexMarker288"/>works but, hopefully, you can convince yourself that it does what we expect by running tests and seeing the last one pass! The <strong class="source-inline">printExpected</strong> functions<a id="_idIndexMarker289"/> add quotes to<a id="_idIndexMarker290"/> our value and colors it green:<p class="source-code">import {</p><p class="source-code">  matcherHint,</p><p class="source-code">  printExpected,</p><p class="source-code">} from "jest-matcher-utils";</p><p class="source-code">export const toContainText = (</p><p class="source-code">  received,</p><p class="source-code">  expectedText</p><p class="source-code">) =&gt; {</p><p class="source-code">  const pass = </p><p class="source-code">    received.textContent.includes(expectedText);</p><p class="source-code">  const message = () =&gt;</p><p class="source-code">    matcherHint(</p><p class="source-code">      "toContainText",</p><p class="source-code">      "element",</p><p class="source-code">      printExpected(expectedText),</p><p class="source-code">      { }</p><p class="source-code">    );</p><p class="source-code">  return { pass, message };</p><p class="source-code">};</p></li>
</ol>
<p class="callout-heading">Learning about Jest’s matcher utilities</p>
<p class="callout">At the time of <a id="_idIndexMarker291"/>writing, I’ve found the best way to learn what the Jest matcher utility functions do is to read their source. You could also avoid them entirely if you like – there’s no obligation to use them.</p>
<ol>
<li value="10">Now comes <a id="_idIndexMarker292"/>the <a id="_idIndexMarker293"/>complicated part. Add the following test, which specifies the scenario of a failed expectation when using the negated matcher. The message should reflect that the matcher was negated, as shown here:<p class="source-code">it("returns a message that contains the source line if negated match", () =&gt; {</p><p class="source-code">  const domElement = { textContent: "text to find" };</p><p class="source-code">  const result = toContainText(</p><p class="source-code">    domElement,</p><p class="source-code">    "text to find"</p><p class="source-code">  );</p><p class="source-code">  expect(</p><p class="source-code">    stripTerminalColor(result.message())</p><p class="source-code">  ).toContain(</p><p class="source-code">    `expect(container).not.toContainText("text to find")`</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>To make that <a id="_idIndexMarker294"/>pass, pass a new option to <strong class="source-inline">matcherHint</strong>:<p class="source-code">...</p><p class="source-code">matcherHint(</p><p class="source-code">  "toContainText",</p><p class="source-code">  "element",</p><p class="source-code">  printExpected(expectedText),</p><p class="source-code"><strong class="bold">  { isNot: pass }</strong></p><p class="source-code">);</p><p class="source-code">...</p></li>
<li>There’s one final<a id="_idIndexMarker295"/> test to add. We can print out the<a id="_idIndexMarker296"/> actual <strong class="source-inline">textContent</strong> property value <a id="_idIndexMarker297"/>of the element, which will help debug test failures when they occur. Add the following test:<p class="source-code">it("returns a message that contains the actual text", () =&gt; {</p><p class="source-code">  const domElement = { textContent: "text to find" };</p><p class="source-code">  const result = toContainText(</p><p class="source-code">    domElement,</p><p class="source-code">    "text to find"</p><p class="source-code">  );</p><p class="source-code">  expect(</p><p class="source-code">    stripTerminalColor(result.message())</p><p class="source-code">  ).toContain(`Actual text: "text to find"`);</p><p class="source-code">});</p></li>
<li>Make it pass by adjusting<a id="_idIndexMarker298"/> your matcher code, as <a id="_idIndexMarker299"/>shown here. Note the use of the new <strong class="source-inline">printReceived</strong> function, which is the same as <strong class="source-inline">printExpected</strong> except it <a id="_idIndexMarker300"/>colors the text red instead of green:<p class="source-code">import {</p><p class="source-code">  matcherHint,</p><p class="source-code">  printExpected<strong class="bold">,</strong></p><p class="source-code"><strong class="bold">  printReceived,</strong></p><p class="source-code">} from "jest-matcher-utils";</p><p class="source-code">export const toContainText = (</p><p class="source-code">  received,</p><p class="source-code">  expectedText</p><p class="source-code">) =&gt; {</p><p class="source-code">  const pass = </p><p class="source-code">    received.textContent.includes(expectedText);</p><p class="source-code">  const <strong class="bold">sourceHint</strong> = () =&gt;</p><p class="source-code">    matcherHint(</p><p class="source-code">      "toContainText",</p><p class="source-code">      "element",</p><p class="source-code">      printExpected(expectedText),</p><p class="source-code">      { isNot: pass }</p><p class="source-code">    );</p><p class="source-code">  <strong class="bold">const actualTextHint = () =&gt;</strong></p><p class="source-code"><strong class="bold">    "Actual text: " + </strong></p><p class="source-code"><strong class="bold">    printReceived(received.textContent);</strong></p><p class="source-code"><strong class="bold">  const message = () =&gt;</strong></p><p class="source-code"><strong class="bold">    [sourceHint(), actualTextHint()].join("\n\n");</strong></p><p class="source-code">  return { pass, message };</p><p class="source-code">};</p></li>
<li>It’s time to plug<a id="_idIndexMarker301"/> the test into Jest. To do that, create a <a id="_idIndexMarker302"/>new <a id="_idIndexMarker303"/>file called <strong class="source-inline">test/domMatchers.js</strong> with the following content:<p class="source-code">import {</p><p class="source-code">  toContainText</p><p class="source-code">} from "./matchers/toContainText";</p><p class="source-code">expect.extend({</p><p class="source-code">  toContainText,</p><p class="source-code">});</p></li>
<li>Open <strong class="source-inline">package.json</strong> and update your Jest configuration so that it loads this file before your tests run:<p class="source-code">"jest": {</p><p class="source-code">  ...,</p><p class="source-code">  "setupFilesAfterEnv": ["./test/domMatchers.js"]</p><p class="source-code">}</p></li>
<li>Your new matcher is ready to use. Open <strong class="source-inline">test/AppointmentsDayView.test.js</strong> and change all your tests that use the <strong class="source-inline">expect(&lt;element&gt;.textContent).toEqual(&lt;text&gt;)</strong>and <strong class="source-inline">expect(&lt;element&gt;.textContent).toContain(&lt;text&gt;)</strong> forms. They should be replaced with <strong class="source-inline">expect(&lt;element&gt;).toContainText(&lt;text&gt;)</strong>.</li>
<li>Run your tests; you should see them all still passing. Take a moment to play around and see how your matcher works. First, change one of the expected text values to something incorrect, and watch the matcher fail. See how the output messages look. Then, change the expected value back to the correct one, but negate <a id="_idIndexMarker304"/>the<a id="_idIndexMarker305"/> matcher <a id="_idIndexMarker306"/>by changing it to <strong class="source-inline">.not.toContainText</strong>. Finally, revert your code to the all-green state.</li>
</ol>
<p class="callout-heading">Why do we test-drive matchers?</p>
<p class="callout">You should write tests for any code that isn’t just simply calling other functions or setting variables. At the start of this chapter, you extracted functions <a id="_idIndexMarker307"/>such<a id="_idIndexMarker308"/> as <strong class="source-inline">render</strong> and <strong class="source-inline">click</strong>. These functions didn’t need tests because you were just transplanting the same line of code from one file to another. But this matcher does something much more complex – it must return an object that conforms to the pattern that Jest requires. It also makes use of Jest’s utility functions to build up a helpful message. That complexity warrants tests.</p>
<p class="callout">If you are building matchers for a library, you should be more careful with your matcher’s implementation. For example, we didn’t bother to check that the received value is an HTML element. That’s fine because this matcher exists in our code base only, and we control how it’s<a id="_idIndexMarker309"/> used. When you package matchers for use in other projects, you should also verify that the function inputs are values you’re expecting to see.</p>
<p>You’ve now successfully test-driven your first matcher. There will be more opportunities for you to practice <a id="_idIndexMarker310"/>this<a id="_idIndexMarker311"/> skill as this book progresses. For now, we’ll move on to the final part of our cleanup: creating some fluent DOM helpers.</p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor058"/>Extracting DOM helpers</h1>
<p>In this<a id="_idIndexMarker312"/> section, we’ll pull out a bunch of little functions that will help our tests become more readable. This will be straightforward compared to the matcher we’ve just built.</p>
<p>The <strong class="source-inline">reactTestExtensions.js</strong> module already <a id="_idIndexMarker313"/>contains three functions that you’ve used: <strong class="source-inline">initializeReactContainer</strong>, <strong class="source-inline">render</strong>, and <strong class="source-inline">click</strong>.</p>
<p>Now, we’ll add<a id="_idIndexMarker314"/> four<a id="_idIndexMarker315"/> more: <strong class="source-inline">element</strong>, <strong class="source-inline">elements</strong>, <strong class="source-inline">typesOf</strong>, and <strong class="source-inline">textOf</strong>. These<a id="_idIndexMarker316"/> functions<a id="_idIndexMarker317"/> are designed to help your tests read much more like plain English. Let’s take a look at an example. Here are the expectations for one of our tests:</p>
<pre class="source-code">
const listChildren = document.querySelectorAll("li");
expect(listChildren[0].textContent).toEqual("12:00");
expect(listChildren[1].textContent).toEqual("13:00");</pre>
<p>We can introduce a function, <strong class="source-inline">elements</strong>, that is a shorter version of <strong class="source-inline">document.querySelectorAll</strong>. The shorter name means we can get rid of the extra variable:</p>
<pre class="source-code">
expect(elements("li")[0].textContent).toEqual("12:00");
expect(elements("li")[1].textContent).toEqual("13:00");</pre>
<p>This code is now calling <strong class="source-inline">querySelectorAll</strong> twice – so it’s doing more work than before – but it’s also shorter and more readable. And we can go even further. We can boil this down to one <strong class="source-inline">expect</strong> call by matching on the <strong class="source-inline">elements</strong> array itself. Since we need <strong class="source-inline">textContent</strong>, we will simply build a mapping function called <strong class="source-inline">textOf</strong> that takes that input array <a id="_idIndexMarker318"/>and returns the <strong class="source-inline">textContent</strong> property of each element within it:</p>
<pre class="source-code">
expect(textOf(elements("li"))).toEqual(["12:00", "13:00"]);</pre>
<p>The <strong class="source-inline">toEqual</strong> matcher, when applied to arrays, will check that each array has the same number of elements and that each element appears in the same place.</p>
<p>We’ve reduced our original three lines of code to just one!</p>
<p>Let’s go ahead and build these new helpers:</p>
<ol>
<li value="1">Open <strong class="source-inline">test/reactTestExtensions.js</strong> and <a id="_idIndexMarker319"/>add the following definitions at the bottom of the <a id="_idIndexMarker320"/>file. You’ll<a id="_idIndexMarker321"/> notice that the elements are using <strong class="source-inline">Array.from</strong>. This is so<a id="_idIndexMarker322"/> that the resulting array can be mapped over by both <strong class="source-inline">typesOf</strong> and <strong class="source-inline">textOf</strong>:<p class="source-code">export const element = (selector) =&gt;</p><p class="source-code">  document.querySelector(selector);</p><p class="source-code">export const elements = (selector) =&gt;</p><p class="source-code">  Array.from(document.querySelectorAll(selector));</p><p class="source-code">export const typesOf = (elements) =&gt;</p><p class="source-code">  elements.map((element) =&gt; element.type);</p><p class="source-code">export const textOf = (elements) =&gt;</p><p class="source-code">  elements.map((element) =&gt; element.textContent);</p></li>
<li>Open <strong class="source-inline">test/AppointmentsDayView.test.js</strong> and change the extensions import to include all these new functions:<p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code">  render,</p><p class="source-code">  click,</p><p class="source-code"><strong class="bold">  element,</strong></p><p class="source-code"><strong class="bold">  elements,</strong></p><p class="source-code"><strong class="bold">  textOf,</strong></p><p class="source-code"><strong class="bold">  typesOf,</strong></p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>Now, do a search and replace for <strong class="source-inline">document.querySelectorAll</strong>, replacing each<a id="_idIndexMarker323"/> occurrence with elements. Run <strong class="source-inline">npm test</strong> and verify <a id="_idIndexMarker324"/>that your tests still pass.</li>
<li>Search for and replace <strong class="source-inline">document.querySelector</strong>, replacing each occurrence <a id="_idIndexMarker325"/>with <strong class="source-inline">element</strong>. Again, run your tests and check that everything is fine.</li>
<li>You will see that the<a id="_idIndexMarker326"/> test renders at the time of the<a id="_idIndexMarker327"/> appointment. Replace<a id="_idIndexMarker328"/> the existing expectations with this one:<p class="source-code">expect(textOf(elements("li"))).toEqual([</p><p class="source-code">  "12:00", "13:00"</p><p class="source-code">]);</p></li>
<li>Find the <strong class="source-inline">"has a button element in each li"</strong> test and replace the existing expectations with the following single expectation. Observe that the expectation on the length of the array is no longer necessary if your expectation tests the entire array:<p class="source-code">expect(typesOf(elements("li &gt; *"))).toEqual([</p><p class="source-code">  "button",</p><p class="source-code">  "button",</p><p class="source-code">]);</p></li>
<li>The final three tests pull out the second button on the screen using <strong class="source-inline">elements("button")[1]</strong>. Push this definition up, just below the <strong class="source-inline">beforeEach</strong> block, and give it a more descriptive name:<p class="source-code">const secondButton = () =&gt; elements("button")[1];</p></li>
<li>Now, you can use <a id="_idIndexMarker329"/>this in the three tests. Go ahead and update <a id="_idIndexMarker330"/>them now. For example, the middle test can be updated as follows:<p class="source-code">click(secondButton());</p><p class="source-code">expect(secondButton().className).toContain("toggled");</p></li>
<li>As a final<a id="_idIndexMarker331"/> touch, inline the <strong class="source-inline">listChild</strong> and <strong class="source-inline">listElement</strong> variables that appear in some of the tests – in other words, remove the use of variables and call the function directly within the expectation. As an<a id="_idIndexMarker332"/> example, the <strong class="source-inline">"renders an ol element to display appointments"</strong> test can have its expectation rewritten, as follows:<p class="source-code">expect(element("ol")).not.toBeNull();</p></li>
<li>Run <strong class="source-inline">npm test</strong> one final time and verify that everything is still green.</li>
</ol>
<p class="callout-heading">Not all helpers need to be extracted</p>
<p class="callout">You’ll notice that the helpers you have extracted are all very generic – they make no mention of the specific components under test. It’s good to keep helpers as generic as possible. On the other hand, sometimes it helps to have very localized helper functions. In your test suite, you already have one called <strong class="source-inline">appointmentsTable</strong> and another called <strong class="source-inline">secondButton</strong>. These should remain in the test suite because they are local to the test suite.</p>
<p>In this section, you’ve seen our final technique for simplifying your test suites, which is to pull out fluent helper functions that help keep your expectations short and help them read like plain English.</p>
<p>You've also seen the trick of running expectations on an array of items rather than having an expectation<a id="_idIndexMarker333"/> for individual items. This isn’t always the appropriate course of action. You’ll see an example of this in <a href="B18423_05.xhtml#_idTextAnchor079"><em class="italic">Chapter 5</em></a>, <em class="italic">Adding Complex Form Interactions</em>.</p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor059"/>Summary</h1>
<p>This chapter focused on improving our test suites. Readability is crucially important. Your tests act as specifications for your software. Each component test must clearly state what the expectation of the component is. And when a test fails, you want to be able to understand why it’s failed as quickly as possible.</p>
<p>You’ve seen that these priorities are often in tension with our usual idea of what good code is. For example, in our tests, we are willing to sacrifice performance if it makes the tests more readable.</p>
<p>If you’ve worked with React tests in the past, think about how long an average test was.In this chapter, you've seen a couple of mechanisms for keeping your test short: building domain-specific matchers and extracting little functions for querying the DOM.</p>
<p>You’ve also learned how to pull out React initialization code to avoid clutter in our test suites.</p>
<p>In the next chapter, we’ll move back to building new functionality into our app: data entry with forms.</p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor060"/>Exercises</h1>
<p>Using the techniques you’ve just learned, create a new matcher named <strong class="source-inline">toHaveClass</strong> that replaces the following<a id="_idIndexMarker334"/> expectation:</p>
<pre class="source-code">
expect(secondButton().className).toContain("toggled");</pre>
<p>With your new matcher in place, it should read as follows:</p>
<pre class="source-code">
expect(secondButton()).toHaveClass("toggled"); </pre>
<p>There is also the negated form of this matcher:</p>
<pre class="source-code">
expect(secondButton().className).not.toContain("toggled");</pre>
<p>Your matcher should <a id="_idIndexMarker335"/>work for this form and display an appropriate failure message.</p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor061"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li>The following GitHub repository contains useful matchers for testing React components: <a href="https://github.com/jest-community/jest-extended">https://github.com/jest-community/jest-extended</a></li>
<li>The following link provides the source of Jest’s matcher utilities, which I find useful for figuring out how to write simple matchers: <a href="https://github.com/facebook/jest/tree/main/packages/jest-matcher-utils">https://github.com/facebook/jest/tree/main/packages/jest-matcher-utils</a></li>
</ul>
</div>
</div></body></html>