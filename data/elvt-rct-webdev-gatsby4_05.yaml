- en: '*Chapter 4*: Creating Reusable Templates'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：创建可重用模板'
- en: This chapter is where you will really begin to see the power that Gatsby brings
    to larger sites. You will learn about how we can programmatically create pages
    using reusable templates and data sourced via GraphQL. By the end of this chapter,
    you will have created lists of blog posts, blog pages, and tag pages. You'll also
    understand how to introduce pagination and search functionality to your site.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是您真正开始看到Gatsby为大型网站带来的强大功能的地方。您将了解我们如何使用可重用模板和通过GraphQL获取的数据编程创建页面。到本章结束时，您将创建博客帖子列表、博客页面和标签页面。您还将了解如何将分页和搜索功能引入您的网站。
- en: All the pages we have created up until now have been single instances, meaning
    there is only one copy of that page on the site (for example, our index page,
    of which there will be only one copy ever). But what happens when we consider
    pages such as blog pages? It would be a very laborious process to create a single
    instance page for each post. So, instead, we can use **templates**. A template
    is a multi-instance of a page component that is mapped to data. For every node
    in a GraphQL query, we can create a page using this template and populate it with
    the data of that node.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建的所有页面都是单个实例，这意味着网站上只有一个该页面的副本（例如，我们的索引页面，永远只有一个副本）。但是，当我们考虑像博客页面这样的页面时会发生什么呢？为每篇帖子创建单个实例页面将是一个非常费力的过程。因此，我们可以使用**模板**。模板是页面组件的多实例，它映射到数据。对于GraphQL查询中的每个节点，我们都可以使用这个模板创建一个页面，并用该节点的数据填充它。
- en: Now that we understand what we mean by templates in Gatsby, let's create our
    first few templates, and then **programmatically** create pages with them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了在Gatsby中我们所说的模板是什么，让我们创建我们的第一个几个模板，然后**编程**地使用它们创建页面。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Defining templates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义模板
- en: Creating templates and programmatic page generation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模板和程序化页面生成
- en: Search functionality
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索功能
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will need to have completed [*Chapter 3*](B15983_03_ePub_RK.xhtml#_idTextAnchor057),
    *Sourcing and Querying Data (from Anywhere!)*. You''ll get the most out of this
    chapter if you have a collection of blog posts that we can use to build our pages,
    ingested into Gatsby. The source doesn''t matter – you''ll be ready to start this
    chapter if you can see them in your GraphQL data layer. If you don''t have any
    posts to hand, you can find some placeholder Markdown files that you can ingest
    in Gatsby here: [https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter04/placeholder-markdown](https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter04/placeholder-markdown).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您需要完成[*第3章*](B15983_03_ePub_RK.xhtml#_idTextAnchor057)，*从任何地方获取和查询数据*。如果您有一系列博客帖子，我们可以用来构建我们的页面，并已导入Gatsby，您将充分利用本章。源代码不重要——如果您能在您的GraphQL数据层中看到它们，您就可以开始本章了。如果您没有可用的帖子，您可以在以下位置找到一些占位符Markdown文件，您可以将它们导入Gatsby：[https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter04/placeholder-markdown](https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter04/placeholder-markdown)。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter04](https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter04).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter04](https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter04)找到。
- en: Important Note
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: To keep the code snippets at a manageable size, many of the examples in this
    chapter have styling omitted and comments pointing to code we've already written.
    To see a fully styled version of these components, please navigate to this book's
    code repository.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持代码片段的大小可管理，本章中的许多示例都省略了样式，并带有指向我们已编写的代码的注释。要查看这些组件的完整样式版本，请导航到本书的代码仓库。
- en: Creating templates and programmatic page generation
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模板和程序化页面生成
- en: 'In this section, we will programmatically generate pages using templates. We
    will be creating blog pages, blog list preview pages, and tag pages. To make all
    of this work correctly, it is important to ensure that each node of data that
    you are ingesting to populate blog pages contains the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用模板编程生成页面。我们将创建博客页面、博客列表预览页面和标签页面。为了确保所有这些都能正确工作，重要的是要确保您要填充博客页面的每个数据节点都包含以下内容：
- en: '**Title**: The title of the blog post.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题**: 博客文章的标题。'
- en: '**Description**: A one-line description of what the blog post contains.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**: 对博客文章内容的单行描述。'
- en: '**Date**: The date that the post should be published.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日期**: 文章应该发布的日期。'
- en: '**Tags**: A list of tags that the blog post is associated with.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签**: 与博客文章相关联的标签列表。'
- en: '**Body**: The main content of the post.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正文**: 文章的主要内容。'
- en: If you are sourcing more than one type of content from the same source, it would
    be a good idea to also include a **type** field. This will allow you to filter
    out nodes that don't belong to this type.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从同一来源获取多种类型的内容，最好也包含一个**类型**字段。这将允许你过滤掉不属于此类型的节点。
- en: 'The method for adding these to your nodes will change, depending on the source.
    However, in the case of Markdown, you could create your posts in the following
    format:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这些内容到节点的方法将根据来源而变化。然而，在Markdown的情况下，你可以按照以下格式创建你的文章：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we added `title`, `desc`, `date`, and `tags` to `frontmatter`. Our body
    content would then be everything following `frontmatter`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`title`、`desc`、`date`和`tags`添加到`frontmatter`中。正文内容将是`frontmatter`之后的所有内容。
- en: Important Note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: I will be querying data from local Markdown files within this chapter. If you
    are sourcing content from another type of local or a remote source, you can still
    use all the code except the queries and node field manipulation, which you will
    have to modify to work with your source. If you are struggling to construct your
    queries, refer back to [*Chapter 3*](B15983_03_ePub_RK.xhtml#_idTextAnchor057),
    *Sourcing and Querying Data (from Anywhere!)*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章中查询本地Markdown文件中的数据。如果你从其他类型的本地或远程来源获取内容，你仍然可以使用所有代码，除了查询和节点字段操作，你必须修改以与你的来源一起工作。如果你在构建查询时遇到困难，请参考[*第3章*](B15983_03_ePub_RK.xhtml#_idTextAnchor057)，*从任何地方获取和查询数据*。
- en: Regardless of your source, you should ensure that your content is populated
    with the same fields to ensure GraphQL queries for blog-related data are always
    consistent.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的来源是什么，你应该确保你的内容填充了相同的字段，以确保与博客相关数据的GraphQL查询始终一致。
- en: Now that we have established the necessary blog node data fields, let's create
    blog post pages using our data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了必要的博客节点数据字段，让我们使用我们的数据来创建博客文章页面。
- en: Blog post template
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 博客文章模板
- en: 'In this section, we will create pages for each blog post we have. We will be
    creating and using our first template to do this with the help of the following
    steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为每个博客文章创建页面。我们将通过以下步骤创建和使用我们的第一个模板来完成这项工作：
- en: 'Modify your `gatsby-node.js` file so that it includes the following code:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改你的`gatsby-node.js`文件，使其包含以下代码：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `onCreateNode` function is called whenever a new node is created. Using
    this function, we can transform nodes by adding, removing, or manipulating their
    fields. In this specific case, we are adding a `slug` field if the node is of
    the `MarkdownRemark` type. A `slug` is an address for a specific page on our site,
    so in the case of our blog page, we want every blog post to have a unique `slug`
    where it will render on the site. Creating slugs from filenames can be complicated
    as you need to handle characters that would break URL formatting. Luckily, the
    `gatsby-source-filesystem` plugin ships with a function called `createFilePath`
    for creating them.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`onCreateNode`函数在创建新节点时被调用。使用此函数，我们可以通过添加、删除或操作它们的字段来转换节点。在这种情况下，如果节点是`MarkdownRemark`类型，我们将添加一个`slug`字段。`slug`是我们网站上特定页面的地址，因此在我们的博客页面中，我们希望每个博客文章都有一个独特的`slug`，它将在网站上渲染。从文件名创建slug可能很复杂，因为你需要处理会破坏URL格式的字符。幸运的是，`gatsby-source-filesystem`插件提供了一个名为`createFilePath`的函数来创建它们。'
- en: Verify that each blog page has a `slug` by running your development server and
    using GraphiQL to explore your nodes. If you are using Markdown, you should find
    it within the `fields` object on `MarkdownRemark` nodes.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行你的开发服务器并使用GraphiQL来探索你的节点，验证每个博客页面都有一个`slug`。如果你使用Markdown，你应该在`MarkdownRemark`节点的`fields`对象中找到它。
- en: Create a new folder inside `src` called `templates` to house our page templates.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`目录内创建一个名为`templates`的新文件夹来存放我们的页面模板。
- en: Create a new file inside `templates` called `blog-page.js`. This is the file
    where we will create our blog page template.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`templates`目录内创建一个名为`blog-page.js`的新文件。这是我们创建博客页面模板的文件。
- en: 'Add the following code to the `blog-page.js` file:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`blog-page.js`文件中：
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we are creating the blog post template with a static set of data that
    we will switch out for real content shortly. You can see that we have a heading
    containing our blog post title. We then follow it with the blog's `Date` and a
    `TagList` component, which we will make shortly. Finally, we have the main `Article
    Body`.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个包含静态数据的博客文章模板，稍后我们将用实际内容替换它。您可以看到我们有一个包含博客文章标题的标题。然后我们跟随博客的`日期`和`TagList`组件，我们将在稍后创建它。最后，我们有主要的`文章正文`。
- en: Create a folder inside `src/components` called `blog-posts`, in which we will
    store any component related to the blog.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/components`目录内创建一个名为`blog-posts`的文件夹，我们将在此存储任何与博客相关的组件。
- en: 'Create a `TagList` component in the `src/components/blog-posts` file. We will
    use this component whenever we want to render a list of `tag` badges on the screen:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/components/blog-posts`文件中创建一个`TagList`组件。我们将在需要将屏幕上的`tag`徽章列表渲染时使用此组件：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This component takes in an array of `tags` as a prop, maps over them, and returns
    a styled `div` containing that `tag`. This is all wrapped up in a `Fragment` component.
    By using a `Fragment`, we can avoid enforcing the ordering and positioning of
    our `tags`, and can instead allow the parent element to decide.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此组件接受一个`tags`数组作为属性，遍历它们，并返回一个包含该`tag`的样式`div`。所有这些都包裹在一个`Fragment`组件中。通过使用`Fragment`，我们可以避免强制执行我们的`tags`的排序和定位，而可以允许父元素来决定。
- en: Now that we have created a template file and its components, we can use it within
    our `gatsby-node.js` file.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个模板文件及其组件，我们可以在`gatsby-node.js`文件中使用它。
- en: 'Add the following code to the top of your `gatsby-node.js` file:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到您的`gatsby-node.js`文件顶部：
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we are utilizing the `createPages` function, which allows us to create
    pages dynamically. To ensure you can query all your data, this function is only
    run once all your data has been sourced. Inside this function, we first destructure
    the `actions` object to retrieve the `createPage` function. Then, we tell Gatsby
    where to find our blog post template. With these two pieces in place, we are now
    ready to query our data. You should see a familiar GraphQL query for selecting
    the `slug` from all the Markdown where the type is *Blog*. We then have a small
    `if` statement to catch errors but, assuming it's successful, we then have all
    the data we need to create pages. We can loop through the result of our data and
    loop through every data node, creating a page for each one by specifying a path
    (using `slug`) and our template. You'll also notice that we are defining some
    `context` here. Data that's defined in `context` is available in page queries
    as GraphQL variables, which will make it easy to map the correct Markdown content
    to the correct pages in the following steps. Restart your development server and
    open the development 404 page by navigating to any non-existent route on the port.
    This will display a list of pages on your site, including the pages we have just
    created. Clicking on one should render the static content we defined when creating
    the template. Now that these pages have been created successfully, let's navigate
    back to the template and modify it to retrieve the correct content instead of
    the static content.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们正在使用`createPages`函数，它允许我们动态地创建页面。为了确保您可以查询所有数据，此函数仅在所有数据都已获取后运行一次。在这个函数内部，我们首先解构`actions`对象以检索`createPage`函数。然后，我们告诉Gatsby在哪里可以找到我们的博客文章模板。有了这两部分，我们现在可以查询我们的数据了。您应该会看到一个熟悉的GraphQL查询，用于从所有类型为*Blog*的Markdown中选择`slug`。然后我们有一个小的`if`语句来捕获错误，但假设它是成功的，我们就有创建页面所需的所有数据。我们可以遍历我们的数据结果，遍历每个数据节点，通过指定路径（使用`slug`）和我们的模板为每个节点创建一个页面。您还会注意到我们在这里定义了一些`context`。在`context`中定义的数据可以作为GraphQL变量在页面查询中使用，这将使在以下步骤中将正确的Markdown内容映射到正确的页面变得容易。重新启动您的开发服务器，并通过导航到端口的任何非存在路由来打开开发404页面。这将显示您网站上包括我们刚刚创建的页面的页面列表。点击其中一个应该会渲染我们在创建模板时定义的静态内容。现在，这些页面已成功创建，让我们回到模板并修改它以检索正确的内容而不是静态内容。
- en: 'Modify the `src/templates/blog-post.js` file with the following code:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码修改`src/templates/blog-post.js`文件：
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By restarting your development server and navigating to one of your blog pages
    again, you should now see it populated with its node data. You've successfully
    made your first programmatic pages!
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过重新启动您的开发服务器并再次导航到您的某个博客页面，您现在应该会看到它用其节点数据填充了。您已成功创建了第一个程序化页面！
- en: 'As we only have a few blog posts, creating all of these pages won''t take very
    long. However, what happens if you have thousands of pages to create? Instead
    of waiting for all your site pages to build, you can instruct Gatsby to defer
    the generation of some of these pages. You can do this by passing `defer:true`
    to the `createPage` function in `gatsby-node.js`, like so:'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们只有少数几篇博客文章，创建所有这些页面不会花费太多时间。然而，如果您需要创建数千个页面，会发生什么？您不必等待所有网站页面构建完成，可以指示Gatsby延迟生成一些页面。您可以通过在`gatsby-node.js`中的`createPage`函数传递`defer:true`来实现这一点，如下所示：
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this change, any page that's created in this way will be built the first
    time that that page is requested instead of at build time. This feature changes
    the kind of build from a static build to a hybrid build. For more information
    on this difference, please read [*Chapter 9*](B15983_09_ePub_RK.xhtml#_idTextAnchor127),
    *Deployment and Hosting*.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这次改动，任何以这种方式创建的页面将在第一次请求该页面时构建，而不是在构建时构建。这个特性将构建类型从静态构建改为混合构建。有关这种差异的更多信息，请参阅[*第9章*](B15983_09_ePub_RK.xhtml#_idTextAnchor127)，*部署和托管*。
- en: Now that we have created blog post pages, we must have some way of linking to
    them from our other pages. Let's create a blog preview template page, where we
    can have a list of our blog posts with previews and a link to the pages we have
    just created.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了博客文章页面，我们必须有一种方法从我们的其他页面链接到它们。让我们创建一个博客预览模板页面，在那里我们可以列出我们的博客文章预览和链接到我们刚刚创建的页面。
- en: Blog preview template
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 博客预览模板
- en: 'While we could create a single list of blog posts and render it, it is a standard
    pattern for websites to divide lists of blog posts, articles, and products using
    **pagination**. Using pagination within your site has three main benefits:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以创建一个博客文章的单个列表并渲染它，但使用**分页**来分割网站上的博客文章列表、文章和产品列表是一个标准模式。在您的网站上使用分页有三个主要好处：
- en: '**Better page performance**: If every article includes an image in the preview,
    then with every added item, we are increasing the amount of data we need to transfer
    to the client significantly. By introducing pagination, the client will only download
    small segments of data as they browse a group of items. This leads to faster page
    load times, which is particularly important in areas with low bandwidth.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的页面性能**：如果每篇文章的预览中都包含一张图片，那么随着每个项目的添加，我们需要传输到客户端的数据量将显著增加。通过引入分页，客户端在浏览一组项目时只会下载小部分数据。这导致页面加载时间更快，这在带宽较低的地区尤为重要。'
- en: '**Improved user experience**: Displaying all the content on a single page could
    overwhelm the user, so instead, we must break down our content into small and
    manageable chunks.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进的用户体验**：在单个页面上显示所有内容可能会让用户感到不知所措，因此，我们必须将内容分解成小而可管理的块。'
- en: '**Easier navigation**: If we render hundreds of products in one continuous
    list, the user will have no idea how many products are there while scrolling through.
    By breaking content down into multiple pages with a set quantity of products on
    each, the user can understand the scale of your content better.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更便捷的导航**：如果我们在一个连续的列表中渲染数百个产品，用户在滚动时将无法知道有多少产品。通过将内容拆分为多个页面，每个页面有固定数量的产品，用户可以更好地理解您的内容规模。'
- en: 'With all that in mind, let''s create a paginated blog preview page using a
    template:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，让我们使用模板创建一个分页的博客预览页面：
- en: 'Create a `Pagination` component in the `src/components/blog-posts` file:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/components/blog-posts`文件中创建一个`Pagination`组件：
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we have created the component that will allow us to access paginated
    blog preview pages. The component contains the number of pages and the current
    page as props. Using these two pieces of information, we can determine whether
    a user can navigate forward or back from their current page. How this component
    works is best explained by seeing how it renders:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个组件，它将允许我们访问分页的博客预览页面。该组件包含页数和当前页作为属性。使用这两条信息，我们可以确定用户是否可以从当前页面导航到下一页或上一页。这个组件的工作原理最好通过查看它的渲染方式来解释：
- en: '![Figure 4.1 – Pagination component states'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图4.1 – 分页组件状态'
- en: '](img/Figure_4.1_B15983.jpg)'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_4.1_B15983.jpg)'
- en: Figure 4.1 – Pagination component states
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.1 – 分页组件状态
- en: In the first case, the current page is **1**, so there is no need to render
    a **Previous** button. Instead, we only show the preceding pages and the **Next**
    button. In the second case, we are on page **2**, where the user can navigate
    both forward and back, and as such, we can render the **Previous** and **Next**
    buttons. In the last case, we are on the last page, so we don't need to render
    the **Next** button.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第一种情况下，当前页面是**1**，因此不需要渲染**上一页**按钮。相反，我们只显示前一页和**下一页**按钮。在第二种情况下，我们处于第**2**页，用户可以前后导航，因此我们可以渲染**上一页**和**下一页**按钮。在最后一种情况下，我们处于最后一页，因此不需要渲染**下一页**按钮。
- en: 'Create a new template in `src/templates/` called `blog-preview.js` and add
    the following page query:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/templates/`中创建一个新的模板，命名为`blog-preview.js`，并添加以下页面查询：
- en: '[PRE8]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The query within this file sources data from `allMarkdownRemark` (which I have
    named `blogposts` in this query). The `blogposts` query retrieves all the Markdown
    where the `frontmatter` type is equal to `Blog`. It sorts the collection of posts
    by descending `date`. Here's where things get interesting – we also provide a
    `skip` and `limit` to the query. `skip` tells the query how many documents from
    the collection to skip over, while `limit` tells the query to limit the number
    of results to that quantity. We will be providing `skip` and `limit` to the page
    context, as well as `numPages` and `currentPage`, within our `gatsby-config.js`
    file.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件中的查询从`allMarkdownRemark`（我在此查询中命名为`blogposts`）获取数据。`blogposts`查询检索所有`frontmatter`类型等于`Blog`的Markdown。它按降序对帖子集合进行排序。这里事情变得有趣
    - 我们还向查询提供了`skip`和`limit`。`skip`告诉查询跳过集合中的多少个文档，而`limit`告诉查询限制结果的数量。我们将在`gatsby-config.js`文件中提供`skip`和`limit`，以及`numPages`和`currentPage`。
- en: 'Create the page component before the query in the `blog-preview.js` file:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`blog-preview.js`文件中，在查询之前创建页面组件：
- en: '[PRE9]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As with our other queries, when the query at the end of this file runs, it will
    provide `data` to our page via the `data` prop. Here, we are destructuring `pageContext`
    to access `numPages` and `currentPage`. We are also using destructuring `data`
    to get `nodes` from the `blogposts` query. We will add our render via the `return`
    statement in the following step.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像我们的其他查询一样，当文件末尾的查询运行时，它将通过`data`属性为我们的页面提供`data`。在这里，我们正在解构`pageContext`以访问`numPages`和`currentPage`。我们也在使用解构`data`来获取`blogposts`查询中的`nodes`。我们将在下一步的`return`语句中添加我们的渲染。
- en: 'Create the `return` statement in this same file:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中创建`return`语句：
- en: '[PRE10]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We use `nodes` from the two sources to map through posts, render a preview of
    each (making use of the `TagList` component), as well as render our `Pagination`
    component. Now that we have created our template, we can ingest it into our `gatsby-config.js`
    file.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用两个来源的`nodes`来遍历帖子，渲染每个帖子的预览（利用`TagList`组件），以及渲染我们的`Pagination`组件。现在我们已经创建了模板，我们可以将其导入到我们的`gatsby-config.js`文件中。
- en: 'Modify your `gatsby-config.js` file''s `createPages` function with the following
    code:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改你的`gatsby-config.js`文件的`createPages`函数，使用以下代码：
- en: '[PRE11]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You are now ready to start your development server to verify that pagination
    is working. You should see your posts in descending date order located at `/blog`.
    If you have more posts than your `postsPerPage` value, you should also see your
    `Pagination` component, showing you that there are additional pages and allowing
    you to navigate there.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以开始启动你的开发服务器以验证分页是否正常工作。你应该在`/blog`位置看到按降序排列的帖子。如果你有比`postsPerPage`值更多的帖子，你应该也会看到你的`Pagination`组件，这表明有额外的页面，并允许你导航到那里。
- en: Now that we have implemented a blog preview page, let's use what we have learned
    to create one more collection of pages – tag pages.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了博客预览页面，让我们利用所学知识创建另一个页面集合 - 标签页面。
- en: Tag page template
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签页面模板
- en: As a user, seeing my posts in date order is not always enough – I may want to
    be able to find groups of posts associated with a single topic. Tag pages are
    pages you navigate to whenever you click on one of a blog post's tags. Navigating
    to one of these pages, you are presented with a list of posts that are associated
    with that tag.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 作为用户，看到我的帖子按日期排序并不总是足够的 - 我可能希望能够找到与单个主题相关的帖子组。标签页面是在点击博客帖子中的一个标签时导航到的页面。导航到这些页面之一，你会看到一个与该标签相关的帖子列表。
- en: 'Let''s programmatically create tag pages for each tag that''s present in our
    articles:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们程序化地为文章中存在的每个标签创建标签页面：
- en: 'Install `lodash`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`lodash`：
- en: '[PRE12]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`lodash` is a JavaScript utility library that we will be using to make tags
    URL-friendly. Because a single tag might consist of multiple words, we need a
    way to remove the spaces. While you could create a function yourself to do this,
    `lodash` has a `.kebabCase()` function that works well for this use case.'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`lodash` 是一个 JavaScript 工具库，我们将使用它来使标签 URL 友好。因为一个标签可能由多个单词组成，我们需要一种方法来删除空格。虽然你可以自己创建一个函数来做这件事，但
    `lodash` 有一个 `.kebabCase()` 函数非常适合这个用例。'
- en: 'Modify the `TagList` component to turn our `tag` badges into `Link` components:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `TagList` 组件，将我们的 `tag` 徽章转换为 `Link` 组件：
- en: '[PRE13]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As `Link` components, they need a `to` prop. This prop should point to where
    your `tag` pages will be created – in our case, `/tags/tag-name` is the location.
    We can use the `kebabCase` function from `lodash` to ensure that any spaces in
    tags are turned into hyphens.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为 `Link` 组件，它们需要一个 `to` 属性。这个属性应该指向你的 `tag` 页面将被创建的位置——在我们的例子中，`/tags/tag-name`
    是位置。我们可以使用 `lodash` 中的 `kebabCase` 函数来确保标签中的任何空格都被转换为连字符。
- en: 'Create a `tags.js` file in the `src/templates` folder:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/templates` 文件夹中创建一个 `tags.js` 文件：
- en: '[PRE14]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This component will appear very similar to our previously constructed `blog-preview.js`
    file in the *Blog preview template* section, except for a minor change to the
    query. In this query, we still source our Markdown content, but this time, we
    filter out the posts that do not contain the page's tag.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此组件将非常类似于我们在“博客预览模板”部分之前构建的 `blog-preview.js` 文件，除了对查询进行了一些小的修改。在这个查询中，我们仍然获取我们的
    Markdown 内容，但这次我们过滤掉了不包含页面标签的帖子。
- en: 'Create the page component before the query in the `tags.js` file:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `tags.js` 文件中的查询之前创建页面组件：
- en: '[PRE15]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The page then renders a paragraph containing the tag you are currently filtering
    posts with, followed by the filtered list of posts. Each post preview is rendered
    with its `title`, `date`, description (`desc`), and `tags`, just like in the `blog-preview.js`
    file.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 页面随后渲染一个包含你当前过滤帖子所用的标签的段落，后面跟着过滤后的帖子列表。每个帖子预览都以其 `title`、`date`、描述（`desc`）和
    `tags` 进行渲染，就像在 `blog-preview.js` 文件中一样。
- en: Important Note
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you intend to render the same items in the lists of both your `blog-preview.js`
    and `tags.js` files, then you should probably abstract the item preview component
    into a separate component. To keep these examples independent, I will not do this
    here.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你打算在 `blog-preview.js` 和 `tags.js` 文件中的列表中渲染相同的条目，那么你可能应该将条目预览组件抽象成一个单独的组件。为了保持这些示例的独立性，我这里不会这样做。
- en: 'Import `lodash` into the top of your `gatsby-config.js` file, next to the other
    imports:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `lodash` 导入到 `gatsby-config.js` 文件的顶部，靠近其他导入：
- en: '[PRE16]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We will need to use lodash's `kebabCase` in this file as well.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还需要在这个文件中使用 lodash 的 `kebabCase`。
- en: 'Add your tag template and query to your `gatsby-config.js` files'' `createPages`
    function:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的标签模板和查询添加到 `gatsby-config.js` 文件中的 `createPages` 函数：
- en: '[PRE17]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You are now ready to start your development server to verify that the tag pages
    are working. Navigate to the development 404 page; you should see a page starting
    with `tags/` for each tag. Clicking on one of these, you should be presented with
    our tag page template and a list of blog posts associated with that tag.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以开始启动你的开发服务器以验证标签页面是否正常工作。导航到开发 404 页面；你应该看到每个标签都有一个以 `tags/` 开头的页面。点击其中一个，你应该会看到我们的标签页面模板和与该标签相关的博客帖子列表。
- en: Further Exercise
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 进一步练习
- en: We've learned how to paginate blog lists, as well as create tag pages. Why not
    take this one step further and paginate your tag pages?
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经学会了如何分页博客列表，以及创建标签页面。为什么不更进一步，对标签页面进行分页呢？
- en: With that, we have learned how to programmatically create pages for blog posts,
    blog lists, and tags. Now, let's turn our attention to how we might create a site
    search so that as the site expands, finding our blog's content is easier.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学会了如何以编程方式为博客文章、博客列表和标签创建页面。现在，让我们关注我们如何创建一个网站搜索，以便随着网站的扩展，找到我们的博客内容变得更加容易。
- en: Search functionality
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索功能
- en: There are many different ways of integrating a site search. Many options are
    both hosted and local. For small projects, such as the site we are creating, it's
    often better to opt for a local index solution as the number of pages you are
    searching through is never that large. This also means that your site search will
    work in offline scenarios, which can be a real plus.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 集成网站搜索的方法有很多种。许多选项既可以是托管也可以是本地。对于像我们正在创建的这样的小型项目，通常选择本地索引解决方案会更好，因为你搜索的页面数量永远不会很大。这也意味着你的网站搜索将在离线场景中工作，这可以是一个真正的加分项。
- en: '`elasticlunr` Gatsby plugin, content is indexed and then made available via
    GraphQL to `elasticlunr` index. Search queries can then be made against this index
    to retrieve page information.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`elasticlunr` Gatsby 插件，内容被索引然后通过 GraphQL 供 `elasticlunr` 索引使用。然后可以对此索引进行搜索查询以检索页面信息。'
- en: 'Let''s integrate a site search using `elasticlunr`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `elasticlunr` 集成站点搜索：
- en: 'Install the `elasticlunr` Gatsby plugin:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `elasticlunr` Gatsby 插件：
- en: '[PRE18]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the `elasticlunr` plugin to your `gatsby-config.js` plugins array:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `elasticlunr` 插件添加到你的 `gatsby-config.js` 插件数组中：
- en: '[PRE19]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As part of `options`, we provide the plugin with a list of `fields` that we
    would like to index. Then, we give it a `resolvers` object, which explains how
    to resolve `fields` for a source. Within our blog posts, we can retrieve `title`,
    `tags`, and `desc` from `frontmatter`. We can construct `path` with that specific
    content with a string and the data's `slug`. Finally, we also pass a `filter`.
    This `filter` tells the plugin to only use nodes where the `frontmatter` type
    is of the `Blog` type, as it is only our blog pages that we want to be searchable
    at this moment.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为 `options` 的一部分，我们向插件提供了一个我们希望索引的 `fields` 列表。然后，我们给它一个 `resolvers` 对象，该对象解释了如何解析源中的
    `fields`。在我们的博客文章中，我们可以从 `frontmatter` 中检索 `title`、`tags` 和 `desc`。我们可以使用特定的内容和数据的
    `slug` 来构造 `path`。最后，我们还传递了一个 `filter`。这个 `filter` 告诉插件只使用 `frontmatter` 类型为 `Blog`
    的节点，因为我们只想在这个时候让我们的博客页面可搜索。
- en: 'Create a `Search.js` component in the `src/layout` folder:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/layout` 文件夹中创建一个 `Search.js` 组件：
- en: '[PRE20]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `Search` component takes in `searchIndex` as a prop. One of the first things
    you will notice is a `useEffect` hook that loads the index into a state hook.
    Once we have loaded in the index, we can query it.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Search` 组件接收 `searchIndex` 作为属性。你首先会注意到一个 `useEffect` 钩子，它会将索引加载到状态钩子中。一旦我们加载了索引，我们就可以查询它。'
- en: 'Create a `search` function below `useEffect`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `useEffect` 下方创建一个 `search` 函数：
- en: '[PRE21]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You will see that whenever the `search` function is called, we `search` the
    index using our `query` string. You will notice that we are passing in `expand:
    query.length > 2` as an option to the `search` function. This tells `elasticlunr`
    to allow partial matches if more than two characters have been entered. If you
    allow partial matches for fewer characters, you will often find that you get an
    abundance of results that are not related to what the user is looking for. Once
    we have searched the index, we can `map` over `documentStore` within `index` and
    return the document results, which are then passed to state via the `useState`
    hook.'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '你会看到每当调用 `search` 函数时，我们都会使用我们的 `query` 字符串来搜索索引。你会注意到我们向 `search` 函数传递了 `expand:
    query.length > 2` 作为选项。这告诉 `elasticlunr` 允许输入超过两个字符时的部分匹配。如果你为更少的字符允许部分匹配，你经常会发现你得到了大量与用户所查找内容不相关的结果。一旦我们搜索了索引，我们就可以在
    `index` 中的 `documentStore` 上进行 `map` 操作，并返回文档结果，这些结果随后通过 `useState` 钩子传递到状态中。'
- en: 'Create the `search` result render function:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `search` 结果渲染函数：
- en: '[PRE22]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We `map` over results from the state using the `results` value from the `useState`
    hook and render the results to the screen within our render function. For a slightly
    better user experience, it's often a good idea to include a `searchResultSize`
    constant. This value determines the maximum number of results to display. This
    stops cases where you have hundreds of results and see the overlay run off the
    page. Instead, if there are more results, we simply indicate to the user how many
    more results there are.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `useState` 钩子的 `results` 值在状态的结果上 `map`，并在渲染函数中将结果渲染到屏幕上。为了获得更好的用户体验，通常一个好的做法是包含一个
    `searchResultSize` 常量。此值决定了要显示的最大结果数。这阻止了你有数百个结果时页面覆盖的情况。相反，如果有更多结果，我们只需向用户指示还有多少个结果。
- en: 'Modify your `Header.js` file to retrieve the site index and pass it to your
    `Search` component:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改你的 `Header.js` 文件以检索站点索引并将其传递给你的 `Search` 组件：
- en: '[PRE23]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now that we have completed our search functionality, restart your development
    server. You should see that the header of our site now contains our `Search` component.
    Try typing in a few characters and click on one of the results. You should be
    navigated to the corresponding page.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了搜索功能，重新启动你的开发服务器。你应该会看到我们网站的页眉现在包含了我们的 `Search` 组件。尝试输入几个字符并点击其中一个结果。你应该会被导航到相应的页面。
- en: By adjusting the resolvers and using the same methodology and tools outlined
    here, we could add pages of different types to our results to create a true site-wide
    search.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调整解析器和使用这里概述的方法和工具，我们可以将不同类型的页面添加到结果中，以创建真正的全站搜索。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to programmatically create pages using reusable
    templates. You should feel confident that you can now create pages using any GraphQL
    data source. We've implemented a list of blog posts with pagination, blog pages,
    tag pages, and created a site search for blog posts that even works offline.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用可重用的模板编程创建页面。你应该有信心现在可以使用任何 GraphQL 数据源创建页面。我们已经实现了一个带有分页的博客文章列表、博客页面、标签页面，并为博客文章创建了一个即使在离线状态下也能工作的网站搜索功能。
- en: In the next chapter, we will master the art of adding images to our Gatsby site.
    First, we will learn why importing images is not that simple, before creating
    images that progressively load in and are performant.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将掌握将图片添加到我们的 Gatsby 网站中的艺术。首先，我们将了解为什么导入图片并不那么简单，然后再创建那些渐进式加载且性能良好的图片。
