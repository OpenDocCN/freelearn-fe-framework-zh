<html><head></head><body>
<div id="_idContainer058">
<h1 class="chapter-number" id="_idParaDest-122"><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-123"><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.2.1">Exploring Reactivity with RxJS</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In a web application, one of the most challenging tasks is dealing with the asynchronous nature of the web. </span><span class="koboSpan" id="kobo.3.2">An application cannot predict when events such as requests to the backend, changing routes, and simple user interactions will happen. </span><span class="koboSpan" id="kobo.3.3">Imperative programming in these cases is more complex and susceptible </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">to errors.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">The RxJS library that makes up the Angular ecosystem aims to make controlling asynchronous flows simpler using declarative and </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">reactive programming.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Observables </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">and operators</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Handling data – </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">transformation operators</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Another way to subscribe – the </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">async pipe</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Connecting information flows – </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">high-order operators</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Optimizing data consumption – </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">filter operators</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">How to choose the </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">correct operator</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.21.1">By the end of the chapter, you will be able to create better experiences for your users by integrating their actions with </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">backend requests.</span></span></p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor244"/><span class="koboSpan" id="kobo.23.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.24.1">To follow the instructions in this chapter, you’ll need </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.26.1">Visual Studio </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">Code (</span></span><a href="https://code.visualstudio.com/Download"><span class="No-Break"><span class="koboSpan" id="kobo.28.1">https://code.visualstudio.com/Download</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.29.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">Node.js 18 or </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">higher (</span></span><a href="https://nodejs.org/en/download/"><span class="No-Break"><span class="koboSpan" id="kobo.32.1">https://nodejs.org/en/download/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.33.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.34.1">The code files for this chapter are available </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">at </span></span><a href="https://github.com/PacktPublishing/Angular-17-Design-Patterns-and-Best-Practices/tree/main/ch9"/><a href="https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch9"/><span class="No-Break"><span class="koboSpan" id="kobo.36.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">During this chapter, remember to run the backend of the application found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">gym-diary-backend</span></strong><span class="koboSpan" id="kobo.39.1"> folder with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">npm </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">start</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.42.1"> command.</span></span></p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor245"/><span class="koboSpan" id="kobo.43.1">Observables and operators</span></h1>
<p><span class="koboSpan" id="kobo.44.1">Up until this point, we’ve used observables </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.45.1">as a way to capture the data that came from the backend API using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">subscribe</span></strong><span class="koboSpan" id="kobo.47.1"> method, but let’s take a step back and ask what an observable is and why we don’t just use </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">JavaScript promises.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">Let’s use a table to organize </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">our explanation:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.51.1">Single</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.52.1">Multiple</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.53.1">Synchronous</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.54.1">Function</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.55.1">Iterator</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.56.1">Asynchronous</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.57.1">Promise</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.58.1">Observable</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.59.1">Table 9.1 – Types of objects by requirement</span></p>
<p><span class="koboSpan" id="kobo.60.1">When we need to perform synchronous processing and expect a return value, we use a function. </span><span class="koboSpan" id="kobo.60.2">If we need a collection of synchronous values, we use an object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">Iterator</span></strong><span class="koboSpan" id="kobo.62.1"> type. </span><span class="koboSpan" id="kobo.62.2">We use promises when we need the return value of a function, but its processing </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">is asynchronous.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">But what can we use for asynchronous processing that does not return a value but a collection of values that can be distributed over time as events? </span><span class="koboSpan" id="kobo.64.2">The answer to that need is </span><strong class="bold"><span class="koboSpan" id="kobo.65.1">an observable</span></strong><span class="koboSpan" id="kobo.66.1">! </span><span class="koboSpan" id="kobo.66.2">With this data structure, we can capture a series of events in time and declaratively make our application react to </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">these events.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">Regarding the use of promises for HTTP requests, we can use them, but tasks that are verbose and complex to perform when using promises can be done using observables and RxJS instead. </span><span class="koboSpan" id="kobo.68.2">We can say that everything a promise can do, an observable is also capable of doing, but vice versa, this </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">becomes complex.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">In Angular, most </span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.71.1">asynchronous events are mapped and controlled by observables. </span><span class="koboSpan" id="kobo.71.2">In addition to HTTP requests, user typing, the exchange of routes by the application, and even the life cycle of components are controlled by observables as they are events that occur </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">We can think of these events as flows of information, and RxJS and the concept of observables can manipulate these flows and make our application react to them. </span><span class="koboSpan" id="kobo.73.2">The main resources for manipulating this flow are the RxJS operators, which are functions that receive and return data to </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">this flow.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">In the next section, we’ll start with</span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.76.1"> the operator that will transform the </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">stream data</span><a id="_idTextAnchor246"/><span class="koboSpan" id="kobo.78.1">.</span></span></p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor247"/><span class="koboSpan" id="kobo.79.1">Handling data – transformation operators</span></h1>
<p><span class="koboSpan" id="kobo.80.1">In our </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">DiaryComponent</span></strong><span class="koboSpan" id="kobo.82.1"> application </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.83.1">component, which renders a list of diary entries, we can notice that our component needs to know the details of the return value taken from the API, in which case the detail is returned in an attribute </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">item</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">Let’s refactor </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.88.1">the service to return just what the component needs already formatted, abstracting the structure of </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">the API.</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">ExerciseSetsService</span></strong><span class="koboSpan" id="kobo.92.1"> service, we will refactor the </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">following methods:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.94.1">
import { Observable, </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">map</span></strong><span class="koboSpan" id="kobo.96.1"> } from 'rxjs';
. </span><span class="koboSpan" id="kobo.96.2">. </span><span class="koboSpan" id="kobo.96.3">.
</span><span class="koboSpan" id="kobo.96.4">export class ExerciseSetsService {
. </span><span class="koboSpan" id="kobo.96.5">. </span><span class="koboSpan" id="kobo.96.6">.
</span><span class="koboSpan" id="kobo.96.7">  getInitialList(): Observable&lt;ExerciseSetList&gt; {
    const headers = new HttpHeaders().set('X-TELEMETRY', 'true');
    return this.httpClient
      .get&lt;ExerciseSetListAPI&gt;(this.url, { headers })
      .pipe(map((api) =&gt; api?.items));
  }
  refreshList(): Observable&lt;ExerciseSetList&gt; {
    return this.httpClient
      .get&lt;ExerciseSetListAPI&gt;(this.url)
      .pipe(map((api) =&gt; api?.items));
  }
. </span><span class="koboSpan" id="kobo.96.8">. </span><span class="koboSpan" id="kobo.96.9">.
</span><span class="koboSpan" id="kobo.96.10">}</span></pre> <p><span class="koboSpan" id="kobo.97.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">getInitialList</span></strong><span class="koboSpan" id="kobo.99.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">refreshList</span></strong><span class="koboSpan" id="kobo.101.1"> methods of the service, we are calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">pipe</span></strong><span class="koboSpan" id="kobo.103.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">Observable</span></strong><span class="koboSpan" id="kobo.105.1"> object. </span><span class="koboSpan" id="kobo.105.2">This method is fundamental to understanding RxJS since, through it, we can define which operators will act in the flow of information that the observable </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">is enveloping.</span></span></p>
<p><span class="koboSpan" id="kobo.107.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">pipe</span></strong><span class="koboSpan" id="kobo.109.1"> method </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.110.1">also returns an observable, and </span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.111.1">when the component calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">subscribe</span></strong><span class="koboSpan" id="kobo.113.1"> method, its result will go through all the operators and deliver the result. </span><span class="koboSpan" id="kobo.113.2">For our needs, we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">map</span></strong><span class="koboSpan" id="kobo.115.1"> operator, which receives the data that the observable is processing and returns the other data that will be used by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">next</span></strong><span class="koboSpan" id="kobo.117.1"> operator or, at the end, by the component that made </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">the subscription.</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">In this case, the operator receives an object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">ExerciseSetListAPI</span></strong><span class="koboSpan" id="kobo.121.1"> type and we will return the item element that is contained in it to the component, which is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">ExerciseSetList </span></strong><span class="koboSpan" id="kobo.123.1">type. </span><span class="koboSpan" id="kobo.123.2">With this change, VS Code, together with Angular’s Language Server (for more details on how to configure this, read </span><a href="B19562_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.124.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.125.1">, </span><em class="italic"><span class="koboSpan" id="kobo.126.1">Starting Projects the Right Way</span></em><span class="koboSpan" id="kobo.127.1">), will point out errors in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">diary.resolver.ts</span></strong><span class="koboSpan" id="kobo.129.1"> file. </span><span class="koboSpan" id="kobo.129.2">We will correct it </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.131.1">
export const diaryResolver: ResolveFn&lt;ExerciseSetList&gt; = (route, state) =&gt; {
  const exerciseSetsService = inject(ExerciseSetsService);
  return exerciseSetsService.getInitialList();
};</span></pre> <p><span class="koboSpan" id="kobo.132.1">As the service now returns journal entries and no longer the entire structure of the API return, we </span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.133.1">change the type that the function returns. </span><span class="koboSpan" id="kobo.133.2">Note</span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.134.1"> that RxJS uses TypeScript to improve the </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">developer’s experience.</span></span></p>
<p><span class="koboSpan" id="kobo.136.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">DiaryRoutingModule</span></strong><span class="koboSpan" id="kobo.138.1"> module, let’s refactor the use of the resolver that </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">we fixed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.140.1">
const routes: Routes = [
  {
    path: '',
    children: [
      {
        path: '',
        component: DiaryComponent,
        title: 'Diary',
        resolve: { exerciseList: diaryResolver },
      },
. </span><span class="koboSpan" id="kobo.140.2">. </span><span class="koboSpan" id="kobo.140.3">.
</span><span class="koboSpan" id="kobo.140.4">  },
];</span></pre> <p><span class="koboSpan" id="kobo.141.1">It is important to name your project variables as clearly as possible; in this case, we have changed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">route</span></strong><span class="koboSpan" id="kobo.143.1"> attribute to </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">exerciseList</span></strong><span class="koboSpan" id="kobo.145.1">. </span><span class="koboSpan" id="kobo.145.2">What we need to do to finish this task is to refactor the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">DiaryComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.147.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.148.1">
export class DiaryComponent implements OnInit {
 . </span><span class="koboSpan" id="kobo.148.2">. </span><span class="koboSpan" id="kobo.148.3">.
 </span><span class="koboSpan" id="kobo.148.4">ngOnInit(): void {
   this.route.data.subscribe(({ exerciseList }) =&gt; {
     this.exerciseList = exerciseList;
   });
 }
 newList() {
   this.exerciseSetsService
     .refreshList()
     .subscribe((exerciseList) =&gt; (this.exerciseList = exerciseList));
 }
. </span><span class="koboSpan" id="kobo.148.5">. </span><span class="koboSpan" id="kobo.148.6">.
</span><span class="koboSpan" id="kobo.148.7">}</span></pre> <p><span class="koboSpan" id="kobo.149.1">With the </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.150.1">use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">map</span></strong><span class="koboSpan" id="kobo.152.1"> operator in the service, now, in </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.153.1">the component, we only pass the list of exercises, so the component does not need to know the implementation and the details of </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">the API.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">In the next section, we will see another way </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">to s</span><a id="_idTextAnchor248"/><span class="koboSpan" id="kobo.157.1">ubscribe.</span></span></p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor249"/><span class="koboSpan" id="kobo.158.1">Another way to subscribe – the async pipe</span></h1>
<p><span class="koboSpan" id="kobo.159.1">To demonstrate</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.160.1"> the versatility of RxJS in an Angular application, we will perform the task of adding a search for exercises in our backend to the diary entry </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">inclusion form.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">Following the good practices of an Angular application, we will create an interface that will represent the exercises. </span><span class="koboSpan" id="kobo.162.2">From the command line of the operating system, we will use the </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">Angular CLI:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.164.1">
ng g interface diary/interfaces/exercise</span></pre> <p><span class="koboSpan" id="kobo.165.1">In the file generated by the Angular CLI, we define the structure of the </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">API return:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.167.1">
export interface Exercise {
  id?: string;
  description: string;
}
export type ExerciseList = Array&lt;Exercise&gt;;
export interface ExerciseListAPI {
  hasNext: boolean;
  items: ExerciseList;
}</span></pre> <p><span class="koboSpan" id="kobo.168.1">We are</span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.169.1"> using interfaces to define the return of the API and a type to define a list of exercises. </span><span class="koboSpan" id="kobo.169.2">The next step is to create the service that will fetch this information, again using the </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">Angular CLI:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.171.1">
ng g service diary/services/exercises</span></pre> <p><span class="koboSpan" id="kobo.172.1">With the structure of the service created by the Angular CLI, we will complete the logic of </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">the service:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.174.1">
export class ExercisesService {
  private httpClient = inject(HttpClient);
  private url = 'exercises';
  getExercises(filter?: string): Observable&lt;ExerciseList&gt; {
    const headers = new HttpHeaders().set('X-LOADING', 'false');
    filter = filter ? </span><span class="koboSpan" id="kobo.174.2">`?filter=${filter}` : '';
    return this.httpClient
      .get&lt;ExerciseListAPI&gt;(`${this.url}${filter}`, { headers })
      .pipe(map((api) =&gt; api?.items));
  }
}</span></pre> <p><span class="koboSpan" id="kobo.175.1">In the service, we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">HttpClient</span></strong><span class="koboSpan" id="kobo.177.1"> Angular service because we are going to query an API, and we are adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">X-LOADING</span></strong><span class="koboSpan" id="kobo.179.1"> header with </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">false</span></strong><span class="koboSpan" id="kobo.181.1"> to the request because, here, we don’t want the loading screen to search </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">for exercises.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">If the </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.184.1">component passes a filter, we will add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">get</span></strong><span class="koboSpan" id="kobo.186.1"> URL. </span><span class="koboSpan" id="kobo.186.2">Finally, we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">map</span></strong><span class="koboSpan" id="kobo.188.1"> operator that we saw in the previous section because we don’t want the component to worry about knowing the structure of </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">the API.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">With the service created, we can change the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">NewEntryFormReactiveComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.192.1"> form:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.193.1">
export class NewEntryFormReactiveComponent implements OnInit {
. </span><span class="koboSpan" id="kobo.193.2">. </span><span class="koboSpan" id="kobo.193.3">.
</span><span class="koboSpan" id="kobo.193.4">  private exerciseService = inject(ExercisesService);
  public showSuggestions: boolean = false;
  public exercises$ = this.exerciseService.getExercises();
  selectExercise(suggestion: string) {
    this.entryForm.get('exercise')?.setValue(suggestion);
    this.toggleSuggestions(false);
  }
  toggleSuggestions(turnOn: boolean) {
    this.showSuggestions = turnOn;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.194.1">Here we are first injecting the service we created and creating an attribute to control when to show the exercises list </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">or not.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">exercises$</span></strong><span class="koboSpan" id="kobo.198.1"> attribute will contain the observable that the service will return. </span><span class="koboSpan" id="kobo.198.2">One detail that you may have noticed is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">$</span></strong><span class="koboSpan" id="kobo.200.1"> symbol here. </span><span class="koboSpan" id="kobo.200.2">Using this postfix for variables and attributes that are observables is a community convention. </span><span class="koboSpan" id="kobo.200.3">It is not an obligation, but you will often see this symbol in code bases that </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">use RxJS.</span></span></p>
<p><span class="koboSpan" id="kobo.202.1">We also created two methods that will be triggered when the user selects an exercise from the list. </span><span class="koboSpan" id="kobo.202.2">Let’s change</span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.203.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">form template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.205.1">
. </span><span class="koboSpan" id="kobo.205.2">. </span><span class="koboSpan" id="kobo.205.3">.
</span><span class="koboSpan" id="kobo.205.4">    &lt;input
      type="text"
      id="exercise"
      name="exercise"
      class="w-full appearance-none rounded border px-3 py-2 leading-tight text-gray-700 shadow"
      formControlName="exercise"
      (focus)="toggleSuggestions(true)"
    /&gt;
    &lt;ul
      class="absolute z-10 mt-2 w-auto rounded border border-gray-300 bg-white"
      *ngIf="showSuggestions"
    &gt;
      &lt;li
        *ngFor="let suggestion of exercises$ | async"
        class="cursor-pointer px-3 py-2 hover:bg-blue-500 hover:text-white"
        (click)="selectExercise(suggestion.description)"
      &gt;
        {{ suggestion.description }}
      &lt;/li&gt;
    &lt;/ul&gt;
. </span><span class="koboSpan" id="kobo.205.5">. </span><span class="koboSpan" id="kobo.205.6">.</span></pre> <p><span class="koboSpan" id="kobo.206.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">exercise</span></strong><span class="koboSpan" id="kobo.208.1"> field, we are adding a list with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">ul</span></strong><span class="koboSpan" id="kobo.210.1"> HTML element, and this list will be presented by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">showSuggestions</span></strong><span class="koboSpan" id="kobo.212.1"> attribute. </span><span class="koboSpan" id="kobo.212.2">The focus event of the field will trigger this</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.213.1"> variable and clicking on the element will call the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">selectExercise</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.215.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.216.1">The attention in this code will be on the </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">following directive:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.218.1">
*ngFor="let suggestion of exercises$ | async"</span></pre> <p><span class="koboSpan" id="kobo.219.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">*ngFor</span></strong><span class="koboSpan" id="kobo.221.1"> directive, we want to iterate over a list, but here, we don’t have a list but an observable. </span><span class="koboSpan" id="kobo.221.2">How is </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">that possible?</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">This is the responsibility of the async pipe! </span><span class="koboSpan" id="kobo.223.2">What this pipe does in the template is perform a subscription in the observable, take the result of it, which is a list of exercises, and offer the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">*ngFor</span></strong><span class="koboSpan" id="kobo.225.1"> directive to </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">the iteration.</span></span></p>
<p><span class="koboSpan" id="kobo.227.1">Notice that we only got such concise code because, in the service, we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">map</span></strong><span class="koboSpan" id="kobo.229.1"> operator to prepare the return of the observable for exactly what the component needs. </span><span class="koboSpan" id="kobo.229.2">Another advantage that the async pipe provides is that the framework controls the life cycle of the observable; that is, when the component is destroyed, Angular automatically triggers the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">unsubscribe</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.231.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.232.1">We haven’t done this treatment so far in the book because the observable generated by an HTTP request is not open after the request is completed, but here we will use observables for other cases that may leave the flow with the observable </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">still open.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">It is very important to control the life cycle of the observables that we use; otherwise, we can generate bugs and performance degradation caused by memory leaks. </span><span class="koboSpan" id="kobo.234.2">Using the async pipe, this subscription management is done by </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">Angular itself!</span></span></p>
<p><span class="koboSpan" id="kobo.236.1">In the next section, we will connect different streams using RxJS and t</span><a id="_idTextAnchor250"/><span class="koboSpan" id="kobo.237.1">he </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">async pipe.</span></span></p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor251"/><span class="koboSpan" id="kobo.239.1">Connecting information flows – high-order operators</span></h1>
<p><span class="koboSpan" id="kobo.240.1">As we saw at the </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.241.1">beginning of the chapter, there are many uses of observables</span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.242.1"> besides an HTTP request. </span><span class="koboSpan" id="kobo.242.2">In our task, we will exemplify this use. </span><span class="koboSpan" id="kobo.242.3">In a reactive form, a user typing into a field is treated as </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">an observable.</span></span></p>
<p><span class="koboSpan" id="kobo.244.1">In our example, let’s change the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">NewEntryFormReactiveComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.246.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.247.1">
ngOnInit(): void {
  this.entryForm.valueChanges.subscribe((model) =&gt; console.log(model));
  . </span><span class="koboSpan" id="kobo.247.2">. </span><span class="koboSpan" id="kobo.247.3">.
</span><span class="koboSpan" id="kobo.247.4">}</span></pre> <p><span class="koboSpan" id="kobo.248.1">Running our </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.249.1">application, we can see in the browser’s console that typing into any form field triggers an event captured by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">subscribe</span></strong></span><span class="No-Break"> </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">method.</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">Knowing that</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.253.1"> we can react to user typing events, how do we connect this event to the search for exercise information in the API? </span><span class="koboSpan" id="kobo.253.2">We use </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">an operator!</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">Back in our component, we will refactor </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.257.1">
public exercises$ = this.entryForm.valueChanges.pipe(
  switchMap((model) =&gt; this.exerciseService.getExercises(model?.exercise))
);</span></pre> <p><span class="koboSpan" id="kobo.258.1">We remove the subscription of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">ngOnInit</span></strong><span class="koboSpan" id="kobo.260.1"> method from the component and put in the assignment of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">exercises$</span></strong><span class="koboSpan" id="kobo.262.1"> observable. </span><span class="koboSpan" id="kobo.262.2">However, if we do this, TypeScript and Angular type validation show an error because the template is waiting for a list to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">the iteration.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">Enter the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">switchMap</span></strong><span class="koboSpan" id="kobo.266.1"> operator. </span><span class="koboSpan" id="kobo.266.2">We exchange the first flow of events for typing the form with the exercise request flow, passing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">exercise</span></strong><span class="koboSpan" id="kobo.268.1"> field of the form model as a filter for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">exerciseService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.270.1"> service.</span></span></p>
<p><span class="koboSpan" id="kobo.271.1">The result of this is that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">exercises$</span></strong><span class="koboSpan" id="kobo.273.1"> observable continues to receive a list of exercises. </span><span class="koboSpan" id="kobo.273.2">Executing our project, we notice that we have a list with a typeahead search making the request as we fill in the field, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">following figure.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<span class="koboSpan" id="kobo.275.1"><img alt="Figure 9.1 – Selection of exercises" src="image/B19562_09_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.276.1">Figure 9.1 – Selection of exercises</span></p>
<p><span class="koboSpan" id="kobo.277.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">switchMap</span></strong><span class="koboSpan" id="kobo.279.1"> operator</span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.280.1"> is a higher-order observable because it takes an observable </span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.281.1">as input and returns an observable as output. </span><span class="koboSpan" id="kobo.281.2">This is in contrast to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">map</span></strong><span class="koboSpan" id="kobo.283.1"> operator, which takes an observable as input and returns a value </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">as output.</span></span></p>
<p><span class="koboSpan" id="kobo.285.1">With a command, we have our </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">search</span></strong><span class="koboSpan" id="kobo.287.1"> field, but if we look at our browser’s </span><strong class="bold"><span class="koboSpan" id="kobo.288.1">Network</span></strong><span class="koboSpan" id="kobo.289.1"> tab, we can see that a request is triggered for every letter we type. </span><span class="koboSpan" id="kobo.289.2">We can improve our application’s data consumption without harming our user experience, which we will do i</span><a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.290.1">n the </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">next section.</span></span></p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor253"/><span class="koboSpan" id="kobo.292.1">Optimizing data consumption – filter operators</span></h1>
<p><span class="koboSpan" id="kobo.293.1">Our task of</span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.294.1"> creating a typeahead type</span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1"> search</span></strong><span class="koboSpan" id="kobo.296.1"> field is complete, but we can make this functionality more efficient from the point of view of </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.297.1">consuming HTTP requests. </span><span class="koboSpan" id="kobo.297.2">Here, in our case, if the user types just one letter, we have already started the search</span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.298.1"> for information, but just one letter still results in a very </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">open list.</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">It would be more interesting for our application to start looking for exercises from the third letter that </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.301.1">the user types onward, and we can make the following modification for </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">this behavior:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.303.1">
public exercises$ = this.entryForm.valueChanges.pipe(
  map((model) =&gt; model?.exercise ?? </span><span class="koboSpan" id="kobo.303.2">''),
  filter((exercise) =&gt; exercise.length &gt;= 3),
  switchMap((exercise) =&gt; this.exerciseService.getExercises(exercise))
);</span></pre> <p><span class="koboSpan" id="kobo.304.1">Here, we</span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.305.1"> start using one of the most versatile features of RxJS, which is chaining operators for a certain action. </span><span class="koboSpan" id="kobo.305.2">We always need to keep in mind that </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.306.1">the order of operators is very important, and the output of an operator is the input of the </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">next one:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.308.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">map</span></strong><span class="koboSpan" id="kobo.310.1"> operator that we already know to extract only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">exercise</span></strong><span class="koboSpan" id="kobo.312.1"> field from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">form</span></strong><span class="koboSpan" id="kobo.314.1"> model and treat the data as if the field value </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">is undefined.</span></span></li>
<li><span class="koboSpan" id="kobo.316.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">filter</span></strong><span class="koboSpan" id="kobo.318.1"> operator works similarly to the method of the same name for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">Array</span></strong><span class="koboSpan" id="kobo.320.1"> object in JavaScript. </span><span class="koboSpan" id="kobo.320.2">It receives the </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">exercise</span></strong><span class="koboSpan" id="kobo.322.1"> string and we validate that its length must be greater than or equal to three to go to the </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">next operator.</span></span></li>
<li><span class="koboSpan" id="kobo.324.1">Finally, we run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">switchMap</span></strong><span class="koboSpan" id="kobo.326.1"> high-order operator to switch the form typing observable to the service’s HTTP </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">request observable.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.328.1">We can also, with another operator, add a waiting time for starting the flow of the observable, as in the </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.330.1">
const DEBOUNCE_TIME = 300;
. </span><span class="koboSpan" id="kobo.330.2">. </span><span class="koboSpan" id="kobo.330.3">.
</span><span class="koboSpan" id="kobo.330.4">public exercises$ = this.entryForm.valueChanges.pipe(
  debounceTime(DEBOUNCE_TIME),
  map((model) =&gt; model?.exercise ?? </span><span class="koboSpan" id="kobo.330.5">''),
  filter((exercise) =&gt; exercise.length &gt;= 3),
  switchMap((exercise) =&gt; this.exerciseService.getExercises(exercise))
);
. </span><span class="koboSpan" id="kobo.330.6">. </span><span class="koboSpan" id="kobo.330.7">.</span></pre> <p><span class="koboSpan" id="kobo.331.1">We added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">debounceTime</span></strong><span class="koboSpan" id="kobo.333.1"> operator to create a delay time for the beginning of the flow, defining</span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.334.1"> the time in milliseconds and with the good practice of using a constant to make the </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">code clearer.</span></span></p>
<p><span class="koboSpan" id="kobo.336.1">Let’s add one</span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.337.1"> last </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.338.1">optimization to our code with a </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">new operator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.340.1">
public exercises$ = this.entryForm.valueChanges.pipe(
  debounceTime(DEBOUNCE_TIME),
  map((model) =&gt; model?.exercise ?? </span><span class="koboSpan" id="kobo.340.2">''),
  filter((exercise) =&gt; exercise.length &gt;= 3),
 </span><strong class="bold"><span class="koboSpan" id="kobo.341.1"> distinctUntilChanged(),</span></strong><span class="koboSpan" id="kobo.342.1">
  switchMap((exercise) =&gt; this.exerciseService.getExercises(exercise))
);</span></pre> <p><span class="koboSpan" id="kobo.343.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">distinctUntilChanged</span></strong><span class="koboSpan" id="kobo.345.1"> operator checks whether the stream’s data, here </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">exercise</span></strong><span class="koboSpan" id="kobo.347.1">, has changed from one iteration to another and triggers the next operator only if the value is different, saving even more unnecessary calls to </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">the backend.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">We’ve learned about a few operators, but the library has over 80. </span><span class="koboSpan" id="kobo.349.2">In the next section, we’ll learn how to navigat</span><a id="_idTextAnchor254"/><span class="koboSpan" id="kobo.350.1">e </span><a id="_idTextAnchor255"/><span class="koboSpan" id="kobo.351.1">the </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">library’s documentation.</span></span></p>
<h1 id="_idParaDest-130"><span class="koboSpan" id="kobo.353.1">How to</span><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.354.1"> choose the correct operator</span></h1>
<p><span class="koboSpan" id="kobo.355.1">The RxJS library has an</span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.356.1"> extensive number of operators that can help simplify your code and handle corner cases of asy</span><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.357.1">nchrony and </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">even performance.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">You don’t need to memorize all the operators and the ones we’ve seen so far will help yo</span><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.360.1">u with the most </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">common cases.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">The library documentation has a </span><strong class="bold"><span class="koboSpan" id="kobo.363.1">Decision Tree</span></strong><span class="koboSpan" id="kobo.364.1"> page, and we’l</span><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.365.1">l learn how to </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">navigate that.</span></span></p>
<p><span class="koboSpan" id="kobo.367.1">Enter the site (</span><a href="https://rxjs.dev/operator-decision-tree"><span class="koboSpan" id="kobo.368.1">https://rxjs.dev/operator-decision-tree</span></a><span class="koboSpan" id="kobo.369.1">) and, here, we will navigate to an operator that </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.370.1">we have already studied to ex</span><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.371.1">emplify the use of </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">this tool.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<span class="koboSpan" id="kobo.373.1"><img alt="Figure 9.2 – Operator Decision Tree" src="image/B19562_09_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.374.1">Figure 9.2 – Operator Decision Tree</span></p>
<p><span class="koboSpan" id="kobo.375.1">Let’s go back </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.376.1">to our form example. </span><span class="koboSpan" id="kobo.376.2">We need to fetch the exercise information from what the user’s typing – let’s assume that we don’t know which operator </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">to choose.</span></span></p>
<p><span class="koboSpan" id="kobo.378.1">We already have an observable, which is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">valueChanges</span></strong><span class="koboSpan" id="kobo.380.1"> event in the Angular form, so on the first screen, we will choose the </span><strong class="screen-inline"><span class="koboSpan" id="kobo.381.1">I have one existing </span></strong><strong class="screen-inline"><span class="koboSpan" id="kobo.382.1">Observable, </span></strong><span class="No-Break"><strong class="screen-inline"><span class="koboSpan" id="kobo.383.1">and</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.384.1"> option.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">The request to our API is represented by an observable, so on the next screen, we will choose the </span><strong class="bold"><span class="koboSpan" id="kobo.386.1">I want to start a new Observable for each </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.387.1">value</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.388.1"> option.</span></span></p>
<p><span class="koboSpan" id="kobo.389.1">As we want to make a new request for each letter the user types, we want to change one stream for another, so on the next screen, we’ll choose </span><strong class="bold"><span class="koboSpan" id="kobo.390.1">and cancel the previous nested Observable when a new </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.391.1">value arrives</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.393.1">The exercise search depends on the value that is in the Angular form, so on the final page, we will choose </span><strong class="bold"><span class="koboSpan" id="kobo.394.1">where the nested Observable is calculated for </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.395.1">each value</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.397.1">Confirming</span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.398.1"> the selection, the decision tree indicates that the correct operator for this situation is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">switchMap</span></strong><span class="koboSpan" id="kobo.400.1"> operator that we </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">are using!</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">Another thing we need to understand in the RxJS documentation is the marble graph. </span><span class="koboSpan" id="kobo.402.2">For this, let’s take as an example another operator that we studied in the chapter, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">map</span></strong><span class="koboSpan" id="kobo.404.1"> operator </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">here: </span></span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">https://rxjs.dev/api/index/function/map</span></span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.408.1">In addition to the textual explanation, we have the </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<span class="koboSpan" id="kobo.410.1"><img alt="Figure 9.3 – Map operator marble graph (source: https://rxjs.dev/api/index/function/map, MIT license)" src="image/B19562_09_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.411.1">Figure 9.3 – Map operator marble graph (source: https://rxjs.dev/api/index/function/map, MIT license)</span></p>
<p><span class="koboSpan" id="kobo.412.1">As we learned at the beginning of this chapter, RxJS works on information flows, where operators have the function of </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">handling information.</span></span></p>
<p><span class="koboSpan" id="kobo.414.1">The graph that illustrates this flow uses arrows to represent the passage of time and marbles to </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">represent values.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">In the documentation here, then, we see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">map</span></strong><span class="koboSpan" id="kobo.418.1"> operator takes each value emitted and, based on a function, results in a flow with the values transformed </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">by it.</span></span></p>
<p><span class="koboSpan" id="kobo.420.1">These values are exchanged one by one as soon as they are issued so, in the graph, we can see that the positions of the marbles </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">are same.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">This understanding</span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.423.1"> is fundamental to understanding other more co</span><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.424.1">mplex operators in </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">the library.</span></span></p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.426.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.427.1">In this chapter, we explored the RxJS library and its basic </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">elements, observables.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">We learned what an observable is and how it differs from a promise or a function. </span><span class="koboSpan" id="kobo.429.2">With that knowledge, we refactored our project to handle data with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">map</span></strong><span class="koboSpan" id="kobo.431.1"> operator, abstracting the implementation details of the component that will consume the service. </span><span class="koboSpan" id="kobo.431.2">We also learned about Angular’s async pipe and how it simplifies the management of subscription to an observable, leaving this task to the framework itself </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">to manage.</span></span></p>
<p><span class="koboSpan" id="kobo.433.1">Finally, we created a typeahead search field using RxJS to search for exercises based on the user’s typing event, using operators in order to optimize HTTP calls from our frontend. </span><span class="koboSpan" id="kobo.433.2">In the next chapter, we will explore the possibilities of the automated tests that we can do in our </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">Angular application.</span></span></p>
</div>


<div class="Content" id="_idContainer059">
<h1 id="_idParaDest-132" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.1.1">Part 3: Architecture and Deployment</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part, you will learn how to build the architecture of your Angular project to meet the challenges and demands of your users. </span><span class="koboSpan" id="kobo.2.2">We will explore the best practices for automated testing using the libraries that the framework uses and we will install Cypress for end-to-end testing. </span><span class="koboSpan" id="kobo.2.3">We will understand the micro frontend architecture and how to implement it with Angular. </span><span class="koboSpan" id="kobo.2.4">We will use the Azure cloud service to perform the build and deploy our example application and finally understand how to update an Angular application and use features from version 17 onwards such as </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">Angular Signals</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B19562_10.xhtml#_idTextAnchor264"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 10</span></em></a><em class="italic"><span class="koboSpan" id="kobo.7.1">, Design for Tests: Best Practices</span></em></li>
<li><a href="B19562_11.xhtml#_idTextAnchor285"><em class="italic"><span class="koboSpan" id="kobo.8.1">Chapter 11</span></em></a><em class="italic"><span class="koboSpan" id="kobo.9.1">, Micro Frontend with Angular Elements</span></em></li>
<li><a href="B19562_12.xhtml#_idTextAnchor311"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 12</span></em></a><em class="italic"><span class="koboSpan" id="kobo.11.1">, Packaging Everything: Best Practices for Deployment</span></em></li>
<li><a href="B19562_13.xhtml#_idTextAnchor328"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 13</span></em></a><em class="italic"><span class="koboSpan" id="kobo.13.1">, The Angular Renaissance</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer060">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer061">
</div>
</div>
</body></html>