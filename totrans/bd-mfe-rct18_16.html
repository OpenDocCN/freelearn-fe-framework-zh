<html><head></head><body>
		<div id="_idContainer070" class="calibre2">
			<h1 id="_idParaDest-164" class="chapter-number"><a id="_idTextAnchor163" class="pcalibre1 calibre6 pcalibre"/>11</h1>
			<h1 id="_idParaDest-165" class="calibre7"><a id="_idTextAnchor164" class="pcalibre1 calibre6 pcalibre"/>Latest Trends in Microfrontends</h1>
			<p class="calibre3">The world of frontend engineering is constantly evolving, and as we go about building microfrontends following the currently available tools, approaches, and best practices, it is important to keep an eye on the latest trends that are evolving in this space and keep exploring and experimenting with them to see how they can help us become more efficient and build <span>better apps.</span></p>
			<p class="calibre3">In this chapter, we will cover some trends that can influence how we build microfrontends in the future. Some of the trends we will explore are <span>the following:</span></p>
			<ul class="calibre15">
				<li class="calibre14">The name <em class="italic">microfrontends</em> itself and what is a better term <span>for it</span></li>
				<li class="calibre14">The island pattern of mixing static content with <span>dynamic content</span></li>
				<li class="calibre14">Looking at other build tools <span>beyond Webpack</span></li>
				<li class="calibre14"><span>WebAssembly</span></li>
				<li class="calibre14">Cloud or <span>edge functions</span></li>
				<li class="calibre14">How generative AI can influence <span>our work</span></li>
			</ul>
			<p class="calibre3">By the end of this chapter, we will have learned about the latest trends in the frontend engineering space that impact how we <span>build microfrontends.</span></p>
			<h1 id="_idParaDest-166" class="calibre7"><a id="_idTextAnchor165" class="pcalibre1 calibre6 pcalibre"/>Microfrontends – decoupled modular frontends</h1>
			<p class="calibre3">The term <em class="italic">microfrontends</em> has obviously <a id="_idIndexMarker448" class="pcalibre1 calibre6 pcalibre"/>become very popular, and this entire book<a id="_idIndexMarker449" class="pcalibre1 calibre6 pcalibre"/> uses it, but to be honest, I’ve always felt it was poorly coined and unfortunately, it has stuck within the community. As mentioned a couple of times, the word <em class="italic">microfrontend</em> has led to a lot of misinterpretation, leading to bad architectural patterns that cause more harm than good. A new proposal has <a id="_idIndexMarker450" class="pcalibre1 calibre6 pcalibre"/>been put forward to start calling them <strong class="bold">composable decoupled frontends</strong> (<a href="https://microfrontend.dev/" class="pcalibre1 calibre6 pcalibre">https://microfrontend.dev/</a>), which I think is apt and clearly explains the intent and purpose of what we are building. I really hope the community starts picking this term up and that we collectively all start moving to building and calling microfrontends what they really are and defining what they are really supposed <span>to do.</span></p>
			<p class="calibre3">I’m sure many of you will wonder how simply changing the name helps and what’s really in a name; however, I feel that, in this case, a name that clearly articulates the architecture pattern greatly reduces the misconceptions, misinterpretation, and complications arising from wrongly architected systems. As you will have realized through the course of this book, it is all about building modular applications that are decoupled <a id="_idIndexMarker451" class="pcalibre1 calibre6 pcalibre"/>from each <a id="_idIndexMarker452" class="pcalibre1 calibre6 pcalibre"/>other and hence they should be rightfully called <strong class="bold">Decoupled </strong><span><strong class="bold">Modular Frontends</strong></span><span>.</span></p>
			<h1 id="_idParaDest-167" class="calibre7"><a id="_idTextAnchor166" class="pcalibre1 calibre6 pcalibre"/>The island pattern</h1>
			<p class="calibre3">Statically generated pages<a id="_idIndexMarker453" class="pcalibre1 calibre6 pcalibre"/> are gaining a lot of popularity as they ship very little to no JavaScript; however, the challenge with them has always been on how to serve <span>dynamic content.</span></p>
			<p class="calibre3">The <strong class="bold">island pattern</strong> aims to solve this problem. It was made popular by the Astro build framework, wherein we have our application published as a set of statically generated HTML pages, within which the dynamic parts of the page are imported <span>as islands.</span></p>
			<p class="calibre3">Here is an example of how this can be achieved using Astro, a popular framework for building statically <span>generated sites.</span></p>
			<p class="calibre3">You can read more about this <span>at </span><a href="https://docs.astro.build/en/concepts/islands/" class="pcalibre1 calibre6 pcalibre"><span>https://docs.astro.build/en/concepts/islands/</span></a><span>:</span></p>
			<pre class="source-code">
//index file
---
// Example: Use a dynamic React component on the page.
import MyReactComponent from '../components/MyReactComponent.jsx';
---
&lt;!-- This component is now interactive on the page!
     The rest of your website remains static and zero JS. --&gt;
&lt;MyReactComponent client:load /&gt;</pre>			<p class="calibre3">Run the Astro build command, test the app locally, and look into your <strong class="source-inline">Inspect</strong> command; you will notice that while the rest of the page is plain HTML with little to no JavaScript, <strong class="source-inline">MyReactComponent</strong> is a small JavaScript element and executes on the <span>client side.</span></p>
			<p class="calibre3">As you can see, with the island pattern, we get a clear distinction between static and dynamic content with the potential added benefit of not being locked down to a single framework for all parts of <span>the application.</span></p>
			<p class="calibre3">Having said that, there are a few differences between the island pattern and microfrontends, including <span>the following:</span></p>
			<ul class="calibre15">
				<li class="calibre14">Islands in Astro are components that are hydrated/rendered on the client side, while microfrontends are independent applications with their own code bases, routing, and backends. Microfrontends are more isolated <span>and decoupled.</span></li>
				<li class="calibre14">Astro builds the entire app and islands at build time. Microfrontends are built and deployed independently. Astro has a unified build, while microfrontends can have <span>separate builds.</span></li>
				<li class="calibre14">Routing in Astro happens in the shell, while each microfrontend manages its own routing. Astro islands don’t have <span>independent routing.</span></li>
				<li class="calibre14">Astro islands can<a id="_idIndexMarker454" class="pcalibre1 calibre6 pcalibre"/> communicate with each other via Astro integration, while microfrontends typically communicate via well-defined APIs and events. Islands have tighter coupling and integration with the <span>Astro app.</span></li>
			</ul>
			<h1 id="_idParaDest-168" class="calibre7"><a id="_idTextAnchor167" class="pcalibre1 calibre6 pcalibre"/>Beyond Webpack with ES Modules</h1>
			<p class="calibre3">With the <a id="_idIndexMarker455" class="pcalibre1 calibre6 pcalibre"/>dawn of <a id="_idIndexMarker456" class="pcalibre1 calibre6 pcalibre"/>JavaScript-based frameworks, Webpack rose in popularity, and it became the de facto module bundler for all JavaScript frameworks. However, bundling/compiling large applications with Webpack can be very slow, and manually configuring it to efficiently bundle an app is very complex. Recently, a new breed of bundler tools that takes advantage of ES modules has taken the frontend world by storm, promising compilation over 20 times faster <span>than Webpack.</span></p>
			<p class="calibre3">ES modules are a standardized way to define and import modules in JavaScript. They allow for modular code organization, which can make it easier to develop and maintain large applications. ES modules also provide a clear and explicit syntax for importing and exporting code, making it easier to reason about the dependencies between <span>different modules.</span></p>
			<p class="calibre3">Each of our micro apps can be exported as ES modules, and by using dynamic imports, we can embed them into our <span>host application.</span></p>
			<p class="calibre3">The entire microfrontend application can be bundled using an ES build-based module bundler such<a id="_idIndexMarker457" class="pcalibre1 calibre6 pcalibre"/> as Vite (<a href="https://vitejs.dev/" class="pcalibre1 calibre6 pcalibre">https://vitejs.dev/</a>).  Monorepo frameworks such as Nx allow you to easily configure using Vite as your <span>module bundler.</span></p>
			<p class="calibre3">We can <a id="_idIndexMarker458" class="pcalibre1 calibre6 pcalibre"/>scaffold <a id="_idIndexMarker459" class="pcalibre1 calibre6 pcalibre"/>out a React app using Vite <span>as follows:</span></p>
			<pre class="console">
pnpm create vite microfrontend-app --template react</pre>			<p class="calibre3">Here is a rough example of how this can <span>be achieved:</span></p>
			<pre class="source-code">
// Catalog App
<strong class="bold1">function CatalogApp()</strong> { 
  return &lt;h1&gt;Hello World&lt;/h1&gt;;
}
export default CatalogApp;</pre>			<p class="calibre3">In the host app, we use the classic React <strong class="source-inline">suspense</strong> and <strong class="source-inline">lazy</strong> functions to load in <strong class="source-inline">CatalogApp</strong> <span>at runtime:</span></p>
			<pre class="source-code">
// Host App
import React, { lazy, Suspense } from 'react';
const CatalogApp = lazy(() =&gt; import('./catalog'));
function App() {
  return (
    &lt;&gt;
      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
        &lt;CatalogApp /&gt;
      &lt;/Suspense&gt;
    &lt;/&gt;
  );
}</pre>			<p class="calibre3">As you will have noticed, we have managed to get our app working without using Webpack or Webpack’s module federation, and I’m sure you will also notice how fast the app builds after any changes that <span>you make.</span></p>
			<p class="calibre3">We believe ES modules and ES build systems will soon replace Webpack to become the de facto tools of choice for building all modern frontends. What is also interesting to note is that<a id="_idIndexMarker460" class="pcalibre1 calibre6 pcalibre"/> while <a id="_idIndexMarker461" class="pcalibre1 calibre6 pcalibre"/>React’s <strong class="source-inline">lazy</strong> and <strong class="source-inline">suspense</strong> functions are commonly thought of as performance optimization techniques, we take advantage of their ability to load modules in real time to <span>build microfrontends.</span></p>
			<h1 id="_idParaDest-169" class="calibre7"><a id="_idTextAnchor168" class="pcalibre1 calibre6 pcalibre"/>Using WebAssembly Modules</h1>
			<p class="calibre3"><strong class="bold">WebAssembly</strong> (<strong class="bold">Wasm</strong>) has been<a id="_idIndexMarker462" class="pcalibre1 calibre6 pcalibre"/> around for many years now. Despite its <a id="_idIndexMarker463" class="pcalibre1 calibre6 pcalibre"/>huge benefits in terms of performance and low bundle size, it hasn’t gained much popularity, primarily because it wasn’t easy for developers to build a WASM module. However, now that people are starting to work with tools such as Rust, it gets fairly easy to build WebAssembly modules with Rust. We anticipate that WebAssembly will become mainstream when building applications that require a high level of computation on <span>the browser.</span></p>
			<p class="calibre3">WASM modules can work really well in a microfrontend architecture, where the critical compute-intensive modules are built in WASM wrapped as a micro app and imported into a microfrontend architecture in which the rest of the micro apps in the microfrontend are built using the <span>standard React.</span></p>
			<p class="calibre3">Here is a rough approach of how you could set this up in your module federated Next.js app. Use our module federation code from <a href="B18987_06.xhtml#_idTextAnchor093" class="pcalibre1 calibre6 pcalibre"><span><em class="italic">Chapter 6</em></span></a>. First build a Rust app using <strong class="source-inline">wasm_bindgen</strong> within a <strong class="source-inline">/rust</strong> folder. </p>
			<p class="calibre3">To compile the rust app to wasm we need to install the <strong class="source-inline">wasm-pack-plugin</strong> as using <strong class="source-inline">pnpm install @wasm-tool/wasm-pack-plugin</strong> and use it in the <strong class="source-inline">next.config.js</strong> configuration <span>as follows:</span></p>
			<pre class="source-code">
const NextFederationPlugin = require("@module-federation/nextjs-mf");
const WasmPackPlugin = require('@wasm-tool/wasm-pack-plugin');
const path= require("path")
const remotes = (isServer) =&gt; {
  const location = isServer ? "ssr" : "chunks";
  return {
    catalog: `catalog@http://localhost:3001/_next/static/${location}/remoteEntry.js`,
  };
};
module.exports = {
  webpack(config, options) {
    config.plugins.push(
      new WasmPackPlugin({
        crateDirectory: ('./rust'),
    }),
      new NextFederationPlugin({
        name: "catalog",
        filename: "static/chunks/remoteEntry.js",
        exposes: {
          "./Module": "./pages/index.tsx",
        },
        remotes: remotes(options.isServer),
        shared: {},
        extraOptions: {
          automaticAsyncBoundary: true,
        },
      
  
      })
    );
    config.experiments = {
      syncWebAssembly: true,
    };
    config.module.rules.push({
      test: /\.wasm$/,
      type: 'webassembly/sync',
    });
    return config;
  },
};</pre>			<p class="calibre3">Then using dynamic imports, import the wasm module into the index page of the remote app. And finally using the approaches we used in <a href="B18987_06.xhtml#_idTextAnchor093" class="pcalibre1 calibre6 pcalibre"><span><em class="italic">Chapter 6</em></span></a> import the remote app into the <span>host app.</span></p>
			<p class="calibre3">WASM is already being used in some very popular web-based tools such as Figma, AutoCAD, Google Earth, the Unity game engine, and so on. Combining WebAssembly modules with microfrontends helps bring the best of both worlds: the power and performance of WASM, and the ease of use and modularity <span>of microfrontends.</span></p>
			<h1 id="_idParaDest-170" class="calibre7"><a id="_idTextAnchor169" class="pcalibre1 calibre6 pcalibre"/>Edge Functions or Cloud functions</h1>
			<p class="calibre3">Edge functions <a id="_idIndexMarker464" class="pcalibre1 calibre6 pcalibre"/>are gaining a lot <a id="_idIndexMarker465" class="pcalibre1 calibre6 pcalibre"/>of popularity, as they provide the power to compute on the edge. Think of them<a id="_idIndexMarker466" class="pcalibre1 calibre6 pcalibre"/> like a <strong class="bold">Content Delivery Network</strong> (<strong class="bold">CDN</strong>) but with the power and ability to <span>run computations.</span></p>
			<p class="calibre3">The primary benefits of edge functions are that they provide very low latency, which greatly helps improve performance, and they use an automatic distributed deployment, which mitigates single points of failure and helps <span>improve scalability.</span></p>
			<p class="calibre3">Edge functions and microfrontends work quite well hand in hand, where you can have each micro app deployed within a cloud function; this automatically allows for modular deployments, and each team can manage its cloud <span>functions independently.</span></p>
			<p class="calibre3">Cloudflare is one of the most popular providers that support cloud functions.  Cloudflare Workers and most recently Cloudflare Pages support computing on the edge. Here is an example of how to deploy a Next.js App on Cloudflare Pages using Edge Runtime. </p>
			<ol class="calibre13">
				<li class="calibre14">Start with any of the existing Next.js apps <span>we’ve built.</span><pre class="source-code">
<strong class="bold1">npm install --save-dev @cloudflare/next-on-pages</strong></pre></li>				<li class="calibre14">Commit your changes and push them into a <span>Git repo.</span></li>
				<li class="calibre14">Login into the Cloudflare dashboard and go to <strong class="bold">Workers &amp; Pages | Create Application | Pages | Connect </strong><span><strong class="bold">to Git</strong></span><span>.</span></li>
				<li class="calibre14">4. Select the repo where you pushed the code and in the Setup builds and deployments, select Next.js as your Framework. Leave the rest of the settings as default. </li>
			</ol>
			<p class="calibre3">Next we need to set the Compatibility Flags which we do by going into the <strong class="bold">Pages | Settings | Functions | Compatibility Flags</strong>. And we need to set the value <span>to </span><span><strong class="source-inline">nodejs_compat</strong></span><span>.</span></p>
			<p class="calibre3">From the Deployment Details section go to the <strong class="bold">Manage Deployment</strong> and select <strong class="bold">Retry deployment </strong>from <span>the dropdown.</span></p>
			<p class="calibre3">Thanks to the low costs and ease of deployments, we believe there is a great potential to deploy all frontend applications, irrespective of whether they are microfrontends or not, on platforms such as Vercel, Cloudflare, Fastly, and <span>so on.</span></p>
			<p class="calibre3">Most edge function providers have very good support for the JavaScript ecosystem; however, it is important to keep in mind that based on the vendor/platform you are working on, there may be certain restrictions. For example, Cloudflare limits the size of each worker<a id="_idIndexMarker467" class="pcalibre1 calibre6 pcalibre"/> to<a id="_idIndexMarker468" class="pcalibre1 calibre6 pcalibre"/> be under 1 MB, or it explicitly supports package versions that are compatible with the broader Node.js runtime environments. For Cloudflare, you can read more about Node.js compatibility <span>here: </span><a href="https://developers.cloudflare.com/pages/framework-guides/" class="pcalibre1 calibre6 pcalibre"><span>https://developers.cloudflare.com/pages/framework-guides/</span></a><span>.</span></p>
			<h1 id="_idParaDest-171" class="calibre7"><a id="_idTextAnchor170" class="pcalibre1 calibre6 pcalibre"/>Generative AI and Microfrontends</h1>
			<p class="calibre3">Generative AI has <a id="_idIndexMarker469" class="pcalibre1 calibre6 pcalibre"/>clearly taken <a id="_idIndexMarker470" class="pcalibre1 calibre6 pcalibre"/>the world by storm. We are seeing amazing examples of generative AI being able to generate complete <span>end-to-end applications.</span></p>
			<p class="calibre3">When it comes to building microfrontends, it will be very interesting to see how things evolve. While I believe generative AI can’t take over a developer’s job, I do see interesting use cases of how generative AI can work hand in hand with microfrontends in building unique <span>customer experiences.</span></p>
			<p class="calibre3">Generative AI can be leveraged to dynamically generate and assemble various parts of a web application. By intelligently analyzing user behavior, preferences, and real-time context, AI can create microfrontends that are tailor-made for individual users, resulting in a highly personalized and optimized user experience. This approach also simplifies the development process by allowing developers to focus on creating modular, composable micro apps, while the AI system takes care of the overall assembly and rendering of the <span>web application.</span></p>
			<p class="calibre3">New AI-powered tools such as GPT-Engineer, smol-ai, and Auto-GPT are emerging, which allow developers to describe application requirements using plain text or Markdown. These tools then scaffold and generate code for the full application based on the developer’s specifications. This removes the need for manually writing all of the code, and instead, lets the AI handle much of the initial setup. These kinds of AI developer assistants are still at quite an early stage; developers will need to learn skills such as crafting effective prompts to get the most consistent and accurate results from the AI, but the potential is there for AI to significantly enhance and accelerate development workflows. The key will be continuing to improve the AI’s code generation abilities while also helping developers provide the right input <span>and guidance.</span></p>
			<p class="calibre3">The use of AI in microfrontends can lead to more efficient resource utilization and improved performance, as the system can adaptively load and unload components based on<a id="_idIndexMarker471" class="pcalibre1 calibre6 pcalibre"/> user<a id="_idIndexMarker472" class="pcalibre1 calibre6 pcalibre"/> interactions and needs. This innovative integration of AI and microfrontends has the potential to revolutionize the way web applications are designed, developed, and delivered <span>to users.</span></p>
			<h1 id="_idParaDest-172" class="calibre7"><a id="_idTextAnchor171" class="pcalibre1 calibre6 pcalibre"/>Summary</h1>
			<p class="calibre3">With this, we have come to the end of this chapter and the book. We really hope you’ve enjoyed <span>the journey.</span></p>
			<p class="calibre3">In this chapter, we looked at a few new trends that will influence the way we build and deploy microfrontends. We saw how concepts such as the island pattern can help interlace dynamic content blocks within a statically generated multipage app. We saw how the new Rust-based bundler can be many times faster than Webpack. We learned about WebAssembly and how it can be used within microfrontends, and finally, we looked at cloud functions, which have the potential to become the default solution for deploying all modern <span>frontend applications.</span></p>
			<p class="calibre3">I’m truly excited about how quickly technology is evolving and how it affects the way we build our applications. I can’t wait to see you go out in the wild and build things that make this world a <span>better place.</span></p>
			<p class="calibre3">In closing, it is essential to remember that the world of microfrontends, much like our dynamic digital landscape, is in a constant state of evolution. The concepts, techniques, and technologies we have unraveled throughout this journey, such as Module Federation and the intriguing practice of deploying microfrontends to the cloud, are just the beginning of this ever-evolving tapestry. They provide us with the building blocks to construct high-performing, scalable, and maintainable frontend architectures. Yet, the future beckons with promises of newer trends and advancements that will continue to redefine <span>the horizon.</span></p>
			<p class="calibre3">I encourage you, the next generation of developers, to step into this exciting journey and build upon the foundational knowledge this book has attempted to provide. Challenge the status quo, experiment with the latest trends, and mold them to fit the unique demands of your projects. It’s a grand time to be a frontend engineer, and the world awaits the innovative solutions you will create using React and microfrontends. Remember, every line of code you write is an opportunity to improve, innovate, and inspire. So, go forth and build for <span>the future.</span></p>
		</div>
	</body></html>