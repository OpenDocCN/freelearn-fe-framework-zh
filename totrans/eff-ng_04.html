<html><head></head><body>
<div id="_idContainer018">
<h1 class="chapter-number" id="_idParaDest-72"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-73"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.2.1">Building Forms Like a Pro</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.3.1">Forms</span></strong><span class="koboSpan" id="kobo.4.1"> are at the core of many frontend applications. </span><span class="koboSpan" id="kobo.4.2">They allow you to collect user input to save and act upon data provided by your application users. </span><span class="koboSpan" id="kobo.4.3">Building forms is one of the aspects where Angular excels. </span><span class="koboSpan" id="kobo.4.4">Angular provides two different approaches for building forms, both with tools to validate individual form fields as well as the validity of the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">entire form.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">In this chapter, you will learn how to create Angular </span><strong class="bold"><span class="koboSpan" id="kobo.7.1">template-driven</span></strong><span class="koboSpan" id="kobo.8.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.9.1">reactive forms</span></strong><span class="koboSpan" id="kobo.10.1">, synchronize your form fields with your application state, validate forms and individual form fields, and learn about advanced concepts such as dynamic form creation. </span><span class="koboSpan" id="kobo.10.2">By the end of this chapter, you will be able to create forms like </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">a pro!</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">This chapter will cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.14.1">Understanding the different types of forms </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">in Angular</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Building </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">template-driven forms</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Building </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">reactive forms</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Creating </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">forms dynamically</span></span></li>
</ul>
<h1 id="_idParaDest-74"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.22.1">Understanding the different types of forms in Angular</span></h1>
<p><span class="koboSpan" id="kobo.23.1">Angular </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.24.1">provides two different types of forms: template-driven forms and reactive forms. </span><span class="koboSpan" id="kobo.24.2">This </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.25.1">section will discuss the differences between template-driven and reactive forms and help you assess what approach best fits </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">your situation.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">Let’s start by explaining the key characteristics of both approaches for </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">building forms.</span></span></p>
<h3><span class="koboSpan" id="kobo.29.1">Characteristics of template-driven forms</span></h3>
<p><span class="koboSpan" id="kobo.30.1">Template-driven forms</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.31.1"> are a way to build forms where the HTML template plays a central role. </span><span class="koboSpan" id="kobo.31.2">Template-driven forms implicitly define form controls </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.32.1">and validation rules in the HTML template using directives. </span><span class="koboSpan" id="kobo.32.2">This means the form controls and validation rules are created and managed by the directives you place on the HTML elements instead of manually creating the form controls and validations inside your TypeScript files and directly communicating with the form </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">API yourself.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">The template-driven approach relies on two-way data binding using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">ngModel</span></strong><span class="koboSpan" id="kobo.36.1"> directive to synchronize changes in the data model for both user input and programmatic changes. </span><span class="koboSpan" id="kobo.36.2">When you add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.37.1">ngModel</span></strong><span class="koboSpan" id="kobo.38.1"> directive to an HTML element, the directive creates and manages a </span><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">FormControl</span></strong><span class="koboSpan" id="kobo.40.1"> instance for you. </span><span class="koboSpan" id="kobo.40.2">These </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">FormControl</span></strong><span class="koboSpan" id="kobo.42.1"> classes that are created by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">ngModel</span></strong><span class="koboSpan" id="kobo.44.1"> directive are used to track and validate the status of individual form fields inside </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">your form.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">When using template-driven forms, the form data is mutable, meaning you don’t update the form values using the form API, but you directly change values that are used within the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">FormControl</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.48.1"> instances.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.49.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.50.1">It’s also important to note that the data flow for template-driven forms is asynchronous and updates through events and subscriptions. </span><span class="koboSpan" id="kobo.50.2">While this asynchronous behavior is managed for you, it’s good to know because it can affect tests and sometimes lead to unexpected behavior if you aren’t aware that the data flow </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">is asynchronous.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">Template-driven forms are easy and quick to build and work very well combined with Signals (we will learn more about Signals in </span><a href="B21625_07.xhtml#_idTextAnchor129"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.53.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.54.1">), which can reduce the number of times change detection is triggered, </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">improving performance.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">However, the data model and form controls of template-driven forms are complex to reuse and test; also, when building large forms, your HTML template becomes bloated. </span><span class="koboSpan" id="kobo.56.2">When creating forms that need rigorous testing, reusable form models and controls, or forms that need a dynamic way of being constructed, reactive forms might be the </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">better fit.</span></span></p>
<h3><span class="koboSpan" id="kobo.58.1">Characteristics of reactive forms</span></h3>
<p><span class="koboSpan" id="kobo.59.1">Reactive forms </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.60.1">provide a flexible, model-driven approach to creating </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.61.1">forms. </span><span class="koboSpan" id="kobo.61.2">Reactive forms facilitate more programmatic control compared to template-driven forms. </span><span class="koboSpan" id="kobo.61.3">When using the reactive approach, you explicitly define the form model by creating </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">FormGroup</span></strong><span class="koboSpan" id="kobo.63.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">FormControl</span></strong><span class="koboSpan" id="kobo.65.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">FormArray</span></strong><span class="koboSpan" id="kobo.67.1"> instances in your TypeScript files. </span><span class="koboSpan" id="kobo.67.2">The explicit nature of reactive forms allows for more complex logic, easy testing, and better reusability of form controls and models. </span><span class="koboSpan" id="kobo.67.3">In reactive forms, validation rules are also explicitly defined using </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">Validator</span></strong><span class="koboSpan" id="kobo.69.1"> classes or custom validators, allowing for more </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">complex validations.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">Reactive forms provide fine-grained control over the form’s state, allowing you to set, get, and manipulate values programmatically. </span><span class="koboSpan" id="kobo.71.2">Once a form and its form controls have been created, you cannot directly modify the values. </span><span class="koboSpan" id="kobo.71.3">This makes reactive forms immutable. </span><span class="koboSpan" id="kobo.71.4">Immutable forms provide a more reliable data model, which, in turn, leads to </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">fewer bugs.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">Because you directly define the form models in your TypeScript files using the form API, the form models that are created for reactive forms can easily be reused and tested. </span><span class="koboSpan" id="kobo.73.2">Reactive forms are straightforward when it comes to writing tests because you can directly use the form API in your tests, just like you do in your </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">component classes.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">Reactive forms have a synchronous data flow between the view (by </span><em class="italic"><span class="koboSpan" id="kobo.76.1">view</span></em><span class="koboSpan" id="kobo.77.1">, we mean the HTML template that’s displayed in the browser) and the data model. </span><span class="koboSpan" id="kobo.77.2">As a result, Angular knows precisely when to run change detection on reactive forms, </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">improving performance.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">While the reactive approach requires more initial setup compared to template-driven forms, reactive forms are better suited for large, complex forms where additional control, testing, and reusability of form controls and models </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">are crucial.</span></span></p>
<h3><span class="koboSpan" id="kobo.81.1">Key differences between template-driven forms and reactive forms</span></h3>
<p><span class="koboSpan" id="kobo.82.1">The</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.83.1"> following table outlines the differences </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.84.1">between template-driven and </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">reactive forms:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.86.1">Template-Driven Forms</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.87.1">Reactive Forms</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.88.1">Form, model, and </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">validation creation</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.90.1">Implicitly using directives in the </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">HTML template</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.92.1">Explicitly using classes in </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">TypeScript files</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.94.1">Setting up and creating </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">the form</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.96.1">Easy and simple to </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">set up</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.98.1">Needs more initial setup and can feel </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">more complex</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.100.1">Data model</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.101.1">Unstructured </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">and mutable</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.103.1">Structured </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">and immutable</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.105.1">Data flow</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.106.1">Asynchronous</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.107.1">Synchronous</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.108.1">Compatible </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">with Signals</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.110.1">Good</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.111.1">Not good</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.112.1">Testability</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.113.1">Difficult to </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">unit test</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.115.1">Easy to test using the </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">form API</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.117.1">Reusability and dynamic creation of </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">the form</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.119.1">Harder to reuse or </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">build dynamically</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.121.1">Easy to reuse and </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">build dynamically</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.123.1">Table 4.1: Key differences between template-driven forms and reactive forms</span></p>
<p><span class="koboSpan" id="kobo.124.1">Now that</span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.125.1"> you </span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.126.1">know the key characteristics of Angular template-driven and reactive forms, let’s do a deep dive and learn how you can create both types </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">of forms.</span></span></p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.128.1">Building template-driven forms</span></h1>
<p><span class="koboSpan" id="kobo.129.1">In this section, we will </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.130.1">build a template-driven form. </span><span class="koboSpan" id="kobo.130.2">You will learn how to bind data to input fields, group form fields, and perform built-in and custom validation rules in template-driven forms. </span><span class="koboSpan" id="kobo.130.3">You will also learn how template-driven forms work behind the scenes to get a better understanding of </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">template-driven forms.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">By the end of this section, you’ll be able to build robust template-driven forms and create a template-driven form to add expenses to our </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">demo application.</span></span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.134.1">Creating a forms library with a form component</span></h2>
<p><span class="koboSpan" id="kobo.135.1">Before</span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.136.1"> we start creating the form, we need a new library. </span><span class="koboSpan" id="kobo.136.2">We will generate the new library using the custom Nx generator we made in </span><a href="B21625_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.137.1">Chapter 1</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.138.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">You can debate about how to separate the forms library. </span><span class="koboSpan" id="kobo.139.2">You can either create one library that holds all the forms of a specific domain, you can create a forms library for each application in a particular domain, or you can create a new library for </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">each form.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">Using a single library for each form is the best way to use the Nx caching and incremental build systems, but it also has some extra overhead in terms of development and maintenance. </span><span class="koboSpan" id="kobo.141.2">If your organization has a lot of forms that are reused among multiple applications, splitting them up into individual libraries might be worth the extra setup as it will speed up your builds </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">and pipelines.</span></span></p>
<p><span class="koboSpan" id="kobo.143.1">For our example, I will create a forms library dedicated to the </span><em class="italic"><span class="koboSpan" id="kobo.144.1">expenses-registration</span></em><em class="italic"><span class="koboSpan" id="kobo.145.1"> application</span></em><span class="koboSpan" id="kobo.146.1"> so that the library will contain all the forms for this </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">specific application:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.148.1">Run the custom Nx generator to create the library. </span><span class="koboSpan" id="kobo.148.2">Name </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">expenses-registration-forms</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.152.1">Select </span><strong class="bold"><span class="koboSpan" id="kobo.153.1">finance</span></strong><span class="koboSpan" id="kobo.154.1"> for the domain and </span><strong class="bold"><span class="koboSpan" id="kobo.155.1">ui</span></strong><span class="koboSpan" id="kobo.156.1"> for the type. </span><span class="koboSpan" id="kobo.156.2">Then, </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">click </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.158.1">Generate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.160.1">Once the library has been generated, restart VS Code so that the Nx schematics are updated with your </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">new library.</span></span></li>
<li><span class="koboSpan" id="kobo.162.1">We will create a component for our template-driven form using the Nx generator. </span><span class="koboSpan" id="kobo.162.2">Name the </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">component </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">add-expense</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.166.1">Select the newly created library for the project, check the </span><strong class="bold"><span class="koboSpan" id="kobo.167.1">standalone</span></strong><span class="koboSpan" id="kobo.168.1"> checkbox, click </span><strong class="bold"><span class="koboSpan" id="kobo.169.1">Show all options</span></strong><span class="koboSpan" id="kobo.170.1">, and select </span><strong class="bold"><span class="koboSpan" id="kobo.171.1">OnPush</span></strong><span class="koboSpan" id="kobo.172.1"> for the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.173.1">changeDetection</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.174.1"> option.</span></span></li>
<li><span class="koboSpan" id="kobo.175.1">Click </span><strong class="bold"><span class="koboSpan" id="kobo.176.1">Generate</span></strong><span class="koboSpan" id="kobo.177.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">top-right corner.</span></span></li>
<li><span class="koboSpan" id="kobo.179.1">Once the component has been generated, export it into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">index.ts</span></strong><span class="koboSpan" id="kobo.181.1"> file of the library. </span><span class="koboSpan" id="kobo.181.2">I like to end the component selector for forms with </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">form</span></strong><span class="koboSpan" id="kobo.183.1">, so I will rename the component </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">selector </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">bt-libs-ui-add-expense-form</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.187.1">Now that we’ve created the library and component, we can start creating the </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">template-driven form.</span></span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.189.1">Creating a template-driven form</span></h2>
<p><span class="koboSpan" id="kobo.190.1">We </span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.191.1">will start by creating a simple HTML form and slowly convert it into an Angular template-driven form. </span><span class="koboSpan" id="kobo.191.2">Add this to your </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">add-expense.component.html</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.193.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.194.1">
&lt;form&gt;
  &lt;div class=»form-field"&gt;
    &lt;label for=»description»&gt;Description:&lt;/label&gt;
    &lt;input type=»text» id=»description» name=»description»&gt;
  &lt;/div&gt;
  </span><strong class="bold"><span class="koboSpan" id="kobo.195.1">…………</span></strong><span class="koboSpan" id="kobo.196.1">
  &lt;button type=»submit»&gt;Submit&lt;/button&gt;
&lt;/form&gt;</span></pre> <p><span class="koboSpan" id="kobo.197.1">You can replace the </span><strong class="bold"><span class="koboSpan" id="kobo.198.1">dots</span></strong><span class="koboSpan" id="kobo.199.1"> with any additional form fields you want. </span><span class="koboSpan" id="kobo.199.2">In this example, I will have four fields: </span><strong class="bold"><span class="koboSpan" id="kobo.200.1">description</span></strong><span class="koboSpan" id="kobo.201.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">amount excluding VAT</span></strong><span class="koboSpan" id="kobo.203.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">VAT percentage</span></strong><span class="koboSpan" id="kobo.205.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.207.1">date</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.209.1">You can find the complete form and styling in this book’s GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">repository: </span></span><a href="https://github.com/PacktPublishing/Effective-Angular/tree/feature/chapter-four/building-forms-like-a-pro"><span class="No-Break"><span class="koboSpan" id="kobo.211.1">https://github.com/PacktPublishing/Effective-Angular/tree/feature/chapter-four/building-forms-like-a-pro</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.212.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.213.1">Import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">AddExpenseForm</span></strong><span class="koboSpan" id="kobo.215.1"> class into </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">expenses-overview-page.component.ts</span></strong><span class="koboSpan" id="kobo.217.1"> and add the component selector in the corresponding HTML file to display our HTML form. </span><span class="koboSpan" id="kobo.217.2">When you click the submit button, you’ll notice that the page is reloaded; this is the default native behavior when submitting forms. </span><span class="koboSpan" id="kobo.217.3">Yet, when building modern applications using frameworks such as Angular, we expect a better user experience where we process form submissions without page reloads, just like when we route to pages without reloading </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">the page.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">We’ll start converting our native HTML form into an Angular template-driven form by importing </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">FormsModule</span></strong><span class="koboSpan" id="kobo.221.1">. </span><span class="koboSpan" id="kobo.221.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">FormsModule</span></strong><span class="koboSpan" id="kobo.223.1"> contains all the directives we need to build our template-driven forms. </span><span class="koboSpan" id="kobo.223.2">If you’re building with </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">NgModules</span></strong><span class="koboSpan" id="kobo.225.1">, you must import </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">FormsModule</span></strong><span class="koboSpan" id="kobo.227.1"> in the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">NgModule</span></strong><span class="koboSpan" id="kobo.229.1">. </span><span class="koboSpan" id="kobo.229.2">We’re using standalone components, so we’ll import </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">FormsModule</span></strong><span class="koboSpan" id="kobo.231.1"> into components where we build a form. </span><span class="koboSpan" id="kobo.231.2">Add </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">FormsModule</span></strong><span class="koboSpan" id="kobo.233.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">imports</span></strong><span class="koboSpan" id="kobo.235.1"> array of the component decorator of our newly created </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">add-expense</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.237.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.238.1">
imports: [CommonModule, </span><strong class="bold"><span class="koboSpan" id="kobo.239.1">FormsModule</span></strong><span class="koboSpan" id="kobo.240.1">]</span></pre> <p><span class="koboSpan" id="kobo.241.1">After adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">FormsModule</span></strong><span class="koboSpan" id="kobo.243.1">, the page won’t be reloaded when you click your form’s submit button, which is precisely what </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">we wanted.</span></span></p>
<p><span class="koboSpan" id="kobo.245.1">But how can</span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.246.1"> this be, since we didn’t change our form? </span><span class="koboSpan" id="kobo.246.2">The Angular </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">ngForm</span></strong><span class="koboSpan" id="kobo.248.1"> directive prevents the default browser behavior when submitting the form, and because of that, the page isn’t reloading. </span><span class="koboSpan" id="kobo.248.2">But we didn’t add the directive to our form, so why isn’t the </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">page reloading?</span></span></p>
<p><span class="koboSpan" id="kobo.250.1">The answer lies in the selector of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">ngForm</span></strong><span class="koboSpan" id="kobo.252.1"> directive. </span><span class="koboSpan" id="kobo.252.2">When we inspect the selector of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">ngForm</span></strong><span class="koboSpan" id="kobo.254.1"> directive, we can see that the directive is automatically applied to all form tags, and because we’ve added </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">FormsModule</span></strong><span class="koboSpan" id="kobo.256.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">ngForm</span></strong><span class="koboSpan" id="kobo.258.1"> directive is applied to the form in our component. </span><span class="koboSpan" id="kobo.258.2">Even though the directive is automatically applied to HTML form tags, it’s advised to write declarative code and manually apply the directive to form tags. </span><span class="koboSpan" id="kobo.258.3">So, add the directive to your form tag </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.260.1">
&lt;form #addExpenseForm="ngForm"&gt;………&lt;/form&gt;</span></pre> <p><span class="koboSpan" id="kobo.261.1">On the left, we added a template variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">#addExpenseForm</span></strong><span class="koboSpan" id="kobo.263.1">, while on the right, we assigned this template variable with an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">ngForm</span></strong><span class="koboSpan" id="kobo.265.1"> directive. </span><span class="koboSpan" id="kobo.265.2">By assigning the directive to a template variable, we can use the directive in all sibling and child elements of our HTML </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">form tag.</span></span></p>
<p><span class="koboSpan" id="kobo.267.1">Now that we’ve added the forms module and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">ngForm</span></strong><span class="koboSpan" id="kobo.269.1"> directive, we can start to configure the fields of our </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">template-driven form.</span></span></p>
<h3><span class="koboSpan" id="kobo.271.1">Configuring template-driven form fields</span></h3>
<p><span class="koboSpan" id="kobo.272.1">To have a</span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.273.1"> template-driven form, we need to connect the form’s input fields to an object in our component class and bind the fields to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">ngForm</span></strong><span class="koboSpan" id="kobo.275.1"> instance to validate the </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">entire form.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">Let’s start by creating an interface for the object we want to use in </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">our form.</span></span></p>
<p><span class="koboSpan" id="kobo.279.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">add-expense</span></strong><span class="koboSpan" id="kobo.281.1"> folder, create a new file, </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">add-expense.interface.ts</span></strong><span class="koboSpan" id="kobo.283.1">, and add the interface reflecting the fields in </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">your form.</span></span></p>
<p><span class="koboSpan" id="kobo.285.1">For our example, this is the </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">interface definition:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.287.1">
export interface AddExpense {
  description: string;
  amountExclVat: number | null;
  vatPercentage: number | null;
  date: Date | null;
}</span></pre> <p><span class="koboSpan" id="kobo.288.1">Also, export the interface in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">index.ts</span></strong><span class="koboSpan" id="kobo.290.1"> file of the library. </span><span class="koboSpan" id="kobo.290.2">Now, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">add-expense.component.ts</span></strong><span class="koboSpan" id="kobo.292.1">, define a property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">AddExpense</span></strong><span class="koboSpan" id="kobo.294.1"> type, </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.296.1">
@Input() expenseToAdd: AddExpense = { description: '', amountExclVat: null, vatPercentage: null, date: null }</span></pre> <p><span class="koboSpan" id="kobo.297.1">Here, we </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.298.1">used an input with a default value. </span><span class="koboSpan" id="kobo.298.2">We used an input because the form will be a dumb component, and the parent component will input any default values other than </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">empty values.</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">Note that you don’t have to use an object in a template-driven form; you can also use separated properties or a combination of properties and objects. </span><span class="koboSpan" id="kobo.300.2">Once you’ve defined the object, you need to bind the properties of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">expenseToAdd</span></strong><span class="koboSpan" id="kobo.302.1"> object to the fields of your form. </span><span class="koboSpan" id="kobo.302.2">We can do this using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">ngModel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.304.1"> directive.</span></span></p>
<p><span class="koboSpan" id="kobo.305.1">When you add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">ngModel</span></strong><span class="koboSpan" id="kobo.307.1"> directive, behind the scenes, Angular registers </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">FormControl</span></strong><span class="koboSpan" id="kobo.309.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">ngForm</span></strong><span class="koboSpan" id="kobo.311.1"> instance. </span><span class="koboSpan" id="kobo.311.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">ngModel</span></strong><span class="koboSpan" id="kobo.313.1"> directive allows for two-way data binding, meaning the values of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">expenseToAdd</span></strong><span class="koboSpan" id="kobo.315.1"> object and our form will automatically be synchronized if we change the properties in our component class or if the user enters values inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">form inputs.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">You connect the properties of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">expenseToAdd</span></strong><span class="koboSpan" id="kobo.319.1"> object to the form inputs by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">ngModel</span></strong><span class="koboSpan" id="kobo.321.1"> directive and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">name</span></strong><span class="koboSpan" id="kobo.323.1"> attribute to each of the form inputs, </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.325.1">
&lt;input </span><strong class="bold"><span class="koboSpan" id="kobo.326.1">[(ngModel)]="expenseToAdd.description"</span></strong><span class="koboSpan" id="kobo.327.1"> type="text" id="description" </span><strong class="bold"><span class="koboSpan" id="kobo.328.1">name="description"</span></strong><span class="koboSpan" id="kobo.329.1">&gt;</span></pre> <p><span class="koboSpan" id="kobo.330.1">As you can see, we use the banana-in-the-box syntax for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">ngModel</span></strong><span class="koboSpan" id="kobo.332.1"> directive, just like we did with two-way data binding for inputs and outputs in </span><a href="B21625_02.xhtml#_idTextAnchor033"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.333.1">Chapter 2</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.334.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.335.1">Just like using two-way data binding for input values, you can also split this </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">ngModel</span></strong><span class="koboSpan" id="kobo.337.1"> into a separate input and output, </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.339.1">
[ngModel]="expenseToAdd.description" (ngModelChange)="expenseToAdd.description = $event"</span></pre> <p class="callout-heading"><span class="koboSpan" id="kobo.340.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.341.1">Using the input and output separately can be useful when you’re working with Signals or when you want to perform additional logic before binding the input value to the </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">data model.</span></span></p>
<p><span class="koboSpan" id="kobo.343.1">When </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.344.1">you create your input fields, adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">name</span></strong><span class="koboSpan" id="kobo.346.1"> attribute to the field is important as this provides a unique key for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">ngForm</span></strong><span class="koboSpan" id="kobo.348.1"> instance to track the form field. </span><span class="koboSpan" id="kobo.348.2">You will get an error in your browser console if you don’t add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">name</span></strong><span class="koboSpan" id="kobo.350.1"> attribute. </span><span class="koboSpan" id="kobo.350.2">Now, go ahead and add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">ngModel</span></strong><span class="koboSpan" id="kobo.352.1"> directive and </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">name</span></strong><span class="koboSpan" id="kobo.354.1"> attribute for all the fields in your form. </span><span class="koboSpan" id="kobo.354.2">After adding all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">ngModel</span></strong><span class="koboSpan" id="kobo.356.1"> directives and </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">name</span></strong><span class="koboSpan" id="kobo.358.1"> attributes, you can confirm that two-way data binding works by temporarily adding the following code to your </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">HTML template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.360.1">
{{ expenseToAdd | json }}</span></pre> <p><span class="koboSpan" id="kobo.361.1">After adding the preceding code to your HTML template, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">expenseToAdd</span></strong><span class="koboSpan" id="kobo.363.1"> object is displayed as JSON on your screen. </span><span class="koboSpan" id="kobo.363.2">When you start to type in the form inputs, you can see the properties of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">expenseToAdd</span></strong><span class="koboSpan" id="kobo.365.1"> object being updated. </span><span class="koboSpan" id="kobo.365.2">Vice versa, when you assign values to the properties of </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">expenseToAdd</span></strong><span class="koboSpan" id="kobo.367.1"> in your component class, the form is also updated, and just like that, you’ve created a form with two-way </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">data binding.</span></span></p>
<p><span class="koboSpan" id="kobo.369.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">ngModel</span></strong><span class="koboSpan" id="kobo.371.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">ngForm</span></strong><span class="koboSpan" id="kobo.373.1"> directives have some other interesting configurations that are useful. </span><span class="koboSpan" id="kobo.373.2">Let’s start by </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">examining </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">ngModelOptions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.377.1">Additional form field options</span></h3>
<p><span class="koboSpan" id="kobo.378.1">You can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">ngModelOptions</span></strong><span class="koboSpan" id="kobo.380.1"> to configure form control instances in template-driven forms. </span><span class="koboSpan" id="kobo.380.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">ngModelOptions</span></strong><span class="koboSpan" id="kobo.382.1"> directive can be used to define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">name</span></strong><span class="koboSpan" id="kobo.384.1"> attribute, control </span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.385.1">the update behavior, or mark an </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">ngModel</span></strong><span class="koboSpan" id="kobo.387.1"> instance </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">as standalone.</span></span></p>
<p><span class="koboSpan" id="kobo.389.1">You can add </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">ngModelOptions</span></strong><span class="koboSpan" id="kobo.391.1"> by adding the directive to an input field where you declare the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">ngModel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.393.1"> directive:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.394.1">
[ngModelOptions]="{name: 'description', updateOn: 'blur', standalone: false}"</span></pre> <p><span class="koboSpan" id="kobo.395.1">Let’s learn more about the properties you can set on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">ngModelOptions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.397.1"> directive.</span></span></p>
<h4><span class="koboSpan" id="kobo.398.1">Using the name property</span></h4>
<p><span class="koboSpan" id="kobo.399.1">When</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.400.1"> you set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">name</span></strong><span class="koboSpan" id="kobo.402.1"> property of </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">ngModelOptions</span></strong><span class="koboSpan" id="kobo.404.1">, you can remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">name</span></strong><span class="koboSpan" id="kobo.406.1"> attribute on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">input</span></strong><span class="koboSpan" id="kobo.408.1"> field as using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">name</span></strong><span class="koboSpan" id="kobo.410.1"> property with </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">ngModelOptions</span></strong><span class="koboSpan" id="kobo.412.1"> is the same as providing the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">name</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.414.1"> attribute.</span></span></p>
<h4><span class="koboSpan" id="kobo.415.1">Using the updateOn property</span></h4>
<p><span class="koboSpan" id="kobo.416.1">Next, we</span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.417.1"> have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">updateOn</span></strong><span class="koboSpan" id="kobo.419.1"> property, which controls the update behavior of the form control and can take three values – </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">change</span></strong><span class="koboSpan" id="kobo.421.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">blur</span></strong><span class="koboSpan" id="kobo.423.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">submit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">change</span></strong><span class="koboSpan" id="kobo.428.1">: This is the default value and doesn’t have to be set explicitly unless the update strategy for the entire form is changed to something else. </span><span class="koboSpan" id="kobo.428.2">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">change</span></strong><span class="koboSpan" id="kobo.430.1"> value, the form control will update on </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">each keystroke.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">blur</span></strong><span class="koboSpan" id="kobo.433.1">: When you set </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">updateOn</span></strong><span class="koboSpan" id="kobo.435.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">blur</span></strong><span class="koboSpan" id="kobo.437.1">, the form control will update when you blur (focus out) from the correlating input field. </span><span class="koboSpan" id="kobo.437.2">This can be useful when you run some logic that can take a lot of time or resources to run. </span><span class="koboSpan" id="kobo.437.3">If you run heavy logic on each keystroke, your performance </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">will suffer.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">submit</span></strong><span class="koboSpan" id="kobo.440.1">: If you set </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">updateOn</span></strong><span class="koboSpan" id="kobo.442.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">submit</span></strong><span class="koboSpan" id="kobo.444.1">, the form control will only be updated when the form is submitted. </span><span class="koboSpan" id="kobo.444.2">Just like </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">blur</span></strong><span class="koboSpan" id="kobo.446.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">submit</span></strong><span class="koboSpan" id="kobo.448.1"> option can help improve the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">your form.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.450.1">You can also change the update behavior for all the form controls in your form by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">ngFormOptions</span></strong><span class="koboSpan" id="kobo.452.1"> directive on the HTML form tag. </span><span class="koboSpan" id="kobo.452.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">ngFormOptions</span></strong><span class="koboSpan" id="kobo.454.1"> directive only takes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">updateOn</span></strong><span class="koboSpan" id="kobo.456.1"> property. </span><span class="koboSpan" id="kobo.456.2">When you change the update behavior of the entire form, you can still overwrite it for individual form controls using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">ngModelOptions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.458.1"> directive.</span></span></p>
<h4><span class="koboSpan" id="kobo.459.1">Using the standalone property</span></h4>
<p><span class="koboSpan" id="kobo.460.1">Lastly, we</span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.461.1"> have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">standalone</span></strong><span class="koboSpan" id="kobo.463.1"> property. </span><span class="koboSpan" id="kobo.463.2">When you mark a form control as standalone, the form control won’t register itself in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">ngForm</span></strong><span class="koboSpan" id="kobo.465.1"> instance. </span><span class="koboSpan" id="kobo.465.2">When a form control is marked as standalone, you don’t have to provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">name</span></strong><span class="koboSpan" id="kobo.467.1"> attribute because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">ngForm</span></strong><span class="koboSpan" id="kobo.469.1"> instance doesn’t have to track the value of the input. </span><span class="koboSpan" id="kobo.469.2">Determining the form’s validity will also not account for the fields marketed as standalone. </span><span class="koboSpan" id="kobo.469.3">This can be useful when you have form fields that do not represent the </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">form model.</span></span></p>
<p><span class="koboSpan" id="kobo.471.1">Another scenario for standalone form controls is a single input for which you don’t need to create an entire form, but you do want to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">ngModel</span></strong><span class="koboSpan" id="kobo.473.1"> directive. </span><span class="koboSpan" id="kobo.473.2">Some examples might be a theme toggle, language selection, </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">or search.</span></span></p>
<h3><span class="koboSpan" id="kobo.475.1">Grouping template-driven form fields</span></h3>
<p><span class="koboSpan" id="kobo.476.1">Often, you </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.477.1">have a group of form fields that belong together. </span><span class="koboSpan" id="kobo.477.2">A good example is address fields such as street, ZIP code, and house number. </span><span class="koboSpan" id="kobo.477.3">You might want to check the validity of the fields as a group, add styling or user feedback, or perform validation logic on the group instead of the </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">individual fields.</span></span></p>
<p><span class="koboSpan" id="kobo.479.1">For these use cases, Angular provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">FormGroup</span></strong><span class="koboSpan" id="kobo.481.1"> class. </span><span class="koboSpan" id="kobo.481.2">In template-driven forms, you can create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">FormGroup</span></strong><span class="koboSpan" id="kobo.483.1"> class using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">ngModelGroup</span></strong><span class="koboSpan" id="kobo.485.1"> directive. </span><span class="koboSpan" id="kobo.485.2">When you declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">ngModel</span></strong><span class="koboSpan" id="kobo.487.1"> group, Angular will create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">FormGroup</span></strong><span class="koboSpan" id="kobo.489.1"> class behind </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">the scenes.</span></span></p>
<p><span class="koboSpan" id="kobo.491.1">Declaring </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">ngModelGroup</span></strong><span class="koboSpan" id="kobo.493.1"> is simple! </span><span class="koboSpan" id="kobo.493.2">Just add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">ngModelGroup</span></strong><span class="koboSpan" id="kobo.495.1"> directive to an HTML tag, which wraps multiple HTML elements with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">ngModel</span></strong><span class="koboSpan" id="kobo.497.1"> directive declared </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">on it.</span></span></p>
<p><span class="koboSpan" id="kobo.499.1">As an example, we can group our amount, excluding VAT, and VAT </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">percentage fields.</span></span></p>
<p><span class="koboSpan" id="kobo.501.1">We can do this </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">like so:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.503.1">Wrap the HTML for the amount and VAT percentage fields inside a </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">fieldset</span></strong><span class="koboSpan" id="kobo.505.1"> tag and declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">ngModelGroup</span></strong><span class="koboSpan" id="kobo.507.1"> directive on this </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">fieldset</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.509.1"> tag.</span></span></li>
<li><span class="koboSpan" id="kobo.510.1">Assign </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">ngModelGroup</span></strong><span class="koboSpan" id="kobo.512.1"> with a name for your </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">FormGroup</span></strong><span class="koboSpan" id="kobo.514.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">that’s it:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.516.1">
&lt;fieldset </span><strong class="bold"><span class="koboSpan" id="kobo.517.1">ngModelGroup="amount"</span></strong><span class="koboSpan" id="kobo.518.1">&gt;&lt;/fieldset&gt;</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.519.1">Now that all the </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.520.1">input fields have been declared and bound to your data fields using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">ngModel</span></strong><span class="koboSpan" id="kobo.522.1"> directive, you need a way to listen for the </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">form submission.</span></span></p>
<h3><span class="koboSpan" id="kobo.524.1">Submitting template-driven forms</span></h3>
<p><span class="koboSpan" id="kobo.525.1">As you </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.526.1">may have noticed, we added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">submit</span></strong><span class="koboSpan" id="kobo.528.1"> type to our </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">submit button:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.530.1">
&lt;button type="submit"&gt;Submit&lt;/button&gt;</span></pre> <p><span class="koboSpan" id="kobo.531.1">This will trigger a submit event. </span><span class="koboSpan" id="kobo.531.2">When this submit event happens, Angular will trigger its own internal submit event called </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">ngSubmit</span></strong><span class="koboSpan" id="kobo.533.1">. </span><span class="koboSpan" id="kobo.533.2">We can listen for this </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">ngSubmit</span></strong><span class="koboSpan" id="kobo.535.1"> event as we would for any other browser event or </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">component output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.537.1">
&lt;form #addExpenseForm="ngForm" </span><strong class="bold"><span class="koboSpan" id="kobo.538.1">(ngSubmit)="onSubmit()"</span></strong><span class="koboSpan" id="kobo.539.1">&gt;</span></pre> <p><span class="koboSpan" id="kobo.540.1">You declare </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">ngSubmit</span></strong><span class="koboSpan" id="kobo.542.1"> on the form tag; on the right-hand side, you declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">ngSubmit</span></strong><span class="koboSpan" id="kobo.544.1"> event in round brackets; and on the left-hand side, you define a function that’s declared in the component class to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">the submission.</span></span></p>
<p><span class="koboSpan" id="kobo.546.1">For our example, we will create an output event to output a clone of the form object and reset the form using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">ngForm</span></strong><span class="koboSpan" id="kobo.548.1"> instance. </span><span class="koboSpan" id="kobo.548.2">To achieve this, we need a way to access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">ngForm</span></strong><span class="koboSpan" id="kobo.550.1"> instance in our component class; we can do this using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">ViewChild</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.553.1"> directive:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.554.1">
@ViewChild('addExpenseForm') form!: NgForm;</span></pre> <p><span class="koboSpan" id="kobo.555.1">Next, we need to add the component’s output, which will allow us to send the submitted values to the parent component so that it can act upon </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">it accordingly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.557.1">
@Output() addExpense = new EventEmitter&lt;AddExpense&gt;();</span></pre> <p><span class="koboSpan" id="kobo.558.1">Lastly, we need to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">onSubmit</span></strong><span class="koboSpan" id="kobo.560.1"> method with </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">our logic:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.562.1">
onSubmit() {
  this.addExpense.emit(structuredClone(this.expenseToAdd));
  this.form.reset();
}</span></pre> <p><span class="koboSpan" id="kobo.563.1">As you </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.564.1">can see, we used the native </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">structuredClone</span></strong><span class="koboSpan" id="kobo.566.1"> method to send a clone of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">expenseToAdd</span></strong><span class="koboSpan" id="kobo.568.1"> object to the parent. </span><span class="koboSpan" id="kobo.568.2">We sent a clone because </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">expenseToAdd</span></strong><span class="koboSpan" id="kobo.570.1"> is a reference object, meaning it will be cleared everywhere (also in the parent component) after we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">reset</span></strong><span class="koboSpan" id="kobo.572.1"> on the form, and it will clear the object we bound to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">ngForm</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.574.1"> instance.</span></span></p>
<p><span class="koboSpan" id="kobo.575.1">Now that we’ve added the submit logic, we’ll start exploring validation rules, control status, and how to display messages to the user based on the control statuses and validity of the form and </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">its controls.</span></span></p>
<h3><span class="koboSpan" id="kobo.577.1">Using built-in validation rules for template-driven forms</span></h3>
<p><span class="koboSpan" id="kobo.578.1">For a </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.579.1">good user experience, it’s important to provide good user feedback on our form. </span><span class="koboSpan" id="kobo.579.2">You want to indicate when your form fields are valid or still require some changes to be made by the user. </span><span class="koboSpan" id="kobo.579.3">You also want to prevent the user from submitting the form when not all the fields are valid and provide good error messages for incorrect or incomplete </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">form fields.</span></span></p>
<p><span class="koboSpan" id="kobo.581.1">To achieve these feats, you must add form validations to the form fields and use the control statuses to add or remove styling and error messages. </span><span class="koboSpan" id="kobo.581.2">Let’s start by exploring how to validate form fields in </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">template-driven forms.</span></span></p>
<p><span class="koboSpan" id="kobo.583.1">Validating the form fields of template-driven forms can be done using directives. </span><span class="koboSpan" id="kobo.583.2">Most validations can be done using the built-in validation directives, but when needed, you can also create your own directives to validate template-driven </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">form fields.</span></span></p>
<p><span class="koboSpan" id="kobo.585.1">You can find all built-in validation directives on the official Angular </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">website:</span></span><span class="No-Break"><span class="P---URL"> </span></span><a href="https://angular.io/api/forms/Validators"><span class="No-Break"><span class="koboSpan" id="kobo.587.1">https://angular.io/api/forms/Validators</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.588.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.589.1">Let’s learn how to add validators to our example form. </span><span class="koboSpan" id="kobo.589.2">We will start by making our form fields required using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">required</span></strong><span class="koboSpan" id="kobo.591.1"> directive. </span><span class="koboSpan" id="kobo.591.2">You can apply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">required</span></strong><span class="koboSpan" id="kobo.593.1"> validator by adding this directive to your </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">input</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.595.1"> fields:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.596.1">
&lt;input </span><strong class="bold"><span class="koboSpan" id="kobo.597.1">required</span></strong><span class="koboSpan" id="kobo.598.1"> [(ngModel)]="expenseToAdd.amountExclVat" &gt;</span></pre> <p><span class="koboSpan" id="kobo.599.1">As you can see, adding the built-in validators is simple. </span><span class="koboSpan" id="kobo.599.2">Let’s add another validator to limit the maximum number we accept on our VAT percentage field. </span><span class="koboSpan" id="kobo.599.3">It wouldn’t make sense to enter a number higher than 100 for a percentage field. </span><span class="koboSpan" id="kobo.599.4">To achieve this, you can use the built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">max</span></strong><span class="koboSpan" id="kobo.601.1"> validator. </span><span class="koboSpan" id="kobo.601.2">You can still type a number higher than 100, but the form field will </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">be invalid.</span></span></p>
<p><span class="koboSpan" id="kobo.603.1">To apply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">max</span></strong><span class="koboSpan" id="kobo.605.1"> validator, add the following to the </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">input tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.607.1">
[max]="100"</span></pre> <p><span class="koboSpan" id="kobo.608.1">You can </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.609.1">also conditionally add validators. </span><span class="koboSpan" id="kobo.609.2">Upon using the notation with square brackets, as we did with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">max</span></strong><span class="koboSpan" id="kobo.611.1"> validator, and supplying a property to it as a value when the value is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">null</span></strong><span class="koboSpan" id="kobo.613.1">, the validation rule </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">is disabled:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.615.1">
[max]="null" [disabled]="null"</span></pre> <p><span class="koboSpan" id="kobo.616.1">If you want, you can add additional validation rules to your form; go through the validators in the Angular documentation and add the directives of the validation rules you want </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">to use.</span></span></p>
<p><span class="koboSpan" id="kobo.618.1">I briefly want to mention the pattern validator as this is a special one. </span><span class="koboSpan" id="kobo.618.2">The pattern validator can be used for many use cases as it takes a regular expression and checks if the value in the input field matches the regular expression pattern. </span><span class="koboSpan" id="kobo.618.3">Other validators are used for a single purpose, such as checking for a maximum input value or whether the field has </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">a value.</span></span></p>
<p><span class="koboSpan" id="kobo.620.1">Now that you know how to add the built-in validation rules, let’s find out how we can style the form fields based on the status and validity of the form and </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">form controls.</span></span></p>
<h3><span class="koboSpan" id="kobo.622.1">Styling the form and form fields based on control status values</span></h3>
<p><span class="koboSpan" id="kobo.623.1">To</span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.624.1"> provide a good user experience for your application users, it’s important to provide visual feedback about the status of the form and its fields. </span><span class="koboSpan" id="kobo.624.2">The</span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.625.1"> best way to do this is by utilizing the control status of your form and its </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">form controls.</span></span></p>
<p><span class="koboSpan" id="kobo.627.1">The form, as well as its </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">FormGroup</span></strong><span class="koboSpan" id="kobo.629.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">FormControl</span></strong><span class="koboSpan" id="kobo.631.1"> instances, are updated by Angular with a control status and corresponding CSS classes. </span><span class="koboSpan" id="kobo.631.2">The best way to provide visual feedback about the status of your form and its fields is by providing styles for the control status CSS classes. </span><span class="koboSpan" id="kobo.631.3">Because these stylings are shared among all your applications, it’s a good practice to create them as a </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">global styling.</span></span></p>
<p><span class="koboSpan" id="kobo.633.1">Let’s start by creating a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">global-styling</span></strong><span class="koboSpan" id="kobo.635.1"> folder under the shared library folder. </span><span class="koboSpan" id="kobo.635.2">In this </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">global-styling</span></strong><span class="koboSpan" id="kobo.637.1"> folder, create a file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">form-control-status.scss</span></strong><span class="koboSpan" id="kobo.639.1">. </span><span class="koboSpan" id="kobo.639.2">After you’ve made the folder and file, add the following under </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">devDependencies</span></strong><span class="koboSpan" id="kobo.641.1"> in the root </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">package.json</span></strong><span class="koboSpan" id="kobo.643.1"> file of the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.644.1">Nx monorepo</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.646.1">
"@global/styling": "file:libs/shared/global-styling"</span></pre> <p><span class="koboSpan" id="kobo.647.1">Next, you </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.648.1">need to run </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">npm install</span></strong><span class="koboSpan" id="kobo.650.1"> so that you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">@global/styling</span></strong><span class="koboSpan" id="kobo.652.1"> to import your global styling inside CSS files throughout your </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.653.1">Nx monorepo</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.655.1">Now, it’s time to add the styling for the control status CSS classes inside our newly created </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">CSS file.</span></span></p>
<p><span class="koboSpan" id="kobo.657.1">Angular </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.658.1">provides us with eight different control status CSS classes by which we can style our form and its form groups </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">and controls:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">ng-valid</span></strong><span class="koboSpan" id="kobo.661.1">: This is applied when the form control or group is valid based on the validation rules. </span><span class="koboSpan" id="kobo.661.2">It’s applied to the form when all groups and controls </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">are valid.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">ng-invalid</span></strong><span class="koboSpan" id="kobo.664.1">: This is applied when the form control doesn’t pass all validation rules. </span><span class="koboSpan" id="kobo.664.2">It’s applied to the form when one or more controls </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">are invalid.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">ng-pending</span></strong><span class="koboSpan" id="kobo.667.1">: This is applied when an asynchronous validation is </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">being validated.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">ng-pristine</span></strong><span class="koboSpan" id="kobo.670.1">: This is applied to a form control that has not been interacted with. </span><span class="koboSpan" id="kobo.670.2">It’s applied to the form when there has been no interaction with any of the </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">form controls.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">ng-dirty</span></strong><span class="koboSpan" id="kobo.673.1">: This is applied to a form control that has been interacted with. </span><span class="koboSpan" id="kobo.673.2">It’s applied to the form when there has been interaction with at least one </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">form control.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">ng-untouched</span></strong><span class="koboSpan" id="kobo.676.1">: This is applied to a form control that the user has not focused on or interacted with. </span><span class="koboSpan" id="kobo.676.2">It’s applied to the form when no field has been focused or </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">interacted with.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">ng-touched</span></strong><span class="koboSpan" id="kobo.679.1">: This is applied to a form control that the user has focused on or interacted with. </span><span class="koboSpan" id="kobo.679.2">It’s applied to the form when at least one field has been focused or </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">interacted with.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">ng-submitted</span></strong><span class="koboSpan" id="kobo.682.1">: This is applied to the form element when the form has </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">been submitted.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.684.1">You can </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.685.1">use these CSS classes to style the form however you see fit. </span><span class="koboSpan" id="kobo.685.2">We will style the form fields based on their validity in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">add-expense</span></strong><span class="koboSpan" id="kobo.687.1"> form </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.688.1">but only do so when the form has </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">been touched.</span></span></p>
<p><span class="koboSpan" id="kobo.690.1">You can add the following inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">form-control-status.scss</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.692.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.693.1">
form.ng-touched {
  .ng-valid:not(fieldset)  {
    border-left: 5px solid #42A948; /* green */
  }
  .ng-invalid:not(form, fieldset) {
    border-left: 5px solid #a94442; /* red */
  }
}</span></pre> <p><span class="koboSpan" id="kobo.694.1">Now, we only need to import this file into the CSS file of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">add-expense</span></strong><span class="koboSpan" id="kobo.696.1"> form. </span><span class="koboSpan" id="kobo.696.2">Open your </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">add-expense.component.scss</span></strong><span class="koboSpan" id="kobo.698.1"> file and add the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">import</span></strong><span class="koboSpan" id="kobo.700.1"> statement at the top of the file to import the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">form-control-status</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.702.1"> styling:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.703.1">
@import '@global/styling/form-control-status';</span></pre> <p><span class="koboSpan" id="kobo.704.1">After adding the import, the styles will be applied to </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">the form.</span></span></p>
<p><span class="koboSpan" id="kobo.706.1">Now that you know how to style the form and its form groups and controls using the control status classes, let’s learn how to display messages to the user based on the status of the </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">form controls.</span></span></p>
<h3><span class="koboSpan" id="kobo.708.1">Displaying messages based on the status of form controls</span></h3>
<p><span class="koboSpan" id="kobo.709.1">You </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.710.1">can improve the user experience even further by showing messages when a form field isn’t valid. </span><span class="koboSpan" id="kobo.710.2">You can do this by using the form control instances created </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">ngModel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.714.1">Start by adding a template variable to the inputs where you declared </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">ngModel</span></strong><span class="koboSpan" id="kobo.716.1"> and assign the </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">ngModel</span></strong><span class="koboSpan" id="kobo.718.1"> instance to the template variable so that you can use it throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">the template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.720.1">
&lt;input required [(ngModel)]="expenseToAdd.description"
       </span><strong class="bold"><span class="koboSpan" id="kobo.721.1">#description=»ngModel»</span></strong><span class="koboSpan" id="kobo.722.1"> type="text" id="description"&gt;</span></pre> <p><span class="koboSpan" id="kobo.723.1">As you can see, we’ve added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">#description</span></strong><span class="koboSpan" id="kobo.725.1"> template variable and assigned it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">ngModel</span></strong><span class="koboSpan" id="kobo.727.1">. </span><span class="koboSpan" id="kobo.727.2">Now, you can access and control the form control instance created by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">ngModel</span></strong><span class="koboSpan" id="kobo.729.1"> instance through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">#decscription</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.731.1">template variable.</span></span></p>
<p><span class="koboSpan" id="kobo.732.1">Let’s add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">span</span></strong><span class="koboSpan" id="kobo.734.1"> element with an error message underneath the </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">input element:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.736.1">
&lt;span&gt;This field is required&lt;/span&gt;</span></pre> <p><span class="koboSpan" id="kobo.737.1">Next, we want to ensure this message is only shown when the form has been touched, and the input validator needs to be satisfied. </span><span class="koboSpan" id="kobo.737.2">We can do this by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">ngForm</span></strong><span class="koboSpan" id="kobo.739.1"> and the form control instance, which we bound to the template variables. </span><span class="koboSpan" id="kobo.739.2">The form control instance exposes several properties that we can check to determine the status of the correlating </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">input field.</span></span></p>
<p><span class="koboSpan" id="kobo.741.1">Like the control status CSS classes, the form and form control itself expose properties to assess the same statuses: </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">valid</span></strong><span class="koboSpan" id="kobo.743.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">invalid</span></strong><span class="koboSpan" id="kobo.745.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">pending</span></strong><span class="koboSpan" id="kobo.747.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">pristine</span></strong><span class="koboSpan" id="kobo.749.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">dirty</span></strong><span class="koboSpan" id="kobo.751.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">touched</span></strong><span class="koboSpan" id="kobo.753.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">untouched</span></strong><span class="koboSpan" id="kobo.755.1">. </span><span class="koboSpan" id="kobo.755.2">The form control also exposes </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">disabled</span></strong><span class="koboSpan" id="kobo.757.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">enabled</span></strong><span class="koboSpan" id="kobo.759.1"> as checks of the disabled status of the correlating </span><span class="No-Break"><span class="koboSpan" id="kobo.760.1">input field.</span></span></p>
<p><span class="koboSpan" id="kobo.761.1">Besides these Boolean properties, the form control exposes multiple values and methods; you can find all the properties on the official Angular </span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">website: </span></span><a href="https://angular.io/api/forms/FormControl"><span class="No-Break"><span class="koboSpan" id="kobo.763.1">https://angular.io/api/forms/FormControl</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.764.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.765.1">Now, without further ado, let’s add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">*ngIf</span></strong><span class="koboSpan" id="kobo.767.1"> statement to our span element so that it’s only displayed when the input form is touched and the required validator of the form control </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">isn’t satisfied:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.769.1">
*ngIf="addExpenseForm.touched &amp;&amp; description.hasError('required')"</span></pre> <p><span class="koboSpan" id="kobo.770.1">As you can see, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">hasError</span></strong><span class="koboSpan" id="kobo.772.1"> method to check for the required validator. </span><span class="koboSpan" id="kobo.772.2">You can go ahead and add template variables for </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">ngModel</span></strong><span class="koboSpan" id="kobo.774.1"> and error messages for the other fields in the form. </span><span class="koboSpan" id="kobo.774.2">For our VAT percentage field, we will add an additional message to check for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">max</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.776.1"> validator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.777.1">
&lt;span *ngIf="addExpenseForm.touched &amp;&amp; </span><strong class="bold"><span class="koboSpan" id="kobo.778.1">vatPercentage.hasError('max')</span></strong><span class="koboSpan" id="kobo.779.1">"&gt;The max percentage allowed is 100&lt;/span&gt;</span></pre> <p><span class="koboSpan" id="kobo.780.1">In this</span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.781.1"> instance, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">hasError</span></strong><span class="koboSpan" id="kobo.783.1"> with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">max</span></strong><span class="koboSpan" id="kobo.785.1"> parameter to get the validity of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">max</span></strong><span class="koboSpan" id="kobo.787.1"> validator. </span><span class="koboSpan" id="kobo.787.2">If you want to display the message under other conditions, you can change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">*ngIf</span></strong><span class="koboSpan" id="kobo.789.1"> statement however you </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">see fit.</span></span></p>
<p><span class="koboSpan" id="kobo.791.1">Another common way to improve the user experience of your form is to prevent the user from submitting the form when the form isn’t valid yet. </span><span class="koboSpan" id="kobo.791.2">You can do this by binding the form validity to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">disabled</span></strong><span class="koboSpan" id="kobo.793.1"> attribute of the </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">submit button:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.795.1">
&lt;button </span><strong class="bold"><span class="koboSpan" id="kobo.796.1">[disabled]="addExpenseForm.invalid"</span></strong><span class="koboSpan" id="kobo.797.1"> type="submit"&gt;Submit&lt;/button&gt;</span></pre> <p><span class="koboSpan" id="kobo.798.1">Here, we simply used the reference to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">ngForm</span></strong><span class="koboSpan" id="kobo.800.1"> instance and made the button invalid when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">invalid</span></strong><span class="koboSpan" id="kobo.802.1"> property of the form </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">returned </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.806.1">Now that we’ve enhanced the user experience of our form by adding validation rules and supplying visual user feedback through styling and error messages, let’s move on and see how we can create custom validators for </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">template-driven forms.</span></span></p>
<h3><span class="koboSpan" id="kobo.808.1">Custom validators for template-driven forms</span></h3>
<p><span class="koboSpan" id="kobo.809.1">To </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.810.1">finish this section, we will learn how to create custom validators for template-driven forms. </span><span class="koboSpan" id="kobo.810.2">The built-in validators will cover most scenarios, but in some cases, you need to create custom validators – for example, when you want to</span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.811.1"> check values in your database or state when you need to perform cross-field validations or need to perform other validations that can’t be done with </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">built-in validators.</span></span></p>
<p><span class="koboSpan" id="kobo.813.1">All the built-in validators for template-driven forms are directives, so we also need to create a directive to build </span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">custom validators.</span></span></p>
<p><span class="koboSpan" id="kobo.815.1">Let’s start by creating a new library with our custom Nx generator. </span><span class="koboSpan" id="kobo.815.2">Name the library </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">form-validators</span></strong><span class="koboSpan" id="kobo.817.1">; then, select </span><strong class="bold"><span class="koboSpan" id="kobo.818.1">shared</span></strong><span class="koboSpan" id="kobo.819.1"> for the domain and </span><strong class="bold"><span class="koboSpan" id="kobo.820.1">util</span></strong><span class="koboSpan" id="kobo.821.1"> for its type. </span><span class="koboSpan" id="kobo.821.2">When the library is created, generate a directive inside it. </span><span class="koboSpan" id="kobo.821.3">Name the directive </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">max-word-count</span></strong><span class="koboSpan" id="kobo.823.1"> and check the </span><strong class="bold"><span class="koboSpan" id="kobo.824.1">standalone</span></strong><span class="koboSpan" id="kobo.825.1"> checkbox. </span><span class="koboSpan" id="kobo.825.2">After creating the directive, create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">template-driven-validators</span></strong><span class="koboSpan" id="kobo.827.1"> folder and move the directive inside it. </span><span class="koboSpan" id="kobo.827.2">Now, add an export for the directive </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">inside </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">index.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.831.1">
export * from './lib/template-driven-validators/max-word-count.directive';</span></pre> <p><span class="koboSpan" id="kobo.832.1">Now, let’s</span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.833.1"> add some validation logic inside </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.834.1">our directive. </span><span class="koboSpan" id="kobo.834.2">We’ll start by creating an input for our custom </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">validator directive:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.836.1">
@Input('btLibsUtilMaxWordCount') maxWords = 1;</span></pre> <p><span class="koboSpan" id="kobo.837.1">Next, we must implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">Validator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.839.1"> interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.840.1">
export class MaxWordCountDirective implements Validator {}</span></pre> <p><span class="koboSpan" id="kobo.841.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">Validator</span></strong><span class="koboSpan" id="kobo.843.1"> interface requires you to implement a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">validate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.845.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.846.1">
validate(control: AbstractControl): ValidationErrors|null{}</span></pre> <p><span class="koboSpan" id="kobo.847.1">As you can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">validate</span></strong><span class="koboSpan" id="kobo.849.1"> function takes </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">AbstractControl</span></strong><span class="koboSpan" id="kobo.851.1"> as input and returns either </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">null</span></strong><span class="koboSpan" id="kobo.853.1"> or a </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">ValidationErrors</span></strong><span class="koboSpan" id="kobo.855.1"> object. </span><span class="koboSpan" id="kobo.855.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">validate</span></strong><span class="koboSpan" id="kobo.857.1"> function, we will add our validation logic. </span><span class="koboSpan" id="kobo.857.2">When the validation passes, we will return </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">null</span></strong><span class="koboSpan" id="kobo.859.1">, and when the validation doesn’t pass, we will return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">ValidationErrors</span></strong><span class="koboSpan" id="kobo.861.1"> object. </span><span class="koboSpan" id="kobo.861.2">To perform some validation logic, we need to access the form control of the HTML element on which our directive </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">is declared.</span></span></p>
<p><span class="koboSpan" id="kobo.863.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">AbstractControl</span></strong><span class="koboSpan" id="kobo.865.1"> function parameter gives you access to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">FormControl</span></strong><span class="koboSpan" id="kobo.867.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">FormGroup</span></strong><span class="koboSpan" id="kobo.869.1"> instance, depending on which HTML element you place the directive. </span><span class="koboSpan" id="kobo.869.2">When you place the directive on HTML elements that declare </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">ngModel</span></strong><span class="koboSpan" id="kobo.871.1">, you will receive a </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">FormControl</span></strong><span class="koboSpan" id="kobo.873.1"> instance; if you put the directive on an HTML element with </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">ngModelGroup</span></strong><span class="koboSpan" id="kobo.875.1"> declared, you will receive a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">FormGroup</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.877.1"> instance.</span></span></p>
<p><span class="koboSpan" id="kobo.878.1">In our example, we will use the directive on elements with </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">ngModel</span></strong><span class="koboSpan" id="kobo.880.1"> on it and receive a </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">FormControl</span></strong><span class="koboSpan" id="kobo.882.1"> instance through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">function</span></strong><span class="koboSpan" id="kobo.884.1"> parameter. </span><span class="koboSpan" id="kobo.884.2">We want to check the value of our form control and determine if more words are in the value than we defined in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">maxWords</span></strong><span class="koboSpan" id="kobo.886.1"> input. </span><span class="koboSpan" id="kobo.886.2">When there are more words, our validation fails, and we return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">ValidationErrors</span></strong><span class="koboSpan" id="kobo.888.1"> object; otherwise, we return </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">null</span></strong><span class="koboSpan" id="kobo.890.1">, which means our </span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">validation passes.</span></span></p>
<p><span class="koboSpan" id="kobo.892.1">First, we must check the number </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">of words:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.894.1">
const wordCount = control?.value?.trim().split(' ').length;</span></pre> <p><span class="koboSpan" id="kobo.895.1">As you can see, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">control.value</span></strong><span class="koboSpan" id="kobo.897.1"> to get the value from the form control. </span><span class="koboSpan" id="kobo.897.2">If there is a value, we trim it and split it into spaces to get the number of words in the string. </span><span class="koboSpan" id="kobo.897.3">Next, we check if the number of words is bigger than the </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">maxWords</span></strong><span class="koboSpan" id="kobo.899.1"> input; if that is the case, we return the error object; otherwise, we return </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">null</span></strong><span class="koboSpan" id="kobo.901.1">. </span><span class="koboSpan" id="kobo.901.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">error</span></strong><span class="koboSpan" id="kobo.903.1"> object can have any format </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">you like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.905.1">
return wordCount &gt; this.maxWords ?   {btLibsUtilMaxWordCount: { count: wordCount }} : null;</span></pre> <p><span class="koboSpan" id="kobo.906.1">That is all </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.907.1">the logic we need for our custom validator. </span><span class="koboSpan" id="kobo.907.2">But</span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.908.1"> there is still one problem: when we declare the directive on our form, the form won’t know this directive is a custom validator; it will think it’s just a regular directive. </span><span class="koboSpan" id="kobo.908.2">Instead, we want our form to register the directive as a validator so that the form takes the directive into account when determining the form’s validity and its form groups and controls. </span><span class="koboSpan" id="kobo.908.3">We can achieve this by adding a provider to the </span><span class="No-Break"><span class="koboSpan" id="kobo.909.1">directive decorator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.910.1">
providers: [{
  provide: NG_VALIDATORS,
  useExisting: MaxWordCountDirective,
  multi: true
}]</span></pre> <p><span class="koboSpan" id="kobo.911.1">By adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">NG_VALIDATORS</span></strong><span class="koboSpan" id="kobo.913.1"> provider to our directive, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">ngForm</span></strong><span class="koboSpan" id="kobo.915.1"> instance will register the directive as a validator and include the directive when determining if the form and its groups and controls </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">are valid.</span></span></p>
<p><span class="koboSpan" id="kobo.917.1">To use the directive, you need to add the directive class’ name to the imports of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">add-expense</span></strong><span class="koboSpan" id="kobo.919.1"> component since both the directive and our component are standalone. </span><span class="koboSpan" id="kobo.919.2">After adding the directive to the imports array, you can use the directive in the </span><span class="No-Break"><span class="koboSpan" id="kobo.920.1">HTML template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.921.1">
&lt;input </span><strong class="bold"><span class="koboSpan" id="kobo.922.1">[btLibsUtilMaxWordCount]="3"</span></strong><span class="koboSpan" id="kobo.923.1"> [(ngModel)]="expenseToAdd.description" ………&gt;</span></pre> <p><span class="koboSpan" id="kobo.924.1">Now, when you type more than three words in the description input, the form field becomes invalid. </span><span class="koboSpan" id="kobo.924.2">You can check if the form control has errors related to our custom directive by using the template variable concerning the description form control and calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">hasError</span></strong><span class="koboSpan" id="kobo.926.1"> method on the control, just like we did when we checked for the </span><span class="No-Break"><span class="koboSpan" id="kobo.927.1">required error:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.928.1">
description.hasError('btLibsUtilMaxWordCount')</span></pre> <p><span class="koboSpan" id="kobo.929.1">When you</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.930.1"> look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.931.1">error</span></strong><span class="koboSpan" id="kobo.932.1"> object we return in our directive, you might notice that we included a </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">count</span></strong><span class="koboSpan" id="kobo.934.1"> property with the number</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.935.1"> of words we used in our </span><span class="No-Break"><span class="koboSpan" id="kobo.936.1">form control:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.937.1">
{btLibsUtilMaxWordCount: { count: wordCount }}</span></pre> <p><span class="koboSpan" id="kobo.938.1">You can retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">count</span></strong><span class="koboSpan" id="kobo.940.1"> value by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">getError</span></strong><span class="koboSpan" id="kobo.942.1"> method on the form </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">control instance:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.944.1">
description.getError('btLibsUtilMaxWordCount').count</span></pre> <p><span class="koboSpan" id="kobo.945.1">As you can see, we used the description template variable, which holds the reference to the form control instance, and called </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">getError</span></strong><span class="koboSpan" id="kobo.947.1"> to retrieve the error object. </span><span class="koboSpan" id="kobo.947.2">You can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">error</span></strong><span class="koboSpan" id="kobo.949.1"> object to display extra information to the user in an error message; in our example, you can include the current count </span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">of words.</span></span></p>
<p><span class="koboSpan" id="kobo.951.1">With that, you know how to add a custom validator to template-driven forms and show error messages when your custom errors occur. </span><span class="koboSpan" id="kobo.951.2">Next, we will learn how to validate form groups with </span><span class="No-Break"><span class="koboSpan" id="kobo.952.1">custom validators.</span></span></p>
<h4><span class="koboSpan" id="kobo.953.1">Validating form groups with custom validators</span></h4>
<p><span class="koboSpan" id="kobo.954.1">In our </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.955.1">current example, we’re declaring our custom validator directive on HTML elements with </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">ngModel</span></strong><span class="koboSpan" id="kobo.957.1"> declared on it. </span><span class="koboSpan" id="kobo.957.2">However, in some cases, you might want to perform cross-field validations or validate multiple fields at once. </span><span class="koboSpan" id="kobo.957.3">A typical example is when you have a password and confirm the password input field in your form and want to check if both fields hold the </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">same value.</span></span></p>
<p><span class="koboSpan" id="kobo.959.1">When you want to perform validation logic on a group of fields, you group the fields in your form using </span><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">ngModelGroup</span></strong><span class="koboSpan" id="kobo.961.1">, as we did with our VAT fields. </span><span class="koboSpan" id="kobo.961.2">Next, you must declare the custom validator on the HTML tag </span><span class="No-Break"><span class="koboSpan" id="kobo.962.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">ngModelGroup</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.964.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.965.1">When you declare the directive on an element with </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">ngModelGroup</span></strong><span class="koboSpan" id="kobo.967.1"> on it, the validator directive will receive </span><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">FormGroup</span></strong><span class="koboSpan" id="kobo.969.1"> as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">AbstractControl</span></strong><span class="koboSpan" id="kobo.971.1"> function parameter. </span><span class="koboSpan" id="kobo.971.2">Inside the custom validator, you can then access the values of the individual form controls of the form group, </span><span class="No-Break"><span class="koboSpan" id="kobo.972.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.973.1">
const password = control.get('password').value;
const confirm = control.get('password-confirm').value;</span></pre> <p><span class="koboSpan" id="kobo.974.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">string</span></strong><span class="koboSpan" id="kobo.976.1"> value </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.977.1">inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">get</span></strong><span class="koboSpan" id="kobo.979.1"> method should be equal to the name you declared on the form control in your </span><span class="No-Break"><span class="koboSpan" id="kobo.980.1">HTML template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.981.1">
&lt;input required [(ngModel)]="formObj.password" </span><strong class="bold"><span class="koboSpan" id="kobo.982.1">name="password"</span></strong><span class="koboSpan" id="kobo.983.1">&gt;</span></pre> <p><span class="koboSpan" id="kobo.984.1">For the rest, the custom validator is equal to our example validator. </span><span class="koboSpan" id="kobo.984.2">You perform the validation logic you want and return </span><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">null</span></strong><span class="koboSpan" id="kobo.986.1"> if the validation passes and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">ValidationErrors</span></strong><span class="koboSpan" id="kobo.988.1"> object when the </span><span class="No-Break"><span class="koboSpan" id="kobo.989.1">validation fails.</span></span></p>
<h4><span class="koboSpan" id="kobo.990.1">Async validations with custom validators</span></h4>
<p><span class="koboSpan" id="kobo.991.1">Lastly, you </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.992.1">can create asynchronous validators. </span><span class="koboSpan" id="kobo.992.2">These asynchronous validators work similarly to regular custom validators; there are only two differences. </span><span class="koboSpan" id="kobo.992.3">First, the provider for the asynchronous validators is different. </span><span class="koboSpan" id="kobo.992.4">If you want to create an asynchronous validator, you must change the provider to the </span><span class="No-Break"><span class="koboSpan" id="kobo.993.1">following values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.994.1">
providers: [{
  provide: NG_ASYNC_VALIDATORS,
  useExisting: UsernameAvailabilityDirective,
  multi: true,
}]</span></pre> <p><span class="koboSpan" id="kobo.995.1">Secondly, you need to return </span><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">Promise</span></strong><span class="koboSpan" id="kobo.997.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.998.1">Observable</span></strong><span class="koboSpan" id="kobo.999.1"> with either a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">null</span></strong><span class="koboSpan" id="kobo.1001.1"> value or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">ValidationErrors</span></strong><span class="koboSpan" id="kobo.1003.1"> object. </span><span class="koboSpan" id="kobo.1003.2">Here’s an example of such </span><span class="No-Break"><span class="koboSpan" id="kobo.1004.1">a function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1005.1">
validate(control: AbstractControl): Promise&lt;ValidationErrors | null&gt; | Observable&lt;ValidationErrors | null&gt; {
  const username = control.value;
  return checkUsernameInDatabase(username).pipe(
    map((isAvailable) =&gt; (isAvailable ? </span><span class="koboSpan" id="kobo.1005.2">null : { usernameTaken: true }))
  );
}</span></pre> <p><span class="koboSpan" id="kobo.1006.1">In this example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">checkUsernameInDatabase</span></strong><span class="koboSpan" id="kobo.1008.1"> function is an API call that returns an observable, and we use RxJS’s pipe and map to map the result to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">null</span></strong><span class="koboSpan" id="kobo.1010.1"> or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">ValidationErrors</span></strong><span class="koboSpan" id="kobo.1012.1"> object. </span><span class="koboSpan" id="kobo.1012.2">You can use any asynchronous logic inside your validator, so long as you return </span><strong class="source-inline"><span class="koboSpan" id="kobo.1013.1">Promise</span></strong><span class="koboSpan" id="kobo.1014.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1015.1">Observable</span></strong><span class="koboSpan" id="kobo.1016.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1017.1">null</span></strong><span class="koboSpan" id="kobo.1018.1"> or the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1019.1">ValidationErrors</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1020.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.1021.1">In this section, you</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.1022.1"> learned how to create template-driven forms. </span><span class="koboSpan" id="kobo.1022.2">You also learned how to create form controls using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1023.1">ngModel</span></strong><span class="koboSpan" id="kobo.1024.1"> directive, how to create form groups using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1025.1">ngModelGroup</span></strong><span class="koboSpan" id="kobo.1026.1">, and how to use built-in validators. </span><span class="koboSpan" id="kobo.1026.2">Then, you learned about how to style a form and display error messages based on form control statuses. </span><span class="koboSpan" id="kobo.1026.3">Lastly, you learned how to create custom validators for form controls, form groups, and asynchronous validation rules. </span><span class="koboSpan" id="kobo.1026.4">Next, we will start learning how to build </span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">reactive forms.</span></span></p>
<h1 id="_idParaDest-78"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.1028.1">Building reactive forms</span></h1>
<p><span class="koboSpan" id="kobo.1029.1">In this section, you </span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.1030.1">will learn how to build reactive forms. </span><span class="koboSpan" id="kobo.1030.2">We will rebuild the form we used in the previous section but reactively. </span><span class="koboSpan" id="kobo.1030.3">You will learn how to create </span><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1032.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1033.1">FormArray</span></strong><span class="koboSpan" id="kobo.1034.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1035.1">FormControl</span></strong><span class="koboSpan" id="kobo.1036.1"> instances, how to validate reactive forms, and how to create custom validators for reactive forms. </span><span class="koboSpan" id="kobo.1036.2">You will also learn how to dynamically create form fields and how to change the update behavior of reactive </span><span class="No-Break"><span class="koboSpan" id="kobo.1037.1">form fields.</span></span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.1038.1">Creating a reactive form</span></h2>
<p><span class="koboSpan" id="kobo.1039.1">Start by removing or</span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.1040.1"> commenting out the HTML template and TypeScript code for our template-driven form. </span><span class="koboSpan" id="kobo.1040.2">I will comment out the code so that it remains an example of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1041.1">template-driven approach.</span></span></p>
<p><span class="koboSpan" id="kobo.1042.1">Next, we’ll start with the same simple HTML form, including the description, amount excluding VAT, VAT percentage, and date fields. </span><span class="koboSpan" id="kobo.1042.2">We will gradually transform the simple HTML form into a </span><span class="No-Break"><span class="koboSpan" id="kobo.1043.1">reactive form:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1044.1">
&lt;form&gt;
  &lt;div class=»form-field"&gt;
    &lt;label for=»description»&gt;Description:&lt;/label&gt;
    &lt;input type=»text» id=»description»&gt;
  &lt;/div&gt;
  …………
  &lt;button type=»submit»&gt;Submit&lt;/button&gt;
&lt;/form&gt;</span></pre> <p><span class="koboSpan" id="kobo.1045.1">After creating </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.1046.1">the simple HTML form, we will start by importing </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">ReactiveFormsModule</span></strong><span class="koboSpan" id="kobo.1048.1"> inside our component. </span><span class="koboSpan" id="kobo.1048.2">When building reactive forms, you import </span><strong class="source-inline"><span class="koboSpan" id="kobo.1049.1">ReactiveFormsModule</span></strong><span class="koboSpan" id="kobo.1050.1"> instead of the regular </span><strong class="source-inline"><span class="koboSpan" id="kobo.1051.1">FormsModule</span></strong><span class="koboSpan" id="kobo.1052.1">. </span><span class="koboSpan" id="kobo.1052.2">After adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.1053.1">ReactiveFormsModule</span></strong><span class="koboSpan" id="kobo.1054.1"> to your component file, we can move on and start to create the form model using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1056.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">FormControl</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1058.1"> classes.</span></span></p>
<p><span class="koboSpan" id="kobo.1059.1">At its core, an Angular form is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1060.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1061.1"> class with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1062.1">FormControl</span></strong><span class="koboSpan" id="kobo.1063.1"> elements inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1064.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1065.1">. </span><span class="koboSpan" id="kobo.1065.2">When we created our template-driven form, Angular created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1066.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1067.1"> class for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1068.1">ngForm</span></strong><span class="koboSpan" id="kobo.1069.1"> instance and added a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1070.1">FormControl</span></strong><span class="koboSpan" id="kobo.1071.1"> element inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1072.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1073.1"> class for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1074.1">ngModel</span></strong><span class="koboSpan" id="kobo.1075.1"> directive </span><span class="No-Break"><span class="koboSpan" id="kobo.1076.1">we declared.</span></span></p>
<p><span class="koboSpan" id="kobo.1077.1">To construct our reactive form model, we need to do the same </span><span class="No-Break"><span class="koboSpan" id="kobo.1078.1">only manually:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1079.1">
addExpenseForm = new </span><strong class="bold"><span class="koboSpan" id="kobo.1080.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1081.1">({
  description: new </span><strong class="bold"><span class="koboSpan" id="kobo.1082.1">FormControl</span></strong><span class="koboSpan" id="kobo.1083.1">(''),
  amountExclVat: new </span><strong class="bold"><span class="koboSpan" id="kobo.1084.1">FormControl</span></strong><span class="koboSpan" id="kobo.1085.1">(null),
  vatPercentage: new </span><strong class="bold"><span class="koboSpan" id="kobo.1086.1">FormControl</span></strong><span class="koboSpan" id="kobo.1087.1">(null),
  date: new FormControl(''),
});</span></pre> <p><span class="koboSpan" id="kobo.1088.1">As you can see, we’ve created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1090.1"> instance and added a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">FormControl</span></strong><span class="koboSpan" id="kobo.1092.1"> element inside for each form field. </span><span class="koboSpan" id="kobo.1092.2">Inside the function brackets of the form control, we’ve added either an empty string or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1093.1">null</span></strong><span class="koboSpan" id="kobo.1094.1">; these are the default values for the form </span><span class="No-Break"><span class="koboSpan" id="kobo.1095.1">control instances.</span></span></p>
<p><span class="koboSpan" id="kobo.1096.1">If you </span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.1097.1">want different default values, you can change the values inside the function brackets of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">FormControl</span></strong><span class="koboSpan" id="kobo.1099.1"> instances. </span><span class="koboSpan" id="kobo.1099.2">Later in this section, we will create an input by which you can send default values from the parent, just like we did with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1100.1">template-driven form.</span></span></p>
<p><span class="koboSpan" id="kobo.1101.1">After creating the form model, you need to bind the form model to the form inside your HTML template. </span><span class="koboSpan" id="kobo.1101.2">You can bind the form model to the template by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1102.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1103.1"> directive and assigning the directive with the form model, </span><span class="No-Break"><span class="koboSpan" id="kobo.1104.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1105.1">
&lt;form </span><strong class="bold"><span class="koboSpan" id="kobo.1106.1">[formGroup]="addExpenseForm"</span></strong><span class="koboSpan" id="kobo.1107.1">&gt; ……… &lt;/form&gt;</span></pre> <p><span class="koboSpan" id="kobo.1108.1">Next, you need to bind the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">FormControl</span></strong><span class="koboSpan" id="kobo.1110.1"> instances to the form field by using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1111.1">formControlName</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1112.1"> directive:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1113.1">
&lt;input </span><strong class="bold"><span class="koboSpan" id="kobo.1114.1">formControlName="description"</span></strong><span class="koboSpan" id="kobo.1115.1"> type="text" …… &gt;</span></pre> <p><span class="koboSpan" id="kobo.1116.1">You must assign the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">formControlName</span></strong><span class="koboSpan" id="kobo.1118.1"> directive with the key that was used to assign </span><strong class="source-inline"><span class="koboSpan" id="kobo.1119.1">FormControl</span></strong><span class="koboSpan" id="kobo.1120.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1121.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1122.1"> class you declared inside your TypeScript file. </span><span class="koboSpan" id="kobo.1122.2">After adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1123.1">formControlName</span></strong><span class="koboSpan" id="kobo.1124.1"> directive to all your form fields, the form model is bound to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1125.1">HTML form.</span></span></p>
<p><span class="koboSpan" id="kobo.1126.1">Now, when you change the values inside the input fields, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1127.1">addExpenseForm</span></strong><span class="koboSpan" id="kobo.1128.1"> in your component class will be updated, and when you update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">FormControl</span></strong><span class="koboSpan" id="kobo.1130.1"> values inside your TypeScript file, the changes you made will be reflected inside the input fields in the browser. </span><span class="koboSpan" id="kobo.1130.2">You can test this by adding a default value to one of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1131.1">FormControl</span></strong><span class="koboSpan" id="kobo.1132.1"> values inside your TypeScript file; when you do, the value should be reflected inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.1133.1">HTML template.</span></span></p>
<p><span class="koboSpan" id="kobo.1134.1">To test if changing the input also changes the values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1135.1">addExpenseForm</span></strong><span class="koboSpan" id="kobo.1136.1"> in your component class, you can temporarily add the following code to your template so that you can see the changes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1137.1">addExpenseForm</span></strong><span class="koboSpan" id="kobo.1138.1"> object in </span><span class="No-Break"><span class="koboSpan" id="kobo.1139.1">real time:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1140.1">
&lt;div&gt;{{addExpenseForm.value | json}}&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.1141.1">After creating the reactive form, you can remove the aforementioned line of code. </span><span class="koboSpan" id="kobo.1141.2">Until then, it can be helpful to see if all values </span><span class="No-Break"><span class="koboSpan" id="kobo.1142.1">are synchronized.</span></span></p>
<p><span class="koboSpan" id="kobo.1143.1">Now that we’ve defined and tested our form fields, let’s learn how we can group form fields into </span><span class="No-Break"><span class="koboSpan" id="kobo.1144.1">reactive forms.</span></span></p>
<h3><span class="koboSpan" id="kobo.1145.1">Grouping fields in reactive forms</span></h3>
<p><span class="koboSpan" id="kobo.1146.1">In our </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.1147.1">template-driven form, we grouped the amount excluding VAT and VAT percentage fields using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">ngModelGroup</span></strong><span class="koboSpan" id="kobo.1149.1"> directive. </span><span class="koboSpan" id="kobo.1149.2">By grouping fields, you can perform validation logic on the group instead of the individual fields, style the group, or just change the data structure to something better resembling your state or </span><span class="No-Break"><span class="koboSpan" id="kobo.1150.1">DTO objects.</span></span></p>
<p><span class="koboSpan" id="kobo.1151.1">Let’s also group the amount excluding VAT and the VAT percentage fields in our reactive form. </span><span class="koboSpan" id="kobo.1151.2">Start by changing the HTML template and wrap the two input fields inside a fieldset </span><span class="No-Break"><span class="koboSpan" id="kobo.1152.1">HTML template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1153.1">
&lt;fieldset&gt; ……… &lt;/fieldset&gt;</span></pre> <p><span class="koboSpan" id="kobo.1154.1">Next, change the form model so that it reflects the structure where the two fields are grouped inside a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1155.1">FormGroup</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1156.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1157.1">
addExpenseForm = new FormGroup({
  description: new FormControl('Test'),
  amount: new FormGroup({
    amountExclVat: new FormControl(null),
    vatPercentage: new FormControl(null),
  }),
  date: new FormControl(''),
});</span></pre> <p><span class="koboSpan" id="kobo.1158.1">When you’ve updated the form model, you need to bind the form group inside the HTML form. </span><span class="koboSpan" id="kobo.1158.2">You can bind the form group using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1159.1">formGroupName</span></strong><span class="koboSpan" id="kobo.1160.1"> directive and assign it with the key of your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1161.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1162.1"> class inside the form model. </span><span class="koboSpan" id="kobo.1162.2">In our case, this </span><span class="No-Break"><span class="koboSpan" id="kobo.1163.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1164.1">amount</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1165.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1166.1">
&lt;fieldset </span><strong class="bold"><span class="koboSpan" id="kobo.1167.1">formGroupName="amount"</span></strong><span class="koboSpan" id="kobo.1168.1">&gt; ……… &lt;/fieldset&gt;</span></pre> <p><span class="koboSpan" id="kobo.1169.1">That is all you need to do. </span><span class="koboSpan" id="kobo.1169.2">Now, when you log the form value, its structure will look </span><span class="No-Break"><span class="koboSpan" id="kobo.1170.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1171.1">
{
  "description": "",
  amount": {
    "amountExclVat": null,
    "vatPercentage": null },
  "date": ""
}</span></pre> <p><span class="koboSpan" id="kobo.1172.1">Now that </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.1173.1">you know how to group fields using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1174.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1175.1"> class, let’s explore how we can dynamically add fields and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">FormControl</span></strong><span class="koboSpan" id="kobo.1177.1"> instances to our form and </span><span class="No-Break"><span class="koboSpan" id="kobo.1178.1">form model.</span></span></p>
<h3><span class="koboSpan" id="kobo.1179.1">Dynamically adding fields and FormControl instances</span></h3>
<p><span class="koboSpan" id="kobo.1180.1">Unlike </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.1181.1">template-driven forms, when creating reactive forms, you can also group fields using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1182.1">FormArray</span></strong><span class="koboSpan" id="kobo.1183.1"> class. </span><span class="koboSpan" id="kobo.1183.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1184.1">FormArray</span></strong><span class="koboSpan" id="kobo.1185.1"> class is useful when you don’t know how many values will be supplied, and the user can dynamically add and </span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.1186.1">remove input fields in the form. </span><span class="koboSpan" id="kobo.1186.2">An example of this might be tags </span><span class="No-Break"><span class="koboSpan" id="kobo.1187.1">or comments.</span></span></p>
<p><span class="koboSpan" id="kobo.1188.1">To demonstrate this, we will add another field to our reactive form so that we can add tags. </span><span class="koboSpan" id="kobo.1188.2">Start by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1189.1">FormArray</span></strong><span class="koboSpan" id="kobo.1190.1"> class to your </span><span class="No-Break"><span class="koboSpan" id="kobo.1191.1">form model:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1192.1">
tags: new FormArray([ new FormControl('')])</span></pre> <p><span class="koboSpan" id="kobo.1193.1">As you can see, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1194.1">FormArray</span></strong><span class="koboSpan" id="kobo.1195.1"> takes an array instead of an object as a parameter. </span><span class="koboSpan" id="kobo.1195.2">Inside this array, we declared a form control, which will be the first tag inside our form. </span><span class="koboSpan" id="kobo.1195.3">Because </span><strong class="source-inline"><span class="koboSpan" id="kobo.1196.1">FormArray</span></strong><span class="koboSpan" id="kobo.1197.1"> takes an array, we can dynamically add (or remove) from controls, which, in turn, will add or remove input fields to/from our </span><span class="No-Break"><span class="koboSpan" id="kobo.1198.1">HTML form.</span></span></p>
<p><span class="koboSpan" id="kobo.1199.1">Now that we’ve added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1200.1">FormArray</span></strong><span class="koboSpan" id="kobo.1201.1"> class inside our form model, let’s add some HTML so that the user can add </span><span class="No-Break"><span class="koboSpan" id="kobo.1202.1">multiple tags.</span></span></p>
<p><span class="koboSpan" id="kobo.1203.1">Start by creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1204.1">fieldset</span></strong><span class="koboSpan" id="kobo.1205.1"> value and declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1206.1">formArrayName</span></strong><span class="koboSpan" id="kobo.1207.1"> directive on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1208.1">HTML tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1209.1">
&lt;fieldset formArrayName="tags"&gt; &lt;/fieldset&gt;</span></pre> <p><span class="koboSpan" id="kobo.1210.1">Inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1211.1">fieldset</span></strong><span class="koboSpan" id="kobo.1212.1">, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.1213.1">following HTML:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1214.1">
&lt;div class="form-field" *ngFor="let item of addExpenseForm.controls.tags.controls; index as i"&gt;
  &lt;label for=»tag-{{i}}»&gt;Tag:&lt;/label&gt;
  &lt;div class=»tag-field»&gt;
   &lt;input [formControlName]="i" type="text" id="tag-{{i}}"&gt;
  &lt;/div&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.1215.1">The </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.1216.1">aforementioned HTML will output a label and input for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1217.1">FormControl</span></strong><span class="koboSpan" id="kobo.1218.1"> inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1219.1">FormArray</span></strong><span class="koboSpan" id="kobo.1220.1">. </span><span class="koboSpan" id="kobo.1220.2">Now, we only need a way to add and remove </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1221.1">FormControl</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1222.1"> instances.</span></span></p>
<p><span class="koboSpan" id="kobo.1223.1">Let’s add</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.1224.1"> two buttons to the HTML underneath the </span><span class="No-Break"><span class="koboSpan" id="kobo.1225.1">input tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1226.1">
&lt;div&gt;
  &lt;button *ngIf="i &gt; 0" (click)="removeTag(i)"&gt;-&lt;/button&gt;
  &lt;button (click)=»addTag()"&gt;+&lt;/button&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.1227.1">Next, we need to add the logic for the click functions inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.1228.1">component class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1229.1">
addTag() {
  this.addExpenseForm.controls.tags.insert(0, new FormControl(''));
}
removeTag(index: number) {
  this.addExpenseForm.controls.tags.removeAt(index);
}</span></pre> <p><span class="koboSpan" id="kobo.1230.1">With the aforementioned functions added to the component class, you can now add and remove </span><strong class="source-inline"><span class="koboSpan" id="kobo.1231.1">FormControl</span></strong><span class="koboSpan" id="kobo.1232.1"> instances inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1233.1">FormArray</span></strong><span class="koboSpan" id="kobo.1234.1"> class, which will result in added or removed </span><span class="No-Break"><span class="koboSpan" id="kobo.1235.1">input fields.</span></span></p>
<p><span class="koboSpan" id="kobo.1236.1">But what if you have data in an object format instead of an array and you need to keep the form format, and just like our previous example, you don’t know how many or what fields you will have and what the keys for these fields </span><span class="No-Break"><span class="koboSpan" id="kobo.1237.1">will be?</span></span></p>
<p><span class="koboSpan" id="kobo.1238.1">An</span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.1239.1"> example </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.1240.1">could be when you receive a list of statuses that our expense has gone through, such as submitted, waiting for revision, checked, approved, and so on. </span><span class="koboSpan" id="kobo.1240.2">For these scenarios, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1241.1">FormRecord</span></strong><span class="koboSpan" id="kobo.1242.1"> class. </span><span class="koboSpan" id="kobo.1242.2">We won’t add this to our form, but I will outline an example of how to handle a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1243.1">FormRecord</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1244.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1245.1">
statuses: new FormRecord({})</span></pre> <p><span class="koboSpan" id="kobo.1246.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1247.1">FormRecord</span></strong><span class="koboSpan" id="kobo.1248.1"> class receives an object with keys and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1249.1">FormControl</span></strong><span class="koboSpan" id="kobo.1250.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1251.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1252.1"> instances. </span><span class="koboSpan" id="kobo.1252.2">You can add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1253.1">FormControl</span></strong><span class="koboSpan" id="kobo.1254.1"> instances to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1255.1">FormRecord</span></strong><span class="koboSpan" id="kobo.1256.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.1257.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1258.1">
this.form.controls.statuses.addControl('someKey', new FormControl(''));</span></pre> <p><span class="koboSpan" id="kobo.1259.1">As you can see, we utilize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1260.1">addControl</span></strong><span class="koboSpan" id="kobo.1261.1"> method, which is exposed on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1262.1">FormRecord</span></strong><span class="koboSpan" id="kobo.1263.1"> class. </span><span class="koboSpan" id="kobo.1263.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1264.1">addControl</span></strong><span class="koboSpan" id="kobo.1265.1"> method is also available on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1266.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1267.1">, but you should use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1268.1">FormRecord</span></strong><span class="koboSpan" id="kobo.1269.1"> when you don’t know what fields will be added beforehand. </span><span class="koboSpan" id="kobo.1269.2">You can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1270.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1271.1"> when you do know what the entire model will look like. </span><span class="koboSpan" id="kobo.1271.2">You can strongly type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1272.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1273.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1274.1">FormRecord</span></strong><span class="koboSpan" id="kobo.1275.1">. </span><span class="koboSpan" id="kobo.1275.2">To strongly type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1276.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1277.1">, use the </span><span class="No-Break"><span class="koboSpan" id="kobo.1278.1">following syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1279.1">
address: new FormGroup&lt;IAddress&gt;({…………})</span></pre> <p><span class="koboSpan" id="kobo.1280.1">In this example, we added an interface for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1281.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1282.1"> between the arrow brackets. </span><span class="koboSpan" id="kobo.1282.2">By adding the type, you strongly typed </span><strong class="source-inline"><span class="koboSpan" id="kobo.1283.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1284.1"> and can’t add fields not defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1285.1">IAddress</span></strong><span class="koboSpan" id="kobo.1286.1"> interface. </span><span class="koboSpan" id="kobo.1286.2">When strongly typing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1287.1">FormRecord</span></strong><span class="koboSpan" id="kobo.1288.1"> class, we tell the record what value our dynamic controls will have. </span><span class="koboSpan" id="kobo.1288.2">For example, if we have a list of keys with a Boolean value, we can use </span><span class="No-Break"><span class="koboSpan" id="kobo.1289.1">this syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1290.1">
statuses: new FormRecord&lt;FormControl&lt;boolean&gt;&gt;({…………})</span></pre> <p><span class="koboSpan" id="kobo.1291.1">Here, we tell </span><strong class="source-inline"><span class="koboSpan" id="kobo.1292.1">FormRecord</span></strong><span class="koboSpan" id="kobo.1293.1"> that each field that will be added should be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1294.1">FormContro</span></strong><span class="koboSpan" id="kobo.1295.1"> instance and that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1296.1">FormControl</span></strong><span class="koboSpan" id="kobo.1297.1"> should have a Boolean value. </span><span class="koboSpan" id="kobo.1297.2">If we have form controls with different values, we can change the Boolean value for string or any other type our controls </span><span class="No-Break"><span class="koboSpan" id="kobo.1298.1">will hold.</span></span></p>
<p><span class="koboSpan" id="kobo.1299.1">Now that you know how to group fields using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1300.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1301.1"> or dynamically add fields using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1302.1">FormArray</span></strong><span class="koboSpan" id="kobo.1303.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1304.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1305.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1306.1">FormRecord</span></strong><span class="koboSpan" id="kobo.1307.1">, let’s explore how we can control the update behavior of our fields and how to declare standalone controls in a </span><span class="No-Break"><span class="koboSpan" id="kobo.1308.1">reactive form.</span></span></p>
<h3><span class="koboSpan" id="kobo.1309.1">Configuring update behavior and declaring standalone controls</span></h3>
<p><span class="koboSpan" id="kobo.1310.1">With</span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.1311.1"> template-driven forms, we have the option to configure the update behavior of form control instances using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1312.1">ngModelOptions</span></strong><span class="koboSpan" id="kobo.1313.1"> directive; in reactive forms, we control the update behavior inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1314.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1315.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1316.1">FormArray</span></strong><span class="koboSpan" id="kobo.1317.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1318.1">FormControl</span></strong><span class="koboSpan" id="kobo.1319.1"> class. </span><span class="koboSpan" id="kobo.1319.2">You can add a configuration object to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1320.1">updateOn</span></strong><span class="koboSpan" id="kobo.1321.1"> property. </span><span class="koboSpan" id="kobo.1321.2">You can set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1322.1">updateOn</span></strong><span class="koboSpan" id="kobo.1323.1"> property for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1324.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1325.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1326.1">FormArray</span></strong><span class="koboSpan" id="kobo.1327.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1328.1">FormControl</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1329.1">elements alike.</span></span></p>
<p><span class="koboSpan" id="kobo.1330.1">When</span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.1331.1"> you set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1332.1">updateOn</span></strong><span class="koboSpan" id="kobo.1333.1"> property for a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1334.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1335.1"> element of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1336.1">FormArray</span></strong><span class="koboSpan" id="kobo.1337.1">, it will be applied to all nested </span><strong class="source-inline"><span class="koboSpan" id="kobo.1338.1">FormControl</span></strong><span class="koboSpan" id="kobo.1339.1"> elements. </span><span class="koboSpan" id="kobo.1339.2">If you define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1340.1">updateOn</span></strong><span class="koboSpan" id="kobo.1341.1"> property for a nested object inside the form model, that nested property will overrule the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1342.1">updateOn</span></strong><span class="koboSpan" id="kobo.1343.1"> property of parent elements. </span><span class="koboSpan" id="kobo.1343.2">Just like template-driven forms, you can set the update behavior to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1344.1">change</span></strong><span class="koboSpan" id="kobo.1345.1"> (which is the default), </span><strong class="source-inline"><span class="koboSpan" id="kobo.1346.1">blur</span></strong><span class="koboSpan" id="kobo.1347.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1348.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1349.1">submit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1350.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1351.1">
description: new FormControl('', </span><strong class="bold"><span class="koboSpan" id="kobo.1352.1">{updateOn: 'blur'}</span></strong><span class="koboSpan" id="kobo.1353.1">),</span></pre> <p><span class="koboSpan" id="kobo.1354.1">When you used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1355.1">ngModelOptions</span></strong><span class="koboSpan" id="kobo.1356.1"> directive inside our template-driven form, you also had the option to mark an input field as standalone. </span><span class="koboSpan" id="kobo.1356.2">As with template-driven forms, you can also have a standalone reactive form element, but you don’t have to set it with a standalone property; instead, you just declare a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1357.1">FormControl</span></strong><span class="koboSpan" id="kobo.1358.1"> instance </span><span class="No-Break"><span class="koboSpan" id="kobo.1359.1">without </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1360.1">FormGroup</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1361.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1362.1">
searchInput = new FormControl('');</span></pre> <p><span class="koboSpan" id="kobo.1363.1">For a standalone reactive form field, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1364.1">formControl</span></strong><span class="koboSpan" id="kobo.1365.1"> directive instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1366.1">formControlName</span></strong><span class="koboSpan" id="kobo.1367.1"> directive inside your </span><span class="No-Break"><span class="koboSpan" id="kobo.1368.1">HTML template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1369.1">
&lt;input [formControl]="searchInput" type="text"&gt;</span></pre> <p><span class="koboSpan" id="kobo.1370.1">You can access the value of your standalone form field by using the value property </span><span class="No-Break"><span class="koboSpan" id="kobo.1371.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1372.1">FormControl</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1373.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1374.1">
this.searchInput.value;</span></pre> <p><span class="koboSpan" id="kobo.1375.1">Instead of using the value property, you can also access the value more reactively and react to each update of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1376.1">FormControl</span></strong><span class="koboSpan" id="kobo.1377.1">. </span><span class="koboSpan" id="kobo.1377.2">You can handle the changes reactively by subscribing</span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.1378.1"> to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1379.1">valueChanges</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1380.1"> observable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1381.1">
this.searchInput.valueChanges.subscribe(() =&gt; { ……… });</span></pre> <p><span class="koboSpan" id="kobo.1382.1">Now that </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.1383.1">you know how to control the update behavior of the form fields and how you can reactively create standalone form fields, let’s learn how to programmatically set and update </span><span class="No-Break"><span class="koboSpan" id="kobo.1384.1">form values.</span></span></p>
<h3><span class="koboSpan" id="kobo.1385.1">Setting and updating values programmatically</span></h3>
<p><span class="koboSpan" id="kobo.1386.1">Often, you </span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.1387.1">need a way to set and update values programmatically inside your component class. </span><span class="koboSpan" id="kobo.1387.2">In reactive forms, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1388.1">setValue</span></strong><span class="koboSpan" id="kobo.1389.1"> to set values</span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.1390.1"> on individual form controls and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1391.1">patchValue</span></strong><span class="koboSpan" id="kobo.1392.1"> method when you want to update multiple fields of your </span><span class="No-Break"><span class="koboSpan" id="kobo.1393.1">form simultaneously.</span></span></p>
<p><span class="koboSpan" id="kobo.1394.1">In this section, we will create our component </span><strong class="source-inline"><span class="koboSpan" id="kobo.1395.1">@Input()</span></strong><span class="koboSpan" id="kobo.1396.1"> directive and use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1397.1">patchValue</span></strong><span class="koboSpan" id="kobo.1398.1"> to update the default form values with the values we received from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1399.1">parent component.</span></span></p>
<p><span class="koboSpan" id="kobo.1400.1">Start by adding a new interface inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1401.1">add-expense.interface.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1402.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1403.1">
export interface AddExpenseReactive {
  description?: string;
  amount?: {
    amountExclVat?: number;
    vatPercentage?: number;
  };
  date?: string[];
  tags?: string[];
}</span></pre> <p><span class="koboSpan" id="kobo.1404.1">Next, we will add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1405.1">@Input()</span></strong><span class="koboSpan" id="kobo.1406.1"> directive with a setter. </span><span class="koboSpan" id="kobo.1406.2">Inside this setter, we will use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1407.1">patchValue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1408.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1409.1">
@Input()
public set expenseToAdd(value: AddExpenseReactive) {
  this.addExpenseForm.patchValue(value);
}</span></pre> <p><span class="koboSpan" id="kobo.1410.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1411.1">patchValue</span></strong><span class="koboSpan" id="kobo.1412.1"> method will update all values that are supplied inside the value object. </span><span class="koboSpan" id="kobo.1412.2">So, if </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.1413.1">the value only contains the description key, only the description will be updated; when the value object contains the description and amount with both properties, all these values will be updated. </span><span class="koboSpan" id="kobo.1413.2">The</span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.1414.1"> only exceptions are the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1415.1">date</span></strong><span class="koboSpan" id="kobo.1416.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1417.1">tags</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1418.1"> fields.</span></span></p>
<p><span class="koboSpan" id="kobo.1419.1">As you may have noticed, when we defined the date in the interface, we gave the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1420.1">date</span></strong><span class="koboSpan" id="kobo.1421.1"> property a string array type; this is because to set a default value, we need to supply the form control with a string array, </span><span class="No-Break"><span class="koboSpan" id="kobo.1422.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1423.1">
['2023-10-15']</span></pre> <p><span class="koboSpan" id="kobo.1424.1">If you provide a value in a similar format from the parent component, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1425.1">patchValue</span></strong><span class="koboSpan" id="kobo.1426.1"> will also work for the date; when you provide it with a simple string, the input will not </span><span class="No-Break"><span class="koboSpan" id="kobo.1427.1">be populated.</span></span></p>
<p><span class="koboSpan" id="kobo.1428.1">Make sure you also update the default value inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1429.1">FormControl</span></strong><span class="koboSpan" id="kobo.1430.1">; otherwise, you will get compiler errors because the types inside your control and patch value </span><span class="No-Break"><span class="koboSpan" id="kobo.1431.1">don’t match:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1432.1">
date: new FormControl(['']),</span></pre> <p><span class="koboSpan" id="kobo.1433.1">Besides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1434.1">date</span></strong><span class="koboSpan" id="kobo.1435.1"> field, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1436.1">tags</span></strong><span class="koboSpan" id="kobo.1437.1"> field is also different because we use it to add controls to our form dynamically. </span><span class="koboSpan" id="kobo.1437.2">When we assign </span><strong class="source-inline"><span class="koboSpan" id="kobo.1438.1">addExpenseForm</span></strong><span class="koboSpan" id="kobo.1439.1"> with the form model, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1440.1">FormArray</span></strong><span class="koboSpan" id="kobo.1441.1"> tags receive a default value of one </span><strong class="source-inline"><span class="koboSpan" id="kobo.1442.1">FormControl</span></strong><span class="koboSpan" id="kobo.1443.1">. </span><span class="koboSpan" id="kobo.1443.2">Because we only added one </span><strong class="source-inline"><span class="koboSpan" id="kobo.1444.1">FormControl</span></strong><span class="koboSpan" id="kobo.1445.1"> inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1446.1">FormArray</span></strong><span class="koboSpan" id="kobo.1447.1">, when we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1448.1">patchValue</span></strong><span class="koboSpan" id="kobo.1449.1"> method on the form, only one tag will be set, even if more tags are supplied. </span><span class="koboSpan" id="kobo.1449.2">To update the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1450.1">FormArray</span></strong><span class="koboSpan" id="kobo.1451.1">, we need to add some additional logic inside </span><span class="No-Break"><span class="koboSpan" id="kobo.1452.1">our setter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1453.1">
this.addExpenseForm.controls.tags.clear();
value.tags?.forEach(tag =&gt; {
  this.addExpenseForm.controls.tags.push(new FormControl(tag)); });</span></pre> <p><span class="koboSpan" id="kobo.1454.1">First, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1455.1">clear</span></strong><span class="koboSpan" id="kobo.1456.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1457.1">FormArray</span></strong><span class="koboSpan" id="kobo.1458.1"> tags. </span><span class="koboSpan" id="kobo.1458.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1459.1">clear</span></strong><span class="koboSpan" id="kobo.1460.1"> method will clear all existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.1461.1">FormControl</span></strong><span class="koboSpan" id="kobo.1462.1"> instances declared inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1463.1">FormArray</span></strong><span class="koboSpan" id="kobo.1464.1">. </span><span class="koboSpan" id="kobo.1464.2">After we clear the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1465.1">FormArray</span></strong><span class="koboSpan" id="kobo.1466.1">, we will use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1467.1">forEach</span></strong><span class="koboSpan" id="kobo.1468.1"> loop to add a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1469.1">FormControl</span></strong><span class="koboSpan" id="kobo.1470.1"> for each of the tags we received from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1471.1">parent component.</span></span></p>
<p><span class="koboSpan" id="kobo.1472.1">Now, when </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.1473.1">we supply an object with values </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.1474.1">from the parent component, our form will be populated with </span><span class="No-Break"><span class="koboSpan" id="kobo.1475.1">these values.</span></span></p>
<p><span class="koboSpan" id="kobo.1476.1">In some scenarios, you only want to set the value of a single control. </span><span class="koboSpan" id="kobo.1476.2">When you only want to set the value of a single control, you must use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1477.1">setValue</span></strong><span class="koboSpan" id="kobo.1478.1"> method on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1479.1">FormControl</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1480.1"> instance:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1481.1">
this.addExpenseForm.controls.description.setValue('New description');</span></pre> <p><span class="koboSpan" id="kobo.1482.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1483.1">setValue</span></strong><span class="koboSpan" id="kobo.1484.1"> method doesn’t allow you to assign a number value to the description input field, making it a type-safe and programmatic way to set the values of form controls. </span><span class="koboSpan" id="kobo.1484.2">We added the input to receive values from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1485.1">parent component.</span></span></p>
<p><span class="koboSpan" id="kobo.1486.1">With that, you’ve learned how to set and update values programmatically for your reactive forms. </span><span class="koboSpan" id="kobo.1486.2">Next, we will start learning about validation in </span><span class="No-Break"><span class="koboSpan" id="kobo.1487.1">reactive forms.</span></span></p>
<h3><span class="koboSpan" id="kobo.1488.1">Validating reactive forms</span></h3>
<p><span class="koboSpan" id="kobo.1489.1">As with </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.1490.1">template-driven forms, you can validate reactive forms using built-in or custom validators. </span><span class="koboSpan" id="kobo.1490.2">We’ll start by looking into the built-in validators and then create a custom validator. </span><span class="koboSpan" id="kobo.1490.3">Reactive forms have the same built-in validators as template-driven forms, except we don’t declare them using directives but the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1491.1">Validator</span></strong><span class="koboSpan" id="kobo.1492.1"> class. </span><span class="koboSpan" id="kobo.1492.2">Inside your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1493.1">FormControl</span></strong><span class="koboSpan" id="kobo.1494.1"> instances, you can add an array with the validators you want </span><span class="No-Break"><span class="koboSpan" id="kobo.1495.1">to apply.</span></span></p>
<p><span class="koboSpan" id="kobo.1496.1">To add the required validator to our description field, we can use </span><span class="No-Break"><span class="koboSpan" id="kobo.1497.1">this syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1498.1">
description: new FormControl('', [</span><strong class="bold"><span class="koboSpan" id="kobo.1499.1">Validators.required</span></strong><span class="koboSpan" id="kobo.1500.1">]),</span></pre> <p><span class="koboSpan" id="kobo.1501.1">That’s all we need to do to add the built-in validators – simple and clean. </span><span class="koboSpan" id="kobo.1501.2">When we want to create custom validators for our reactive forms, we must create a function that returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1502.1">ValidatorFn</span></strong><span class="koboSpan" id="kobo.1503.1"> interface. </span><span class="koboSpan" id="kobo.1503.2">We will create the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.1504.1">max</span></strong><span class="koboSpan" id="kobo.1505.1"> word count validator, just like we did with the template-driven form, now only as a function instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.1506.1">a directive.</span></span></p>
<p><span class="koboSpan" id="kobo.1507.1">To create the custom validator, start by creating a new folder, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1508.1">reactive-validators</span></strong><span class="koboSpan" id="kobo.1509.1">, inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1510.1">form-validators</span></strong><span class="koboSpan" id="kobo.1511.1"> library. </span><span class="koboSpan" id="kobo.1511.2">Inside this folder, create a new file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1512.1">max-word-count.function.ts</span></strong><span class="koboSpan" id="kobo.1513.1">. </span><span class="koboSpan" id="kobo.1513.2">We will use this new file to create our </span><span class="No-Break"><span class="koboSpan" id="kobo.1514.1">validator function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1515.1">
export function maxWordCountValidator(maxWords: number): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null =&gt; {
    const wordCount = control?.value?.trim().split(' ').length;
    return wordCount &gt; maxWords ? </span><span class="koboSpan" id="kobo.1515.2">{ maxWordCount: { count: wordCount } } : null; }; }</span></pre> <p><span class="koboSpan" id="kobo.1516.1">Here, we</span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.1517.1"> create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1518.1">maxWordCountValidator</span></strong><span class="koboSpan" id="kobo.1519.1"> function, which will receive an input for the maximum word count we will allow. </span><span class="koboSpan" id="kobo.1519.2">Inside this function, we return an implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1520.1">ValidatorFn</span></strong><span class="koboSpan" id="kobo.1521.1"> interface. </span><span class="koboSpan" id="kobo.1521.2">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1522.1">ValidatorFn</span></strong><span class="koboSpan" id="kobo.1523.1"> is the same as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1524.1">validate</span></strong><span class="koboSpan" id="kobo.1525.1"> method we declared inside the directive; we check the word count and return </span><strong class="source-inline"><span class="koboSpan" id="kobo.1526.1">null</span></strong><span class="koboSpan" id="kobo.1527.1"> if the word count is equal to or smaller than the allowed count and return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1528.1">ValidationErrors</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1529.1">object otherwise.</span></span></p>
<p><span class="koboSpan" id="kobo.1530.1">Next, you can add this custom validator to your </span><span class="No-Break"><span class="koboSpan" id="kobo.1531.1">form controls:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1532.1">
description: new FormControl('', [Validators.required, </span><strong class="bold"><span class="koboSpan" id="kobo.1533.1">maxWordCountValidator(3)</span></strong><span class="koboSpan" id="kobo.1534.1">]),</span></pre> <p><span class="koboSpan" id="kobo.1535.1">Now, when you type four or more words inside the description input, the form field becomes invalid. </span><span class="koboSpan" id="kobo.1535.2">With reactive forms, you can also dynamically add and remove validators. </span><span class="koboSpan" id="kobo.1535.3">Compared to template-driven forms, dynamically adding validators is simpler because you don’t have to think about different </span><strong class="source-inline"><span class="koboSpan" id="kobo.1536.1">null</span></strong><span class="koboSpan" id="kobo.1537.1"> values for different validators; you simply call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1538.1">addValidators</span></strong><span class="koboSpan" id="kobo.1539.1"> or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1540.1">removeValidators</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1541.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1542.1">
this.addExpenseForm.controls.description.addValidators(Validators.required);
this.addExpenseForm.controls.description.removeValidators(Validators.required);</span></pre> <p><span class="koboSpan" id="kobo.1543.1">With that, you’ve learned how to use the built-in validators, how to create validators using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1544.1">ValidatorFn</span></strong><span class="koboSpan" id="kobo.1545.1"> implementation, and how to add and remove validators dynamically. </span><span class="koboSpan" id="kobo.1545.2">In the next section, you’ll learn how to provide visual feedback in </span><span class="No-Break"><span class="koboSpan" id="kobo.1546.1">reactive forms.</span></span></p>
<h3><span class="koboSpan" id="kobo.1547.1">Providing visual feedback about the form’s state in reactive forms</span></h3>
<p><span class="koboSpan" id="kobo.1548.1">Angular applies </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.1549.1">control status CSS classes to form elements, just like it does with template-driven forms. </span><span class="koboSpan" id="kobo.1549.2">The control status CSS classes are the same ones that are used for template-driven and reactive forms, so we don’t have to change anything for the styles we’ve already created to be applied. </span><span class="koboSpan" id="kobo.1549.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1550.1">FormGroup</span></strong><span class="koboSpan" id="kobo.1551.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1552.1">FormArray</span></strong><span class="koboSpan" id="kobo.1553.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1554.1">FormRecord</span></strong><span class="koboSpan" id="kobo.1555.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1556.1">FormControl</span></strong><span class="koboSpan" id="kobo.1557.1"> instances will all receive the control value CSS classes based on their </span><span class="No-Break"><span class="koboSpan" id="kobo.1558.1">current status.</span></span></p>
<p><span class="koboSpan" id="kobo.1559.1">The only real difference is how we display the error messages. </span><span class="koboSpan" id="kobo.1559.2">We created a template variable in the template-driven form and bound it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1560.1">ngModel</span></strong><span class="koboSpan" id="kobo.1561.1"> instance to access the form controls. </span><span class="koboSpan" id="kobo.1561.2">When we are using reactive forms, we access the form control instances through the form model </span><span class="No-Break"><span class="koboSpan" id="kobo.1562.1">we created:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1563.1">
&lt;span *ngIf="addExpenseForm.touched &amp;&amp; </span><strong class="bold"><span class="koboSpan" id="kobo.1564.1">addExpenseForm.controls.description.hasError('required')"</span></strong><span class="koboSpan" id="kobo.1565.1">&gt;This field is required&lt;/span&gt;</span></pre> <p><span class="koboSpan" id="kobo.1566.1">For the rest, nothing changes, so go ahead and add the error messages you want to display to your users. </span><span class="koboSpan" id="kobo.1566.2">We already discussed providing visual feedback when we covered template-driven forms, so when it comes to reactive forms, this is all we have </span><span class="No-Break"><span class="koboSpan" id="kobo.1567.1">to cover.</span></span></p>
<p><span class="koboSpan" id="kobo.1568.1">Submitting and resetting a reactive form works the same as for template-driven forms, so you can copy the submission and reset behavior from the </span><em class="italic"><span class="koboSpan" id="kobo.1569.1">Building template-driven forms</span></em><span class="koboSpan" id="kobo.1570.1"> section. </span><span class="koboSpan" id="kobo.1570.2">To finish this chapter, we will learn how to build forms based on a configuration </span><span class="No-Break"><span class="koboSpan" id="kobo.1571.1">object dynamically.</span></span></p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.1572.1">Creating forms dynamically</span></h1>
<p><span class="koboSpan" id="kobo.1573.1">Creating</span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.1574.1"> a good form requires quite a bit of code. </span><span class="koboSpan" id="kobo.1574.2">Regardless of whether you’re using the template-driven or reactive approach, you need a lot of HTML; you need to define the model, add validators, and additional logic such as the </span><span class="No-Break"><span class="koboSpan" id="kobo.1575.1">submit behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.1576.1">You could use a base class for some of the shared functionality, but you can also build a dynamic form, which will dynamically build the form based on a JSON input. </span><span class="koboSpan" id="kobo.1576.2">In this section, we will build a simple example of a dynamic form. </span><span class="koboSpan" id="kobo.1576.3">You can extend the dynamic form to fit your specific needs. </span><span class="koboSpan" id="kobo.1576.4">For example, you might want to fetch the configuration from an external source or support </span><span class="No-Break"><span class="koboSpan" id="kobo.1577.1">additional validators.</span></span></p>
<p><span class="koboSpan" id="kobo.1578.1">To start our dynamic form, create a new form component named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1579.1">dynamic-form</span></strong><span class="koboSpan" id="kobo.1580.1"> in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1581.1">expenses-registration-forms</span></strong><span class="koboSpan" id="kobo.1582.1"> library. </span><span class="koboSpan" id="kobo.1582.2">Next, create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1583.1">dynamic-control.interfaces.ts</span></strong><span class="koboSpan" id="kobo.1584.1"> file. </span><span class="koboSpan" id="kobo.1584.2">I will create the new interface inside the component folder, but </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.1585.1">you can locate all interfaces in a designated folder or use any other folder structure you like. </span><span class="koboSpan" id="kobo.1585.2">Our new dynamic control interfaces will define the interface for a form control, which will be </span><span class="No-Break"><span class="koboSpan" id="kobo.1586.1">generated dynamically:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1587.1">
export interface DynamicControl {
  controlKey: string;
  formFieldType?: 'input' | 'select';
  inputType?: string;
  label?: string;
  defaultValue?: any;
  selectOptions?: string[];
  updateOn: 'change' | 'blur' | 'submit';
  validators?: ValidatorFn[];
}</span></pre> <p><span class="koboSpan" id="kobo.1588.1">Once we’ve defined the interface, we need to add an input property to the component, which will receive an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1589.1">DynamicControl</span></strong><span class="koboSpan" id="kobo.1590.1"> objects, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1591.1">formModel</span></strong><span class="koboSpan" id="kobo.1592.1"> property, which will hold our </span><span class="No-Break"><span class="koboSpan" id="kobo.1593.1">form model:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1594.1">
@Input() formModelConfig: DynamicControl[] = [];
formModel = new FormGroup({});</span></pre> <p><span class="koboSpan" id="kobo.1595.1">When we receive the form configuration as input, we need to build our form model. </span><span class="koboSpan" id="kobo.1595.2">We can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1596.1">ngOnChanges</span></strong><span class="koboSpan" id="kobo.1597.1"> life cycle hook to build the form model each time we receive a new </span><span class="No-Break"><span class="koboSpan" id="kobo.1598.1">form configuration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1599.1">
ngOnChanges(changes: SimpleChanges) {
  if (changes[‹formModelConfig']) {
    this.formModel = new FormGroup({});
    this.formModelConfig.forEach((control) =&gt; {
      this.formModel.addControl(
        control.controlKey,
        new FormControl(control.defaultValue, { updateOn: control.updateOn, validators: control.validators }));
    }); }}</span></pre> <p><span class="koboSpan" id="kobo.1600.1">As you</span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.1601.1"> can see, we check if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1602.1">changes</span></strong><span class="koboSpan" id="kobo.1603.1"> object contains a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1604.1">formModelConfig</span></strong><span class="koboSpan" id="kobo.1605.1">; when </span><strong class="source-inline"><span class="koboSpan" id="kobo.1606.1">formModelConfig</span></strong><span class="koboSpan" id="kobo.1607.1"> is included in the changes, we use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1608.1">forEach</span></strong><span class="koboSpan" id="kobo.1609.1"> loop to add the form controls of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1610.1">formModelConfig</span></strong><span class="koboSpan" id="kobo.1611.1"> to our form model. </span><span class="koboSpan" id="kobo.1611.2">We also need a submit function and an output that will send the form model to the parent component </span><span class="No-Break"><span class="koboSpan" id="kobo.1612.1">on submission:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1613.1">
@Output() outputForm = new EventEmitter();
onSubmit() {
  this.outputForm.emit(structuredClone(this.formModel.value));
  this.formModel.reset();
}</span></pre> <p><span class="koboSpan" id="kobo.1614.1">For our component class, this is everything we need. </span><span class="koboSpan" id="kobo.1614.2">We need to translate this into the template so that our form will be built based on the configuration. </span><span class="koboSpan" id="kobo.1614.3">Start by adding the form tag, bind it to the form model, and add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1615.1">ngSubmit</span></strong><span class="koboSpan" id="kobo.1616.1"> function to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1617.1">form</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1618.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1619.1">
&lt;div class="form-container"&gt;
  &lt;form [formGroup]="formModel" (ngSubmit)="onSubmit()"&gt;
  &lt;/form&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.1620.1">Next, we need to create an input for each configuration inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1621.1">formModelConfig</span></strong><span class="koboSpan" id="kobo.1622.1">. </span><span class="koboSpan" id="kobo.1622.2">We will use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1623.1">*ngFor</span></strong><span class="koboSpan" id="kobo.1624.1"> loop to output elements for each instance inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1625.1">formModelConfig</span></strong><span class="koboSpan" id="kobo.1626.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1627.1">*ngSwitch</span></strong><span class="koboSpan" id="kobo.1628.1"> directive to determine which element to create. </span><span class="koboSpan" id="kobo.1628.2">We will use the properties of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1629.1">DynamicControl</span></strong><span class="koboSpan" id="kobo.1630.1"> to bind the elements to the form and provide </span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.1631.1">all the </span><span class="No-Break"><span class="koboSpan" id="kobo.1632.1">correct values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1633.1">
&lt;div class="form-field" </span><strong class="bold"><span class="koboSpan" id="kobo.1634.1">*ngFor="let control of formModelConfig"</span></strong><span class="koboSpan" id="kobo.1635.1">&gt;
  &lt;label for=»description»&gt;{{</span><strong class="bold"><span class="koboSpan" id="kobo.1636.1">control.label</span></strong><span class="koboSpan" id="kobo.1637.1">}}&lt;/label&gt;
  &lt;ng-container </span><strong class="bold"><span class="koboSpan" id="kobo.1638.1">[ngSwitch]=»control.formFieldType»</span></strong><span class="koboSpan" id="kobo.1639.1">&gt;
    &lt;input </span><strong class="bold"><span class="koboSpan" id="kobo.1640.1">*ngSwitchCase=»›input›»</span></strong><span class="koboSpan" id="kobo.1641.1">
            formControlName="{{</span><strong class="bold"><span class="koboSpan" id="kobo.1642.1">control.controlKey</span></strong><span class="koboSpan" id="kobo.1643.1">}}"
            type="{{</span><strong class="bold"><span class="koboSpan" id="kobo.1644.1">control.inputType</span></strong><span class="koboSpan" id="kobo.1645.1">}}"&gt;
    &lt;select </span><strong class="bold"><span class="koboSpan" id="kobo.1646.1">*ngSwitchCase=»›select›»</span></strong><span class="koboSpan" id="kobo.1647.1">
            formControlName="{{</span><strong class="bold"><span class="koboSpan" id="kobo.1648.1">control.controlKey</span></strong><span class="koboSpan" id="kobo.1649.1">}}"&gt;
      &lt;option
         *ngFor="let option of control.selectOptions"
         value="{{option}}"&gt;
      &lt;/option&gt;
    &lt;/select&gt;
  &lt;/ng-container&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.1650.1">Once you’ve added this HMTL, each form element will be rendered and bound to the form model. </span><span class="koboSpan" id="kobo.1650.2">The last thing we need to do is add error messages. </span><span class="koboSpan" id="kobo.1650.3">Here’s an example of how you can display error messages inside your </span><span class="No-Break"><span class="koboSpan" id="kobo.1651.1">dynamic form:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1652.1">
&lt;span *ngIf="formModel.touched &amp;&amp; formModel.get(control.controlKey)?.hasError('required')"&gt; This field is required&lt;/span&gt;</span></pre> <p><span class="koboSpan" id="kobo.1653.1">Add an additional </span><strong class="source-inline"><span class="koboSpan" id="kobo.1654.1">span</span></strong><span class="koboSpan" id="kobo.1655.1"> for each error message your form supports. </span><span class="koboSpan" id="kobo.1655.2">To test the dynamic form, you can import it inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1656.1">expenses-overview-page.component</span></strong><span class="koboSpan" id="kobo.1657.1"> and add the</span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.1658.1"> selector inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.1659.1">HTML template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1660.1">
&lt;bt-libs-ui-dynamic-form [formModelConfig]="formModelConfig" (outputForm)="addExpense($event)" /&gt;</span></pre> <p><span class="koboSpan" id="kobo.1661.1">Create </span><strong class="source-inline"><span class="koboSpan" id="kobo.1662.1">formModelConfig</span></strong><span class="koboSpan" id="kobo.1663.1"> inside the component class so that the dynamic form has fields </span><span class="No-Break"><span class="koboSpan" id="kobo.1664.1">to generate:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1665.1">
formModelConfig: DynamicControl[] = [
  {
    controlKey: 'description', formFieldType: 'input',
    inputType: 'text', label: 'Description',
    defaultValue: '', updateOn: 'change',
    validators: [Validators.required]
  },
  {
    controlKey: 'amount', formFieldType: 'input',
    inputType: 'number', label: 'Amount excl. </span><span class="koboSpan" id="kobo.1665.2">VAT',
    defaultValue: null, updateOn: 'change',
    validators: [Validators.required]
  }
]</span></pre> <p><span class="koboSpan" id="kobo.1666.1">Go ahead and add the rest of the fields we used inside our reactive and template-driven form to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1667.1">formModelConfig</span></strong><span class="koboSpan" id="kobo.1668.1">; you will see that the same form will be generated dynamically, including the validation rules and </span><span class="No-Break"><span class="koboSpan" id="kobo.1669.1">error messages.</span></span></p>
<p><span class="koboSpan" id="kobo.1670.1">This is just a simple example of a dynamic form; you can add additional logic if you want, such as to allow form groups, form arrays, and form records. </span><span class="koboSpan" id="kobo.1670.2">The concept stays the same; just adjust the model, add the logic inside the component class to generate the form model correctly, and </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.1671.1">adjust the template so that you can render it how </span><span class="No-Break"><span class="koboSpan" id="kobo.1672.1">you intended.</span></span></p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.1673.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1674.1">In this chapter, you learned about Angular’s different types of forms. </span><span class="koboSpan" id="kobo.1674.2">You now know the difference between template-driven and reactive forms and when to use which type. </span><span class="koboSpan" id="kobo.1674.3">We created a template-driven form that includes validation, error messages, default values, and styling based on control statuses. </span><span class="koboSpan" id="kobo.1674.4">We also created a custom validator directive for the template-driven form. </span><span class="koboSpan" id="kobo.1674.5">Next, we recreated the same for using </span><span class="No-Break"><span class="koboSpan" id="kobo.1675.1">reactive forms.</span></span></p>
<p><span class="koboSpan" id="kobo.1676.1">We also created a custom validator function that can be used inside the reactive form. </span><span class="koboSpan" id="kobo.1676.2">We learned about dynamically adding fields inside form group, form array, or form record classes inside the reactive form. </span><span class="koboSpan" id="kobo.1676.3">Then, we learned how to change our fields’ update behavior in both template-driven and reactive forms. </span><span class="koboSpan" id="kobo.1676.4">Lastly, you built a dynamic form that builds the form model based on a configuration and will render the form accordingly, including validations and </span><span class="No-Break"><span class="koboSpan" id="kobo.1677.1">error messages.</span></span></p>
<p><span class="koboSpan" id="kobo.1678.1">In the next chapter, you will learn how to create dynamic components, which can be reused in </span><span class="No-Break"><span class="koboSpan" id="kobo.1679.1">many scenarios.</span></span></p>
</div>


<div class="Content" id="_idContainer019">
<h1 id="_idParaDest-82" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.1.1">Part 2:Handling Application State and Writing Cleaner, More Scalable Code</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part, you’ll learn how to develop cleaner, more scalable, and performant code for your Angular applications. </span><span class="koboSpan" id="kobo.2.2">You’ll start by developing dynamic components suited for more complex UI scenarios. </span><span class="koboSpan" id="kobo.2.3">You’ll learn about lazy-loading individual components on demand to reduce your bundle size and enhance performance. </span><span class="koboSpan" id="kobo.2.4">Then, you’ll explore commonly used conventions and design patterns to develop more robust and scalable Angular applications. </span><span class="koboSpan" id="kobo.2.5">You’ll finish this part by getting hands-on experience implementing the facade pattern, state management using NgRx, and reactive programming with RxJs </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">and signals.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part includes the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B21625_05.xhtml#_idTextAnchor083"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Creating Dynamic Angular Components</span></em></li>
<li><a href="B21625_06.xhtml#_idTextAnchor115"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Applying Code Conventions and Design Patterns in Angular</span></em></li>
<li><a href="B21625_07.xhtml#_idTextAnchor129"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Mastering Reactive Programming in Angular</span></em></li>
<li><a href="B21625_08.xhtml#_idTextAnchor150"><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.16.1">, </span><em class="italic"><span class="koboSpan" id="kobo.17.1">Handling Application State with Grace</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer020">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer021">
</div>
</div>
</body></html>