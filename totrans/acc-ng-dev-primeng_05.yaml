- en: '*Chapter 9*: Debugging with the New Ivy Runtime APIs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular Ivy introduces a new API for inspecting and debugging our Angular applications
    at runtime. It replaces the previous `NgProbe` API and allows tree-shaking of
    `DebugElement`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore Angular''s most useful runtime debugging functions, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ng.applyChanges`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng.getComponent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng.getContext`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng.getListeners`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having these debugging utilities at hand will allow you to verify your assumptions
    about active components, their templates, and their DOM bindings at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the new Ivy runtime API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting an active component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting event listeners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting an embedded view context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting familiar with these topics will improve your development workflow when
    implementing Angular Ivy applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To support all the features used in the code examples of this chapter, your
    application requires at least the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Angular Ivy version 12.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript version 4.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, note that the runtime debugging API is only available when Angular runs
    in development mode.
  prefs: []
  type: TYPE_NORMAL
- en: You can find complete code examples for the random number generator in this
    book's companion GitHub repository at [https://github.com/PacktPublishing/Accelerating-Angular-Development-with-Ivy/tree/main/projects/chapter9/random-number](https://github.com/PacktPublishing/Accelerating-Angular-Development-with-Ivy/tree/main/projects/chapter9/random-number).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the new Ivy runtime API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have worked with Angular versions before Angular Ivy, you might be familiar
    with the `NgProbe` API, which was available in the global scope at runtime as
    the `ng.probe` function. Angular Ivy replaces this API with a set of new runtime
    debugging functions, which are only available in Angular development mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new API contains the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ng.applyChanges(component: {}): void;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark the specified component for dirty checking if it is using the `OnPush`
    change detection strategy. Afterward, trigger a change detection cycle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ng.getComponent<T>(element: Element): T | null;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolve the Angular component that is attached to the specified DOM element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ng.getContext<T>(element: Element): T | null;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When passed a DOM element generated by a structural directive such as `NgIf`
    or `NgFor`, resolve the view context of the embedded view. In other cases, resolve
    the parent component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ng.getDirectiveMetadata(directiveOrComponentInstance: any): ComponentDebugMetadata
    | DirectiveDebugMetadata | null;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolve the metadata of the specified Angular component or directive instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ng.getDirectives(element: Element): {}[];`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolve Angular directives – but not components – attached to the specified
    DOM element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ng.getHostElement(componentOrDirective: {}): Element;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolve the host element that the specified component or directive is attached
    to.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ng.getInjector(elementOrDir: {} | Element): Injector;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolve the injector associated with the specified element, directive, or component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ng.getListeners(element: Element): Listener[];`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolve event listeners attached to the specified DOM element. This does not
    include host listeners created from directive or component metadata but includes
    event listeners not added by Angular.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ng.getOwningComponent<T>(elementOrDir: {} | Element): T | null;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolve the host component of the specified DOM element, directive, or component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ng.getRootComponents(elementOrDir: {} | Element): {}[];`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolve the root components associated with the specified DOM element, directive,
    or component, that is, the components bootstrapped by Angular.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `Listener` data structures returned by `ng.getListeners` have the following
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The data structures returned by `ng.getDirectiveMetadata` have the following
    interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `inputs` and `outputs` properties defined in the preceding debug metadata
    interfaces contain object maps from data binding property names to component property
    names.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to be aware that the `ComponentDebugMetadata#changeDetection`
    and `ComponentDebugMetadata#encapsulation` properties are number enumerations,
    so their values will be numbers at runtime, not strings. This makes them a bit
    harder to interpret when debugging.
  prefs: []
  type: TYPE_NORMAL
- en: As seen in the preceding overview, most of these runtime debugging utilities
    accept as a parameter a DOM element, a component instance, or a directive instance.
    From the specified object, they look up DOM elements, one or more component instances,
    one or more directive instances, an injector, or event listeners attached to the
    DOM.
  prefs: []
  type: TYPE_NORMAL
- en: The one that stands out is `ng.applyChanges`. We will discuss when and how to
    use it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting a component instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To explore our application programmatically at runtime, we often need a reference
    to an active component instance. Once we have a component reference, we can change
    bound properties and call event handlers or other methods.
  prefs: []
  type: TYPE_NORMAL
- en: However, first, we need a reference to either a directive instance or a DOM
    element with an attached component. Using the `$0` variable. Alternatively, we
    can use `document.querySelector`, or any other DOM querying or traversing API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we have a component that generates random numbers, as seen in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – A component for generating a random number'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.1_B16295.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – A component for generating a random number
  prefs: []
  type: TYPE_NORMAL
- en: 'It has a component model as seen in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In its template, it is using Angular Material''s Button component as seen in
    the following code listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that we have a reference to the `<button>` DOM element in the `$0` variable,
    we can do the following to resolve two different component instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There is a subtle but important distinction between `ng.getComponent` and `ng.getOwningComponent`.
    The first invocation returns an instance of the `MatButton` component, which is
    attached to the `<button>` DOM element. The second invocation gives us a reference
    to the active instance of `RandomNumberComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: We conclude that `ng.getComponent` returns the component attached to the specified
    DOM element, in this case `MatButton`. Now, `ng.getOwningComponent` returns the
    component instance that's associated with the component template used to generate
    the specified DOM element, in this case an instance of `RandomNumberComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `generatedNumber` UI property is bound to text in the DOM created for the
    random generator component by Angular. What if we wanted to change it to something
    specific, say `42`? With a reference to an active component instance, we can change
    UI properties directly as seen in the following browser console listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: However, when looking at the rendered application, we notice that the DOM has
    not been updated to reflect this new component state. When using the runtime debugging
    API, we must let Angular know when we have manually changed the state and want
    Angular to update the DOM it manages.
  prefs: []
  type: TYPE_NORMAL
- en: 'We notify Angular of the dirty state by passing the component instance to `ng.applyChanges`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After Angular completes a change detection cycle, we notice that the new state
    is reflected in the DOM, as seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – A component displaying a manually specified number'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.2_B16295.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – A component displaying a manually specified number
  prefs: []
  type: TYPE_NORMAL
- en: Great, now you are familiar with the most common runtime debugging functions,
    which put us in control of Angular components. In the following sections, we will
    look at debugging APIs that are instrumental to runtime debugging, yet not as
    commonly used.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting event listeners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll reuse the random number generator example from the *Inspecting a component
    instance* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reference, the following is the random number directive used in the template
    of the random number component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When its `generateNumber` method is called, it outputs the randomly generated
    number through the `numberGenerated` output property. The random number component
    has bound its event handler `RandomNumberComponent#onNumberGenerated` to this
    custom component event.
  prefs: []
  type: TYPE_NORMAL
- en: DOM event listeners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We pick the `<button>` element in the `$0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice in the component template that the button component has a click event
    binding. We want to access it so that we can trigger it. To do that, pass the
    button DOM element to the `ng.getListeners` function, as seen in the following
    browser console listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We unpack the first and only event listener that is returned by `ng.getListeners`
    when passed the button DOM element. This `Listener` data structure is stored in
    the `onButtonClick` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We invoke the click event handler by invoking `onButtonClick.callback`. This
    triggers the same state update as clicking the **Generate** button. However, Angular
    is not aware of the dirty state.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: DOM event listeners registered outside of Angular code are also returned by
    `ng.getListeners`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might remember from the *Inspecting a component instance* section that
    we must notify Angular of state changes we introduce through the runtime debugging
    APIs. We do this by passing the component instance to `ng.applyChanges` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When Angular finishes a change detection cycle, the newly generated number is
    displayed in the DOM for the random number generator component, which is managed
    by Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we did not pass any parameters to the `Listener#callback` method.
    In our use case, the event handler did not accept any parameters. If it did, we
    would most likely have to pass arguments of the expected type for it to work.
    For example, a click event listener might accept a `MouseEvent` event of type
    `click`.
  prefs: []
  type: TYPE_NORMAL
- en: Custom component event bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Event handlers bound by Angular custom component event bindings are also registered
    as listeners. Our example component has an inline event handler bound for the
    custom `numberGenerated` event.
  prefs: []
  type: TYPE_NORMAL
- en: We pick the `<span>` element in the `$0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We pass the `span` element to `ng.getListeners`, and notice that it lists two
    listeners, one of type `"dom"` and another one of type `"output"`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We simulate a random number generation by passing `7` to `outputListener.callback`
    and run change detection by passing the component to `ng.applyChanges`. This is
    shown in the following browser console listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Once a change detection cycle has finished, the random number generation that
    we simulated is displayed in the DOM, which is managed by Angular.
  prefs: []
  type: TYPE_NORMAL
- en: That is all for inspecting native and custom event listeners using the Angular
    runtime debugging API. In the final section of this chapter, we'll learn what
    an embedded view context is, and how to inspect it using Angular Ivy's runtime
    debugging API.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting an embedded view context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A structural directive is used to add and remove elements to the DOM throughout
    the lifecycle of a component. They create an embedded view, which is bound to
    a view context. This is the case of the `NgIf` and `NgFor` directives that are
    part of the Angular framework.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Only one structural directive can be attached to an element. If you need to
    apply multiple structural directives, wrap the element in the special `<ng-container>`
    element, attach the outer structural directive to this element, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we pass an element with a structural directive attached to `ng.getContext`,
    it returns the view context. For example, when we pass an element with an `NgIf`
    directive attached to it, `NgIfContext` is returned, which has the following shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The embedded view that is dynamically created by `NgIf` is bound to the `$implicit`
    property of `NgIfContext`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we instead pass an element that has an `NgFor` directive attached to it,
    `NgForOfContext` is returned. It has the following shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: An embedded view is dynamically created by the `NgFor` directive for each item
    in `NgForOfContext#ngForOf`. Each embedded view is bound to the `$implicit` property
    of `NgForOfContext` specific to that item.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, each embedded view also has access to the other properties that are
    specified in `NgForOfContext`. For example, we can loop through a list of users
    and store a reference to the `index` and `first` context properties, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The embedded view created for each user has access to and uses the `index` and
    `first` properties, which are aliased as `i` and `isFirst`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing a list item element from the previous code listing to `ng.getContext`
    results in an `NgForOfContext` value, such as the examples in the following code
    listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if we pass the `<span>` element to `ng.getContext`, we get an `NgIfContext`
    value, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Take special care to pass the element that has a structural directive attached,
    or you will instead receive the closest component instance.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know how to inspect the embedded view context of template elements with
    a structural directive attached.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope you like the new shiny tools that we added to your toolbox in this chapter.
    We started with an overview of Angular Ivy's runtime debugging API, which is available
    only in development mode.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we learned how to inspect a component instance using `ng.getComponent`
    and `ng.getOwningComponent`. We also changed the component state, then updated
    the DOM using `ng.applyChanges`.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Inspecting event listeners* section, we used `ng.getListeners` to inspect
    both native DOM event listeners and custom component event listeners. We passed
    arguments to their callbacks and triggered change detection using `ng.applyChanges`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you now know what an embedded view context is and how to inspect it,
    for example, how one is created and bound to each component or element managed
    by the `NgFor` directive. Similarly, we explored an example of an embedded view
    context for an element managed by an `NgIf` directive.
  prefs: []
  type: TYPE_NORMAL
- en: With all these newfound skills, you are ready to debug Angular applications
    by inspecting and updating state directly or through events, then reflecting the
    changes by triggering change detection.
  prefs: []
  type: TYPE_NORMAL
- en: You are even able to inspect the ever-so-hard-to-locate embedded view contexts.
    Amazing!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about the Angular Compatibility Compiler,
    and when and why it is needed. We will explore its configuration options and optimize
    it for a CI/CD workflow.
  prefs: []
  type: TYPE_NORMAL
