- en: 5\. Global Component Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to reduce duplication in your Vue.js application
    code using global abstractions, new composition models, and new types of components.
    You will experiment with Vue.js **mixins**, **plugins**, and new types of components
    and ways of composing them.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to identify situations where **mixins**
    and **plugins** can be used to achieve global composition and keep code **DRY**
    (**don't repeat yourself**) in a Vue.js application, as well as how to define
    global components, functional components, and components in non-Vue files. You
    will also be able to contrast the advantages and drawbacks of global composition
    and select the right abstraction to maximize component flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Component nesting is an approach to composition where the application is built
    up from smaller units (components). The application can be thought of as components
    fitting within each other. In this scenario, any shared functionality will be
    provided through components. Vue.js provides other methods of composition.
  prefs: []
  type: TYPE_NORMAL
- en: Component-based composition can be very verbose and will mean we repeat imports
    wherever a certain piece of functionality is needed. This does not follow the
    DRY principle. To avoid this duplication and verbosity, we can globally register
    `import MyComponent from ...` in every consumer of `MyComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Much in the same way, applications can be built from different types of primitives
    (mixins, plugins, and components). For maximum flexibility, components can be
    defined in different ways beyond Vue.js single-file component files (`.vue` files).
    In this category, we have the case of functional components, as well as components
    defined with `render` functions. Each of these types of components has some advantages
    and drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: To keep code DRY, a component should be easy to use and extend. This chapter
    will look at a few tips that we can follow to make a component more reusable,
    thereby making the application more DRY.
  prefs: []
  type: TYPE_NORMAL
- en: Mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mixins can add methods, properties, and default life cycle methods to components
    that consume them. In the following example, we are defining a mixin that adds
    a `greet` method and a `greeting` field to the component''s `data` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Mixins allow multiple components' shared functionality to be defined independently.
    They are used through a `mixins` component property, which accepts an array.
  prefs: []
  type: TYPE_NORMAL
- en: In the `App.vue` file, we can consume the mixin by setting the component's `mixins` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The properties and methods of the mixin are then available in the component
    (just as they would be if they were defined in the component itself):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This displays the following message in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Hello World using a greeter mixin'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_05_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.1: Hello World using a greeter mixin'
  prefs: []
  type: TYPE_NORMAL
- en: When there is a conflict, in terms of instance properties or methods that are
    named the same, between the component and the mixin, the component wins. This
    can be thought of as the component adopting mixin behavior by default unless said
    component declares the same instance property or method. In this case, instance
    access that is defined in the mixin would access the component's instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s add a `data()` initializer to our `App` component that
    has `greeting` set to `Hi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The mixin defines a `data` method, but so does the component. In this case,
    the component *wins*, hence why the greeting displayed is `Hi` (as defined in
    the component) instead of `Hello` (as defined in the mixin), as displayed in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: Hi World using a greeter mixin with overridden data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_05_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.2: Hi World using a greeter mixin with overridden data'
  prefs: []
  type: TYPE_NORMAL
- en: Note that when the component does not define a `data` method, the mixin's implementation
    is used but the component "wins" if both the mixin and the component define it.
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js life cycle hooks are prime candidates to be extracted into mixins. The
    life cycle hooks we can use are (in order of execution) `beforeCreated`, `created`,
    `beforeMount`, `mounted`, `beforeUpdate`, `updated`, `beforeDestroy`, and `destroyed`.
  prefs: []
  type: TYPE_NORMAL
- en: Life cycle hooks are an exception to the mixin/component conflict resolution
    rule mentioned previously. In the case of Vue.js life cycle hooks functions, for
    each mixin, component, and hook, the hook functions are all executed in the order
    of mixins first (in order of addition to the component), component last.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this in action in the following example. Let''s create two mixins
    that implement the `mounted` life cycle hook and implement that hook in the component.
    This illustrates the case of life cycle hooks for mixin/component conflict resolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The browser console output for this component will be (in order) `First mixin
    mounted hook`, `Second mixin mounted hook`, and `Component mounted hook`, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: Browser console output showing the hooks defined in the mixins
    that were executed before the component hooks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_05_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.3: Browser console output showing the hooks defined in the mixins
    that were executed before the component hooks'
  prefs: []
  type: TYPE_NORMAL
- en: All the examples we have seen have used mixins directly to inject functionality
    into components. Mixins can also be created globally by using a `Vue.mixin` function
    call.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, for example, make our greeting function a global instance method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`this.$greet` will now be available on all Vue instances declared after the
    `Vue.mixin` call. This use case, however, is better served by a plugin.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `$methodName` convention is used in Vue.js for methods that are provided
    by the Vue.js application instance (as opposed to the current component instance).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.01: Creating Your Own Mixin'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will create a mixin called `debug` that will return the
    JSON-stringified representation of the input it has been passed. `debug` do what
    is called pretty-printing so that we can read it more easily.
  prefs: []
  type: TYPE_NORMAL
- en: This can also be useful for printing data inside HTML when debugging a Vue.js
    application in a situation where Vue.js DevTools are not available or reliable.
    To access the code files for this exercise, refer to [https://packt.live/38ivgFq](https://packt.live/38ivgFq).
  prefs: []
  type: TYPE_NORMAL
- en: We will start with a clean Vue CLI project (this can be created with the `vue
    new exercise5.01` command). The application in the Vue CLI project can be started
    with `npm run serve`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `src/mixins` folder and a `src/mixins/debug.js` file where we
    will define the skeleton of our mixin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The mixin will add a `debug` method, which we should define under `methods`.
    The `debug` method will take an `obj` parameter and return the output of `JSON.stringify`
    for that data. We will use `JSON.stringify(obj, null, 2)` to output two-space
    pretty-printed JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are now able to import the `debug` mixin from `src/App.vue` and register
    it under the `mixins` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To see the `debug` method in action, we will add a `data` method and a `created`
    hook (from which we can print the output of `debug`) in the `src/App.vue` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.4: Browser console output due to the created hook'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_05_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.4: Browser console output due to the created hook'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`debug` is also available in the template; we can interpolate its output in
    a `pre` tag so that whitespace is respected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The application, as well as this template, will look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.5: Browser printing myObj using the debug method from the mixin'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_05_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.5: Browser printing myObj using the debug method from the mixin'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have learned how mixins can be used to inject shared functionality
    into multiple components in a manner that is quite explicit (a `mixins` property).
    We also got a chance to see what happens when a component's implementation overwrites
    properties and methods provided by the mixin (the component usually wins).
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at how to inject instance and global functionality and distribute
    it through plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue.js plugins are a way to add custom functionality to Vue.js globally. Good
    candidates for plugins are core to the application and used widely. Classic examples
    of plugin candidates are translation/internationalization libraries (such as `i18n-next`)
    and HTTP clients (such as the `axios`, `fetch`, and `GraphQL` clients). The plugin
    initializer has access to the `Vue` instance, so it can be a good way to wrap
    global directive, mixin, component, and filter definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins can inject functionality by registering directives and filters. They
    can also add `global` and `instance` Vue.js methods, as well as defining global
    component mixins.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Vue.js plugin is an object that exposes an `install` method. The `install`
    function is called with `Vue` and `options`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `install` method, we can register directives, filters, and mixins
    and add global and instance properties and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Plugins are registered using the `Vue.use` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`Vue.use` can also be passed options as the second argument. These options
    are passed to the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: One of the features of `Vue.use` is that it does not allow you to register the
    same plugin twice. This is a nice feature that avoids edge case behavior when
    attempting to instantiate or install the same plugin multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: A popular HTTP client to use in combination with Vue.js is `axios`. It is common
    to configure `axios` with interceptors or `axios` options to achieve things such
    as retries, passing cookies, or following redirects.
  prefs: []
  type: TYPE_NORMAL
- en: '`axios` can be installed using: `npm install –save axios`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.02: Creating a Custom Axios Plugin'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to avoid having to add `import axios from 'axios'` or having to wrap
    our custom `axios` instance under an `http` or `transport` internal module, we'll
    inject our custom `axios` instance into the Vue object and Vue component instances
    under `Vue.axios` and `this.axios`. This will make it easier and more ergonomic
    to use in our application, which needs to call out to an API using `axios` as
    the HTTP client. To access the code files for this exercise, refer to [https://packt.live/36po08b](https://packt.live/36po08b).
  prefs: []
  type: TYPE_NORMAL
- en: We will start with a clean Vue CLI project (this can be created with the `vue
    new exercise5.02` command). The application in the Vue CLI project can be started
    with `npm run serve`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To organize our code properly, we will create a new folder in `src/plugins`
    and a new file for our `axios` plugin at `src/plugins/axios.js`. In the new file,
    we will scaffold the `axios` plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now register our `axios` plugin on the Vue.js instance in `src/main.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now install `axios` through `npm` using the following command. This
    will allow us to import `axios` and expose it on Vue through a plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now add `axios` to Vue as a global property in `src/plugins/axios.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`axios` is now available on `Vue`. In `src/App.vue`, we can make a request
    to an API that will populate a list of `todos`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the expected output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.6: Global Vue.axios todo display sample'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_05_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.6: Global Vue.axios todo display sample'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Having to add `import Vue from ''vue''` is a bit odd in our case. The whole
    point of injecting `axios` through a plugin was to get rid of the `import` boilerplate.
    The better way to expose `axios` is through the component instance; that is, `this.axios`.
    To do so, we need to update the install step in the `src/plugins/axios.js` file
    and add `axios` to the `Vue.prototype` so that any `new Vue()` component will
    have it as a property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now remove the `import Vue from ''vue''` line and access `axios` through
    `this.axios` in `src/App.vue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.7: Vue instance axios todo display sample'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_05_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.7: Vue instance axios todo display sample'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have used a plugin to inject both global and instance-level properties
    and methods, as well as having learned how they can be used to create directives
    and other Vue constructs in a format that is easy to distribute.
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at how globally registering components can help reduce boilerplate
    for high usage components in a code base.
  prefs: []
  type: TYPE_NORMAL
- en: Globally Registering Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A reason for using plugins is to reduce boilerplate in all Vue application files
    by removing `imports` and replacing them with access to `this` and/or `Vue`.
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js components are usually defined in a single-file component and imported
    explicitly. Much for the same reasons as we define global methods and properties,
    we might want to register components globally. This will allow us to use these
    components in all our other component templates without having to import them
    and register them under the `components` property.
  prefs: []
  type: TYPE_NORMAL
- en: A situation where this can be very useful is when using a design system or when
    a component is used across the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Globally registering a component helps with some types of updates, such as if
    the filename is not exposed to the consumer so that when changing the filename,
    there is only one path to update as opposed to one per user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have a `CustomButton` component in the `CustomButton.vue`
    file that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can register `CustomButton` globally as follows (this is usually done in
    the `main.js` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use it in the `App.vue` file without locally registering it or importing
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This renders as expected, with a button called `Click Me`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8: CustomButton rendering with a Click Me button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_05_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.8: CustomButton rendering with a Click Me button'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have explored how globally registering components can cut down
    on boilerplate when components are used often across a code base.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at some tips on how to increase component flexibility in
    Vue.js.
  prefs: []
  type: TYPE_NORMAL
- en: Maximizing Component Flexibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue.js components take props and slots as input; their output is rendered as
    HTML and emitted events.
  prefs: []
  type: TYPE_NORMAL
- en: To maximize component flexibility, it always makes sense to leverage slots and
    props.
  prefs: []
  type: TYPE_NORMAL
- en: 'Leveraging props and default values judiciously means a component can be reused
    and extended. For example, instead of hardcoding a value in the component, we
    could set it as a default prop. In this case, `date` defaults to the current date,
    `new Date()`. We then extract the epoch using a computed property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When registered and used, this renders as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Slots can be thought of as a way for a component to delegate rendering back
    to its consumers. Delegating parts of the template to the parent component helps
    with reusability.
  prefs: []
  type: TYPE_NORMAL
- en: 'A specific example of slots used to maximize reusability is the **renderless
    component** pattern. For example, in the epoch display example, we could leverage scoped
    slots and remove any rendering logic from the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the parent component, the rendering can be defined using a scoped slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the delegation of the component is delegated to the parent
    and displays the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The next set of practices maximize the reuse of components by making their API
    predictable. In many ways, forwarding attributes, leveraging the `style` and `class`
    attributes being merged, and implementing a `v-model` interface is another way
    of making Vue.js custom components behave more like HTML elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Forwarding attributes can be interesting. For example, a `CustomInput` component
    (in the `CustomInput.vue` file) might need to pass the `type` attribute, as well
    as a `required` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CustomInput` component can be used to render any type of component (`src/App.vue`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This renders the text and date inputs correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9: CustomInput with text and date as types'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_05_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.9: CustomInput with text and date as types'
  prefs: []
  type: TYPE_NORMAL
- en: 'Vue.js does a lot of the heavy lifting around classes/inline styles since it
    merges the `style` and `class` objects defined on a component with the `style`
    and `class` objects of the root element in said component. As per the documentation,
    "*the class and style attributes are a little smarter, so both values are merged*"
    (*Vue.js Component Props guide*: [https://vuejs.org/v2/guide/components-props.html#Replacing-Merging-with-Existing-Attributes](https://vuejs.org/v2/guide/components-props.html#Replacing-Merging-with-Existing-Attributes)).'
  prefs: []
  type: TYPE_NORMAL
- en: In Vue.js, the tendency is for input elements and components to be controlled
    through `v-model`, a two-way reactive Vue.js binding. `v-model` is shorthand for
    using `v-bind:value` and `v-on:input` to provide a value and keep it in sync with
    the output from the child component or element.
  prefs: []
  type: TYPE_NORMAL
- en: The `value` that is passed is only used as the starting value; `input` events
    are emitted when the input is done being captured (for example, typing is done).
  prefs: []
  type: TYPE_NORMAL
- en: If a component implements the `v-model` shape, it works as a direct replacement
    for form elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a `TextInput` that implements the `v-model` interface can be used
    interchangeably with `input` and `textarea`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This can then be used as follows in `src/App.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The application renders as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10: Custom component implementing v-model'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_05_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.10: Custom component implementing v-model'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have looked at how to leverage props and slots, inherit attributes,
    and implement well-known Vue.js interfaces to help maximize component flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: The next section is dedicated to deepening our understanding of Vue.js components
    by learning how to use them without `.vue` files.
  prefs: []
  type: TYPE_NORMAL
- en: Using Vue.js Components without a .vue Single-File Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the examples we have seen of Vue.js components have leveraged `.vue`
    single-file components.
  prefs: []
  type: TYPE_NORMAL
- en: This is not the only way to define a Vue.js component. In this section, we will
    look at four different ways to define Vue.js components without using a `.vue`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating these options will help us understand what a Vue.js component is
    at its core.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime Definition with a String Template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A component can use a `template` property that accepts a string value. This
    is commonly called a **string template**. This template is evaluated at runtime
    (in the browser).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a component in the `StringTemplate.js` file by defining an object
    with a `template` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This can then be consumed from the `App.vue` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this crashes on load and displays the following Vue warning
    in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11: Vue runtime compiler missing warning'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_05_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.11: Vue runtime compiler missing warning'
  prefs: []
  type: TYPE_NORMAL
- en: As per the Vue warning, for this component to work when imported, we need to
    include the Vue.js compiler in the runtime build. To do so, in a Vue CLI project,
    we can set the `runtimeCompiler` option to `true` in `vue.config.js` (the Vue
    CLI configuration file).
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `vue.config.js` should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'After setting this option and restarting the development server, a message
    from the `StringTemplate` component appears in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Props and other component instance properties can be defined with `.vue` component
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: The render Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Vue.js single-file component `template` section gets compiled into a `render`
    function at build time.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `render` function tends to be used in the `main.js` file of a Vue CLI project
    – specifically, the `new Vue()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: A `render` function takes a `createElement` parameter and returns a virtual
    DOM node. This is done by calling the `createElement` function (in the preceding
    example, this is `h`).
  prefs: []
  type: TYPE_NORMAL
- en: '`h` is often used as shorthand for `createElement` due to its compactness.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a component in a JavaScript file (`RenderFunction.js`) with a
    `render` property like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be rendered in the `App.vue` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This component displays a `h2` with **Render Function Component** as its content
    in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Beyond writing components in non `.vue` files, `render` functions can be useful
    for highly dynamic components.
  prefs: []
  type: TYPE_NORMAL
- en: JSX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSX has been popularized by React. As per the React documentation, *JSX is a
    syntax extension to JavaScript. We recommend using it with React to describe what
    the UI should look like* ([https://reactjs.org/docs/introducing-jsx.html](https://reactjs.org/docs/introducing-jsx.html)).
    JSX is a superset of JavaScript that allows `HTML-style` tags and interpolation
    using braces.
  prefs: []
  type: TYPE_NORMAL
- en: React, like Vue.js, does not render JSX to the DOM. Like Vue.js templates, React
    application build tools compile JSX to `render` functions that are used at runtime
    so that they can be rendered to the Virtual DOM. The Virtual DOM is then *reconciled*
    (synced) with the real DOM.
  prefs: []
  type: TYPE_NORMAL
- en: JSX compiles to `render` functions and Vue.js supports component definitions
    with `render` functions. Moreover, **Vue CLI 3+** compiles JSX out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means we can write the following, which is the equivalent of the `RenderFunction`
    component, `JSXRender.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent `render` function without JSX looks as follows (based on the
    example from the previous section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `App.vue` file renders `JSXRender` to the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can see the `h2` from `JSXRender` on the screen with the expected content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have learned that Vue.js components are just objects with a `render`
    or `template` function. `.vue` component `template` sections are compiled to `render`
    functions at build time, which means that to use string templates, we need to
    include the Vue.js compiler in the application runtime. We have also learned how
    to use `render` functions, as well as JSX, to define components and pointed out
    some things React and Vue.js have in common from an implementation point of view.
    When choosing to use JSX or `render` functions, JSX can be easier to read with
    the full flexibility of `render` functions (which regular templates do not always
    have).
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at how components can be rendered dynamically from runtime
    data using the Vue.js `component` tag.
  prefs: []
  type: TYPE_NORMAL
- en: The Vue component Tag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSX and `render` functions are great for situations where the component being
    rendered needs to be very dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: The way to achieve this within regular Vue.js templates is by using the `component` tag.
  prefs: []
  type: TYPE_NORMAL
- en: The `component` tag uses the `is` prop to dynamically select which component
    will be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'To render a dynamic component, we use a `component` tag with a bound `is` property
    (here, we are using the shorthand `:is`, which is equivalent to `v-bind:is`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We will now learn how to render dynamic components using a name or component reference.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering Dynamic Components by Name or Component Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say we have a grid that contains items whose display can be toggled between
    a card display (a design element with an image and text) or an image-only view.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the relevant components and register them as components.
    We will also set some fixture data to loop through for the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then reference the components by name – that is, `card` and `image-entry`
    – and set `itemComponent` as the value for `is`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `Card` component will render since we are passing its lowercased
    name (`card`) to the `component` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we turned `itemComponent` into `image-entry`, the `ImageEntry` component
    would render. This switch can be made as follows using `v-model`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also pass components to `is` using the component reference itself (instead
    of the name). For example, we could set `itemComponent` to `Card`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In this case, switching between card and image views would be more difficult
    since we would need to use component references instead of using names.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pass props to components that have been dynamically rendered with `component`
    as we would pass regular props either with `v-bind:prop-name` or the `:prop-name`
    shorthand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Given the following `Card` and `ImageEntry` components, we get an application
    that has toggleable views for grid items.
  prefs: []
  type: TYPE_NORMAL
- en: '`Card.vue` renders the image and the title and has a `150px` maximum width:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output will display the entries in card view, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: Grid rendering entries in card view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_05_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.12: Grid rendering entries in card view'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `ImageEntry.vue` to render only the image at double the width of the card view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You will now see the entries in an image view, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13: Grid rendering entries in an image view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_05_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.13: Grid rendering entries in an image view'
  prefs: []
  type: TYPE_NORMAL
- en: A caveat of the `component` tag is that the rendered dynamic component gets
    completely torn down when it is not displayed anymore. In this example, the dynamic
    components being rendered do not have any state, so this teardown does not create
    any issues.
  prefs: []
  type: TYPE_NORMAL
- en: We will now learn how a dynamic component state is cached.
  prefs: []
  type: TYPE_NORMAL
- en: Caching a Dynamic Component State with Keep-Alive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Components that are dynamically rendered through the `component` tag can have
    state, such as in a multipart form, with a `name` field and an `address` field
    on the next page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement this with a `component` tag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, we can enter data in the `Name` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14: My name is entered in the name field'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_05_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.14: My name is entered in the name field'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we navigate, using `Next`, (to the address part of the form) and then `Back`,
    the name will disappear, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15: Empty name field upon clicking Next and then Back in the address
    step'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_05_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.15: Empty name field upon clicking Next and then Back in the address
    step'
  prefs: []
  type: TYPE_NORMAL
- en: This is due to the component being torn down (destroyed) when it is not the
    currently rendered dynamic component.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, we can use the `keep-alive` element around the `component` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In this manner, filling out the name and going `Back` from the address section
    of the form shows the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16: My name is is still the value in the Name field after navigation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_05_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.16: My name is is still the value in the Name field after navigation'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have learned how to use the `component` tag to denote an area
    within which we can dynamically display a component based on a string or the component
    itself (as imported). We have also explored how to work around the main gotcha
    of `component`; namely, how to use `keep-alive` to maintain component state when
    it is not the component being actively used in the `component` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.03: Creating a Dynamic Card Layout with the component Tag'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A modern application layout is a grid with cards. `Card` layouts have the benefit
    of being well-suited to mobile, desktop, and tablet displays. In this exercise,
    we will create a dynamic `card` layout with three different modes and a way to
    select between the three of them. This layout will allow the user to select how
    much information is displayed on the screen to suit their preference.
  prefs: []
  type: TYPE_NORMAL
- en: The `Rich` view will display all the details for an item, including the image,
    the title, and the description.
  prefs: []
  type: TYPE_NORMAL
- en: The `Compressed` view will display all the details but not the image preview.
  prefs: []
  type: TYPE_NORMAL
- en: The `List` view will only display the title and should be a vertical layout.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the `card` views will be implemented as a separate component that will
    then be dynamically rendered using the `component` tag. To access the code files
    for this exercise, refer to [https://packt.live/3mYYvkq](https://packt.live/3mYYvkq).
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the rich layout at `src/components/Rich.vue`. It contains three props
    called `url` (the image URL), `title`, and `description` and renders the image,
    the title, and the description, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up `src/App.vue` with some fixture data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the `Rich` view component into `src/App.vue` and register it locally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have got the `Rich` view component, wire it into the application in
    `src/App.vue`, render it with `component`, and pass the relevant props through:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is a good point to add a bit of styling to make the grid look like a grid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This displays the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.17: Rich component rendering dynamically'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_05_17.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.17: Rich component rendering dynamically'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, implement the `Compressed` view, which is just the `Rich` view without
    the image in the `Compressed.vue` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import and register the `Compressed` component in `src/App.vue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `select` to switch between views. It will have two options with values
    for `rich` and `compressed` and will be bound to `layout` using `v-model`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using this `select`, we can switch to the `compressed` layout, which looks
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.18: Compressed layout with select open'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_05_18.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.18: Compressed layout with select open'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `List` layout to `src/components/List.vue`. The `list` view is the
    compressed view but without the description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the `List` component into `src/App.vue` and register it locally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an extra option with `value="list"` to switch to the `List` layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When switching to the `list` layout, the items are displayed in a horizontal
    row, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.19: List view with incorrect horizontal stacking'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_05_19.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.19: List view with incorrect horizontal stacking'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To fix this horizontal stacking, create a new `grid-column` class that sets
    `flex-direction: column` (as opposed to `row`, which is the default) and conditionally
    applies it when the layout is `list`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our `List` layout now looks as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.20: List view with vertical stacking'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_05_20.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.20: List view with vertical stacking'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have learned how to use the `component` tag to dynamically render
    different components both by name and by using the component object itself. We
    have also explored the pitfalls of stateful dynamic components, namely the teardown
    of components when they are not displayed anymore and how to circumvent them using
    the `keep-alive` element.
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at how simple components can be implemented using only a `render`
    function or `template` tag using functional components.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional components are a subset of regular Vue.js components. They do not
    have state or a component instance. They can be thought of as `render` functions
    (as shown earlier in this chapter) to which props are passed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We can mark components as functional, which means that they are stateless (no
    reactive data) and instance-less (no `this` context).
  prefs: []
  type: TYPE_NORMAL
- en: See the Vue.js documentation for more ([https://vuejs.org/v2/guide/render-function.html#Functional-Components](https://vuejs.org/v2/guide/render-function.html#Functional-Components)).
  prefs: []
  type: TYPE_NORMAL
- en: Functional components can only access props, children, slots, and scoped slots,
    as passed from their parent component. They also receive references to **parents**
    and **listeners**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a `Greet` component (in the `Greet.vue` file). Note the `functional`
    annotation in `template`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Functional components must access props through `props.propName`. Functional
    components can also be denoted by the `functional: true` Boolean and be used with
    a `render` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use both these functional components in the `App.vue` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This renders the following to the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21: Functional component rendering'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_05_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.21: Functional component rendering'
  prefs: []
  type: TYPE_NORMAL
- en: Functional components are a great way to encapsulate functionality that is render-only;
    that is, they derive their templates from props. They have a slightly better performance
    profile than regular components since they do not have any associated reactive
    state or a component instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common use case we have covered for non-functional components is emitting
    events, which can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: To emit an event with a functional component, we can bind elements to properties
    in the `listeners` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To delegate all events to a child, we can use `v-on="listeners"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To bind a specific listener, we can use `v-on:eventName="listeners.listenerName"`,
    where `listenerName` is the listener that the parent of the functional component
    is bound to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Binding to a listener property that does not exist will result in an error.
    To avoid this, we can use the `listeners.listenerName || (() => {})` expression.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have learned how to implement common Vue.js component patterns
    using functional components with both the `.vue` component `template` variant
    and `render` functions.
  prefs: []
  type: TYPE_NORMAL
- en: We will now build a to-do application that uses all the patterns we have looked
    at throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 5.01: Building a Vue.js Application with Plugins and Reusable Components'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we will build a `jsonplaceholder` as a data source.
  prefs: []
  type: TYPE_NORMAL
- en: Our to-do app will load todos and display them as a list. It will display a
    checkbox based on whether the to-do has been completed, as well as the name of
    the to-do.
  prefs: []
  type: TYPE_NORMAL
- en: When checking off a to-do, the application will sync it to the API.
  prefs: []
  type: TYPE_NORMAL
- en: We will inject `axios` as a plugin to query against [https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Install `axios` into the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To inject `axios` as a property into `this` component instances, create a `src/plugins/axios.js`
    plugin file that, on `install`, will mean component instances have an `axios`
    property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the plugin to work, import and register it in `src/main.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also want to inject our API's `baseUrl` into all our components. We will
    create a plugin inline of the `src/main.js` file to do this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now want to fetch all the to-dos from our `src/App.vue`. A good place to
    do this is in the `mounted` life cycle method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To display the to-do list, we will create a `TodoList` functional component
    in `src/components/TodoList.vue` that takes a `todos` prop, loops through the
    items, and defers rendering of the to-do under a `todo` scoped slot that binds
    the to-do.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can now use the `TodoList` component to render out the todos we have already
    fetched in `src/App.vue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now need to create a `TodoEntry` component where we will implement most of
    the to-do-specific logic. A good practice for components is to have the props
    be very specific to the component's role. In this case, the properties of the
    `todo` object we will tackle are `id`, `title`, and `completed`, so those should
    be the props that our `TodoEntry` component receives. We will not make `TodoEntry`
    a functional component since we will need a component instance to create HTTP
    requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will then update `src/App.vue` so that it consumes `TodoEntry` (making sure
    to bind `id`, `title`, and `completed`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the ability to toggle the `todo`. We will implement the majority of this
    in `src/components/TodoEntry.vue`. We will listen to the `input` change event.
    On change, we will want to read the new value and send a `PATCH` request to `/todos/{todoId}`
    with an object containing `completed` set to the new value. We will also want
    to emit a `completedChange` event in Vue.js so that the `App` component can update
    the data that's in-memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `App.vue`, we will want to update the relevant `todo` when `completeChange`
    is triggered. Since `completeChange` does not include the ID of the `todo`, we
    will need to read that from the context when setting the `handleCompleteChange`
    function to listen to `completeChange`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22: Our to-do app using jsonplaceholder data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_05_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.22: Our to-do app using jsonplaceholder data'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor389).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we have looked at global composition patterns and advanced
    component setups that can be used to reduce duplication throughout a Vue.js application.
  prefs: []
  type: TYPE_NORMAL
- en: First, we learned about mixins, which explicitly share functionality while letting
    components have the last say and saw the exceptions to this rule. We then saw
    how plugins are a great hook into multiple Vue.js primitives.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked at how prescriptive patterns maximize component reusability
    in Vue.js. Ideas such as leveraging props to delegate data, slots to delegate
    templates, and implementing interfaces that allow components to be used with Vue-idiomatic
    shorthand such as `v-model` were shown.
  prefs: []
  type: TYPE_NORMAL
- en: We also took an in-depth look at what Vue.js components are beyond `.vue` files.
    We delved into what a Vue.js component is by introducing string templates, `render`
    functions, and JSX, as well as the requirements for each of these approaches to
    work. The `component` tag and `keep-alive` showed another approach to dynamically
    rendering components in Vue.js applications based on reactive data. Finally, we
    saw how functional components cement how we can define components with `.vue`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned how to build applications in terms of components, mixins,
    and plugins. To build applications that span multiple pages, we need to implement
    routing. This is what we will tackle in the next chapter.
  prefs: []
  type: TYPE_NORMAL
