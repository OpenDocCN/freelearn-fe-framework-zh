- en: Angular Directives in Depth
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解 Angular 指令
- en: '**Directives** are everywhere. They are the fundamental building blocks of
    Angular. Each extension to the application has resulted in us creating new **component
    directives**. These component directives have further consumed **attribute directives**
    (such as `NgClass` and `NgStyle`) and **structural directives** (such as `NgIf`
    and `NgFor`) to extend their behavior.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**指令** 始终随处可见。它们是 Angular 的基本构建块。每个应用程序的扩展都导致我们创建新的 **组件指令**。这些组件指令进一步使用了 **属性指令**（如`NgClass`和
    `NgStyle`）和 **结构指令**（如`NgIf`和 `NgFor`）来扩展其行为。'
- en: While we have built a number of component directives and a lone attribute directive,
    there are still some concepts of directive building that are worth exploring.
    This is especially true for attribute and structural directives, which we are
    yet to cover in detail.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经构建了许多组件指令和一个单独的属性指令，但仍有一些值得探索的指令构建概念。特别是对于属性和结构指令，我们尚未详细介绍。
- en: 'The topics we will cover in this chapter include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: '**Building directives**: We build multiple directives and learn where directives
    are useful, how they differ from components, and how directives communicate with
    each other and/or their host component. We explore all directive types, including
    *component directives*, *attribute directives*, and *structural directives*.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建指令**：我们构建多个指令，并学习指令的有用之处，它们与组件的区别，以及指令如何相互通信和/或与它们的宿主组件通信。我们探讨包括*组件指令*、*属性指令*和*结构指令*在内的所有指令类型。'
- en: '**Asynchronous validation**: Angular makes it easy to validate rules that require
    server interaction and hence are async in nature. We will build our first async
    validator in this chapter.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步验证**：Angular 可以轻松验证需要服务器交互和因此是异步的规则。在本章中，我们将构建我们的第一个异步验证器。'
- en: '**Using renderer for view manipulation**: Renderer allows view manipulation
    in a platform-agnostic way. We will utilize renderer for the busy indicator directive
    and learn about its API.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用渲染器进行视图操作**：渲染器允许以与平台无关的方式进行视图操作。我们将利用渲染器来实现繁忙指示器指令，并学习其 API。'
- en: '**Host binding**: Host binding allows directives to communicate with their
    *host element*. This chapter covers how to utilize such bindings for directives.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宿主绑定**：宿主绑定允许指令与其*宿主元素*进行通信。本章将涵盖如何利用这样的绑定来进行指令。'
- en: '**Directive injection**: The Angular DI framework allows directive injection
    based on where in the HTML hierarchy the directives are declared. We will cover
    multiple scenarios pertaining to such injections.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指令注入**：Angular DI 框架允许基于指令在 HTML 层次结构中的声明位置进行指令注入。我们将介绍与此类注入相关的多种情景。'
- en: '**Working with view children and content children**: Components have the capability
    to include external view templates into their own view. How to work with the injected
    content is something we will cover here.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用视图子和内容子**：组件具有将外部视图模板包含到其自身视图中的能力。我们将介绍如何处理注入的内容。'
- en: '**Understanding the NgIf platform directive**: We will look under the hood
    of the `NgIf` platform directive and try to comprehend the working of *structural
    directives* such as `NgIf`.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解 NgIf 平台指令**：我们将深入了解`NgIf`平台指令的内部工作，并尝试理解*结构指令*（如`NgIf`）的工作方式。'
- en: '**View encapsulation of Angular components**: We will learn how Angular uses
    concepts derived from *web components* to support view and style encapsulation.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular 组件的视图封装**：我们将学习 Angular 如何使用来自*Web 组件*的概念来支持视图和样式的封装。'
- en: Building a remote validator directive
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建远程验证器指令
- en: We ended [Chapter 3](cba52e86-29c5-4c51-a34f-5db71de16503.xhtml), *Supporting
    Server Data Persistence*, with *Workout Runner* capable of managing workouts in
    the MongoDB store. Since each workout should have a unique name, we need to enforce
    the uniqueness constraint. Therefore, while creating/editing a workout, every
    time the user changes the workout name, we can query MongoDB to verify that the
    name already exists.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以*支持服务器数据持久性*的[第3章](cba52e86-29c5-4c51-a34f-5db71de16503.xhtml) 结束了 *Workout
    Runner* 能够在 MongoDB 存储中管理锻炼。由于每个锻炼都应具有唯一名称，我们需要执行唯一性约束。因此，在创建/编辑锻炼时，每当用户更改锻炼名称时，我们可以查询
    MongoDB 来验证该名称是否已存在。
- en: As is the case with any remote invocation, this check is asynchronous, and hence
    it requires a *remote validator*. We are going to build this remote validator
    using Angular's *async validator support*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何远程调用一样，这个检查是异步进行的，因此需要一个 *远程验证器*。我们将使用 Angular 的 *异步验证器支持* 来构建这个远程验证器。
- en: '**Async validators** are similar to standard custom validators, except that
    instead of returning a key-value object map or null, the return value of a validation
    check is a **promise**. This promise is eventually resolved with the validation
    state being set (if there is an error), or null otherwise (on validation success).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步验证器**与标准自定义验证器类似，只是返回的不是键-值对象映射或 null，而是一个**promise**。这个promise最终将根据验证状态进行解析（如果有错误，则设置为相应状态），如果验证成功，则返回
    null。'
- en: 'We are going to create a validation directive that does workout name checks.
    There are two possible implementation approaches for such a directive:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个验证指令，用于进行工作名称检查。针对这样的指令，有两种可能的实现方法：
- en: We can create a directive specifically for unique name validation
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以专门为唯一名称验证创建一个指令
- en: We can create a generic directive that can perform any remote validation
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个通用指令，可以执行任何远程验证。
- en: Validation directives
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 验证指令
- en: While we are building a validation directive here, we could have built a standard
    custom validator class. The advantage of creating a directive is that it allows
    us to incorporate the directive in a template-driven form approach, where the
    directive can be embedded in the view HTML. Or, if the form has been generated
    using a model (reactive approach), we can directly use the validator class while
    creating the `Control` objects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们正在构建一个验证指令，但我们也可以构建一个标准的自定义验证器类。创建指令的优势在于它可以让我们将指令嵌入到模板驱动的表单中，在视图HTML中使用指令。或者，如果表单是使用模型（响应式方法）生成的，我们可以在创建`Control`对象时直接使用验证器类。
- en: At first, the requirement of checking duplicate names against a data source
    (the *mLab* database) seems to be too a specific requirement and cannot be handled
    by a generic validator. But with some sensible assumptions and design choices,
    we can still implement a validator that can handle all types of remote validation,
    including workout name validation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，针对数据源（*mLab*数据库）检查重复名称的要求似乎是一个过于具体的要求，无法通过通用验证器来处理。但通过一些明智的假设和设计选择，我们仍然可以实现一个能够处理所有类型远程验证的验证器，包括工作名称验证。
- en: The plan is to create a validator that externalizes the actual validation logic.
    The directive will take the validation function as input. This implies that the
    actual validation logic is not a part of the validator, but a part of the component
    that actually needs to validate input data. The job of the directive is just to
    call the function and return the appropriate error keys based on the function's
    return value.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 计划是创建一个外部化实际验证逻辑的验证器。该指令将以验证函数作为输入。这意味着实际验证逻辑不是验证器的一部分，而是实际需要验证输入数据的组件的一部分。指令的工作仅是调用函数并根据函数的返回值返回相应的错误键。
- en: Let's put this theory into practice and build our remote validation directive,
    aptly named `RemoteValidatorDirective`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个理论付诸实践，构建我们的远程验证指令，恰如其名的`RemoteValidatorDirective`。
- en: The companion code base for the following section is Git branch `checkpoint6.1`.
    You can work along with us or check out the implementation available in the aforementioned
    folder. Or if you are not using Git, download the snapshot of `checkpoint6.1`
    (a ZIP file) from GitHub location [http://bit.ly/ng2be-checkpoint6-1](http://bit.ly/ng2be-checkpoint6-1).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分的伴随代码基于 Git 分支`checkpoint6.1`。您可以与我们一起工作，或者查看上述文件夹中提供的实现。或者，如果您不使用Git，可以从GitHub位置[http://bit.ly/ng2be-checkpoint6-1](http://bit.ly/ng2be-checkpoint6-1)下载`checkpoint6.1`的快照（ZIP文件）。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Validating workout names using async validators
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步验证器验证工作名称
- en: Like custom validators, async validators inherit from the same `Validator` class
    too; but this time, instead of returning an object map, async validators return
    a `Promise`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与自定义验证器类似，异步验证器也继承自相同的`Validator`类；但这次，异步验证器返回一个`Promise`而不是对象映射。
- en: 'Let''s look at the definition of the validator. Copy the definition of the
    validator from the GitHub ([http://bit.ly/ng6be-6-1-remote-validator-directive-ts](http://bit.ly/ng6be-6-1-remote-validator-directive-ts))
    folder and add it to the `shared` module folder. The validator definition looks
    as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看验证器的定义。从 GitHub（[http://bit.ly/ng6be-6-1-remote-validator-directive-ts](http://bit.ly/ng6be-6-1-remote-validator-directive-ts)）文件夹中复制验证器的定义，并将其添加到`shared`模块文件夹。验证器的定义如下：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Do remember to export this directive from the shared module, allowing us to
    use it in the workout builder module.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 切记要从共享模块导出这个指令，以便我们可以在锻炼构建器模块中使用它。
- en: 'Since we are registering the validator as a directive instead of registering
    using a `FormControl` instance (generally used when building forms with a *reactive
    approach*), we need the extra provider configuration setting (added in the preceding
    `@Directive` metadata) by using this syntax:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将验证器注册为指令，而不是使用 `FormControl` 实例进行注册（通常用于以*响应式方式*构建表单时），我们需要额外的提供者配置设置（在前述`@Directive`元数据中添加）,通过以下语法：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This statement registers the validator with the existing async validators.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句将验证器注册到现有的异步验证器中。
- en: 'The strange directive selector, `selector: `[abeRemoteValidator][ngModel]``,
    used in the preceding code will be covered in the next section, where we will
    build a busy indicator directive.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '在接下来的部分中，我们将构建一个繁忙指示器指令，解释在前述代码中使用的奇怪的指令选择器`selector: `[abeRemoteValidator][ngModel]`。'
- en: Before we dig into the validator implementation, let's add it to the workout
    name input. This will help us correlate the behavior of the validator with its
    usage.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究验证器实现之前，让我们将其添加到锻炼名称输入中。这将帮助我们将验证器的行为与其使用联系起来。
- en: 'Update the workout name input (`workout.component.html`) with the validator
    declaration:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 用验证器声明更新锻炼名称输入（`workout.component.html`）：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Prefixing the directive selector
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为指令选择器添加前缀
- en: Always prefix your directives with an identifier (`abe` as you just saw) that
    distinguishes them from framework directives and other third-party directives.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用一个标识符（正如你刚刚看到的`abe`）作为你的指令前缀，以将其与框架指令和其他第三方指令区分开来。
- en: '**Note**: If the `ngModelOptions`, `updateOn` is set to `submit,` change it
    to `blur`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：如果 `ngModelOptions`，`updateOn` 设置为 `submit,`，则更改为 `blur`。'
- en: 'The directive implementation takes two inputs: the *validation key* through
    directive property `abeRemoveValidator,` used to set the *error key*, and the
    *validation function* (`validateFunction`), called to validate the value of the
    control. Both inputs are annotated with the `@Input` decorator.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 指令实现通过指令属性`abeRemoveValidator`接受两个输入：*validation key*，用于设置*error key*，和*validation
    function*（`validateFunction`），用于验证控件的值。这两个输入都用`@Input`装饰器进行了注解。
- en: 'The input parameter `@Input("validateFunction") validateFunction: (value: string)
    => Promise<boolean>;`, binds to a function, not a standard component property.
    We are allowed to treat the function as a property due to the nature of the underlying
    language, TypeScript (as well as JavaScript).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '输入参数`@Input("validateFunction") validateFunction: (value: string) => Promise<boolean>;`，绑定到一个函数，而不是标准的组件属性。由于底层语言TypeScript的性质（以及JavaScript），我们可以把这个函数当作属性对待。'
- en: 'When the async validation fires (on a change of `input`), Angular invokes the
    function, passing in the underlying `control`. As the first step, we pull the
    current input value and then invoke the `validateFunction` function with this
    input. The `validateFunction` returns a promise, which should eventually resolve
    to `true` or `false`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当异步验证触发（输入更改时），Angular调用该函数，并传入基础的`control`。作为第一步，我们提取当前的输入值，然后使用该输入调用 `validateFunction`
    函数。`validateFunction` 返回一个promise，最终应该解析为 `true` 或 `false`：
- en: If the promise resolves to `true`, the validation is successful, the promise
    callback function returns `null`.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果promise解析为`true`，则验证成功，promise回调函数返回`null`。
- en: If it is `false`, the validation has failed, and an error key-value map is returned.
    The *key* here is the string literal that we set when using the validator (`a2beRemoteValidator="workoutname"`).
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是 `false`，则验证失败，返回一个错误键值映射。这里的*key*是我们在使用验证器时设置的字符串字面量（`a2beRemoteValidator="workoutname"`）。
- en: This *key* comes in handy when there are multiple validators declared on the
    input, allowing us to identify validations that have failed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*key*在输入上有多个验证器声明时非常有用，可以帮助我们识别失败的验证。
- en: 'To the workout component next add a validation message for this failure too.
    Add this label declaration after the existing validation `label` for *workout
    name*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来在锻炼组件中为这个失败添加一个验证消息。在现有的*workout name*的验证`label`后添加此标签声明：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: And then wrap these two labels inside a `div`, as we do for *workout title*
    error labels.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将这两个标签包裹在 `div` 中，就像我们为*workout title*错误标签做的那样。
- en: The `hasError` function checks whether the `'workoutname'` validation key is
    present.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasError` 函数检查`''workoutname''`验证键是否存在。'
- en: The last missing piece of this implementation is the actual validation function
    we assigned when applying the directive (`[validateFunction]="**validateWorkoutName**"`),
    but never implemented.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现缺少的最后一部分是我们在应用指令时分配的实际验证函数（`[validateFunction]="**validateWorkoutName**""`），但尚未实现。
- en: 'Add the `validateWorkoutName` function to `workout.component.ts`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `validateWorkoutName` 函数添加到 `workout.component.ts` 中。
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Before we explore what the preceding function does, we need to do some more
    fixes on the `WorkoutComponent` class. The `validateWorkoutName` function is dependent
    on `WorkoutService` to get a workout with a specific name. Let''s inject the service
    in the constructor and add the necessary import in the imports section:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索前面的函数功能之前，我们需要对 `WorkoutComponent` 类进行一些其他修复。`validateWorkoutName` 函数依赖于
    `WorkoutService` 来获取具有特定名称的训练计划。让我们在构造函数中注入该服务，并在导入部分添加必要的导入。
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then declare variables `workoutName` and `queryParamsSub`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后声明 `workoutName` 和 `queryParamsSub` 变量。
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And add this statement to `ngOnInit`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 并在 `ngOnInit` 中添加这个语句。
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding statement set the current workout name by watching (subscribing)
    over the observable `route.params` service. `workoutName` is used to skip workout
    name validation for an existing workout if the original workout name is used.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 前述语句通过观察（订阅）`route.params` 服务的 observable 来设置当前的训练计划名称。`workoutName` 用于在使用原始训练计划名称时跳过训练计划名称验证。
- en: 'The subscription created previously needs to be clear to avoid memory leak,
    hence add this line to the `ngDestroy` function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之前创建的订阅需要清除以避免内存泄漏，因此将此行添加到 `ngDestroy` 函数中。
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The reason for defining the `validateWorkoutName` function as an *instance function*
    (the use of the *arrow operator*) instead of defining it as a standard function
    (which declares the function on the *prototype*) is the `'this'` scoping issue.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `validateWorkoutName` 函数定义为*实例函数*（使用*箭头运算符*）而不是标准函数（在*原型*上声明函数）的原因是 `'this'`
    作用域问题。
- en: 'Look at the validator function invocation inside `RemoteValidatorDirective`
    (declared using `@Input("validateFunction") validateFunction;`):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `RemoteValidatorDirective` 中 `validateFunction` 指令的验证器函数调用（使用 `@Input("validateFunction")
    validateFunction;` 进行声明）。
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When the function (named `validateFunction`) is invoked, the `this` reference
    is bound to `RemoteValidatorDirective` instead of the `WorkoutComponent`. Since
    `execute` is referencing the `validateWorkoutName` function in the preceding setup,
    any access to `this` inside `validateWorkoutName` is problematic.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数（名为 `validateFunction`）被调用时，`this` 引用被绑定到 `RemoteValidatorDirective`，而不是
    `WorkoutComponent`。由于 `execute` 在前述设置中引用了 `validateWorkoutName` 函数，所以内部对 `this`
    的任何访问都会有问题。
- en: This causes the `if (this.workoutName === name)` statement inside `validateWorkoutName`
    to fail, as `RemoteValiatorDirective` does not have a `workoutName` instance member.
    By defining `validateWorkoutName` as an instance function, the *TypeScript* compiler
    *creates a closure* around the value of `this` when the function is defined.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致 `validateWorkoutName` 内部的 `if (this.workoutName === name)` 语句失败，因为 `RemoteValiatorDirective`
    没有 `workoutName` 实例成员。通过将 `validateWorkoutName` 定义为实例函数，TypeScript 编译器在函数定义时*创建了一个闭包*，捕获了
    `this` 的值。
- en: With the new declaration, `this` inside `validateWorkoutName` always points
    to the `WorkoutComponent` irrespective of how the function gets invoked.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过新的声明，`validateWorkoutName` 内部的 `this` 始终指向 `WorkoutComponent`，不管函数是如何被调用的。
- en: 'We can also look at the compiled JavaScript for `WorkoutComponent` to know
    how the closure works with respect to `validateWorkoutName`. The parts of the
    generated code that interest us are as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以查看 `WorkoutComponent` 的编译后的 JavaScript 代码，了解闭包是如何与 `validateWorkoutName`
    一起工作的。我们关注的生成代码部分如下：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If we look at the validation function implementation, we see that it involves
    querying *mLab* for a specific workout name. The `validateWorkoutName` function
    returns `true` when a workout with the same name is not found and `false` when
    a workout with the same name is found (actually a *promise* is returned).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看验证函数的实现，我们会发现它涉及查询 *mLab* 以获取特定的训练计划名称。`validateWorkoutName` 函数在未找到同名训练计划时返回
    `true`，在找到同名训练计划时返回 `false`（实际上返回的是一个*promise*）。
- en: The `getWorkout` function on `WorkoutService` returns an *observable,* but we
    convert it into a *promise* by calling the `toPromise` function on the observable.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutService` 上的 `getWorkout` 函数返回一个*observable*，但我们通过调用 observable 上的 `toPromise`
    函数将其转换为一个*promise*。'
- en: 'The validation directive can now be tested. Create a new workout and enter
    an existing workout name such as `7minworkout`. See how the validation error message
    shows up eventually:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以测试验证指令了。创建一个新的训练，并输入一个已有的训练名称，如`7minworkout`。看看验证错误消息是如何最终显示出来的：
- en: '![](img/3f7be3d2-984e-406c-858c-02aca3b262ce.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f7be3d2-984e-406c-858c-02aca3b262ce.png)'
- en: Excellent! It looks great, but there is still something missing. The user is
    not informed that we are validating the workout name. We can improve this experience.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！看起来很不错，但仍然缺少一些东西。用户并不知道我们正在验证训练名称。我们可以改善这个体验。
- en: Building a busy indicator directive
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个忙碌指示器指令
- en: While the workout name is being validated remotely, we want the user to be aware
    of the activity in the background. A visual clue around the input box while the
    remote validation happens should serve the purpose.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当远程验证训练名称时，我们希望用户意识到后台的活动。在远程验证发生时围绕输入框提供视觉线索应该能达到目的。
- en: Think carefully; there is an input box with an asynchronous validator (which
    does remote validation) and we want to adorn the input box with a visual clue
    during validation. Seems like a common pattern to solve? Indeed it is, so let's
    create another directive!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细思考一下；有一个带有异步验证器（执行远程验证）的输入框，我们想要在验证期间用一个视觉线索装饰输入框。看起来像一个常见的解决模式？的确如此，所以让我们创建另一个指令！
- en: 'But before we start the implementation, it is imperative to understand that
    we are not in it alone. The busy indicator directive requires the help of another
    directive, `NgModel`. We have already used the `NgModel` directive on `input`
    elements in Chapter 2, *Personal Trainer*. `NgModel` helps us track the input
    element state. The following example is taken from [Chapter 2](4b0ad450-2a56-4c24-b431-116d7225a57e.xhtml),
    *Personal Trainer*, and it highlights how `NgModel` helps us validate inputs:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们开始实施之前，必须明确理解我们并不孤军奋战。忙碌指示器指令需要另一个指令`NgModel`的帮助。我们已经在第2章*个人教练*中的`input`元素上使用了`NgModel`指令。`NgModel`帮助我们跟踪输入元素的状态。以下示例取自[第2章](4b0ad450-2a56-4c24-b431-116d7225a57e.xhtml)《个人教练》，突出了`NgModel`如何帮助我们验证输入：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Even the unique workout name validation done in the previous section employs
    the same technique of using `NgModel` to check the validation state.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在上一部分中完成了唯一的训练名称验证，也是使用了相同的`NgModel`技术来检查验证状态。
- en: 'Let''s begin with defining the outline of the directive. Create a `busy-indicator.directive.ts`
    file using the CLI generator in the `src/app/shared` folder:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义指令的概要开始。在`src/app/shared`文件夹中使用CLI生成器创建一个`busy-indicator.directive.ts`文件：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Also, export it by adding the directive to the `exports` array in the shared
    module file `shared.module.ts`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，通过将指令添加到共享模块文件`shared.module.ts`中的`exports`数组中导出它。
- en: 'Next, update the directive''s constructor with `NgModel` injection and import
    the `NgModel` reference from `@angular/forms`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`NgModel`注入来更新指令的构造函数，并从`@angular/forms`中导入`NgModel`引用：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This instructs Angular to inject the `NgModel` instance of the element on which
    the directive is declared. Remember that the `NgModel` directive is already present
    on `input` (`workoutname`):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Angular要对声明指令的元素注入`NgModel`实例。记住，`NgModel`指令已经存在于`input`（`workoutname`）上了：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is enough to integrate our new directive in the workout view, so let's
    do it quickly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经足够将我们的新指令集成到训练视图中了，让我们快速做吧。
- en: 'Open `workout.component.html` from `workout-builder` and add the busy indicator
    directive to the workout name `input`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`workout-builder`中的`workout.component.html`，并在训练名称`input`中添加忙碌指示器指令：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Create a new workout or open an existing one to see whether the `BusyIndicatorDirective`
    is loaded and the `NgModel` injection worked fine. This can be easily verified
    by putting a breakpoint inside the `BusyIndicatorDirective` constructor.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的训练或打开一个现有的训练，查看`BusyIndicatorDirective`是否已加载并且`NgModel`注入是否正常工作。这可以通过在`BusyIndicatorDirective`构造函数内设置断点来轻松验证。
- en: Angular injects the same `NgModel` instance into `BusyIndicatorDirective` that
    it created when it encountered `ngModel` on the input HTML.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Angular将相同的`NgModel`实例注入到`BusyIndicatorDirective`中，就像在输入HTML中遇到`ngModel`时创建的那样。
- en: 'You may be wondering what happens if we apply this directive on an input element
    that does not have the `ngModel` attribute, or as a matter of fact on any HTML
    element/component, such as this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想知道，如果我们将这个指令应用于没有`ngModel`属性的输入元素，或者实际上任何HTML元素/组件，会发生什么，例如这样：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Will the injection work?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注射会起作用吗？
- en: 'Of course not! We can try it in the create workout view. Open `workout.component.html`
    and add the following `input` above the workout name `input`. Refresh the app:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当然不是！我们可以在创建锻炼视图中试一下。打开`workout.component.html`，并在锻炼名称`input`上面添加以下`input`。刷新应用：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Angular throws an exception, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Angular抛出一个异常，如下所示：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How to avoid this? Well, Angular's DI can rescue us here as it allows us to
    declare an optional dependency.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如何避免这个问题？嗯，Angular的DI可以在这里拯救我们，因为它允许我们声明一个可选的依赖关系。
- en: Remove the `input` control that you just added before proceeding further.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前删除刚刚添加的`input`控件。
- en: Injecting optional dependencies with the @Optional decorator
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用`@Optional`装饰器注入可选依赖项
- en: Angular has an `@Optional` decorator, which when applied to a constructor argument
    instructs the Angular *injector* to inject `null` if the dependency is not found.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Angular有一个`@Optional`装饰器，当应用于构造函数参数时，指示Angular *注入器*在找不到依赖项时注入`null`。
- en: 'Hence, the busy indicator constructor can be written as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，繁忙指示符构造函数可以写成如下所示：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Problem solved? Not really; as stated previously, we require the `NgModel` directive
    for `BusyIndicatorDirective` to work. So, while we have learned something new,
    it is not very useful in the current scenario.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 问题解决了吗？并没有；正如先前所述，我们需要`NgModel`指令使`BusyIndicatorDirective`起作用。因此，虽然我们学到了一些新知识，但在当前情况下并不是很有用。
- en: Before proceeding further, remember to revert the `workoutname``input` to its
    original state, with `abeBusyIndicator` applied.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请记得将`workoutname``input`还原为初始状态，应用`abeBusyIndicator`。
- en: '`BusyIndicatorDirective` should only be applied if there is an `NgModel` directive
    already present on the element.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在元素上已经存在`NgModel`指令时，才能应用`BusyIndicatorDirective`。
- en: 'The `selector` directive is going to save our day this time. Update the `BusyIndicatorDirective`
    selector to this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`selector`指令将会拯救我们。将`BusyIndicatorDirective`选择器更新为如下所示：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This selector creates the `BusyIndicatorDirective` only if the combination of
    `a2beBusyIndicator` with the `ngModel` attribute is present on the element. Problem
    solved!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素上同时存在`a2beBusyIndicator`和`ngModel`属性的组合，那么这个选择器将创建`BusyIndicatorDirective`。问题解决了！
- en: It's now time to add the actual implementation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加实际的实现了。
- en: Implementation one – using renderer
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一 - 使用渲染器
- en: 'For `BusyIndicatorDirective` to work, it needs to know when the async validation
    on the `input` fires and when it is over. This information is only available with
    the `NgModel` directive. `NgModel` has a property, `control`, which is an instance
    of the `Control` class. It is this `Control` class that tracks the current state
    of the input, including the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`BusyIndicatorDirective`起作用，它需要知道`input`上的异步验证何时触发以及何时结束。这些信息只能由`NgModel`指令提供。`NgModel`有一个`control`属性，它是`Control`类的一个实例。正是这个`Control`类跟踪输入的当前状态，包括以下内容：
- en: Currently assigned validators (sync and async)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前分配的验证器（同步和异步）
- en: The current value
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前值
- en: The input element state, such as `pristine`, `dirty`, and `touched`
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入元素的状态，比如`pristine`、`dirty`和`touched`
- en: The input validation state, which could be any one of `valid`, `invalid`, or
    `pending` in the case of validation being performed asynchronously
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入验证状态可能是`valid`、`invalid`或者在异步执行验证时是`pending`之一
- en: Events that track when the value changes or the validation state changes
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪数值变化或验证状态变化的事件
- en: '`Control` seems to be a useful class, and it''s the `pending` state that interests
    us!'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Control`看起来是一个很有用的类，它的`pending`状态引起了我们的兴趣！'
- en: 'Let''s add our first implement for the `BusyIndicatorDirective` class. Update
    the class with this code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`BusyIndicatorDirective`类添加第一个实现。用以下代码更新类：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Two new dependencies need to be added to the constructor, as we use them in
    the `ngAfterViewInit` function. Update the `BusyIndicatorDirective` constructor
    to look as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 需要向构造函数添加两个新的依赖项，因为我们在`ngAfterViewInit`函数中使用它们。将`BusyIndicatorDirective`构造函数更新如下：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: And also add imports for `ElementRef` and `Renderer` in `'@angular/core'`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要在`'@angular/core'`中导入`ElementRef`和`Renderer`。
- en: '`ElementRef` is a wrapper object over the underlying HTML element (`input`
    in this case). The `MyAudioDirective` directive used `ElementRef` to get hold
    of the underlying `Audio` element.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`ElementRef`是对底层HTML元素（在本例中是`input`）的包装对象。`MyAudioDirective`指令使用`ElementRef`来获取底层的`Audio`元素。'
- en: The `Renderer` injection deserves a bit of attention. Calling `setElementStyle`
    is a dead giveaway that `Renderer` is responsible for managing the DOM. But before
    we delve more deeply into the role of `Renderer`, let's try to understand what
    the preceding code is doing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Renderer` 注入值值得一提。调用 `setElementStyle` 很明显是 `Renderer` 负责管理 DOM 的标志。 但在更深入地了解
    `Renderer` 的角色之前，让我们尝试理解前面的代码在做什么。'
- en: In the preceding code, the `control` property on the model (the `NgModel` instance)
    defines an event (an `Observable`), `statusChanges`, which we can subscribe to
    in order to know when the control validation state changes. The available validation
    states are `valid`, `invalid`, and `pending`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，模型（`NgModel` 实例）上的 `control` 属性定义了一个事件（一个 `Observable`），`statusChanges`，我们可以订阅以了解控件验证状态何时更改。
    可用的验证状态是`valid`、`invalid` 和 `pending`。
- en: The subscription checks whether the control state is `pending` or not, and accordingly
    adorns the underlying element using the `Renderer` API function, `setElementStyle`.
    We set the `border-width` and `border-color` of the input.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅检查控件状态是否为`pending`，并相应地使用 `Renderer` API 函数 `setElementStyle` 装饰底层元素。 我们设置
    `input` 的 `border-width` 和 `border-color`。
- en: The preceding implementation is added to the `ngAfterViewInit` directive lifecycle
    hook, which is called after the view has initialized.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 前述的实现添加到 `ngAfterViewInit` 指令生命周期钩子中，该生命周期钩子在视图初始化后调用。
- en: Let's try it out. Open the create workout page or the existing *7 Minute Workout*.
    As soon as we leave workout name input, the `input` style changes and reverts
    once the remote validation of the workout name is complete. Nice!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试。打开创建锻炼页面或现有的 *7分钟锻炼*。 一旦我们离开锻炼名称输入，`input` 样式会更改，并在锻炼名称的远程验证完成后恢复。 好！
- en: '![](img/298a4f9b-ed8c-4e43-8f9d-b98633a24d68.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/298a4f9b-ed8c-4e43-8f9d-b98633a24d68.png)'
- en: 'Before moving forward, also add the un-subscription code to the `BusyIndicatorDirective`
    to avoid a memory leak. Add this function (life  cycle hook) to `BusyIndicatorDirective`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，还要将取消订阅代码添加到 `BusyIndicatorDirective` 中以避免内存泄漏。 将此函数（生命周期钩子）添加到 `BusyIndicatorDirective`
    中：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Always unsubscribe from observables
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 始终取消订阅 observables
- en: Always remember to unsubscribe from any `Observable`/`EventEmitter` subscription
    done in the code to avoid memory leaks.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要始终记住取消对代码中已完成的任何 `Observable`/`EventEmitter` 订阅，以避免内存泄漏。
- en: The implementation looks good. The `Renderer` is doing its job. But there are
    some unanswered questions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 实现看起来不错。`Renderer`正在发挥作用。但还有一些未解答的问题。
- en: Why not just get hold of the underlying DOM object and use the standard DOM
    API to manipulate the input styles? Why do we need the *renderer*?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接获取底层 DOM 对象并使用标准 DOM API 来操作输入样式？ 为什么我们需要 *renderer*？
- en: Angular renderer, the translation layer
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 渲染器，翻译层
- en: One of the primary design goals of Angular 2 was to make it run across environments,
    frameworks, and devices. Angular enabled this by dividing the core framework implementation
    into an **application layer** and a **rendering layer**. The application layer
    has the API we interact with, whereas the rendering layer provides an abstraction
    that the application layer can use without worrying about how and where the actual
    view is being rendered.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2 的主要设计目标之一是使其在各种环境、框架和设备上运行。 Angular 通过将核心框架实现分为**应用层**和**呈现层**来实现了这一目标。
    应用层具有我们交互的 API，而呈现层提供了一个抽象，应用层可以使用它而不必担心视图的实际渲染位置。
- en: 'By separating the rendering layer, Angular can theoretically run in various
    setups. These include (but are not limited to):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分离渲染层，Angular 理论上可以在各种设置中运行。其中包括（但不限于）：
- en: Browser
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器
- en: Browser main thread and web worker thread, for obvious performance reasons
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器主线程和网络工作线程，出于明显的性能原因
- en: Server-side rendering
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: Native app frameworks; efforts are underway to integrate Angular with `NativeScript`
    with `ReactNative`
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生应用程序框架；正在努力将 Angular 与 `NativeScript` 和 `ReactNative` 集成。
- en: Testing, allowing us to test the app UI outside the web browser
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试，允许我们在网络浏览器之外测试应用程序 UI
- en: The `Renderer` implementation that Angular uses inside our browser is `DOMRenderer`.
    It is responsible for translating our API calls into browser DOM updates. In fact,
    we can verify the renderer type by adding a breakpoint in the `BusyIndicatorDirective`'s
    constructor and seeing the value of `renderer`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 在浏览器中使用的 `Renderer` 实现是 `DOMRenderer`。 它负责将我们的 API 调用转换为浏览器 DOM 更新。
    实际上，我们可以通过在 `BusyIndicatorDirective` 的构造函数中添加断点并查看 `renderer` 的值来验证渲染器类型。
- en: 'For this precise reason, we avoid direct manipulation of DOM elements inside
    `BusyIndicatorDirective`. You never know where the code will end up running. We
    could have easily done this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 准确因此，我们避免在`BusyIndicatorDirective`内部直接操纵DOM元素。您永远不知道代码最终将在哪里运行。我们本来很容易就可以这样做：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Instead, we used the `Renderer` to do the same in a platform-agnostic way.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们使用了`Renderer`以平台无关的方式来做同样的事情。
- en: 'Look at the `Renderer` API function, `setElementStyle`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`Renderer`API函数，`setElementStyle`：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It takes the element on which the style has to be set, the style property to
    update, and the value to set. The `element` references the `input` element injected
    into `BusyIndicatorDirective`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受要设置样式的元素，要更新的样式属性和要设置的值。`element`引用了注入到`BusyIndicatorDirective`中的`input`元素。
- en: Resetting styles
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 重置样式
- en: Styles set by calling `setElementStyle` can be reset by passing a `null` value
    in the third argument. Check out the `else` condition in the preceding code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`setElementStyle`设置的样式可以通过在第三个参数中传递`null`值来重置。请查看前面代码中的`else`条件。
- en: The `Renderer` API has a number of other methods that can be used to set attributes,
    set properties, listen to events, and even create new views. Whenever you build
    a new directive, remember to evaluate the `Renderer` API for DOM manipulation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Renderer`API还有许多其他方法可用于设置属性、设置属性、监听事件，甚至创建新视图。每当您构建新指令时，请记得评估`Renderer`API以进行DOM操作。'
- en: 'A more detailed explanation of `Renderer` and its application is available
    as part of Angular''s design documents here: [http://bit.ly/ng2-render](http://bit.ly/ng2-render)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`Renderer`及其应用的更详细解释，请参阅 Angular 的设计文档的这里：[http://bit.ly/ng2-render](http://bit.ly/ng2-render)
- en: We are not done yet! With Angular's awesomeness, we can improve the implementation.
    Angular allows us to do *host binding* in directive implementation, helping us
    avoid a lot of boilerplate code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成！借助 Angular 的强大功能，我们可以改进此实现。Angular允许我们在指令实现中进行*主机绑定*，帮助我们避免大量样板代码。
- en: Host binding in directives
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令中的主机绑定
- en: In the Angular realm, the component/element that a directive gets attached to
    is termed the **host element**:a container that hosts our directive/component.
    For the `BusyIndicatorDirective`, the `input` element is the *host*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 领域，指令附加到的组件/元素被称为**宿主元素**：一个承载我们的指令/组件的容器。对于`BusyIndicatorDirective`，`input`元素就是*宿主*。
- en: While we can use the `Renderer` to manipulate the host (and we did too), the
    Angular data binding infrastructure can reduce the code further. It provides a
    declarative way to manage directive-host interaction. Using the host binding concepts,
    we can manipulate an element's *properties* and *attributes* and subscribe to
    its *events*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使用`Renderer`来操纵宿主（我们也是这样做的），但是 Angular 数据绑定基础设施可以进一步减少代码。它提供了一种声明性的方式来管理指令-宿主交互。使用主机绑定概念，我们可以操纵元素的*属性*和*属性*，并订阅其*事件*。
- en: Let's understand each of the host binding capabilities, and in the end, we will
    fix our `BusyIndicatorDirective` implementation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解每种主机绑定的能力，最后，我们将修复我们的`BusyIndicatorDirective`实现。
- en: Property binding using @HostBinding
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用@HostBinding进行属性绑定
- en: Use **host property binding** to bind a *directive property* to a *host element
    property*. Any changes to the directive property will be synced with the linked
    host property during the change detection phase.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**主机属性绑定**将*指令属性*绑定到*宿主元素属性*。在变更检测阶段，对指令属性的任何更改都将与链接的主机属性同步。
- en: 'We just need to use the `@HostBinding` decorator on the directive property
    that we want to sync with. For example, consider this binding:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在想要同步的指令属性上使用`@HostBinding`装饰器。例如，考虑这样的绑定：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When applied to `input`, it will set the `input``readOnly` property to `true`
    when the `isbusy` directive property is `true`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于`input`时，当`isbusy`指令属性为`true`时，它将将`input``readOnly`属性设置为`true`。
- en: Note that `readonly` is also an *attribute* on `input`. What we are referring
    to here is the input *property* `readOnly`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`readonly`也是`input`上的*属性*。这里指的是我们所说的输入*属性*`readOnly`。
- en: Attribute binding
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性绑定
- en: '**Attribute binding** binds a directive property to a host component attribute.
    For example, consider a directive with binding like the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性绑定**将指令属性绑定到宿主组件属性。例如，考虑具有以下绑定的指令：'
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If applied to input it will add the `disabled` attribute on `input` when the
    `isAdmin` flag is `false`, and clear it otherwise. We follow the same attribute
    binding notation used in the HTML template here too. The attribute name is prefixed
    with string literal `attr`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用于输入，当`isAdmin`标志为`false`时，它将在`input`上添加`disabled`属性，并在`isAdmin`为真时清除它。我们在这里也遵循HTML模板中使用的相同属性绑定符号。属性名称前缀为字符串字面量`attr`。
- en: 'We can do something similar with *class* and *style binding* too. Consider
    the following line:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用*class*和*style绑定*来做类似的事情。考虑以下行：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This line sets up a class binding, and the following line creates a style binding:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行设置了一个类绑定，下一行创建了一个样式绑定：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Event binding
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件绑定
- en: 'Lastly, **event binding** is used to subscribe to the events raised by the
    host component/element. Consider this example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**事件绑定**用于订阅宿主组件/元素引发的事件。考虑这个例子：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This sets up a listener on the host event `click`. Angular will instantiate
    the preceding directive for every *button*, *div*, *span*, and *input* on the
    view and set up the host binding with the `onClick` function. The `$event` variable
    contains the event data for the event raised, and `target` refers to the element/component
    that was clicked on.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这在宿主事件`click`上建立了一个监听器。Angular将为视图上的每个*button*、*div*、*span*和*input*实例化前述指令，并为`onClick`函数设置宿主绑定。`$event`变量包含引发的事件数据，`target`指的是所点击的元素/组件。
- en: 'Event bindings work for components too. Consider the following example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 事件绑定也适用于组件。考虑以下例子：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With this directive, we track the `workoutStarted` event defined on the `WorkoutRunner`
    component. The `onWorkoutStarted` function is called when the workout starts,
    with the details of the started workout.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个指令，我们跟踪了在`WorkoutRunner`组件上定义的`workoutStarted`事件。当锻炼开始时，将调用`onWorkoutStarted`函数，并带上已开始的锻炼的详情。
- en: Now that we understand how these bindings work, we can improve our `BusyIndicatorDirective`
    implementation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了这些绑定是如何工作的，我们可以改进我们的`BusyIndicatorDirective`实现。
- en: Implementation two - BusyIndicatorDirective with host bindings
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施二 - 具有宿主绑定的BusyIndicatorDirective
- en: You may have already guessed it! We will use *host property binding* instead
    of `Renderer` to set styles. Want to give it a try? Go ahead! Clear the existing
    implementation and try to set up a host binding for the `borderWidth` and `borderColor`
    style attributes without looking at the following implementation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了！我们将使用*宿主属性绑定*而不是`Renderer`来设置样式。想要试试吗？试一试吧！清除现有的实现，尝试在不查看以下实现的情况下为`borderWidth`和`borderColor`样式属性设置宿主绑定。
- en: 'This is how the directive will look after the host binding implementation:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在宿主绑定实现之后，指令将如下所示：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have moved the `pending` state check into a directive property called `validating`
    and then used the `controlBorderWidth` and `controlBorderColor` properties for
    style binding. This is definitely more succinct than our earlier approach! Go
    test it out.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`pending`状态检查移到了名为`validating`的指令属性中，然后使用了`controlBorderWidth`和`controlBorderColor`属性进行样式绑定。这绝对比我们之前的方法更简洁！去测试一下吧。
- en: 'And if we tell you that this can be done without the need for a custom directive,
    don''t be surprised! This is how we do it, just by using style bindings on the
    workout name `input`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们告诉你，这可以不需要自定义指令来完成，你不要感到惊讶！这就是我们做的，只需在锻炼名称`input`上使用样式绑定即可：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We get the same effect!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了相同的效果！
- en: No, our effort did not go to waste. We did learn about **renderer** and **host
    binding**. These concepts will come in handy while building directives that provide
    complex behavior extension instead of just setting element styles.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我们的努力并不是白费的。我们学到了**renderer**和**host binding**。这些概念在构建提供复杂行为扩展而不仅仅是设置元素样式的指令时会派上用场。
- en: If you are having a problem with running the code, look at the Git branch `checkpoint6.1`
    for a working version of what we have done thus far. Or if you are not using Git,
    download the snapshot of `checkpoint6.1` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-6-1](http://bit.ly/ng6be-checkpoint-6-1).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在运行代码时遇到问题，请查看Git分支`checkpoint6.1`，查看我们迄今为止所做的工作的可运行版本。或者，如果你没有使用Git，请从[http://bit.ly/ng6be-checkpoint-6-1](http://bit.ly/ng6be-checkpoint-6-1)下载`checkpoint6.1`的快照（ZIP文件）。在第一次设置快照时，请查看`trainer`文件夹中的`README.md`文件。
- en: The next topic that we are going to take up is *directive injection*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的主题是*指令注入*。
- en: Directive injection
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令注入
- en: 'Go back a few pages and look at the `BusyIndicatorDirective` implementation
    that uses the *renderer,* specifically the constructor:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 回到几页前，看一下使用*renderer*的`BusyIndicatorDirective`实现，特别是构造函数：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Angular automatically locates the `NgModel` directive created for the directive
    element and injects it into `BusyIndicatorDirective`. This is possible because
    both directives are declared on the same *host element*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Angular会自动定位为指令元素创建的`NgModel`指令，并将其注入到`BusyIndicatorDirective`中。这是可能的，因为这两个指令都声明在同一个*宿主元素*上。
- en: The good news is that we can influence this behavior. Directives created on
    a parent HTML tree or child tree can also be injected. The next few sections talk
    about how to inject directives across the component tree, a very handy feature
    that allows cross-directive communication for directives that have a *common lineage*
    (in a view).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是我们可以影响这种行为。在父HTML树或子树上创建的指令也可以被注入。接下来的几节将讨论如何在组件树中跨指令进行注入，这是一个非常实用的功能，允许具有*共同血统*（在视图中）的指令进行跨指令通信。
- en: We will use StackBlitz ([https://stackblitz.com/edit/angular-pzljm3](https://stackblitz.com/edit/angular-pzljm3))
    to demonstrate these concepts. SlackBlitz is an online IDE to run Angular applications!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 StackBlitz（[https://stackblitz.com/edit/angular-pzljm3](https://stackblitz.com/edit/angular-pzljm3)）来演示这些概念。StackBlitz是一个在线IDE，用于运行Angular应用程序！
- en: 'To start with, look at the file `app.component.ts`. It has three directives: `Relation`,`Acquaintance`,
    and `Consumer` and this view hierarchy is defined:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，查看文件`app.component.ts`。它有三个指令：`Relation`，`Acquaintance`和`Consumer`，并定义了这个视图层次结构：
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the next few sections, we will describe the various ways in which we can
    inject the different `relation` and `Acquaintance` directives into the `consumer`
    directive. Check out the browser console for the injected dependencies that we
    log during the `ngAfterViewInit` lifecycle hook.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将描述不同方式将不同的`Relation`和`Acquaintance`指令注入到`consumer`指令中。在`ngAfterViewInit`生命周期钩子期间，查看浏览器控制台中我们记录的注入依赖项。
- en: Injecting directives defined on the same element
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入在同一元素上定义的指令
- en: 'Constructor injection by default supports injecting directives defined on the
    same element. The constructor function just needs to declare the directive type
    variable that we want to inject:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，构造函数注入支持在同一元素上定义的指令。构造函数只需要声明我们要注入的指令类型变量即可：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `NgModel` injection that we did in `BusyIndicatorDirective` falls under
    this category. If the directive is not found on the current element, the Angular
    DI will throw an error, unless we mark the dependency as `@Optional`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`BusyIndicatorDirective`中进行的`NgModel`注入就属于这一类。如果在当前元素上找不到指令，那么Angular DI将抛出错误，除非我们将依赖标记为`@Optional`。
- en: Optional dependency
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 可选依赖
- en: The `@Optional` decorator is not limited to directive injection. It's there
    to mark any type of dependency optional.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Optional` 装饰器不仅限于指令注入。它用于标记任何类型的可选依赖。'
- en: 'From the plunk example, the first injection (in `Consumer` directive implementation)
    injects the `Relation` directive with the `me` attribute (`relation="me"`) into
    the consumer directive:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 从plunk示例中，第一个注入（在`Consumer`指令实现中）将带有`me`属性（`relation="me"`）的`Relation`指令注入到消费者指令中：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Injecting directive dependency from the parent
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从父级注入指令依赖
- en: 'Prefixing a constructor argument with the `@Host` decorator instructs Angular
    to search for the dependency on the *current element*, *its parent*, or its *parents*
    until it reaches the component boundaries (a component with the directive present
    somewhere in its view hierarchy). Check the second `consumer` injection:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Host`装饰符对构造函数参数进行前缀，指示Angular在*当前元素*、*其父级*或其*父级*中搜索依赖项，直到它达到组件边界（在其视图层次结构中的某个地方有指令的组件）。查看第二个`consumer`注入：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This statement injects the `Acquaintance` directive instance declared two levels
    up the hierarchy.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句将注入两层上层声明的`Acquaintance`指令实例。
- en: Like the `@Option` decorator described previously, the usage of `@Host()` is
    not limited to directives too. Angular service injection also follows the same
    pattern. If a service is marked with `@Host`, the search stops at the host component.
    It does not continue further up the component tree.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 像前面描述的`@Optional`装饰器一样，`@Host()`的使用也不仅限于指令。Angular服务注入也遵循相同的模式。如果服务标记为`@Host`，那么搜索将停在宿主组件处。它不会继续向上查找组件树。
- en: The `@Skipself` decorator can be used to skip the current element for a directive
    search.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Skipself` 装饰器可用于跳过当前元素以进行指令搜索。'
- en: 'From the StackBlitz example, this injection injects the `Relation` directive
    with the `relation` attribute value `parent` (`relation="parent"`) into `consumer`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从StackBlitz示例中，这个注入将带有`relation="parent"`（`relation`属性值为`parent`）的`Relation`指令注入`consumer`中：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Injecting a child directive (or directives)
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入子指令（或多个指令）
- en: 'If there is a need to inject directive(s) defined on nested HTML into a parent
    directive/component, there are four decorators that can help us:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要将嵌套HTML中定义的指令注入到父指令/组件中，有四个装饰器可以帮助我们：
- en: '`@ViewChild`/`@ViewChildren`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ViewChild`/`@ViewChildren`'
- en: '`@ContentChild`/`@ContentChildren`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ContentChild`/`@ContentChildren`'
- en: 'As these naming conventions suggest, there are decorators to inject a single
    child directive or multiple children directives:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这些命名约定所暗示的，有用于注入单个子指令或多个子指令的装饰器：
- en: To understand the significance of `@ViewChild/@ViewChildren` versus `@ContentChild/@ContentChildren`,
    we need to look at what view and content children are, a topic that we will take
    up soon. But for now, it's enough to understand that view children are part of
    a component's own view and content children are external HTML injected into the
    component's view.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`@ViewChild/@ViewChildren`与`@ContentChild/@ContentChildren`的重要性，我们需要看一下什么是视图和内容子项，这是我们很快要讨论的一个主题。但现在，了解视图子项是组件自己视图的一部分，而内容子项是注入到组件视图中的外部HTML就足够了。
- en: 'Look how, in the StackBlitz example, the `ContentChildren` decorator is used
    to inject the child `Relation` directive into `Consumer`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 看看在StackBlitz的示例中，`ContentChildren`装饰器是如何用于将子`Relation`指令注入到`Consumer`中的：
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Surprisingly, the data type of the variable `children` is not an array, but
    a custom class-`QueryList`. The `QueryList` class is not a typical array, but
    a collection that is kept up to date by Angular whenever dependencies are added
    or removed. This can happen if the DOM tree is created/destroyed when using structural
    directives such as `NgIf` or `NgFor`. We will also talk more about `QueryList`
    in the coming sections.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 可笑的是，变量`children`的数据类型不是数组，而是一个自定义类-`QueryList`。`QueryList`类并不是典型的数组，而是一个由Angular在添加或移除依赖项时保持更新的集合。这可能发生在使用`NgIf`或`NgFor`等结构指令创建/销毁DOM树时。我们在接下来的章节中也会更多地讨论`QueryList`。
- en: You may have observed that the preceding injection is not a constructor injection
    as were the earlier two examples. This is for a reason. The injected directive(s)
    will not be available until the underlying component/element's content has initialized.
    For this precise reason, we have the `console.log` statements inside the `ngAfterViewInit`
    lifecycle hook. We should only access the content children post this life cycle
    hook execution.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，前面的注入不是构造函数注入，就像前面的两个例子一样。这是有原因的。注入的指令将在底层的组件/元素内容初始化之前不可用。出于这个特定的原因，我们在`ngAfterViewInit`生命周期钩子内有`console.log`语句。我们应该只在此生命周期钩子执行后访问内容子项。
- en: The preceding sample code injects in all three child `relation` objects into
    the `consumer` directive.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例代码将所有三个子`relation`对象注入到`consumer`指令中。
- en: Injecting descendant directive(s)
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入后代指令
- en: 'The standard `@ContentChildren` decorator (or as a matter of fact `@ViewChildren`
    too) only injects the immediate children of a directive/component and not its
    descendants. To include all its descendants, we need to provide an argument to
    `Query`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的`@ContentChildren`装饰器（或事实上也是`@ViewChildren`）只会注入指令/组件的直接子项，而不是其后代。要包含所有后代，我们需要向`Query`提供参数：
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Passing the `descendants: true` parameter will instruct Angular to search for
    all descendants.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '传递`descendants: true`参数将指示Angular搜索所有后代。'
- en: If you look at the console log, the preceding statement injects in all four
    descendants.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看控制台日志，前面的语句会注入所有四个后代。
- en: The Angular DI, while it seems simple to use, packs a lot of functionality.
    It manages our services, components, and directives and provides us with the right
    stuff in the right place at the right time. Directive injection in components
    and other directives provides a mechanism for directives to communicate with each
    other. Such injections allow one directive to access the public API (public functions/properties)
    of another directive.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Angular DI看起来很容易使用，但它拥有很多功能。它管理我们的服务、组件和指令，并在正确的时间将正确的东西提供给我们的正确位置。在组件和其他指令中注入指令提供了一种指令相互通信的机制。这样的注入允许一个指令访问另一个指令的公共API（公共函数/属性）。
- en: It's now time to explore something new. We are going to build an Ajax button
    component that allows us to inject an external view into the component, a process
    also known as **content ****transclusion**.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是探索新事物的时候了。我们将构建一个 Ajax 按钮组件，允许我们将外部视图注入组件中，这个过程也被称为**内容转译**。
- en: Building an Ajax button component
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个 Ajax 按钮组件
- en: When we save/update an exercise or workout, there is always the possibility
    of duplicate submission (or duplicate `POST` requests). The current implementation
    does not provide any feedback as to when the save/update operation started and
    when it is  completed. The user of an app can knowingly or unknowingly click on
    the Save button multiple times due to the lack of visual clues.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们保存/更新练习或锻炼时，总是存在重复提交的可能性（或重复的`POST`请求）。当前的实现不提供任何关于保存/更新操作何时开始以及何时完成的反馈。由于缺乏视觉线索，应用程序的用户可能会有意或无意地多次点击保存按钮。
- en: Let's try to solve this problem by creating a specialized button—an *Ajax button*
    that gives some visual clues when clicked on and also stops duplicate Ajax submissions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过创建一个专用按钮来解决这个问题——一个*Ajax 按钮*，当点击时提供一些视觉线索，并阻止重复的 Ajax 提交。
- en: The button component will work on these lines. It takes a function as input.
    This input function (input parameter) should return a promise pertaining to the
    remote request. On clicking on the button, the button internally makes the remote
    call (using the input function), tracks the underlying promise, waits for it to
    complete, and shows some busy clues during this activity. Also, the button remains
    disabled until the remote invocation completes to avoid duplicate submission.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮组件将按照这些行工作。它接受一个函数作为输入。此输入函数（输入参数）应返回与远程请求相关的 promise。单击按钮时，按钮内部调用远程调用（使用输入函数），跟踪底层
    promise，并在此过程中显示一些忙碌的线索。此外，为了避免重复提交，按钮在远程调用完成之前保持禁用状态。
- en: The companion code base for the following section is Git branch `checkpoint6.2`.
    You can work along with us, or check out the implementation available in the branch.
    Or if you are not using Git, download the snapshot of `checkpoint6.2` (a ZIP file)
    from the GitHub location [http://bit.ly/ng6be-checkpoint-6-2](http://bit.ly/ng6be-checkpoint-6-2).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分的伴随代码基于 Git 分支`checkpoint6.2`。您可以与我们一起工作，或者查看分支中提供的实现。或者如果您不使用 Git，请从 GitHub
    位置 [http://bit.ly/ng6be-checkpoint-6-2](http://bit.ly/ng6be-checkpoint-6-2) 下载`checkpoint6.2`的快照（ZIP
    文件）。在第一次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: 'Let''s create the component outline to make things clearer. Use the following
    command to create an `ajax-button` component under the application''s shared module
    (`src/app/shared`) and **then export the component** from the `SharedModule`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建组件大纲以使事情更清晰。使用以下命令在应用程序的共享模块 (`src/app/shared`) 下创建一个`ajax-button`组件，**然后从`SharedModule`导出该组件**：
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Update the component definition too and import them from `@angular/core`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 也需要更新组件定义并从`@angular/core`导入它们：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And add the following HTML template to `ajax-button.component.html`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将以下 HTML 模板添加到`ajax-button.component.html`中：
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The component (`AjaxButtonComponent`) takes two property bindings, `execute`
    and `parameter`. The `execute` property points to the function that is invoked
    on the Ajax button click. The `parameter` is the data that can be passed to this
    function.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件（`AjaxButtonComponent`）具有两个属性绑定，`execute`和`parameter`。`execute`属性指向在单击 Ajax
    按钮时调用的函数。`parameter`是可以传递给此函数的数据。
- en: 'Look at the usage of the `busy` flag in the view. We disable the button and
    show the spinner when the `busy` flag is set. Let''s add the implementation that
    makes everything work. Add this code to the `AjaxButtonComponent` class:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 查看视图中`busy`标志的使用方式。当`busy`标志被设置时，我们禁用按钮并显示旋转图标。让我们添加使一切正常工作的实现。将此代码添加到`AjaxButtonComponent`类中：
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We set up a *host event binding* to the click event on `AjaxButtonComponent`.
    Anytime the `AjaxButtonComponent` component is clicked on, the `onClick` function
    is invoked.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了一个*主机事件绑定*，将点击事件绑定到`AjaxButtonComponent`组件。每当单击`AjaxButtonComponent`组件时，都会调用`onClick`函数。
- en: The `HostListener` import needs to be added to the `'@angular/core'` module.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将`HostListener`导入添加到`'@angular/core'`模块中。
- en: The `onClick` implementation calls the input function with a lone parameter
    as `parameter`. The result of the invocation is stored in the `result` variable.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`onClick` 实现使用`parameter`作为唯一参数调用输入函数。调用的结果存储在`result`变量中。'
- en: The `if` condition checks whether the `result` is a `Promise` object. If yes,
    the `busy` indicator is set to `true`. The button then waits for the promise to
    get resolved, using the `then` function. Irrespective of whether the promise is
    resolved with *success* or *error*, the busy flag is set to `null`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 条件检查 `result` 是否为 `Promise` 对象。如果是，`busy`指示器就会被设置为 `true`。然后按钮等待 promise
    被解决，使用 `then` 函数。无论 promise 是否解决为*成功*还是*错误*，忙标志都被设置为`null`。'
- en: The reason the busy flag is set to `null` and not `false` is due to this attribute
    binding `[attr.disabled]="busy"`. The `disabled` attribute will not be removed
    unless `busy` is `null`. Remember that in HTML, `disabled="false"` does not enable
    the button. The attribute needs to be removed before the button becomes clickable
    again.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 忙标志被设置为`null`而不是`false`的原因是由于这个属性绑定`[attr.disabled]="busy"`。除非`busy`是`null`，否则`disabled`属性不会被移除。请记住，在HTML中，`disabled="false"`不会使按钮处于可点击状态。在按钮再次可点击之前，需要删除属性。
- en: 'If we are confused about this line:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对这一行感到困惑：
- en: '[PRE46]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then you need to look at how the component is used. Open `workout.component.html`
    and replace the `Save` button HTML with the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要看一下组件的使用方式。打开`workout.component.html`，将`保存`按钮的HTML替换为以下内容：
- en: '[PRE47]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `Workout.save` function binds to `execute`, and `parameter` takes the `FormControl`
    object `f`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`Workout.save` 函数绑定到 `execute`，而 `parameter` 获取 `FormControl` 对象 `f`。'
- en: 'We need to change the `save` function in the `Workout` class to return a promise
    for `AjaxButtonComponent` to work. Change the `save` function implementation to
    the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更改 `Workout` 类中的 `save` 函数以返回 `AjaxButtonComponent` 的 promise 才能工作。将 `save`
    函数的实现更改为以下内容：
- en: '[PRE48]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `save` function now returns a *promise* that we build by calling the `toPromise`
    function on the *observable* returned from the call to `workoutBuilderService.save()`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`save` 函数现在返回一个*promise*，我们通过调用从`workoutBuilderService.save()`调用返回的*observable*上的
    `toPromise` 函数来构建它。'
- en: Make note of how we define the `save` function as an *instance function* (with
    the use of the arrow operator) to create a closure over *this*. It's something
    we did earlier while building the *remote validator directive*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何将 `save` 函数定义为*实例函数*（使用箭头操作符）以使其在*this*上创建闭包。这是我们之前在构建*远程验证器指令*时做的事情。
- en: 'Time to test our implementation! Refresh the application and open the create/edit
    workout view. Click on the Save button and see the Ajax button in action:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候测试我们的实现了！刷新应用程序，打开创建/编辑锻炼视图。点击保存按钮，看到 Ajax 按钮的效果：
- en: '![](img/998a8485-f94b-4114-ba5b-9830963b9fb3.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/998a8485-f94b-4114-ba5b-9830963b9fb3.png)'
- en: The preceding animation may be short-lived as we navigate back to the workout
    list page post save. We can temporarily disable the navigation to see the new
    changes.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的动画可能只是短暂的，因为我们在保存后返回到锻炼列表页面。我们可以临时禁用导航以查看新更改。
- en: We started this section with the aim of highlighting how external elements/components
    can be transcluded into a component. Let's do it now!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这一部分开始，旨在突显外部元素/组件如何被传递到组件中。让我们来做吧！
- en: Transcluding external components/elements into a component
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将外部组件/元素传递到一个组件中
- en: From the very start, we need to understand what **transclusion** means. And
    the best way to understand this concept would be to look at an example.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，我们就需要了解**传递**意味着什么。了解这个概念的最佳方式是看一个例子。
- en: No component that we have built thus far has borrowed content from outside.
    Not sure what this means?
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们建立的任何组件都没有从外部借用内容。不确定这意味着什么？
- en: 'Consider the preceding `AjaxButtonComponent` example in `workout.component.html`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在`workout.component.html`中的前面的 `AjaxButtonComponent` 示例：
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: What if we change the `ajax-button` usage to the following?
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`ajax-button`的使用更改为以下内容会怎样？
- en: '[PRE50]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Will the `Save Me!` text show up on the button? It will not try it!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: “保存我！”的文本会显示在按钮上吗？不会，试一下！
- en: The `AjaxButtonComponent` component already has a template, and it rejects the
    content we provide in the preceding declaration. What if we can somehow make the
    content (`Save Me!` in the preceding example) load inside the `AjaxButtonComponent`?
    This act of injecting an external view fragment into the component's view is what
    we call **transclusion**, and the framework provides the necessary constructs
    to enable transclusions.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`AjaxButtonComponent` 组件已经有一个模板，并拒绝了我们在前面的声明中提供的内容。如果我们能够以某种方式将内容（在前面的例子中的“保存我！”）注入`AjaxButtonComponent`内部呢？这种将外部视图片段注入组件视图的行为就是我们所说的**传递**，框架提供了必要的构造来启用传递。'
- en: It's time to introduce two new concepts, *content children* and *view children*.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候介绍两个新概念，*内容子级*和*视图子级*。
- en: Content children and view children
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容子级和视图子级
- en: To define it succinctly, the HTML structure that a component defines internally
    (using `template or templateUrl`) is the **view children** of the component. However, the
    HTML view provided as part of the component usage added to the host element (such
    as `<ajax-button>**Save Me!**</ajax-button>`), defines the **content children**
    of the component.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 简洁地定义，组件内部定义的HTML结构（使用`template或templateUrl`）是组件的**视图子级**。然而，作为组件使用的一部分提供的HTML视图添加到宿主元素（例如`<ajax-button>**Save
    Me!**</ajax-button>`）中，定义了组件的**内容子级**。
- en: 'By default, Angular does not allow *content children* to be embedded as we
    saw before. The `Save Me!` text was never emitted. We need to explicitly tell
    Angular where to emit the *content children* inside the *component view template*.
    To understand this concept, let''s fix the `AjaxButtonComponent` view. Open `ajax-button.component.ts`
    and update the view template definition to the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Angular不允许将*内容子级*嵌入，就像我们之前看到的那样。`Save Me!`文本从未被发送。我们需要明确告诉Angular在*组件视图模板*内的哪里发出*内容子级*。为了理解这个概念，让我们来修复`AjaxButtonComponent`的视图。打开`ajax-button.component.ts`并更新视图模板定义如下：
- en: '[PRE51]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The two `ng-content` elements in the preceding view define the *content injection
    locations*, where the content children can be injected/transcluded. The `selector`
    property defines the *CSS selector* that should be used to locate the content
    children when injected into the main host.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 前述视图中的两个`ng-content`元素定义了*内容注入位置*，内容子级可以被注入/跨越。`selector`属性定义了注入到主机中时应使用的*CSS选择器*。
- en: 'It starts to make more sense as soon as we fix the `AjaxButtonComponent` usage
    in `workout.component.html`. Change it to the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在`workout.component.html`中修复了`AjaxButtonComponent`的使用情况，它就会变得更有意义。将其更改为如下：
- en: '[PRE52]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `span` with `data-animator` is injected into the `ng-content` with the `select=[data-animator]`
    property and the other `span` (with the `data-content` attribute) is injected
    into the second `ng-content` declaration.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`data-animator`的`span`被注入到具有`select=[data-animator]`属性的`ng-content`中，而另一个带有`data-content`属性的`span`被注入到第二个`ng-content`声明中。
- en: 'Refresh the application again and try to save a workout. While the end result
    is the same, the resultant view is a combination of multiple view fragments: one
    part for component definition (*view children*) and another part for component
    usage (*content children*).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 再次刷新应用程序，尝试保存锻炼。虽然最终结果是相同的，但最终视图是多个视图片段的组合：一个用于组件定义的部分（*视图子级*），另一个用于组件使用的部分（*内容子级*）。
- en: 'The following diagram highlights this difference for the rendered `AjaxButtonComponent`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 下图突出显示了渲染的`AjaxButtonComponent`的不同之处：
- en: '![](img/f1721b2e-ffe9-4e35-a57c-fca2c3bf62cb.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1721b2e-ffe9-4e35-a57c-fca2c3bf62cb.png)'
- en: The `ng-content` can be declared without the `selector` attribute. In such a
    scenario, the complete content defined inside the component tag is injected.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng-content`可以在不带有`selector`属性的情况下声明。在这种情况下，将注入组件标记内定义的全部内容。'
- en: '*Content injection* into an existing component view is a very powerful concept.
    It allows the component developer to provide extension points that the component
    consumer can readily consume and customize the behavior of the component, that
    too in a controlled manner.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*内容注入*进入现有组件视图是一个非常强大的概念。它允许组件开发人员提供扩展点，组件消费者可以轻松消费并自定义组件的行为，而且是在受控的方式。'
- en: The content injections that we defined for the `AjaxButtonComponent` allow the
    consumer to change the busy indicator animation and the button content, keeping
    the behavior of the button intact.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`AjaxButtonComponent`定义的内容注入允许消费者更改忙碌指示动画和按钮内容，同时保持按钮的行为不变。
- en: Angular's advantages do not end here. It has the capability to inject *content
    children* and *view children* into the *component code/implementation*. This allows
    the component to interact with its content/view children and control their behavior
    too.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的优势并不止于此。它具有将*内容子级*和*视图子级*注入到*组件代码/实现*中的能力。这使得组件可以与其内容/视图子级交互并控制它们的行为。
- en: Injecting view children using @ViewChild and @ViewChildren
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用@ViewChild和@ViewChildren注入视图子级
- en: 'Let''s look at the relevant parts of the `WorkoutAudioComponent` implementation.
    The view definition looked as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`WorkoutAudioComponent`实现的相关部分。视图定义如下：
- en: '[PRE53]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And the injection looked as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 注入的样式如下：
- en: '[PRE54]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The directive (`MyAudioDirective`) associated with the `audio` tag was injected
    into the `WorkoutAudio` implementation using the `@ViewChild` decorator. The parameters
    passed to `@ViewChild` are the *template variable* names (such as `tick`) used
    to locate the element in the view definition. The `WorkoutAudio` component then
    used these audio directives to control the audio playback for *7 Minute Workout*.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 与`audio`标签相关联的指令(`MyAudioDirective`)被注入到`WorkoutAudio`的实现中，使用`@ViewChild`装饰器。传递给`@ViewChild`的参数是用于在视图定义中定位元素的*模板变量*名称（例如`tick`）。然后`WorkoutAudio`组件使用这些音频指令来控制*7分钟锻炼*的音频播放。
- en: 'While the preceding implementation injects `MyAudioDirective`, even child components
    can be injected. For example, instead of using `MyAudioDirective`, suppose we
    build a `MyAudioComponent`, something like the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '尽管前面的实现注入了`MyAudioDirective`，但甚至子组件也可以被注入。例如，我们构建了一个`MyAudioComponent`，与`MyAudioDirective`相似，如下所示:'
- en: '[PRE55]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can then use it instead of the `audio` tag:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '然后我们可以使用`audio`标签的方式代替它:'
- en: '[PRE56]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The injection would still work.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 注入仍然可以工作。
- en: 'What happens if there is more than one directive/component of the same type
    defined on the component view? Use the `@ViewChildren` decorator. It allows you
    to query injections of one type. The syntax for the use of `@ViewChildren` is
    as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '如果组件视图中定义了多个相同类型的指令/组件会发生什么？使用`@ViewChildren`装饰器。它允许您查询一个类型的注入。使用`@ViewChildren`的语法如下:'
- en: '[PRE57]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This injects all the view children of type `directiveType`. For the `WorkoutAudio`
    component example stated previously, we can use the following statement to get
    hold of all `MyAudioDirective`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '这会注入所有类型为`directiveType`的视图子元素。对于前面所述的`WorkoutAudio`组件示例，我们可以使用以下语句来获取所有的`MyAudioDirective`:'
- en: '[PRE58]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `ViewChildren` decorator can also take a list of comma-separated selectors
    (*template variable names*) instead of type. For example, to select multiple `MyAudioDirective `instances in
    the `WorkoutAudio` component, we can use the following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewChildren`装饰器也可以接受用逗号分隔的选择器列表（*模板变量名*）而不是类型。例如，要在`WorkoutAudio`组件中选择多个`MyAudioDirective`实例，我们可以使用以下内容：'
- en: '[PRE59]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `QueryList` class is a special class provided by Angular. We introduced
    `QueryList` in the *Injecting descendant directive(s)* section earlier in the
    chapter. Let's explore `QueryList` further.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueryList`类是Angular提供的特殊类。我们在本章前面的*注入后代指令*部分介绍了`QueryList`。让我们进一步探讨`QueryList`。'
- en: Tracking injected dependencies with QueryList
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`QueryList`跟踪注入的依赖
- en: For components that require multiple components/directives to be injected (using
    either `@ViewChildren` or `@ContentChildren`), the dependency injected is a `QueryList`
    object.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要注入多个组件/指令的组件（使用`@ViewChildren`或`@ContentChildren`），注入的依赖是一个`QueryList`对象。
- en: The `QueryList` class is a *read-only **collection* of injected components/directives.
    Angular keeps this collection in sync based on the current state of the user interface.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueryList`类是一个*只读*的**集合*，包含注入的组件/指令。Angular根据用户界面当前的状态来保持此集合同步。'
- en: 'Consider, for example, the `WorkoutAudio` directive view. It has five instances
    of `MyAudioDirective`. Hence, for the following collection, we will have five
    elements:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '举个例子，`WorkoutAudio`指令视图有五个`MyAudioDirective`实例。因此，对于以下集合，我们将有五个元素:'
- en: '[PRE60]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: While the preceding example does not highlight the syncing part, Angular can
    track components/directives being added or removed from the view. This happens
    when we use content generation directives such as `ngFor`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的例子没有突出显示同步部分，Angular可以跟踪从视图中添加或删除的组件/指令。这是在使用`ngFor`等内容生成指令时发生的。
- en: 'Take this hypothetical template for example:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '以这个假设的模板为例:'
- en: '[PRE61]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The number of `MyAudioDirective` directives injected here equals the size of
    the `allAudios` array. During the program's execution, if elements are added to
    or removed from the `allAudios` array, the directive collection is also kept in
    sync by the framework.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这里注入的`MyAudioDirective`指令的数量等于`allAudios`数组的大小。程序执行过程中，如果向`allAudios`数组添加或删除元素，则框架也会同步更新指令集合。
- en: While the `QueryList` class is not an array, it can be iterated over (as it
    implements the **ES6 iterable interface**) using the `for (var item in queryListObject)`
    syntax. It also has some other useful properties, such as `length`, `first`, and
    `last`, which can come in handy. Check out the framework documentation ([http://bit.ly/ng2-querylist-class](http://bit.ly/ng2-querylist-class))
    for more details.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`QueryList`类不是数组，但它可以通过 `for (var item in queryListObject)` 语法进行迭代（因为它实现了**ES6
    iterable接口**）。它还有一些其他有用的属性，如 `length`、`first` 和 `last`，可以派上用场。查看框架文档（[http://bit.ly/ng2-querylist-class](http://bit.ly/ng2-querylist-class)）以获取更多详细信息。
- en: From the preceding discussion, we can conclude that `QueryList` saves the component
    developer a lot of boilerplate code that would be required if tracking had to
    be done manually.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的讨论中，我们可以得出结论，`QueryList` 可以为组件开发人员节省大量样板代码，在需要手动追踪时会很麻烦。
- en: View children access timing
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 视图子代访问时机
- en: View children injections are not available when the component/directive initializes.
    Angular makes sure that the view children injections are available to the component
    no later than the `ngAfterViewInit` life cycle event. Make sure you access the
    injected components/directives only when (or after) the `ngAfterViewInit` event
    has fired.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件/指令初始化时，视图子代注入是不可用的。Angular 确保视图子代注入在`ngAfterViewInit`生命周期事件之前可用于组件。确保只在（或之后）`ngAfterViewInit`事件触发后访问被注入的组件/指令。
- en: Let's now look at content children injection, which is almost similar, except
    for a few minor differences.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看内容子代注入，这几乎相同，只不过有一些细微差别。
- en: Injecting content children using @ContentChild and @ContentChildren
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 @ContentChild 和 @ContentChildren 注入内容子代
- en: 'Angular allows us to inject *content children* too, using a parallel set of
    attributes: `@ContentChild` to inject a specific content child and `@ContentChildren`
    to inject content children of a specific type.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Angular也允许我们*注入内容子代*，使用一组并行属性：`@ContentChild`用于注入特定内容子代，`@ContentChildren`用于注入特定类型的内容子代。
- en: 'If we look back at the usage of `AjaxButtonComponent`, its content children
    spans can be injected into `AjaxButtonComponent` implementation by doing this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下 `AjaxButtonComponent` 的用法，其内容子代 span 可以通过以下方式注入到 `AjaxButtonComponent`
    实现中：
- en: '[PRE62]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'And adding template variables onto the corresponding spans in `workout.component.html`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 并在`workout.component.html`中对应的 span 上添加模板变量：
- en: '[PRE63]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'While the preceding injection is `ElementRef`, it could have been a component
    too. Had we defined a component for spinner, such as:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的注入中，它是`ElementRef`，但也可以是一个组件。如果我们为旋转器定义了一个组件，比如：
- en: '[PRE64]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We could have injected it too using the following:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用以下方式进行注入：
- en: '[PRE65]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The same holds true for directives too. Any directive declared on `AjaxButtonComponent`
    can be injected into the `AjaxButtonComponent` implementation. For the preceding
    case, since the transcluded elements are standard HTML elements, we injected `ElementRef`,
    a wrapper that Angular creates for any HTML element.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 对于指令也是一样的。在`AjaxButtonComponent`上声明的任何指令都可以注入到`AjaxButtonComponent`实现中。对于上述情况，由于被传递的元素是标准
    HTML 元素，我们注入了`ElementRef`，这是 Angular 为任何 HTML 元素创建的包装器。
- en: Like *view children*, Angular makes sure that the content children references
    are bound to the variables injected before the `ngAfterContentInit` life cycle
    event.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 与*视图子代*类似，Angular确保在`ngAfterContentInit`生命周期事件之前，内容子代引用绑定到被注入的变量。
- en: While we are on the subject of injecting dependencies, let's talk about some
    variations around *injecting services into **components*.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论注入依赖项时，让我们谈谈一些关于*将服务注入到组件中**的变体。
- en: Dependency injection using viewProvider
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`viewProvider`进行依赖注入
- en: We are already familiar with the mechanism of DI registration in Angular, where
    we register a dependency at the global level by adding it to any module declaration.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉 Angular 中的 DI 注册机制，在那里我们通过将其添加到任何模块声明中将依赖项注册到全局级别。
- en: 'Or we can do it at a component level using the `providers` property on the
    `@Component` decorator:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以在组件级别使用`@Component`装饰器上的`providers`属性进行：
- en: '[PRE66]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Just to avoid confusion, we are now talking about injecting dependencies other
    than directive/component objects. Directives/components are registered in the
    `declarations` array of a module before they can be injected using decorator hints
    such as `@Query`, `@ViewChild`, `@ViewChildren`, and a few others.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免混淆，我们现在讨论的是注入除指令/组件对象之外的依赖项。在能够使用装饰器提示（如 `@Query`、`@ViewChild`、`@ViewChildren`
    等）注入之前，指令/组件需要在模块的`declarations`数组中进行注册。
- en: Dependencies registered at the component level are available for its *view children*
    and *content children* and their descendants.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件级别注册的依赖项可供其*视图子组件*和*内容子组件*及其后代使用。
- en: Before we proceed, we hope that the distinction between *view* and *content **children*
    is crystal clear to everyone. If in doubt, refer to the *Content children and
    view children* section again.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们希望*视图*和*内容子组件*之间的区别对每个人都非常清晰。如有疑问，请再次参考*内容子组件和视图子组件*部分。
- en: 'Let''s take an example from [Chapter 2](4b0ad450-2a56-4c24-b431-116d7225a57e.xhtml),
    *Personal Trainer*. The `WorkoutBuilderService` service was registered at the
    app level in the workout builder module (`WorkoutBuilderModule`):'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以[第二章](4b0ad450-2a56-4c24-b431-116d7225a57e.xhtml)中的一个例子，*个人教练*为例。`WorkoutBuilderService`
    服务在锻炼构建模块（`WorkoutBuilderModule`）中以应用程序级别注册：
- en: '[PRE67]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This allows us to inject `WorkoutBuilderService` across the app in order to build
    workouts and while running workouts. Instead, we could have registered the service
    at the `WorkoutBuilderComponent` level since it is the parent of all workout/exercise
    creation components, something like the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以让我们在整个应用程序中注入 `WorkoutBuilderService` 以构建锻炼，同时运行锻炼。相反，我们也可以在 `WorkoutBuilderComponent`
    级别注册服务，因为它是所有锻炼/练习创建组件的父组件，类似以下示例：
- en: '[PRE68]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This change would disallow injecting `WorkoutBuilderService` in `WorkoutRunner`
    or any component related to workout execution.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变将禁止在 `WorkoutRunner` 或与锻炼相关的任何组件中注入 `WorkoutBuilderService`。
- en: What if the `WorkoutBuilderService` service is registered at the app level as
    well as at the component level (as shown in the preceding example)? How does the
    injection happen? From our experience, we know that Angular will inject a different
    instance of the `WorkoutBuilderService` service into `WorkoutBuilderComponent`
    (and its descendants), while other parts of the application (*Workout runner*)
    will get the global dependency. Remember **hierarchical injectors**!
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `WorkoutBuilderService` 服务在应用程序级别和组件级别（如上例所示）都注册了，会发生什么？注入会如何进行？根据我们的经验，我们知道
    Angular 会将 `WorkoutBuilderService` 服务的不同实例注入到 `WorkoutBuilderComponent`（及其后代）中，而应用程序的其他部分（*Workout
    runner*）会获得全局依赖。记住**层次注入器**！
- en: Angular does not stop here. It provides some further scoping of dependencies
    using the `viewProviders` property. The `viewProviders` property, available on
    the `@Component` decorator, allows the registering of dependencies that can be
    injected only in the view children.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 还不止于此。它使用 `viewProviders` 属性提供了一些进一步的依赖项作用域限定。`@Component` 装饰器上的 `viewProviders`
    属性允许注册只能在视图子组件中注入的依赖项。
- en: 'Let''s consider the `AjaxButtonComponent` example again, and a simple directive
    implementation called `MyDirective`, to elaborate on our discussion:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次考虑 `AjaxButtonComponent` 的例子，并且考虑一个简单的指令实现，名为 `MyDirective`，以阐明我们的讨论：
- en: '[PRE69]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `MyDirective` class depends upon a service, `MyService`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyDirective` 类依赖于一个名为 `MyService` 的服务。'
- en: 'To apply this directive to the *button element* in the `AjaxButtonComponent`
    template, we need to register the `MyService` dependency too (assuming that `MyService`
    has not been registered globally):'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此指令应用于 `AjaxButtonComponent` 模板中的*按钮元素*，我们也需要注册 `MyService` 的依赖（假设 `MyService`
    尚未全局注册）：
- en: '[PRE70]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Since `MyService` is registered with `AjaxButtonComponent`, `MyDirective` can
    be added to its content children too. Hence the `myDirective` application on *spinner
    HTML* will also work (the code in `workout.component.html`):'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `MyService` 已与 `AjaxButtonComponent` 注册，因此 `MyDirective` 也可以添加到其内容子组件中。因此，在
    *spinner HTML* 上应用 `myDirective` 也将起作用（`workout.component.html` 中的代码）：
- en: '[PRE71]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'But changing the `providers` property to `viewProviders`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 但将 `providers` 属性更改为 `viewProviders`：
- en: '[PRE72]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Will fail the `MyService` injection for the `AjaxButtonComponent`'s content
    children (the `div` in the preceding code), with a DI error in the console.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 会导致 `AjaxButtonComponent` 的内容子组件（上述代码中的 `div`）中的 `MyService` 注入失败，控制台会显示 DI
    错误。
- en: Dependencies registered with `viewProviders` are invisible to its content children.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `viewProviders` 注册的依赖对其内容子组件不可见。
- en: This dependency scoping for *the view* and *content children* may not seem useful
    at first sight, but it does have its benefits. Imagine we are building a reusable
    component that we want to package and deliver to developers for consumption. If
    the component has a service dependency that it prepackages too, we need to be
    extra cautious. If such a component allows *content injection* (content children),
    the dependent service is widely exposed if *provider-based* registration is used
    on the component. Any content children can get hold of the service dependency
    and use it, leading to undesirable consequences. By registering the dependency
    using `viewProvider`, only the component implementation and its child views have
    access to the dependency, providing the necessary layer of encapsulation.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 视图和内容子级别的依赖作用域乍看起来可能并不有用，但它确实有其好处。 想象一下，我们正在构建一个可重用的组件，我们希望将其打包并交付给开发人员使用。 如果组件有一个预打包的服务依赖项，我们需要特别小心。
    如果这样的组件允许*内容注入*（内容子级别），则在组件上使用基于*提供者*的注册时，依赖服务将被广泛暴露。 任何内容子级别都可以获取服务依赖并使用它，这会导致不良后果。
    通过使用`viewProvider`注册依赖项，只有组件实现和其子视图才能访问到依赖项，提供了必要的封装层。
- en: Yet again, we are amazed by the flexibility and level of customization that
    the DI framework provides. While it may be intimidating for starters, once we
    start building more and more components/directives with Angular, we will always
    find areas where these concepts make our implementation simpler.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次对DI框架提供的灵活性和定制级别感到惊讶。 尽管对于初学者来说可能有些令人生畏，但一旦我们开始使用Angular构建越来越多的组件/指令，我们总会发现这些概念使我们的实现变得更简单的地方。
- en: Let's shift our focus to the third classification of directives: *structural
    directives*.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把焦点转向指令的第三个分类：*结构指令*。
- en: Understanding structural directives
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解结构指令
- en: 'While we will often be using structural directives, such as `NgIf` and `NgFor`,
    there is seldom a need to creating a structural directive. Think carefully. If
    we need a new view, we create a *component*. If we need to extend an existing
    element/component, we use a *directive*. Whereas the most common use of structural
    directives is to clone a piece of a view (also called a *template view*) and then,
    based on some conditions:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们经常使用结构指令，比如`NgIf`和`NgFor`，但很少需要创建一个结构指令。仔细考虑。如果我们需要一个新的视图，我们会创建一个*组件*。如果我们需要扩展现有的元素/组件，我们使用*指令*。
    而结构指令最常见的用途是克隆视图的一部分（也称为*模板视图*），然后根据一些条件：
- en: Either inject/destroy these templates (`NgIf` and `NgSwitch`)
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要么注入/销毁这些模板（`NgIf`和`NgSwitch`）
- en: Or duplicate these templates (`NgFor`)
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者复制这些模板（`NgFor`）
- en: Any behavior implemented using structure directives will inadvertently fall
    into either of these two categories.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 使用结构指令实现的任何行为都会无意中落入这两个类别之一。
- en: Given this fact, instead of building our own structural directive, let's look
    at the source code of the `NgIf` implementation.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个事实，与其构建我们自己的结构指令，不如看看`NgIf`实现的源代码。
- en: 'The following is an excerpt from the `NgIf` directive that is of interest to
    us. We have ignored the `ngIfElse` parts from the excerpt intentionally:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是引起我们兴趣的`NgIf`指令的摘录。 我们特意忽略了摘录中的`ngIfElse`部分：
- en: '[PRE73]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: No magic here, just a simple structural directive that checks a Boolean condition
    (`this._context.$implicit`) to create/destroy the view!
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么神奇的，只是一个简单的结构指令，检查一个布尔条件（`this._context.$implicit`）来创建/销毁视图！
- en: The first if condition above check, if the condition `this._context.$implicit`
    is `true.` The next condition makes sure that the view is already not rendered
    by checking the variable `_thenViewRef`. We only want to flip the view if `this._context.$implicit`
    translates from `false` to `true`. If both if's conditions are true the existing
    view is cleared (`this._viewContainer.clear()`) and the reference to the else
    view is cleared. The innermost if condition makes sure that the if's template
    reference is available. Finally, the code calls `_viewContainer.createEmbeddedView`
    to render (or re-render) the view.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的第一个if条件检查条件`this._context.$implicit`是否为`true`。 接下来的条件确保视图已经不是通过检查变量`_thenViewRef`渲染的。
    如果`this._context.$implicit`从`false`转换为`true`，我们只希望翻转视图。 如果两个if条件都为true，则清除现有视图（`this._viewContainer.clear()`）并清除else视图的引用。
    最内层的if条件确保if的模板引用可用。 最后，代码调用`_viewContainer.createEmbeddedView`来渲染（或重新渲染）视图。
- en: It's not difficult to understand how the directive works. What needs to be detailed
    are the two new injections, `ViewContainerRef (_viewContainer)` and `TemplateRef
    (_templateRef)`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 理解指令的工作原理并不困难。需要详细说明的是两个新的注入，`ViewContainerRef(_viewContainer)` 和 `TemplateRef(_templateRef)`。
- en: TemplateRef
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TemplateRef
- en: 'The `TemplateRef` class (`_templateRef`) stores the reference to the template
    that the structural directive is referring to. Remember the discussion on structural
    directives from [Chapter 1](8eb47c1f-58fe-45dd-9afe-b955ef2080be.xhtml), *Building
    Our First App - 7 Minute Workout*? All structural directives take a template HTML
    that they work on. When we use a directive such as `NgIf`:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`TemplateRef` 类（`_templateRef`）存储了结构指令所引用的模板的引用。还记得来自[第一章](8eb47c1f-58fe-45dd-9afe-b955ef2080be.xhtml)，*构建我们的第一个应用程序
    - 7分钟锻炼*的结构指令的讨论吗？所有结构指令都会使用模板HTML。当我们使用`NgIf`这样的指令时：'
- en: '[PRE74]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Angular internally translates this declaration to the following:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Angular在内部将该声明转换为以下内容：
- en: '[PRE75]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This is the template that structural directives work with, and `_templateRef`
    points to this template.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结构指令使用的模板，`_templateRef`指向这个模板。
- en: The other injection is `ViewContainerRef`.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个注入是`ViewContainerRef`。
- en: ViewContainerRef
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ViewContainerRef
- en: The `ViewContainerRef` class points to the container where templates are rendered.
    This class has a number of handy methods for managing views. The two functions
    that `NgIf` implementation uses, `createEmbeddedView` and `clear`, are there to
    add and remove the template HTML.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewContainerRef` 类指向模板渲染的容器。这个类有许多便利的方法来管理视图。`NgIf` 实现使用的两个函数`createEmbeddedView`和`clear`，用于添加和移除模板HTML。'
- en: The `createEmbeddedView` function takes the template reference (again injected
    into the directive) and renders the view.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`createEmbeddedView` 函数接受模板引用（再次注入到指令中）并渲染视图。'
- en: The `clear` function destroys the element/component already injected and clears
    the view container. Since every component and its children referenced inside the
    template (`TemplateRef`) are destroyed, all the associated bindings also cease
    to exist.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`clear`函数销毁已经注入的元素/组件并清除视图容器。因为模板（`TemplateRef`）中引用的每个组件及其子元素都被销毁，所有相关的绑定也随之消失。'
- en: Structural directives have a very specific area of application. Still, we can
    do a lot of nifty tricks using the `TemplateRef` and `ViewContainerRef` classes.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 结构指令有一个非常具体的应用领域。不过，我们可以使用`TemplateRef`和`ViewContainerRef`类做很多巧妙的技巧。
- en: We can implement a structural directive that, depending on the user role, shows/hides
    the view template.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现一个结构指令，根据用户角色显示/隐藏视图模板。
- en: 'Consider this example of a hypothetical structural directive, `forRoles`:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个假设的结构指令`forRoles`的例子：
- en: '[PRE76]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `forRoles` directive will not render the button if the user does not belong
    to the *admin* role. The core logic would look something like the following:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户不属于*admin*角色，`forRoles`指令将不会渲染按钮。核心逻辑可能看起来像下面这样：
- en: '[PRE77]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The directive implementation will need some sort of service that returns the
    logged-in user's details. We will leave the implementation for such a directive
    to the readers.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 指令的实现将需要某种返回已登录用户详情的服务。我们将把这样的指令的实现留给读者。
- en: 'What the `forRoles` directive does can also be done using `NgIf`:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`forRoles`指令所做的事情也可以使用`NgIf`来实现：'
- en: '[PRE78]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: But the `forRoles` directive just adds to the template's readability with clear
    intentions.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`forRoles`指令只是为模板的可读性增加了明确的意图。
- en: 'A fun application of structural directives may involve creating a directive
    that just duplicates the template passed to it. It would be quite easy to build
    one; we just need to call `createEmbeddedView` twice:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 结构指令的一个有趣的应用可能涉及创建一个只是复制传递给它的模板的指令。构建一个将会非常简单；我们只需调用`createEmbeddedView`两次：
- en: '[PRE79]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Another fun exercise!
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的练习！
- en: The `ViewContainerRef` class also has some other functions that allow us to
    inject *components*, get the number of embedded views, reorder the view, and so
    on and so forth. Look at the framework documentation for `ViewContainerRef` ([http://bit.ly/view-container-ref](http://bit.ly/view-container-ref))
    for more details.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewContainerRef` 类还有一些其他函数，允许我们注入*组件*，获取嵌入视图的数量，重新排序视图等等。查看`ViewContainerRef`的框架文档（[http://bit.ly/view-container-ref](http://bit.ly/view-container-ref)）获取更多详细信息。'
- en: That completes our discussion on structural directives and it's time to start
    something new!
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对结构指令的讨论就到这里，是时候开始一些新的东西了！
- en: The components that we have built thus far derive their styles (CSS) from the
    common *bootstrap style sheet* and some custom styles defined in `app.css`. Angular
    has much more to offer in this area. A truly reusable component should be completely
    self-contained, in terms of both behavior and user interface.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止构建的组件从通用*bootstrap样式表*和`app.css`中定义的一些自定义样式中获取它们的样式（CSS）。Angular在这方面提供了更多。一个真正可重复使用的组件应该是完全自包含的，无论是行为还是用户界面。
- en: Component styling and view encapsulation
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件样式和视图封装
- en: A longstanding problem with web app development is the lack of encapsulation
    when it comes to DOM element behavior and styles. We cannot segregate one part
    of the application HTML from another through any mechanism.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序开发中长期存在的一个问题是，当涉及DOM元素的行为和样式时缺乏封装性。我们无法通过任何机制将应用程序的一个部分与另一个部分隔离开来。
- en: In fact, we have too much power at our disposal. With libraries such as jQuery
    and powerful *CSS selectors*, we can get hold of any DOM element and change its
    behavior. There is no distinction between our code and any external library code
    in terms of what it can access. Every single piece of code can manipulate any
    part of the rendered DOM. Hence, the encapsulation layer is broken. A badly written
    library can cause some nasty issues that are hard to debug.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们拥有太多的强大功能。通过诸如jQuery和强大的*CSS选择器*等库，我们可以获得任何DOM元素并更改其行为。在访问方面，我们的代码与任何外部库的代码之间没有区别。每一段代码都可以操作任何渲染的DOM部分。因此，封装层被破坏了。一个编写不良的库可能会引发一些难以调试的严重问题。
- en: The same holds true for CSS styling too. Any UI library implementation can override
    global styles if the library implementation wants to do so.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: CSS样式也同样适用。如果库实现希望这样做，任何UI库实现都可以覆盖全局样式。
- en: These are genuine challenges that any library developer faces when building
    reusable libraries. Some emerging web standards have tried to address this issue
    by coming up with concepts such as **web components**.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是任何库开发者在构建可重复使用库时所面临的真正挑战。一些新兴的Web标准试图通过提出**web组件**等概念来解决这个问题。
- en: '**Web components**, in simple terms, are reusable user interface widgets that
    encapsulate their *state*, *style*, *user interface*, and *behavior*. Functionality
    is exposed through well-defined APIs, and the user interface parts are encapsulated
    too.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web组件**简单来说，是可重复使用的用户界面部件，它们封装了*状态*，*样式*，*用户界面*和*行为*。功能通过明确定义的API暴露，用户界面部分也被封装。'
- en: 'The *web component* concept is enabled by four standards:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '*web组件*的概念的实现依赖于四个标准：'
- en: HTML templates
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML模板
- en: Shadow DOM
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shadow DOM
- en: Custom elements
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义元素
- en: HTML imports
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML导入
- en: For this discussion, the technology standard we are interested in is **Shadow
    DOM.**
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个讨论中，我们感兴趣的技术标准是**Shadow DOM**。
- en: Overview of Shadow DOM
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shadow DOM概述
- en: '**Shadow DOM** is like a parallel DOM tree hosted inside a component (*an HTML
    element, **not to be confused with Angular components*), hidden away from the
    main DOM tree. No part of the application has access to this shadow DOM other
    than the component itself.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shadow DOM**就像一个并行的DOM树，嵌套在一个组件内部（*一个HTML元素，*与Angular组件不要混淆*）中，隐藏在主DOM树之外。除了组件本身，应用程序的任何部分都无法访问这个Shadow
    DOM。'
- en: It is the implementation of the Shadow DOM standard that allows view, style,
    and behavior encapsulation. The best way to understand Shadow DOM is to look at
    HTML5 `video` and `audio` tags.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 实现Shadow DOM标准允许视图，样式和行为封装。了解Shadow DOM的最佳方式是查看HTML5的`video`和`audio`标签。
- en: 'Have you ever wondered how this `audio` declaration:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 你曾经想过这个`audio`声明是如何实现的吗：
- en: '[PRE80]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Produces the following?
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 产生以下结果？
- en: '![](img/1db22226-a91d-457a-82bc-44c19d34ac5f.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1db22226-a91d-457a-82bc-44c19d34ac5f.png)'
- en: 'It is the browser that generates the underlying Shadow DOM to render the audio
    player. Surprisingly, we can even look at the generated DOM! Here is how we do
    it:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 是浏览器生成潜在的Shadow DOM来渲染音频播放器。令人惊讶的是，我们甚至可以查看生成的DOM！以下是我们如何实现它的步骤：
- en: Take the preceding HTML, create a dummy HTML page, and open it in Chrome.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拿前面的HTML，创建一个虚拟的HTML页面，并在Chrome中打开它。
- en: Then open the Developer tools window (*F12*). Click on the Setting icon on the
    upper-left corner.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后打开开发者工具窗口（*F12*）。单击左上角的设置图标。
- en: 'On the General settings, click on the checkbox, as highlighted in the following
    screenshot, to enable the inspection of Shadow DOM:'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在常规设置中，单击如下屏幕截图中突出显示的复选框，以启用查看Shadow DOM的检查功能：
- en: '![](img/a95f3b1d-c9b0-476f-8a25-65a2d9e37851.png)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a95f3b1d-c9b0-476f-8a25-65a2d9e37851.png)'
- en: 'Refresh the page, and if we now inspect the generated `audio` HTML, the Shadow
    DOM shows up:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新页面，现在如果检查生成的`audio` HTML，影子DOM就会显示出来：
- en: '![](img/d2af88cb-b2c8-4b3a-9987-cedfb585e570.png)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2af88cb-b2c8-4b3a-9987-cedfb585e570.png)'
- en: Under `shadow-root`, there is a whole new world that the other part of the page
    and script do not have access to.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在`shadow-root`下，有一个其他部分的页面和脚本无法访问的全新世界。
- en: In the Shadow DOM realm, **shadow-root** (`#shadow-root` in the preceding code)
    is the root node for the generated DOM, hosted inside a **shadow host** (in this
    case the `audio` tag). When the browser renders this element/component, what gets
    rendered is the content from the *shadow root* and not the *shadow host*.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在影子DOM领域中，**shadow-root**（在上述代码中的`#shadow-root`）是生成的DOM的根节点，托管在**shadow host**（在这种情况下是`audio`标签）内。当浏览器渲染这个元素/组件时，渲染的是*shadow
    root*的内容，而不是*shadow host*的内容。
- en: From this discussion, we can conclude that Shadow DOM is a parallel DOM created
    by the browser that encapsulates the *markup*, *style*, and *behavior* (DOM manipulation)
    of an HTML element.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 从这次讨论中，我们可以得出结论，影子DOM是浏览器创建的一个并行DOM，它封装了HTML元素的*标记*、*样式*和*行为*（DOM操纵）。
- en: 'This was a gentle introduction to Shadow DOM. To learn more about how Shadow
    DOM works, we recommend this series by Rob Dodson: [http://bit.ly/shadow-dom-intro](http://bit.ly/shadow-dom-intro)'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对影子DOM的一个初步介绍。要了解更多关于影子DOM如何工作的信息，我们建议参阅Rob Dodson的系列文章：[http://bit.ly/shadow-dom-intro](http://bit.ly/shadow-dom-intro)
- en: But what has all this got to do with Angular? As it turns out, Angular components
    support some sort of view encapsulation too! This allows us to isolate styles
    for Angular components too.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 但这一切与Angular有什么关系呢？事实证明，Angular组件也支持某种视图封装！这也允许我们为Angular组件隔离样式。
- en: Shadow DOM and Angular components
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 影子DOM和Angular组件
- en: To understand how Angular employs the concept of Shadow DOM, we will first have
    to learn about styling Angular components.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解Angular如何应用影子DOM的概念，我们首先必须学习如何为Angular组件设置样式。
- en: When it comes to styling the apps built as part of this book, we have taken
    a conservative approach. Be it *Workout Builder* or the *Workout Runner* (*7 Minute
    Workout*) app, all the components that we built derive their style from *bootstrap
    CSS* and from custom styles defined in `app.css`. No component has defined its
    own style.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到对本书构建的应用进行样式设置时，我们采取了一种保守的方法。无论是*工作构建器*还是*工作程序*（*7分钟锻炼*）应用，我们构建的所有组件都派生其样式于*bootstrap
    CSS*和在`app.css`中定义的自定义样式。没有一个组件定义了自己的样式。
- en: While this adheres to the standard practices of web app development, sometimes
    we do need to deviate. This is especially true when we are building self-contained,
    packaged, and reusable components.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这符合Web应用开发的标准实践，但有时我们确实需要偏离。特别是当我们构建自包含、打包和可重用的组件时。
- en: Angular allows us to define styles specific to a component by using the `style`
    (for inline style) and `styleUrl` (external style sheet) properties on the `@Component`
    decorator. Let's play around with the `style` property and see what Angular does.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: Angular通过在`@Component`装饰器上使用`style`（用于内联样式）和`styleUrl`（外部样式表）属性，允许我们为组件定义特定样式。让我们尝试一下`style`属性，看看Angular会做什么。
- en: 'We will use the `AjaxButtonComponent` implementation as our playground for
    the next exercise. But before doing that, let''s look at the `AjaxButtonComponent`
    HTML as it stands now. The HTML tree for `AjaxButtonComponent` looks as follows:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将使用`AjaxButtonComponent`实现来作为我们的实验场所。但在这之前，让我们先看看`AjaxButtonComponent`的HTML。`AjaxButtonComponent`的HTML树如下：
- en: '![](img/4bf43910-2297-4538-836e-3652883be3d0.png)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4bf43910-2297-4538-836e-3652883be3d0.png)'
- en: 'Let''s override some styles using the `styles` property:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`styles`属性覆盖一些样式：
- en: '[PRE81]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The preceding *CSS selector* sets the `background` property to `green` for
    all HTML buttons. Save the preceding style and refresh the work builder page.
    The button style has been updated. No surprises here? Not true, there are some!
    Look at the generated HTML:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的*CSS选择器*将`background`属性设置为`green`，应用于所有HTML按钮。保存前面的样式并刷新工作构建器页面。按钮样式已更新。没有惊喜吗？不对，实际上有！看一下生成的HTML：
- en: '![](img/c7ed693e-b585-41c5-ac7a-06653cb7e447.png)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7ed693e-b585-41c5-ac7a-06653cb7e447.png)'
- en: 'There are some new attributes added to a number of HTML elements. And where
    have the recently defined styles landed? At the very top, inside the `head` tag:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 一些新属性被添加到许多HTML元素上。而最近定义的样式又落在了哪里呢？正如图片显示的，位于`head`标签的顶部：
- en: '![](img/536978ea-de4e-4426-9ae0-8cc238f36954.png)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![](img/536978ea-de4e-4426-9ae0-8cc238f36954.png)'
- en: The style defined in the `head` section has an extra scope with the `_ngcontent-c1`
    attribute (the attribute name may differ in your case). This scoping allows us
    to style `AjaxButtonComponent` independently and it cannot override any global
    styles.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在`head`部分定义的样式具有额外的作用域，带有`_ngcontent-c1`属性（在您的情况下可能属性名不同）。这种作用域允许我们独立地为`AjaxButtonComponent`设置样式，它不能覆盖任何全局样式。
- en: 'Angular does the same even if we use the `styleUrls` property. Suppose we had
    embedded the same CSS in an external CSS file and used this: `styleUrls:[''static/css/ajax-button.css'']`
    Angular would have still in-lined the styles into the `head` section, by fetching
    the CSS, parsing it, and then injecting it.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们使用了`styleUrls`属性，Angular也会这样做。假设我们已经将相同的CSS嵌入到外部CSS文件中并使用了这个：`styleUrls:['static/css/ajax-button.css']`，Angular仍然会将样式嵌入到`head`部分，通过获取CSS，解析它，然后注入它。
- en: The styles that by definition, should have affected the appearance of all the
    buttons in the application, have had no effect. Angular has scoped these styles.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，本应影响应用程序中所有按钮外观的样式没有产生任何效果。Angular对这些样式进行了作用域限定。
- en: This scoping makes sure that the component styles do not mess with the already
    defined style, but the reverse is not true. Global styles will still affect the
    component unless overridden in the component itself.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这种作用域确保组件样式不会干扰已定义的样式，但反之则不成立。全局样式仍会影响组件，除非在组件本身中进行覆盖。
- en: This scoped style is the result of Angular trying to emulate the Shadow DOM
    paradigm. The styles defined on the component never leak into the global styles.
    All this awesomeness without any effort!
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这种作用域样式是Angular试图模拟影子DOM范式的结果。组件上定义的样式永远不会泄漏到全局样式中。所有这些都是无需任何努力的美妙之处！
- en: If you are building components that define their own styles and want a degree
    of isolation, use the component's `style`/`styleUrl` property instead of using
    the old-school approach of having a common CSS file for all styles.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建定义自己样式并希望具有一定隔离性的组件，请使用组件的`style`/`styleUrl`属性，而不是使用有一个公共CSS文件的老式方法。
- en: 'We can further control this behavior by using a `@Component` decorator property
    called **encapsulation**. The API documentation for this property mentions:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用名为**encapsulation**的`@Component`装饰器属性进一步控制这种行为。该属性的API文档提到：
- en: '**encapsulation:** `ViewEncapsulation` Specify how the template and the styles
    should be encapsulated. The default is `ViewEncapsulation.Emulated` if the view
    has styles, otherwise `ViewEncapsulation.None`.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '**encapsulation:** `ViewEncapsulation`指定模板和样式应如何封装。如果视图具有样式，则默认为`ViewEncapsulation.Emulated`，否则为`ViewEncapsulation.None`。'
- en: As we can see, as soon as we set the style on the component, the encapsulation
    effect is `Emulated`. Otherwise, it is `None`.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，一旦我们在组件上设置了样式，封装效果就是`Emulated`。否则，它是`None`。
- en: If we explicitly set `encapsulation` to `ViewEncapsulation.None`, the scoping
    attributes are removed and the styles are embedded in the head section as normal
    styles.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`encapsulation`明确设置为`ViewEncapsulation.None`，则作用域属性将被移除，样式将嵌入到头部部分，就像普通样式一样。
- en: 'And then there is a third option, `ViewEncapsulation.Native`, in which Angular
    actually creates Shadow DOM for the components view. Set the `encapsulation` property
    on the `AjaxButtonComponent` implementation to `ViewEncapsulation.Native`, and
    now look at the rendered DOM:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第三种选项，`ViewEncapsulation.Native`，在其中Angular实际上为组件视图创建了影子DOM。将`AjaxButtonComponent`实现中的`encapsulation`属性设置为`ViewEncapsulation.Native`，现在查看渲染的DOM：
- en: '![](img/2a817126-9d31-49b5-982f-d80bac011607.png)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a817126-9d31-49b5-982f-d80bac011607.png)'
- en: '`AjaxButtonComponent` now has a shadow DOM! This also implies that the complete
    styling of the button is lost (style derived from bootstrap CSS) and the button
    needs to now define its own style.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '`AjaxButtonComponent`现在有了影子DOM！这也意味着按钮的完整样式丢失（来自bootstrap CSS的样式），现在按钮需要定义自己的样式。'
- en: Angular goes to great lengths to make sure that the components we develop can
    work independently and are reusable. Each component already has its own template
    and behavior. In addition to that, we can also encapsulate component styles, allowing
    us to create robust, standalone components.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: Angular竭尽全力确保我们开发的组件可以独立工作并且是可重用的。每个组件已经有了自己的模板和行为。除此之外，我们还可以封装组件样式，使我们能够创建健壮的独立组件。
- en: This brings us to the end of the chapter, and it's time to wrap up the chapter
    with what we've learned.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们来到了本章的结尾，是时候总结一下我们所学到的内容了。
- en: Summary
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As we conclude this chapter, we now have a better understanding of how directives
    work and how to use them effectively.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们结束本章，我们现在对指令的工作原理和如何有效使用它们有了更好的理解。
- en: We started the chapter by building a `RemoteValidatorDirective`, and learned
    a lot about Angular's support for *asynchronous validations*.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从构建`RemoteValidatorDirective`开始本章，了解了很多关于Angular对*异步验证*的支持。
- en: Next in line was `BusyIndicatorDirective`, again an excellent learning ground.
    We explored the **renderer** service, which allows component view manipulation
    in a platform-agnostic way. We also learned about **host bindings**, which let
    us bind to a host element's *events*, *attributes*, and *properties*.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`BusyIndicatorDirective`，再次是一个很好的学习机会。我们探索了**renderer**服务，它允许以跨平台的方式操纵组件视图。我们还了解了**host
    bindings**，它让我们绑定到主机元素的*事件*，*属性*和*属性*。
- en: Angular allows directives declared across the view lineage to be injected into
    the lineage. We dedicated a few sections to understanding this behavior.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: Angular允许将指令声明在视图血统中，以便将其注入到血统中。我们专门花了一些时间来理解这种行为。
- en: The third directive (component) that we created was `AjaxButtonComponent`. It
    helped us understand the critical difference between *content children* and *view
    children* for a component.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的第三个指令（组件）是`AjaxButtonComponent`。它帮助我们理解了*内容子级*和*视图子级*对于组件的关键区别。
- en: We also touched upon structural directives, where we explored the `NgIf` platform
    directive.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涉及了结构指令，其中我们探索了`NgIf`平台指令。
- en: Lastly, we looked at Angular's capabilities in terms of view encapsulation.
    We explored the basics of Shadow DOM and learned how the framework employs the
    Shadow DOM paradigm to provide view plus style encapsulation.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们从Angular在视图封装方面的能力来看。我们探索了Shadow DOM的基础知识，并了解了框架如何采用Shadow DOM范式来提供视图加样式封装。
- en: 'All of this is interesting from an educational standpoint. It doesn''t describe
    the elephant in the room, how do we manage our data when things get complicated?
    The concerns we have to deal with are:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '从教育的角度来看，所有这些都很有趣。它没有描述房间里的大象，当事情变得复杂时，我们如何管理我们的数据？我们需要处理的问题有:'
- en: Bidirectional data flow
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向数据流
- en: Lack of predictability (a change can lead to cascading changes)
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测性不足（一个变化可能导致级联变化）
- en: Spread out state (there is no one source of truth and our components can sit
    on a state that is partially updated)
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分散状态（没有真正的事实来源，我们的组件可以处于部分更新的状态）
- en: Let's keep these concerns in mind as we move on to [Chapter 5](c38d8d6b-23f1-4e6d-aee3-db093c15f2d4.xhtml), *1.21
    Gigawatt - Flux Pattern Explained*.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们牢记这些问题，当我们开始进入[第五章](c38d8d6b-23f1-4e6d-aee3-db093c15f2d4.xhtml)，“1.21 Gigawatt
    - Flux Pattern Explained”时。
