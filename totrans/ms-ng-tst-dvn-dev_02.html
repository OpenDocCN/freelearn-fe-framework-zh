<html><head></head><body>
		<div id="_idContainer032">
			<h1 id="_idParaDest-34" class="chapter-number"><a id="_idTextAnchor049"/><st c="0">2</st></h1>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor050"/><st c="2">Using Jasmine and Karma to Test Angular Applications</st></h1>
			<p><st c="54">Jasmine</st><a id="_idIndexMarker084"/><st c="62"> and Karma</st><a id="_idIndexMarker085"/><st c="72"> are two powerful tools that developers can use to test their Angular applications. </st><st c="156">Testing is an essential part of the development process as it helps ensure that the application works as expected and avoids any potential bugs </st><span class="No-Break"><st c="300">or issues.</st></span></p>
			<p><st c="310">Jasmine is a </st><strong class="bold"><st c="324">behavior-driven development</st></strong><st c="351"> (</st><strong class="bold"><st c="353">BDD</st></strong><st c="356">) framework</st><a id="_idIndexMarker086"/><st c="368"> for testing JavaScript code. </st><st c="398">It provides a simple and readable syntax for writing tests, making it easier to understand and maintain the code. </st><st c="512">With Jasmine, developers can define test suites and test cases, and then use various matchers to check the expected behavior of </st><span class="No-Break"><st c="640">their code.</st></span></p>
			<p><st c="651">Karma, on the other hand, is a test runner that allows developers to execute their tests in multiple browsers and environments. </st><st c="780">It provides a seamless integration with Jasmine, allowing developers to easily run their Jasmine tests in different browsers and get real-time feedback on the test results. </st><st c="953">Karma also offers additional features, such as code coverage reporting and continuous </st><span class="No-Break"><st c="1039">integration support.</st></span></p>
			<p><st c="1059">Using Jasmine and Karma together can greatly enhance the testing process for Angular applications. </st><st c="1159">Developers can write comprehensive test suites using Jasmine’s expressive syntax, and then use Karma to run these tests in various browsers, ensuring compatibility across different environments. </st><st c="1354">This helps catch any potential issues or bugs early on and promotes a more robust and </st><span class="No-Break"><st c="1440">reliable application.</st></span></p>
			<p><st c="1461">In this chapter, we will look into the basics of using Jasmine and Karma for testing Angular applications. </st><st c="1569">We will learn how to set up the testing environment, write unit tests with Jasmine, and configure Karma to run the tests in </st><span class="No-Break"><st c="1693">different browsers.</st></span></p>
			<p><st c="1712">The following topics will be covered in </st><span class="No-Break"><st c="1753">this chapter:</st></span></p>
			<ul>
				<li><st c="1766">Mastering Jasmine’s unit </st><span class="No-Break"><st c="1792">testing techniques</st></span></li>
				<li><st c="1810">Writing your </st><a id="_idIndexMarker087"/><st c="1824">first unit tests in Angular related to </st><strong class="bold"><st c="1863">test-driven </st></strong><span class="No-Break"><strong class="bold"><st c="1875">development</st></strong></span><span class="No-Break"><st c="1886"> (</st></span><span class="No-Break"><strong class="bold"><st c="1888">TDD</st></strong></span><span class="No-Break"><st c="1891">)</st></span></li>
				<li><st c="1893">Utilizing code coverage and test result analysis </st><span class="No-Break"><st c="1942">with Karma</st></span></li>
			</ul>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor051"/><st c="1952">Technical requirements</st></h1>
			<p><st c="1975">To follow along with the examples and exercises in this chapter, you will need to have a basic understanding of Angular and TypeScript, as well as the following </st><span class="No-Break"><st c="2137">technical requirements:</st></span></p>
			<ul>
				<li><st c="2160">Node.js LTS and npm LTS installed on </st><span class="No-Break"><st c="2198">your computer</st></span></li>
				<li><st c="2211">Angular 17 or later CLI </st><span class="No-Break"><st c="2236">installed globally</st></span></li>
				<li><st c="2254">A code editor, such as Visual Studio Code, installed on </st><span class="No-Break"><st c="2311">your computer</st></span></li>
			</ul>
			<p><st c="2324">The code files of this chapter can be found </st><span class="No-Break"><st c="2369">at </st></span><a href="https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%202"><span class="No-Break"><st c="2372">https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%202</st></span></a><span class="No-Break"><st c="2470">.</st></span></p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor052"/><st c="2471">Mastering Jasmine’s unit testing techniques</st></h1>
			<p><st c="2515">In this section, we’ll explore the Jasmine framework by writing descriptive test suites, utilizing matchers, using spies for function testing, and testing asynchronous code. </st><st c="2690">By leveraging these techniques, you can ensure the quality and reliability of your </st><span class="No-Break"><st c="2773">code base.</st></span></p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor053"/><st c="2783">What is Jasmine?</st></h2>
			<p><st c="2800">Jasmine</st><a id="_idIndexMarker088"/><st c="2808"> is a widely used testing framework for JavaScript that’s commonly employed for writing tests for web applications and Node.js projects. </st><st c="2945">With its clean and expressive syntax, Jasmine allows developers to create easy-to-understand and maintainable test suites and cases. </st><st c="3078">It offers built-in functionalities for assertions, test spies, and asynchronous testing. </st><st c="3167">Jasmine seamlessly integrates with numerous libraries and frameworks, including AngularJS and React, enabling developers to compose comprehensive and dependable tests for JavaScript applications. </st><st c="3363">Its popularity stems from its simplicity, flexibility, and ability to facilitate the creation of robust and reliable tests for </st><span class="No-Break"><st c="3490">JavaScript code.</st></span></p>
			<p><st c="3506">With Jasmine, developers can structure their tests using a BDD style, making it easy to write tests that are both descriptive and readable. </st><st c="3647">It provides a set of built-in functions for assertions, which allow developers to verify the expected behavior of their code. </st><st c="3773">These assertions cover a wide range of scenarios and make it simple to write tests that validate the correctness of the code </st><span class="No-Break"><st c="3898">being tested.</st></span></p>
			<p><st c="3911">Jasmine also includes features such as test spies, which enable developers to track function calls and arguments, as well as</st><a id="_idIndexMarker089"/><st c="4036"> mock and stub function behavior. </st><st c="4070">This helps in testing code that interacts with other components or </st><span class="No-Break"><st c="4137">external dependencies.</st></span></p>
			<p><st c="4159">Furthermore, Jasmine supports asynchronous testing, making it easy to write tests for code that involves asynchronous operations such as AJAX requests or timers. </st><st c="4322">It provides mechanisms to handle asynchronous tasks and ensure that tests wait for completion before </st><span class="No-Break"><st c="4423">making assertions.</st></span></p>
			<p><st c="4441">Jasmine is highly extensible and can be used in conjunction with various libraries and frameworks, such as AngularJS, Angular, and React. </st><st c="4580">It integrates seamlessly with these ecosystems, allowing developers to write comprehensive and reliable tests for their </st><span class="No-Break"><st c="4700">JavaScript applications.</st></span></p>
			<p><st c="4724">Overall, Jasmine’s simplicity, flexibility, and </st><a id="_idIndexMarker090"/><st c="4773">comprehensive feature set have contributed to its popularity as a testing framework for JavaScript. </st><st c="4873">It empowers developers to write robust and reliable tests, ultimately leading to higher-quality code and more </st><span class="No-Break"><st c="4983">confident deployments.</st></span></p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor054"/><st c="5005">Writing descriptive test suites</st></h2>
			<p><st c="5037">One of the fundamental principles of effective unit testing is writing descriptive test suites. </st><st c="5134">By logically organizing your tests and using descriptive names, you make it easier for yourself and other developers to understand the purpose and behavior of each test. </st><st c="5304">In this section, we will explore strategies for creating meaningful test suite names and describing the expected behavior in clear and concise language. </st><st c="5457">Additionally, we will discuss how descriptive test suites can serve as documentation for </st><span class="No-Break"><st c="5546">future reference.</st></span></p>
			<p><st c="5563">A descriptive test suite is </st><a id="_idIndexMarker091"/><st c="5592">a collection of related test cases that focuses on a specific functionality or component of your code. </st><st c="5695">It serves as a documentation tool and helps developers understand the purpose and behavior of each test. </st><st c="5800">Descriptive test suites are essential for maintaining code quality, facilitating collaboration among team members, and ensuring that tests remain relevant and up-to-date over time. </st><st c="5981">By investing time in creating descriptive test suites, you can improve the maintainability and readability of your </st><span class="No-Break"><st c="6096">test code.</st></span></p>
			<p><st c="6106">Let’s consider a simple scenario where we have a JavaScript function called </st><strong class="source-inline"><st c="6183">calculateTotal</st></strong><st c="6197"> that calculates the total price of items in a shopping cart. </st><st c="6259">We want to write a test to ensure that the function returns the correct total when given a set of items with their </st><span class="No-Break"><st c="6374">respective prices.</st></span></p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor055"/><st c="6392">Choosing meaningful names</st></h2>
			<p><st c="6418">The first step in creating</st><a id="_idIndexMarker092"/><st c="6445"> descriptive test suites is choosing meaningful names for your test suites and test cases. </st><st c="6536">Use clear and concise language to describe the functionality or behavior being tested. </st><st c="6623">Avoid ambiguous or generic names that don’t provide enough context. </st><st c="6691">For example, instead of naming a test suite “Test Suite 1,” consider naming it “User Authentication Tests” to convey the purpose of the tests. </st><st c="6834">Meaningful names make it easier for developers to locate specific tests and understand their purpose, even when revisiting the code base after a </st><span class="No-Break"><st c="6979">long time.</st></span></p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor056"/><st c="6989">Structuring test suites</st></h2>
			<p><st c="7013">Organizing your</st><a id="_idIndexMarker093"/><st c="7029"> test suites in a logical and hierarchical structure is crucial for creating descriptive test suites in Jasmine. </st><st c="7142">A well-structured test suite mirrors the structure of your code base, making it easier to locate and understand specific tests. </st><st c="7270">Group related tests together to improve readability and maintainability. </st><st c="7343">For example, if you are testing a user authentication module, create a test suite specifically for login functionality and another for registration. </st><st c="7492">This separation helps you isolate and focus on specific features, making it easier to identify and resolve issues. </st><st c="7607">Additionally, consider using nested describe blocks to further organize your tests hierarchically. </st><st c="7706">Here’s </st><span class="No-Break"><st c="7713">an example:</st></span></p>
			<pre class="source-code"><st c="7724">
describe("User Authentication", () =&gt; {
  describe("Login", () =&gt; {
    // Login-related test cases
  });
  describe("Registration", () =&gt; {
    // Registration-related test cases
  });
});</st></pre>			<h2 id="_idParaDest-42"><a id="_idTextAnchor057"/><st c="7898">Writing clear and concise test descriptions</st></h2>
			<p><st c="7942">Within each test </st><a id="_idIndexMarker094"/><st c="7960">case, write clear and concise descriptions that accurately describe the expected behavior. </st><st c="8051">Use language that is easily understandable and avoids technical jargon whenever possible. </st><st c="8141">A well-written test description should provide enough information for you and others to understand the purpose of the test without needing to dive into the implementation details. </st><st c="8321">Consider using the “should” format to describe the expected behavior – for example, “should correctly calculate the total for a cart with multiple items.” By using descriptive language, future developers can quickly grasp the intent of the test and identify any deviations from the </st><span class="No-Break"><st c="8603">expected behavior.</st></span></p>
			<p><st c="8621">In addition to the test description, it is also helpful to include comments within the test code to provide further clarification or context where needed. </st><st c="8777">These comments can explain the reasoning behind certain assertions or provide additional information about the test scenario. </st><st c="8903">However, it is important to strike a balance and avoid excessive commenting that may clutter the </st><span class="No-Break"><st c="9000">test code.</st></span></p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor058"/><st c="9010">Maintaining and updating descriptive test suites</st></h2>
			<p><st c="9059">Descriptive</st><a id="_idIndexMarker095"/><st c="9071"> test suites are not a one-time effort but require ongoing maintenance and updates as the code base evolves. </st><st c="9180">It is essential to review and update test suites regularly to ensure they remain relevant and accurate. </st><st c="9284">When making changes to the code, developers should also update the corresponding tests to reflect the updated behavior. </st><st c="9404">Additionally, if a test case becomes obsolete or redundant, it should be removed </st><span class="No-Break"><st c="9485">or refactored.</st></span></p>
			<p><st c="9499">When up</st><a id="_idTextAnchor059"/><st c="9507">dating </st><a id="_idIndexMarker096"/><st c="9515">test suites, it is crucial to keep their descriptive nature intact. </st><st c="9583">If a test case needs significant changes, it may be beneficial to create a new test case with an appropriate description instead of modifying the existing one. </st><st c="9743">This helps maintain the clarity and transparency of the </st><span class="No-Break"><st c="9799">test suite.</st></span></p>
			<p><st c="9810">Let’s </st><a id="_idIndexMarker097"/><st c="9817">consider a simple scenario where we have a JavaScript </st><a id="_idIndexMarker098"/><st c="9871">function called </st><strong class="source-inline"><st c="9887">calculateTotal</st></strong><st c="9901"> that calculates the total price of items in a shopping cart. </st><st c="9963">We want to write a test to ensure that the function returns the correct total when given a set of items with their </st><span class="No-Break"><st c="10078">respective prices:</st></span></p>
			<pre class="source-code"><st c="10096">
// Function under test
function calculateTotal(items) {
  let total = 0;
  items.forEach(item =&gt; {
    total += item.price;
  });
  return total;
}
// Test suite
describe("calculateTotal function", () =&gt; {
  // Test case 1: Calculate total for an empty cart
  it("should return 0 for an empty cart", () =&gt; {
    const cart = [];
    const result = calculateTotal(cart);
    expect(result).toBe(0);
  });
  // Test case 2: Calculate total for a cart with multiple items
  it("should correctly calculate the total for a cart with multiple items", () =&gt; {
    const cart = [
      { name: "Item 1", price: 10 },
      { name: "Item 2", price: 15 },
      { name: "Item 3", price: 20 }
    ];
    const result = calculateTotal(cart);
    expect(result).toBe(45);
  });
});</st></pre>			<p><st c="10795">In the</st><a id="_idIndexMarker099"/><st c="10802"> preceding example, we have created a test suite for </st><a id="_idIndexMarker100"/><st c="10855">the </st><strong class="source-inline"><st c="10859">calculateTotal</st></strong><st c="10873"> function. </st><st c="10884">Within the test suite, we have two test cases, and the descriptions of the test cases clearly state what behavior is </st><span class="No-Break"><st c="11001">being tested:</st></span></p>
			<ul>
				<li><st c="11014">The first test case, </st><em class="italic"><st c="11036">“should return 0 for an empty cart,”</st></em><st c="11072"> verifies that the function correctly handles an empty shopping cart and returns a total </st><span class="No-Break"><st c="11161">of 0</st></span></li>
				<li><st c="11165">The second test case, </st><em class="italic"><st c="11188">“should correctly calculate the total for a cart with multiple items,”</st></em><st c="11258"> tests the function with a cart containing multiple items and checks if the calculated total is </st><span class="No-Break"><st c="11354">as expected</st></span></li>
			</ul>
			<p><st c="11365">By providing descriptive test case descriptions, other developers can easily understand the intent and behavior of each test. </st><st c="11492">These descriptions act as documentation, making it easier to maintain and update the tests as the code </st><span class="No-Break"><st c="11595">base evolves.</st></span></p>
			<p><st c="11608">In the next section, we’ll look at how to write our first unit tests using </st><span class="No-Break"><st c="11684">TDD principles.</st></span></p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor060"/><st c="11699">Writing your first unit tests in an Angular project</st></h1>
			<p><st c="11751">Unit testing</st><a id="_idIndexMarker101"/><st c="11764"> is a critical aspect of Angular development that ensures code quality, reliability, and maintainability. </st><st c="11870">TDD is </st><a id="_idIndexMarker102"/><st c="11877">a software development approach that emphasizes writing tests before implementing the actual code. </st><st c="11976">In this section, you’ll learn how to write your first unit tests in an Angular project while following the principles of TDD. </st><st c="12102">By leveraging the Jasmine testing framework and Angular’s testing utilities, developers can create effective and robust unit tests that verify the correctness of </st><span class="No-Break"><st c="12264">their code.</st></span></p>
			<p><st c="12275">We’ll be </st><a id="_idIndexMarker103"/><st c="12285">using the project we created in </st><a href="B21146_01.xhtml#_idTextAnchor018"><span class="No-Break"><em class="italic"><st c="12317">Chapter 1</st></em></span></a><st c="12326"> to practice. </st><st c="12340">Follow these</st><a id="_idIndexMarker104"/><st c="12352"> steps to write your first </st><span class="No-Break"><st c="12379">unit test:</st></span></p>
			<ol>
				<li><st c="12389">Create a new component called </st><strong class="source-inline"><st c="12420">CalculatorComponent</st></strong><st c="12439"> by running the </st><span class="No-Break"><st c="12455">following command:</st></span><pre class="source-code">
<strong class="bold"><st c="12473">$ ng g m calculator --route calculator --module=app.module</st></strong></pre><p class="list-inset"><st c="12532">After creating the component with the preceding command line, a </st><strong class="source-inline"><st c="12597">calculator.component.spec.ts</st></strong><st c="12625"> file will be created in the </st><strong class="source-inline"><st c="12654">src/ app/calculator</st></strong><st c="12673"> folder. </st><st c="12682">When you open the file, you’ll see the following code </st><span class="No-Break"><st c="12736">by default:</st></span></p><pre class="source-code"><st c="12747"> import { ComponentFixture, TestBed } from '@angular/core/testing';
import { CalculatorComponent } from './calculator.component';
describe('CalculatorComponent', () =&gt; {
let calculator: CalculatorComponent;
let fixture: ComponentFixture&lt;CalculatorComponent&gt;;
beforeEach(async () =&gt; {
await TestBed.configureTestingModule({
declarations: [ CalculatorComponent ]
})
.compileComponents();
fixture = TestBed.createComponent(CalculatorComponent);
calculator = fixture.componentInstance;
fixture.detectChanges();
});
it('should create', () =&gt; {
expect(calculator).toBeTruthy();
});
});</st></pre><p class="list-inset"><st c="13326">In the</st><a id="_idIndexMarker105"/><st c="13333"> preceding generated code, we have a</st><a id="_idIndexMarker106"/><st c="13369"> test suite where we have used the </st><strong class="source-inline"><st c="13404">describe</st></strong><st c="13412"> function, providing a descriptive name for the component under test. </st><st c="13482">Within the test suite, we have a </st><strong class="source-inline"><st c="13515">beforeEach</st></strong><st c="13525"> block to set up the test environment. </st><st c="13564">The </st><strong class="source-inline"><st c="13568">TestBed.configureTestingModule</st></strong><st c="13598"> method is used to configure the test module and provide the necessary dependencies. </st><st c="13683">The </st><strong class="source-inline"><st c="13687">calculator</st></strong><st c="13697"> variable is then assigned to an instance of </st><strong class="source-inline"><st c="13742">CalculatorComponent</st></strong><st c="13761"> using the </st><span class="No-Break"><strong class="source-inline"><st c="13772">TestBed.inject</st></strong></span><span class="No-Break"><st c="13786"> method.</st></span></p><p class="list-inset"><st c="13794">Our </st><strong class="source-inline"><st c="13799">CalculatorComponent</st></strong><st c="13818"> component will enable us to perform basic arithmetic operations. </st><st c="13884">To write a unit test using TDD, we’ll start by creating a test case that verifies the component’s </st><span class="No-Break"><st c="13982">expected behavior.</st></span></p></li>				<li><st c="14000">Now, we’ll </st><a id="_idIndexMarker107"/><st c="14012">write the actual test case using the </st><strong class="source-inline"><st c="14049">it</st></strong><st c="14051"> function. </st><st c="14062">In </st><a id="_idIndexMarker108"/><st c="14065">this case, we’ll test the </st><strong class="source-inline"><st c="14091">add</st></strong><st c="14094"> method of </st><strong class="source-inline"><st c="14105">CalculatorComponent</st></strong><st c="14124"> by passing it two numbers and expecting the result to be </st><strong class="source-inline"><st c="14182">5</st></strong><st c="14183">. The </st><strong class="source-inline"><st c="14189">expect</st></strong><st c="14195"> function is used to define the expected behavior and check the actual result. </st><st c="14274">The following code must be added to the test suite – that is, inside the </st><span class="No-Break"><strong class="source-inline"><st c="14347">describe</st></strong></span><span class="No-Break"><st c="14355"> function:</st></span><pre class="source-code"><st c="14365">
  it('should add two numbers correctly', () =&gt; {
    const result = calculator.add(2, 3);
    expect(result).toBe(5);
 });
});</st></pre></li>				<li><st c="14481">You will get an error in your code editor telling you that the </st><strong class="source-inline"><st c="14545">add</st></strong><st c="14548"> function </st><span class="No-Break"><st c="14558">doesn’t exist:</st></span></li>
			</ol>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B21146_02_1.jpg" alt="Figure 2.1 – Code error"/><st c="14572"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="14684">Figure 2.1 – Code error</st></p>
			<p class="list-inset"><st c="14707">This is normal as it hasn’t been </st><span class="No-Break"><st c="14741">created yet.</st></span></p>
			<p class="list-inset"><st c="14753">Upon</st><a id="_idIndexMarker109"/><st c="14758"> returning to our Karma server, we’ll see that</st><a id="_idIndexMarker110"/><st c="14804"> our test case isn’t displayed in </st><strong class="source-inline"><st c="14838">CalculatorComponent</st></strong><st c="14857"> and that in the terminal, we have an error related to the non-existence of the function and a message indicating that no test </st><span class="No-Break"><st c="14984">has succeeded.</st></span></p>
			<p class="list-inset"><st c="14998">Don’t panic – it’s the red of TDD! </st><span class="No-Break"><st c="15034">Well done!</st></span></p>
			<ol>
				<li value="4"><st c="15044">Next, we will implement the </st><strong class="source-inline"><st c="15073">add</st></strong><st c="15076"> function in </st><strong class="source-inline"><st c="15089">calculator.component.ts</st></strong><st c="15112">. Having defined our first test case, we can proceed to implement </st><strong class="source-inline"><st c="15178">calculator.component.ts</st></strong><st c="15201"> for the test to pass. </st><st c="15224">Following the TDD approach, write the minimum amount of code necessary to pass </st><span class="No-Break"><st c="15303">the tests:</st></span><pre class="source-code"><st c="15313">
add(a: number, b: number): number {
    return a + b;
  }</st></pre><p class="list-inset"><st c="15365">You’ll see the following result on your </st><span class="No-Break"><st c="15406">Karma server:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/B21146_02_2.jpg" alt="Figure 2.2 – The test succeeded"/><st c="15419"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="15665">Figure 2.2 – The test succeeded</st></p>
			<p class="list-inset"><st c="15696">In your terminal, you will receive the </st><span class="No-Break"><st c="15736">following message:</st></span></p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/B21146_02_3.jpg" alt="Figure 2.3 – The test was executed successfully"/><st c="15754"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="15890">Figure 2.3 – The test was executed successfully</st></p>
			<p class="list-inset"><st c="15937">With that, we’re</st><a id="_idIndexMarker111"/><st c="15954"> at the green stage of TDD and writing the </st><a id="_idIndexMarker112"/><st c="15997">minimum amount of code needed for our test to pass. </st><span class="No-Break"><st c="16049">Well done!</st></span></p>
			<p><st c="16059">Once the tests have passed, you can refactor the code to improve its design, readability, and maintainability. </st><st c="16171">Refactoring is an essential step in the TDD process as it helps eliminate duplication and improves code structure and overall quality. </st><st c="16306">It is essential to ensure that tests continue to run after refactoring. </st><st c="16378">Regularly reviewing and updating tests as the code base evolves will help maintain the integrity and reliability of </st><span class="No-Break"><st c="16494">unit tests.</st></span></p>
			<p><st c="16505">In our example, we don’t need to refactor the test. </st><st c="16558">Don’t worry – we’ll have the opportunity to do so in </st><a href="B21146_03.xhtml#_idTextAnchor065"><span class="No-Break"><em class="italic"><st c="16611">Chapter 3</st></em></span></a><span class="No-Break"><st c="16620">.</st></span></p>
			<p><st c="16621">In the next section, we’ll look at how to use code coverage and test result analysis </st><span class="No-Break"><st c="16707">with Karma.</st></span></p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor061"/><st c="16718">Utilizing code coverage and test result analysis with Karma</st></h1>
			<p><st c="16778">Code coverage </st><a id="_idIndexMarker113"/><st c="16793">and test result analysis</st><a id="_idIndexMarker114"/><st c="16817"> are essential aspects of the software development process. </st><st c="16877">By measuring code coverage, developers can assess the effectiveness of their unit tests and identify areas that require additional testing. </st><st c="17017">Karma, a popular testing framework in the JavaScript ecosystem, provides built-in support for code coverage and test result analysis. </st><st c="17151">In this section, we’ll learn how to leverage Karma to measure code coverage, generate detailed reports, and analyze test results. </st><st c="17281">By utilizing these features, developers can ensure comprehensive testing and improve the overall quality and reliability of </st><span class="No-Break"><st c="17405">their code.</st></span></p>
			<p><st c="17416">Before going any further, it’s worth noting that all the configurations we’ll be looking at are already present in our Angular project. </st><st c="17553">When we create our project, Angular takes care of all </st><span class="No-Break"><st c="17607">the configuration.</st></span></p>
			<p><st c="17625">Here</st><a id="_idIndexMarker115"/><st c="17630"> are</st><a id="_idIndexMarker116"/><st c="17634"> the different</st><a id="_idIndexMarker117"/><st c="17648"> steps </st><a id="_idIndexMarker118"/><st c="17655">Angular performs </st><span class="No-Break"><st c="17672">for us:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="17679">Step 1 – setting up Karma with </st></strong><span class="No-Break"><strong class="bold"><st c="17711">code coverage</st></strong></span><span class="No-Break"><st c="17724">:</st></span><p class="list-inset"><st c="17726">To </st><a id="_idIndexMarker119"/><st c="17729">utilize code coverage </st><a id="_idIndexMarker120"/><st c="17751">with Karma, start by</st><a id="_idIndexMarker121"/><st c="17771"> installing</st><a id="_idIndexMarker122"/><st c="17782"> the </st><span class="No-Break"><st c="17787">necessary dependencies:</st></span></p><pre class="source-code">
<strong class="bold"><st c="17810">$ npm install --save-dev karma-coverage</st></strong></pre><p class="list-inset"><st c="17850">Next, configure Karma to generate code coverage reports. </st><st c="17908">Update your Karma configuration file (</st><strong class="source-inline"><st c="17946">karma.conf.js</st></strong><st c="17960">) with the </st><span class="No-Break"><st c="17972">following changes:</st></span></p><pre class="source-code"><st c="17990">module.exports = function(config) {
  config.set({
    // ...
    </st><st c="18047">reporters: ['progress', 'coverage'],
    coverageReporter: {
      dir: 'coverage/',
      reporters: [
        { type: 'html', subdir: 'report-html' },
        { type: 'lcov', subdir: 'report-lcov' }
      ]
    },
    // ...
  </st><st c="18228">});
};</st></pre><p class="list-inset"><st c="18234">This configuration specifies the reporters to be used (</st><strong class="source-inline"><st c="18290">progress</st></strong><st c="18299"> for test progress and </st><strong class="source-inline"><st c="18322">coverage</st></strong><st c="18330"> for code coverage). </st><st c="18351">The </st><strong class="source-inline"><st c="18355">coverageReporter</st></strong><st c="18371"> section defines the output directory and the types of reports to generate (HTML </st><span class="No-Break"><st c="18452">and LCOV).</st></span></p></li>				<li><strong class="bold"><st c="18462">Step 2 – running tests and generating code </st></strong><span class="No-Break"><strong class="bold"><st c="18506">coverage reports</st></strong></span><span class="No-Break"><st c="18522">:</st></span><p class="list-inset"><st c="18524">After configuring Karma for code coverage, run your tests as usual. </st><st c="18592">Karma will now generate code coverage reports alongside the test results. </st><st c="18666">These coverage reports provide insights into which parts of your code base are covered by tests and which areas require </st><span class="No-Break"><st c="18786">additional testing.</st></span></p><p class="list-inset"><st c="18805">Once the tests have finished running, navigate to the </st><strong class="source-inline"><st c="18860">coverage</st></strong><st c="18868"> directory to view the generated reports. </st><st c="18910">Open the HTML report (</st><strong class="source-inline"><st c="18932">coverage/report-html/index.html</st></strong><st c="18964">) in a web browser to visualize the code coverage details. </st><st c="19024">The report highlights covered lines, uncovered lines, and overall coverage percentages. </st><st c="19112">Additionally, the LCOV report (</st><strong class="source-inline"><st c="19143">coverage/report-lcov/lcov-report/index.html</st></strong><st c="19187">) provides a more detailed breakdown of </st><span class="No-Break"><st c="19228">code coverage.</st></span></p></li>
				<li><strong class="bold"><st c="19242">Step 3 – analyzing the </st></strong><span class="No-Break"><strong class="bold"><st c="19266">test results</st></strong></span><span class="No-Break"><st c="19278">:</st></span><p class="list-inset"><st c="19280">Karma also offers features to analyze the test results, including test reporting and integration with </st><a id="_idIndexMarker123"/><st c="19382">popular </st><strong class="bold"><st c="19390">continuous integration</st></strong><st c="19412"> (</st><strong class="bold"><st c="19414">CI</st></strong><st c="19416">) tools. </st><st c="19426">By leveraging these capabilities, developers can gain insights into test failures, identify patterns, and track the overall health of their </st><span class="No-Break"><st c="19566">test suite.</st></span></p><p class="list-inset"><st c="19577">Karma </st><a id="_idIndexMarker124"/><st c="19584">provides various reporters that offer </st><a id="_idIndexMarker125"/><st c="19622">different levels of detail in the test output. </st><st c="19669">For </st><a id="_idIndexMarker126"/><st c="19673">example, </st><strong class="source-inline"><st c="19682">mocha-reporter</st></strong><st c="19696"> displays</st><a id="_idIndexMarker127"/><st c="19705"> detailed information about test failures, including stack traces and error messages, whereas </st><strong class="source-inline"><st c="19799">junit-reporter</st></strong><st c="19813"> generates JUnit-style XML reports that can be consumed by CI tools for </st><span class="No-Break"><st c="19885">further analysis.</st></span></p><p class="list-inset"><st c="19902">To integrate Karma with CI tools, configure the respective plugin or reporter in your Karma configuration file. </st><st c="20015">For example, to generate JUnit reports for Jenkins, add the </st><strong class="source-inline"><st c="20075">karma-junit-reporter</st></strong><st c="20095"> plugin and configure </st><span class="No-Break"><st c="20117">it accordingly.</st></span></p></li>
				<li><strong class="bold"><st c="20132">Step 4 – utilizing thresholds and </st></strong><span class="No-Break"><strong class="bold"><st c="20167">quality gates</st></strong></span><span class="No-Break"><st c="20180">:</st></span><p class="list-inset"><st c="20182">Karma</st><a id="_idIndexMarker128"/><st c="20187"> allows developers to define thresholds</st><a id="_idIndexMarker129"/><st c="20226"> and quality gates for code coverage and </st><a id="_idIndexMarker130"/><st c="20267">test results. </st><st c="20281">By setting these thresholds, developers </st><a id="_idIndexMarker131"/><st c="20321">can establish the minimum requirements for code coverage and test success rates. </st><st c="20402">This ensures that the code base maintains a certain level of quality and reduces the risk of shipping untested or poorly </st><span class="No-Break"><st c="20523">covered code.</st></span></p><p class="list-inset"><st c="20536">To set thresholds for code coverage, update your Karma configuration file </st><span class="No-Break"><st c="20611">as follows:</st></span></p><pre class="source-code"><st c="20622">
module.exports = function(config) {
  config.set({
    // ...
    </st><st c="20679">coverageReporter: {
      // ...
      </st><st c="20706">check: {
        global: {
          statements: 80,
          branches: 80,
          functions: 80,
          lines: 80
        }
      }
    },
    // ...
  </st><st c="20794">});
};</st></pre><p class="list-inset"><st c="20800">In this </st><a id="_idIndexMarker132"/><st c="20809">example, the thresholds have been set </st><a id="_idIndexMarker133"/><st c="20847">to 80% for statements, branches, functions, and</st><a id="_idIndexMarker134"/><st c="20894"> lines. </st><st c="20902">If any of these thresholds are not</st><a id="_idIndexMarker135"/><st c="20936"> met, Karma will report a failed </st><span class="No-Break"><st c="20969">test result.</st></span></p></li>			</ul>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor062"/><st c="20981">Code coverage visualization</st></h2>
			<p><st c="21009">In our project, we started by writing</st><a id="_idIndexMarker136"/><st c="21047"> tests on </st><strong class="source-inline"><st c="21057">CalculatorComponent</st></strong><st c="21076">. Now, we can see the code coverage using Karma. </st><st c="21125">Let’s run the following command in our </st><span class="No-Break"><st c="21164">project’s terminal:</st></span></p>
			<pre class="console">
<strong class="bold"><st c="21183">$ ng test –code-coverage</st></strong></pre>			<p><st c="21208">After executing the preceding command, we’ll observe the following </st><span class="No-Break"><st c="21276">three things:</st></span></p>
			<ul>
				<li><st c="21289"> In the terminal, we’ll have the following, if all </st><span class="No-Break"><st c="21340">goes well:</st></span></li>
			</ul>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B21146_02_4.jpg" alt="Figure 2.4 – Test coverage in the terminal"/><st c="21350"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="21893">Figure 2.4 – Test coverage in the terminal</st></p>
			<ul>
				<li><st c="21935">Karma launches our browser, showing us the various tests that were </st><span class="No-Break"><st c="22003">carried out:</st></span></li>
			</ul>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B21146_02_5.jpg" alt="Figure 2.5 – A successful test"/><st c="22015"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="22376">Figure 2.5 – A successful test</st></p>
			<ul>
				<li><st c="22406"> A </st><strong class="source-inline"><st c="22409">coverage</st></strong><st c="22417"> folder</st><a id="_idIndexMarker137"/><st c="22424"> is created in our </st><span class="No-Break"><st c="22443">project’s arborescence:</st></span></li>
			</ul>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B21146_02_6.jpg" alt="Figure 2.6 – The test coverage folder"/><st c="22466"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="22644">Figure 2.6 – The test coverage folder</st></p>
			<p><st c="22681">Inside is an </st><strong class="source-inline"><st c="22695">index.html</st></strong><st c="22705"> file. </st><st c="22712">When we launch the file in the browser, we’ll see a table summarizing all the files tested, and in each file, we’re told how much of a given piece of code has </st><span class="No-Break"><st c="22871">been tested.</st></span></p>
			<p><st c="22883">The following </st><a id="_idIndexMarker138"/><st c="22898">screenshots show </st><span class="No-Break"><st c="22915">test coverage:</st></span></p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B21146_02_7.jpg" alt="Figure 2.7 – Test coverage visualization on the web – part 1"/><st c="22929"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="23233">Figure 2.7 – Test coverage visualization on the web – part 1</st></p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B21146_02_8.jpg" alt="Figure 2.8 – Test coverage visualization on the web – part 2"/><st c="23293"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="23574">Figure 2.8 – Test coverage visualization on the web – part 2</st></p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B21146_02_9.jpg" alt="Figure 2.9 – Test coverage visualization on the web – part 3"/><st c="23634"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="24073">Figure 2.9 – Test coverage visualization on the web – part 3</st></p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B21146_02_10.jpg" alt="Figure 2.10 – Test coverage visualization on the web – part 4"/><st c="24133"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="24435">Figure 2.10 – Test coverage visualization on the web – part 4</st></p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B21146_02_11.jpg" alt="Figure 2.11 – Test coverage visualization on the web – part 5"/><st c="24496"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="25038">Figure 2.11 – Test coverage visualization on the web – part 5</st></p>
			<p><st c="25099">By utilizing code</st><a id="_idIndexMarker139"/><st c="25117"> coverage and test result analysis with Karma, developers can enhance their testing practices and ensure comprehensive code coverage. </st><st c="25251">Karma’s built-in support for code coverage enables developers to measure the effectiveness of their tests and identify areas that require additional attention. </st><st c="25411">Additionally, Karma’s test reporting and integration capabilities allow for deeper analysis of test results, enabling developers to track the health of their test suite and identify patterns in test failures. </st><st c="25620">By setting thresholds and quality gates, developers can establish minimum requirements for code coverage and test success rates, ensuring a higher level of code quality </st><span class="No-Break"><st c="25789">and reliability.</st></span></p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor063"/><st c="25805">Summary</st></h1>
			<p><st c="25813">This chapter covered how to set up the testing environment, write unit tests with Jasmine, and configure Karma to run the tests in different browsers. </st><st c="25965">Jasmine and Karma are powerful tools for testing Angular applications. </st><st c="26036">Jasmine is a BDD framework that provides an intuitive syntax for writing test cases. </st><st c="26121">Karma, on the other hand, is a test runner that allows you to execute tests in various environments and provides features such as code coverage and test </st><span class="No-Break"><st c="26274">result analysis.</st></span></p>
			<p><st c="26290">To use Jasmine and Karma to test Angular applications, you need to set up the testing environment by installing the necessary dependencies and configuring Karma. </st><st c="26453">Jasmine provides a rich set of matchers and assertions to validate the behavior of Angular components, services, and directives. </st><st c="26582">You can create test suites and test cases to cover different scenarios </st><span class="No-Break"><st c="26653">and expectations.</st></span></p>
			<p><st c="26670">Karma allows you to run tests in real browsers or headless environments, making it easy to simulate user interactions and test the application’s behavior across different platforms. </st><st c="26853">It also provides support for code coverage, generating reports that help identify areas of the code base that require </st><span class="No-Break"><st c="26971">additional testing.</st></span></p>
			<p><st c="26990">By using Jasmine and Karma together, you can write complete unit tests for your Angular applications and practice the principles </st><span class="No-Break"><st c="27120">of TDD.</st></span></p>
			<p><st c="27127">In the next chapter, we’ll learn how to write effective unit tests for Angular components, services, </st><span class="No-Break"><st c="27229">and directives.</st></span></p>
		</div>
	<div id="charCountTotal" value="27244"/>

		<div id="_idContainer033" class="Content">
			<h1 id="_idParaDest-48" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor064"/><st c="0">Part 2: Writing Effective Unit Tests</st></h1>
			<p><st c="37">In this part, you’ll write unit tests for components, services, and directives, using pipes, forms, and reactive programming while respecting </st><span class="No-Break"><st c="180">TDD principles.</st></span></p>
			<p><st c="195">This part has the </st><span class="No-Break"><st c="214">following chapters:</st></span></p>
			<ul>
				<li><a href="B21146_03.xhtml#_idTextAnchor065"><em class="italic"><st c="233">Chapter 3</st></em></a><st c="243">, </st><em class="italic"><st c="245">Writing Effective Unit Tests for Angular Components, Services, and Directives</st></em></li>
				<li><a href="B21146_04.xhtml#_idTextAnchor108"><em class="italic"><st c="322">Chapter 4</st></em></a><st c="332">, </st><em class="italic"><st c="334">Mocking and Stubbing Dependencies in Angular Tests</st></em></li>
				<li><a href="B21146_05.xhtml#_idTextAnchor200"><em class="italic"><st c="384">Chapter 5</st></em></a><st c="394">, </st><em class="italic"><st c="396">Testing Angular Pipes, Forms, and Reactive Programming</st></em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer034">
			</div>
		</div>
	<div id="charCountTotal" value="450"/></body></html>