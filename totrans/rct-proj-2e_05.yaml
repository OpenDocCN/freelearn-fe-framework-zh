- en: '*Chapter 5*: Building a Personal Shopping List Application Using Context and
    Hooks'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：使用 Context 和 Hooks 构建个人购物清单应用程序'
- en: State management is a very important part of modern web and mobile applications
    and is something that React is very good at. Handling state management in React
    applications can be quite confusing, as there are multiple ways you can handle
    the current state of your application. The projects you created in the first four
    chapters of this book didn't focus on state management too much, something that
    will be investigated much more in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 状态管理是现代 Web 和移动应用程序的重要组成部分，React 在此方面表现优秀。在 React 应用程序中处理状态管理可能会相当复杂，因为您有多种方式可以处理应用程序的当前状态。本书的前四章中创建的项目并没有过多关注状态管理，而这一点将在本章中深入探讨。
- en: This chapter will show how you can handle state management in React by creating
    an application state that is accessible from every component. Before React v16.3,
    you needed third-party packages to handle state in React, but with the renewed
    version of the context API, this is no longer mandatory. Also, with the release
    of React Hooks, more ways to mutate this Context were introduced. Using an example
    application, the methods for handling state management for your application are
    demonstrated.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将展示您如何通过创建一个可从每个组件访问的应用程序状态来在 React 中处理状态管理。在 React v16.3 之前，您需要第三方包来处理 React
    中的状态，但有了上下文 API 的更新版本，这不再是强制性的。此外，随着 React Hooks 的发布，引入了更多修改上下文的方法。通过一个示例应用程序，演示了处理应用程序状态管理的方法。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Using the context API for state management
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上下文 API 进行状态管理
- en: Mutating Context with Hooks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Hooks 修改 Context
- en: Code splitting with React Suspense
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React Suspense 进行代码拆分
- en: Project overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, we will build a personal shopping list by adding state management
    using Context and Hooks. We will advance upon a boilerplate application that has
    been created with Create React App and has declarative routing using `react-router`.
    Also, code splitting of the bundle is added with React Suspense.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过使用 Context 和 Hooks 来添加状态管理，构建一个个人购物清单。我们将基于使用 Create React App 创建的样板应用程序进行扩展，该应用程序使用
    `react-router` 进行声明式路由。此外，还添加了 React Suspense 的代码拆分功能。
- en: The build time is 2.5 hours.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 构建时间为 2.5 小时。
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'The project that we''ll create in this chapter builds upon an initial version
    that you can find on GitHub: [https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter05-initial](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter05-initial).
    The complete source code can also be found on GitHub: [https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter05).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将创建的项目基于您可以在 GitHub 上找到的初始版本：[https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter05-initial](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter05-initial)。完整的源代码也可以在
    GitHub 上找到：[https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter05)。
- en: After downloading the initial application, make sure that you run `npm install`
    from the project's root directory. This project is created using Create React
    App and installs the `react`, `react-dom`, `react-scripts`, `styled-components`,
    and `react-router-dom` packages, which you've already seen in previous chapters.
    After finishing the installation process, you can run `npm start` from the same
    tab in Terminal and view the project in your browser (`http://localhost:3000`).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下载初始应用程序后，请确保您从项目的根目录运行 `npm install`。该项目使用 Create React App 创建，并安装了 `react`、`react-dom`、`react-scripts`、`styled-components`
    和 `react-router-dom` 包，这些包您在之前的章节中已经见过。安装过程完成后，您可以从终端的同一选项卡中运行 `npm start`，并在浏览器中查看项目（`http://localhost:3000`）。
- en: 'The initial application for this section is created with Create React App and
    has routing and data fetching already implemented. When you open the application,
    a screen displaying a header, a navigation bar, and two lists are being rendered.
    If, for example, you click on the first list that is displayed here, a new page
    will open that displays the items of this list. On this page, you can click on
    the **Add Item** button in the top-right corner to open a new page, which has
    a form to add a new list and looks like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本节初始应用程序使用 Create React App 创建，并已实现路由和数据获取。当您打开应用程序时，一个显示标题、导航栏和两个列表的屏幕正在渲染。例如，如果您点击此处显示的第一个列表，将打开一个新页面，显示该列表的项目。在此页面上，您可以在右上角点击
    **添加项目** 按钮打开一个新页面，该页面有一个用于添加新列表的表单，看起来如下：
- en: '![Figure 5.1 – The initial application'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – 初始应用程序]'
- en: '](img/Figure_5.1_B17390.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B17390.jpg)'
- en: Figure 5.1 – The initial application
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 初始应用程序
- en: This form is rendered by the `ListForm` component and has no functionality yet,
    as you'll add this later on. When you click on the left button, it redirects you
    to the previously visited page, using the navigate method from `react-router-dom`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此表单由 `ListForm` 组件渲染，目前没有功能，因为您将在稍后添加此功能。当您点击左侧按钮时，它将使用 `react-router-dom` 中的
    navigate 方法重定向到之前访问的页面。
- en: Note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When you try to submit the form to either add a new list or add a new item to
    a list, nothing happens yet. The functionality of these forms will be added in
    this section later on, for which you'll use the Context API and React Hooks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当您尝试提交表单以添加新列表或向列表添加新项目时，目前没有任何反应。这些表单的功能将在本节稍后添加，您将使用 Context API 和 React Hooks
    来实现。
- en: The project is structured in the same manner as the applications you've created
    before. A distinction is made, however, between reusable function components in
    the `components` directory and components that represent a route in the `pages`
    directory. The page components are using the `useDataFetching` Hook, which we
    saw earlier in [*Chapter 3*](B17390_03_Final_NM_ePub.xhtml#_idTextAnchor039),
    *Building a Dynamic Project Management Board*, which adds data fetching.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目结构与您之前创建的应用程序相同。然而，在 `components` 目录中的可重用函数组件和在 `pages` 目录中表示路由的组件之间有所区分。页面组件使用了我们在
    [*第3章*](B17390_03_Final_NM_ePub.xhtml#_idTextAnchor039) 中见过的 `useDataFetching`
    钩子，即 *构建动态项目管理板*，它增加了数据获取功能。
- en: 'The following is an overview of the complete structure of the project:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对项目完整结构的概述：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The entry point of this application is the `src/index.js` file that renders
    the `App` component, which sets up routing using a `Router` component from `react-router-dom`.
    The `App` component contains a `Header` component and a `Switch` router component
    that defines four routes. These routes are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序的入口点是 `src/index.js` 文件，它渲染 `App` 组件，该组件使用 `react-router-dom` 中的 `Router`
    组件设置路由。`App` 组件包含一个 `Header` 组件和一个定义了四个路由的 `Switch` 路由组件。这些路由如下：
- en: '`/`: Renders `Lists`, with an overview of all of the lists'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`: 渲染 `Lists` 组件，显示所有列表的概述'
- en: '`/list/:listId`: Renders `ListDetail`, with an overview of all items from a
    specific list'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/list/:listId`: 渲染 `ListDetail` 组件，显示特定列表中所有项目的概述'
- en: '`/list/:listId/new`: Renders `ListForm`, with a form to add new items to a
    specific list'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/list/:listId/new`: 渲染 `ListForm` 组件，包含用于向特定列表添加新项目的表单'
- en: 'The data is fetched from a mock server that was created using the free service,
    My JSON Server, which creates a server from the `db.json` file in the root directory
    of your project in GitHub. This file consists of a JSON object that has two fields,
    `items` and `lists`, which creates multiple endpoints on a mock server. The ones
    you''ll be using in this chapter are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是从一个使用免费服务 My JSON Server 创建的模拟服务器中获取的，该服务从您项目根目录中的 `db.json` 文件创建服务器。该文件由一个具有两个字段
    `items` 和 `lists` 的 JSON 对象组成，在模拟服务器上创建了多个端点。您在本章中将使用以下端点：
- en: '[https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/items](https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/items)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/items](https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/items)'
- en: '[https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/lists](https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/lists)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/lists](https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/lists)'
- en: Note
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The `db.json` file must be present in the master branch (or default branch)
    of your GitHub repository for My JSON Server to work. Otherwise, you'll receive
    a **404 Not Found** message when trying to request the API endpoints.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`db.json` 文件必须存在于你的 GitHub 仓库的 master 分支（或默认分支）中，以便 My JSON Server 能够正常工作。否则，当你尝试请求
    API 端点时，你会收到一个 **404 Not Found** 错误信息。'
- en: Personal shopping list
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人购物清单
- en: In this section, you'll build a personal shopping list application that has
    state management using Context and Hooks. With this application, you can create
    shopping lists that you can add items to, along with their quantities and prices.
    The starting point of this section is an initial application that has routing
    and local state management already enabled.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将构建一个使用 Context 和 Hooks 进行状态管理的个人购物清单应用程序。使用这个应用程序，你可以创建可以添加项目、数量和价格的购物清单。本节的起点是一个已经启用了路由和本地状态管理的初始应用程序。
- en: Using the Context API for state management
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Context API 进行状态管理
- en: State management is very important, as the current state of the application
    holds data that is valuable to the user. In previous chapters, you've already
    used local state management by using `useState` and `useEffect` Hooks. This pattern
    is very useful when the data in the state is only of importance to the components
    you're setting the state in. As passing down the state as props through several
    components can become confusing, you'd need a way to access props throughout your
    application even when you're not specifically passing them as props. For this,
    you can use the Context API from React, which is also used by packages you've
    already used in previous chapters such as `styled-components` and `react-router-dom`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 状态管理非常重要，因为应用程序的当前状态包含对用户有价值的数据。在之前的章节中，你已经通过使用 `useState` 和 `useEffect` 钩子来使用本地状态管理。当状态中的数据只对设置状态的组件重要时，这种模式非常有用。因为通过多个组件向下传递状态可能会变得混乱，你需要一种方法来访问你的应用程序中的
    props，即使你并没有明确地将它们作为 props 传递。为此，你可以使用 React 的 Context API，这个 API 也被你在之前章节中使用的包如
    `styled-components` 和 `react-router-dom` 所使用。
- en: To share state across multiple components, a React feature called Context will
    be explored, starting in the first part of this section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要在多个组件之间共享状态，我们将从本节的第一个部分开始探索 React 的一个功能，称为 Context。
- en: Creating Context
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Context
- en: When you want to add Context to your React application, you can do this by creating
    a new Context with the `createContext` method from React. This creates a Context
    object that consists of two React components, called Provider and Consumer. The
    Provider is where the initial (and subsequently current) value of the Context
    is placed, which can be accessed by components that are present within the Consumer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想给你的 React 应用程序添加上下文时，你可以通过使用 React 的 `createContext` 方法创建一个新的上下文来实现。这会创建一个包含两个
    React 组件的上下文对象，称为 Provider 和 Consumer。Provider 是放置上下文初始（以及随后的当前）值的地方，这些值可以通过 Consumer
    内部的组件访问。
- en: 'This is done in the `App` component in `src/App.js`, as you want the Context
    for the lists to be available in every component that is rendered by `Route`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 `src/App.js` 中的 `App` 组件中完成的，因为你希望列表的 Context 在由 `Route` 渲染的每个组件中都是可用的：
- en: 'Let''s start by creating a Context for the lists and making it exportable so
    that the list data can be used everywhere. For this, you can create a new file
    called `ListsContext.js` inside a new directory, `src/context`. In this file,
    you can add the following code:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先为列表创建一个 Context，并使其可导出，以便列表数据可以在任何地方使用。为此，你可以在一个新目录 `src/context` 中创建一个名为
    `ListsContext.js` 的新文件。在这个文件中，你可以添加以下代码：
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The previous code creates a Provider based on a `Context` object that is passed
    as a prop and sets a value based on the return from the `useDataFetching` Hook
    that is fetching all of the lists. Using the `children` prop, all of the components
    that will be wrapped inside the `ListsContextProvider` component can retrieve
    the data for the value from a Consumer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码创建了一个基于传递为 prop 的 `Context` 对象的 Provider，并根据从 `useDataFetching` 钩子返回的值设置了一个值，该钩子正在获取所有列表。使用
    `children` prop，所有将被包裹在 `ListsContextProvider` 组件内部的组件都可以从 Consumer 中检索值的 data。
- en: 'This `ListsContextProvider` component can be imported inside your `App` component
    to wrap the Router component that is wrapping all the routes for our application:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以将 `ListsContextProvider` 组件导入到你的 `App` 组件中，以便包裹所有路由的 Router 组件：
- en: '[PRE2]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This way, you''re now able to consume the value from the Provider for `ListsContext`,
    from all the components wrapped within `ListsContextProvider`. In the `Lists`
    component, this data can be retrieved using the `useContext` Hook from React by
    passing the `ListsContext` object to it. This data can then be used to render
    the lists, and the `useDataFetching` Hook can be removed from `src/pages/Lists.js`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样，你现在可以消费 `ListsContext` 提供者的值，从所有被 `ListsContextProvider` 包裹的组件中。在 `Lists`
    组件中，可以使用 React 的 `useContext` Hook 通过传递 `ListsContext` 对象来检索这些数据。然后可以使用这些数据来渲染列表，并且可以从
    `src/pages/Lists.js` 中移除 `useDataFetching` Hook：
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that you've removed the `useDataFetching` Hook from `Lists`, no requests
    to the API are sent directly from this component anymore. The data for the lists
    is instead fetched from `ListsContextProvider` and is passed by `ListsContext`,
    which is used by the `useContext` Hook in `Lists`. If you open the application
    in the browser by going to `http://localhost:3000/`, you can see the lists are
    being rendered just as before.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经从 `Lists` 中移除了 `useDataFetching` Hook，这个组件不再直接向 API 发送请求。列表的数据现在是从 `ListsContextProvider`
    中获取的，并通过 `ListsContext` 传递，该上下文被 `Lists` 中的 `useContext` Hook 使用。如果你通过访问 `http://localhost:3000/`
    在浏览器中打开应用程序，你可以看到列表的渲染与之前一样。
- en: In the next section, you'll also add a Context object for the items, so the
    items are also available to all of the components within the Routes component
    from `react-router`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你还将为项目添加一个 Context 对象，这样项目也可以在 `react-router` 的 `Routes` 组件内的所有组件中使用。
- en: Nesting Context
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套上下文
- en: 'Just as for the list data, the item data could also be stored in Context and
    passed to the components that need this data. That way, data is no longer fetched
    from any of the rendered components but from the Context only:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 就像列表数据一样，项目数据也可以存储在 Context 中并传递给需要这些数据的组件。这样，数据就不再是从任何渲染的组件中获取，而是只从 Context
    中获取：
- en: 'Again, start by creating a new file where both a Context and Provider are created.
    This time, it''s called `ItemsContext.js`, which can also be added to the `src/context`
    directory:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，首先创建一个新文件，其中创建了一个上下文和一个提供者。这次，它被命名为 `ItemsContext.js`，也可以添加到 `src/context`
    目录中：
- en: '[PRE4]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, import this new Context and Provider in `src/App.js`, where you can nest
    this below the `ListsContextProvider` component:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `src/App.js` 中导入这个新的 Context 和 Provider，你可以在 `ListsContextProvider` 组件下面嵌套它：
- en: '[PRE5]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `ListDetail` component can now get the item from `ItemsContext`, meaning
    we no longer have to use the `useDataFetching` Hook in this component. To accomplish
    this, you need to make the following changes to `src/pages/ListDetail.js`:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ListDetail` 组件现在可以从 `ItemsContext` 中获取项目，这意味着我们不再需要在组件中使用 `useDataFetching`
    Hook。为了实现这一点，你需要对 `src/pages/ListDetail.js` 进行以下更改：'
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All of the data fetching is now no longer by the `List` and `Lists` components.
    By nesting these Context Providers, the return values can be consumed by multiple
    components. But this still isn't ideal, as you're now loading all of the lists
    and all of the items when starting your application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有数据获取都不是由 `List` 和 `Lists` 组件完成的。通过嵌套这些 Context 提供者，返回值可以被多个组件消费。但这还不是最佳方案，因为你现在在启动应用程序时加载了所有列表和所有项目。
- en: The downside of this approach is that once we open a detail page for a list,
    it will retrieve all items, even if they are not for this list. In the next section,
    you'll see how to get only the data you need by combining Context with custom
    Hooks.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，一旦我们打开列表的详细页面，它将检索所有项目，即使它们不是属于这个列表的。在下一节中，你将看到如何通过结合 Context 和自定义
    Hooks 来获取所需的数据。
- en: Mutating Context with Hooks
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Hooks 修改上下文
- en: There are multiple ways in which you can get data conditionally from the Context;
    one of these is placing the data from the Context in the local state. That could
    be a solution for a smaller application, but can be inefficient for larger applications,
    as you'd still need to pass this state down your component tree. Another solution
    is to use React Hooks to create a function that is added to the value of your
    Context and can be invoked from any of the components that are nested in this
    Context. Also, this method of getting the data lets you efficiently load only
    the data that you'd need.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 Context 中有条件地获取数据的方式有很多；其中之一是将 Context 中的数据放在本地状态中。这可能是一个适用于较小应用程序的解决方案，但对于较大的应用程序来说可能效率不高，因为你仍然需要将这个状态传递到组件树中。另一个解决方案是使用
    React Hooks 创建一个函数，并将其添加到 Context 的值中，可以从嵌套在这个 Context 中的任何组件中调用。此外，这种方法获取数据可以让你高效地只加载所需的数据。
- en: How this can be used together with React life cycles and state management using
    Hooks is demonstrated in the first part of this section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将React生命周期和状态管理结合使用Hooks进行演示，在本节的第一部分。
- en: Using life cycles in functional components
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在函数组件中使用生命周期
- en: 'Previously, we used the `useDataFetching` Hook to do the data fetching for
    us, but this doesn''t let us control when the data will be fetched exactly. From
    the components that are consuming our Context data, we want to be able to initiate
    the data fetching. Therefore we need to add life cycles to them, which invoke
    a function to do the data fetching inside our Context components. Follow these
    steps to implement this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用`useDataFetching`钩子来帮我们进行数据获取，但这并不让我们能够精确控制数据何时被获取。从消耗我们上下文数据的组件中，我们希望能够启动数据获取。因此，我们需要为它们添加生命周期，这些生命周期会在我们的上下文组件内部调用一个函数来执行数据获取。按照以下步骤来实现这一功能：
- en: 'The first step in achieving this is by adding logic to do data fetching in
    the `src/context/ItemsContext.js` file. This logic will replace the usage of the
    `useDataFetching` Hook, starting with adding local state variables for the data
    fetching state:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现这一功能的第一步是在`src/context/ItemsContext.js`文件中添加进行数据获取的逻辑。这个逻辑将替换掉`useDataFetching`钩子的使用，从添加用于数据获取状态的本地区域变量开始：
- en: '[PRE7]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After this, we can add a function called `fetchItems` that we pass to `ItemsContextProvider`,
    meaning it will be added to the Context. This function is wrapped in a `useCallback`
    Hook to prevent unneeded (re)renders of your component:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们可以添加一个名为`fetchItems`的函数，并将其传递给`ItemsContextProvider`，这意味着它将被添加到上下文中。这个函数被`useCallback`钩子包装，以防止组件不必要的（重新）渲染：
- en: '[PRE8]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With this function in place, the next step would be to invoke it with a value
    for `listId` from the `ListDetail` component. This would mean that we no longer
    retrieve all the items once we load this component, but use the params from the
    URL to determine what data should be fetched and added to the Context:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数就位后，下一步就是从`ListDetail`组件中调用它，并传递一个`listId`的值。这意味着一旦加载了这个组件，我们就不再检索所有项目，而是使用URL中的参数来确定应该获取并添加到上下文中的数据：
- en: '[PRE9]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding `useEffect` Hooks call the `fetchItems` function when there's
    a `listId` present in the URL of the page, and when the value for `items` is an
    empty array. This prevents us from fetching the items again if they already exist
    in `ItemsContext`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的`useEffect`钩子会在页面URL中存在`listId`并且`items`的值为空数组时调用`fetchItems`函数。这防止我们在`ItemsContext`中已经存在项目时再次获取项目。
- en: By creating a function to do data fetching in our Context, we can now control
    when the data should be fetched, so there will no longer be unnecessary requests
    to the API. But other Hooks can also directly pass data to the Provider without
    having to duplicate `useState` Hooks. This will be demonstrated in the next part
    of this section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的上下文中创建一个进行数据获取的函数，我们现在可以控制数据何时被获取，因此将不再有对API的不必要请求。但其他钩子也可以直接将数据传递给Provider，而无需重复`useState`钩子。这将在本节的下一部分进行演示。
- en: Using advanced state with useReducer
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`useReducer`进行高级状态管理
- en: 'Another way to use actions for adding data to the Provider is by using a pattern
    similar to Flux, which was introduced by Facebook. The Flux pattern describes
    a data flow where actions are being dispatched that retrieve data from a store
    and return it to the view. This would mean that actions need to be described somewhere;
    there should be a central place where data is stored and this data can be read
    by the view. To accomplish this pattern with the Context API, you can use another
    Hook, called `useReducer`. This Hook can be used to return data not from a local
    state, but from any data variable:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种向Provider添加数据的方法是使用类似于Facebook引入的Flux的模式。Flux模式描述了一种数据流，其中正在分发动作以从存储中检索数据并将其返回给视图。这意味着动作需要在某处进行描述；应该有一个中央位置来存储数据，并且视图可以读取这些数据。为了使用上下文API实现此模式，你可以使用另一个名为`useReducer`的钩子。这个钩子可以用来返回数据，而不是从本地状态，而是从任何数据变量：
- en: 'Just as with the `useState` Hook, the `useReducer` Hook needs to be added to
    the component that is using it. `useReducer` will take an initial state and a
    function that determines which data should be returned. This initial value needs
    to be added to the `src/context/ListsContext.js` file before adding the Hook:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如与`useState`钩子一样，`useReducer`钩子需要添加到使用它的组件中。`useReducer`将接受一个初始状态和一个函数，该函数确定应该返回哪些数据。这个初始值需要在添加钩子之前添加到`src/context/ListsContext.js`文件中：
- en: '[PRE10]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next to an initial value, the `useReducer` Hook also takes a function that''s
    called `reducer`. This `reducer` function should also be created and is a function
    that updates `initialState`, which was passed and returns the current value, based
    on the action that was sent to it. If the action that was dispatched doesn''t
    match any of those defined in `reducer`, the reducer will just return the current
    value without any changes:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了初始值之外，`useReducer` Hook还接受一个名为`reducer`的函数。这个`reducer`函数也应该被创建，它是一个根据发送给它的操作更新`initialState`（已传递）并返回当前值的函数。如果发送给reducer的操作不匹配`reducer`中定义的任何操作，reducer将只返回当前值而不做任何更改：
- en: '[PRE11]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The two parameters for the `useReducer` Hook are now added to the file, so
    you need to add the actual Hook and pass `initialState` and `reducer` to it. The
    `useDataFetching` Hook can be removed, as this will be replaced with a new function
    that has data fetching logic:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useReducer` Hook的两个参数现在已添加到文件中，因此你需要添加实际的Hook并将`initialState`和`reducer`传递给它。`useDataFetching`
    Hook可以被移除，因为这将被一个新的具有数据获取逻辑的函数所取代：'
- en: '[PRE12]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, `reducer` changes the value it returns when the `GET_LISTS_SUCCESS`
    or `GET_LISTS_ERROR` action is sent to it. Before it was mentioned, you can call
    this `reducer` by using the `dispatch` function that was returned by the `useReducer`
    Hook. However, as you also have to deal with the asynchronous fetching of the
    data, you can''t invoke this function directly. Instead, you need to create an
    `async/await` function that calls the `fetchData` function and dispatches the
    correct action afterward:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，`reducer`在接收到`GET_LISTS_SUCCESS`或`GET_LISTS_ERROR`操作时改变了它返回的值。在之前提到之前，你可以通过使用由`useReducer`
    Hook返回的`dispatch`函数来调用这个`reducer`。然而，因为你还要处理数据的异步获取，你不能直接调用这个函数。相反，你需要创建一个调用`fetchData`函数并在之后发送正确操作的`async/await`函数：
- en: '[PRE13]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding `fetchLists` function calls the API and if there is a result,
    the `GET_LISTS_SUCCESS` action will be dispatched to the reducer using the `dispatch`
    function from the `useReducer` Hook. If not, the `GET_LISTS_ERROR` action will
    be dispatched, which returns an error message.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的`fetchLists`函数中，它调用API，如果有结果，将使用来自`useReducer` Hook的`dispatch`函数将`GET_LISTS_SUCCESS`操作发送到reducer。如果没有，将发送`GET_LISTS_ERROR`操作，它返回一个错误消息。
- en: 'The values from the state and the `fetchLists` function must be added to the
    Provider so that we can access them from other components through the Context:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须将状态和`fetchLists`函数的值添加到Provider中，这样我们就可以从其他组件通过Context访问它们：
- en: '[PRE14]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This `getLists` function can now be invoked from the `useEffect` Hook in the
    component where the lists are displayed, the `Lists` component, on the first render.
    The lists should only be retrieved when there aren''t any lists available yet:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，这个`getLists`函数可以从显示列表的组件中的`useEffect` Hook调用，即`Lists`组件，在第一次渲染时。列表应该在还没有任何列表可用时才检索：
- en: '[PRE15]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you now visit the project in the browser again, you can see the data from
    the lists is loaded just as before. The big difference is that the data is fetched
    using a Flux pattern, meaning this can be extended to fetch the data in other
    instances as well. The same can be done for `ItemsContext` as well, in the `src/context/ItemsContext.js`
    file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在再次在浏览器中访问项目，你可以看到列表的数据就像之前一样被加载。最大的不同是数据是使用Flux模式获取的，这意味着这可以扩展到在其他实例中获取数据。同样，对于`ItemsContext`也可以在`src/context/ItemsContext.js`文件中这样做：
- en: 'First, import the `useReducer` Hook, and add the initial value for the items
    and the `reducer` function that we use with this Hook later:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入`useReducer` Hook，并为项目添加初始值和我们将与这个Hook一起使用的`reducer`函数：
- en: '[PRE16]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After this, you can add the initial state and reducer to the `useReducer` Hook.
    The `fetchItems` function that already exists in this file must be changed so
    that it will use the `dispatch` function from `useReducer` instead of the `update`
    functions from the `useState` Hooks:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，你可以将初始状态和reducer添加到`useReducer` Hook中。该文件中已经存在的`fetchItems`函数必须进行更改，以便它将使用来自`useReducer`的`dispatch`函数，而不是来自`useState`
    Hook的`update`函数：
- en: '[PRE17]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Also, add the state and the `fetchItems` function to `ListsContextProvider`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，将状态和`fetchItems`函数添加到`ListsContextProvider`：
- en: '[PRE18]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you were to open a specific list on the `/lists/:listId` route, for example,
    `http://localhost:3000/list/1`, you would see that nothing has changed and that
    the items for the list are still displayed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在打开特定的列表，例如`/lists/:listId`路由上的列表，例如`http://localhost:3000/list/1`，你会看到没有任何变化，列表的项目仍然被显示。
- en: 'You might notice that the title of the list isn''t displayed here. The information
    for the lists is only fetched when the `Lists` component is first rendered, so
    you''d need to create a new function to always fetch the information for the list
    that you''re currently displaying in the `List` component:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到列表的标题在这里没有显示。列表的信息只有在`Lists`组件首次渲染时才会被检索，所以你需要创建一个新的函数来始终检索你目前在`List`组件中显示的列表信息：
- en: 'In the `src/context/ListsContextProvider.js` file, you need to extend `initialState`
    to also have a field called `list`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/context/ListsContextProvider.js`文件中，你需要扩展`initialState`以包含一个名为`list`的字段：
- en: '[PRE19]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In `reducer`, you also now have to check for two new actions that either add
    the data about a list to the context or add an error message:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`reducer`中，你现在还必须检查两个新的动作，这两个动作要么将关于列表的数据添加到上下文中，要么添加一个错误消息：
- en: '[PRE20]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'These actions will be dispatched from a new `fetchList` function that takes
    the specific ID of a list to call the API. If successful, the `GET_LIST_SUCCESS`
    action will be dispatched; otherwise, the `GET_LIST_ERROR` action is dispatched.
    Also, pass the function to the Provider so that it can be used from other components:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些动作将从一个新的`fetchList`函数中分发，该函数接受一个特定列表的ID来调用API。如果成功，将分发`GET_LIST_SUCCESS`动作；否则，将分发`GET_LIST_ERROR`动作。同时，将函数传递给Provider，以便它可以在其他组件中使用：
- en: '[PRE21]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And, in the `ListDetail` component, we can get the list data from `ListsContext`
    by calling the `fetchList` function in a `useEffect` Hook. Also, pass it as a
    prop to the `NavBar` component so that it will be displayed:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ListDetail`组件中，我们可以通过在`useEffect` Hook中调用`fetchList`函数从`ListsContext`获取列表数据。同时，将其作为prop传递给`NavBar`组件，以便它将被显示：
- en: '[PRE22]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the previous code block, we're calling the `fetchList` function from a different
    `useEffect` Hook than the `fetchItems` function. This is a good way to separate
    concerns to keep our code clean and concise.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们是从一个与`fetchItems`函数不同的`useEffect` Hook中调用`fetchList`函数。这是一种很好的分离关注点的方法，以保持我们的代码干净和简洁。
- en: All of the data in your application is now being loaded using the Providers,
    which means it's now detached from the views. Also, the `useDataFetching` Hook
    is completely removed, making your application structure more readable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你应用中的所有数据现在都是通过Provider加载的，这意味着它现在与视图分离。此外，`useDataFetching` Hook被完全移除，使你的应用程序结构更易于阅读。
- en: Not only can you use the context API with this pattern to make data available
    to many components, but you can also mutate the data. How to mutate this data
    will be shown in the next section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以使用这个上下文API与这个模式来使数据对许多组件可用，还可以修改数据。如何修改这些数据将在下一节中展示。
- en: Mutating data in the Provider
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Provider中修改数据
- en: 'Not only can you retrieve data using this Flux pattern, but you can also use
    it to update data. The pattern remains the same: you dispatch an action that would
    trigger the request to the server and, based on the outcome, the reducer will
    mutate the data with this result. Depending on whether or not it was successful,
    you could display a success message or an error message.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以使用这种Flux模式检索数据，还可以用它来更新数据。模式保持不变：你分发一个动作，该动作会触发对服务器的请求，并根据结果，reducer将使用这个结果来修改数据。根据是否成功，你可以显示一个成功消息或一个错误消息。
- en: 'The code already has a form for adding a new item to a list—something that
    is not working yet. Let''s create the mechanism to add items by updating the Provider
    for `items`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 代码已经有一个用于向列表添加新项目的表单——但目前这个功能还没有正常工作。让我们创建一个机制来通过更新`items`的Provider来添加项目：
- en: 'The first step is to add new actions to the reducer in `ItemsContext`, which
    will be dispatched once we try to add a new item:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是在`ItemsContext`中添加新的动作，一旦我们尝试添加一个新项目，这个动作就会被分发：
- en: '[PRE23]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We also need to add a new function that can handle `POST` requests, as this
    function should also set the method and a body when handling the `fetch` request.
    You can create this function in the preceding file as well, and pass it to the
    Provider:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要添加一个新的函数来处理`POST`请求，因为这个函数在处理`fetch`请求时也应该设置方法和一个主体。你可以在前面的文件中创建这个函数，并将其传递给Provider：
- en: '[PRE24]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As the function to add a new item to a list is now available from the Provider,
    the `ListForm` component in `src/pages/ListForm.js` is now able to use the `addItem`
    function, which will dispatch the action that will call the API and add the item
    to the state. However, the values of the input fields in the form need to be determined
    first. Therefore, the input fields need to be controlled components, meaning their
    value is controlled by the local state that encapsulates the value. Therefore
    we need to import the `useState` Hook and also a `useContext` Hook, which we''ll
    use later to get values from the Context:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于现在可以从提供者处获取添加新项目到列表的函数，`src/pages/ListForm.js`中的`ListForm`组件现在能够使用`addItem`函数，这将触发调用API并将项目添加到状态的行动。然而，表单中输入字段的值需要首先确定。因此，输入字段需要是受控组件，意味着它们的值由封装值的本地状态控制。因此我们需要导入`useState`钩子和一个`useContext`钩子，我们将在稍后使用它来从传递给它的上下文的提供者中获取值：
- en: '[PRE25]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For this, we used the `useState` Hook for every `state` value that we created.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们为每个创建的`state`值使用了`useState`钩子。
- en: 'The local state values and the function that triggers an update of the local
    state values must be set as a prop on the `FormItem` components:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地状态值和触发本地状态值更新的函数必须作为属性设置在`FormItem`组件上：
- en: '[PRE26]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The last thing you need to do now is to add a function that will be dispatched
    when the form is submitted by clicking the submit button. This function takes
    `value` for the local state, adds information about the item, and uses this to
    call the `addItem` function. After this function is called, the navigate function
    from `useNavigate` is called to go back to the overview for this list:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你需要做的最后一件事是添加一个函数，当点击提交按钮提交表单时将被触发。这个函数接受`value`作为本地状态，添加关于项的信息，并使用这个信息来调用`addItem`函数。在这个函数被调用后，`useNavigate`中的导航函数被调用，以便返回到该列表的概览页面：
- en: '[PRE27]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When you now submit the form, a `POST` request to the mock server will be sent.
    You'll be sent back to the previous page where you can see the result. If successful,
    the `GET_LIST_SUCCESS` action was dispatched and the item you inserted was added
    to the list.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在提交表单时，将向模拟服务器发送一个`POST`请求。你将被送回到上一个页面，在那里你可以看到结果。如果成功，将触发`GET_LIST_SUCCESS`操作，你插入的项目被添加到列表中。
- en: So far, the information from the Context has been used only separately by using
    the Providers, but this can also be combined into one application Context, as
    shown in the next section.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，来自上下文的信息仅通过使用提供者单独使用，但也可以将其组合成一个应用程序上下文，如下一节所示。
- en: Creating an application Context
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序上下文
- en: 'If you look at the current structure of the routes in your `App` component,
    you can imagine that this will get messy if you add more Providers and Consumers
    to your application. State management packages such as Redux tend to have an application
    state where all of the data for the application is stored. When using Context,
    it''s possible to create an application Context that can be accessed using the
    `useContext` Hook. This Hook acts as a Consumer and can retrieve values from the
    Provider of the Context that was passed to it. Let''s refactor the current application
    to have an application Context:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`App`组件中当前的路由结构，你可以想象，如果你向应用程序中添加更多的提供者和消费者，这将会变得混乱。像Redux这样的状态管理包通常有一个应用程序状态，其中存储了应用程序的所有数据。当使用上下文时，可以创建一个应用程序上下文，可以使用`useContext`钩子访问它。这个钩子充当消费者，可以从传递给它的上下文的提供者中检索值。让我们重构当前的应用程序，使其具有应用程序上下文：
- en: 'Start by creating a file called `AppContext.js` in the `src/context` directory.
    This file will import both `ListsContextProvider` and `ItemsContextProvider`,
    nest them, and have them wrap any component that will be passed to it as a `children`
    prop:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`src/context`目录中创建一个名为`AppContext.js`的文件。这个文件将导入`ListsContextProvider`和`ItemsContextProvider`，将它们嵌套，并将任何将被传递给它的组件作为`children`属性包裹：
- en: '[PRE28]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the `src/App.js` file, we can now import this `AppContext` file in favor
    of the Providers for the lists and items and replace `ListsContextProvider` and
    `ItemsContextProvider` with `AppContext`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/App.js`文件中，我们现在可以导入这个`AppContext`文件，以替代列表和项的提供者，并将`ListsContextProvider`和`ItemsContextProvider`替换为`AppContext`：
- en: '[PRE29]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `AppContext` component can be extended with all of the Context objects that
    you might want to add in the future. Our application now has a much cleaner structure,
    while the data is still being retrieved by the Providers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppContext`组件可以扩展到所有你可能希望在将来添加的上下文对象。我们的应用程序现在有一个更干净的结构，而数据仍然由提供者检索。'
- en: Code splitting with React Suspense
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Suspense进行代码拆分
- en: So far, we've focused mostly on adding new features, such as routing or state
    management, to our application. But not much focus has been devoted to making
    our application more performant, something that we can do with code splitting.
    A React feature called Suspense can be used for code splitting, which means you
    split the compiled code (your bundle) into smaller chunks. This will prevent the
    browser from downloading the entire bundle with your compiled code at once, and
    instead load your bundle in chunks depending on the components that are rendered
    by the browser.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要关注添加新功能，如路由或状态管理，到我们的应用程序中。但并没有太多关注于使我们的应用程序更高效，我们可以通过代码拆分来实现这一点。React的一个名为Suspense的功能可以用于代码拆分，这意味着你将编译后的代码（你的包）拆分成更小的块。这将防止浏览器一次性下载包含编译代码的整个包，而是根据浏览器渲染的组件分块加载你的包。
- en: Note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the previous chapter, we used Next.js instead of Create React App to create
    our React application, which has code splitting enabled by default.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用Next.js而不是Create React App来创建我们的React应用程序，它默认启用了代码拆分。
- en: Suspense lets your components wait until the component you're importing is ready
    to be displayed. Before React 18 it could only be used for code splitting, but
    since the latest version of React it serves more purposes. When you fetch data
    from a component that is imported with Suspense, React will also wait until the
    data for that component is completely fetched.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Suspense允许你的组件等待直到你导入的组件准备好显示。在React 18之前，它只能用于代码拆分，但自从最新版本的React以来，它有更多的用途。当你从使用Suspense导入的组件获取数据时，React也会等待直到该组件的数据完全获取。
- en: 'Suspense must be used together with the lazy method, which involves using JavaScript
    dynamic imports to load the component only when requested. Both methods can be
    imported from React in `src/App.js`, where the lazy method is used to import the
    components for our pages:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 悬念必须与懒加载方法结合使用，这涉及到使用JavaScript动态导入来仅在请求时加载组件。这两种方法都可以从React的`src/App.js`中导入，其中懒加载方法用于导入我们页面的组件：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the `return` statement for the `App` component, Suspense must be used with
    a fallback that will be displayed when the dynamically imported components are
    being loaded:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`App`组件的`return`语句中，Suspense必须与一个回退一起使用，当动态导入的组件正在加载时，将显示该回退：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When you look at the application in the browser, you don't see any changes,
    unless you have a slow internet connection. In that case, the fallback for Suspense
    will be displayed while the component is being loaded. However, when you open
    the `bundle.js` and `main.chunk.js`. However, after applying code splitting, chunked
    components are also being loaded, for example, `src_pages_ListDetail_js.js`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器中查看应用程序时，除非你有慢速的互联网连接，否则你不会看到任何变化。在这种情况下，Suspense的回退将在组件加载时显示。然而，当你打开`bundle.js`和`main.chunk.js`时。然而，在应用代码拆分后，块组件也会被加载，例如，`src_pages_ListDetail_js.js`。
- en: '![Figure 5.2 – The network requests for our application after code splitting'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 – 代码拆分后我们应用程序的网络请求'
- en: '](img/Figure_5.2_B17390.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2_B17390.jpg]'
- en: Figure 5.2 – The network requests for our application after code splitting
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 代码拆分后我们应用程序的网络请求
- en: 'Looking at the main route, which is `/`, we can see that a chunk named `3.chunk.js`
    is loaded. This isn''t a very helpful filename, something we can change with `webpackChunkName`
    in an inline comment. With this addition, we can instruct webpack to name the
    file something more user friendly:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 查看主路由`/`，我们可以看到名为`3.chunk.js`的块被加载。这不是一个非常有用的文件名，我们可以通过在行内注释中使用`webpackChunkName`来更改它。通过这个添加，我们可以指导webpack将文件命名为更用户友好的名称：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This latest addition makes recognizing which chunks (or components) are loaded
    in our application much easier, as you can see by reloading the application in
    the browser and checking the Network tab again.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最新的功能使得识别我们应用程序中加载了哪些块（或组件）变得容易得多，正如你通过在浏览器中重新加载应用程序并再次检查网络标签所看到的那样。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you've created a shopping list application that uses the Context
    API and Hooks to pass and retrieve data. Context is used to store data and Hooks
    are used to retrieve and mutate data. With the Context API, you can create more
    advanced scenarios for state management using the `useReducer` Hook. Context is
    also used to create a situation where all of the data is stored application-wide
    and can be accessed from any component by creating a shared Context. Finally,
    we've used React Suspense to apply code splitting to our bundle for improved performance.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您创建了一个使用 Context API 和 Hooks 传递和检索数据的购物清单应用程序。Context 用于存储数据，Hooks 用于检索和修改数据。使用
    Context API，您可以使用 `useReducer` Hook 创建更高级的状态管理场景。Context 还用于创建一个所有数据都存储在应用程序范围内，并且可以通过创建共享
    Context 从任何组件访问的情况。最后，我们使用了 React Suspense 来对我们的包应用代码拆分，以改善性能。
- en: The Context API will be used in the next chapter as well, which will show you
    how to build a hotel review application with automated testing using libraries
    such as Jest and Enzyme. It will introduce you to the multiple ways in which you
    can test your UI components created with React, and also show you how to test
    state management in your application using the Context API.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中也将使用 Context API，这将向您展示如何使用 Jest 和 Enzyme 等库进行自动化测试来构建一个酒店评论应用程序。它将向您介绍多种测试您使用
    React 创建的 UI 组件的方法，并展示如何使用 Context API 测试您应用程序中的状态管理。
- en: Further reading
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, refer to the following links:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅以下链接：
- en: 'Consuming multiple Context objects: [https://reactjs.org/docs/context.html#consuming-multiple-contexts](https://reactjs.org/docs/context.html#consuming-multiple-contexts)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费多个 Context 对象：[https://reactjs.org/docs/context.html#consuming-multiple-contexts](https://reactjs.org/docs/context.html#consuming-multiple-contexts)
- en: 'React Suspense: [https://reactjs.org/docs/react-api.html#reactsuspense](https://reactjs.org/docs/react-api.html#reactsuspense)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Suspense：[https://reactjs.org/docs/react-api.html#reactsuspense](https://reactjs.org/docs/react-api.html#reactsuspense)
