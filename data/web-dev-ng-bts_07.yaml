- en: Templates, Directives, and Pipes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板、指令和管道
- en: Templates define how your components are displayed, and laid out on your web
    pages. Angular provides several built-in directives that provide developers control
    over the display of their components—from whether to display or hide the component,
    to rendering it multiple times on the page. Built-in directives also provide a
    mechanism for binding classes and styles to your components.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模板定义了组件在网页上的显示和布局方式。Angular提供了几个内置指令，让开发人员控制他们的组件的显示方式——从是否显示或隐藏组件，到在页面上多次渲染组件。内置指令还提供了一种将类和样式绑定到组件的机制。
- en: In [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml), *Building Angular
    Components*, we looked at the structure of a component and how to break down our
    application into a tree of components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](acd5e47c-07a7-4954-993d-360134221325.xhtml)，*构建Angular组件*中，我们看了组件的结构以及如何将我们的应用程序分解为一棵组件树。
- en: 'In this chapter, you''ll learn how to have command over the display of your
    components within their parents'' templates. Specifically, at a high level, here''s
    what we''re going to be covering together:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何控制组件在其父模板中的显示。具体来说，我们将一起讨论以下内容：
- en: Templates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板
- en: Directives
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令
- en: Pipes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道
- en: Templates
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: In the previous chapter, we've seen what component templates are and how to
    create them. However, so far, we've only seen static HTML. In this section, I'd
    like to zoom in a little and take a look at some template syntax with you that
    allows us to create dynamic HTML, which, of course, is one of the main goals of
    Angular.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经了解了组件模板是什么以及如何创建它们。然而，到目前为止，我们只看到了静态HTML。在本节中，我想稍微放大一下，和您一起看一些模板语法，这些语法允许我们创建动态HTML，这当然是Angular的主要目标之一。
- en: Templating syntax in Angular provides us with a mechanism to make our HTML dynamic—specifically,
    for data binding, property binding, and event binding. We'll be taking a look
    at these three types of binding in this chapter. The way in which Angular gives
    us the power to create templates that produce dynamic HTML, or to manipulate the
    DOM (more on this in just a little bit), is through a set of symbols.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，模板语法为我们提供了一种机制，使我们的HTML动态化——具体来说，用于数据绑定、属性绑定和事件绑定。在本章中，我们将看看这三种绑定类型。Angular赋予我们创建生成动态HTML模板或操作DOM的能力，是通过一组符号。
- en: 'Here are the six basic symbols that we can use:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以使用的六个基本符号：
- en: '`{{ }}` for string interpolation and one-way data binding'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{ }}` 用于字符串插值和单向数据绑定'
- en: '`[( )]` for two-way data binding'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[( )]` 用于双向数据绑定'
- en: '`#` for variable declaration'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#` 用于变量声明'
- en: '`( )` for event binding'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( )` 用于事件绑定'
- en: '`[ ]` for property binding'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ ]` 用于属性绑定'
- en: '`*` prepends structural directives, such as `ngFor`, as we''ll see'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` 用于前置结构指令，例如`ngFor`，正如我们将看到的'
- en: Directives
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令
- en: The three types of the directives are:  components, attribute directives, and
    structural directives. However we're really only going to cover two of the three
    types of directives— **attribute directives** and **structural directives**. The
    reason for this is because we've already spent an entire chapter covering the
    first type of directive, and that was components. That's right! Components are
    actually directives under cover! Specifically, and stated another way (which illustrates
    how components are differentiated from attribute and structural directives), components
    are directives that have a template. Of course, this must mean that attribute
    and structural directives do not have templates.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 指令的三种类型是：组件、属性指令和结构指令。然而，我们实际上只会涵盖其中的两种——属性指令和结构指令。原因是我们已经花了整整一章的时间来覆盖第一种指令，也就是组件。没错！组件实际上是隐藏的指令！具体来说（这说明了组件与属性和结构指令的区别），组件是具有模板的指令。当然，这必须意味着属性和结构指令没有模板。
- en: 'OK, so what exactly are directives, then? Let''s give the term *directives*
    a distinct definition to get rid of any possible confusion that this terminology
    may be causing before we move on to discuss the the next two types of directives.
    The definition we''ll be using is this: *Angular directives are constructs that
    provide specific DOM manipulation operations.* DOM (or HTML DOM) is an acronym
    for Document Object Model, and is not an Angular thing—it is a browser thing.
    All modern browsers create a DOM whenever a web page is loaded, which is a tree
    of objects that is accessible by JavaScript. Without the DOM, Angular (and any
    other web framework that manipulates the DOM) would not exist.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么指令到底是什么？让我们给术语“指令”一个明确定义，以消除在讨论接下来的两种指令之前可能引起的任何混淆。我们将使用的定义是：Angular指令是提供特定DOM操作的构造。DOM（或HTML
    DOM）是文档对象模型的缩写，不是Angular的东西，而是浏览器的东西。所有现代浏览器在加载网页时都会创建一个DOM，这是一个可以被JavaScript访问的对象树。没有DOM，Angular（以及任何其他操作DOM的Web框架）都不会存在。
- en: Components, as we've seen in [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml),
    *Building Angular Components*, fit our definition of directives because they are
    indeed constructs that provide specific DOM operations. Not only are their templates
    injected into our page (replacing their custom HTML tags), but they themselves
    contain data, property, and event bindings, which further manipulate the DOM.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第6章](acd5e47c-07a7-4954-993d-360134221325.xhtml)中所看到的，构建Angular组件符合我们对指令的定义，因为它们确实是提供特定DOM操作的构造。它们的模板不仅被注入到我们的页面中（替换它们的自定义HTML标签），而且它们本身包含数据、属性和事件绑定，进一步操作DOM。
- en: We've now fully explained components in various ways, and we'll see them in
    action during the implementation of our wireframes throughout the rest of the
    chapters that follow.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经以各种方式充分解释了组件，并将在接下来的章节中看到它们在实现我们的线框时的实际应用。
- en: The remaining two types of directives do not inject any HTML templates in our
    pages or views because they do not have any templates. However, they do manipulate
    the DOM—as mandated by our previous definition of directives. Let's now look at
    what each of these types of directives do.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的两种指令类型不会在我们的页面或视图中注入任何HTML模板，因为它们没有任何模板。然而，它们会操作DOM，正如我们之前对指令的定义所要求的那样。现在让我们来看看这两种类型的指令分别是做什么的。
- en: Attribute directives
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性指令
- en: Attribute directives manipulate the DOM by changing the appearance or the behavior
    of specific DOM elements. These types of directives are surrounded by brackets,
    and are attributes of an HTML element. The brackets are symbols (one of the five
    types of symbols we listed at the beginning of this chapter), and they signal
    to Angular that it may need to change either the appearance or the behavior of
    the element for which the directive is an attribute of.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 属性指令通过改变特定DOM元素的外观或行为来操作DOM。这些类型的指令被括号括起来，是HTML元素的属性。括号是符号（我们在本章开头列出的五种符号之一），它们向Angular发出信号，告诉它可能需要改变指令所属元素的外观或行为。
- en: 'That last sentence was a mouthful, so let''s take a look at a code example
    of the attribute directive you''re most likely to use. The directive I''m referring
    to is named `hidden`, and will cause Angular to either show or hide its element:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一句话很啰嗦，让我们看一个你最有可能使用的属性指令的代码示例。我所指的指令名为`hidden`，它将导致Angular要么显示要么隐藏它的元素：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous code, we've hidden the `div` element and any embedded HTML from
    all user types that are not admins. Here, `usertype` and `admin` are, of course,
    application-contextual things, and are only used as an example to illustrate what
    Angular can do.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们隐藏了`div`元素和所有非管理员用户类型的嵌入式HTML。在这里，`usertype`和`admin`当然是应用上下文的东西，只是用作示例来说明Angular可以做什么。
- en: More generally, the `hidden` attribute directive is associated with an expression
    to be evaluated. The expression must evaluate to a Boolean (that is, `true` or
    `false`). If the expression evaluates to `true`, Angular will hide the element
    from the view. Conversely, if the expression evaluates to `false`, Angular will
    leave it alone and it will be displayed in the view.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地说，`hidden`属性指令与要评估的表达式相关联。表达式必须评估为布尔值（即`true`或`false`）。如果表达式评估为`true`，Angular将从视图中隐藏该元素。相反，如果表达式评估为`false`，Angular将不做任何改变，并且该元素将在视图中显示。
- en: As I did in previous chapters, I will make sure to point you to the official
    documentation online. As you know by now, I'm not a fan of the approach that a
    lot of other IT books take, which is to regurgitate documentation. While it's
    unavoidable to some extent, some books fill most of their pages with it. So, I
    will continue to stay away from that trap and will continue to add all the value
    I can in better ways.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我在之前的章节中所做的那样，我会确保将您指向官方在线文档。正如您现在所知，我不喜欢其他许多IT书籍采取的方法，即机械地重复文档。虽然在某种程度上是不可避免的，但有些书籍的大部分页面都是这样。因此，我将继续远离这种陷阱，并将继续以更好的方式添加所有可能的价值。
- en: That being said, the official online documentation for attribute directives
    can be found at [https://angular.io/guide/attribute-directives](https://angular.io/guide/attribute-directives).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，属性指令的官方在线文档可以在[https://angular.io/guide/attribute-directives](https://angular.io/guide/attribute-directives)找到。
- en: Structural directives
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构指令
- en: Structural directives manipulate the DOM by adding or removing specific DOM
    elements. Just as we have syntax we can use to signal to Angular that we have
    an attribute directive to which it needs pay attention to, with the brackets symbol,
    we have the equivalent for structural directives.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 结构指令通过添加或删除特定的DOM元素来操作DOM。就像我们有语法可以用来向Angular发出信号，告诉它我们有一个需要注意的属性指令一样，使用括号符号，我们也有结构指令的等价物。
- en: The syntax we use to signal to Angular that we have a structural directive it
    needs to pay attention to is the asterisk (*). Structural directives are prefixed
    with an asterisk, which signals to Angular that it may need to add or remove elements
    from the DOM. As I enumerated at the beginning of the chapter, the asterisk is
    another one of the symbols we can use in our template syntax.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来向Angular发出信号，告诉它我们有一个结构指令需要注意的语法是星号（*）。结构指令以星号为前缀，这向Angular发出信号，告诉它可能需要向DOM添加或删除元素。正如我在本章开头列举的那样，星号是我们可以在模板语法中使用的符号之一。
- en: NgFor
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgFor
- en: 'Just as we look at a code example of the attribute directive you are most likely
    to use, let''s now take a look at a code example of the structural directive you
    will probably use most often—`NgFor`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们看一个属性指令的代码示例，你最有可能使用的，现在让我们来看一个结构指令的代码示例，你可能会经常使用——`NgFor`：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The previous `ngFor` code example prints out the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的`ngFor`代码示例输出如下：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are a few things I''d like to point out in the previous code; firstly,
    the `*ngFor` structural directive. Let''s take a look at these in bullet-point
    form:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，有几件事我想指出；首先是`*ngFor`结构指令。让我们用项目符号形式来看一下这些：
- en: '`ngFor` takes an iterable, and loops through it, adding elements to the DOM'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngFor`接受一个可迭代对象，并循环遍历它，向DOM添加元素'
- en: The general form of the directive's syntax is `*ngFor="let <value> of <collection>"`
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令语法的一般形式是 `*ngFor="let <value> of <collection>"`
- en: '`NgFor` (note the capital N) refers to the class that defines the directive'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NgFor`（注意大写N）指的是定义指令的类'
- en: '`ngFor` (note the lower case n) refers to both the attribute name, as well
    as it being an instance of the `NgFor` class'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngFor`（注意小写n）既是属性名称，也是`NgFor`类的一个实例'
- en: The rest of the structural directives follow the same casing convention as `NgFor`
    (see the previous two bullet points)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余的结构指令遵循与`NgFor`相同的大小写约定（参见前两个项目符号）。
- en: We can nest `ngFor` (in much the same way that we can have nested `for each`...i
    n loops)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以嵌套使用`ngFor`（就像我们可以嵌套使用`for each`...in循环一样）
- en: Next, the collection I've provided to the `ngFor` directive is not indicative
    of how we would normally pass data to the directive. I've coded it this way for
    brevity. The way we'd normally do this is to have the data (that is, our collection)
    defined within our component class and assigned to a variable, and then use that
    variable in the statement attached to the directive.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我提供给`ngFor`指令的集合并不代表我们通常如何向指令传递数据。我之所以以这种方式编码是为了简洁。我们通常会这样做，即在组件类中定义数据（即我们的集合），并将其分配给一个变量，然后在附加到指令的语句中使用该变量。
- en: Accessing the index value of the iteration
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问迭代的索引值
- en: We'll often be interested in having access to the index value of the iteration—maybe
    to grab every *n*th object, or to group things in numbers of *x*, or maybe we
    want to implement some kind of custom pagination. Whatever the need to read the
    current index value of the iteration, we can use the `index` keyword to set the
    index to a variable within our expression.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常会对迭代的索引值感兴趣——也许是为了抓取每个第n个对象，或者按照x的数量分组，或者可能我们想要实现某种自定义分页。无论需要读取迭代的当前索引值是什么，我们都可以使用`index`关键字将索引设置为表达式中的变量。
- en: 'Here''s some example code demonstrating this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些演示这一点的示例代码：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previous code sample, let's just assume that the cars collection was
    populated elsewhere—such as in the component class.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码示例中，让我们假设汽车集合是在其他地方填充的，比如在组件类中。
- en: Also, Angular takes care of updating the index value with each iteration for
    us—and all we have to do is to reference it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Angular会为我们更新每次迭代的索引值，而我们所要做的就是引用它。
- en: Note that we use `{{ i + 1 }}` to output the car number. This is because, as
    with most arrays or iterables (in most languages, but certainly in JavaScript
    and TypeScript), the index is zero-based. Also, note that the expression within
    the double curly braces, `i + 1`, is not just a variable. In Angular, whatever
    is inserted within the double curly braces is evaluated. We could even insert
    function calls there if we wanted to.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用 `{{ i + 1 }}` 来输出汽车编号。这是因为，与大多数数组或可迭代对象一样（在大多数语言中，但肯定在JavaScript和TypeScript中），索引是从零开始的。另外，请注意，双大括号内的表达式
    `i + 1` 不仅仅是一个变量。在Angular中，双大括号内插入的任何内容都会被评估。如果我们愿意，甚至可以在那里插入函数调用。
- en: The official online documentation for structural directives is available at [https://angular.io/guide/structural-directives](https://angular.io/guide/structural-directives).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 结构指令的官方在线文档可在 [https://angular.io/guide/structural-directives](https://angular.io/guide/structural-directives)
    上找到。
- en: Built-in directives
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置指令
- en: 'There are a few built-in directives that we have at our disposal. Let''s take
    a peek at these in the sections that follow:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几个内置指令可供我们使用。让我们在接下来的部分中看看这些。
- en: '`NgFor` (we''ve already covered this one, as the first example of a structural
    directive)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NgFor`（我们已经涵盖了这个，作为结构指令的第一个示例）'
- en: '`NgIf`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NgIf`'
- en: '`NgSwitch`, `NgCase`, and `NgDefault`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NgSwitch`、`NgCase` 和 `NgDefault`'
- en: '`NgStyle`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NgStyle`'
- en: '`NgClass`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NgClass`'
- en: '`NgNonBindable`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NgNonBindable`'
- en: NgIf
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgIf
- en: When we want to either display or remove an element from the DOM, we use the
    `NgIf` directive. We pass an expression to the directive, and it must evaluate
    to a Boolean. If it evaluates to `true`, the element will be displayed on the
    view. Conversely, if the expression evaluates to `false`, the element will be
    removed from the DOM.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要在DOM中显示或移除元素时，我们使用 `NgIf` 指令。我们向指令传递一个表达式，它必须求值为布尔值。如果求值为 `true`，元素将在视图上显示。相反，如果表达式求值为
    `false`，元素将从DOM中移除。
- en: Note that we can also bind to the `hidden` property (property binding will be
    described as follows) to achieve the same thing, visually, but there is a difference
    between the property binding method, and using the `NgIf` directive. The difference
    is that using property binding on `hidden` just hides the element, whereas using
    the `NgIf` directive physically removes the element from the DOM.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还可以绑定到 `hidden` 属性（属性绑定将在下文中描述）来实现相同的视觉效果，但是属性绑定方法和使用 `NgIf` 指令之间存在区别。区别在于，使用
    `hidden` 的属性绑定只是隐藏元素，而使用 `NgIf` 指令会从DOM中实际移除元素。
- en: 'Here is what `NgIf` looks like in code (in the context of our car example,
    assume we had a `horsepower` property):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码中 `NgIf` 的样子（在我们的汽车示例中的上下文中，假设我们有一个 `horsepower` 属性）：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In most traditional programming languages when there are alternate things to
    check for in sequence, as in a series of traditional `if`, `then`, and `else`
    statements, it sometimes makes more sense to use a `switch` statement (if the
    language supports one). Java, JavaScript, and TypeScript are examples of languages
    (and there are, of course, many others) that support this conditional construct.
    Angular gives this power to us as well, so we can be more expressive and efficient
    with our code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数传统编程语言中，当有一系列传统的 `if`、`then` 和 `else` 语句中要检查的替代事物时，有时使用 `switch` 语句（如果语言支持）更有意义。Java、JavaScript
    和 TypeScript是支持这种条件构造的语言的例子（当然还有许多其他语言）。Angular也给了我们这种能力，所以我们可以更加表达和高效地编写我们的代码。
- en: Let's take a look at how this is accomplished in Angular in the next section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看在Angular中如何实现这一点。
- en: NgSwitch, NgCase, and NgDefault
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgSwitch、NgCase 和 NgDefault
- en: In several programming languages, such as Java, JavaScript, and TypeScript,
    the `switch` statement does not work in isolation. It works in concert with other
    statements and keywords—namely, `case` and `default`. Angular's `NgSwitch` directive
    works exactly the same way, in that `NgSwitch` works in concert with `NgCase`
    and `NgDefault`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些编程语言中，比如Java、JavaScript和TypeScript，`switch`语句不能单独使用。它需要与其他语句和关键字一起使用，即`case`和`default`。Angular的`NgSwitch`指令的工作方式完全相同，`NgSwitch`与`NgCase`和`NgDefault`一起使用。
- en: 'Let''s flesh out a slightly larger example here by creating a component that
    will contain our car data, our styling, and our template, which makes use of `NgSwitch`,
    with `NgCase` and `NgDefault`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个包含我们的汽车数据、样式和模板的组件来丰富一下这里稍微大一点的例子，该组件使用`NgSwitch`，`NgCase`和`NgDefault`：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, we've constructed a complete component named
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们构建了一个完整的组件
- en: '`CarHorsepowerComponent`. Within the parent component template, Angular will
    replace instances of our custom HTML element, `<car-hp>`, with the template we''ve
    created in our `CarHorsepowerComponent` (this is because we assigned `car-hp`
    to the `selector` property of the component annotation of our `CarHorsepowerComponent`
    class).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`CarHorsepowerComponent`。在父组件模板中，Angular将用我们在`CarHorsepowerComponent`中创建的模板替换我们自定义的HTML元素`<car-hp>`的实例（这是因为我们将`car-hp`分配给了我们的`CarHorsepowerComponent`类的组件注解的`selector`属性）。'
- en: We've also included the data for the collection we're passing to the `NgFor`
    directive within our component class, as opposed to it being inline within the
    expression assigned to the `NgFor` directive, as we did in a previous example.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在组件类中包含了传递给`NgFor`指令的集合数据，而不是在之前的例子中内联在分配给`NgFor`指令的表达式中。
- en: 'This was a simple example whose template iterates through our cars collection,
    and applies one of three styles to the make and model of the cars based on the
    current car''s horsepower—and this is accomplished via the `NgSwitch`, `NgCase`,
    and `NgDefault` directives. Specifically, here''s the result:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，其模板遍历我们的汽车集合，并根据当前汽车的马力应用三种样式之一到汽车的品牌和型号上-这是通过`NgSwitch`、`NgCase`和`NgDefault`指令实现的。具体来说，这是结果：
- en: If the car's horsepower is equal to or greater than 375 HP, we're going to consider
    it to be a supercar and will have the car's make and model rendered in white font
    with a red background
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果汽车的马力等于或大于375马力，我们将认为它是一辆超级跑车，并且将汽车的品牌和型号以白色字体呈现在红色背景上
- en: If the car's horsepower is equal to or greater than 200 HP, but less than 375
    HP, we're going to consider it to only be a sports car and will have the car's
    make and model rendered in black font with an orange background
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果汽车的马力等于或大于200马力，但小于375马力，我们将认为它只是一辆跑车，并且将汽车的品牌和型号以黑色字体呈现在橙色背景上
- en: If the car's horsepower is anything under 200 HP, which is our *default* (or
    *catch-all*) case, we're going to consider it to be a car that is suitably safe
    for a grandmother to drive, and will have the car's make and model rendered in
    black font with a yellow background—because most grandmothers find the color scheme
    of honey bees to be attractive
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果汽车的马力低于200马力，这是我们的*默认*（或*通用*）情况，我们将认为它是一辆适合祖母开车的汽车，并且将汽车的品牌和型号以黑色字体呈现在黄色背景上-因为大多数祖母都觉得蜜蜂的颜色搭配很吸引人
- en: Of course, the grandmother comment was for entertainment value only, and I'm
    not trying to intentionally offend anyone who drives a car that takes a full 8
    seconds, *or more,* to accelerate from 0 to 60 MPH (wink). Truth be told, one
    of my cars (a 2016 Honda Civic) only has 158 HP—and believe me, I've been passed
    on the road going uphill by a grandmother driving an Infinity Q50\. That's why
    I bought something more powerful within the next couple of days after that horrible
    experience (big smile).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，祖母的评论只是为了娱乐价值，我并不是故意冒犯任何需要花费整整8秒，*甚至更多*时间从0到60英里/小时加速的人（眨眼）。说实话，我的一辆车（2016年本田思域）只有158马力——相信我，我曾经在上坡路上被一位开英菲尼迪Q50的祖母超过。这就是为什么在那可怕的经历之后的几天内，我买了一些更强大的东西（大笑）。
- en: One last thing I wanted to point out in this previous example is the way in
    which the `NgSwitch` directive was used. You'll note that I wrote it in a different
    format, namely `[ngSwitch]="car.horsepower"`, instead of `*ngSwitch="car.horsepower"`.
    This is because there is a rule that Angular imposes on us when it comes to structural
    directives, which is that we cannot have more than one structural directive using
    the asterisk symbol prepending the directive's name. To work around this, we used
    the property binding symbol, `[ ]` (a pair of square brackets).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在上一个示例中指出的最后一件事是`NgSwitch`指令的使用方式。您会注意到我以不同的格式编写了它，即`[ngSwitch]="car.horsepower"`，而不是`*ngSwitch="car.horsepower"`。这是因为在使用结构指令时，Angular对我们施加了一条规则，即我们不能有多个使用星号符号作为指令名称前缀的结构指令。为了解决这个问题，我们使用了属性绑定符号`[
    ]`（一对方括号）。
- en: NgStyle
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgStyle
- en: 'The `NgStyle` directive is used for setting an element''s style properties.
    Let''s rework our previous `CarHorsepowerComponent` example, which used to demonstrate `NgSwitch`,
    `NgCase`, and `NgDefault`, in order to show how the same desired outcome (that
    is, conditionally styling elements) can be better done using `NgStyle`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgStyle`指令用于设置元素的样式属性。让我们重新设计之前的`CarHorsepowerComponent`示例，该示例用于演示`NgSwitch`，`NgCase`和`NgDefault`，以展示如何使用`NgStyle`更好地实现相同的期望结果（即有条件地设置元素样式）：'
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In our reworking of the original `CarHorsepowerComponent` class, we've lightened
    up our component template by moving the logic into a function within the class.
    We've removed the styles property of the component annotation, and instead created
    a function (that is, `getCarTextStyle`) to return the style text to the calling
    function so that we can set the correct style.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们重新设计原始的`CarHorsepowerComponent`类时，我们通过将逻辑移入类中的一个函数来简化了组件模板。我们删除了组件注释的样式属性，而是创建了一个函数（即`getCarTextStyle`）来返回样式文本给调用函数，以便我们可以设置正确的样式。
- en: Though this is a cleaner approach, we can do even better. Since we're setting
    a style for the car text, we can just change the style class altogether, as opposed
    to passing the actual style rulesets via text.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一种更清晰的方法，但我们可以做得更好。由于我们正在为汽车文本设置样式，我们可以完全更改样式类，而不是通过文本传递实际的样式规则集。
- en: In the next section, on `NgClass`, we'll rework our code one more time to see
    how this is done.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，关于`NgClass`，我们将再次重写我们的代码，以了解如何完成这一点。
- en: NgClass
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgClass
- en: The `NgClass` directive is similar to the `NgStyle` directive, but is used to
    set the style class (from the CSS rulesets with the styles property of the component
    annotation), instead of setting the style via the raw CSS rulesets.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgClass`指令类似于`NgStyle`指令，但用于设置样式类（从组件注释的样式属性中的CSS规则集），而不是通过原始CSS规则集设置样式。'
- en: 'The following code example is the best choice of the last three code examples
    in order to achieve what we want to do:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例是最后三个代码示例中最好的选择，以实现我们想要做的事情：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we've kept our `styles` property for our component annotation, we've kept
    the template light and clean, and our function just returns the name of the CSS
    class to be assigned to our `NgClass` directive.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们保留了组件注释的`styles`属性，保持了模板的轻量和清晰，我们的函数只返回要分配给我们的`NgClass`指令的CSS类的名称。
- en: NgNonBindable
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgNonBindable
- en: The last directive in our list to cover is the `NgNonBindable` directive. `NgNonBindable`
    is used when we want Angular to ignore the special symbols in our template syntax.
    Why would we want to do this? Well, let's say that you and I decided to create
    an online Angular tutorial, and the website itself was to be coded using Angular.
    If we wanted to render the text `{{ my_value }}` to the view, Angular would try
    to find the `my_value` variable within its current scope to bind the value and
    then insert the text in its place. Since this is not what we'd want Angular to
    do, we need a way to instruct Angular, *Hey, by the way, do not try and evaluate
    and string interpolate anything right now—just render the symbols as you would
    with any other normal text*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要介绍的最后一个指令是`NgNonBindable`指令。当我们希望Angular忽略模板语法中的特殊符号时，就会使用`NgNonBindable`。为什么我们要这样做呢？嗯，假设你和我决定创建一个在线的Angular教程，而网站本身要使用Angular进行编码。如果我们想要将文本`{{
    my_value }}`呈现到视图中，Angular会尝试在当前范围内查找`my_value`变量来绑定值，然后插入文本。由于这不是我们希望Angular做的事情，我们需要一种方法来指示Angular，“嘿，顺便说一句，现在不要尝试评估和字符串插值任何东西，只需像对待任何其他普通文本一样呈现这些符号”。
- en: 'Here is what this looks like for, say, a `span` element:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，这是一个`span`元素的样子：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note the placement of the `NgNonBindable` directive within the opening `<span>`
    tag. When Angular sees `ngNonBindable`, it will disregard the double curly braces
    and will not one-way bind anything. Instead, it will let the raw text be rendered
    to the view.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`NgNonBindable`指令在开放的`<span>`标记中的位置。当Angular看到`ngNonBindable`时，它将忽略双大括号，并且不会单向绑定任何内容。相反，它将让原始文本呈现到视图中。
- en: Data binding using the NgModel directive
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NgModel指令进行数据绑定
- en: We've seen an example of one-way data binding within our example that demonstrated
    how to use the `NgFor` directive. Namely, one-way data binding is done using the
    double curly braces symbol, `{{ }}`. The variable that we enclose within the double
    curly braces (such as `car.make` and `car.model` from the example) is bound one-way
    (that is, from the component class to the template), converted to a string, and
    rendered to the view. It does not allow for binding any changes back to the component
    class.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在示例中看到了单向数据绑定的一个例子，该示例演示了如何使用`NgFor`指令。换句话说，单向数据绑定是使用双大括号符号`{{ }}`完成的。我们在双大括号中包含的变量（例如示例中的`car.make`和`car.model`）是单向绑定的（即从组件类到模板），转换为字符串，并呈现到视图中。它不允许将任何更改绑定回组件类。
- en: In order for us to implement two-way data binding, thereby also allowing the
    binding of changes within the view back to the component class, we have to use
    the `NgModel` directive.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现双向数据绑定，从而也允许在视图中绑定对组件类的更改，我们必须使用`NgModel`指令。
- en: 'We''re going to see this in action when we implement our wireframes, but let
    me show you what this looks like for now. In order to use `NgModel`, we have to
    first import an Angular module named `FormsModule` from the `forms` package, like
    this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现我们的线框时，我们将看到这一点，但现在让我向你展示一下它是什么样子的。为了使用`NgModel`，我们必须首先从`forms`包中导入一个名为`FormsModule`的Angular模块，就像这样：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, to use this directive, we''d have something like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要使用这个指令，我们会有类似这样的东西：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Having this code in place would not only cause the view template to display
    the value of `my_content` in the component class, but any changes to this `div`
    within the view template would be then be bound back to the component class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将这段代码放在这里不仅会导致视图模板显示组件类中`my_content`的值，而且对视图模板中这个`div`的任何更改都会被绑定回组件类。
- en: Event binding
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件绑定
- en: We're going to see a lot of event binding during our implementation of the example
    application's wireframes. To bind an event that we're interested in listening
    for on an element, we enclose the event name within parentheses (which are one
    of our special symbols that we can use in our template syntax). To do so, we assign
    a statement to be run when the event is triggered.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现示例应用程序的线框时，我们将看到很多事件绑定。为了绑定我们感兴趣的元素上要监听的事件，我们将事件名称括在括号中（这是我们在模板语法中可以使用的特殊符号之一）。为此，我们分配一个语句在事件触发时运行。
- en: 'Here is an example of a JavaScript alert that will be triggered when someone
    clicks within the `<span>` element:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个JavaScript警报的例子，当有人点击`<span>`元素时将会触发：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we have attached a `click` event and we invoke an alert
    box with the message.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们附加了一个`click`事件，并调用一个带有消息的警报框。
- en: Property binding
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性绑定
- en: 'We''ve seen property binding in previous examples, but for completeness, I
    will very briefly give another example here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在先前的例子中已经看到了属性绑定，但为了完整起见，我在这里很简要地给出另一个例子：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this previous example, we enclose the property we want to set within square
    brackets (which are one of the special symbols that we can use in our template
    syntax). Of course, this is not that useful in this example, because I've hardcoded
    the Boolean to `true` instead of using an expression that is to be evaluated—but
    the point of this example was to focus on the `[hidden]` part.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个先前的例子中，我们将要设置的属性括在方括号中（这是我们在模板语法中可以使用的特殊符号之一）。当然，在这个例子中这并不是很有用，因为我已经将布尔值硬编码为`true`，而不是使用要求评估的表达式，但这个例子的重点是集中在`[hidden]`部分。
- en: Custom directives
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义指令
- en: Angular is extensible. Not only can we easily create our own custom components
    (so that we're not restricted to using ready-made components from third parties),
    but we can also create our own attribute directives so that we're not restricted
    to what Angular gives us out of the box.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是可扩展的。我们不仅可以轻松创建自定义组件（这样我们就不受限于使用第三方提供的现成组件），还可以创建自定义属性指令，这样我们就不受限于Angular默认提供的内容。
- en: I'll leave some of the custom things we can do in Angular, such as custom attribute
    directives, custom pipes (we'll see what pipes are in the next section), and custom
    form validation, until [Chapter 14](485921eb-86e2-4068-b314-5c62a1545c22.xhtml),
    *Advanced Angular Topics*. We'll be taking a look at form validation in [Chapter
    10](5f27121b-6fb2-4429-aa6e-394aec2152ac.xhtml), *Working with Forms*. There's
    a good reason why I chose to lump all of the advanced stuff that is covered in
    this book into one chapter—to give you time to digest the basic stuff first. By
    the time the advanced chapter comes along, near the end of the book, you'll be
    ready and primed to more easily absorb that information.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我会留下一些我们在Angular中可以做的自定义事情，比如自定义属性指令、自定义管道（我们将在下一节中看到管道是什么），以及自定义表单验证，直到[第14章](485921eb-86e2-4068-b314-5c62a1545c22.xhtml)，*高级Angular主题*。我们将在[第10章](5f27121b-6fb2-4429-aa6e-394aec2152ac.xhtml)，*使用表单*中看到表单验证。我选择将这本书中涵盖的所有高级内容都放在一个章节中是有充分理由的——让你有时间先消化基础知识。当高级章节出现时，接近书的末尾，你将准备好并更容易吸收那些信息。
- en: Pipes
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道
- en: Pipes are used for formatting the data in our template views. Pipes will take
    data as input and transform it into our desired format for displaying it to end
    user. We can use the `pipe` property (`|`) in any Angular template or view in
    our project.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 管道用于格式化我们模板视图中的数据。管道将接受数据作为输入，并将其转换为我们期望的格式，以便向最终用户显示。我们可以在我们项目中的任何Angular模板或视图中使用`pipe`属性（`|`）。
- en: Let me give you a quick rundown before we jump into creating our examples. Let's
    say that, from the backend service, we get the price of a product as 100, and
    based on the user's country or preference, we may want to display the value as
    $100 if the user is from the USA, or INR 100 if the user is from India. So, we
    are able to transform the way that we display the price without any major complexity.
    This is thanks to the currency pipe operator.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建示例之前，让我快速概述一下。假设我们从后端服务获取产品的价格为100，并根据用户的国家或偏好，我们可能希望以$100的方式显示价值，如果用户来自美国，或者以INR
    100的方式显示价值，如果用户来自印度。因此，我们能够在没有任何主要复杂性的情况下转换我们显示价格的方式。这要归功于货币管道运算符。
- en: Angular provides a lot of built-in pipes ready to use directly in our templates.
    Additionally, we can also create our own custom pipes to extend our application's
    functionality.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了许多内置管道，可以直接在我们的模板中使用。此外，我们还可以创建自定义管道来扩展我们应用程序的功能。
- en: 'Here''s the list of all the built-in pipes that Angular provides:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Angular提供的所有内置管道的列表：
- en: Lowercase pipe
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小写管道
- en: Uppercase pipe
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大写管道
- en: Date pipe
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期管道
- en: Currency pipe
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 货币管道
- en: JSON pipe
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON管道
- en: Percent pipe
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 百分比管道
- en: Decimal pipe
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小数管道
- en: Slice pipe
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片管道
- en: We will learn about each of the available built-in pipes by doing some fun,
    practical examples. We can make use of any of the existing template files that
    we have created in our Angular project so far.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一些有趣的实际示例来了解每个可用的内置管道。到目前为止，我们可以利用我们在Angular项目中创建的任何现有模板文件。
- en: 'We will need some data that we want to process and transform using our pipes.
    I am going to quickly create a dataset in our `app.component.ts` file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些数据，我们想要使用我们的管道来处理和转换。我将在我们的`app.component.ts`文件中快速创建一个数据集：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have created a sample dataset for products in our app component. Great, now
    we are good to apply our pipes in our `app.component.html` file. We are going
    to keep it simple in our template. We will just create a table and bind the values
    in the table. If you are feeling a little adventurous today, go ahead create a
    layout for our application using Flex-Layout, which we learned in [Chapter 5](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml),
    *Flex-Layout – Angular's Responsive Layout Engine:*
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序组件中创建了一个产品的样本数据集。好了，现在我们可以在我们的`app.component.html`文件中应用我们的管道了。我们将在模板中保持简单。我们将只创建一个表格并绑定表中的值。如果你今天感觉有点冒险，那就继续使用Flex-Layout为我们的应用程序创建一个布局，我们在[第5章](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml)中学到了*Flex-Layout
    – Angular's Responsive Layout Engine*：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding sample code, we have created a table and, using the data binding,
    we have bound the data in our template. Now it''s time to use the pipe operator
    in our template. To apply any pipe, we will have to add the pipe operator against
    the data, as shown in the following syntax:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例代码中，我们创建了一个表格，并使用数据绑定将数据绑定到我们的模板中。现在是时候在我们的模板中使用管道运算符了。要应用任何管道，我们必须在数据中添加管道运算符，如下面的语法所示：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can easily transform our product name into uppercase by applying the uppercase
    pipe, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过应用大写管道轻松地将我们的产品名称转换为大写，如下所示：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Similarly, we can apply the lowercase pipe as well, which will make all characters
    lowercase:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们也可以使用小写管道，这将使所有字符变为小写：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That was very simple, you might say? So it is! Let's keep rolling. In a similar
    way, we will use the number pipe operator to show or hide the decimal points.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会说那太简单了？确实如此！让我们继续。类似地，我们将使用数字管道操作符来显示或隐藏小数点。
- en: 'For displaying product prices, we want to add the currency; no problem, we
    will use the currency pipe:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示产品价格，我们想要添加货币；没问题，我们将使用货币管道：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding example, we have transformed the product price by adding the
    currency pipe. The remaining pipe operators I am leaving to you as homework.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们通过添加货币管道来转换了产品价格。剩下的管道操作符就留给你作业了。
- en: By default, `$ currency` is added when we use the currency pipe.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用货币管道时，默认情况下会添加`$ currency`。
- en: 'We can customize it by parameterizing the currency pipe. We will learn how
    to pass parameters to the pipe operators. We will have to extend the syntax of
    the pipe operator by passing the parameters as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过给货币管道加参数来自定义它。我们将学习如何向管道操作符传递参数。我们将不得不通过以下方式扩展管道操作符的语法来传递参数：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding syntax looks similar to how we learned to define a pipe operator,
    except that now it has two parameters. We can define a pipe operator with any
    number of parameters based on our requirements. We have used the currency operator
    in the previous example, so let''s pass parameters to extend the currency pipe
    operator:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语法看起来类似于我们学习如何定义管道操作符的方式，只是现在它有两个参数。根据我们的需求，我们可以定义任意数量的参数的管道操作符。在前面的例子中，我们使用了货币操作符，所以让我们传递参数来扩展货币管道操作符：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We are passing the `INR`  parameter to our currency pipe operator. Now, the
    output of the currency pipe operator will not be `$` anymore; instead, it will
    be as shown in the following screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在向我们的货币管道操作符传递`INR`参数。现在，货币管道操作符的输出将不再是`$`，而是如下所示的屏幕截图中显示的内容：
- en: '![](assets/6a445fcb-47d2-494e-8ff7-1c9a932b9260.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6a445fcb-47d2-494e-8ff7-1c9a932b9260.png)'
- en: We have learned to use built-in pipe operators in this section. Now, we'll learn
    about creating our own custom pipes. .
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经学会了使用内置的管道操作符。现在，我们将学习如何创建我们自己的自定义管道。
- en: Custom pipes
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义管道
- en: Angular is extensible in this area of custom pipes as well as well as custom
    directives. However, I'm deferring our discussion of custom pipes until [Chapter
    14](485921eb-86e2-4068-b314-5c62a1545c22.xhtml), *Advanced Angular Topics*. I've
    included this section here as a placeholder, and a reminder of later coverage,
    as well as for completeness.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Angular在自定义管道和自定义指令的领域也是可扩展的。然而，我将推迟我们对自定义管道的讨论，直到[第14章](485921eb-86e2-4068-b314-5c62a1545c22.xhtml)，“高级Angular主题”。我在这里包含了这一部分作为一个占位符，以及对以后的覆盖的提醒，也是为了完整性。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we zoomed in on component templates, and on what template syntax
    was available to us for creating them. Our template syntax included symbols, directives,
    and pipes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们放大了组件模板，以及我们用于创建它们的模板语法。我们的模板语法包括符号、指令和管道。
- en: We've seen that directives are just templateless components, and they come in
    two main flavors—**attribute directives**, and **structural directives**. Whatever
    their flavor or category, we associate (or attach) directives to HTML elements
    by adding them as attributes of those elements.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到指令只是没有模板的组件，它们有两种主要的类型——**属性指令**和**结构指令**。无论它们的类型或类别如何，我们都可以通过将它们添加为元素的属性来将指令与HTML元素关联（或附加）。
- en: We've gone over the following special symbols that we can use in our template
    syntax. We've also covered the built-in directives that we can use in our template
    syntax. Next, we covered event binding, as well as property binding, and finally,
    we covered pipes, which provide us with the means to format our data so that it
    can be rendered to our views in the way we desire.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了我们可以在模板语法中使用的以下特殊符号。我们还介绍了我们可以在模板语法中使用的内置指令。接下来，我们介绍了事件绑定，以及属性绑定，最后，我们介绍了管道，它为我们提供了格式化数据的方式，以便按照我们期望的方式呈现到视图中。
- en: We know that Angular is extensible and that it provides us with mechanisms to
    create custom directives, as well as custom pipes—but we are deferring our discussion
    of anything custom to [Chapter 14](485921eb-86e2-4068-b314-5c62a1545c22.xhtml),
    *Advanced Angular Topics*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道Angular是可扩展的，并且它为我们提供了创建自定义指令和自定义管道的机制，但我们将推迟讨论任何自定义内容到[第14章]《高级Angular主题》。
- en: In the next chapter, [Chapter 8](784689d5-c12c-4a1d-b2a4-dfcdbe7e6d38.xhtml),
    *Working with NG Bootstrap*, we're going to put our component hats back on our
    heads so that we can explore what `ng-bootstrap` brings to the table for us in
    building our Angular applications.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[第8章]《使用NG Bootstrap工作》，我们将重新戴上组件帽子，以便探索`ng-bootstrap`为我们在构建Angular应用程序时带来了什么。
