- en: Building a Media Streaming Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Uploading and streaming media content, specifically video content, has been
    a growing part of the internet culture for some time now. From individuals sharing
    personal video content to the entertainment industry disseminating commercial
    content on online streaming services, we all rely on web applications that enable
    smooth uploading and streaming. Capabilities within the MERN stack technologies
    can be used to build and integrate these core streaming features into any MERN-based
    full-stack application. In this chapter, we will extend the MERN skeleton application
    to build a media streaming application, while demonstrating how to utilize MongoDB
    GridFS and add media streaming features to your web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics to implement basic media
    uploading and streaming by extending the MERN skeleton application:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing MERN Mediastream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading videos to MongoDB GridFS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and retrieving media details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streaming videos from GridFS to a basic media player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing, displaying, updating, and deleting media
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing MERN Mediastream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will build the MERN Mediastream application by extending the skeleton application.
    This will be a simple video streaming application that allows registered users
    to upload videos that can be streamed by anyone browsing the application. The
    following screenshot shows the home page view on the MERN Mediastream application,
    along with a list of popular videos on the platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a726f61d-5154-48bd-a13e-ae648367456b.png)'
  prefs: []
  type: TYPE_IMG
- en: The code for the complete MERN Mediastream application is available on GitHub
    at [https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter11%20and%2012/mern-mediastream](https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter11%20and%2012/mern-mediastream).
  prefs: []
  type: TYPE_NORMAL
- en: You can clone this code and run the application as you go through the code explanations
    in the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The frontend user interface views that are needed for the features related
    to media uploading, editing, and streaming in a simple media player will be developed
    by extending and modifying existing React components in the MERN skeleton application. The
    component tree shown in the following diagram shows all the custom React components
    that make up the MERN Mediastream frontend that will be developed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80f78dff-f6a3-48b6-9244-f532cb0ffa45.png)'
  prefs: []
  type: TYPE_IMG
- en: We will add new React components to implement views for uploading a new video,
    listing already posted media, modifying media post details, and displaying a video
    where users can interact with the video content to stream and watch it. We will also
    modify existing components such as the `Home` component so we can render a list
    of popular videos and the `Profile` component so we can list all the videos that
    are posted by a given user. These uploading and streaming capabilities in the
    application will rely on the user's ability to upload video content. In the next
    section, we will discuss how to allow signed-in users to add media to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading and storing media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Registered users on the MERN Mediastream application will be able to upload
    videos from their local files to store each video and related details directly
    on MongoDB using GridFS. To enable uploading media content to the application,
    we need to define how to store media details and the video content and implement
    a full-stack slice that will let users create a new media post and upload a video
    file. In the following sections, first we will define a media model for storing
    the details of each media post and configure GridFS to store the associated video
    content. Then, we will discuss implementations for the backend API, which will
    receive and store the video content with other media details, and the frontend
    form view, which will allow a user to create a new media post on the application.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Media model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will implement a Mongoose model to define a Media model for storing the
    details of each piece of media that''s posted to the application. This model will
    be defined in `server/models/media.model.js`, and the implementation will be similar
    to other Mongoose model implementations we covered in the previous chapters, such
    as the Course model we defined in [Chapter 6](c58ac055-5a1e-4bf4-b8a6-c9b311cf267a.xhtml), *Building
    a Web-Based Classroom Application*. The Media schema in this model will have fields
    to record the media title, description, genre, number of views, dates of when
    the media was posted and updated, and a reference to the user who posted the media. The
    code for defining the media fields is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Media title**: The `title` field is declared to be of the `String` type and
    will be a required field for introducing the media that are uploaded to the application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Media description and genre**: The `description` and `genre` fields will
    be of type `String`, and these will store additional details about the media posted.
    The `genre` field will also allow us to group the different media uploaded to
    the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Number of views**: The `views` field is defined as a `Number` type and will
    keep track of how many times the uploaded media was viewed by users in the application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Media posted by**: The `postedBy` field will reference the user who created
    the media post:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Created and updated at times**: The `created` and `updated` fields will be `Date` types,
    with `created` generated when a new media is added and `updated` changed when
    any media details are modified:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The fields that were added to the schema definition will only store details
    about each video that's posted to the application. In order to store the video
    content itself, we will use MongoDB GridFS. Before getting into the implementation
    of uploading a video file, in the next section we will discuss how GridFS makes
    it possible to store large files in MongoDB, and then add initialization code
    to start using GridFS in this streaming application.
  prefs: []
  type: TYPE_NORMAL
- en: Using MongoDB GridFS to store large files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we discussed how files uploaded by users could be stored
    directly in MongoDB as binary data; for example, when adding a profile photo in the
    *Upload profile photo* section in [Chapter 5](27d3dbdf-0617-4ad8-9dcc-27afa417c174.xhtml),
    *Growing the Skeleton into a Social Media Application*. But this only worked for
    files smaller than 16 MB. In order to store larger files in MongoDB, such as video
    files needed for this streaming application, we will need to use GridFS.
  prefs: []
  type: TYPE_NORMAL
- en: GridFS is a specification in MongoDB that allows us to store large files in
    MongoDB by dividing a given file into several chunks. Each chunk can be a maximum
    of 255 KB in size, and is stored as a separate document. When the file has to
    be retrieved in response to a query to GridFS, the chunks are reassembled as needed.
    This opens up the option to fetch and load only parts of the file as required,
    rather than retrieving the whole file.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of storing and retrieving video files for the MERN Mediastream application,
    we will utilize GridFS to store video files and stream parts of the video, depending
    on which part the user skips to and starts playing from.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about the GridFS specification and its features in the official
    MongoDB documentation at [https://docs.mongodb.com/manual/core/gridfs/](https://docs.mongodb.com/manual/core/gridfs/).
  prefs: []
  type: TYPE_NORMAL
- en: To access and work with MongoDB GridFS from our backend code, we will use the Node.js
    MongoDB driver's streaming API by creating a `GridFSBucket` with the established
    database connection.
  prefs: []
  type: TYPE_NORMAL
- en: GridFSBucket is the GridFS streaming interface that gives us access to the streaming
    GridFS API. It can be used to interact with files in GridFS. You can learn more
    about GridFSBucket and the streaming API in the Node.js MongoDB Driver API documentation
    at [https://mongodb.github.io/node-mongodb-native/3.2/api/GridFSBucket.html](https://mongodb.github.io/node-mongodb-native/3.2/api/GridFSBucket.html).
  prefs: []
  type: TYPE_NORMAL
- en: Since we are using Mongoose to establish a connection with the MongoDB database
    for our application, we will add the following code to initialize a new `GridFSBucket`
    with this database connection after it has been established.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `gridfs` object we created here will give us access to the GridFS functionalities
    that are required to store the video file when new media is created and to fetch
    the file when the media is to be streamed back to the user. In the next section,
    we will add a create media form view and an API in the backend, which will use
    this `gridfs` object to save the video file that's uploaded with the request that's
    sent from the form view in the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new media post
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a user to be able to create a new media post on the application, we will
    need to integrate a full-stack slice that allows the user to fill out a form in
    the frontend and then save both the provided media details and the associated
    video file in the database in the backend. To implement this feature, in the following
    sections, we will add a create media API in the backend, along with a way to fetch
    this API in the frontend. Then, we will implement a create new media form view
    that allows the user to input media details and select a video file from their
    local filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: The create media API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will implement a create media API in the backend to allow users to create
    new media posts on the application. This API will receive a POST request at `'/api/media/new/:userId'`
    with the multipart body content containing the media fields and the uploaded video
    file. First, we will declare the create media route and utilize the `userByID`
    method from the user controller, as shown in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `userByID` method processes the `:userId` parameter that's passed in the
    URL and retrieves the associated user from the database. The user object becomes
    available in the request object to be used in the next method that will be executed. Similar
    to the user and auth routes, we will have to mount the media routes on the Express
    app in `express.js` as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/express.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A POST request to the create route URL, `/api/media/new/:userId`, will make
    sure the user is signed in and then initiate the `create` method in the media
    controller. The `create` controller method will use the `formidable` node module
    to parse the multipart request body that will contain the media details and video
    file uploaded by the user. You can install the module by running the following
    command from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the `create` method, we will use the media fields that have been received
    in the form data and parsed with `formidable` to generate a new Media object and
    then save it to the database. This `create` controller method is defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If there is a file in the request, `formidable` will store it temporarily in
    the filesystem. We will use this temporary file and the media object's ID to create
    a writable stream with `gridfs.openUploadStream`. Here, the temporary file will
    be read and then written into MongoDB GridFS, while setting the `filename` value
    to the media ID. This will generate the associated chunks and file information
    documents in MongoDB, and when it is time to retrieve this file, we will identify
    it with the media ID.
  prefs: []
  type: TYPE_NORMAL
- en: To use this create media API in the frontend, we will add a corresponding `fetch`
    method in `api-media.js` to make a `POST` request to the API by passing the multipart
    form data from the view. This method will be defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/api-media.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This `create` fetch method will take the current user's ID, user credentials,
    and the media form data to make a POST request to the create media API in the
    backend. We will use this method when the user submits the new media form to upload
    a new video and post it on the application. In the next section, we will look
    at the implementation of this form view in the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: The NewMedia component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Registered users on the MERN Mediastream application will interact with a form
    view to enter details of a new media post. This form view will be rendered in
    the `NewMedia` component, which will allow a signed-in user to create a media
    post by entering the title, description, and genre of the video and uploading
    a video file from their local filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'This form view will render as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/044f5619-fbaa-42bb-bcad-e5d2f97c93f6.png)'
  prefs: []
  type: TYPE_IMG
- en: We will implement this form in a React component named `NewMedia`. For the view,
    we will add the file upload elements using a Material-UI `Button` and an HTML5
    file `input` element, as shown in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/NewMedia.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the file `input` element, we specify that it accepts video files, so when
    the user clicks on Upload and browses through their local folders, they only have
    the option to upload a video file.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the view, we add the title, description, and genre form fields with
    the `TextField` components, as shown in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/NewMedia.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These form field changes will be tracked with the `handleChange` method when
    a user interacts with the input fields to enter values. The `handleChange` function
    will be defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/NewMedia.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `handleChange` method updates the state with the new values, including the
    name of the video file, if one is uploaded by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can complete this form view by adding a Submit button, which, when
    clicked, should send the form data to the server. We will define a `clickSubmit` method
    here, which will be called when the Submit button is clicked by the user.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/NewMedia.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This `clickSubmit` function will take the input values and populate `mediaData`,
    which is a `FormData` object that ensures the data is stored in the correct format
    for the `multipart/form-data` encoding type. Then, the `create` fetch method is
    called to create the new media in the backend with this form data. On successful
    media creation, the user may be redirected to a different view as desired, for
    example, to a Media view with the new media details, as shown in the following
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/NewMedia.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `NewMedia` component can only be viewed by a signed-in user. Therefore,
    we will add a `PrivateRoute` in the `MainRouter` component, which will render
    this form only for authenticated users at `/media/new`.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/MainRouter.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This link can be added to any view, such as in the Menu component, so that it's
    rendered conditionally when users are signed in. Now that it is possible to add
    new media posts in this media streaming application, in the next section we will
    discuss the implementation of retrieving and rendering the video content associated
    with each media post. This will allow users to stream and view video files stored
    in MongoDB GridFS from the frontend of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving and streaming media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any visitor browsing through the MERN Mediastream application will be able to
    view the media posted on the application by its users. Implementing this feature
    will require streaming the video files stored in MongoDB GridFS to the requesting
    client and rendering the stream in a media player. In the following sections,
    we will set up a backend API to retrieve a single video file, which we will then
    use as a source in a React-based media player to render the streaming video.
  prefs: []
  type: TYPE_NORMAL
- en: The video API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To retrieve the video file associated with a single media post, we will implement
    a get video API that will accept a GET request at `'/api/medias/video/:mediaId'` and
    query both the Media collection and GridFS files. We will start implementing this
    video API by declaring the route shown in the following code, along with a way
    to handle the `:mediaId` parameter in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `:mediaId` parameter in the route URL will be processed in the `mediaByID`
    controller to fetch the associated document from the Media collection and file
    details from GridFS. These retrieved results are then attached to the request
    object so that it can be used in the `video` controller method as required. This `mediaByID` controller
    method is defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To retrieve the relevant file details from GridFS, we use `find` from the MongoDB
    streaming API. We query the files stored in GridFS by the filename value, which
    should match the corresponding media ID in the Media collection. Then, we receive
    the resulting matching file records in an array and attach the first result to
    the request object so that it can be used in the next method.
  prefs: []
  type: TYPE_NORMAL
- en: The next method that's invoked when this API receives a request is the `video`
    controller method. In this method, depending on whether the request contains range
    headers, we send back the correct chunks of video with the related content information
    set as response headers. The `video` controller method is defined with the following
    structure, with the response composed depending on the existence of range headers
    in the request.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, if the request does not contain range headers, we stream
    back the whole video file using `gridfs.openDownloadStream`, which gives us a
    readable stream of the corresponding file stored in GridFS. This is piped with
    the response sent back to the client. In the response header, we set the content
    type and total length of the file.
  prefs: []
  type: TYPE_NORMAL
- en: If the request contains range headers – for example, when the user drags to
    the middle of the video and starts playing from that point – we need to convert
    the received range headers to the start and end positions, which will correspond
    with the correct chunks stored in GridFS, as shown in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We pass the start and end values that have been extracted from the header as
    a range to `gridfs.openDownloadStream`. These start and end values specify the
    0-based offset in bytes to start streaming from and stop streaming before. We
    also set the response headers with additional file details, including content
    length, range, and type. The content length will now be the total size of the
    content within the defined range. Therefore, the readable stream that's piped
    back to the response, in this case, will only contain the chunks of file data
    that fall within the start and end ranges.
  prefs: []
  type: TYPE_NORMAL
- en: The final readable stream that's piped to the response after a request is received at
    this get video API can be rendered directly in a basic HTML5 media player or a
    React-flavored media player in the frontend view. In the next section, we will
    look at how to render this video stream in a simple React media player.
  prefs: []
  type: TYPE_NORMAL
- en: Using a React media player to render the video
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the frontend of the application, we can render the video file being streamed
    from MongoDB GridFS in a media player. A good option for a React-flavored media
    player is the `ReactPlayer` component, available as a node module, which can be
    customized as required. Providing the video stream as a source to a default `ReactPlayer`
    component will render with basic player controls, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5426cde7-a7af-44d8-922e-a1b36c11aed7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To start using `ReactPlayer` in our frontend code, we need to install the corresponding
    node module by running the following Yarn command from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, we can import it into any React component and add it to the
    view. For basic usage with the default controls provided by the browser, we can
    add it to any React view in any application that has access to the ID of the media
    to be rendered, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This will load the player with the video stream that was received from the get
    video API and provide the user with basic control options to interact with the
    stream being played. `ReactPlayer` can be customized so that more options are
    available. We will explore some of these advanced options for customizing this `ReactPlayer` with
    our own controls in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about what is possible with `ReactPlayer`, visit [cookpete.com/react-player](https://cookpete.com/react-player).
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's possible to retrieve a single video file stored in MongoDB GridFS
    and stream it to a media player in the frontend for the user to view and play
    the video as desired. In the next section, we will discuss how to fetch and display
    lists of multiple videos from the backend to the frontend of the streaming application.
  prefs: []
  type: TYPE_NORMAL
- en: Listing media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In MERN Mediastream, we will add list views of relevant media with a snapshot
    of each video to give visitors easier access and an overview of the videos on
    the application. For example, in the following screenshot, the `Profile` component
    displays a list of media posted by the corresponding user, showing the video preview
    and other details of each media:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d39a7f3f-6078-41a7-8bd5-442e6404057e.png)'
  prefs: []
  type: TYPE_IMG
- en: We will set up list APIs in the backend to retrieve different lists, such as
    videos uploaded by a single user and the most popular videos with the highest
    views in the application. Then, these retrieved lists can be rendered in a reusable `MediaList` component,
    which will receive a list of media objects as a prop from a parent component that
    fetches the specific API. In the following sections, we will implement the `MediaList`
    component and the backend APIs to retrieve the two different lists of media from
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: The MediaList component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `MediaList` component is a reusable component that will take a list of media
    and iterate through it to render each media item in the view. In MERN Mediastream,
    we use it to render a list of the most popular media in the home view and a list
    of media uploaded by a specific user in their profile.
  prefs: []
  type: TYPE_NORMAL
- en: In the view part of the `MediaList` component, we will iterate through the `media`
    array that's received in `props` using `map`, as shown in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaList.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This `MediaList` component uses the Material-UI `GridList` components as it
    iterates through the array of objects sent in the props and renders media details
    for each item in the list. It also includes a `ReactPlayer` component, which renders
    the video URL without showing any controls. In the view, this gives the visitor
    a brief overview of each piece of media, as well as a glimpse of the video content.
  prefs: []
  type: TYPE_NORMAL
- en: 'This component can be added to any view that can provide an array of media
    objects. In the MERN Mediastream application, we use it to render two different
    lists of media: a list of popular media and a list of media posted by a specific
    user. In the next section, we will look at how to retrieve a list of popular media
    from the database to render it in the frontend.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing popular media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To retrieve specific lists of media from the database, we need to set up the
    relevant APIs on the server. For popular media, we will set up a route that receives
    a GET request at `/api/media/popular`. The route will be declared as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A GET request to this URL will invoke the `listPopular` method. The `listPopular`
    controller method will query the Media collection and retrieve nine media documents
    that have the highest `views` in the whole collection. The `listPopular` method
    is defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The result that's returned by the query to the Media collection is sorted by
    the number of views in descending order and limited to nine. Each media document
    in this list will also contain the name and ID of the user who posted it since
    we are calling `populate` to add these user attributes.
  prefs: []
  type: TYPE_NORMAL
- en: This API can be used in the frontend with a fetch request. You can define a
    corresponding fetch method in `api-media.js` to make the request, similarly to
    other API implementations. Then, the fetch method can be called in a React component,
    such as in the `Home` component for this application. In the `Home` component,
    we will fetch a list of popular videos in a `useEffect` hook, as shown in the
    following code.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/core/Home.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The list that's fetched from the API in this hook is set in the state so that
    it can be passed to a `MediaList` component in the view. In the Home view, we
    can add the `MediaList` as follows, with the list provided as a prop.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/core/Home.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will render a list of up to nine of the most popular videos from the database
    on the home page of the MERN Mediastream application. In the next section, we
    will discuss a similar implementation to retrieve and render a list of media that's
    been posted by a specific user.
  prefs: []
  type: TYPE_NORMAL
- en: Listing media by users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to retrieve a list of media that's been uploaded by a specific user
    from the database, we will set up an API with a route that accepts a `GET` request
    at `'/api/media/by/:userId'`. The route will be declared as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: A GET request to this route will invoke the `listByUser` method. The `listByUser`
    controller method will query the Media collection to find media documents that
    have `postedBy` values matching with the `userId` attached as a parameter in the
    URL. The `listByUser` controller method is defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The result that's returned from the query to the Media collection is sorted
    by the date it was created on, with the latest post showing up first. Each media
    document in this list will also contain the name and ID of the user who posted
    it since we are calling `populate` to add these user attributes.
  prefs: []
  type: TYPE_NORMAL
- en: This API can be used in the frontend with a fetch request. You can define a
    corresponding `fetch` method in `api-media.js` to make the request, similar to
    other API implementations. Then, the fetch method can be called in a React component.
    In our application, we use the `fetch` method in the `Profile` component, similar
    to the `listPopular` fetch method we used in the home view, to retrieve the list
    data, set it to the state, and then pass it to a `MediaList` component. This will
    render a profile page with a list of media that was posted by the corresponding
    user.
  prefs: []
  type: TYPE_NORMAL
- en: We are able to retrieve and display multiple videos on the application by utilizing
    APIs that have been implemented in the backend to fetch the list data. We can
    also utilize a ReactPlayer component without controls to give the user a glimpse
    of each video when we render the list in the frontend views. In the next section,
    we will discuss the full-stack slices that will display media posts and allow
    authorized users to update and delete individual media posts in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying, updating, and deleting media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any visitor to MERN Mediastream will be able to view media details and stream
    videos, while only registered users will be able to edit the media's details and
    delete it any time after they post it on the application. In the following sections,
    we will implement full-stack slices, including backend APIs and frontend views,
    to display a single media post, update details of a media post, and delete a media
    post from the application.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any visitor to MERN Mediastream will be able to browse to a single media view
    to play a video and read the details associated with it. Every time a specific
    video is loaded on the application, we will also increment the number of views
    associated with the media. In the following sections, we will implement the individual
    media view by adding a read media API to the backend, a way to call this API from
    the frontend, and the React component that will display the media details in the
    view.
  prefs: []
  type: TYPE_NORMAL
- en: The read media API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To implement the read media API in the backend, we will start by adding a `GET` route
    that queries the `Media` collection with an ID and returns the media document
    in the response. The route is declared as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `mediaId` in the request URL will cause the `mediaByID` controller method
    to execute and attach the retrieved media document to the request object so that
    it can be accessed in the next method.
  prefs: []
  type: TYPE_NORMAL
- en: A `GET` request to this API will execute the `incrementViews` controller method
    next, which will find the matching media record and increment the `views` value
    by `1`, before saving the updated record to the database. The `incrementViews`
    method is defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This method will increment the number of views for a given media by 1 every
    time this read media API is called. After the media is updated from this `incrementViews`
    method, the `read` controller method is invoked. The `read` controller method
    will simply return the retrieved media document in response to the requesting
    client, as shown in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: To retrieve the media document that was sent in the response, we need to call
    this read media API in the frontend using a fetch method. We will set up a corresponding
    fetch method in `api-media.js`, as shown in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/api-media.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This method takes the ID of the media to be retrieved and makes a `GET` request
    to the read API route using a `fetch`.
  prefs: []
  type: TYPE_NORMAL
- en: The read media API can be used to render individual media details in a view
    or to pre-populate a media edit form. In the next section, we will use this fetch
    method to call the read media API in the React component to render the media details,
    as well as a `ReactPlayer` that will play the associated video.
  prefs: []
  type: TYPE_NORMAL
- en: The Media component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Media` component will render details of an individual media record and
    stream the video in a basic `ReactPlayer` with default browser controls. The completed
    single Media view will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c171333d-9949-44de-8e54-08edce73050f.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Media` component can call the read API to fetch the media data itself or
    receive the data as props from a parent component that makes the call to the read
    API. In the latter case, the parent component will fetch the media from the server
    in a `useEffect` hook, set it to state, and add it to the `Media` component, as
    follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/PlayMedia.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In MERN Mediastream, we will add the `Media` component in a `PlayMedia` component
    that fetches the media content from the server in a `useEffect` hook using the
    read API and passes it to `Media` as a prop. The composition of the `PlayMedia`
    component will be discussed in more detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `Media` component will take this data in the props and render it in the
    view to display the details and load the video in a `ReactPlayer` component. The
    title, genre, and view count details of the media can be rendered in a Material-UI
    `CardHeader` component in the `Media` component, as shown in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/Media.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Besides rendering these media details, we will also load the video in the `Media`
    component. The video URL, which is basically the get video API route we set up
    in the backend, is loaded in a `ReactPlayer` with default browser controls, as
    shown in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/Media.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This will render a simple player that allows the user to play the video stream.
  prefs: []
  type: TYPE_NORMAL
- en: The `Media` component also renders additional details about the user who posted
    the video, a description of the video, and the date it was created, as shown in
    the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/Media.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the details being displayed in the Material-UI `ListItem` component, we will also
    conditionally show edit and delete options if the currently signed-in user is
    the one who posted the media being displayed. To render these elements conditionally
    in the view, we will add the following code after the `ListItemText` displaying
    the date.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/Media.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that the edit and delete options only render when the current
    user is signed in and is the uploader of the media being displayed. The edit option
    links to the media edit form, while the delete option opens a dialog box that
    can initiate the deletion of this particular media document from the database.
    In the next section, we will implement the functionality of this option to edit
    details of the uploaded media post.
  prefs: []
  type: TYPE_NORMAL
- en: Updating media details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Registered users will have access to an edit form for each of their media uploads.
    Updating and submitting this form will save the changes to the given document
    in the Media collection. To implement this capability, we will have to create
    a backend API that allows the update operation on a given media after ensuring
    that the requesting user is authenticated and authorized. Then, this updated API
    needs to be called from the frontend with the changed details of the media. In
    the following sections, we will build this backend API and the React component
    to allow users to make changes to the media they already posted on the application.
  prefs: []
  type: TYPE_NORMAL
- en: The media update API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the backend, we will need an API that allows us to update existing media
    in the database if the user making the request is the authorized creator of the
    given media post. First, we will declare the PUT route, which accepts the update
    request from the client.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: When a PUT request is received at `'api/media/:mediaId'`, the server will ensure
    the signed-in user is the original poster of the media content by calling the
    `isPoster` controller method. The `isPoster` controller method is defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This method ensures the ID of the authenticated user is the same as the user
    ID referenced in the `postedBy` field of the given media document. If the user
    is authorized, the `update` controller method will be called `next` in order to
    update the existing media document with the changes. The `update` controller method
    is defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This method extends the existing media document with the changed details that
    were received in the request body and saves the updated media to the database.
  prefs: []
  type: TYPE_NORMAL
- en: To access the update API in the frontend, we will add a corresponding fetch
    method in `api-media.js` that takes the necessary user auth credentials and media
    details as parameters before making the fetch call to this update media API, as
    shown in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/user/api-media.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This fetch method will be used in the media edit form when the user makes updates
    and submits the form. In the next section, we will discuss the implementation
    of this media edit form.
  prefs: []
  type: TYPE_NORMAL
- en: The media edit form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The media edit form, which will allow an authorized user to make changes to
    the details of a media post, will be similar to the new media form. However, it
    will not have an upload option, and the fields will be pre-populated with the
    existing values, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/180e69b1-8f55-46f0-b290-6304b551a616.png)'
  prefs: []
  type: TYPE_IMG
- en: The `EditMedia` component containing this form will fetch the existing values
    of the media by calling the read media API in a `useEffect` hook, as shown in
    the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/EditMedia.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The retrieved media details are set to state so that the values can be rendered
    in the text fields. The form field elements will be the same as in the `NewMedia`
    component. When a user updates any of the values in the form, the changes will
    be registered in the `media` object in state with a call to the `handleChange`
    method. The `handleChange` method is defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`mediastream/client/media/EditMedia.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In this method, the specific field that's being updated in the form is reflected
    in the corresponding attribute in the media object in state. When the user is
    done editing and clicks submit, a call will be made to the update API with the
    required credentials and the changed media values. This is done by invoking the
    `clickSubmit` method, which is defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`mediastream/client/media/EditMedia.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The call to the update media API will update the media details in the corresponding
    media document in the Media collection, while the video file associated with the
    media remains as it is in the database.
  prefs: []
  type: TYPE_NORMAL
- en: This `EditMedia` component can only be accessed by signed-in users and will
    be rendered at `'/media/edit/:mediaId'`. Due to this, we will add a `PrivateRoute` in
    the `MainRouter` component, like so.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/MainRouter.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This link is added with an edit icon in the `Media` component, allowing the
    user who posted the media to access the edit page. In the `Media` view, the user
    can also choose to delete their media post. We will implement this in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An authorized user can completely delete the media they uploaded to the application,
    including the media document in the Media collection and the file chunks stored
    in MongoDB using GridFS. To allow a user to remove the media from the application,
    in the following sections, we will define a backend API for media deletion from
    the database and implement a React component that makes use of this API when the
    user interacts with the frontend to perform this deletion.
  prefs: []
  type: TYPE_NORMAL
- en: The delete media API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To delete media from the database, we will implement a delete media API in the
    backend, which will accept a DELETE request from a client at `/api/media/:mediaId`. We
    will add the `DELETE` route for this API as follows, which will allow an authorized
    user to delete their uploaded media records.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: When the server receives a DELETE request at `'/api/media/:mediaId'`, it will
    make sure the signed-in user is the original poster of the media by invoking the
    `isPoster` controller method. Then, the `remove` controller method will completely delete
    the specified media from the database. The `remove` method is defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Besides deleting the media record from the Media collection, we are also using `gridfs`
    to remove the associated file details and chunks stored in the database.
  prefs: []
  type: TYPE_NORMAL
- en: To access this backend API in the frontend, you will also need a fetch method
    with this route, similar to other API implementations. The fetch method will need
    to take the media ID and the current user's auth credentials in order to call
    the delete media API with these values.
  prefs: []
  type: TYPE_NORMAL
- en: The fetch method will be used when the user performs the delete operation by
    clicking a button in the frontend interface. In the next section, we will discuss
    a React component called `DeleteMedia`, where by this delete media action will
    be performed by the user.
  prefs: []
  type: TYPE_NORMAL
- en: The DeleteMedia component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `DeleteMedia` component is added to the `Media` component and is only visible
    to the signed-in user who added this specific media. This component is basically
    a button that, when clicked, opens a `Dialog` component asking the user to confirm
    the delete action, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71d31ba9-fc95-4b16-a1aa-116fdc04ac03.png)'
  prefs: []
  type: TYPE_IMG
- en: This `DeleteMedia` component takes the media ID and title as props when it is
    added in the `Media` component. Its implementation will be similar to the `DeleteUser` component
    we discussed in [Chapter 4](6f2ca10a-8079-4e3a-9d42-a3db8e85b9d9.xhtml), *Adding
    a React Frontend to Complete MERN*. Once the `DeleteMedia` component has been
    added, the user will be able to remove the posted media completely from the application
    by confirming their action.
  prefs: []
  type: TYPE_NORMAL
- en: The MERN Mediastream application that we've developed in this chapter is a complete
    media streaming application with the capability to upload video files to the database,
    stream stored videos back to the viewers, support CRUD operations such as media
    create, update, read, and delete, and support options for listing media by uploader
    or popularity.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we developed a media streaming application by extending the
    MERN skeleton application and leveraging MongoDB GridFS.
  prefs: []
  type: TYPE_NORMAL
- en: Besides adding basic add, update, delete, and listing features for media uploads,
    we looked into how MERN-based applications can allow users to upload video files,
    store these files into MongoDB GridFS as chunks, and stream the video back to
    the viewer partially or fully as required. We also covered using `ReactPlayer`
    with default browser controls to stream the video file. You can apply these streaming
    capabilities to any full-stack application that may require storing and retrieving
    large files from the database.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to customize `ReactPlayer` with our own
    controls and functionality so that users have more options, such as playing the
    next video in a list. In addition, we will discuss how to improve the SEO of the
    media details by implementing server-side rendering with data for the media view.
  prefs: []
  type: TYPE_NORMAL
