- en: '*Chapter 5*: Managing Local and Global States in Next.js'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：在Next.js中管理本地和全局状态'
- en: State management is one of the central parts of any React application, Next.js
    apps included. When talking about state, we refer to those dynamic pieces of information
    that allow us to create highly interactive **user interfaces** (**UIs**), making
    our customers' experience as beautiful and enjoyable as possible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 状态管理是任何React应用程序（包括Next.js应用程序）的核心部分之一。当谈到状态时，我们指的是那些动态信息片段，使我们能够创建高度交互的**用户界面**（**UIs**），使客户的体验尽可能美丽和愉悦。
- en: 'Thinking about modern websites, we can spot state changes in many parts of
    the UI: switching from light to dark theme means that we''re changing the UI theme
    state, filling an e-commerce form with our shipping information means that we''re
    changing that form state, even clicking on a simple button can potentially change
    a local state, as it can lead our UI to react in many different ways, depending
    on how the developers decided to manage that state update.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到现代网站，我们可以在UI的许多部分中发现状态变化：从浅色主题切换到深色主题意味着我们在改变UI主题状态，用我们的运输信息填写电子商务表单意味着我们在改变该表单状态，甚至点击一个简单的按钮也可能潜在地改变本地状态，因为它可以使我们的UI以许多不同的方式反应，这取决于开发者如何决定管理那个状态更新。
- en: Even though state management allows us to create beautiful interactions inside
    our applications, it comes with some extra complexities. Many developers have
    come up with very different solutions to manage them, allowing us to manage the
    application state in more straightforward and organized ways.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管状态管理使我们能够在应用程序内部创建美丽的交互，但它也带来了一些额外的复杂性。许多开发者提出了非常不同的解决方案来管理它们，使我们能够以更直接和更有组织的方式管理应用程序状态。
- en: Talking about React specifically, since the first versions of the library, we
    had access to the class components, where the class kept a local state, allowing
    us to interact with it via the `setState` method. With more modern React versions
    (>16.8.0), that process has been simplified with the introduction of React Hooks,
    including the `useState` Hook.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到React，特别是从库的第一个版本开始，我们就有了访问类组件的权限，其中类保持本地状态，使我们能够通过`setState`方法与之交互。随着更现代的React版本（>16.8.0）的引入，这个过程通过引入React
    Hooks（包括`useState`钩子）得到了简化。
- en: The most significant difficulty in managing state in a React application is
    that the data flow should be unidirectional, meaning that we can pass a given
    state as a prop to a child component, but we cannot do the same with a parent
    element. That means that local state management can be effortless thanks to class
    components and Hooks, but global state management can become really convoluted.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在React应用程序中管理状态的最大困难是数据流应该是单向的，这意味着我们可以将给定状态作为prop传递给子组件，但不能对父元素做同样的事情。这意味着本地状态管理可以因为类组件和Hooks而变得轻松，但全局状态管理可能会变得非常复杂。
- en: In this chapter, we will take a look at two different approaches for managing
    the global application state. First, we will see how to use React Context APIs;
    then, we will rewrite the application using **Redux**, which will let us understand
    how to initialize an external library for state management both on the client
    and server side.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨两种不同的管理全局应用程序状态的方法。首先，我们将了解如何使用React Context API；然后，我们将使用**Redux**重写应用程序，这将让我们了解如何在客户端和服务器端初始化外部状态管理库。
- en: 'We will look in detail at the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细探讨以下主题：
- en: Local state management
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地状态管理
- en: Managing the application state via the Context APIs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Context API管理应用程序状态
- en: Managing the application state via Redux
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Redux管理应用程序状态
- en: By the end of this chapter, you will learn the differences between local and
    global state management. You will also learn how to manage the global application
    state using the React built-in Context APIs or an external library such as Redux.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解本地状态管理和全局状态管理之间的区别。您还将学习如何使用React内置的Context API或外部库（如Redux）来管理全局应用程序状态。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run the code examples in this chapter, you need to have both Node.js and
    npm installed on your local machine. If you prefer, you can use an online IDE
    such as [https://repl.it](https://repl.it) or https://codesandbox.io, as they
    both support Next.js, and you don't need to install any dependency on your computer.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码示例，您需要在您的本地计算机上安装Node.js和npm。如果您愿意，可以使用在线IDE，例如[https://repl.it](https://repl.it)或https://codesandbox.io，因为它们都支持Next.js，您不需要在您的计算机上安装任何依赖项。
- en: 'As with the other chapters, you can find the code base for this chapter on
    GitHub: [https://github.com/PacktPublishing/Real-World-Next.js](https://github.com/PacktPublishing/Real-World-Next.js).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他章节一样，您可以在GitHub上找到本章的代码库：[https://github.com/PacktPublishing/Real-World-Next.js](https://github.com/PacktPublishing/Real-World-Next.js)。
- en: Local state management
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地状态管理
- en: 'When talking about local state management, we''re referring to application
    state that is *component-scoped*. We can summarize that concept with an elementary
    `Counter` component:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论本地状态管理时，我们指的是*组件作用域*的应用状态。我们可以用一个基本的`Counter`组件来概括这个概念：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When we click on the `Increment` button, we will add `1` to the current `count`
    value. Vice-versa, we will subtract `1` to that value when we click on the `Decrement`
    button; nothing special!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击`Increment`按钮时，我们将`1`添加到当前的`count`值。反之，当我们点击`Decrement`按钮时，我们将从该值中减去`1`；没什么特别的！
- en: 'But while it''s easy for a parent component to pass an `initialCount` value
    as a prop for the `Counter` element, it can be way more challenging to do the
    opposite: passing the current `count` value to the parent component. There are
    many cases where we need to manage just the local state, and the React `useState`
    Hook can be an excellent way to do so. Those cases can include (but are not limited
    to) the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于父组件来说，将`initialCount`值作为`Counter`元素的prop传递很容易，但将当前的`count`值传递给父组件可能要复杂得多。在许多情况下，我们只需要管理本地状态，React的`useState`钩子可以是一个做这件事的绝佳方式。这些情况可能包括（但不限于）以下内容：
- en: '**Atom components**: As seen in [*Chapter 4*](B16985_04_Final_SB_epub.xhtml#_idTextAnchor053),
    *Organizing the Code Base and Fetching Data in Next.js*, atoms are the most essential
    React components we can encounter, and they''re likely to manage little local
    states only. More complex states can be delegated to **molecules** or **organisms**
    in many cases.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子组件**：如[第4章](B16985_04_Final_SB_epub.xhtml#_idTextAnchor053)中所述，*在Next.js中组织代码库和获取数据*，原子是我们可能遇到的最重要的React组件，它们很可能只管理少量本地状态。在许多情况下，更复杂的状态可以委托给**分子**或**组织体**。'
- en: '`loading` state to `true` until the fetch request is completed to display a
    nice loading spinner on the UI.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在获取请求完成之前将`loading`状态设置为`true`，以便在UI上显示一个漂亮的加载指示器。
- en: React Hooks such as `useState` and `useReducer` make local state management
    effortless, and most of the time, you don't need any external library to handle
    it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: React钩子如`useState`和`useReducer`使本地状态管理变得轻而易举，而且大多数时候，您不需要任何外部库来处理它。
- en: Things can change once you need to maintain a global application state across
    all of your components. A typical example could be an e-commerce website, where
    once you add an item to the shopping cart, you may want to display the number
    of products you're buying with an icon inside your navigation bar.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要维护所有组件的全局应用状态时，情况可能会有所变化。一个典型的例子可能是一个电子商务网站，一旦您将商品添加到购物车，您可能希望在导航栏内显示您购买的产品数量。
- en: We will talk about this specific example right in the next section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中详细讨论这个特定的例子。
- en: Global state management
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局状态管理
- en: When talking about the global application state, we refer to a state shared
    between all the components for a given web application that is, therefore, reachable
    and modifiable by any component.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论全局应用状态时，我们指的是给定Web应用中所有组件之间共享的状态，因此任何组件都可以访问和修改。
- en: 'As seen in the previous section, the React data flow is unidirectional, meaning
    that components can pass data to their children components, but not to their parents
    (unlike Vue or Angular). That makes our components less error prone, easier to
    debug, and more efficient, but adds extra complexity: by default, there cannot
    be a global state.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，React的数据流是单向的，这意味着组件可以向其子组件传递数据，但不能向其父组件传递（与Vue或Angular不同）。这使得我们的组件更不容易出错，更容易调试，更高效，但增加了额外的复杂性：默认情况下，不能有全局状态。
- en: 'Let''s take a look at the following scenario:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下场景：
- en: '![Figure 5.1 – A link between product cards and items in the cart'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – 产品卡片和购物车中项目之间的链接'
- en: '](img/Figure_5.01_B16985.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.01_B16985.jpg)'
- en: Figure 5.1 – A link between product cards and items in the cart
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 产品卡片和购物车中项目之间的链接
- en: In the web application shown in the preceding screenshot, we want to display
    many products and let our users put them in the shopping cart. The biggest problem
    here is that there's no link between the data shown in the navigation bar and
    the product cards, and it can be non-trivial to update the number of products
    in the cart as soon as the user clicks on the "add" button for a given product.
    And what if we want to keep this information on page change? It would be lost
    as soon as the single card components get unmounted with their local state.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个屏幕截图所示的Web应用中，我们希望显示许多产品，并让我们的用户将它们放入购物车。这里最大的问题是导航栏中显示的数据与产品卡片之间没有链接，并且当用户点击某个产品的“添加”按钮时，立即更新购物车中产品数量的操作可能相当复杂。而且如果我们想在页面更改时保持这些信息呢？一旦单个卡片组件及其本地状态卸载，这些信息就会丢失。
- en: 'Today, many libraries make it a bit easier to manage those situations: **Redux**,
    **Recoil**, and **MobX** are just some of the most popular solutions, but there
    are also other approaches. In fact, with React Hooks'' introduction, we can use
    the *Context APIs* for managing the global application state without the need
    for external libraries. There''s also a less popular approach that I''d like to
    take into consideration: using **Apollo Client** (and its **in-memory cache**).
    That would change the way we think of our state and gives us a formal query language
    for interacting with the global application data. If you''re interested in that
    approach, I''d highly recommend reading the official Apollo GraphQL tutorial:
    [https://www.apollographql.com/docs/react/local-state/local-state-management](https://www.apollographql.com/docs/react/local-state/local-state-management).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，许多库使管理这些情况变得容易一些：**Redux**、**Recoil**和**MobX**只是最受欢迎的解决方案之一，但还有其他方法。实际上，随着React
    Hooks的引入，我们可以使用*Context API*来管理全局应用状态，而无需外部库。还有一个不太受欢迎的方法，我想考虑一下：使用**Apollo Client**（及其**内存缓存**）。这将改变我们看待状态的方式，并为我们提供了一个正式的查询语言，用于与全局应用数据交互。如果您对这个方法感兴趣，我强烈建议阅读官方的Apollo
    GraphQL教程：[https://www.apollographql.com/docs/react/local-state/local-state-management](https://www.apollographql.com/docs/react/local-state/local-state-management).
- en: Starting from the next section, we will be building a very minimal storefront,
    just like the one we saw in the previous figure. Once the user adds one or more
    products to the shopping cart, we will update the count inside of the navigation
    bar. Once the user decides to proceed with the checkout, we will need to display
    the selected products on the checkout page.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一节开始，我们将构建一个非常简单的店面，就像我们在上一幅图中看到的那样。一旦用户将一个或多个产品添加到购物车中，我们将在导航栏中更新计数。一旦用户决定进行结账，我们需要在结账页面上显示所选的产品。
- en: Using the Context APIs
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Context API
- en: 'With **React v16.3.0**, released back in 2018, we finally got access to stable
    Context APIs. They give us a straightforward way to share data between all the
    components inside a given context without explicitly having to pass it via props
    from one component to another, even from children to a parent component. If you
    want to learn more about React Context, I highly recommend reading the official
    React documentation: https://reactjs.org/docs/context.html.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 随着**React v16.3.0**的发布，该版本于2018年发布，我们终于可以访问稳定的Context API。它们为我们提供了一个简单的方法，在给定上下文内的所有组件之间共享数据，而无需显式地通过props从一个组件传递到另一个组件，甚至是从子组件传递到父组件。如果您想了解更多关于React
    Context的信息，我强烈建议阅读官方的React文档：https://reactjs.org/docs/context.html.
- en: 'Starting with this section, we will always use the same boilerplate code for
    approaching global state management with different libraries. You can find this
    boilerplate code here: https://github.com/PacktPublishing/Real-World-Next.js/tree/main/05-state-management-made-easy/boilerplate.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从本节开始，我们将始终使用相同的样板代码来使用不同的库处理全局状态管理。您可以在以下位置找到此样板代码：https://github.com/PacktPublishing/Real-World-Next.js/tree/main/05-state-management-made-easy/boilerplate.
- en: 'We will also keep the same approach for storing the selected products in the
    global state for simplicity''s sake; our state will be a JavaScript object. Each
    property is the ID of a product, and its value will represent the number of products
    that the user has selected. If you open the `data/items.js` file, you will find
    an array of objects representing our products. If a user selects four carrots
    and two onions, our state will look like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，我们将采用相同的方法在全局状态中存储所选产品；我们的状态将是一个JavaScript对象。每个属性是产品的ID，其值将表示用户所选产品的数量。如果你打开`data/items.js`文件，你会找到一个表示我们产品的对象数组。如果用户选择了四个胡萝卜和两个洋葱，我们的状态将如下所示：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That being said, let''s start by creating the context for our shopping cart.
    We can do that by creating a new file: `components/context/cartContext.js`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们首先为我们的购物车创建上下文。我们可以通过创建一个新的文件来实现：`components/context/cartContext.js`：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Just like in a typical client-side rendered React app, we now want to wrap all
    the components that need to share the cart data under the same context. For instance,
    the `/components/Navbar.js` component needs to be mounted inside the same context
    as the `/components/ProductCard.js` component.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在典型的客户端渲染的React应用中一样，我们现在希望将所有需要共享购物车数据的组件都包裹在同一个上下文中。例如，`/components/Navbar.js`组件需要被挂载在`/components/ProductCard.js`组件相同的上下文中。
- en: 'We should also consider that we want our global state to be persistent when
    changing the page, as we want to display the number of products selected by the
    user on the checkout page. That said, we can customize the `/pages/_app.js` page,
    as seen in [*Chapter 3*](B16985_03_Final_SB_epub.xhtml#_idTextAnchor038)*, Next.js
    Basics and Built-In Components*, to wrap the entire application under the same
    React context:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该考虑，当页面发生变化时，我们希望我们的全局状态保持持久，因为我们希望在结账页面上显示用户所选产品的数量。因此，我们可以自定义`/pages/_app.js`页面，如[*第3章*](B16985_03_Final_SB_epub.xhtml#_idTextAnchor038)*，Next.js基础和内置组件*所示，将整个应用程序包裹在同一个React上下文中：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, we're wrapping both `<Navbar />` and `<Component {...pageProps
    />` under the same context. That way, they gain access to the same global state,
    creating a link between all the components rendered on every page and the navigation
    bar.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们在同一个上下文中包裹了`<Navbar />`和`<Component {...pageProps />`。这样，它们就能访问相同的全局状态，从而在每一页上渲染的所有组件和导航栏之间建立联系。
- en: 'Now let''s take a quick look at the `/pages/index.js` page:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速看一下`/pages/index.js`页面：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To make it simpler, we're importing all the products from a local JavaScript
    file, but of course, they could also come from a remote API. For each product,
    we render the `ProductCard` component, which will allow the users to add them
    to the shopping cart and then proceed to the checkout.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们正在从本地JavaScript文件中导入所有产品，但当然，它们也可以来自远程API。对于每个产品，我们渲染`ProductCard`组件，这将使用户能够将它们添加到购物车，然后进行结账。
- en: 'Let''s take a look at the `ProductCard` component:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`ProductCard`组件：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, we are already building the UI for that component, but nothing
    happens when clicking on both the `increment` and `decrement` buttons. We now
    need to link that component to the `cartContext` context and then update the context
    state as soon as the user clicks on one of the two buttons:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们已经在构建该组件的UI，但在点击`increment`和`decrement`按钮时没有任何反应。现在，我们需要将该组件链接到`cartContext`上下文，并在用户点击这两个按钮之一时立即更新上下文状态：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using the `useContext` Hook, we''re linking both `setItems` and `items` from
    the `_app.js` page to our `ProductCard` component. Every time we call `setItems`
    on that component, we will be updating the global `items` object, and that change
    will be propagated to all the components living under the same context and linked
    to the same global state. That also means that we don''t need to keep a local
    state for each `ProductCard` component, as the information about the number of
    single products added to the shopping cart already exists in our context state.
    Therefore, if we want to know the number of products added to the shopping cart,
    we can proceed as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`useContext`钩子，我们将`_app.js`页面中的`setItems`和`items`链接到我们的`ProductCard`组件。每次我们在该组件上调用`setItems`时，我们都会更新全局的`items`对象，并且这个变化将传播到所有位于相同上下文并链接到相同全局状态的组件。这也意味着我们不需要为每个`ProductCard`组件保留本地状态，因为关于单个产品添加到购物车中的数量信息已经存在于我们的上下文状态中。因此，如果我们想知道添加到购物车中的产品数量，我们可以按以下步骤进行：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That way, every time the user clicks on the `increment` button for a given product,
    the global `items` state will change, the `ProductCard` component will be re-rendered,
    and the `productAmount` constant will end up having a new value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每次用户点击特定产品的`增加`按钮时，全局`items`状态将改变，`ProductCard`组件将被重新渲染，`productAmount`常量将最终具有新的值。
- en: Talking again about handling both `increment` and `decrement` actions, we need
    to control the user clicks on those buttons. We can write a generic `handleAmount`
    function taking a single argument that can be either `"increment"` or `"decrement"`.
    If the passed parameter is `"increment"`, we need to check if the current product
    already exists inside the global state (remember, an initial global state is an
    empty object). If it exists, we only need to increment its value by one; otherwise,
    we need to create a new property inside the `items` object where the key will
    be our product ID, and its value will be set to `1`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 再次谈到处理`增加`和`减少`操作，我们需要控制用户对那些按钮的点击。我们可以编写一个通用的`handleAmount`函数，它接受一个参数，可以是`"increment"`或`"decrement"`。如果传递的参数是`"increment"`，我们需要检查当前产品是否已经存在于全局状态中（记住，初始的全局状态是一个空对象）。如果存在，我们只需要将其值增加一；否则，我们需要在`items`对象中创建一个新的属性，其键将是我们的产品ID，其值将被设置为`1`。
- en: 'If the parameter is `"decrement"`, we should check whether the current product
    already exists inside of the global `items` object. If that''s the case, and the
    value is greater than `0`, we can just decrement it. In all other cases, we can
    just exit the function, as we cannot have a negative number as a value for an
    amount of our products:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数是`"decrement"`，我们应该检查当前产品是否已经存在于全局`items`对象中。如果是这种情况，并且值大于`0`，我们只需减少它。在所有其他情况下，我们只需退出函数，因为我们不能将负数作为产品数量的值：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We now just need to update the `increment` and `decrement` buttons to trigger
    the `handleAmount` function on click:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在只需要更新`增加`和`减少`按钮，以便在点击时触发`handleAmount`函数：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we now try to increment and decrement our products'' amount, we will see
    the number inside of the `ProductCard` component changing after each button click!
    But looking at the navigation bar, the value will remain set to `0`, as we haven''t
    linked the global items state to the `Navbar` component. Let''s open the `/components/Navbar.js`
    file and type the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试增加和减少产品的数量，我们将在每次按钮点击后看到`ProductCard`组件中的数字变化！但是，当我们查看导航栏时，值将保持为`0`，因为我们还没有将全局项目状态链接到`Navbar`组件。让我们打开`/components/Navbar.js`文件并输入以下内容：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We don''t need to update the global `items` state from our navigation bar,
    so, in that case, we don''t need to declare the `setItems` function. In that component,
    we only want to display the total amount of products added to the shopping cart
    (for instance, if we add two carrots and one onion, we should see `3` as the total
    in our `Navbar`). We can do that quite easily:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要从我们的导航栏更新全局`items`状态，所以在这种情况下，我们不需要声明`setItems`函数。在这个组件中，我们只想显示添加到购物车中的产品总数（例如，如果我们添加了两根胡萝卜和一颗洋葱，我们应该在“导航栏”中看到总数为`3`）。我们可以很容易地做到这一点：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now let''s just display the `totalItemsAmount` variable inside of the resulting
    HTML:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们只显示`totalItemsAmount`变量在生成的HTML中：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Great! We just missed one last thing: clicking on the `Navbar` link to the
    checkout page, we can''t see any products displayed on the page. We can fix that
    by fixing the `/pages/cart.js` page:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们只错过了一件事：点击“导航栏”链接到结算页面，我们看不到页面上的任何产品显示。我们可以通过修复`/pages/cart.js`页面来解决这个问题：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see, we''re importing the context objects as usual and the complete
    product list. That''s because we need to get the complete product info (inside
    the state, we only have the relationship between a product ID and product amount)
    for displaying the name of the product, the amount, and the total price for that
    product. We then need a way to get the whole product object given a product ID.
    We can write a `getFullItem` function (outside of our component) that only takes
    an ID and returns the entire product object:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们像往常一样导入上下文对象和完整的商品列表。这是因为我们需要获取完整的商品信息（在状态中，我们只有产品ID和产品数量的关系）以显示产品的名称、数量和该产品的总价。然后我们需要一种方法来获取给定产品ID的整个商品对象。我们可以在组件外部编写一个`getFullItem`函数，它只接受一个ID并返回整个商品对象：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we have access to the complete product object, we can get the total
    price for all of our products inside of the shopping cart:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以访问完整的商品对象，我们可以在购物车中的所有产品内获取总价：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We also want to display a list of products inside of the shopping cart in the
    format of *x2 Carrots ($7)*. We can easily create a new array called `amounts`
    and fill it with all the products we''ve added to the cart, plus the amount for
    every single product:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望在购物车中显示产品列表，格式为*x2 Carrots ($7)*。我们可以轻松创建一个新的数组`amounts`，并填充我们添加到购物车中的所有产品以及每个产品的数量：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we only need to update the returning template for that component:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要更新该组件的返回模板：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: And we're done! After booting the server, we can add as many products as we
    want to the shopping cart and see the total price going to the `/cart` page.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！在启动服务器后，我们可以将尽可能多的产品添加到购物车中，并看到总价会显示在`/cart`页面上。
- en: Using the context APIs in Next.js is not that difficult, as the concepts are
    the same for the vanilla React applications. In the next section, we will see
    how to achieve the same results using Redux as a global state manager.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Next.js中使用上下文API并不困难，因为对于纯React应用，这些概念是相同的。在下一节中，我们将看到如何使用Redux作为全局状态管理器来实现相同的结果。
- en: Using Redux
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Redux
- en: In 2015, two years after the initial React public release, there weren't asmany
    frameworks and libraries as today for handling large-scale application states.
    The most advanced way for handling unidirectional data flow was Flux, which, as
    time has passed, has been superseded by more straightforward and modern libraries
    such as **Redux** and **MobX**.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在2015年，React首次公开发布后的两年，用于处理大规模应用程序状态的框架和库并没有像今天这样多。处理单向数据流最先进的方式是Flux，但随着时间的推移，它已经被更直接、更现代的库如**Redux**和**MobX**所取代。
- en: Redux, in particular, had a significant impact on the React community and quickly
    became a de facto state manager for building large-scale applications in React.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是Redux对React社区产生了重大影响，并迅速成为构建React大规模应用程序的事实上的状态管理器。
- en: In this section, we will be using plain Redux (without middlewares such as **redux-thunk**
    or **redux-saga**) for managing the storefront state instead of using the React
    Context APIs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用纯Redux（不使用如**redux-thunk**或**redux-saga**等中间件）来管理店面状态，而不是使用React Context
    API。
- en: Let's start by cloning the boilerplate code from [https://github.com/PacktPublishing/Real-World-Next.js/tree/main/05-managing-local-and-global-states-in-nextjs/boilerplate](https://github.com/PacktPublishing/Real-World-Next.js/tree/main/05-managing-local-and-global-states-in-nextjs/boilerplate)(just
    like we did in the previous section).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从克隆[https://github.com/PacktPublishing/Real-World-Next.js/tree/main/05-managing-local-and-global-states-in-nextjs/boilerplate](https://github.com/PacktPublishing/Real-World-Next.js/tree/main/05-managing-local-and-global-states-in-nextjs/boilerplate)的样板代码开始（就像我们在上一节中所做的那样）。
- en: 'At this point, we will need to install two new dependencies:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们需要安装两个新的依赖项：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can also install the **Redux DevTools extension**, which allows us to inspect
    and debug the application state from our browser:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以安装**Redux DevTools扩展程序**，它允许我们从浏览器中检查和调试应用程序状态：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now we can start coding our Next.js + Redux application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始编写我们的Next.js + Redux应用程序了。
- en: 'First of all, we will need to initialize the global store, which is the part
    of our application containing the application state. We can do that by creating
    a new folder inside of the root of our project, calling it `redux/`. Here we can
    write a new `store.js` file containing the logic for initializing our store on
    both the client side and server side:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要初始化全局存储，这是我们应用程序包含应用程序状态的部分。我们可以通过在项目根目录下创建一个新文件夹，命名为`redux/`来实现。在这里，我们可以编写一个新的`store.js`文件，包含初始化我们存储的客户端和服务器端逻辑：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, we start by instantiating a new variable, `store`, which (as
    you may have guessed) will be used later on for keeping the Redux store.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们首先实例化一个新的变量`store`，它（正如您可能已经猜到的）将用于稍后保持Redux存储。
- en: Then, we initialize the `initialState` for our Redux store. In that case, it
    will be an empty object, as we will add more properties depending on which product
    our users select on the storefront.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们初始化Redux存储的`initialState`。在这种情况下，它将是一个空对象，因为我们将在用户在店面选择哪个产品的基础上添加更多属性。
- en: 'We now need to create our first and only reducer. In a real-world application,
    we would write many different reducers in many different files, making things
    more manageable in terms of maintainability for our project. In that case, we
    will write just one reducer (as it is the only one we need), and we will include
    that in the `store.js` file for simplicity''s sake:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要创建我们的第一个也是唯一的一个reducer。在现实世界的应用中，我们会在许多不同的文件中编写许多不同的reducer，这使得我们的项目在可维护性方面更加易于管理。在这种情况下，我们将只编写一个reducer（因为我们只需要一个），并且为了简便起见，我们将将其包含在`store.js`文件中：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The reducer's logic is not that different from the one we wrote in the previous
    section inside the `handleAmount` function for our `ProductCard` component.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Reducer的逻辑与我们之前在`ProductCard`组件的`handleAmount`函数中编写的逻辑并没有太大的不同。
- en: 'Now we need to initialize our store, and we can do that by creating two different
    functions. The first one will be a simple helper function called `initStore`,
    and it will make things easier later on:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要初始化我们的存储，我们可以通过创建两个不同的函数来实现这一点。第一个将是一个简单的辅助函数，称为`initStore`，它将使后续操作更加简便：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The second function we need to create is the one we will use for properly initializing
    the store, and we''re going to call it `initializeStore`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的第二个函数是我们将用于正确初始化存储的函数，我们将称之为`initializeStore`：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now that we have our store set up, we can create one last function, a Hook
    we''ll be using in our components. We''ll wrap it inside a `useMemo` function
    to take advantage of the React built-in memoization system, which will cache complex
    initial states, avoiding the system re-parsing it on every `useStore` function
    call:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了存储，我们可以创建最后一个函数，一个我们将要在我们的组件中使用的钩子。我们将它包裹在一个`useMemo`函数中，以利用React内置的memoization系统，这将缓存复杂的初始状态，避免在每次`useStore`函数调用时重新解析系统：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Great! We're now ready to move on and attach Redux to our Next.js application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在可以继续前进，将Redux附加到我们的Next.js应用上了。
- en: 'Just as we did with the Context APIs in the previous section, we will need
    to edit our `_app.js` file so that Redux will be globally available for every
    component living inside of our Next.js app:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中使用Context API所做的那样，我们需要编辑我们的`_app.js`文件，以便Redux将全局可用，对于Next.js应用中每个居住的组件：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you compare this `_app.js` file with the one we created in the previous section,
    you may notice some similarities. From this moment, the two implementations will
    look very similar, as Context APIs try to make global state management more accessible
    and easier for everyone, and the Redux influence in shaping those APIs is visible.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个`_app.js`文件与我们之前创建的文件进行比较，你可能会注意到一些相似之处。从现在开始，这两个实现将看起来非常相似，因为Context
    API试图使全局状态管理对每个人来说更加可访问和容易，Redux对这些API的影响是显而易见的。
- en: 'We now need to implement the `increment`/`decrement` logic for our `ProductCard`
    component using Redux. Let''s start by opening the `components/ProductCard.js`
    file and add the following imports:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要实现`ProductCard`组件的`increment`/`decrement`逻辑，使用Redux。让我们首先打开`components/ProductCard.js`文件，并添加以下导入：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s create a Hook that will come in handy when we need to fetch all
    the products in our Redux store:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个钩子，当我们需要从我们的Redux存储中获取所有产品时，它会很有用：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Staying inside the same file, let''s edit the `ProductCard` component by integrating
    the Redux Hooks we need:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件中，让我们通过集成我们需要的Redux Hooks来编辑`ProductCard`组件：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, we need to trigger a dispatch when the user clicks on one of our component''s
    buttons. Thanks to the `useDispatch` Hook we previously imported, that operation
    will be straightforward to implement. We just need to update the `onClick` callback
    for our HTML buttons inside the render function as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在用户点击我们组件的按钮之一时触发一个分发操作。多亏了我们之前导入的`useDispatch`钩子，这个操作将非常容易实现。我们只需要更新渲染函数中HTML按钮的`onClick`回调，如下所示：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Suppose you've installed the Redux DevTools extension for your browser. In that
    case, you can now start to increment or decrement a product and see the action
    as it is dispatched directly inside your debugging tools.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经为你的浏览器安装了Redux DevTools扩展。在这种情况下，你现在可以开始增加或减少产品，并直接在你的调试工具中看到分发的动作。
- en: 'By the way, we still need to update the navigation bar when we add or remove
    a product from our cart. We can easily do that by editing the `components/NavBar.js`
    component just as we did for the `ProductCard` one:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，我们仍然需要在添加或从购物车中移除产品时更新导航栏。我们可以通过编辑`components/NavBar.js`组件，就像我们为`ProductCard`所做的那样，轻松地做到这一点：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We can now try to add and remove products from our storefront and see the state
    change reflected in the navigation bar.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以尝试添加和删除我们的店面产品，并看到状态变化在导航栏中反映出来。
- en: 'One last thing before we can consider our e-commerce app complete: we need
    to update the `/cart` page so that we can see a summary of the shopping cart before
    moving to the checkout step. It will be incredibly easy, as we will combine what
    we learned from the previous section using the Context APIs and the knowledge
    of Redux Hooks we''ve just gained. Let''s open the `pages/Cart.js` file and import
    the same Redux Hook we used for the other components:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们考虑我们的电子商务应用程序完整之前，还有最后一件事：我们需要更新`/cart`页面，以便在进入结账步骤之前查看购物车摘要。这将非常简单，因为我们将会结合之前章节中学到的Context
    API和刚刚获得的Redux Hooks知识。让我们打开`pages/Cart.js`文件，并导入我们用于其他组件的相同Redux Hook：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'At this point, we can just replicate the `getFullItem` function we created
    for the Context APIs in the previous section:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们只需复制我们在上一节为Context API创建的`getFullItem`函数：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The same happens for the `Cart` component. We will basically replicate what
    we did in the previous section, with a simple difference: the `items` object will
    come from the Redux store instead of a React context:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Cart`组件也是如此。我们将基本上复制我们在上一节所做的一切，唯一的区别是`items`对象将来自Redux存储而不是React上下文：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you now try to add a couple of products to your shopping cart, then move
    to the `/cart` page, you will see a summary of your expenses.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在尝试将一些产品添加到您的购物车中，然后转到`/cart`页面，您将看到您的费用摘要。
- en: As you may have noticed, there aren't many differences between Context APIs
    and plain Redux (without using any middleware). By using Redux, by the way, you'll
    gain access to an incredibly vast ecosystem of plugins, middleware, and debugging
    tools that will make your developer experience way more effortless once you need
    to scale and handle very complex business logic inside of your web application.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，Context API和纯Redux（不使用任何中间件）之间没有太多区别。顺便说一句，通过使用Redux，您将获得一个极其庞大的生态系统，包括插件、中间件和调试工具，这将使您的开发体验在需要扩展和处理Web应用程序内部非常复杂业务逻辑时变得更加轻松。
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we focused on state management using both React built-in APIs
    (the Context APIs and Hooks) and external libraries (Redux). There are many other
    tools and libraries for managing an application's global state (**MobX**, **Recoil**,
    **XState**, **Unistore**, to name just a few). You can use all of them inside
    your Next.js application by initializing them for both client-side and server-side
    usage, just like we did with Redux.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于使用React内置API（Context API和Hooks）以及外部库（Redux）进行状态管理。还有许多其他工具和库用于管理应用程序的全局状态（**MobX**、**Recoil**、**XState**、**Unistore**，仅举几个例子）。您可以在Next.js应用程序中使用它们，通过为客户端和服务器端使用初始化它们，就像我们使用Redux一样。
- en: Also, you can use Apollo GraphQL and its in-memory cache for managing your application
    state, gaining access to a formal query language for mutating and querying your
    global data.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用Apollo GraphQL及其内存缓存来管理您的应用程序状态，从而获得一个用于修改和查询全局数据的正式查询语言。
- en: We can now create more complex and interactive web applications, managing different
    kinds of state with any library we want.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建更复杂和交互式的Web应用程序，使用我们想要的任何库来管理不同种类的状态。
- en: But once you have your data well organized and ready to use, you need to display
    it and render your application UI depending on your application state. In the
    next chapter, you will see how to style your web app by configuring and using
    different CSS and JavaScript libraries.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但一旦您的数据组织得很好并且准备好使用，您就需要根据您的应用程序状态显示它并渲染您的应用程序UI。在下一章中，您将看到如何通过配置和使用不同的CSS和JavaScript库来设置您的Web应用程序样式。
