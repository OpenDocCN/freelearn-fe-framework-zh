- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Mocking the API
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟 API
- en: In the previous chapter, we built the application pages that use test data.
    The UI of the pages is complete, but the pages are not functional yet. We are
    using the test data without making requests to the API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了使用测试数据的应用程序页面。页面的 UI 是完整的，但页面尚未启用。我们正在使用测试数据，而不向 API 发送请求。
- en: In this chapter, we will learn what mocking is and why it is useful. We will
    learn how to mock the API endpoints with the `msw` library, a great tool that
    allows us to create mocked API endpoints that behave as real-world API endpoints.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习模拟是什么以及为什么它有用。我们将学习如何使用 `msw` 库模拟 API 端点，这是一个允许我们创建模拟 API 端点的强大工具，这些端点的行为类似于现实世界的
    API 端点。
- en: We will also learn how to model the data of our application entities with the
    `@``mswjs/data` library.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将学习如何使用 `@mswjs/data` 库对应用程序实体的数据进行建模。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Why is mocking useful?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么模拟是有用的？
- en: Introduction to MSW
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSW 简介
- en: Configuring data models
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置数据模型
- en: Configuring request handlers for API endpoints
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 API 端点的请求处理器
- en: By the end of this chapter, we will learn how to generate fully featured mocked
    APIs with data models set in place, which will make our code base less dependent
    on external APIs during development.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将学习如何生成具有完整功能的模拟 API，其中已设置数据模型，这将使我们的代码库在开发期间对外部 API 的依赖性降低。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we get started, we need to set up our project. To be able to develop
    our project, we will need the following things installed on our computer:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要设置我们的项目。为了能够开发我们的项目，我们将在计算机上需要以下内容安装：
- en: '**Node.js** version 16 or above and **npm** version 8 or above'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js** 版本 16 或以上和 **npm** 版本 8 或以上'
- en: 'There are multiple ways to install Node.js and npm. Here is a great article
    that goes into more detail: [https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js](https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Node.js 和 npm 有多种方法。以下是一篇深入探讨的精彩文章：[https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js](https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js).
- en: '**Visual Studio Code** (**VS Code**) (optional) is currently the most popular
    editor/IDE for JavaScript/TypeScript, so we will be using it. It is open source,
    has great integration with TypeScript, and we can extend its features via extensions.
    It can be downloaded from here: [https://code.visualstudio.com/](https://code.visualstudio.com/).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code** （**VS Code**）（可选）是目前最流行的 JavaScript/TypeScript 编辑器/IDE，因此我们将使用它。它是开源的，与
    TypeScript 集成良好，并且我们可以通过扩展来扩展其功能。可以从这里下载：[https://code.visualstudio.com/](https://code.visualstudio.com/).'
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/React-Application-Architecture-for-Production](https://github.com/PacktPublishing/React-Application-Architecture-for-Production)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/React-Application-Architecture-for-Production](https://github.com/PacktPublishing/React-Application-Architecture-for-Production)
- en: 'The repository can be cloned locally with the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令在本地克隆存储库：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the repository is cloned, we need to install the application’s dependencies:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦克隆了存储库，我们需要安装应用程序的依赖项：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can provide the environment variables using the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令提供环境变量：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the dependencies have been installed, we need to select the right stage
    of the code base that matches this chapter. We can do that by executing the following
    command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了依赖项，我们需要选择与本章匹配的代码库的正确阶段。我们可以通过执行以下命令来完成：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command will prompt us with a list of stages for each chapter:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将为我们提供每个章节的阶段列表：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is the fifth chapter, so we can select `chapter-05-start` if we want to
    follow along, or `chapter-05` to see the final results of the chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第五章，所以如果我们想跟随，可以选择 `chapter-05-start`，或者选择 `chapter-05` 来查看章节的最终结果。
- en: Once the chapter has been selected, all files required to follow along with
    the chapter will appear.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了章节，所有用于跟随本章所需的文件将显示出来。
- en: For more information about the setup details, check out the `README.md` file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于设置细节的信息，请查看 `README.md` 文件。
- en: Why is mocking useful?
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么模拟是有用的？
- en: '**Mocking** is the process of simulating parts of the system, meaning they
    are not production-ready but fake versions that are useful for development and
    testing.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟**是模拟系统部分的过程，这意味着它们不是生产就绪的，而是有用的开发测试的假版本。'
- en: 'You may ask yourself, *Why do we want to bother with setting a mocked API?*
    There are several benefits of having the API mocked:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己，*为什么我们要费心设置模拟API呢？* 拥有模拟API有几个好处：
- en: '**Independence of external services during development**: A web application
    usually consists of many different parts such as the frontend, the backend, external
    third-party APIs, and so on. When developing our frontends, we want to be as autonomous
    as possible without getting blocked by some parts of the system that are not functional.
    If the API of our application is broken or unfinished, we should still be able
    to proceed with developing the frontend part of the application.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发期间外部服务的独立性**：一个Web应用程序通常由许多不同的部分组成，如前端、后端、外部第三方API等。在开发前端时，我们希望尽可能自主，不被系统中的某些非功能部分所阻碍。如果我们的应用程序API损坏或不完整，我们仍然应该能够继续开发应用程序的前端部分。'
- en: '**Good for quick prototyping**: Mocked endpoints allow us to prototype the
    application quicker since they don''t require any additional setup such as the
    backend server, database, and so on. Very useful for building **proofs of concept**
    (**POCs**) and **minimum viable product** (**MVP**) applications.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速原型设计**：模拟端点允许我们更快地原型化应用程序，因为它们不需要任何额外的设置，例如后端服务器、数据库等。这对于构建**概念验证**（**POCs**）和**最小可行产品**（**MVP**）应用程序非常有用。'
- en: '**Offline development**: Having mocked API endpoints allows us to develop our
    application without an internet connection.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**离线开发**：通过模拟API端点，我们可以在没有互联网连接的情况下开发我们的应用程序。'
- en: '**Testing**: We do not want to hit our real services while testing our frontends.
    That’s where mocked APIs become useful. We can build and test the entire functionality
    as if we were building it against a real API and then switch to the real one when
    in production.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：我们不想在测试前端时触及我们的真实服务。这就是模拟API变得有用的地方。我们可以像针对真实API构建一样构建和测试整个功能，然后在生产时切换到真实的一个。'
- en: For testing our API endpoints, we will use the **Mock Service Worker** (**MSW**)
    library, a great tool that allows us to mock endpoints in a very elegant way.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的API端点，我们将使用**Mock Service Worker**（**MSW**）库，这是一个非常棒的工具，它允许我们以非常优雅的方式模拟端点。
- en: Introduction to MSW
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MSW简介
- en: '**MSW** is a tool that allows us to create mocked APIs. It works as a service
    worker that intercepts any API request that has its mocked version defined. We
    can inspect the requests and responses in the **Network** tab of our browser the
    same way as if we were calling the real API.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**MSW** 是一个允许我们创建模拟API的工具。它作为一个服务工作者，拦截任何已定义模拟版本的API请求。我们可以像调用真实API一样，在我们的浏览器“网络”标签页中检查请求和响应。'
- en: 'To get a high-level overview of how it works, let’s take a look at the diagram
    provided on their website:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得其工作的高级概述，让我们看看他们网站上提供的图解：
- en: '![Figure 5.1 – MSW workflow diagram ](img/B17297_05_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – MSW工作流程图](img/B17297_05_01.jpg)'
- en: Figure 5.1 – MSW workflow diagram
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – MSW工作流程图
- en: One great thing about MSW is that our application will behave the same as if
    it were using a real API, and it’s pretty trivial to switch to using the real
    API by turning mocked endpoints off and not intercepting requests.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: MSW的一个优点是，我们的应用程序将表现得就像它正在使用真实的API一样，而且通过关闭模拟端点和不拦截请求，切换到使用真实API是非常简单的。
- en: Another great thing is that since the interception happens at the network level,
    we will still be able to inspect our requests in the **Network** tab of the browser
    dev tools.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件很棒的事情是，由于拦截发生在网络级别，我们仍然能够在浏览器开发者工具的“网络”标签页中检查我们的请求。
- en: Configuration overview
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置概述
- en: We already have the MSW package installed as a dev dependency. The msw mocked
    API can be configured to work both in the browser and on the server.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将MSW包安装为开发依赖项。msw模拟API可以被配置为在浏览器和服务器上同时工作。
- en: Browser
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浏览器
- en: The *browser* version of the mocked API can be used for running mocked endpoints
    during the development of the application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟API的**浏览器**版本可以在应用程序开发期间运行模拟端点。
- en: Initialization
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始化
- en: 'The first thing that needs to be done is to create a service worker. This can
    be done by executing the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 需要做的第一件事是创建一个服务工作者。这可以通过执行以下命令来完成：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding command will create a service worker at `public/mockServiceWorker.js`,
    which will intercept our requests in the browser and modify the responses accordingly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在`public/mockServiceWorker.js`创建一个服务工作者，它将在浏览器中拦截我们的请求并相应地修改响应。
- en: Configuring the worker for the browser
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为浏览器配置工作器
- en: 'We can now configure our worker to use the endpoints we will define in a couple
    of moments. Let’s open the `src/testing/mocks/browser.ts` file and add the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以配置我们的工作器使用我们将在不久后定义的端点。让我们打开`src/testing/mocks/browser.ts`文件并添加以下内容：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding snippet will configure MSW to work with the provided handlers
    in the browser.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段将配置MSW与提供的处理程序在浏览器中一起工作。
- en: Server
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器
- en: The *server* version is used mostly during running automated tests since our
    test runner works in the Node environment instead of the browser. The server version
    is also useful for API calls executed on the server, which we will have for our
    application during server-side rendering.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务器*版本主要用于运行自动化测试，因为我们的测试运行器在Node环境中工作，而不是在浏览器中。服务器版本对于在服务器上执行的API调用也很有用，这对于我们的应用程序在服务器端渲染时是必需的。'
- en: Configuring MSW for the server
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为服务器配置MSW
- en: 'Let’s open the `src/testing/mocks/server.ts` file and add the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`src/testing/mocks/server.ts`文件并添加以下内容：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding snippet will apply the handlers to the server version of our mocks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段将处理程序应用到我们的模拟的服务器版本。
- en: Running MSW in the application
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在应用程序中运行MSW
- en: 'Now that we have configured MSW, we need to make it run in our application.
    To do that, let’s open the `src/testing/mocks/initialize.ts` file and modify the
    `initializeMocks` function to the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了MSW，我们需要让它在我们的应用程序中运行。为此，让我们打开`src/testing/mocks/initialize.ts`文件并修改`initializeMocks`函数如下：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `initializeMocks` function is in charge of calling the proper MSW setup
    based on the environment it is being called in. If it is executed on the server,
    it will run the server version. Otherwise, it will start the browser version.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`initializeMocks`函数负责根据其被调用的环境调用适当的MSW设置。如果它在服务器上执行，它将运行服务器版本。否则，它将启动浏览器版本。'
- en: Now, we need to integrate our mocks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要集成我们的模拟。
- en: 'Let’s create an `src/lib/msw.tsx` file and add the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`src/lib/msw.tsx`文件并添加以下内容：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here we defined `MSWWrapper`, which is a component that will wrap our application
    and initialize MSW and the MSW dev tools into the wrapped application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了`MSWWrapper`，这是一个将包裹我们的应用程序并初始化MSW和MSW开发工具到包裹应用程序中的组件。
- en: Now we can integrate it into our application by opening `src/pages/_app.tsx`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过打开`src/pages/_app.tsx`将其集成到我们的应用程序中。
- en: 'We want to add new imports:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要添加新的导入：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we want to load `MSWWrapper` dynamically:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们想要动态加载`MSWWrapper`：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, let’s modify the `return` statement of our `App` component as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们修改`App`组件的`return`语句如下：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, we will load the `MSWWrapper` component and wrap the content
    of the page only if the mocks are enabled. We are doing this to exclude MSW-related
    code for the production version of the application, which uses the real API and
    does not need the redundant MSW-related code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只有在模拟启用时才会加载`MSWWrapper`组件并包裹页面内容。我们这样做是为了排除应用程序生产版本中的MSW相关代码，该版本使用真实API，并且不需要冗余的MSW相关代码。
- en: 'To verify that MSW is running, let’s open the console. We should see something
    like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证MSW是否正在运行，让我们打开控制台。我们应该看到如下内容：
- en: '![Figure 5.2 – MSW running in our application ](img/B17297_05_02.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – MSW在我们的应用程序中运行](img/B17297_05_02.jpg)'
- en: Figure 5.2 – MSW running in our application
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – MSW在我们的应用程序中运行
- en: Now that we have successfully installed and integrated MSW in our application,
    let’s implement our first mocked endpoint.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功安装并集成了MSW到我们的应用程序中，让我们实现我们的第一个模拟端点。
- en: Writing our first handler
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写我们的第一个处理程序
- en: To define mocked endpoints, we need to create request handlers. Think of request
    handlers as functions that determine whether a request should be intercepted and
    modified by mocking their responses.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义模拟端点，我们需要创建请求处理程序。将请求处理程序想象成函数，它们通过模拟其响应来确定是否应该拦截和修改请求。
- en: 'Let’s create our first handler in the `src/testing/mocks/handlers/index.ts`
    file by adding the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`src/testing/mocks/handlers/index.ts`文件中创建我们的第一个处理程序，添加以下内容：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We are using the `rest` helper provided by `msw` to define our rest endpoints.
    We are using the `get` method, which accepts the path, and a callback, which will
    modify the response.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`msw`提供的`rest`辅助工具来定义我们的REST端点。我们使用的是`get`方法，它接受路径和一个回调，该回调将修改响应。
- en: The handler callback will return a response with a status code of `200` and
    the response data set as `{ healthy:` `true }`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '处理程序回调将返回一个状态码为`200`的响应，并将响应数据设置为`{ healthy: true }`。'
- en: 'To verify that our handler is working, let’s open the dev tools in the bottom-right
    corner and then select the health check endpoint:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们的处理程序是否正常工作，让我们在右下角打开开发者工具，然后选择健康检查端点：
- en: '![Figure 5.3 – Health check handler test selection ](img/B17297_05_03.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 健康检查处理程序测试选择](img/B17297_05_03.jpg)'
- en: Figure 5.3 – Health check handler test selection
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 健康检查处理程序测试选择
- en: 'Sending the request should give us a response, as shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 发送请求应该会给我们一个响应，如下所示：
- en: '![Figure 5.4 – Health check handler test result ](img/B17297_05_04.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – 健康检查处理程序测试结果](img/B17297_05_04.jpg)'
- en: Figure 5.4 – Health check handler test result
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 健康检查处理程序测试结果
- en: The **Devtools** widget is going to give us the ability to test our handlers
    without creating the UI in the application right away.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**Devtools**小部件将为我们提供测试处理程序的能力，而无需立即在应用程序中创建UI。'
- en: Now that we have MSW running properly in our application, it is time to create
    a data model for our application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在应用程序中正确运行了MSW，是时候为我们的应用程序创建数据模型了。
- en: Configuring data models
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置数据模型
- en: For data modeling our application, we will be using the data library from MSW,
    which is very useful and simple to use to manipulate the data in a similar way
    an **object-relational mapper** (**ORM**) on the backend would.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对应用程序进行数据建模，我们将使用MSW的数据库，它非常实用且易于使用，可以以类似后端对象关系映射器（ORM）的方式操作数据。
- en: To make our request handlers functional, we could just hardcode the responses,
    but where is the fun in that? With MSW and its data library, we can build a mocked
    backend that is fully functional with the business logic included should we decide
    to implement it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的请求处理程序功能化，我们只需直接编写响应即可，但那样有什么乐趣呢？使用MSW及其数据库，我们可以构建一个模拟的后端，它包含业务逻辑，并且如果我们决定实现它，它将完全功能化。
- en: 'To configure our data models, let’s open the `src/testing/mocks/db.ts` file
    and add the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置我们的数据模型，让我们打开`src/testing/mocks/db.ts`文件并添加以下内容：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are importing the `factory` and `primaryKey` functions from the `@mswjs/data`
    package. The `primaryKey` function allows us to define primary keys in our mocked
    database, and the `factory` function creates an in-memory database that we can
    use for testing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`@mswjs/data`包中导入`factory`和`primaryKey`函数。`primaryKey`函数允许我们在模拟数据库中定义主键，而`factory`函数创建一个内存数据库，我们可以用它来进行测试。
- en: 'We can then access a bunch of different methods on each model that allow us
    to manipulate our data more easily, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以访问每个模型的一组不同方法，这些方法允许我们更轻松地操作我们的数据，如下所示：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It would also be great if we could pre-fill some data in the database so that
    we always had something to show in our application. To do that, we should seed
    the database.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能在数据库中预先填充一些数据，那就太好了，这样我们总是有东西可以在我们的应用程序中展示。为此，我们应该对数据库进行预种。
- en: 'Let’s open the `src/testing/mocks/seed-db.ts` file and add the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`src/testing/mocks/seed-db.ts`文件并添加以下内容：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `seedDb` function will populate the database with test data.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`seedDb`函数将用测试数据填充数据库。'
- en: 'Let’s execute it after our mocked endpoints have been initialized. Open `src/testing/mocks/initialize.ts`
    and call the function, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模拟端点初始化后执行它。打开`src/testing/mocks/initialize.ts`并调用函数，如下所示：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To inspect the data in our database, we can open the **Data** tab in **Devtools**:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查我们数据库中的数据，我们可以在**Devtools**中打开**数据**标签页：
- en: '![Figure 5.5 – Inspecting seeded data ](img/B17297_05_05.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – 检查预种数据](img/B17297_05_05.jpg)'
- en: Figure 5.5 – Inspecting seeded data
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 检查预种数据
- en: Awesome! Now, we have our database pre-filled with some test data. We can now
    create request handlers, which will interact with the database and consume the
    data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，我们的数据库已经预先填充了一些测试数据。我们现在可以创建请求处理程序，它们将与数据库交互并消耗数据。
- en: Configuring request handlers for API endpoints
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置API端点的请求处理程序
- en: In this section, we will define handlers for our application. As already mentioned,
    a handler in MSW is a function that, if defined, will intercept any matching requests,
    and instead of sending the requests to the network, it will modify them and return
    the mocked response.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将定义我们应用程序的处理程序。如前所述，MSW中的处理程序是一个函数，如果定义了它，将拦截任何匹配的请求，而不是将请求发送到网络，而是修改它们并返回模拟的响应。
- en: API utils
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API工具
- en: 'Before getting started, let’s take a quick look at the `src/testing/mocks/utils.ts`
    file, which includes some utilities we will be using for handling the business
    logic of our API handlers:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们快速查看`src/testing/mocks/utils.ts`文件，它包含我们将用于处理API处理程序业务逻辑的一些实用工具：
- en: '`authenticate` accepts user credentials, and if they are valid, it will return
    the user from the database together with the authentication token.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authenticate` 接受用户凭证，如果它们有效，它将从数据库返回用户以及认证令牌。'
- en: '`getUser` returns a test user object.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getUser` 返回一个测试用户对象。'
- en: '`requireAuth` returns the current user if the token in the cookie is available.
    It can optionally throw an error if the token does not exist.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requireAuth` 如果cookie中的令牌可用，则返回当前用户。如果令牌不存在，它可以选择抛出一个错误。'
- en: 'Before getting started, let’s include all handlers in the configuration. Open
    the `src/testing/mocks/handlers/index.ts` file and change it to the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们将所有处理器包含在配置中。打开 `src/testing/mocks/handlers/index.ts` 文件并将其更改为以下内容：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We are including all handlers we will define in each of the handlers’ files
    and make them available to MSW.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义的所有处理器都包含在每个处理器的文件中，并使它们对MSW可用。
- en: Now, we can start working on the request handlers for our application.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始为我们应用程序编写请求处理器。
- en: Auth handlers
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证处理器
- en: 'For the `auth` feature, we will need the following endpoints:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `auth` 功能，我们需要以下端点：
- en: '`POST /auth/login`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /auth/login`'
- en: '`POST /auth/logout`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /auth/logout`'
- en: '`GET /auth/me`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /auth/me`'
- en: The endpoints for `auth` will be defined in the `src/test/mocks/handlers/auth.ts`
    file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`auth` 的端点将在 `src/test/mocks/handlers/auth.ts` 文件中定义。'
- en: 'Let’s start by importing the dependencies:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先导入依赖项：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, let’s create a request handler for logging in:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个用于登录的请求处理器：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We are extracting the credentials and using them to get the user info and the
    token. Then, we attach the token to the cookie and return the user in the response
    with a 300 ms delay as the real API.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在提取凭证并使用它们来获取用户信息和令牌。然后，我们将令牌附加到cookie中，并在300毫秒的延迟后以真实API的方式返回用户。
- en: We are using the `httpOnly` cookie because it is safer since it is not accessible
    from the client.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `httpOnly` cookie，因为它更安全，因为它不可从客户端访问。
- en: 'Then, let’s create a logout handler:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个注销处理器：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The handler will just empty the cookie and return the response. Any subsequent
    requests to protected handlers will throw an error.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 该处理器将仅清空cookie并返回响应。任何后续请求到受保护的处理器都将抛出错误。
- en: 'Finally, we have an endpoint for fetching the currently authenticated user:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个用于获取当前认证用户的端点：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The endpoint will extract the user from the token and return it in the response.
    In the end, we should export the handlers in order for them to be consumed by
    MSW:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 该端点将提取令牌中的用户并将其作为响应返回。最后，我们应该导出处理器，以便它们可以被MSW消费：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Jobs handlers
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作处理器
- en: 'For the `jobs` feature, we will need the following endpoints:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `jobs` 功能，我们需要以下端点：
- en: '`GET /jobs`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /jobs`'
- en: '`GET /jobs/:jobId`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /jobs/:jobId`'
- en: '`POST /jobs`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /jobs`'
- en: The endpoints for `jobs` will be defined in the `src/test/mocks/handlers/jobs.ts`
    file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`jobs` 的端点将在 `src/test/mocks/handlers/jobs.ts` 文件中定义。'
- en: 'Let’s start by importing the dependencies:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先导入依赖项：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, let’s implement a handler for fetching jobs:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们实现一个用于获取工作的处理器：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We are getting the organization ID from the search parameters and using that
    to get jobs for a given organization, which we return in the response.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从查询参数中获取组织ID，并使用它来获取给定组织的作业，然后将其作为响应返回。
- en: 'Another endpoint we want to create is a job details endpoint. We can do that
    by creating the following handler:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想要创建一个工作详情端点。我们可以通过创建以下处理器来实现：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We are getting the job ID from the URL parameters and using that to retrieve
    the given job from the database. If the job is not found, we return a `404` error.
    Otherwise, we return the job in the response.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从URL参数中获取工作ID，并使用它从数据库检索给定的工作。如果没有找到工作，我们返回一个 `404` 错误。否则，我们在响应中返回工作。
- en: 'Our application also needs an endpoint for creating jobs. We can create a handler
    for that, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序还需要一个用于创建工作的端点。我们可以创建一个处理器，如下所示：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are first checking whether the user is authenticated since we don’t want
    to allow creation for unauthenticated users. Then, we get the job data from the
    request and use that to create a new job, which we then return in the response.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查用户是否已认证，因为我们不希望允许未认证用户创建（操作）。然后，我们从请求中获取工作数据，并使用这些数据创建一个新的工作，然后将其作为响应返回。
- en: 'Finally, we want to export the handlers to make them available for MSW:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们想要导出处理器，以便它们对MSW可用：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Organizations handlers
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织处理器
- en: For the `organizations` feature, we will need the `GET /``organizations/:organizationId`
    endpoint.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `organizations` 功能，我们需要 `GET /``organizations/:organizationId` 端点。
- en: All handlers for this feature will be defined in the `src/test/mocks/handlers/organizations.ts`
    file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 所有针对此功能的处理程序都将定义在 `src/test/mocks/handlers/organizations.ts` 文件中。
- en: 'Let’s start by importing all required dependencies:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先导入所有必需的依赖项：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we can implement the endpoint for getting organization details by adding
    the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过添加以下内容来实现获取组织详情的端点：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We are getting the organization ID from URL parameters and using that to retrieve
    the given organization. If it doesn’t exist in the database, the handler will
    return a `404` error; otherwise, it will return the found organization.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 URL 参数中获取组织 ID，并使用它来检索指定的组织。如果它在数据库中不存在，处理程序将返回一个 `404` 错误；否则，它将返回找到的组织。
- en: 'In the end, we must export the handler:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须导出处理程序：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To verify that we have all handlers defined, we can visit **Devtools** again:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们已定义了所有处理程序，我们可以再次访问 **Devtools**：
- en: '![Figure 5.6 – Mocked endpoints ](img/B17297_05_06.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 模拟端点](img/B17297_05_06.jpg)'
- en: Figure 5.6 – Mocked endpoints
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 模拟端点
- en: Great! Now, we have all the required handlers to make our application work as
    if it were consuming the real API. Play around with the handlers to make sure
    that everything works as expected. In the next chapter, we will integrate these
    endpoints into the application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，我们已经拥有了所有必需的处理程序，使我们的应用程序能够像消费真实 API 一样工作。玩转这些处理程序以确保一切按预期工作。在下一章中，我们将将这些端点集成到应用程序中。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about mocking the API. We introduced the **MSW**
    library, which is a great tool for mocking APIs in an elegant way. It can work
    both in the browser and on the server. It is super useful for prototyping and
    testing the application during development.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何模拟 API。我们介绍了 **MSW** 库，这是一个以优雅方式模拟 API 的优秀工具。它可以在浏览器和服务器上工作。它在原型设计和开发过程中的测试中非常有用。
- en: In the next chapter, we will integrate the API layer of the application, which
    will consume the endpoints we just created.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将集成应用程序的 API 层，该层将消费我们刚刚创建的端点。
