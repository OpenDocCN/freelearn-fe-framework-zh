- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setup and Project Structure Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at all the challenges when building a React
    application and some great solutions that can help us handle them. We also planned
    out how our application should work and what tools we should use.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at the project structure and the setup tools that
    make a good baseline for our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Next.js application overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript setup overview and usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ESLint setup overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prettier setup overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pre-committing checks setup overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project structure overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have a good understanding of the tools we
    will be using for the project setup and the feature-based project structure to
    make organizing our code more manageable.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get started, we need to set up our project. To be able to develop
    our project, we will need the following things installed on our computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node.js** version 16 or above and **npm** version 8 or above.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are multiple ways to install Node.js and npm. Here is a great article
    that goes into more detail: [https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js](https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js).'
  prefs: []
  type: TYPE_NORMAL
- en: '**VSCode** (optional) is currently the most popular editor/IDE for JavaScript/TypeScript,
    so we will be using it. It is open source, has great integration with TypeScript,
    and we can extend its features via extensions. It can be downloaded from [https://code.visualstudio.com/](https://code.visualstudio.com/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/React-Application-Architecture-for-Production](https://github.com/PacktPublishing/React-Application-Architecture-for-Production).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The repository can be cloned locally with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the repository has been cloned, we need to install the application’s dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to provide the environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the dependencies have been installed, we need to select the right stage
    of the code base that matches this chapter. We can do that by executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will prompt us with a list of stages for each chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is the second chapter so we can select the `chapter-02` option.
  prefs: []
  type: TYPE_NORMAL
- en: Once the chapter has been selected, all files required to follow along with
    the chapter will appear. To follow along with this chapter, we don’t need to make
    any changes to the code. We can just use it as a reference to help get a better
    overview of the code base.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the setup details, check out the `README.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: Next.js application overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next.js is a web framework built on top of React and Node.js, allowing us to
    build web applications. Because it can run on the server, it can be used as a
    full-stack framework.
  prefs: []
  type: TYPE_NORMAL
- en: Why Next.js?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using Next.js has multiple benefits. We want to use it because of several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Very easy to get started with**: In the early days of React, it was very
    challenging to start a project. To get a simple page on the screen, we had to
    deal with many tools such as Webpack, Babel, and others. We still use those tools
    today, but fortunately, most tooling configuration is hidden from us with an interface
    to extend the configuration if required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides the challenges of setting up the project, it is very challenging to
    maintain all those dependencies over time. Next.js hides all those complexities
    away from developers and allows them to get started quickly with a new project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Allows multiple rendering strategies**: Being able to use multiple rendering
    strategies is probably the main reason why we want to use Next.js, although it
    comes with other great benefits. First, it allows us to define the behavior of
    page rendering at the page level, meaning we can define how we want to render
    each page individually. It also supports multiple rendering strategies, such as
    the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-side rendering
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-side rendering
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Static site generation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Incremental static regeneration
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be using different strategies based on the application’s needs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance optimizations**: Next.js is built with web performance in mind.
    It implements performance optimization techniques such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code splitting
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy loading
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefetching
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Image optimization
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: That sums up why we want to use Next.js for our application. Now, let’s see
    what the Next.js application structure looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Next.js application structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to get started with Next.js is to use the `create-next-app`
    CLI to generate a new application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have already generated the application as part of the code samples,
    we do not need to use the CLI, but if we were generating the application from
    scratch, we would execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By executing this command, we would generate a new Next.js application with
    TypeScript configured out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of things that are specific to Next.js. Let’s look at the
    following file and folder structure of a simple Next.js application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s analyze each file and folder one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.next`: Contains production-ready files generated by running the `build` command
    of Next.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public`: Contains all static assets of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/pages`: This is a special folder in Next.js where all pages defined here
    become available at corresponding routes. This is possible thanks to the filesystem-based
    routing system. The `pages` folder can also live in the root of the project, but
    it is nice to keep everything in the `src` folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/pages/_app.tsx`: The `_app.tsx` file is a special file that exports a
    React component that wraps every page when rendered. By wrapping pages with this
    special component, we can add custom behavior for our application, such as adding
    any global configurations, providers, styles, layouts, and more to all the pages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/pages/index.tsx`: This is how we declare pages of the application. This
    shows how the root page is defined. We will dive into Next.js-specific routing
    in the upcoming chapters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next.config.js`: This is where we can extend the default functionalities such
    as Webpack configuration and other things in a simple way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package.json`: Every Next.js application includes the following npm scripts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dev`: Starts a development server on `localhost:3000`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build`: Builds the application for production'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start`: Starts the production build on `localhost:3000`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We will cover more on these topics in the following chapters, but for now, this
    should give us enough information to get started with Next.js.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript setup overview and usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is a dynamically typed programming language, meaning it doesn’t catch
    any type errors during build time. That’s where TypeScript comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript is a programming language that acts as a superset of JavaScript,
    which allows us to write JavaScript with some behaviors of a statically typed
    language. This comes in handy as we can catch many potential bugs before they
    get into production.
  prefs: []
  type: TYPE_NORMAL
- en: Why TypeScript?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript is especially useful for large applications built by large teams.
    Code written in TypeScript is much better documented than code written in vanilla
    JavaScript. By looking at the type definitions, we can figure out how a piece
    of code is supposed to work.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason is that TypeScript makes refactoring much easier because most
    of the issues can be caught before running the application.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript also helps us utilize our editor’s IntelliSense, which shows us intelligent
    code completion, hover information, and signature information, which speeds up
    our productivity.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our project already has TypeScript configured. The TypeScript configuration
    is defined in the `tsconfig.json` file at the root of the project. It allows us
    to configure how strict we want it to be based on our needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will not dive too deeply into every configuration property since most of
    the properties have been auto-generated. However, there is one thing that was
    also provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will tell the TypeScript compiler that anything imported via `@/*` will
    refer to the `src` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, we had to perform messy imports, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can import components like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: No matter how many nested levels we have, we can always import with absolute
    paths, and we will not be required to change our import statement should we decide
    to move the consumer file somewhere else.
  prefs: []
  type: TYPE_NORMAL
- en: Basic TypeScript usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s cover some TypeScript basics so that we are comfortable using it throughout
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we are only allowed to assign values with the corresponding type.
    Assigning to any other type except the `any` type, which we will cover in a moment,
    will cause a TypeScript error.
  prefs: []
  type: TYPE_NORMAL
- en: Any
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `any` type is the loosest type in TypeScript and using it will disable
    any type checking. We can use it when we want to bypass errors that would usually
    occur. However, we should only use it as a last resort and try to use other types
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, variables with the `any` type can accept and be assigned to a
    value of any other type, which makes it very flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Unknown
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, we can’t know upfront which types we will have. This might happen
    with some dynamic data where we don’t know its type yet. Here, we can use the
    `unknown` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we can assign values of any type to the variable with `unknown`
    `type`. However, we can only assign values with type `unknown` to the variables
    with `any` and `unknown` types.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two ways to define array types with TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Object shapes can be defined in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first one is called type alias, while the second is called interface.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few differences between type aliases and interfaces, but we won't
    get into them right now. For any object shape type we define, we can use type
    aliases.
  prefs: []
  type: TYPE_NORMAL
- en: Unions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The basic types we just mentioned are great, but sometimes, we want to allow
    a variable to be one of many types. Let’s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `content` variable can now be either `string` or `number`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add literal types in the union, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are defining colors as strings, but we want to add more constraints
    so that we can only take one of those three colors. If we try to add anything
    else, TypeScript will warn us with an error.
  prefs: []
  type: TYPE_NORMAL
- en: Intersections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Intersection types allow us to combine the properties of two different objects
    into a single type. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `FooBar` type will now contain the `x`, `y`, and `z` properties.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Generics is a mechanism of creating reusable types by parameterizing them.
    They can help us reduce code repetition. Consider the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see what happens if we need the same structure but with `x` as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that there is some code duplication going on. We can simplify
    this by making it generic so that it accepts the type as `T`. This would be assigned
    as the type of the `x` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a nice way to reuse the structure by passing different types to
    the generic.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use generics with functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To try out these snippets and see how different types behave, go to [https://www.typescriptlang.org/play](https://www.typescriptlang.org/play),
    copy the snippets, and play around with the types to see how they work.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript and React
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every TypeScript file that uses JSX must have the `.``tsx` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typing React components is very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: These examples are pretty trivial. We will see more practical examples in the
    upcoming chapters when we start building the application. To learn more about
    TypeScript, it is recommended to check the TypeScript handbook at [https://www.typescriptlang.org/docs](https://www.typescriptlang.org/docs),
    which covers all these topics in much more detail.
  prefs: []
  type: TYPE_NORMAL
- en: ESLint setup overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Linting** is a process where linters analyze source code and detect any potential
    issues in the code base.'
  prefs: []
  type: TYPE_NORMAL
- en: We will be using **ESLint**, which is the most popular linting tool for JavaScript.
    It can be configured with different plugins and rules to adapt the linter to our
    application’s needs.
  prefs: []
  type: TYPE_NORMAL
- en: The ESLint configuration is defined in the `.eslintrc.js` file at the root of
    the project. We can add different rules, extend them with different plugins, and
    override which files to apply the rules to so that they suit our application’s
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we don’t want to lint every folder and file, so we can tell ESLint
    to ignore folders and files by defining them in the `.``eslintignore` file.
  prefs: []
  type: TYPE_NORMAL
- en: ESLint has great integration with editors and IDEs so that we can see any potential
    issues in the file while we are coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run our linter, we have defined the linting script in `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: By running `npm run lint`, we will lint every `.ts` and `.tsx` file in the `src`
    directory, and the linter will notify us about any potential issues.
  prefs: []
  type: TYPE_NORMAL
- en: Prettier setup overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`.prettierrc` file. It will also give us good feedback when something is wrong
    with the code. If it doesn’t auto-format, something is wrong with the code and
    it needs to be fixed.'
  prefs: []
  type: TYPE_NORMAL
- en: Prettier comes with a default configuration out of the box. We can override
    this by creating the `.prettierrc` file and modifying the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with ESLint, sometimes, there are files we do not want to auto-format.
    We can tell Prettier to ignore files and folders by adding them to the `.``prettierignore`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run Prettier, we have defined a couple of scripts in `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we can run `npm run format:check` to just check the formatting
    without trying to fix it. If we want to fix it, then we can run `npm run format:fix`,
    which will modify the files that need to be fixed.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-committing checks setup overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having static code analysis tools such as TypeScript, ESLint, and Prettier is
    great; we have configured them and can run individual scripts whenever we make
    some changes to ensure everything is in the best order.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are some drawbacks. Developers can forget to run all checks before
    committing to the repo, which can still bring problematic and inconsistent code
    to production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there is a solution that can fix this problem: whenever we try
    to commit to the repository, we want to run all checks in an automated way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the flow we want to have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Pre-commit code checking diagram ](img/B17297_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Pre-commit code checking diagram
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, whenever we attempt to commit to the repository, the `git pre-commit`
    hook will run and execute the scripts that will do the checking. If all the checks
    pass, the changes will be committed to the repository; otherwise, we will have
    to fix the issues and try again.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable this flow, we will use `husky` and `lint-staged`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`husky` is a tool that allows us to run git hooks. We want to run the pre-commit
    hook to run the checks before committing our changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lint-staged` is a tool that allows us to run those checks only on files that
    are in the staging area of Git. This improves the speed of code checking since
    doing that on the entire code base might be too slow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We already have these tools installed and configured, but if we didn’t, they
    could be installed using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we would need to enable Git hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we would need to create the pre-commit hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The Husky pre-commit hook will run lint-staged. Then, we would need to define
    what commands lint-staged should run inside the `lint-staged.config.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If we try to commit code that contains any violations, it will fail and stop
    us from committing the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we covered most of our setup, let’s look at the structure of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Project structure overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already mentioned, React is very flexible when it comes to project structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the benefits of having a good project structure are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Separation of concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier refactors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better reasoning about the code base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier for larger teams to work on the code base simultaneously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see what the feature-based project structure looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We will focus on the `src` folder only since, from now on, most of the code
    base lives there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the structure of our `src` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s analyze each of the folders, one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`components`: Contains all shared components that are used across the entire
    application.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`config`: Contains the application configuration files.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`features`: Contains all the feature-based modules. We will analyze this one
    in more detail in the following section.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`layouts`: Contains different layouts for the pages.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lib`: Contains configurations for different libraries that are used in our
    application.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pages`: Contains the pages of our application. This is where Next.js will
    look for pages in the filesystem-based routing.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`providers`: Contains all application providers. For example, if our application
    uses many different providers for styling, state, and so on, we can combine them
    here and export a single application provider with which we can wrap our `_app.tsx`
    to make all the providers available on all the pages.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`stores`: Contains all global state stores that are used in the application.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`testing`: Contains test-related mocks, helpers, utilities, and configurations.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`types`: Contains base TypeScript type definitions that are used across the
    application.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`utils`: Contains all shared utility functions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is nothing wrong with grouping files in folders based on their types.
    However, once the application starts to grow, it becomes more difficult to reason
    about and maintain the code base because there are too many files of a single
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To scale the application in the easiest and most maintainable way, we want to
    keep most of the application code inside the `features` folder, which should contain
    different feature-based things. Every `feature` folder should contain domain-specific
    code for a given feature. This will allow us to keep functionalities scoped to
    a feature and not mix its declarations with the shared things. This is much easier
    to maintain than a flat folder structure with many files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at one of our feature folders, which has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`api`: Contains the API request declarations and API hooks related to a specific
    feature. This makes our API layer and the UI layer separate and reusable.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`components`: Contains all components that are scoped to a specific feature.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`types`: This contains the TypeScript type definitions for a specific feature.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`index.ts`: This is the entry point of every feature. It behaves as the public
    API of the feature, and it should only export things that should be public for
    other parts of the application.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A feature might have other folders, such as `hooks`, `utils`, and others, depending
    on the needs of the feature. The only required file is the `index.ts` file, which
    acts as the public API of a feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to visualize the project structure with the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Project structure ](img/B17297_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Project structure
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, most of our application code will live within features.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more thing we can configure is enforcing developers to import features
    code via the `index.ts` file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We shouldn’t do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This will give us a better picture of which dependency is used where and where
    it comes from. Also, if the feature gets refactored, it doesn’t have to impact
    any external parts of the application where that component is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can constrain our code by having the following ESLint rule in the `.``eslintrc.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `no-restricted-imports` rule will add constraints to imports from other
    features by erroring if any violations in the preceding pattern are detected.
  prefs: []
  type: TYPE_NORMAL
- en: Things from a feature can only be consumed if they’re exported from the `index.ts`
    file of that feature. This will force us to explicitly make something in a feature
    publicly available.
  prefs: []
  type: TYPE_NORMAL
- en: If we decide to use features this way, we should also include the `import/no-cycle`
    rule to prevent cyclic dependencies where Feature A imports things from Feature
    B and vice versa. If this happens, that means something with the application design
    is wrong and it needs to be restructured.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned what our application structure will look like. Then,
    we focused on splitting the application by feature, which will allow our code
    base to scale well if we decide to add more features.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the basics of our Next.js application setup, which
    has been configured to work with TypeScript. Then, we learned about absolute imports,
    which will make it easier to move files around. We also overviewed ESLint and
    Prettier and made them static code analysis tools so that they can run checks
    before committing the changes to our repository by using lint-staged and Husky.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned what our project structure will look like. We learned that
    the best way is to group code by features. We also defined an ESLint rule to enforce
    importing code from a feature in a specific way and prevent cyclic dependencies
    to make the code base clean and easy to reason about.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will create the shared components that will act as the
    baseline for our application’s user interface.
  prefs: []
  type: TYPE_NORMAL
