<html><head></head><body>
		<div id="_idContainer040">
			<h1 id="_idParaDest-86"><em class="italic"><a id="_idTextAnchor090"/>Chapter 7</em>: Building a Full-Stack E-Commerce Application with Next.js and GraphQL</h1>
			<p>If you're reading this, this means you've reached the last chapter of this book that is focused on building web applications with React. In the preceding chapters, you've already used the core features of React, such as rendering components, state management with Context, and Hooks. You've learned how to add routing to your React application, or SSR with Next.js. Also, you know how to add testing to a React application with Jest and Enzyme. Let's make this experience full stack by adding GraphQL to the list of things you've learned about so far.</p>
			<p>In this chapter, you will not only build the frontend of an application, but also the backend. For this, GraphQL will be used, which can best be defined as a query language for APIs. Using mock data, you'll create a GraphQL server in Next.js that exposes a single endpoint for your React application. On the frontend side, this endpoint will be consumed using Apollo Client, which helps you handle sending requests to the server and state management for this data.</p>
			<p>In this chapter, the following topics will be covered:</p>
			<ul>
				<li>Creating a GraphQL server with Next.js</li>
				<li>Consuming GraphQL with Apollo Client</li>
				<li>Handling authentication in GraphQL</li>
			</ul>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor091"/>Project overview</h1>
			<p>In this chapter, we will create a full stack e-commerce application in Next.js that has a GraphQL server as a backend and consumes this server in React using Apollo Client. For the frontend, an initial application is available to get you started quickly.</p>
			<p>The build time is 3 hours.</p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor092"/>Getting started</h1>
			<p>The project that we'll create in this chapter builds upon an initial version that you can find on GitHub: <a href="https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter07-initial">https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter07-initial</a>. The complete source code can also be found on GitHub: <a href="https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter07">https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter07</a>.</p>
			<p>The initial project consists of a boilerplate application based on Next.js to get you started quickly. This application requires the installation of several dependencies, which you can do by running the following commands:</p>
			<p class="source-code">npm install &amp;&amp; npm run dev</p>
			<p>This command will install all the dependencies that are needed to run the React application with Next.js, such as <strong class="source-inline">react</strong>, <strong class="source-inline">next</strong>, and <strong class="source-inline">styled-components</strong>. Once the installation process has finished, both the GraphQL server and the React application will be started.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor093"/>Getting started with the initial React application</h2>
			<p>Since the React application<a id="_idIndexMarker423"/> is created with Next.js, it can be<a id="_idIndexMarker424"/> started with <strong class="source-inline">npm run dev</strong> and will be available at <strong class="source-inline">http://localhost:3000/</strong>. This initial application doesn't show any data as it still needs to be connected to the GraphQL server, which you'll do later in this chapter. At this point, the application will, therefore, just render a header with the title <strong class="bold">E-Commerce Store</strong> and a subheader as well, which looks something like this:</p>
			<p class="figure-caption">:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/Figure_7.1_B17390.jpg" alt="Figure 7.1 – The initial application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – The initial application</p>
			<p>The structure of this <a id="_idIndexMarker425"/>initial React application built with Next.js is as follows:</p>
			<p class="source-code">chapter-7-initial </p>
			<p class="source-code">  |- /node_modules </p>
			<p class="source-code">  |- /public </p>
			<p class="source-code">  |- /pages </p>
			<p class="source-code">     |- /api </p>
			<p class="source-code">        |- /hello.js </p>
			<p class="source-code">     |- /products </p>
			<p class="source-code">        |- /index.js </p>
			<p class="source-code">     |- /cart </p>
			<p class="source-code">        |- /index.js </p>
			<p class="source-code">     |- /login </p>
			<p class="source-code">        |- /index.js </p>
			<p class="source-code">     |- _app.js </p>
			<p class="source-code">     |- index.js </p>
			<p class="source-code">  |- /utils </p>
			<p class="source-code">     |- hooks.js </p>
			<p class="source-code">     |- authentication.js</p>
			<p class="source-code">  package.json </p>
			<p>In the <strong class="source-inline">pages</strong> directory, you'll find <a id="_idIndexMarker426"/>all the routes for this application. The route <strong class="source-inline">/</strong> is rendered by <strong class="source-inline">pages/index.js</strong>, and the routes <strong class="source-inline">/cart</strong>, <strong class="source-inline">/login</strong>, and <strong class="source-inline">/products</strong> are rendered by the <strong class="source-inline">.js</strong> files in those respective directories. All routes will be wrapped within <strong class="source-inline">pages/_app.js</strong>. In this file, the header for all pages is constructed for example. All routes will also contain a <strong class="source-inline">SubHeader</strong> component, with a <strong class="source-inline">Button</strong> to go back to the previous page or a <strong class="source-inline">Button</strong> to the <strong class="source-inline">Cart</strong> component. The <strong class="source-inline">utils</strong> directory contains two files with methods that you'll be needing later in this chapter. Also, this application will have a REST endpoint available <a id="_idIndexMarker427"/>under <strong class="source-inline">http://localhost:3000/api/hello</strong> coming from the <strong class="source-inline">pages/api/hello.js</strong> file.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor094"/>Building a full stack e-commerce application with React, Apollo, and GraphQL</h1>
			<p>In this section, you'll connect <a id="_idIndexMarker428"/>the React web application to the GraphQL server. A GraphQL Server on a Next.js API Route is used to create a single GraphQL endpoint that uses dynamic mock data as a source. Apollo Client is used by React to consume this endpoint and handle state management for your application.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor095"/>Creating a GraphQL server with Next.js</h2>
			<p>In <a href="B17390_03_Final_NM_ePub.xhtml#_idTextAnchor039"><em class="italic">Chapter 3</em></a>, <em class="italic">Building a Dynamic Project Management Board</em>, we already created a React application <a id="_idIndexMarker429"/>with<a id="_idIndexMarker430"/> Next.js, in which it was already mentioned that you can also use it to create API endpoints. By<a id="_idIndexMarker431"/> looking at the files in our directory for this chapter, you can see that the <strong class="source-inline">pages</strong> directory contains a directory called <strong class="source-inline">api</strong> with a file called <strong class="source-inline">hello.js</strong>. All the directories and files that you create in the <strong class="source-inline">pages</strong> directory become available as a route in the browser, but if you create them under the <strong class="source-inline">api</strong> directory in <strong class="source-inline">pages</strong>, they are called API routes. The <strong class="source-inline">hello.js</strong> file is such an API route, which is available <a id="_idIndexMarker432"/>under <strong class="source-inline">http://localhost:3000/api/hello</strong>. This endpoint returns a JSON blob with the following contents:</p>
			<p class="source-code">{"name":"John Doe"}</p>
			<p>This is a REST endpoint, which we've also explored in the previous chapters of this book. In this chapter, we'll be using a GraphQL endpoint instead, as GraphQL is a popular format for APIs that are used by web and mobile applications.</p>
			<p>GraphQL is <a id="_idIndexMarker433"/>best described as a query language for APIs and is defined as a convention for retrieving data from an API. Often, GraphQL APIs are compared to RESTful APIs, which is a well-known convention for sending HTTP requests that are dependent on multiple endpoints that <a id="_idIndexMarker434"/>will all return a separate data collection. As opposed to the well-known RESTful APIs, a GraphQL API will provide a single<a id="_idIndexMarker435"/> endpoint that lets you query and/or mutate data sources such as a database. You can query or mutate data by sending a document containing either a query or mutation operation to the GraphQL server. Whatever data is available can be found in the schema of the GraphQL server, which consists of types that define what data can be queried or mutated.</p>
			<p>Before creating the GraphQL endpoint, we need to set up the server in Next.js. Therefore, we need to install the following dependencies that are needed to do so:</p>
			<p class="source-code">npm install graphql @graphql-tools/schema @graphql-tools/mock express-graphql</p>
			<p>The <strong class="source-inline">graphql</strong> library is needed to use GraphQL in our application, while <strong class="source-inline">express-graphql</strong> is a tiny implementation of GraphQL Server for Node.js. Both <strong class="source-inline">@graphql-tools/schema</strong> and <strong class="source-inline">@graphql-tools/mock</strong> are open source libraries that helps you create GraphQL servers. We can also delete the <strong class="source-inline">pages/api/hello.js</strong> file as we won't be using this API route.</p>
			<p>To set up the GraphQL server, we must create a new file, <strong class="source-inline">pages/api/graphql/index.js</strong>, that will contain the single GraphQL endpoint for our application. We need to import <strong class="source-inline">graphqlHTTP</strong> to create the server. The schema for the GraphQL server is written under a variable called <strong class="source-inline">typeDefs</strong>:</p>
			<p class="source-code">import { graphqlHTTP } from 'express-graphql'; </p>
			<p class="source-code">import { makeExecutableSchema } from '@graphql-tools/schema'; </p>
			<p class="source-code">import { addMocksToSchema } from '@graphql-tools/mock';</p>
			<p class="source-code">const typeDefs = /* GraphQL */ ` </p>
			<p class="source-code">  type Product { </p>
			<p class="source-code">    id: Int! </p>
			<p class="source-code">    title: String! </p>
			<p class="source-code">    thumbnail: String! </p>
			<p class="source-code">    price: Float </p>
			<p class="source-code">  } </p>
			<p class="source-code">  type Query {</p>
			<p class="source-code">    product: Product</p>
			<p class="source-code">    products(limit: Int): [Product]</p>
			<p class="source-code">  }</p>
			<p class="source-code">`;</p>
			<p>Below <a id="_idIndexMarker436"/>the schema, we <a id="_idIndexMarker437"/>can initiate the GraphQL server using the <strong class="source-inline">graphqlHTTP</strong> instance and pass the <a id="_idIndexMarker438"/>schema to it. We also configure the server to create mocks for all the values in our schema. At the bottom of the file, we return the <strong class="source-inline">handler</strong> that is used by Next.js to make the GraphQL server <a id="_idIndexMarker439"/>available at the route <strong class="source-inline">http://localhost:3000/api/graphql</strong>:</p>
			<p class="source-code">// ...</p>
			<p class="source-code">const executableSchema = addMocksToSchema({ </p>
			<p class="source-code">  schema: makeExecutableSchema({ typeDefs, }), </p>
			<p class="source-code">}); </p>
			<p class="source-code">function runMiddleware(req, res, fn) { </p>
			<p class="source-code">  return new Promise((resolve, reject) =&gt; { </p>
			<p class="source-code">    fn(req, res, (result) =&gt; { </p>
			<p class="source-code">      if (result instanceof Error) { </p>
			<p class="source-code">        return reject(result); </p>
			<p class="source-code">      } </p>
			<p class="source-code">      return resolve(result); </p>
			<p class="source-code">    }); </p>
			<p class="source-code">  }); </p>
			<p class="source-code">} </p>
			<p class="source-code">async function handler(req, res) { </p>
			<p class="source-code">  const result = await runMiddleware( </p>
			<p class="source-code">    req, </p>
			<p class="source-code">    res, </p>
			<p class="source-code">    graphqlHTTP({ </p>
			<p class="source-code">      schema: executableSchema, </p>
			<p class="source-code">      graphiql: true, </p>
			<p class="source-code">    }), </p>
			<p class="source-code">  ); </p>
			<p class="source-code">  res.json(result); </p>
			<p class="source-code">} </p>
			<p class="source-code">export default handler;</p>
			<p>After making <a id="_idIndexMarker440"/>sure you've run the application again, the GraphQL API <a id="_idIndexMarker441"/>becomes available on <strong class="source-inline">http://localhost:3000/api/graphql</strong>. On this page in the browser, the GraphiQL playground <a id="_idIndexMarker442"/>will be displayed, and here is where you can use and explore the GraphQL server. </p>
			<p>With this <a id="_idIndexMarker443"/>playground, you can send queries and mutations to the GraphQL server, which you can type on the left-hand side of this page. The queries and mutations that you're able to send can be found in <strong class="bold">DOCS</strong> for this GraphQL server, which you can find by clicking on the green button labeled <strong class="bold">DOCS</strong>. This button will open an overview with all the possible return values of the GraphQL server.</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/Figure_7.2_B17390.jpg" alt="Figure 7.2 – Using the GraphiQL playground&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Using the GraphiQL playground</p>
			<p>Whenever you describe a query or mutation on the left-hand side of this page, the output<a id="_idIndexMarker444"/> that is returned by the server will be displayed on the right-hand side of the playground. The <a id="_idIndexMarker445"/>way a GraphQL query is constructed will determine the structure of the returned data <a id="_idIndexMarker446"/>since GraphQL follows the principle of <em class="italic">ask for what you need, get exactly that</em>. Since GraphQL queries always return predictable results, we can have a query that looks like this:</p>
			<p class="source-code">query {</p>
			<p class="source-code">  products {</p>
			<p class="source-code">    id</p>
			<p class="source-code">    title</p>
			<p class="source-code">    price</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>This will return an output that will follow the same structure of the query that's defined in the document that you sent to the GraphQL server. Sending this document with a query to the GraphQL server will return an array consisting of objects with product information, which has a limit of 10 products by default. The result will be returned in JSON format and<a id="_idIndexMarker447"/> will consist of different products every time <a id="_idIndexMarker448"/>you send the requests since the data is mocked by the GraphQL server. The response has the following format:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "data": {</p>
			<p class="source-code">    "products": [</p>
			<p class="source-code">      {</p>
			<p class="source-code">        "id": 85,</p>
			<p class="source-code">        "title": "Hello World",</p>
			<p class="source-code">        "price": 35.610056991945214</p>
			<p class="source-code">      },</p>
			<p class="source-code">      {</p>
			<p class="source-code">        "id": 24,</p>
			<p class="source-code">        "title": "Hello World",</p>
			<p class="source-code">        "price": 89.47561381959673</p>
			<p class="source-code">      }</p>
			<p class="source-code">    ]</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Applications <a id="_idIndexMarker449"/>using GraphQL are often fast and stable because they control the data they get, not the server. With GraphQL we can also create relations between certain fields in our data, for example, by adding a category field to our products. This is done by adding the following to the GraphQL schema in <strong class="source-inline">pages/api/graphql/index.js</strong>:</p>
			<p class="source-code">// ...</p>
			<p class="source-code">  const typeDefs = `</p>
			<p class="source-code">    type Product {</p>
			<p class="source-code">      id: Int!</p>
			<p class="source-code">      title: String!</p>
			<p class="source-code">      thumbnail: String!</p>
			<p class="source-code">      price: Float</p>
			<p class="source-code"><strong class="bold">+     category: Category</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code"><strong class="bold">+   type Category {</strong></p>
			<p class="source-code"><strong class="bold">+     id: Int!</strong></p>
			<p class="source-code"><strong class="bold">+     title: String!</strong></p>
			<p class="source-code"><strong class="bold">+   }</strong></p>
			<p class="source-code">    type Query {</p>
			<p class="source-code">      product: Product</p>
			<p class="source-code">      products(limit: Int): [Product]</p>
			<p class="source-code">    }</p>
			<p class="source-code">  `;</p>
			<p class="source-code">  // ...</p>
			<p>And<a id="_idIndexMarker450"/> we can also add <a id="_idIndexMarker451"/>a query for <strong class="source-inline">type Category</strong> by adding<a id="_idIndexMarker452"/> it to the schema:</p>
			<p class="source-code">// ...</p>
			<p class="source-code">  const typeDefs = `</p>
			<p class="source-code">    // ...</p>
			<p class="source-code">    type Category {</p>
			<p class="source-code">      id: Int!</p>
			<p class="source-code">      title: String!</p>
			<p class="source-code">    }</p>
			<p class="source-code">    type Query {</p>
			<p class="source-code">      product: Product</p>
			<p class="source-code">      products(limit: Int): [Product]</p>
			<p class="source-code"><strong class="bold">+     categories: [Category]</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">  `;</p>
			<p class="source-code">  // ...</p>
			<p>The products<a id="_idIndexMarker453"/> will now have a new field called <strong class="source-inline">category</strong>, but you can also query a list of categories on its own. As all the data for the GraphQL server<a id="_idIndexMarker454"/> is currently mocked, you don't need to connect a data source that makes the category information available. But we can specify how certain fields should be mocked, for example, by adding a thumbnail to our products. Therefore, we need to create a variable called <strong class="source-inline">mocks</strong> that sets the field thumbnail on the <strong class="source-inline">Product</strong> type to be a URL to <a href="https://picsum.photos">https://picsum.photos</a>. This is a free server for generating mock images on the fly:</p>
			<p class="source-code">  // ...</p>
			<p class="source-code"><strong class="bold">+ const mocks = {</strong></p>
			<p class="source-code"><strong class="bold">+     Product: () =&gt; ({</strong></p>
			<p class="source-code"><strong class="bold">+       thumbnail: () =&gt; 'https://picsum.photos/400/400'</strong></p>
			<p class="source-code"><strong class="bold">+     }),</strong></p>
			<p class="source-code"><strong class="bold">+   };</strong></p>
			<p class="source-code">   <strong class="bold"> const executableSchema = addMocksToSchema({ </strong></p>
			<p class="source-code"><strong class="bold">    schema: makeExecutableSchema({ typeDefs, }), </strong></p>
			<p class="source-code"><strong class="bold">+   mocks, </strong></p>
			<p class="source-code">  });</p>
			<p class="source-code">  // ...</p>
			<p>In addition<a id="_idIndexMarker455"/> to mocking the <strong class="source-inline">thumbnail</strong> field on the <strong class="source-inline">Product</strong> type, we also want to mock all the values of fields with the <strong class="source-inline">Int</strong> or <strong class="source-inline">Float</strong> type everywhere. Both fields are now often <a id="_idIndexMarker456"/>negative <a id="_idIndexMarker457"/>values, which is incorrect for its usage as an identifier or price. The <strong class="source-inline">Int</strong> type is used to define identifiers, while the <strong class="source-inline">Float</strong> type is used for prices. We can also mock these by adding the following:</p>
			<p class="source-code">  // ...</p>
			<p class="source-code">  const mocks = {</p>
			<p class="source-code"><strong class="bold">+   Int: () =&gt; Math.floor(Math.random() * 99) + 1,</strong></p>
			<p class="source-code"><strong class="bold">+   Float: () =&gt; (Math.random() * 99.0 + 1.0).toFixed(2),</strong></p>
			<p class="source-code">    Product: () =&gt; ({</p>
			<p class="source-code">      thumbnail: () =&gt; 'https://picsum.photos/400/400'</p>
			<p class="source-code">    }),</p>
			<p class="source-code">  };</p>
			<p class="source-code">  </p>
			<p class="source-code">    // ...</p>
			<p>You can <a id="_idIndexMarker458"/>check this by trying the following query that also requests a category and the thumbnail for the products:</p>
			<p class="source-code">query {</p>
			<p class="source-code">  products {</p>
			<p class="source-code">    id</p>
			<p class="source-code">    title</p>
			<p class="source-code">    price</p>
			<p class="source-code">    thumbnail</p>
			<p class="source-code">    category {</p>
			<p class="source-code">      id</p>
			<p class="source-code">      title</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>You can <a id="_idIndexMarker459"/>insert <a id="_idIndexMarker460"/>the preceding query in the GraphQL playground to get the response, which will look something like the following screenshot:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/Figure_7.3_B17390.jpg" alt="Figure 7.3 – Sending a query to the GraphQL server&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – Sending a query to the GraphQL server</p>
			<p>As the <a id="_idIndexMarker461"/>data is mocked by the GraphQL Server, the values will change every time you send a new request with<a id="_idIndexMarker462"/> this query. But <a id="_idIndexMarker463"/>you can get the same response by sending the query in the body of an HTTP request, from either the command line or from a React application with <strong class="source-inline">fetch</strong>. </p>
			<p>You can also use a library such as Apollo Client to make this more intuitive. This will be explained in the next section of this chapter, where you'll connect the GraphQL server to the React web application using Apollo and send documents to the server from your application.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor096"/>Consuming GraphQL with Apollo Client</h2>
			<p>With <a id="_idIndexMarker464"/>the GraphQL server in place, let's move on to the part where you make requests to this server from a React <a id="_idIndexMarker465"/>application. For this, you'll use Apollo packages that help you add an abstraction layer between your application and the server. That way, you don't have to worry about sending documents to the GraphQL endpoint yourself by using, for example, <strong class="source-inline">fetch</strong>, and can send documents directly from a component.</p>
			<h3>Setting up Apollo Client</h3>
			<p>As we <a id="_idIndexMarker466"/>mentioned previously, you can use Apollo to connect to the GraphQL server; for this, Apollo Client<a id="_idIndexMarker467"/> will be used. With Apollo Client, you can set up the connection with the server, handle queries and mutations, and enable caching for data that's been retrieved from the GraphQL server, among other things. You can add Apollo Client to your application by following these steps:</p>
			<ol>
				<li>To install Apollo Client and its related packages, you need to run the following command from the <strong class="source-inline">client</strong> directory where the React application is initialized:<p class="source-code"><strong class="bold">npm install @apollo/client</strong></p></li>
			</ol>
			<p>This will install Apollo Client as well as the other dependencies you need to use Apollo Client and GraphQL in your React application.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Normally, we also need to install <strong class="source-inline">graphql</strong> when installing Apollo Client, but this library is already present in our application.</p>
			<ol>
				<li value="2">These packages should be imported into the <strong class="source-inline">pages/_app.js</strong> file, where you want to create the Apollo Provider that wraps our application with the connection to the GraphQL server:<p class="source-code">  import { createGlobalStyle } from </p><p class="source-code">    'styled-components';</p><p class="source-code"><strong class="bold">+ import {</strong></p><p class="source-code"><strong class="bold">+   ApolloClient,</strong></p><p class="source-code"><strong class="bold">+   InMemoryCache,</strong></p><p class="source-code"><strong class="bold">+   ApolloProvider,</strong></p><p class="source-code"><strong class="bold">+ } from "@apollo/client";</strong></p><p class="source-code">  import Header from '../components/Header';</p><p class="source-code">  const GlobalStyle = createGlobalStyle` </p><p class="source-code">    // ...</p></li>
				<li>Now <a id="_idIndexMarker468"/>you can define<a id="_idIndexMarker469"/> the <strong class="source-inline">client</strong> constant using the <strong class="source-inline">ApolloClient</strong> class, and pass the location of the local GraphQL server to it:<p class="source-code">  // ...</p><p class="source-code"><strong class="bold">+ const client = new ApolloClient({</strong></p><p class="source-code"><strong class="bold">+   uri: 'http://localhost:3000/api/graphql/',</strong></p><p class="source-code"><strong class="bold">+   cache: new InMemoryCache()</strong></p><p class="source-code"><strong class="bold">+ });</strong></p><p class="source-code">  function MyApp({ Component, pageProps }) {</p><p class="source-code">    return (</p><p class="source-code">      // ...</p></li>
				<li>Within the <strong class="source-inline">return</strong> function for the <strong class="source-inline">MyApp</strong> component, you need to add <strong class="source-inline">ApolloProvider</strong> and pass the <strong class="source-inline">client</strong> you've just created as a prop:<p class="source-code">  // ...</p><p class="source-code">  function MyApp({ Component, pageProps }) {</p><p class="source-code">    return (</p><p class="source-code"><strong class="bold">-     &lt;&gt;</strong></p><p class="source-code"><strong class="bold">+     &lt;ApolloProvider client={client}&gt;</strong></p><p class="source-code">        &lt;GlobalStyle /&gt;</p><p class="source-code">        &lt;Header /&gt;</p><p class="source-code">        &lt;Component {...pageProps} /&gt;</p><p class="source-code"><strong class="bold">+     &lt;/ApolloProvider&gt;</strong></p><p class="source-code"><strong class="bold">-     &lt;/&gt;</strong></p><p class="source-code">    );</p><p class="source-code">  }</p><p class="source-code">  export default MyApp;</p></li>
			</ol>
			<p>After <a id="_idIndexMarker470"/>these steps, all the components <a id="_idIndexMarker471"/>that are nested within <strong class="source-inline">ApolloProvider</strong> can access this <strong class="source-inline">client</strong> and send documents with queries and/or mutations to the GraphQL server. In Next.js, all the page components are rendered under <strong class="source-inline">Component</strong> based on the route. The method for getting data from <strong class="source-inline">ApolloProvider</strong> is similar to the context API that we've used before.</p>
			<h3>Sending GraphQL queries with React</h3>
			<p>Apollo Client doesn't <a id="_idIndexMarker472"/>only export a Provider, but also methods to consume the value from this Provider. That way, you can easily get any value using the client that was added to the Provider. One of those methods is <strong class="source-inline">Query</strong>, which helps you to send a document containing a query to the GraphQL server without having to use a <strong class="source-inline">fetch</strong> function, for example.</p>
			<p>Since a <strong class="source-inline">Query</strong> component should always be nested inside an <strong class="source-inline">ApolloProvider</strong> component, they can be placed in any component that's been rendered within <strong class="source-inline">App</strong>. One of those is the <strong class="source-inline">Products</strong> component in <strong class="source-inline">pages/product/index.js</strong>. This component is being rendered for the <strong class="source-inline">/</strong> route and should display products that are available in the e-commerce store.</p>
			<p>To send a document from the <strong class="source-inline">Products</strong> component, follow these steps, which will guide you in the process of sending documents using <strong class="source-inline">react-apollo</strong>:</p>
			<ol>
				<li value="1">In the <strong class="source-inline">Products</strong> page component, you can import the <strong class="source-inline">useQuery</strong> Hook from <strong class="source-inline">@apollo/client</strong> and define a constant for the named <strong class="source-inline">getProducts</strong> query. Also, you <a id="_idIndexMarker473"/>need to import <strong class="source-inline">gql</strong> to use the GraphQL query language inside your React file as follows:<p class="source-code">  import styled from 'styled-components';</p><p class="source-code"><strong class="bold">+ import { useQuery, gql } from '@apollo/client'</strong>;</p><p class="source-code">  import SubHeader from '../../components/SubHeader';</p><p class="source-code">  import ProductItem from </p><p class="source-code">    '../../components/ProductItem';</p><p class="source-code">  // ...</p><p class="source-code"><strong class="bold">+ const GET_PRODUCTS = gql`</strong></p><p class="source-code"><strong class="bold">+   query getProducts {</strong></p><p class="source-code"><strong class="bold">+     products {</strong></p><p class="source-code"><strong class="bold">+       id</strong></p><p class="source-code"><strong class="bold">+       title</strong></p><p class="source-code"><strong class="bold">+       price</strong></p><p class="source-code"><strong class="bold">+       thumbnail</strong></p><p class="source-code"><strong class="bold">+     }</strong></p><p class="source-code"><strong class="bold">+   }</strong></p><p class="source-code"><strong class="bold">+ `;</strong></p><p class="source-code">  function Products() {</p><p class="source-code">    // ...</p></li>
				<li>The imported <strong class="source-inline">useQuery</strong> Hook can be called from <strong class="source-inline">Products</strong> and handle the data fetching process based on the query that you pass to it. In the same way as the context API, <strong class="source-inline">useQuery</strong> can consume the data from the Provider by returning a <strong class="source-inline">data</strong> variable. You can iterate over the <strong class="source-inline">products</strong> field from this object and <a id="_idIndexMarker474"/>return a list of <strong class="source-inline">ProductItem</strong> components already imported into this file. Also, a <strong class="source-inline">loading</strong> variable is returned that will be <strong class="source-inline">true</strong> when the GraphQL server hasn't returned the data yet:<p class="source-code">  // ...</p><p class="source-code">  function Products() {</p><p class="source-code"><strong class="bold">+   const { loading, data } = useQuery(GET_PRODUCTS);</strong></p><p class="source-code">    return (</p><p class="source-code">      &lt;&gt;</p><p class="source-code">        &lt;SubHeader title='Available products' goToCart /&gt;</p><p class="source-code"><strong class="bold">+       {loading ? (</strong></p><p class="source-code"><strong class="bold">+         &lt;span&gt;Loading...&lt;/span&gt;</strong></p><p class="source-code"><strong class="bold">+       ) : (</strong></p><p class="source-code">          &lt;ProductItemsWrapper&gt;</p><p class="source-code"><strong class="bold">+           {data &amp;&amp; data.products &amp;&amp; </strong></p><p class="source-code"><strong class="bold">             data.products.map((product) =&gt; (</strong></p><p class="source-code"><strong class="bold">+               &lt;ProductItem key={product.id} </strong></p><p class="source-code"><strong class="bold">                  data={product} /&gt;</strong></p><p class="source-code"><strong class="bold">+           ))}</strong></p><p class="source-code">          &lt;/ProductItemsWrapper&gt;</p><p class="source-code"><strong class="bold">+       )}</strong></p><p class="source-code">            &lt;/&gt;</p><p class="source-code">    );</p><p class="source-code">  };</p><p class="source-code">  export default Products;</p></li>
			</ol>
			<p>This will send a document with the <strong class="source-inline">GET_PRODUCTS</strong> query to the GraphQL server <a id="_idIndexMarker475"/>when your application mounts and subsequently display the product information in the list of <strong class="source-inline">ProductItem</strong> components. After adding the logic to retrieve the product information from the GraphQL server, your application will look similar to the following:</p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/Figure_7.4_B17390.jpg" alt="Figure 7.4 – Rendering products from GraphQL&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – Rendering products from GraphQL</p>
			<p>By clicking on the button in the top-right corner of this page, you'll navigate to the <strong class="source-inline">/cart</strong> route, which also needs to query data from the GraphQL server. As we don't have a query to retrieve the cart yet, we need to add it to the GraphQL server in <strong class="source-inline">pages/api/graphql/index.js</strong>.</p>
			<ol>
				<li value="3">We can create a mutable variable using <strong class="source-inline">let</strong> because there is no connected data source for the GraphQL server. This is an object that we want to update later, for example, when<a id="_idIndexMarker476"/> we add products to the cart:<p class="source-code">  import { graphqlHTTP } from 'express-graphql';</p><p class="source-code">  import { makeExecutableSchema } </p><p class="source-code">    from '@graphql-tools/schema'; </p><p class="source-code">  import { addMocksToSchema } from '@graphql-tools/mock';</p><p class="source-code"><strong class="bold">+ let cart = {</strong></p><p class="source-code"><strong class="bold">+   count: 0,</strong></p><p class="source-code"><strong class="bold">+   products: [],</strong></p><p class="source-code"><strong class="bold">+   complete: false,</strong></p><p class="source-code"><strong class="bold">+ };</strong></p><p class="source-code">  const typeDefs = `</p><p class="source-code">    // ... </p></li>
				<li>In the schema, we need to define a type for <strong class="source-inline">Cart</strong> and add this type to the list of queries for our GraphQL server:<p class="source-code">  // ...</p><p class="source-code">  const typeDefs = `</p><p class="source-code">    // ...</p><p class="source-code"><strong class="bold">+   type Cart {</strong></p><p class="source-code"><strong class="bold">+     count: Int</strong></p><p class="source-code"><strong class="bold">+     products: [Product]</strong></p><p class="source-code"><strong class="bold">+     complete: Boolean</strong></p><p class="source-code"><strong class="bold">+   }</strong></p><p class="source-code">    type Query {</p><p class="source-code">      product: Product</p><p class="source-code">      products(limit: Int): [Product]</p><p class="source-code">      categories: [Category]</p><p class="source-code"><strong class="bold">+     cart: Cart</strong></p><p class="source-code">    }</p><p class="source-code">  `;</p><p class="source-code">  const mocks = {</p><p class="source-code">    // ...</p></li>
				<li>In the <strong class="source-inline">pages/cart/index.js</strong> file, the components to render the products in the<a id="_idIndexMarker477"/> cart are already imported. We do have to import the <strong class="source-inline">useQuery</strong> Hook and <strong class="source-inline">gql</strong> from <strong class="source-inline">@apollo/client</strong> and create the query constant:<p class="source-code">  import styled from 'styled-components';</p><p class="source-code"><strong class="bold">+ import { useQuery, gql } from '@apollo/client';</strong></p><p class="source-code">  import { usePrice } from '../../utils/hooks';</p><p class="source-code">  import SubHeader from '../../components/SubHeader';</p><p class="source-code">  import ProductItem from </p><p class="source-code">    '../../components/ProductItem';</p><p class="source-code">  import Button from '../../components/Button';</p><p class="source-code">  // ...</p><p class="source-code"><strong class="bold">+ const GET_CART = gql`</strong></p><p class="source-code"><strong class="bold">+   query getCart {</strong></p><p class="source-code"><strong class="bold">+     cart {</strong></p><p class="source-code"><strong class="bold">+       products {</strong></p><p class="source-code"><strong class="bold">+         id</strong></p><p class="source-code"><strong class="bold">+         title</strong></p><p class="source-code"><strong class="bold">+         price</strong></p><p class="source-code"><strong class="bold">+         thumbnail</strong></p><p class="source-code"><strong class="bold">+       }</strong></p><p class="source-code"><strong class="bold">+     }</strong></p><p class="source-code"><strong class="bold">+   }</strong></p><p class="source-code"><strong class="bold">+ `;</strong></p><p class="source-code">  function Cart() {</p><p class="source-code">    // ...</p></li>
				<li>In the <strong class="source-inline">Cart</strong> component, we<a id="_idIndexMarker478"/> need to get the data that we want to display using the <strong class="source-inline">useQuery</strong> Hook. After getting the data, we can return a list of products that are added to the cart together with the button to check out:<p class="source-code">  // ...</p><p class="source-code">  function Cart() {</p><p class="source-code"><strong class="bold">+   const { loading, data } = useQuery(GET_CART);</strong></p><p class="source-code">    return (</p><p class="source-code">      &lt;&gt;</p><p class="source-code">        &lt;SubHeader title='Cart' /&gt;</p><p class="source-code"><strong class="bold">+       {loading ? (</strong></p><p class="source-code"><strong class="bold">+         &lt;span&gt;Loading...&lt;/span&gt;</strong></p><p class="source-code"><strong class="bold">+       ) : (</strong></p><p class="source-code">          &lt;CartWrapper&gt;</p><p class="source-code">            &lt;CartItemsWrapper&gt;</p><p class="source-code"><strong class="bold">+             {data &amp;&amp; data.cart.products &amp;&amp;</strong></p><p class="source-code"><strong class="bold">               data.cart.products.map((product) =&gt; (</strong></p><p class="source-code"><strong class="bold">+                &lt;ProductItem key={product.id} </strong></p><p class="source-code"><strong class="bold">                   data={product} /&gt;</strong></p><p class="source-code"><strong class="bold">+              ))}</strong></p><p class="source-code">            &lt;/CartItemsWrapper&gt;</p><p class="source-code"><strong class="bold">+           {data &amp;&amp; data.cart.products.length &gt; </strong></p><p class="source-code"><strong class="bold">              0 &amp;&amp; (</strong></p><p class="source-code"><strong class="bold">+             &lt;Button backgroundColor='royalBlue'&gt;</strong></p><p class="source-code"><strong class="bold">                Checkout</strong></p><p class="source-code"><strong class="bold">              &lt;/Button&gt;</strong></p><p class="source-code"><strong class="bold">+           )}</strong></p><p class="source-code">          &lt;/CartWrapper&gt;</p><p class="source-code"><strong class="bold">+       )}</strong></p><p class="source-code">      &lt;/&gt;</p><p class="source-code">    );</p><p class="source-code">  };</p><p class="source-code">export default Cart;</p></li>
				<li>This won't show<a id="_idIndexMarker479"/> any products yet as the cart is empty; the cart will be filled with products in the next section. However, let's proceed by adding a <strong class="source-inline">useQuery</strong> Hook to the button that navigates to the cart in <strong class="source-inline">SubHeader</strong>, which is rendered on routes other than <strong class="source-inline">/cart</strong> itself. A new file called <strong class="source-inline">CartButton.js</strong> can be created in the <strong class="source-inline">components</strong> directory. In this file, a <strong class="source-inline">useQuery</strong> Hook will return data from a query that requests the total number of products in<a id="_idIndexMarker480"/> the cart. Also, we can add a value to the <strong class="source-inline">Button</strong> component by adding the following code to this file:<p class="source-code">import { useQuery, gql } from '@apollo/client';</p><p class="source-code">import Button from './Button';</p><p class="source-code">export const GET_CART_TOTAL = gql`</p><p class="source-code">  query getCart {</p><p class="source-code">    cart {</p><p class="source-code">      count</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">`;</p><p class="source-code">function CartButton({ ...props }) {</p><p class="source-code">  const { loading, data } = useQuery(GET_CART_TOTAL);</p><p class="source-code">  return (</p><p class="source-code">    &lt;Button {...props}&gt;</p><p class="source-code">      {loading ? 'Cart' : `Cart (${data.cart.count})`}</p><p class="source-code">    &lt;/Button&gt;</p><p class="source-code">  );</p><p class="source-code">}</p><p class="source-code">export default CartButton;</p></li>
				<li>This <strong class="source-inline">CartButton</strong> component replaces <strong class="source-inline">Button</strong>, which is now being displayed with a placeholder <a id="_idIndexMarker481"/>count for the number of products in the cart, in the <strong class="source-inline">components/SubHeader.js</strong> file:<p class="source-code">  import styled from 'styled-components';</p><p class="source-code">  import { useRouter } from 'next/router';</p><p class="source-code"><strong class="bold">- import Button from './Button';</strong></p><p class="source-code"><strong class="bold">+ import CartButton from './CartButton';</strong></p><p class="source-code">  // ...</p><p class="source-code">  function SubHeader({ title, goToCart = false }) {</p><p class="source-code">    const router = useRouter();</p><p class="source-code">    return (</p><p class="source-code">      &lt;SubHeaderWrapper&gt;</p><p class="source-code">        // ...</p><p class="source-code">        {goToCart &amp;&amp; (</p><p class="source-code"><strong class="bold">-         &lt;Button onClick={() =&gt; </strong></p><p class="source-code"><strong class="bold">            router.push('/cart')}&gt;</strong></p><p class="source-code"><strong class="bold">-           Cart (0)</strong></p><p class="source-code"><strong class="bold">-         &lt;/Button&gt;</strong></p><p class="source-code">+           &lt;CartButton onClick={() =&gt; </p><p class="source-code">              router.push('/cart')} /&gt;</p><p class="source-code">        )}</p><p class="source-code">      &lt;/SubHeaderWrapper&gt;</p><p class="source-code">    );</p><p class="source-code">  }</p><p class="source-code">  export default SubHeader;</p></li>
			</ol>
			<p>With all the <a id="_idIndexMarker482"/>components that show either a product or cart information connected to the GraphQL server, you can proceed by adding mutations that add products to the cart. How to add mutations to the application and send document container mutations to the GraphQL server will be shown in the next part of this section.</p>
			<h3>Handling mutations in GraphQL</h3>
			<p>Mutating data <a id="_idIndexMarker483"/>makes using GraphQL more interesting because when data is mutated, some side effects should be executed. For example, when a user adds a product to their cart, the data for the cart should be updated throughout the component as well. This is quite easy when you're using Apollo Client since the Provider handles this in the same way as the context API.</p>
			<p>The GraphQL server <a id="_idIndexMarker484"/>now only has queries, but no operations as yet. Adding mutations is quite like how we've added queries to the schema before, but for the mutation, we also need to add resolvers. Resolvers are where the magic happens in GraphQL and where the schema is linked to logic to get the data, possibly from a data source. The addition of mutations is done in the <strong class="source-inline">pages/api/graphql/index.js</strong> file:</p>
			<ol>
				<li value="1">The first step is to add the mutation to add a product to the cart to the schema. This mutation takes <strong class="source-inline">productId</strong> as an argument. Also, we need to mock a list of types later:<p class="source-code">   // ...</p><p class="source-code">  const typeDefs =`</p><p class="source-code">  // ...</p><p class="source-code">  const typeDefs = gql`</p><p class="source-code">   // ...</p><p class="source-code">    type Cart {</p><p class="source-code">      total: Float</p><p class="source-code">      count: Int</p><p class="source-code">      products: [Product]</p><p class="source-code">      complete: Boolean</p><p class="source-code">    }</p><p class="source-code">    type Query {</p><p class="source-code">      product: Product</p><p class="source-code">      products(limit: Int): [Product]</p><p class="source-code">      categories: [Category]</p><p class="source-code">      cart: Cart</p><p class="source-code">    }</p><p class="source-code"><strong class="bold">+   type Mutation {</strong></p><p class="source-code"><strong class="bold">+     addToCart(productId: Int!): Cart</strong></p><p class="source-code"><strong class="bold">+   }</strong></p><p class="source-code">  `;</p><p class="source-code">  const mocks = {</p><p class="source-code">    // ...</p></li>
				<li>So far, all the <a id="_idIndexMarker485"/>values for our schema are mocked the GraphQLServer, but normally you would <a id="_idIndexMarker486"/>add resolvers for every type in the schema. These resolvers will contain the logic to get something from a data source. As we want to store the values for the <strong class="source-inline">Cart</strong> type in the <strong class="source-inline">cart</strong> object that is created at the top of this file, we need to add a resolver for the <strong class="source-inline">addToCart</strong> mutation:<p class="source-code">  // ...</p><p class="source-code"><strong class="bold">+ const resolvers = {</strong></p><p class="source-code"><strong class="bold">+   Mutation: {</strong></p><p class="source-code"><strong class="bold">+     addToCart: (_, { productId }) =&gt; {</strong></p><p class="source-code"><strong class="bold">+       c<a id="_idTextAnchor097"/>art = {</strong></p><p class="source-code"><strong class="bold">+         ...cart,</strong></p><p class="source-code"><strong class="bold">+         count: cart.count + 1,</strong></p><p class="source-code"><strong class="bold">+         products: [ </strong></p><p class="source-code"><strong class="bold">+           ...cart.products, </strong></p><p class="source-code"><strong class="bold">+           { </strong></p><p class="source-code"><strong class="bold">+             productId, </strong></p><p class="source-code"><strong class="bold">+             title: 'My product', </strong></p><p class="source-code"><strong class="bold">+             thumbnail: 'https://picsum.photos/400/400', </strong></p><p class="source-code"><strong class="bold">+             price: (Math.random() * 99.0 + 1.0).</strong></p><p class="source-code"><strong class="bold">                      toFixed(2), </strong></p><p class="source-code"><strong class="bold">+             category: null, </strong></p><p class="source-code"><strong class="bold">+           }, </strong></p><p class="source-code"><strong class="bold">+         ],</strong></p><p class="source-code"><strong class="bold">+       };</strong></p><p class="source-code"><strong class="bold">+       return cart;</strong></p><p class="source-code"><strong class="bold">+     },</strong></p><p class="source-code"><strong class="bold">+   },</strong></p><p class="source-code"><strong class="bold">+ };</strong></p><p class="source-code"><strong class="bold">  const executableSchema = addMocksToSchema({</strong></p><p class="source-code">    // ...</p></li>
				<li>When<a id="_idIndexMarker487"/> creating the <strong class="source-inline">graphqlHTTP</strong> instance, we need to pass the resolver that we created<a id="_idIndexMarker488"/> to it in order for our changes to become effective:<p class="source-code">  // ...</p><p class="source-code">    const executableSchema = addMocksToSchema({ </p><p class="source-code">    schema: makeExecutableSchema({ typeDefs, }),</p><p class="source-code">    mocks, </p><p class="source-code">+   resolvers,</p><p class="source-code">  });</p><p class="source-code">  // ...</p><p class="source-code">  export default handler;</p></li>
			</ol>
			<p>You can already test this mutation by trying it out on the GraphQL playground that's available at <strong class="source-inline">http://localhost:3000/api/graphql</strong>. Here, you'd need to add the mutation in the upper-left box of this page. The variable that you want to include in this mutation for <strong class="source-inline">productId</strong> must be placed in the bottom-left box of this page, called <strong class="bold">QUERY VARIABLES</strong>. This <a id="_idIndexMarker489"/>would result in the following output:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/Figure_7.5_B17390.jpg" alt="Figure 7.5 – Using mutations in the GraphiQL playground&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – Using mutations in the GraphiQL playground</p>
			<p>Every<a id="_idIndexMarker490"/> time you <a id="_idIndexMarker491"/>send a document to the GraphQL server with this mutation, a new product will be added to the list. Also, the <strong class="source-inline">count</strong> field will be incremented by <strong class="source-inline">1</strong>. But, when you want to retrieve this information using the query for the <strong class="source-inline">Cart</strong> type, the values will still be mocked by the GraphQL Server. To return the <strong class="source-inline">cart</strong> object instead, we also need to add a resolver for the query to get the cart information:</p>
			<p class="source-code">  // ...</p>
			<p class="source-code">  const resolvers = {</p>
			<p class="source-code"><strong class="bold">+   Query: {</strong></p>
			<p class="source-code"><strong class="bold">+     cart: () =&gt; cart,</strong></p>
			<p class="source-code"><strong class="bold">+   },</strong></p>
			<p class="source-code">    Mutation: {</p>
			<p class="source-code">      // ...</p>
			<p class="source-code">    },</p>
			<p class="source-code">  };</p>
			<p class="source-code">    const executableSchema = addMocksToSchema({</p>
			<p class="source-code">    // ...</p>
			<p>The <a id="_idIndexMarker492"/>response that will now be<a id="_idIndexMarker493"/> returned after using the <strong class="source-inline">addToCart</strong> mutation will reflect what you can retrieve with the cart query.</p>
			<p>To be able to use this mutation from our React application, we will need to make the following changes:</p>
			<ol>
				<li value="1">Currently, there's no button to add a product to the cart yet, so you can create a new file in the <strong class="source-inline">components</strong> directory and call this <strong class="source-inline">AddToCartButton.js</strong>. In this file, you can add the following code:<p class="source-code">import { useMutation, gql } from '@apollo/client';</p><p class="source-code">import Button from './Button';</p><p class="source-code">const ADD_TO_CART = gql`</p><p class="source-code">  mutation addToCart($productId: Int!) {</p><p class="source-code">    addToCart(productId: $productId) {</p><p class="source-code">      count</p><p class="source-code">      products {</p><p class="source-code">        id</p><p class="source-code">        title</p><p class="source-code">        price</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">`;</p><p class="source-code">function AddToCartButton({ productId }) {</p><p class="source-code">  const [addToCart, { data }] = </p><p class="source-code">    useMutation(ADD_TO_CART);</p><p class="source-code">  return (</p><p class="source-code">    &lt;Button</p><p class="source-code">      onClick={() =&gt;</p><p class="source-code">        !data &amp;&amp; addToCart({ variables: { productId } })</p><p class="source-code">      }</p><p class="source-code">    &gt;</p><p class="source-code">      {data ? 'Added to cart!' : 'Add to cart'}</p><p class="source-code">    &lt;/Button&gt;</p><p class="source-code">  );</p><p class="source-code">}</p><p class="source-code">export default AddToCartButton;</p></li>
			</ol>
			<p>This <a id="_idIndexMarker494"/>new <strong class="source-inline">AddToCartButton</strong> takes <strong class="source-inline">productId</strong> as a prop and has a <strong class="source-inline">useMutation</strong> Hook from <strong class="source-inline">@apollo/client</strong>, which uses the mutation we've created earlier. The<a id="_idIndexMarker495"/> output of <strong class="source-inline">Mutation</strong> is the actual function to call this mutation, which takes an object containing the inputs as an argument. Clicking on the <strong class="source-inline">Button</strong> component will execute the mutation and pass the <strong class="source-inline">productId</strong> to it.</p>
			<ol>
				<li value="2">This button should be displayed next to the products in the list on the <strong class="source-inline">/</strong> or <strong class="source-inline">/products</strong> routes, where<a id="_idIndexMarker496"/> each <a id="_idIndexMarker497"/>product is displayed in a <strong class="source-inline">ProductItem</strong> component. This means that you will need to import <strong class="source-inline">AddCartButton</strong> in <strong class="source-inline">components/ProductItem.js</strong> and pass a <strong class="source-inline">productId</strong> prop to it by using the following code:<p class="source-code">  import styled from 'styled-components';</p><p class="source-code">  import { usePrice } from '../utils/hooks';</p><p class="source-code"><strong class="bold">+ import AddToCartButton from './AddToCartButton';</strong></p><p class="source-code">  // ...</p><p class="source-code">  function ProductItem({ data }) {</p><p class="source-code">    const price = usePrice(data.price);</p><p class="source-code">    return (</p><p class="source-code">      &lt;ProductItemWrapper&gt;</p><p class="source-code">        {data.thumbnail &amp;&amp; &lt;Thumbnail </p><p class="source-code">          src={data.thumbnail} width={200} /&gt;}</p><p class="source-code">        &lt;Title&gt;{data.title}&lt;/Title&gt;</p><p class="source-code">        &lt;Price&gt;{price}&lt;/Price&gt;</p><p class="source-code"><strong class="bold">+       &lt;AddToCartButton productId={data.id} /&gt;</strong></p><p class="source-code">      &lt;/ProductItemWrapper&gt;</p><p class="source-code">    );</p><p class="source-code">  }</p><p class="source-code">  export default ProductItem;</p></li>
			</ol>
			<p>Now, when you open the React application in the browser, a button will be displayed next <a id="_idIndexMarker498"/>to the product titles. If you click this button, the mutation will be sent to the<a id="_idIndexMarker499"/> GraphQL server, and the product will be added to the cart. However, you won't see any changes to the button that displays <strong class="bold">Cart (0)</strong> in the <strong class="source-inline">SubHeader</strong> component. </p>
			<ol>
				<li value="3">Executing this query after sending the mutation can be done by setting a value for the <strong class="source-inline">refetchQueries</strong> option of the <strong class="source-inline">useMutation</strong> Hook in <strong class="source-inline">components/AddToCartButton.js</strong>. This option takes an array of objects with information<a id="_idIndexMarker500"/> about the queries that should be requested. In this case, it's only<a id="_idIndexMarker501"/> the <strong class="source-inline">GET_CART_TOTAL</strong> query, which is executed by <strong class="source-inline">CartButton</strong>. To do this, make the following changes:<p class="source-code">  import { useMutation, gql } from '@apollo/client';</p><p class="source-code">  import Button from './Button';</p><p class="source-code"><strong class="bold">+ import { GET_CART_TOTAL } from './CartButton';</strong></p><p class="source-code">  // ...</p><p class="source-code">  function AddToCartButton({ productId }) {</p><p class="source-code">    const [addToCart, { data }] = </p><p class="source-code">      useMutation(ADD_TO_CART);</p><p class="source-code">    return (</p><p class="source-code">      &lt;Button</p><p class="source-code">        onClick={() =&gt;</p><p class="source-code">          !data &amp;&amp; addToCart({</p><p class="source-code">            variables: { productId },</p><p class="source-code"><strong class="bold">+           refetchQueries: </strong></p><p class="source-code"><strong class="bold">              [{ query: GET_CART_TOTAL }],</strong></p><p class="source-code">          })</p><p class="source-code">        }</p><p class="source-code">      &gt;</p><p class="source-code">        {data ? 'Added to cart!' : 'Add to cart'}</p><p class="source-code">      &lt;/Button&gt;</p><p class="source-code">    );</p><p class="source-code">  }</p><p class="source-code">export default AddToCartButton;</p></li>
				<li>When you<a id="_idIndexMarker502"/> click on <strong class="source-inline">CartButton</strong>, we'll navigate to the <strong class="source-inline">/cart</strong> route, where the products that we have in the cart<a id="_idIndexMarker503"/> are displayed. On here, <strong class="source-inline">AddToCartButton</strong> is also rendered, as this is defined in the <strong class="source-inline">ProductItem</strong> component. Let's change this by going to the <strong class="source-inline">components/ProductItem.js</strong> file and add the following lines of code, which will render this button conditionally:<p class="source-code">  // ...</p><p class="source-code"><strong class="bold">- function ProductItem({ data }) {</strong></p><p class="source-code"><strong class="bold">+ function ProductItem({ data, addToCart = false }) {</strong></p><p class="source-code">    const price = usePrice(data.price);</p><p class="source-code">    return (</p><p class="source-code">      &lt;ProductItemWrapper&gt;</p><p class="source-code">        {data.thumbnail &amp;&amp; &lt;Thumbnail </p><p class="source-code">          src={data.thumbnail} width={200} /&gt;}</p><p class="source-code">        &lt;Title&gt;{data.title}&lt;/Title&gt;</p><p class="source-code">        &lt;Price&gt;{price}&lt;/Price&gt;</p><p class="source-code"><strong class="bold">-       &lt;AddToCartButton productId={data.id} /&gt;</strong></p><p class="source-code"><strong class="bold">+       {addToCart &amp;&amp; &lt;AddToCartButton </strong></p><p class="source-code"><strong class="bold">          productId={data.id} /&gt;}</strong></p><p class="source-code">      &lt;/ProductItemWrapper&gt;</p><p class="source-code">    );</p><p class="source-code">  }</p><p class="source-code">  export default ProductItem;</p></li>
				<li>From<a id="_idIndexMarker504"/> the <strong class="source-inline">Products</strong> page <a id="_idIndexMarker505"/>component, we need to pass the <strong class="source-inline">addToCart</strong> prop to render the button on this page:<p class="source-code">    // ...</p><p class="source-code">    return (</p><p class="source-code">      &lt;&gt;</p><p class="source-code">        &lt;SubHeader title='Available products' goToCart </p><p class="source-code">        /&gt;</p><p class="source-code">        {loading ? (</p><p class="source-code">          &lt;span&gt;Loading...&lt;/span&gt;</p><p class="source-code">        ) : (</p><p class="source-code">          &lt;ProductItemsWrapper&gt;</p><p class="source-code">            {data &amp;&amp; data.products &amp;&amp; </p><p class="source-code">              data.products.map((product) =&gt; (</p><p class="source-code">              &lt;ProductItem </p><p class="source-code">                key={product.id} </p><p class="source-code">                data={product} </p><p class="source-code"><strong class="bold">+               addToCart</strong></p><p class="source-code">              /&gt;</p><p class="source-code">            ))}</p><p class="source-code">          &lt;/ProductItemsWrapper&gt;</p><p class="source-code">        )}</p><p class="source-code">      &lt;/&gt;</p><p class="source-code">    );</p><p class="source-code">  };</p><p class="source-code">  export default Products;</p></li>
			</ol>
			<p>Now, every time you send a mutation in a <a id="_idIndexMarker506"/>document to the GraphQL server from this component, the <strong class="source-inline">GET_CART_TOTAL</strong> query will <a id="_idIndexMarker507"/>be sent as well. If the results have changed, the <strong class="source-inline">CartButton</strong> and <strong class="source-inline">Cart</strong> components will be rendered with this new output. Therefore, the <strong class="source-inline">CartButton</strong> component will be updated to display <strong class="bold">Cart (1)</strong> if you click on the <strong class="source-inline">AddToCartButton</strong> component:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/Figure_7.6_B17390.jpg" alt="Figure 7.6 – Updating the products in the cart&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – Updating the products in the cart</p>
			<p>In this section, we've learned how to set up Apollo Client and use it to send documents to the GraphQL server. In the next section of this chapter, we'll expand on this by handling authentication.</p>
			<h3>Handling authentication in GraphQL</h3>
			<p>Until <a id="_idIndexMarker508"/>now, we've created a <a id="_idIndexMarker509"/>GraphQL server that can be consumed by an application built with Next.js and React. Using queries and mutation, we can view a list of products and add them to a shopping cart. But we haven't added logic to check out that cart yet, which we'll do in this section.</p>
			<p>When users have added products to the cart, you want them to be able to check out; but before that, the users should be authenticated as you want to know who's buying the product.</p>
			<p>For authentication in frontend applications, most of the <a id="_idIndexMarker510"/>time, <strong class="bold">JSON Web Tokens </strong>(<strong class="bold">JWTs</strong>) are used, which are encrypted tokens that can easily be used to share user information with a backend. The JWT will be returned by the backend when the user is successfully authenticated and often, this token will have an expiration date. With every request that the user should be authenticated for, the token should be sent so that the backend server can determine whether the user is authenticated and allowed to take this action. Although JWTs can be used for authentication since they're encrypted, no private information should be added to them since the tokens should only be used to authenticate the user. Private information can only be sent from the server when a document with the correct JWT has been sent.</p>
			<p>Before we can add the checkout process to the React application, we need to make it possible for customers to authenticate. This consists of multiple steps:</p>
			<ol>
				<li value="1">We need to create a new type in the schema that defines a user and a mutation to log in a user, which we can do in <strong class="source-inline">pages/api/graphql/index.js</strong>:<p class="source-code">  // ...</p><p class="source-code">  const typeDefs = `</p><p class="source-code">    // ... </p><p class="source-code"><strong class="bold">+   type User {</strong></p><p class="source-code"><strong class="bold">+     username: String!</strong></p><p class="source-code"><strong class="bold">+     token: String!</strong></p><p class="source-code"><strong class="bold">+   }</strong></p><p class="source-code">    type Query {</p><p class="source-code">      product: Product</p><p class="source-code">      products(limit: Int): [Product]</p><p class="source-code">      categories: [Category]</p><p class="source-code">      cart: Cart</p><p class="source-code">    }</p><p class="source-code">    type Mutation {</p><p class="source-code">      addToCart(productId: Int!): Cart </p><p class="source-code"><strong class="bold">+     loginUser(user</strong><strong class="bold">name: String!, password: String!):</strong></p><p class="source-code"><strong class="bold">        User</strong></p><p class="source-code">    }</p><p class="source-code">  `;</p><p class="source-code">  // ...</p></li>
				<li>With<a id="_idIndexMarker511"/> the mutation <a id="_idIndexMarker512"/>defined in the schema, it can be added to the resolvers. In the <strong class="source-inline">utils/authentication.js</strong> file, a method to check the <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong> combination is already present. This method will return a valid token together with the username if that combination is correct. From this file, we also import a method to check whether<a id="_idIndexMarker513"/> a <a id="_idIndexMarker514"/>token is valid:<p class="source-code">  import { graphqlHTTP } from 'express-graphql'; </p><p class="source-code">  import { makeExecutableSchema } </p><p class="source-code">    from '@graphql-tools/schema'; </p><p class="source-code">  import { addMocksToSchema } from '@graphql-tools/mock';</p><p class="source-code"><strong class="bold">+ import { loginUser, isTokenValid } </strong></p><p class="source-code"><strong class="bold">    from '../../../utils/authentication';</strong></p><p class="source-code"> </p><p class="source-code">  // ...</p><p class="source-code">  const resolvers = {</p><p class="source-code">    Query: {</p><p class="source-code">      cart: () =&gt; cart,</p><p class="source-code">    },</p><p class="source-code">    Mutation: {</p><p class="source-code"><strong class="bold">+     loginUser: async (_, { username, password }) =&gt; </strong></p><p class="source-code"><strong class="bold">      {</strong></p><p class="source-code"><strong class="bold">+       const user = loginUser(username, password);</strong></p><p class="source-code"><strong class="bold">+       if (user) {</strong></p><p class="source-code"><strong class="bold">+         return user;</strong></p><p class="source-code"><strong class="bold">+       }</strong></p><p class="source-code"><strong class="bold">+     },</strong></p><p class="source-code">      // ...</p></li>
			</ol>
			<p>From the GraphiQL playground, we can now check whether this mutation is working by entering the username <strong class="source-inline">test</strong> and the password <strong class="source-inline">test</strong>:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/Figure_7.7_B17390.jpg" alt="Figure 7.7 – Creating a JWT with GraphQL&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7 – Creating a JWT with GraphQL</p>
			<ol>
				<li value="3">In the <strong class="source-inline">pages/login/index.js</strong> file, we can add the logic to use the input from a form to <a id="_idIndexMarker515"/>send a document with the <strong class="source-inline">loginUser</strong> mutation to the GraphQL server. The <a id="_idIndexMarker516"/><strong class="source-inline">Login</strong> page component is already using <strong class="source-inline">useState</strong> Hooks to control the value of the input fields for <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong>. The <strong class="source-inline">useMutation</strong> Hook can be imported from <strong class="source-inline">@apollo/client</strong>:<p class="source-code">  import { useState } from 'react';</p><p class="source-code"><strong class="bold">+ import { useMutation, gql } from '@apollo/client';</strong></p><p class="source-code">  // ...</p><p class="source-code"><strong class="bold">+ const LOGIN_USER = gql`</strong></p><p class="source-code"><strong class="bold">+   mutation loginUser($username: String!, $password:</strong></p><p class="source-code"><strong class="bold">      String!) {</strong></p><p class="source-code"><strong class="bold">+     loginUser(username: $username, </strong></p><p class="source-code"><strong class="bold">        password: $password) {</strong></p><p class="source-code"><strong class="bold">+       username</strong></p><p class="source-code"><strong class="bold">+       token</strong></p><p class="source-code"><strong class="bold">+     }</strong></p><p class="source-code"><strong class="bold">+   }</strong></p><p class="source-code"><strong class="bold">+ `;</strong></p><p class="source-code">  function Login() {</p><p class="source-code">    const [username, setUsername] = useState('');</p><p class="source-code">    const [password, setPassword] = useState('');</p><p class="source-code"><strong class="bold">+   const [loginUser, { data }] = </strong></p><p class="source-code"><strong class="bold">      useMutation(LOGIN_USER);</strong></p><p class="source-code">    return (</p><p class="source-code">      // ...</p></li>
				<li>After<a id="_idIndexMarker517"/> creating the <strong class="source-inline">loginUser</strong> function, this can be added to the <strong class="source-inline">onSubmit</strong> event from the <strong class="source-inline">form</strong> element, and<a id="_idIndexMarker518"/> the values for <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong> should be passed to this function as variables: <p class="source-code">  // ...</p><p class="source-code">  function Login() {</p><p class="source-code">    // ...</p><p class="source-code">    return (</p><p class="source-code">      &lt;&gt;</p><p class="source-code">        &lt;SubHeader title='Login' /&gt;</p><p class="source-code">        &lt;FormWrapper&gt;</p><p class="source-code">          &lt;form</p><p class="source-code"><strong class="bold">+           onSubmit={(e) =&gt; {</strong></p><p class="source-code"><strong class="bold">+             e.preventDefault();</strong></p><p class="source-code"><strong class="bold">+             loginUser({ variables: { username, </strong></p><p class="source-code"><strong class="bold">                password } });</strong></p><p class="source-code"><strong class="bold">+           }}</strong></p><p class="source-code">          &gt;</p><p class="source-code">            // ...</p></li>
				<li>Clicking <a id="_idIndexMarker519"/>the <strong class="source-inline">Button</strong> will send the document containing the <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong> values to the GraphQL server and, if successful, it returns the JWT for this user. This<a id="_idIndexMarker520"/> token should also be stored in the session storage so that it can be used later. Also, we want to redirect the user back to the home page when logged in. To do this, we need to import a <strong class="source-inline">useEffect</strong> Hook from React that watches for changes in the data. When the token is present, we can use a <strong class="source-inline">router</strong> object obtained from a <strong class="source-inline">useRouter</strong> Hook that we need to import from Next.js:<p class="source-code"><strong class="bold">- import { useState } from 'react';</strong></p><p class="source-code"><strong class="bold">+ import { useState, useEffect } from 'react';</strong></p><p class="source-code">  import { useMutation, gql } from '@apollo/client';</p><p class="source-code"><strong class="bold">+ import { useRouter } from 'next/router';</strong></p><p class="source-code">  // ...</p><p class="source-code">  function Login() {</p><p class="source-code">    const [username, setUsername] = useState('');</p><p class="source-code">    const [password, setPassword] = useState('');</p><p class="source-code">    const [loginUser, { data }] = </p><p class="source-code">      useMutation(LOGIN_USER);</p><p class="source-code"><strong class="bold">+   const router = useRouter();</strong></p><p class="source-code"><strong class="bold">+   useEffect(() =&gt; {</strong></p><p class="source-code"><strong class="bold">+     if (data &amp;&amp; data.loginUser &amp;&amp; </strong></p><p class="source-code"><strong class="bold">        data.loginUser.token) {</strong></p><p class="source-code"><strong class="bold">+       sessionStorage.setItem('token',</strong></p><p class="source-code"><strong class="bold">          data.loginUser.token);</strong></p><p class="source-code"><strong class="bold">+       router.push('/');</strong></p><p class="source-code"><strong class="bold">+     }</strong></p><p class="source-code"><strong class="bold">+   }, [data]);</strong></p><p class="source-code">  return (</p><p class="source-code">    // ...</p></li>
				<li>Every<a id="_idIndexMarker521"/> time a <a id="_idIndexMarker522"/>customer logs in via the <strong class="source-inline">/login</strong> route, the token is stored in the session storage in the browser. You can delete the token from the session storage by going to the <strong class="bold">Application</strong> tab in the <strong class="bold">Developer tools</strong> section of your browser; there, you'll find another tab called <strong class="bold">Session Storage</strong>. The customer's authentication details in the form of the JWT are now stored in the session storage. But for the customer to check out, this token should also be sent to the GraphQL server, along with every document for the server, to validate whether the user is authenticated or whether the token has expired. Therefore, you need to extend the setup of Apollo Client to also send the token when you make a request to the server and prefix it with <strong class="source-inline">Bearer</strong>, since this is how a JWT is recognized. This requires<a id="_idIndexMarker523"/> us to make multiple<a id="_idIndexMarker524"/> changes to <strong class="source-inline">pages/_app.js</strong>:<p class="source-code">  import { createGlobalStyle } from </p><p class="source-code">    'styled-components';</p><p class="source-code">  import {</p><p class="source-code">    ApolloClient,</p><p class="source-code">    InMemoryCache,</p><p class="source-code">    ApolloProvider,</p><p class="source-code"><strong class="bold">+   createHttpLink,</strong></p><p class="source-code">  } from '@apollo/client';</p><p class="source-code"><strong class="bold">+ import { setContext } from </strong></p><p class="source-code"><strong class="bold">    '@apollo/client/link/context';</strong></p><p class="source-code">  import Header from '../components/Header';</p><p class="source-code">  // ...</p><p class="source-code"><strong class="bold">+ const httpLink = createHttpLink({</strong></p><p class="source-code"><strong class="bold">+   uri: 'http://localhost:3000/api/graphql/',</strong></p><p class="source-code"><strong class="bold">+ });</strong></p><p class="source-code"><strong class="bold">+ const authLink = setContext((_, { headers }) =&gt; {</strong></p><p class="source-code"><strong class="bold">+   const token = sessionStorage.getItem('token');</strong></p><p class="source-code"><strong class="bold">+   return {</strong></p><p class="source-code"><strong class="bold">+     headers: {</strong></p><p class="source-code"><strong class="bold">+       ...headers,</strong></p><p class="source-code"><strong class="bold">+       authorization: token ? `Bearer ${token}` : '',</strong></p><p class="source-code"><strong class="bold">+     },</strong></p><p class="source-code"><strong class="bold">+   };</strong></p><p class="source-code"><strong class="bold">+ });</strong></p><p class="source-code">  const client = new ApolloClient({</p><p class="source-code"><strong class="bold">-   uri: 'http://localhost:3000/api/graphql/',</strong></p><p class="source-code"><strong class="bold">+   link: authLink.concat(httpLink),</strong></p><p class="source-code">    cache: new InMemoryCache(),</p><p class="source-code">  });</p><p class="source-code">  function MyApp({ Component, pageProps }) {</p><p class="source-code">    // ...</p></li>
			</ol>
			<p>On every request to the GraphQL server, the token will now be added to the headers of the HTTP request.</p>
			<ol>
				<li value="7">The GraphQL Server<a id="_idIndexMarker525"/> can <a id="_idIndexMarker526"/>now get the token from the HTTP request headers and store them in the context. The context is an object that you use to store data that you want to use in your resolvers, such as a JWT. This can be done in <strong class="source-inline">pages/api/graphql/index.js</strong>:<p class="source-code">  // ...</p><p class="source-code">    const executableSchema = addMocksToSchema({ </p><p class="source-code">    schema: makeExecutableSchema({ typeDefs, }), </p><p class="source-code">    mocks, </p><p class="source-code">    resolvers,</p><p class="source-code"><strong class="bold">+   context: ({ req }) =&gt; {</strong></p><p class="source-code"><strong class="bold">+     const token = req.headers.authorization || '';</strong></p><p class="source-code"> </p><p class="source-code">+     return { token }</p><p class="source-code">+   },</p><p class="source-code">  });</p><p class="source-code">  // ...</p></li>
			</ol>
			<p>Finally, we can also <a id="_idIndexMarker527"/>create a<a id="_idIndexMarker528"/> mutation to check out the items. This mutation should empty the card and, in a production environment, redirect the customer to a payment provider. In this scenario, we'll just empty the card and display a message that the order has been created successfully. To aid the checkout process, we need to make the following changes:</p>
			<ol>
				<li value="1">We require a new mutation in the schema of our GraphQL server in <strong class="source-inline">pages/api/graphql/index.js</strong>:<p class="source-code">    // ...</p><p class="source-code">    type Mutation {</p><p class="source-code">      addToCart(productId: Int!): Cart</p><p class="source-code">      loginUser(username: String!, password: String!):</p><p class="source-code">        User</p><p class="source-code"><strong class="bold">+     completeCart: Cart</strong></p><p class="source-code">    }</p><p class="source-code">  `;</p><p class="source-code">  const mocks = {</p><p class="source-code">    // ...</p></li>
				<li>With the mutation defined in the schema, it can be added to the resolvers. The mutation needs to<a id="_idIndexMarker529"/> clear the products in the cart, set the <strong class="source-inline">count</strong> field to <strong class="source-inline">0</strong>, and the <strong class="source-inline">complete</strong> field to <strong class="source-inline">true</strong>. Also, it should check whether the user has a token stored in<a id="_idIndexMarker530"/> the context and whether this is a valid token. To check the token, we can use the previously imported <strong class="source-inline">isTokenValid</strong> method:<p class="source-code">  // ...</p><p class="source-code">  const resolvers = {</p><p class="source-code">    Query: {</p><p class="source-code">      cart: () =&gt; cart,</p><p class="source-code">    },</p><p class="source-code">    Mutation: {</p><p class="source-code">      // ...</p><p class="source-code"><strong class="bold">+     completeCart: (_, {}, { token }) =&gt; {</strong></p><p class="source-code"><strong class="bold">+       if (token &amp;&amp; isTokenValid(token)) {</strong></p><p class="source-code"><strong class="bold">+         cart = {</strong></p><p class="source-code"><strong class="bold">+           count: 0,</strong></p><p class="source-code"><strong class="bold">+           products: [],</strong></p><p class="source-code"><strong class="bold">+           complete: true,</strong></p><p class="source-code"><strong class="bold">+         };</strong></p><p class="source-code"><strong class="bold">  </strong></p><p class="source-code"><strong class="bold">+         return cart;</strong></p><p class="source-code"><strong class="bold">+       }</strong></p><p class="source-code"><strong class="bold">+     },</strong></p><p class="source-code">    },</p><p class="source-code">  };</p><p class="source-code">  // ...</p></li>
				<li>In the <strong class="source-inline">pages/cart/index.js</strong> file, we need to import this Hook from <strong class="source-inline">@apollo/client</strong> and import <strong class="source-inline">useRouter</strong> from Next.js to redirect the user to the <strong class="source-inline">/login</strong> page if <a id="_idIndexMarker531"/>they are not authenticated. Also, the mutation to complete the<a id="_idIndexMarker532"/> cart can be added here:<p class="source-code">  import styled from 'styled-components';</p><p class="source-code">  import { </p><p class="source-code">    useQuery, </p><p class="source-code"><strong class="bold">+   useMutation, </strong></p><p class="source-code">    gql </p><p class="source-code">  } from '@apollo/client';</p><p class="source-code"><strong class="bold">+ import { useRouter } from 'next/router';</strong></p><p class="source-code">  // ...</p><p class="source-code"><strong class="bold">+ const COMPLETE_CART = gql`</strong></p><p class="source-code"><strong class="bold">+   mutation completeCart {</strong></p><p class="source-code"><strong class="bold">+     completeCart {</strong></p><p class="source-code"><strong class="bold">+       complete</strong></p><p class="source-code"><strong class="bold">+     }</strong></p><p class="source-code"><strong class="bold">+   }</strong></p><p class="source-code"><strong class="bold">+ `;</strong></p><p class="source-code">  function Cart() {</p><p class="source-code">    // ...</p></li>
			</ol>
			<p>In the return statement of the <strong class="source-inline">Cart</strong> component, there is a button to check out. This button will<a id="_idIndexMarker533"/> need to call a function created by a <strong class="source-inline">useMutation</strong> Hook that takes this new<a id="_idIndexMarker534"/> mutation. This mutation completes the cart and clears its content. If the user isn't authenticated, it should redirect the user to the <strong class="source-inline">/login</strong> page:</p>
			<p class="source-code">  // ...</p>
			<p class="source-code">  function Cart() {</p>
			<p class="source-code">    const { loading, data } = useQuery(GET_CART);</p>
			<p class="source-code"><strong class="bold">+   const [completeCard] = useMutation(COMPLETE_CART);</strong></p>
			<p class="source-code">    return (</p>
			<p class="source-code">      &lt;&gt;</p>
			<p class="source-code">        &lt;SubHeader title='Cart' /&gt;</p>
			<p class="source-code">        {loading ? (</p>
			<p class="source-code">          &lt;span&gt;Loading...&lt;/span&gt;</p>
			<p class="source-code">        ) : (</p>
			<p class="source-code">          &lt;CartWrapper&gt;</p>
			<p class="source-code">            // ...            </p>
			<p class="source-code">            {data &amp;&amp;</p>
			<p class="source-code">              data.cart.products.length &gt; 0 &amp;&amp; </p>
			<p class="source-code"><strong class="bold">+             sessionStorage.getItem('token') &amp;&amp; (</strong></p>
			<p class="source-code">                &lt;Button</p>
			<p class="source-code">                  backgroundColor='royalBlue'</p>
			<p class="source-code"><strong class="bold">+                 onClick={() =&gt; {</strong></p>
			<p class="source-code"><strong class="bold">+                   const isAuthenticated = </strong></p>
			<p class="source-code"><strong class="bold">                      sessionStorage.getItem(</strong></p>
			<p class="source-code"><strong class="bold">                        'token');</strong></p>
			<p class="source-code"><strong class="bold">+                   if (isAuthenticated) {</strong></p>
			<p class="source-code"><strong class="bold">+                     completeCard();</strong></p>
			<p class="source-code"><strong class="bold">+                   }</strong></p>
			<p class="source-code"><strong class="bold">+                 }}</strong></p>
			<p class="source-code">                &gt;</p>
			<p class="source-code">                  Checkout</p>
			<p class="source-code">                &lt;/Button&gt;</p>
			<p class="source-code">              )}</p>
			<p class="source-code">          &lt;/CartWrapper&gt;</p>
			<p class="source-code">        )}</p>
			<p class="source-code">      &lt;/&gt;</p>
			<p class="source-code">    );</p>
			<p class="source-code">  }</p>
			<p class="source-code">  export default Cart;</p>
			<p>This concludes<a id="_idIndexMarker535"/> the checkout <a id="_idIndexMarker536"/>process for the application and thereby this chapter, where you've used React and GraphQL to create an e-commerce application.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor098"/>Summary</h1>
			<p>In this chapter, you've created a full stack React application that uses GraphQL as its backend. Using a GraphQL server and mock data, the GraphQL server was created within Next.js using API routes. This GraphQL server takes queries and mutations to provide you with data and lets you mutate that data. This GraphQL server is used by a React application that uses Apollo Client to send and receive data from the server.</p>
			<p>That's it! You've completed the seventh chapter of this book and have already created seven web applications with React. By now, you should feel comfortable with React and its features and be ready to learn some more. In the next chapter, you'll be introduced to React Native and learn how you can use your React skills to build a mobile application by creating an animated game with React Native and Expo.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor099"/>Further reading</h1>
			<ul>
				<li>Next.js API routes: <a href="https://nextjs.org/docs/api-routes/introduction">https://nextjs.org/docs/api-routes/introduction</a></li>
				<li>GraphQL: <a href="https://graphql.org/learn/">https://graphql.org/learn/</a></li>
				<li>Apollo Client: <a href="https://www.apollographql.com/docs/react/">https://www.apollographql.com/docs/react/</a></li>
			</ul>
		</div>
	</body></html>