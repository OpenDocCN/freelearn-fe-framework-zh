- en: '23'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Responding to User Gestures
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the examples that you’ve implemented so far in this book have relied
    on user gestures. In traditional web applications, you mostly deal with mouse
    events. However, touchscreens rely on the user manipulating elements with their
    fingers, which is fundamentally different from the mouse.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, first, you’ll learn about scrolling. This is probably the most
    common gesture, besides touch. Then, you’ll learn about giving the user the appropriate
    level of feedback when they interact with your components. Finally, you’ll implement
    components that can be swiped.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter is to show you how the **gesture response system**
    inside React Native works and some of the ways in which this system is exposed
    via components.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling with your fingers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Giving touch feedback
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Swipeable and cancellable components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter2](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter25)3.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling with your fingers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scrolling in web applications is done by using the mouse pointer to drag the
    scrollbar back and forth or up and down, or by spinning the mouse wheel. This
    doesn’t work on mobile devices because there’s no mouse. Everything is controlled
    by gestures on the screen.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you want to scroll down, you use your thumb or index finger
    to pull the content up by physically moving your finger over the screen.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling like this is difficult to implement, but it gets more complicated.
    When you scroll on a mobile screen, the velocity of the dragging motion is taken
    into consideration. You drag the screen fast, then let go, and the screen continues
    to scroll based on how fast you moved your finger. You can also touch the screen
    while this is happening to stop it from scrolling.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, you don’t have to handle most of this stuff. The `ScrollView` component
    handles much of the scrolling complexity for you. In fact, you’ve already used
    the `ScrollView` component back in *Chapter 20*, *Rendering Item Lists*. The `ListView`
    component has `ScrollView` baked into it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: You can adjust the low-level parts of user interactions by implementing gesture
    life cycle methods. You’ll probably never need to do this, but if you’re interested,
    you can read about it at [https://reactnative.dev/docs/gesture-responder-system](https://reactnative.dev/docs/gesture-responder-system).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `ScrollView` outside of `ListView`. For example, if you’re just
    rendering arbitrary content such as text and other widgets: not a list, in other
    words: you can just wrap it in `<ScrollView>`. Here’s an example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `ScrollView` component isn’t of much use on its own: it’s there to wrap
    other components. It needs height in order to function correctly. Here’s what
    the scroll style looks like:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `height` property is set to `1`, but the stretch value of `alignSelf` allows
    the items to display properly. Here’s what the end result looks like:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19636_23_01.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.1: ScrollView'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: There’s a vertical scrollbar on the right-hand side of the screen as you drag
    the content down. If you run this example, you can play around with making various
    gestures, such as making content scroll on its own and then making it stop.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: When the user scrolls through content on the screen, they receive visual feedback.
    Users should also receive visual feedback when they touch certain elements on
    the screen.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Giving touch feedback
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The React Native examples you’ve worked with so far in this book have used plain
    text to act as buttons or links. In web applications, to make text look like something
    that can be clicked, you just wrap it with the appropriate link. There’s no link
    component in React Native, so you can style your text to look like a button.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The problem with trying to style text as links on mobile devices is that they’re
    too hard to press. Buttons provide a bigger target for fingers, and they’re easier
    to apply touch feedback on.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s style some text as a button. This is a great first step as it makes the
    text look touchable. But you also want to give visual feedback to the user when
    they start interacting with the button. React Native provides several components
    to help with this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '`TouchableOpacity`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TouchableHighlight`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pressable API
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But before diving into the code, let’s take a look at what these components
    look like visually when users interact with them, starting with `TouchableOpacity`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture 2](img/B19636_23_02.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.2: TouchableOpacity'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: There are three buttons being rendered here. The top one, labeled **Opacity**,
    is currently being pressed by the user. The opacity of the button is dimmed when
    pressed, which provides important visual feedback for the user.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what the **Highlight** button looks like when pressed:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture 3](img/B19636_23_03.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.3: TouchableHighlight'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Instead of changing the opacity when pressed, the `TouchableHighlight` component
    adds a highlight layer over the button. In this case, it’s highlighted using a
    more transparent version of the slate gray that’s being used in the font and border
    colors.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The last example of a button is provided by the `Pressable` component. The
    Pressable API has been introduced as a core component wrapper and allows different
    stages of press interaction on any of its defined children. With such components,
    we can handle `onPressIn`, `onPressOut` (which we explore in the next chapter),
    and `onLongPress` callbacks and implement any touchable feedback that we want.
    Let’s take a look at how `PressableButton` looks when we click on it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture 4](img/B19636_23_04.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.4: Pressable button'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'If we continue to keep our finger on this button, we get an `onLongPress` event
    and the button will update:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture 5](img/B19636_23_05.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.5: Long Pressed button'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: It doesn’t really matter which approach you use. The important thing is that
    you provide the appropriate touch feedback for your users as they interact with
    your buttons. In fact, you might want to use all the approaches in the same app,
    but for different things.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create an `OpacityButton` and `HighlightButton` component, which makes
    it easy to use the first two approaches:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here are the styles that were used to create this button:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now let’s take a look at the button based on the Pressable API:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s how you can put those buttons into the main app module:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that the `onPress` callbacks don’t actually do anything: we’re passing
    them because they’re a required property.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you’ll learn about providing feedback when the user
    swipes elements across the screen.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Using Swipeable and Cancellable components
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Part of what makes native mobile applications easier to use than mobile web
    applications is that they feel more intuitive. Using gestures, you can quickly
    get a handle on how things work. For example, swiping an element across the screen
    with your finger is a common gesture, but the gesture has to be discoverable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say that you’re using an app, and you’re not exactly sure what something
    on the screen does. So, you press down with your finger and try dragging the element.
    It starts to move. Unsure of what will happen, you lift your finger up, and the
    element moves back into place. You’ve just discovered how part of this application
    works.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll use the `Scrollable` component to implement **swipeable** and **cancellable**
    behaviors like this. You can create a somewhat generic component that allows the
    user to swipe text off the screen and, when that happens, call a callback function.
    Let’s look at the code that will render the swipeables before we look at the generic
    component itself:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will render 10 `<Swipeable>` components on the screen. Let’s see what
    this looks like:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture 6](img/B19636_23_06.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.6: Screen with Swipeable components'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you start to swipe one of these items to the left, it will move. Here’s
    what this looks like:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture 7](img/B19636_23_07.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23.7: Swiped component'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t swipe far enough, the gesture will be canceled and the item will
    move back into place, as expected. If you swipe it all the way, the item will
    be removed from the list completely and the items on the screen will fill the
    empty space.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at the `Swipeable` component itself:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The component accepts the `width` property to specify the width itself, `snapToInterval`
    to create paging-like behavior with swipe canceling, and handling the distance
    where we can call the `onSwipe` callback to remove items from the list.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable swipe to the left, we need to add a blank component beside the component
    with text in it. Here are the styles that are used for this component:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `swipeItemBlank` style has the same height as `swipeItem`, but nothing else.
    It’s invisible.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`swipeItemBlank`样式与`swipeItem`具有相同的高度，但除此之外没有其他内容。它是不可见的。'
- en: We have now covered all the topics in this chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了本章的所有主题。
- en: Summary
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we were introduced to the idea that gestures on native platforms
    make a significant difference compared to mobile web platforms. We started off
    by looking at the `ScrollView` component, and how it makes life much simpler by
    providing native scrolling behavior for wrapped components.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了在原生平台上的手势与移动网页平台相比有显著差异的观点。我们首先查看`ScrollView`组件，以及它如何通过为包装组件提供原生滚动行为来简化生活。
- en: Next, we spent some time implementing buttons with touch feedback. This is another
    area that’s tricky to get right on the mobile web. We learned how to use the `TouchableOpacity`,
    `TouchableHighlight`, and Pressable API components to do this.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们花了一些时间来实现带有触觉反馈的按钮。这是在移动网页上正确实现的一个棘手领域。我们学习了如何使用`TouchableOpacity`、`TouchableHighlight`和`Pressable`
    API组件来完成这项工作。
- en: Finally, we implemented a generic `Swipeable` component. Swiping is a common
    mobile pattern, and it allows the user to discover how things work without feeling
    intimidated.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了一个通用的`Swipeable`组件。滑动是一个常见的移动模式，它允许用户发现事物的工作方式，而不会感到害怕。
- en: In the next chapter, we’ll learn how to control animation using React Native.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用React Native控制动画。
