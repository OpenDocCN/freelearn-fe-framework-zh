- en: '*Chapter 8*: Building an Animated Game Using React Native and Expo'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the taglines for development with React is *"learn once, write anywhere,"*
    which is due to the existence of React Native. With React Native, you can write
    native mobile applications using JavaScript and React, and easily run and deploy
    these applications using a toolchain called **Expo**. The previous applications
    created in this book were all web applications, meaning that they will run in
    a browser. A downside of running applications in a browser is the lack of interaction
    when you click on a button or navigate to a different page. When building a mobile
    application that runs directly on a mobile phone, your users expect animations
    and gestures that make using the application easy and familiar. This is something
    that you'll focus on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you'll create a React Native application with add animations
    and gestures using the Animated API from React Native, a package called `GestureHandler`.
    Together, they make it possible for us to create applications that make the best
    use of a mobile's interaction methods, which is perfect for a game such as the
    *Higher/Lower* game.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this game, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up React Native with Expo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding gestures and animations to React Native
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced animations with Lottie
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be creating an animated *Higher/Lower* game build with
    React Native and Expo, which uses the Animated API to add basic animations, Lottie
    for advanced animations, and `GestureHandler` from Expo to handle native gestures.
  prefs: []
  type: TYPE_NORMAL
- en: The build time is 1.5 hours.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is using React Native version 0.64.3 and Expo SDK version 44\.
    As React Native and Expo are updated frequently, make sure that you're working
    with this version to ensure the patterns described in this chapter are behaving
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete source code for the project we build in this chapter can be found
    on GitHub: [https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter08).
    Also, the `winner.json` file that is needed in the final section of this chapter
    can be found at [https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter08-assets](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter08-assets).'
  prefs: []
  type: TYPE_NORMAL
- en: You need to have the Expo Go application installed on a mobile iOS or Android
    device to run the project on a physical device. Once you've downloaded the application,
    you need to create an Expo account to make the development process smoother. Make
    sure to store your account details somewhere safe, as you will need these later
    on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can install either Xcode or Android Studio on your computer
    to run the application on a virtual device:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For iOS**: Information on how to set up your local machine to run the iOS
    simulator can be found here: [https://docs.expo.io/workflow/ios-simulator/](https://docs.expo.io/workflow/ios-simulator/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For Android**: Information on how to set up your local machine to run the
    emulator from Android Studio can be found here: [https://docs.expo.io/workflow/android-studio-emulator/](https://docs.expo.io/workflow/android-studio-emulator/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It's *highly recommended* to use the Expo Client application to run the project
    from this chapter on a physical device. Receiving notifications is currently only
    supported on physical devices, and running the project on either the iOS simulator
    or Android Studio emulator will result in error messages.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating an animated game application with React Native and Expo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll build an animated game with React Native and Expo that
    runs directly on a mobile device. React Native allows you to use the same syntax
    and patterns you already know from React, as it's using the core React library.
    Also, Expo makes it possible to prevent having to install and configure Xcode
    (for iOS) or Android Studio to start creating native applications on your machine.
    Therefore, you can write applications for both the iOS and Android platforms from
    any machine.
  prefs: []
  type: TYPE_NORMAL
- en: Expo combines both React APIs and JavaScript APIs to the React Native development
    process, such as JSX components, Hooks, and native features such as camera access.
    Briefly, the Expo toolchain consists of multiple tools that help you with React
    Native, such as the Expo CLI, which allows you to create React Native projects
    from your terminal, with all the dependencies that you need to run React Native.
    With the Expo client, you can open these projects from iOS and Android mobile
    devices that are connected to your local network, and Expo SDK is a package that
    contains all the libraries that make it possible to run your application on multiple
    devices and platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up React Native with Expo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applications that we previously created in this book used Create React App or
    Next.js to set up a starter application. For React Native, a similar boilerplate
    is available, which is part of the Expo CLI and can be set up just as easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to globally install the Expo CLI with the following command, using
    `Yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Expo is using Yarn as its default package manager, but you can still use it
    with npm instead as weve done in the previous React chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will start the installation process, which can take some time, as it will
    install the Expo CLI with all its dependencies to help you develop mobile applications.
    After that, you will be able to create a new project using the `init` command
    from the Expo CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Expo will now create the project for you, but before that, it will ask you whether
    you want to create just a blank template, a blank template with TypeScript configuration,
    or a sample template with some example screens set up. For this chapter, you'll
    need to choose the first option. Expo automatically detects whether you have Yarn
    installed on your machine; if so, it will use Yarn to install the other dependencies
    that are needed to set up your computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your application will now be created, using the setting you''ve previously
    selected. This application can now be started by moving into the directory that
    was just created by Expo, using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start Expo and give you the ability to start your project from both
    the terminal and your browser. In the terminal, you will now see a QR code, which
    you can scan with the Expo application from your mobile device, or you can start
    either the iOS or Android emulator if you have Xcode or Android studio installed.
    Also, *Expo DevTools* will be opened in your browser after running the `start`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Expo DevTools when running Expo'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.01_B17390.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Expo DevTools when running Expo
  prefs: []
  type: TYPE_NORMAL
- en: On this page, you will see a sidebar on the left and the logs from your React
    Native application on the right. If you're using an Android device, you can scan
    the QR code directly from the Expo Go application. On iOS, you need to use your
    camera to scan the code, which will ask you to open the Expo client. Alternatively,
    the sidebar in Expo DevTools has buttons to start the iOS or Android emulator,
    for which you need to have either Xcode installed or Android Studio installed.
    Otherwise, you can also find a button to send a link to the application by email.
  prefs: []
  type: TYPE_NORMAL
- en: It doesn't matter whether you've opened the application using the emulator for
    iOS or Android, or from an iOS or Android device; the application at this point
    should be a white screen displaying **Open up App.js to start working on your
    app!**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you don't see the application, but a red screen displaying an error, you
    should make sure that you're running the correct version of React Native and Expo
    on your local machine and mobile device. These versions should be React Native
    version 0.64.3 and Expo version 44\. Using any other version can lead to errors,
    as the versions for React Native and Expo should be in sync.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project structure from this React Native application created with Expo
    is quite similar to the React projects you''ve created in the previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the `assets` directory, you can find the images that are used as the application
    icon on the home screen once you've installed this application on your mobile
    device and the image that will serve as the splash screen, which is displayed
    when you start the application. The `App.js` file is the actual entry point of
    your application, where you'll put code that will be rendered when the application
    mounts. Configurations for your application – for example, the App Store – are
    placed in `app.json`, while `babel.config.js` holds specific Babel configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Adding basic routing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For web applications created with React, we''ve used React Router for navigation,
    while with Next.js, the routing was already built in using the filesystem. For
    React Native, we''ll need a different routing library that supports both iOS and
    Android. The most popular library for this is `react-navigation`, which we can
    install from `Yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install the core library, but we need to extend our current Expo
    installation with dependencies that are needed for `react-navigation` by running
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To add routing to your React Native application, you will need to understand
    the difference between routing in a browser and a mobile application. History
    in React Native doesn't behave the same way as in a browser, where users can navigate
    to different pages by changing the URL in the browser and previously visited URLs
    are added to the browser history. Instead, you will need to keep track of transitions
    between pages yourself and store local history in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'With React Navigation, you can use multiple different navigators to help you
    do this, including a stack navigator and a tab navigator. The stack navigator
    behaves in a way that is very similar to a browser, as it stacks pages after transition
    on top of each other and lets you navigate using native gestures and animations
    for iOS and Android. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to install the library to use stack navigation and an additional
    library with navigation elements from `react-navigation`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From this library and the core library from `react-navigation`, we need to
    import the following to create a stack navigator in `App.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From the `App` component, we need to return this stack navigator, which also
    needs a component to return to the home screen. Therefore, we need to create a
    `Home` component in a new directory called `screens`. This component can be created
    in a file called `Home.js` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `App.js`, we need to import this `Home` component and set up the stack navigator
    by returning a `NavigationContainer` component from the `App` component. Inside
    this component, the stack navigator is created by the `Navigator` component from
    the `Stack` component, and the home screen is described in a `Stack.Screen` component.
    Also, the status bar for the mobile device is defined here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure that you still have Expo running from your terminal; otherwise, start
    it again with the yarn start command. The application on your mobile device or
    emulator should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The application with a stack navigator'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.02_B17390.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – The application with a stack navigator
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To reload the application in Expo Go, you can shake the device when you're using
    an iOS or Android phone. By shaking the device, a menu with an option to reload
    the application will appear. In this menu, you must also select to enable a *fast
    refresh* to refresh the application automatically when you make changes to the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: We've got our stack navigator with the first page set up, so let's add more
    pages and create buttons to navigate between them in the next part of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate between screens
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Navigating between screens in React Native also works a bit differently than
    in the browser, as again there are no URLs. Instead, you need to use the navigation
    object that is available as a prop from components that are rendered by the stack
    navigator, or by calling the `useNavigation` Hook from `react-navigation`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before learning how to navigate between screens, we need to add another screen
    to navigate to:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This screen can be added by creating a new component in a file called `Game.js`
    in the `screens` directory with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This component must be imported in `App.js` and added as a new screen to the
    stack navigator. Also, on the navigator, we need to set the default screen that
    must be displayed by setting the `initialRouteName` prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From the `Home` component in `screens/Home.js`, we can get the navigation object
    from the `useNavigation` Hook and create a button that will navigate to the `Game`
    screen when pressed. This is done by using the `navigate` method from the `navigation`
    object and passing it to the `onPress` prop of the `Button` component from React
    Native:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From the application, you can now move between the **Home** and **Game** screen
    by using the button that we just created or by using the button in the header.
    This header is automatically generated by react-navigation, but you can also customize
    this, which we''ll do in [*Chapter 9*](B17390_09_Final_NM_ePub.xhtml#_idTextAnchor109),
    *Building a Full-Stack Social Media Application with React Native and Expo*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Our application with basic routing](img/Figure_8.03_B17390.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Our application with basic routing
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we''ve added basic routing to our application, but we don''t
    have a game yet. In the `screens/Game.js` file, the logic for the *Higher/Lower*
    game can be added by using local state management, using the `useState` and `useEffect`
    Hooks. These Hooks work the same in React Native as they do in a React web application.
    Let''s add the game logic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import these Hooks from React in the Game component, next to the `Button` and
    `Alert` components from React Native. After importing them, we need to create
    a local state variable to store the user''s choice and create the randomized number
    and score for the game. Also, import the `useNavigation` Hook from `react-navigation`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `baseNumber` value is the number that starts the game with an initial random
    value between 1 and 100, created with a `Math` method from JavaScript. The score
    value also has a random number as a value, and this value is used to compare with
    `baseNumber`. The `choice` local state variable is used to store the choice of
    the user if a score is either higher or lower than `baseNumber`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to make a choice, we need to add two `Button` components that set
    the value for a choice to be higher or lower, depending on which button you''ve
    pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From an `useEffect` Hook, we can compare the values for `baseNumber` and `score`
    and, based on the value choice, show an alert. Depending on the choice, the user
    sees an `Alert` component displayed with a message saying whether they''ve won
    or not, and the score. Next to displaying the alert, the values for `baseNumber`,
    `score`, and `choice` the navigation object will be used to navigate back to the
    previous page. This will reset the `Game` component as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You're now able to play the game and choose whether you think the score will
    be higher or lower than the displayed `baseNumber`. But we haven't added any styling
    yet, which we'll do in the next part of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Styling in React Native
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might have seen in the previous components that we changed or added to
    the project that we used a variable called `StyleSheet`. Using this variable from
    React Native, we can create an object of styles, which we can attach to React
    Native components by passing it as a prop called `style`. We''ve already used
    this to style the components with a style called `container`, but let''s make
    some changes to also add styling to the other components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `screens/Home.js`, we need to replace the `Button` component with a `TouchableHighlight`
    component, as `Button` components in React Native are hard to style. This `TouchableHighlight`
    component is an element that can be pressed, and it gives the user feedback by
    getting highlighted when pressed. Inside this component, a `Text` component must
    be added to display the label for the button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `TouchableHighlight` and `Text` components use the `button` and `buttonText`
    styles from the `styles` object, which we need to add to the `create` method of
    `StyleSheet` at the bottom of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating styles with React Native means you need to use *camelCase* notation
    instead of *kebab-case* as we're used to with CSS – for example, `background-color`
    becomes `backgroundColor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to make styling additions to the buttons on the `Game` screen
    by opening the `screens/Game.js` file. In this file, we again need to replace
    the `Button` components from React Native with a `TouchableHighlight` component
    with an inner `Text`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `styles` object must have the new `baseNumber`, `button`, and `buttonText`
    styles, which we can add at the bottom of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, both buttons will now have the same white background. We can change
    this by adding additional styling to them. The `style` prop on React Native components
    can also take an array of styling objects instead of just a single object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These `buttonGreen` and `buttonRed` objects must also be added to the styling
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With these additions, the application is now styled, which makes it more appealing
    to play. We''ve used the `StyleSheet` object from React Native to apply this styling,
    making your application look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – The styled React Native application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.04_B17390.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – The styled React Native application
  prefs: []
  type: TYPE_NORMAL
- en: Mobile games often have flashy animations that make the user want to keep playing
    and make the game more interactive. The *Higher/Lower* game that is already functioning
    uses no animations so far and just has some transitions that have been built in
    with React Navigation. In the next section, you'll be adding animations and gestures
    to the application, which will improve the game interface and make the user feel
    more comfortable while playing the game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding gestures and animations in React Native
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are multiple ways to use animations in React Native, and one of those
    is to use the Animated API, which can be found at the core of React Native. With
    the Animated API, you can create animations for the `View`, `Text`, `Image`, and
    `ScrollView` components from React Native by default. Alternatively, you can use
    the `createAnimatedComponent` method to create your own.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic animation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the simplest animations you can add is fading an element in or out by
    changing the value for the opacity of that element. In the *Higher/Lower* game
    you created previously, the buttons were styled. These colors already show a small
    transition, since you''re using the `TouchableHighlight` element to create the
    button. However, it''s possible to add a custom transition to this by using the
    Animated API. To add an animation, the following code blocks must be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new directory called `components`, which will hold all
    our reusable `components`. In this directory, create a file called `AnimatedButton.js`,
    which will contain the following code to construct the new component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following styling to the bottom of this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, this component is comparable to the buttons we have in `screens/Game.js`.
    Therefore, we can remove the `TouchableHighlight` buttons in that file and replace
    them with the `AnimatedButton` component. Make sure to pass the correct values
    for `action` and `onPress` as a prop to this component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'No visible changes are present if you look at the application on your mobile
    device or the emulator on your computer, since we need to change the clickable
    element from a `TouchableHighlight` element to a `TouchableWithoutFeedback` element
    first. That way, the default transition with the highlight will be gone, and we
    can replace this with our own effect. The `TouchableWithoutFeedback` element can
    be imported from React Native in `components/AnimatedButton.js` and should be
    placed around a `View` element, which will hold the default styling for the button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create a transition when we click on the button, we can use the Animated
    API. We''ll use this to change the opacity of the `AnimatedButton` component from
    the moment it''s pressed. A new instance of the Animated API starts by specifying
    a value that should be changed during the animation that we created with the Animated
    API. This value should be changeable by the Animated API in your entire component,
    so you can add this value to the top of the component. This value should be created
    with a `useRef` Hook, since you want this value to be changeable later on. Also,
    we need to import `Animated` from React Native:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This value can now be changed by the Animated API using any of the three animations
    types that are built in. These are `decay`, `spring`, and `timing`, where you''ll
    be using the `timing` method from the Animated API to change the animated value
    within a specified time frame. The Animated API can be triggered from the `onPress`
    event on `TouchableWithoutFeedback` and calls the `onPress` prop after finishing
    the animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `timing` method takes the `opacity` that you've specified at the top of
    your component and an object with the configuration for the Animated API. We need
    to take the current value of the opacity, as this is a `ref` value. One of the
    fields is `toValue`, which will become the value for `opacity` when the animation
    has ended. The other field is for the field's duration, which specifies how long
    the animation should last.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The other built-in animation types next to `timing` are `decay` and `spring`.
    Whereas the `timing` method changes gradually over time, the `decay` type has
    animations that change fast in the beginning and gradually slow down until the
    end of the animation. With `spring`, you can create animations that move a little
    outside of their edges at the end of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `View` component can be replaced by an `Animated.View` component. This
    component uses the `opacity` variable created by the `useRef` Hook to set its
    opacity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, when you press any of the buttons on the `Game` screen, they will fade
    out, since the opacity transitions from `1` to `0.2` in 400 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Something else you can do to make the animation appear smoother is to add an
    `easing` field to the `Animated` object. The value for this field comes from the
    `Easing` module, which can be imported from React Native. The `Easing` module
    has three standard functions: `linear`, `quad`, and `cubic`. Here, the `linear`
    function can be used for smoother timing animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With this last change, the animation is complete, and the game interface already
    feels smoother, since the buttons are being highlighted using our own custom animation.
    In the next part of this section, we will combine some of these animations to
    make the user experience for this game even more advanced.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can also combine animations – for example, with the `parallel` method –
    from the Animated API. This method will start the animations that are specified
    within the same moment and take an array of animations as its value. Next to the
    `parallel` function, three other functions help you with animation composition.
    These functions are `delay`, `sequence`, and `stagger`, which can also be used
    in combination with each other. The `delay` function starts any animation after
    a predefined delay, the `sequence` function starts animations in the order you've
    specified and waits until an animation is resolved before starting another one,
    and the `stagger` function can start animations both in order and parallel with
    specified delays in between.
  prefs: []
  type: TYPE_NORMAL
- en: Handling gestures with Expo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gestures are an important feature of mobile applications, as they make the difference
    between a mediocre and a good mobile application. In the *Higher/Lower* game you've
    created, several gestures can be added to make the game more appealing.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, you used the `TouchableHighlight` element, which gives the user
    feedback after they press it by changing it. Another element that you could have
    used for this was the `TouchableOpacity` element. These gestures give the user
    an impression of what happens when they make decisions within your application,
    leading to improved user experience. These gestures can be customized and added
    to other elements as well, making it possible to have custom touchable elements
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: For this, you can use a package called `react-native-gesture-handler`, which
    helps you access native gestures on every platform. All of these gestures will
    be run in the native thread, which means you can add complex gesture logic without
    having to deal with the performance limitations of React Native's gesture responder
    system. Some of the gestures it supports include *tap*, *rotate*, *drag*, and
    *pan*, and a *long press*. In the previous section, we installed this package,
    as it's a requirement for `react-navigation`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can also use gestures directly from React Native, without having to use
    an additional package. However, the gesture responder system that React Native
    currently uses doesn't run in the native thread. Not only does this limit the
    possibilities of creating and customizing gestures, but you can also run into
    cross-platform or performance problems. Therefore, it's advised that you use the
    `react-native-gesture-handler` package, but this isn't necessary for using gestures
    in React Native.
  prefs: []
  type: TYPE_NORMAL
- en: 'The gesture we will implement is a *long press* gesture, which will be added
    to the start button in our `Home` screen, located at `screens/Home.js`. Here,
    we''ll use the `TapGestureHandler` element from `react-native-gesture-handler`,
    which runs in the native thread, instead of the `TouchableWithoutFeedback` element
    from React Native, which uses the gesture responder system. To implement this,
    we need to do the following this becomes number 2 please make sure the rest of
    the numbers are updated accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install using Expo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import `TapGestureHandler` and `State` from `react-native-gesture-handler`,
    next to `View` and `Alert` from React Native. The `TouchableHighlight` import
    can be removed, as this will be replaced:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can replace the `TouchableHighlight` component with `TapGestureHandler`,
    and we need to put a `View` component inside it, to which we apply the styling.
    `TapGestureHandler` doesn''t take an `onPress` prop but an `onHandlerStateChange`
    prop instead, to which we pass the new `on` `Tap` function. In this function,
    we need to check whether the state of the tap event is active. For this, you need
    to know that the tap event goes through different states: `UNDETERMINED`, `FAILED`,
    `BEGAN`, `CANCELLED`, `ACTIVE`, and `END`. The naming of these states is pretty
    straightforward, and usually, the handler will have the following flow: `UNDETERMINED`
    > `BEGAN` > `ACTIVE` > `END` > `UNDETERMINED`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you now press the start button on the `Home` screen, you will receive the
    message that you need to long press the button to start the game. To add this
    long press gesture, we need to add a `LongPressGestureHandler` component inside
    the `TapGestureHandler` component. Also, we need to create a function that can
    be called by the `LongPressGestureHandler` component, which navigates us to the
    `Game` screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `TapGestureHandler` the newly imported `LongPressGestureHandler`
    component should be placed. This component takes the function to navigate to the
    game, and a prop to set the minimal duration of the long press. If you dont set
    this prop, the minimal duration will be 500ms by default::'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this latest change, you can only start the game by long pressing the **start**
    button on the **Home** screen. These gestures can be customized even more, since
    you can use composition to have multiple tap events that respond to each other.
    By creating so-called **cross-handler interactions**, you can create a touchable
    element that supports a *double-tap* gesture and a *long-press* gesture.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will show you how to handle even more advanced animations,
    such as displaying animated graphics when any of two players win. For this, we'll
    use the Lottie package, since it supports more functionalities than the built-in
    Animated API.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced animations with Lottie
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The React Native Animated API is great for building simple animations, but building
    more advanced animations can be harder. Luckily, Lottie offers a solution for
    creating advanced animations in React Native by making it possible for us to render
    After Effects animations in real time for iOS, Android, and React Native.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When using Lottie, you don't have to create these After Effects animations yourself;
    there's a whole library full of resources that you can customize and use in your
    project. This library is called `LottieFiles` and is available at [https://lottiefiles.com/](https://lottiefiles.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''ve already added animations to the buttons of our game, a nice place
    to add more advanced animations would be the message that is displayed when you
    win or lose the game. This message can be displayed on a screen instead of an
    alert, where a trophy can be displayed if the user won. Let''s do this now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with Lottie, run the following command, which will install Lottie
    to our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the installation is completed, we can create a new screen component called
    `screens/Result.js` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add this screen to the stack navigator so that it can be used in the navigation
    for this mobile application by importing it in App.js. Also, the navigation element
    `HeaderBackButton` should be imported:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also imported the `HeaderBackButton` component from React Navigation when
    adding the `Result` screen, as we also want to change the `Home` screen instead
    of the `Game` screen so that the user can start a new game after finishing it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From the `Game` screen in `screens/Game.js`, we can navigate the user to the
    `Result` screen after playing the game and also pass a param to this screen. Using
    this param, a message can be displayed with the result of the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From the `Result` screen in the `screens/Result.js` file, we can import `LottieView`
    from `lottie-react-native` and get the param from the `route` object using the
    `useRoute` Hook from React Navigation. Using this param, we can return a message
    if the user has won or lost:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The imported `Lottie` component can render any Lottie file that you either
    create yourself or that is downloaded from the `LottieFiles` library. In the GitHub
    repository for this chapter, you will find a Lottie file that can be used in this
    project called `winner.json`. This file must be placed in the `assets` directory
    and can be rendered by the `LottieView` component when you add it to the source,
    and the `width` and `height` values of the animation can be set by passing a `style`
    object. Also, you should add the `autoPlay` prop to start the animation once the
    component renders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As a finishing touch, we can add some styling to the message that is displayed
    on this screen and make it bigger:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the `Result` screen component receives the `winner` param with the `true`
    value, instead of the board, the user will see the trophy animation being rendered.
    An example of how this will look when you''re running the application with the
    iOS simulator or on an iOS device can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – The Lottie animation after winning a game'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.05_B17390.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – The Lottie animation after winning a game
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you find the speed of this animation too fast, you can reduce it by combining
    the Animated API with Lottie. The `LottieView` component can take a `progress`
    prop that determines the speed of the animation. When passing a value that is
    created by the Animated API, you can tweak the speed of the animation as per your
    preference.
  prefs: []
  type: TYPE_NORMAL
- en: By adding this animation using Lottie, we've created a mobile application with
    an animated game that you can play for hours.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've created a React Native application with Expo. React Native
    uses the same principles as React and can be used to create mobile applications.
    We've added basic routing with React Navigation, based on stack navigation. We've
    also added basic and more complex gestures to the game, which run in the native
    thread thanks to the `react-native-gesture-handler` package. Finally, animations
    were created using the React Native Animated API and Lottie, which is available
    from the Expo CLI.
  prefs: []
  type: TYPE_NORMAL
- en: The project that we'll create in the next chapter will explore handling data
    in React Native. We'll also learn about the differences in styling between iOS
    and Android.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Expo: [https://docs.expo.io/](https://docs.expo.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Various Lottie files: [https://lottiefiles.com/](https://lottiefiles.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More on the Animated API: [https://facebook.github.io/react-native/docs/animated](https://facebook.github.io/react-native/docs/animated)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gesture Handler:[https://docs.swmansion.com/react-native-gesture-handler/](https://docs.swmansion.com/react-native-gesture-handler/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
