- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing and Debugging the React Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React has become the most popular frontend library in the field of web development,
    enabling programmers to build effective, scalable, and maintainable apps. To ensure
    the stability and dependability of your application, comprehensive testing and
    efficient debugging have become increasingly crucial as projects become larger
    and more complicated. This chapter provides a thorough examination of the tools
    and methods required to master testing and debugging React apps, laying the groundwork
    for you to build on as you hone your abilities.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by talking about React testing helpers, which facilitate testing
    and boost productivity. Then, we will review the most well-liked and adaptable
    testing tools accessible right now for the JavaScript and React ecosystem, including
    Enzyme, Jest, and **React Testing Library**. By doing this, you will be able to
    choose the appropriate tools for your unique needs and requirements. The setup
    and takedown phases of the testing life cycle will then be covered in detail.
  prefs: []
  type: TYPE_NORMAL
- en: We have devoted a section to discussing the best practices for addressing data
    fetching and mocking issues inside our tests because they are essential components
    for applications. We will dive into the details of testing user events, controlling
    timers, and modeling real-world interactions, giving you the necessary tools to
    confirm the responsiveness and performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll present React DevTools, a vital tool for troubleshooting and
    evaluating your React apps.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be equipped with the knowledge, abilities,
    and self-assurance necessary to successfully test and debug your React apps. You
    will be well equipped to build applications that are both dependable and robust
    in the face of constantly changing circumstances if you have a firm grasp of the
    tools and approaches at your disposal. So, let’s start on the path to becoming
    experts in testing and debugging React apps so that your projects can withstand
    the test of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to take a deep dive into the subject of testing
    and debugging from a software point of view as we learn the fundamentals, ideology,
    and concepts for testing our React applications. The following topics will be
    covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing React testing helpers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing our software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing data in our applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code execution using events and timers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using React DevTools for debugging and analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the projects and code of this chapter, here: [https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter08](https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter08)'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing React testing helpers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn about the fundamentals of RTL. But first,
    let’s try to understand what testing means when it comes to programming so that
    we can learn about the core concepts and methodology.
  prefs: []
  type: TYPE_NORMAL
- en: What is testing in software development?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reviewing a software program or system to verify it satisfies its functional
    and non-functional criteria and certifying its overall quality, performance, and
    dependability is known as testing in software development. It comprises running
    the program under controlled settings to find mistakes, flaws, or possible problems
    before the product is delivered to end customers. Testing is usually done at many
    levels, from the individual component level to the completely integrated system,
    and it is a critical part of the software development life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the project, there could be any number of testing phases. Let’s
    see what some of these testing-level phases could look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Testing phase** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Unit tests | Testing isolated code or its parts is known as unit testing.
    It guarantees that every unit operates according to its specifications and acts
    as intended. |'
  prefs: []
  type: TYPE_TB
- en: '| Integration tests | Testing the integration and relationships among various
    software units, modules, or components is known as integration testing. It guarantees
    that the components talk effectively with one another and that the combined system
    functions as a whole. |'
  prefs: []
  type: TYPE_TB
- en: '| Regression tests | Regression testing is done to make sure that new code
    modifications or improvements don’t negatively impact already-existing functionality.
    It entails re-running earlier tests following software modifications. |'
  prefs: []
  type: TYPE_TB
- en: '| Security tests | The product’s security features and weaknesses are evaluated
    during security testing. It pinpoints possible security concerns such as data
    leaks, unauthorized access, and coding flaws. |'
  prefs: []
  type: TYPE_TB
- en: '| Functional tests | Software functioning is compared to the stated requirements
    through functional testing. It comprises testing numerous features, use cases,
    and situations to evaluate the program from the viewpoint of the end user. |'
  prefs: []
  type: TYPE_TB
- en: '| Alpha and beta tests | Before distributing the program to a select group
    of external users, internal testers do alpha testing in a restricted environment.
    Beta testing involves making the program available to a wider number of outside
    users to obtain input from actual users and spot any possible problems. |'
  prefs: []
  type: TYPE_TB
- en: '| Performance tests | The software’s adaptability, rapidity, ability to scale,
    and stability under various load levels are assessed during performance testing.
    This involves testing variables such as the speed of response, resource use, and
    constraints in the system. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.1: Software development testing phases'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are many different types of testing that we can perform
    during a project’s life cycle. Next, let’s learn how we can do testing in React
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: How do we do testing in React applications?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In React, testing is the method of confirming and validating each component
    and the entire application to make sure they work as intended and adhere to the
    set criteria. This often involves testing each individual React component, user
    interactions, and any potential changes to the application state. There are a
    few ways that we can do testing in React applications and these are typically
    unit testing, integration testing, and **end-to-end** (**E2E**) testing.
  prefs: []
  type: TYPE_NORMAL
- en: How do you set up a test environment for a React application?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For your React application to be reliable, maintainable, and of the highest
    quality possible, you must set up a testing environment. You can perform tests
    in a controlled, isolated setting that closely mirrors the production environment
    if your test environment is set up correctly. This aids in locating and resolving
    possible problems before they impact end customers. All test environments require
    us developers to write tests for them, which is known as **test-driven** **development**
    (**TDD**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure describes the TDD cycle in a software development workflow.
    Coding, testing, and design are closely knitted together in this programming approach.
    There are many variations of this; however, the fundamental principle remains
    the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 8.1: The TDD cycle in software development](img/Figure_08.01_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: The TDD cycle in software development'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about the TDD cycle in software development, let’s
    move on to testing frameworks/libraries to see how we can best use them in our
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: How do you choose a testing framework or library?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When building a React application, it’s a good idea to consider a good testing
    library. Having a good testing structure means that our software should operate
    as expected and live up to the user’s expectations. So, let’s take a look at some
    of the popular testing libraries available right now:'
  prefs: []
  type: TYPE_NORMAL
- en: '**React Testing Library** (**RTL**): The lightweight RTL focuses on testing
    the functionality of your components. Compared to other testing frameworks, it
    offers a more straightforward API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jest**: The popular testing framework Jest is already set up to operate with
    React. It has built-in capabilities for testing React apps, such as mocking and
    snapshot testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enzyme**: Shallow rendering, complete DOM rendering, and snapshot testing
    are just a few of the testing tools offered for React by the potent testing framework
    Enzyme.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vite**: The frontend build tool Vite has a unit testing framework called
    **Vitest**. It is a good unit test framework with numerous contemporary features,
    including support for TypeScript, JSX, and component testing for React.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cypress**: Cypress is an E2E solution for advanced web test automation that
    is JavaScript-based. Frontend developers and QA engineers can build automated
    web tests with the help of this tool, which is designed for developers and runs
    directly in the browser'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it comes to testing, there are multiple ways that we can get it set up
    inside our React projects. Every developer has their personal preference. Some
    choose to have a dedicated folder where all of their test files go that is separate
    from their main components. Others prefer to have their test files in the same
    folder as their component and in both cases, the test files follow the same naming
    conventions as their components – so, for example, `index.js` and `index.test.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows an example of both use cases. It is a Next.js project
    that has the default setup for a Jest and RTL project. There is a folder named
    `__tests__` that contains a test called `index.test.tsx`. There is another `index.test.tsx`
    file inside of the `pages` folder next to the `index.tsx` component. Both tests
    can be run using the `npm` `test` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: React project testing file structure](img/Figure_08.02_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: React project testing file structure'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned a bit about testing conventions in general, the next
    topic we’ll cover will be the fundamentals of RTL.
  prefs: []
  type: TYPE_NORMAL
- en: What are the fundamentals of React Testing Library?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the help of the well-liked testing tool RTL, developers are urged to test
    their components in an approach that closely matches how consumers will interact
    with the application. RTL encourages testing components according to what individuals
    observe and perform instead of on implementation specifics, ensuring that the
    program stays accessible, manageable, and user-friendly. RTL is a family of packages,
    and it can be used on both React and React Native projects. So, it’s good to know
    that we can use the same package to test our web and mobile apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'RTL has many different core principles that we should become familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fireEvent` method, which lets you start a variety of DOM events, such as click,
    change, or submit, to imitate user interactions. This enables you to verify that
    the anticipated behavior is displayed by testing how your components respond to
    user interactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetByText`, `GetByRole`, and `GetByTestId` are a few often-used queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom render**: There is a default render function that you can use to render
    your components, but you can also design your own render function to wrap your
    components in a particular context or with a particular provider. When your components
    depend on unique context settings, such as theme or localization, this is very
    helpful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`screen` to output an object that gives you easy access to the displayed parts
    and query methods without you having to manually break them down. You may streamline
    your exams and make them easier to read by using `screen`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`waitFor`, `waitForElementToBeRemoved`, and `find*` searches when working with
    components that download data or depend on asynchronous activities. By guaranteeing
    that your tests wait for the necessary components or actions before continuing,
    these methods assist in managing the asynchronous operation of your components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@testing-library/user-event` package in addition to `fireEvent`. The advanced
    event simulation functions in this package more closely resemble user behavior
    than the fundamental `fireEvent` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, now that we have grasped the idea of using React testing helpers to set
    up a robust testing environment, let’s take what we’ve learned and see how we
    can best set up our test environments when using these tools. This is also going
    to be a chance to see some example test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let’s focus on learning how we can set up and clean up our project and
    code base to isolate the effects of tests – that is, setup and teardown. Setup
    and teardown are the actions that are taken before and following each test or
    collection of tests in the context of programming, particularly in software testing.
    Doing this ensures that we have good test coverage and that our tests are reliable.
    It’s crucial to adhere to a methodical approach while setting up and deconstructing
    tests to isolate their impacts. This guarantees that tests are independent of
    one another and do not affect one another, producing precise and trustworthy findings.
  prefs: []
  type: TYPE_NORMAL
- en: In automated testing, the setup and teardown steps are critical for separating
    the effects of specific tests. Before each test, the setup process helps establish
    a consistent state. This stage may include tasks such as generating required objects,
    connecting to a database, or initializing particular settings. By conducting these
    procedures before each test, we guarantee that each test begins from the same
    starting point, regardless of the outcomes during previous tests. This implies
    that a test’s behavior is not impacted by the side effects of a preceding test,
    which is critical for accurate, trustworthy testing.
  prefs: []
  type: TYPE_NORMAL
- en: Any modifications that are made during the test can be undone during the teardown
    phase. This could require actions such as cutting off database access, removing
    test data, or erasing objects made during the test. We don’t have to worry about
    changes made during one test affecting subsequent tests if we clean up after each
    test. Without a breakdown step, a test could ultimately leave behind certain modifications
    that might affect the behavior of subsequent tests.
  prefs: []
  type: TYPE_NORMAL
- en: Each test runs in the same starting environment and has no impact on the environment
    for any other tests thanks to the setup and teardown stages, which work together
    to make sure each test is isolated and reproducible. One of the guiding principles
    of automated testing is to make sure that the tests are trustworthy and that any
    flaws that are discovered are attributable to the code being tested and not to
    the test configuration or cross-test interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some rules that we can follow that will help us generate an effective
    test plan. Let’s walk through them and see how following them can give us a good
    strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Set up the test environment**: Ensure that the testing environment is the
    same for all tests. This covers any prerequisites that are required for the test
    to perform as well as the software, devices, and network setups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version control**: Use version control tools such as Git and GitHub to keep
    track of changes to your code and tests so that you can see any problems that
    fresh code or tests could cause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Create good tests**: Choose the exact tests you wish to run, and then list
    the variables and testing conditions for each.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utilize test isolation**: Create your tests so that they have no dependence
    on other tests. This implies that each test must have its own setup and teardown
    and cannot rely on the results or state of any other test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use monitoring**: To gather test results and spot any anomalies or trends
    in the test data, use logging and monitoring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Make continuous improvements**: Always enhance your tests and testing environment
    based on the findings and suggestions from each cycle of testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use methods**: Implement the setup and takedown procedures that are carried
    out before and following each test. These techniques may be used to build and
    remove resources that the tests require, such as temporary files or database connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parallel or sequential testing**: Run the tests sequentially to ensure there
    is no conflict between them or run them in parallel based on the kind of test
    to expedite the process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mock external functions**: An approach to testing that isolates the unit
    of code being evaluated from its dependencies, such as external libraries, services,
    or functions, is mocking external functions. Usually, this is done to provide
    predictable and controlled test conditions. For a variety of testing scenarios,
    mocking enables you to imitate the behavior of external dependencies before actually
    calling them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have learned some of the basics of setting up our projects for testing
    it’s time to take it a step further and move on to learning all about writing
    tests for our React.js projects.
  prefs: []
  type: TYPE_NORMAL
- en: How do we write tests for components, props, and events?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you’ve selected a testing framework and libraries, you can start developing
    tests for your React application. You will create a variety of tests, with each
    one having a different purpose and scope. There are several types of tests we
    can write, including component tests, unit tests, integration tests, event tests,
    and E2E tests. The aim is to get as much test coverage across all of the tests
    to set a benchmark and give you credibility and confidence that your application
    has thorough testing in place.
  prefs: []
  type: TYPE_NORMAL
- en: What are component tests?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A React component test is a form of unit test that specializes in individually
    testing React components. React components are the building blocks of a React
    application and define the UI, encapsulate functionality, and manage the application’s
    state. Testing React components ensures that they behave properly and meet the
    desired functionality and criteria.
  prefs: []
  type: TYPE_NORMAL
- en: In this code example, we can see what a component test looks like for a component
    called `Counter.tsx`. We have an accompanying `Counter.test.tsx` file that tests
    for increments and decrements on the buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code for the `Counter.tsx` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the code for our test file, `Counter.test.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have now learned the basics of component and component test files.
  prefs: []
  type: TYPE_NORMAL
- en: What are unit tests?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: React unit tests are a method of testing that focuses on individual React components.
    Their purpose is to guarantee that each component behaves appropriately, follows
    the intended functionality and requirements, and tests the logic and output of
    the component. Unit tests are an essential aspect of the testing process since
    they assist developers in identifying and resolving issues at the most granular
    level, ensuring that each component of the application performs properly.
  prefs: []
  type: TYPE_NORMAL
- en: We saw what a unit test looks like in our component test example.
  prefs: []
  type: TYPE_NORMAL
- en: What is an integration test?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A React integration test is a type of test that verifies the right interaction
    and behavior of many React components or between a React component and other system
    components such as APIs or external services. Integration tests, as opposed to
    unit tests, analyze how well components interact together inside the program,
    ensuring that general functionality is proper and data flows easily between different
    areas of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests are multiple tests that run inside of a `describe()` function
    block scope, as shown in our earlier component test example.
  prefs: []
  type: TYPE_NORMAL
- en: What are event tests?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: React event tests are a form of testing that focuses on confirming the behavior
    and functioning of React component event handlers. User interactions or system
    occurrences that trigger specified actions inside a React application are referred
    to as events. Button clicks, form submissions, mouse movements, and keyboard inputs
    are all examples of events. By testing event handlers, you guarantee that your
    application responds to user interactions appropriately and that the necessary
    actions are taken when events are triggered.
  prefs: []
  type: TYPE_NORMAL
- en: What is snapshot regress testing?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In React, we can use snapshot tests as a way to confirm that our UI has not
    changed and remains the same as it was prior. This helps us check that there were
    no unexpected changes that can affect the way that our design is rendered on screen.
    With snapshot testing, it is common for a snapshot of our code base to be taken
    that can then be compared to a reference snapshot file that is combined with a
    test. The test fails if the snapshots are not the same, and this is how we can
    ensure that there have been no changes to the UI. We can always update the snapshot
    to the latest version to match any changes we have made to the UI.
  prefs: []
  type: TYPE_NORMAL
- en: What are end-to-end tests?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: E2E tests are a form of testing that tries to validate the functionality of
    a whole program, from the UI through to the backend services and databases. E2E
    tests are used to model real-world user situations and guarantee that the overall
    structure works as planned, giving seamless user experience and accurate functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cypress is a popular E2E testing library that does not come bundled with React
    projects but can be installed as a separate package. You can learn more from the
    documentation: [https://www.cypress.io/](https://www.cypress.io/).'
  prefs: []
  type: TYPE_NORMAL
- en: We can use our earlier Counter project example to see what the code looks like
    when doing an E2E test with Cypress. It is quite similar to Jest and RTL and all
    three packages can work together seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at our modified Counter file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s our Counter test file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These examples have provided us with a comparison between E2E tests and component
    tests; the similarities are quite clear.
  prefs: []
  type: TYPE_NORMAL
- en: Managing data in our applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to learn how to manage the data in our applications. This is
    also known as data fetching and mocking, which are two important concepts to grasp.
    When doing testing in this area, it is necessary to have a working knowledge of
    how data-fetching APIs operate and how to mimic their data. This knowledge is
    necessary for several reasons, including development efficiency, independent testing,
    integration and interaction with external systems, and cost and rate limiting.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of developer efficiency, developers can separate portions of the
    application for testing and development by mocking API replies. This means that
    even if the backend portion of a feature is not yet completed, a frontend developer
    can still work on it by simulating an API response. As for independent testing,
    programmers can confirm that their tests are not impacted by the status or behavior
    of other systems by mimicking the data given by APIs, producing more dependable
    and consistent outcomes for tests.
  prefs: []
  type: TYPE_NORMAL
- en: When we use external systems such as APIs, we can communicate and exchange data
    between various software systems. To get data from databases, communicate with
    other apps, or offer services to users, many current applications are built on
    top of APIs. That’s why creating, maintaining, and enhancing these apps requires
    a functional understanding of how these APIs function.
  prefs: []
  type: TYPE_NORMAL
- en: When we think about cost and rate limiting, many APIs contain use restrictions
    or extra fees. To prevent reaching these restrictions or spending needless money,
    we can mock API answers during development and testing.
  prefs: []
  type: TYPE_NORMAL
- en: To use data in an application or system, data must be fetched from a data source,
    such as a database, API, or filesystem. In online applications and other software
    systems, data fetching is frequently used to display, analyze, or change data.
    It often entails sending queries to a local storage location or distant server,
    processing the answer, and then using the data in the application.
  prefs: []
  type: TYPE_NORMAL
- en: While testing, developing, or designing processes, mocking data refers to creating
    fictitious or mock data to replicate the behavior of actual data. When building
    features for a system, testing code, or designing UIs, mock data can be used as
    a stand-in for real data. It enables programmers to test their programs and apps
    without relying on potentially private, erratic, or unreachable external data
    sources or live data.
  prefs: []
  type: TYPE_NORMAL
- en: How do we mock data for tests?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mock data will most likely be required while testing your React application
    to imitate real-world circumstances. This is especially helpful for testing components
    that rely on APIs or third-party services. Numerous libraries are available for
    mimicking data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Axios Mock Adapter**: The Axios Mock Adapter library intercepts Axios requests
    and returns mocked data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nock**: Nock is an HTTP request interceptor that returns faked data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSON Server**: JSON Server is a package that uses JSON data to imitate a
    REST API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why should we use mock data in tests?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many reasons why it’s a good idea to use mock as opposed to real data
    in our tests. We can separate sections of our system using mock data, which makes
    it simpler to find problems and test particular components without being impacted
    by other dependencies. Controlled mock data ensures that tests are reproducible
    and produce consistent findings, which is another advantage. Developers can also
    verify their code and apps without having to wait for access to actual data thanks
    to the speedy generation of mock data. Also, during development and testing, sensitive
    or private data might be exposed, which can be a major worry for organizations.
    Using dummy data helps prevent this.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about events and timers, which is crucial
    learning as it relates to asynchronous or time-dependent actions in programming.
    Asynchronous programming is a technique that allows your program to begin a potentially
    long-running operation while being responsive to other events, rather than needing
    to wait until that work is completed.
  prefs: []
  type: TYPE_NORMAL
- en: When that task is completed, the outcome is shown in your program. An extremely
    flexible asynchronous and concurrent programming language such as JavaScript is
    very powerful because, like sync, it is single-threaded, but unlike async, it
    also does not block code execution, which is great for our React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Code execution using events and timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let’s move on to learning about the subject of events and timers. In software
    development, events and timers are implemented to keep track of the precise moment
    in time when something outside the program takes place. Events and timers are
    critical concepts in programming, especially when dealing with asynchronous or
    time-dependent actions. They also play a crucial part in testing such systems.
    Let’s go through each subject in further depth to drill these concepts in.
  prefs: []
  type: TYPE_NORMAL
- en: What are events?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Events are activities or occurrences that arise during program execution and
    are frequently prompted by input from users, system changes, or other sources.
    In event-driven programming, system components respond to these occurrences by
    executing specified routines known as event handlers or callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating events is critical in testing to guarantee that the application responds
    as intended when the events happen. You might wish to test how your web application
    reacts to user activities such as button clicks, form submissions, or navigation
    events. By simulating these events in your tests, you can ensure that your application’s
    event handlers are functioning properly and handling various circumstances as
    planned.
  prefs: []
  type: TYPE_NORMAL
- en: What are timers?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Timers serve a purpose in programming as they plan the execution of certain
    functions or code snippets after a certain amount of time has passed or at regular
    intervals. In JavaScript, common timer functions are `setTimeout` and `setInterval`,
    which allow you to run a function immediately following a delay or periodically
    at predefined intervals.
  prefs: []
  type: TYPE_NORMAL
- en: Timers can complicate testing since they require asynchronous activities, which
    can result in unexpected behavior or race situations. A race situation, also known
    as a race hazard, is a circumstance in which the substantive behavior of software
    or other systems is reliant on the sequence or timing of other uncontrolled occurrences.
    When one or more of the alternative behaviors is undesired, it constitutes a bug.
  prefs: []
  type: TYPE_NORMAL
- en: It is critical to handle timers appropriately when testing code that depends
    on them to produce accurate and trustworthy test results. Now that we have learned
    about timers, the next section will take what we’ve learned further as we look
    into debugging and making the best use of our knowledge of timers, which can be
    used in conjunction.
  prefs: []
  type: TYPE_NORMAL
- en: Using React DevTools for debugging and analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React DevTools is a browser plugin that offers a variety of tools for testing
    your React application. It allows you to investigate the component hierarchy,
    view the React component tree, and verify the props and state of your components.
    We will dive into the various debugging techniques available to us and how using
    them will give us more confidence in the code that we write.
  prefs: []
  type: TYPE_NORMAL
- en: 'React DevTools can be seen in the following figure. It is available in the
    Chrome web store:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: React DevTools](img/Figure_08.03_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: React DevTools'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have learned about React DevTools. Next, we’ll learn how to configure
    CI/CD pipelines for our automated tests, another useful tool in our debugging
    toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: How do we configure a CI/CD pipeline to automate tests?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To ensure that our tests run every time we make code changes, we can configure
    a **continuous integration/continuous deployment** (**CI/CD**) pipeline that runs
    tests automatically. This allows us to catch issues early and ensure that our
    code meets the expected standard. Using a CI/CD pipeline to automate tests in
    a React application has several advantages, including higher code quality, faster
    feedback, greater collaboration, and more efficient deployment procedures. These
    advantages enable teams to create high-quality software more quickly and consistently,
    making CI/CD pipelines a vital tool for modern software development.
  prefs: []
  type: TYPE_NORMAL
- en: It is common practice to use a code hosting platform such as GitHub, GitLab,
    or Bitbucket combined with a CI/CD testing platform such as GitHub Actions, Jenkins,
    Docker, Kubernetes, or CircleCI to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: How do we debug a React application?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Debugging a React application might be difficult, but it is a necessary skill
    for any React developer. In this subsection, we’ll go over some fundamental strategies
    and tricks for properly debugging a React application.
  prefs: []
  type: TYPE_NORMAL
- en: How do we utilize the debugging tools inside our IDE/code editor?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Popular code editors such as Visual Studio Code include debugging capabilities
    for JavaScript and React apps. You can debug your React application immediately
    within the editor by configuring a launch configuration, which allows you to create
    breakpoints, walk through code, and inspect variables.
  prefs: []
  type: TYPE_NORMAL
- en: How do we set up breakpoints with DevTools?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Debugging a React application begins with the use of breakpoints, which interrupt
    the execution of your code at a certain moment in time. You can set breakpoints,
    analyze variables, and go through your code line by line using the browser’s built-in
    developer tools. Use DevTools and browse the **Sources** tab to establish a breakpoint
    in your program. Locate the necessary file, scroll to the line where you wish
    to establish a breakpoint, and then click on the line number to do so.
  prefs: []
  type: TYPE_NORMAL
- en: If you reload the page once you’ve set a breakpoint, your code will halt at
    the breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: How do we use logging to track application behavior?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another key tool for troubleshooting a React application is logging. You can
    use `console.log()` commands to output variable values, trace the flow of your
    code, and troubleshoot problems.
  prefs: []
  type: TYPE_NORMAL
- en: Just put `console.log()` followed by the value you wish to log into your code
    to add a `console.log()` statement.
  prefs: []
  type: TYPE_NORMAL
- en: How do we create error boundaries?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Error boundaries are React components that can detect JavaScript problems anywhere
    in your component hierarchy, report them, and replace the crashed component with
    a fallback UI. You can prevent your application from crashing if an unhandled
    error in a single component is wrapped in an error border component.
  prefs: []
  type: TYPE_NORMAL
- en: How do we understand JavaScript error codes?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'React apps can experience a variety of issues, ranging from syntax mistakes
    to runtime faults. Knowing these issues and the error codes associated with them
    is critical for effective troubleshooting. For example, a typical problem that’s
    seen by React developers is `TypeError: Cannot read property ''propName'' of undefined`.
    When you try to access a property of an undefined object, this error occurs.'
  prefs: []
  type: TYPE_NORMAL
- en: You can pinpoint the problem and repair it faster if you understand the error
    code and its associated problems.
  prefs: []
  type: TYPE_NORMAL
- en: How do we install a debugger extension?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Browser debugger plugins can also assist you in debugging your React application.
    The React DevTools extension, for example, contains various tools that have been
    developed expressly for debugging React applications, such as the ability to explore
    the component hierarchy, check properties and states, and highlight the selected
    component in the browser. Similarly, we can use the Redux DevTools extension to
    debug our application’s state changes. Using Redux is more applicable when we
    are working with a more complex application that requires a global state.
  prefs: []
  type: TYPE_NORMAL
- en: How do we use the ESLint plugin for React?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: ESLint is a popular JavaScript linting tool that can help you find and correct
    syntax problems, possible bugs, and code quality concerns. The ESLint plugin for
    React adds extra linting rules tailored to React applications, assisting you in
    detecting frequent mistakes and best practice violations.
  prefs: []
  type: TYPE_NORMAL
- en: What are error monitoring tools?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tools for tracking, identifying, and reporting mistakes and anomalies that arise
    in applications throughout development, testing, or deployment are known as error
    monitoring tools. These tools assist programmers in locating problems, determining
    their root causes, and promptly resolving them. For developers to achieve better
    software, error monitoring systems frequently include capabilities such as real-time
    error tracking, alerts, and thorough error reporting.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a lot of error monitoring tools available, and some stand-out
    ones include LogRocket, Sentry, and Rollbar.
  prefs: []
  type: TYPE_NORMAL
- en: We have reached the end of this section and also this chapter. Our knowledge
    of testing and debugging will be crucial at interviews because this is an area
    that many companies expect developers to be good in.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has offered a thorough understanding of the critical parts of testing
    and debugging React applications. We began by discussing the significance of testing
    in software development and the necessity for a strong testing environment geared
    toward React apps. Next, we looked at various testing frameworks and libraries,
    highlighting their unique characteristics as well as the criteria to consider
    when choosing the best tools. Learning about the importance of setups and teardowns
    was also covered.
  prefs: []
  type: TYPE_NORMAL
- en: We covered building tests for components, props, and events throughout this
    chapter, highlighting the need to create extensive test suites to ensure the dependability
    and maintainability of our React applications. To take the testing process even
    further, we talked about mocking data for tests, which allows us to simulate real-world
    scenarios without relying on external dependencies. Understanding events and times
    when doing testing was another hot topic we talked about.
  prefs: []
  type: TYPE_NORMAL
- en: We also introduced React DevTools, which assists developers in evaluating and
    understanding the internal structure and behavior of their apps throughout the
    testing phase, as well as CI/CD pipelines. Another important topic we discussed
    in this chapter was debugging React apps and using error monitoring tools. Understanding
    the art of testing and debugging is critical for React developers looking to build
    high-quality, long-lasting applications because these skills will make us better
    developers. Being capable of solving problems is a quality that is highly sought
    after in the world of programming.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will get the chance to learn about some of the most
    modern React.js build tools available. Next.js, Gatsby and Remix are three popular
    choices for React.js development so let’s expand our knowledge further and get
    a grasp on these amazing libraries
  prefs: []
  type: TYPE_NORMAL
