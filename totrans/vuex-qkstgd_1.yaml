- en: Rethinking User Interfaces with Flux, Vue, and Vuex
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flux、Vue和Vuex重新思考用户界面
- en: I started my first job as a Java EE programmer at the end of 2007\. I still
    remember my friend Giuseppe saying, *You don't like JavaScript, do you?* and me
    answering, *No, I don't. Each time I write something in JavaScript, it doesn't
    work in all versions of Internet Explorer... not to mention Firefox!* He just
    replied, *Have a look at jQuery*. Today, I like to call myself a JavaScript programmer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我在2007年底开始了我的第一份工作，作为Java EE程序员。我仍然记得我的朋友Giuseppe说，“你不喜欢JavaScript，对吧？”而我回答，“不，我不喜欢。每次我写JavaScript时，它都不在所有版本的Internet
    Explorer中工作...更不用说Firefox了！”他只是回答，“看看jQuery。”今天，我喜欢称自己为JavaScript程序员。
- en: Since then, web development has evolved a lot. A number of JavaScript frameworks
    became popular and then declined because new frameworks emerged. You may think
    that it is not worth learning new frameworks since they will eventually decline
    in popularity. Well, in my opinion, that is not true. Each framework added something
    useful to web development, something that we still use. For example, jQuery made
    use of JavaScript that was so simple that we started moving client logic to the
    browser instead of rendering everything server-side.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，Web开发已经发生了很大的变化。许多JavaScript框架变得流行，然后又因为新框架的出现而衰落。你可能认为学习新框架不值得，因为它们最终会失去人气。然而，在我看来，这并不正确。每个框架都为Web开发增添了有用的功能，这些功能我们仍在使用。例如，jQuery利用了非常简单的JavaScript，我们开始将客户端逻辑移动到浏览器，而不是在服务器端渲染一切。
- en: Today, we write progressive web applications that are complex applications with
    web user interfaces. This complexity requires discipline and best practices. Fortunately,
    big companies such as Facebook, Google, and others have introduced frameworks
    and guidelines to help web programmers. You may have heard about Google's *Material
    Design* or Facebook's *Flux*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们编写的是具有Web用户界面的复杂应用程序，即渐进式Web应用程序。这种复杂性需要纪律和最佳实践。幸运的是，像Facebook、Google和其他大公司这样的公司已经引入了框架和指南来帮助Web程序员。你可能听说过Google的*Material
    Design*或Facebook的*Flux*。
- en: 'In this chapter we will focus on the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注以下内容：
- en: '**Model-view-controller** (**MVC**) problems, and using Facebook Flux architecture
    to solve these problems'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）问题，以及使用Facebook Flux架构来解决这些问题'
- en: Flux fundamentals
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flux基础
- en: What Vuex is
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Vuex
- en: Architectural differences between Flux and Vuex
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flux和Vuex之间的架构差异
- en: To understand this book, you need a good knowledge of Vue.js and JavaScript,
    a basic understanding of ECMAScript 6, and a very basic knowledge of webpack.
    In any case, almost all the concepts used here, Vuex and otherwise, are explained.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这本书，你需要对Vue.js和JavaScript有很好的了解，对ECMAScript 6有基本理解，以及对webpack有非常基本的了解。无论如何，这里使用的几乎所有概念，包括Vuex，都得到了解释。
- en: After explaining the Flux concepts, this book will help you understand how Vuex
    implements these concepts, how to use Vue.js and Vuex to build professional web
    applications, and finally how to extend Vuex functionality.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释Flux概念之后，这本书将帮助你理解Vuex如何实现这些概念，如何使用Vue.js和Vuex构建专业Web应用程序，以及最后如何扩展Vuex功能。
- en: MVC problems and the Flux solution
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC问题和Flux解决方案
- en: 'Each time we speak about an application with a user interface, the MVC pattern
    comes out. But what is the MVC pattern? It is an architectural pattern that divides
    components into three parts: a **Model**, a **View**, and a **Controller**. You
    can see the classic diagram describing MVC in the following figure:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们谈论具有用户界面的应用程序时，MVC模式就会出现。但MVC模式是什么？它是一种将组件分为三部分的架构模式：一个**模型**、一个**视图**和一个**控制器**。你可以在以下图中看到描述MVC的经典图示：
- en: '![](img/97330382-a3be-4205-9fb3-64fcd418944f.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/97330382-a3be-4205-9fb3-64fcd418944f.png)'
- en: 'Figure 1.0: Classic MVC diagram'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.0：经典MVC图示
- en: 'Most of the modern frameworks for progressive web applications use the MVC
    pattern. In fact, if you look at the Vue.js single file component shown in the
    following figure, you can clearly see the three parts of the MVC pattern:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代的渐进式Web应用程序框架都使用MVC模式。实际上，如果你看看以下图中显示的Vue.js单文件组件，你可以清楚地看到MVC模式的三个部分：
- en: '![](img/c0ea9c0a-8155-4ab5-b80c-35373ae3fcec.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c0ea9c0a-8155-4ab5-b80c-35373ae3fcec.png)'
- en: 'Figure 1.1: Vue.js single file component'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：Vue.js单文件组件
- en: The `template` and `style` parts represent the view section, the `script` part
    provides the controller, and the `data` section of the controller is the model.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`template`和`style`部分代表视图部分，`script`部分提供控制器，控制器中的`data`部分是模型。'
- en: But what happens when we need some data from the model of a component that's
    inside another component? Moreover, in general, how can we interconnect all the
    components of a page?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当我们需要从另一个组件的模型中获取一些数据时会发生什么？此外，在一般情况下，我们如何将页面的所有组件相互连接？
- en: 'Clearly, providing direct access to the model of the components from other
    components is not a good idea. The following screenshot shows the dependencies
    in the case of exposing the models:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，直接从其他组件访问组件的模型不是一个好主意。以下截图显示了暴露模型时的依赖关系：
- en: '![](img/6574c3ed-6a76-4d69-94d5-29984a28dc37.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6574c3ed-6a76-4d69-94d5-29984a28dc37.png)'
- en: 'Figure 1.2: MVC hell'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2：MVC 地狱
- en: 'Vue.js provides a good way of communicating between parent and child components:
    You can use P*rops* to pass values from a parent to a child component, and you
    can *emit* data from a child component to its parent. The following figure shows
    a visual representation of this concept:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 提供了一种在父组件和子组件之间通信的好方法：你可以使用 P*rops* 从父组件传递值到子组件，你也可以从子组件 *emit* 数据到其父组件。以下图展示了这个概念的一个视觉表示：
- en: '![](img/99cc432f-79f5-46f8-badc-398fd5b46feb.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99cc432f-79f5-46f8-badc-398fd5b46feb.png)'
- en: 'Figure 1.3: Vue.js parent–child communication'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3：Vue.js 父子通信
- en: 'However, when multiple components share a common state, this way of communicating
    is not enough. The following are the issues that would come up:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当多个组件共享一个公共状态时，这种通信方式就不够了。以下是一些可能出现的问题：
- en: Multiple views may share the same piece of state
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个视图可能共享同一块状态
- en: User actions from different views may need to change the same piece of state
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自不同视图的用户操作可能需要改变同一块状态
- en: 'Some frameworks provide a component called `EventBus`; in fact, the Vue instance
    itself is an `EventBus`. It has two methods: `Vue.$emit(event, [eventData])` and
    `Vue.$on(event, callback([eventData]))`. The following is an example of how to
    create a global event bus:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一些框架提供了一个名为 `EventBus` 的组件；实际上，Vue 实例本身就是一个 `EventBus`。它有两个方法：`Vue.$emit(event,
    [eventData])` 和 `Vue.$on(event, callback([eventData]))`。以下是如何创建一个全局事件总线的一个示例：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Even with a global event bus, making components communicate is not easy. What
    if a component that registers to an event gets loaded after the event is fired?
    It will miss the event. This may happen if that component is inside a module that
    gets loaded later, which is likely to happen in a progressive web app where modules
    are lazily loaded.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有全局事件总线，使组件通信也不是一件容易的事。如果一个注册了事件的组件在事件触发后加载，它将错过这个事件。如果这个组件在后来加载的模块中，这种情况很可能会发生在渐进式
    Web 应用程序中，其中模块是按需加载的。
- en: For example, say that a user wants to add a product to the cart list. She taps
    on the *Add to cart* button, which is likely to be in the `CartList` component,
    and she expects the product she sees on the screen to be saved in the cart. How
    can the `CartList` component find out what the product is that should be added
    to its list?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设用户想要将一个产品添加到购物车列表中。她点击了 *添加到购物车* 按钮，这个按钮很可能是位于 `CartList` 组件中，并且她期望屏幕上看到的那个产品被保存在购物车中。`CartList`
    组件如何找出应该添加到其列表中的产品是什么？
- en: 'Well, it seems that Facebook programmers faced similar problems, and to solve
    those problems, they designed what they called *Flux*: Application architecture
    for building user interfaces.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，看起来 Facebook 程序员也面临了类似的问题，为了解决这些问题，他们设计了他们称之为 *Flux* 的东西：用于构建用户界面的应用程序架构。
- en: Inspired by Flux and Elm architecture, Evan You, the author of *Vue.js*, created
    Vuex. You may know Redux already. In that case, you will find that Vuex and Redux
    are similar, and that Evan You saved us time by implementing Vuex instead of forcing
    every programmer to integrate Redux inside a Vue.js application. In addition,
    Vuex is designed around Vue.js to provide the best integration between the two
    frameworks.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 受到 Flux 和 Elm 架构的启发，Vue.js 的作者埃文·尤创建了 Vuex。你可能已经知道 Redux。在这种情况下，你会发现 Vuex 和
    Redux 很相似，而且埃文·尤通过实现 Vuex 而不是强迫每个程序员在 Vue.js 应用程序中集成 Redux，为我们节省了时间。此外，Vuex 是围绕
    Vue.js 设计的，以提供两个框架之间最佳集成。
- en: But what is Vuex? That is the topic of the next section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Vuex 是什么？这就是下一节的主题。
- en: What is Vuex?
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Vuex？
- en: 'Evan Youdefines Vuex as:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 埃文·尤定义 Vuex 为：
- en: '*"*state management pattern + library for Vue.js applications. It serves as
    a centralized store for all the components in an application, with rules ensuring
    that the state can only be mutated in a predictable fashion."'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '"*Vuex 是一个用于 Vue.js 应用程序的状态管理模式 + 库。它作为应用程序中所有组件的集中存储，并确保状态只能以可预测的方式被突变。"'
- en: Without knowing Flux, this definition sounds a little bit obscure. Actually,
    Vuex is a Flux implementation that exploits the reactivity system of Vue using
    a single, centralized store, and ensures that *the state can only be mutated in
    a predictable fashion*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在不了解Flux的情况下，这个定义听起来有点模糊。实际上，Vuex是利用Vue的响应式系统实现的Flux，使用单个集中式store，并确保*状态只能以可预测的方式被修改*。
- en: Before focusing on Vuex itself, we are going to understand the fundamentals
    of Flux and how Vuex took inspiration from these concepts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在专注于Vuex本身之前，我们将了解Flux的基本原理以及Vuex是如何从这些概念中汲取灵感的。
- en: Understanding the Flux fundamentals
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Flux的基本原理
- en: 'Flux is a pattern for managing data flow in your application, and it is the
    application architecture that Facebook uses for building its web applications.
    The following diagram shows the structure and data flow in Flux:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Flux是管理应用程序中数据流的一种模式，它是Facebook用于构建其Web应用程序的应用程序架构。以下图表显示了Flux的结构和数据流：
- en: '![](img/022c599e-8a98-4e29-947f-fde93d093c77.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/022c599e-8a98-4e29-947f-fde93d093c77.png)'
- en: 'Figure 1.4: Structure and data flow in Flux'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：Flux的结构和数据流
- en: 'As shown in the preceding figure, Flux is divided into four parts, and *data
    flows in only one direction*. In the next sections, we will see how data flows
    through the following parts:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，Flux分为四个部分，并且*数据流仅有一个方向*。在接下来的章节中，我们将看到数据是如何通过以下部分流动的：
- en: Actions
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Actions
- en: Dispatchers
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dispatchers
- en: Stores
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stores
- en: Views
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图
- en: Although it is important to understand how Flux works, Vuex has its own implementation
    of Flux architecture that differs from Flux, and it will be explained in detail
    in the following chapters.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然了解Flux的工作原理很重要，但Vuex有自己的Flux架构实现，这与Flux不同，将在以下章节中详细解释。
- en: Actions
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Actions
- en: Actions define the internal API of your application. They represent what can
    be done, but not how it is done. The logic of state mutation is contained inside
    stores. An action is simply an object with a type and some data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Actions定义了应用程序的内部API。它们代表可以做什么，但不是如何做。状态变更的逻辑包含在stores中。一个action只是一个具有类型和一些数据的简单对象。
- en: Actions should be meaningful to the reader and they should avoid implementation
    details. For example, `remove-product-from-cart` is better than splitting it into
    `update-server-cart`, `refresh-cart-list`, and `update-money-total`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Actions应该对读者有意义，并且应该避免实现细节。例如，`remove-product-from-cart`比将其拆分为`update-server-cart`、`refresh-cart-list`和`update-money-total`更好。
- en: An action is dispatched to all the stores and it can cause more than one store
    to update. So dispatching an action will result in one or more stores executing
    the corresponding action handler.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个action被分发到所有store，并且可以导致多个store更新。因此，分发一个action将导致一个或多个store执行相应的action处理器。
- en: 'For example, when a user taps on the *Remove from cart* button, a `remove-product-from-cart`
    action is dispatched:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当用户点击*从购物车中移除*按钮时，会分发一个`remove-product-from-cart` action：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In Vuex, the action system is a bit different, and it splits Flux actions into
    two concepts:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vuex中，动作系统略有不同，它将Flux actions分为两个概念：
- en: Actions
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Actions
- en: Mutations
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mutations
- en: Actions represent a behavior of an application, something that the application
    must do. The result of an action consists typically of one or more mutations being
    committed. Committing a mutation means executing its associated handler. It is
    not possible to change the Vuex state directly inside an action; instead, actions
    commit mutations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Actions代表应用程序的行为，即应用程序必须做的事情。一个action的结果通常包括一个或多个被提交的mutations。提交一个mutation意味着执行其关联的处理器。在action内部直接更改Vuex状态是不可能的；相反，actions提交mutations。
- en: You have to deal with asynchronous code inside actions, since mutations must
    be synchronous.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在actions内部，你必须处理异步代码，因为mutations必须是同步的。
- en: Mutations, on the other hand, can and do modify the application state. They
    represent the application logic directly connected to the application state. Mutations
    should be simple, since complex behavior should be handled by actions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，mutations可以并且确实会修改应用程序状态。它们代表直接连接到应用程序状态的直接应用程序逻辑。mutations应该是简单的，因为复杂的行为应该由actions处理。
- en: Since there is only one store in Vuex, actions are dispatched using the store,
    and there is a direct connection between an action and its handler. In Flux, on
    the other hand, every store knows what to do when responding to the action.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Vuex中只有一个store，因此actions是通过store分发的，action与其处理器之间存在直接连接。另一方面，在Flux中，每个store都知道在响应action时应该做什么。
- en: You will read about the Vuex action/mutation system in the following chapters.
    Right now, you just need to understand the concepts behind actions, and that Vuex
    implements actions in a slightly different way than the one used by Flux.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在接下来的章节中了解到Vuex动作/变异系统。现在，你只需要理解动作背后的概念，以及Vuex以略不同于Flux的方式实现动作。
- en: Dispatcher
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发器
- en: There is only one dispatcher per application, and it receives actions and dispatches
    them to the stores. Every store receives every action. It is a simple mechanism
    to dispatch actions, and it can handle dependencies between stores by dispatching
    actions to the stores in a specific order.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序只有一个分发器，它接收动作并将它们分发给商店。每个商店都接收每个动作。这是一个简单的动作分发机制，它可以通过以特定顺序向商店分发动作来处理商店之间的依赖关系。
- en: 'For example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: A user taps on the *Add to cart* button
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户点击了*添加到购物车*按钮
- en: The view captures this event and dispatches an `add-to-cart` action
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图捕获这个事件并分发一个`添加到购物车`动作
- en: Every store receives this action
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个商店都接收这个动作
- en: Since Vuex differs from Flux because the dispatcher is inside the store, what
    you should remember here is that every change in the application begins by dispatching
    an action.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Vuex与Flux不同，因为分发器位于商店内部，所以你应该记住的是，应用程序中的每个变化都是从分发一个动作开始的。
- en: Stores
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 商店
- en: 'Stores contain the application state and logic. Stores can be mutated only
    by actions and do not expose any setter method. There can be more than one store
    in Flux, each one representing a domain within the application. In Vuex, there
    is only one store, and its state is called a single state tree. Vuex is not the
    only framework that enforces the use of a single store: Redux explicitly states
    that there is one store per Redux application. You may think that a single store
    may break modularity. We will see later how modularity works on Vuex.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 商店包含应用程序状态和逻辑。商店只能通过动作进行修改，不暴露任何设置方法。在Flux中可以有多个商店，每个商店代表应用程序中的一个领域。在Vuex中，只有一个商店，其状态被称为单一状态树。Vuex不是唯一强制使用单个商店的框架：Redux明确指出每个Redux应用程序都有一个商店。你可能认为单个商店可能会破坏模块化。我们将在稍后看到Vuex中模块化是如何工作的。
- en: 'Before switching to Flux architecture, Facebook chat kept experiencing a bug
    where the number of unread messages was wrong. Instead of having two lists—one
    of read messages and another of unread ones—they used to derive the number of
    unread messages from other components events. It is indeed better to have an explicit
    state where all the information is stored. Think of the state as an application
    snapshot: You could save it before the application page gets closed and restore
    it when the application gets opened again so that the user will find the application
    in the same state it was left in.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在切换到Flux架构之前，Facebook聊天一直经历一个错误，即未读消息的数量不正确。他们不是有两个列表——一个是已读消息，另一个是未读消息——而是从其他组件的事件中推导出未读消息的数量。确实，有一个显式的状态，其中存储了所有信息会更好。将状态视为应用程序快照：你可以在应用程序页面关闭之前保存它，当应用程序再次打开时恢复它，这样用户会发现应用程序处于离开时的相同状态。
- en: 'There are three important concepts regarding stores:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关于商店有三个重要概念：
- en: Stores can be mutated only by actions
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商店只能通过动作进行修改
- en: Once a store is mutated, it notifies it has changed to the views
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦商店被修改，它会通知视图它已经发生了变化
- en: Stores represent explicit data, as opposed to deriving data from events
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商店表示显式数据，而不是从事件中推导数据
- en: 'Here is an example of a store reacting to the `add-to-cart` action dispatched
    in the previous example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个商店对之前示例中分发的`添加到购物车`动作做出反应的例子：
- en: The store receives the `add-to-cart` action
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 商店接收了`添加到购物车`动作
- en: It decides it is relevant and executes the logic of the action by adding the
    current product to the cart product list
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它决定这是相关的，并通过将当前产品添加到购物车产品列表来执行动作的逻辑
- en: It updates its data and then notifies the views that it has changed
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它更新其数据，然后通知视图它已经发生了变化
- en: Views
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: Views, or view controllers, display data from the stores. Here is where a framework
    like Vue.js plugs in.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 视图或视图控制器显示商店中的数据。这就是Vue.js等框架插入的地方。
- en: Rendering data in the stores
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在商店中渲染数据
- en: 'In the Facebook video introducing Flux, software engineer Jing Chen talks about
    some of the problems they faced while developing Facebook Chat, and what lessons
    they learned. One interesting lesson they learned concerns rendering: They didn''t
    want to rerender all the messages in the chat, but instead wanted to optimize
    it a bit by updating the chat view with only the new messages. If you are an experienced
    programmer, you may think, T*his is a premature optimization*. Indeed it is! It
    is much more simple to pass the whole view-model to the views rather than just
    pass the differences from the old and new model.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在Facebook介绍Flux的视频中，软件工程师陈静谈到了他们在开发Facebook Chat时遇到的一些问题以及他们学到的经验教训。他们学到的其中一个有趣的教训是关于渲染的：他们不想重新渲染聊天中的所有消息，而是想通过仅更新聊天视图中的新消息来优化它。如果你是一个经验丰富的程序员，你可能认为这是“过早优化”。确实如此！将整个视图模型传递给视图，而不是只传递旧模型和新模型之间的差异，要简单得多。
- en: 'Say that a programmer wants to add a new feature to a view: If the view-model
    is rendered by the view each time it is modified, they just need to add some properties
    to the model and add some code to the view to display these new properties. They
    don''t need to worry about updating/rendering logic.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个程序员想要向一个视图添加一个新功能：如果视图模型每次修改时都由视图渲染，他们只需向模型添加一些属性，并在视图中添加一些代码来显示这些新属性。他们不需要担心更新/渲染逻辑。
- en: 'But what about performance? Isn''t it bad to rerender the whole page just because
    the number of unread messages has changed? Here, Vue.js comes to help us. A programmer
    just needs to update the view-model and Vue.js will understand what has changed
    and will rerender only the **Document Object Model** (**DOM**) parts that actually
    changed. The following diagram schematizes this concept:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，关于性能呢？仅仅因为未读消息的数量发生了变化，就重新渲染整个页面，这不是很糟糕吗？在这里，Vue.js来帮助我们。程序员只需更新视图模型，Vue.js就会理解发生了什么变化，并且只会重新渲染实际发生变化的**文档对象模型**（**DOM**）部分。以下图表概述了这一概念：
- en: '![](img/37625ad0-2d63-46fe-891d-02d91f4d847c.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/37625ad0-2d63-46fe-891d-02d91f4d847c.png)'
- en: 'Figure 1.5: Vue.js updating a DOM node'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5：Vue.js更新DOM节点
- en: 'The lesson is this: Spend time on designing explicit, meaningful models and
    let Vue.js take care of the performance and rendering logic.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 经验教训是这样的：花时间设计明确的、有意义的模型，让Vue.js负责性能和渲染逻辑。
- en: The **DOM** is used to render a web page. See [https://www.w3schools.com/js/js_htmldom.asp](https://www.w3schools.com/js/js_htmldom.asp)
    for more information.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**DOM**用于渲染网页。更多信息请见[https://www.w3schools.com/js/js_htmldom.asp](https://www.w3schools.com/js/js_htmldom.asp)。'
- en: Stores and private components model
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储和私有组件模型
- en: Since views display data from stores, you may think that a view-model is just
    a portion of a store. Actually, each component can have a private model that can
    hold values that are needed just inside the component. There is no need to put
    every value in a store. Stores should contain only data relevant to the application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于视图显示来自存储的数据，你可能会认为视图模型只是存储的一部分。实际上，每个组件都可以有一个私有的模型，可以保存仅在该组件内部需要的值。没有必要将每个值都放入存储中。存储应只包含与应用程序相关的数据。
- en: For example, say you want to select some photos from a list and share them.
    The view-model of the photo list component will contain the list of selected photos,
    and when a user taps on the Share button, the view-controller just needs to dispatch
    an action called `share-photos` with the selected photo list as data in the `action`
    object. There is no need to put the selected photo list inside a store.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想要从列表中选择一些照片并分享它们。照片列表组件的视图模型将包含所选照片的列表，当用户点击分享按钮时，视图控制器只需分发一个名为`share-photos`的动作，并将所选照片列表作为`action`对象中的数据。不需要将所选照片列表放入存储中。
- en: Summarizing Flux architecture
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结Flux架构
- en: 'The following is the Flux architecture summarized in a single image:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将Flux架构总结在一张图中的内容：
- en: '![](img/9a48c973-8e31-4f23-942f-560cb9cbdd84.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a48c973-8e31-4f23-942f-560cb9cbdd84.png)'
- en: 'Figure 1.6: Flux data flow explained'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6：Flux数据流解释
- en: Benefits of using Flux
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flux的好处
- en: 'The following are some of the benefits that Facebook gained after introducing
    Flux to their web applications:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些Facebook在将Flux引入其Web应用程序后获得的一些好处：
- en: Better scalability than the classic MVC
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比经典的MVC模式有更好的可扩展性
- en: Easy-to-understand data flow
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据流易于理解
- en: Easier and more effective unit tests
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试更简单、更有效
- en: Since actions represent behaviors of the application, behavior-driven development
    is a perfect match to write applications using Flux architecture
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于动作代表了应用程序的行为，因此以行为驱动的开发非常适合使用Flux架构编写应用程序。
- en: By adding the Vuex framework to your `Vue.js` application, you will experience
    the same benefits. In addition, Vuex, like Redux, simplified this architecture
    in several different ways, such as using a single store per application and removing
    the dispatcher from the process in favor of using the store to dispatch actions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将Vuex框架添加到您的`Vue.js`应用程序中，您将体验到同样的好处。此外，Vuex，就像Redux一样，以几种不同的方式简化了这种架构，例如每个应用程序使用一个存储库，并且为了使用存储库来分发动作，从过程中移除了分发器。
- en: Summary
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we looked at why Facebook engineers designed the Flux architecture.
    We focused on the fundamentals of Flux and learned that Vuex differs slightly
    from Flux. We can now summarize Flux in one sentence: Flux is a predictable state
    management system with a one-way data flow.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了为什么Facebook工程师设计了Flux架构。我们关注了Flux的基本原理，并了解到Vuex与Flux略有不同。现在我们可以用一句话来概括Flux：Flux是一个具有单向数据流的可预测状态管理系统。
- en: In [Chapter 2](80f5c4a1-49e4-44f6-aa6e-8012d8608f3d.xhtml), *Implementing Flux
    Architecture with Vuex*, you will learn the core concepts of Vuex, as well as
    how you can use Vuex in your applications.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](80f5c4a1-49e4-44f6-aa6e-8012d8608f3d.xhtml)《使用Vuex实现Flux架构》中，您将学习Vuex的核心概念，以及如何在您的应用程序中使用Vuex。
