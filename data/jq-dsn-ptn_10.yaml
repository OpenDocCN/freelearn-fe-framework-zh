- en: Chapter 10. Plugin and Widget Development Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第十章。插件和小部件开发模式
- en: This chapter focuses on the design patterns and best practices used when implementing
    jQuery Plugins. We will learn here how to abstract parts of an application into
    separate jQuery Plugins, promoting the **Separation of Concerns** principle and
    code reusability.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了实现 jQuery 插件时使用的设计模式和最佳实践。我们将在这里学习如何将应用程序的部分抽象为单独的 jQuery 插件，促进**关注点分离**原则和代码的可重用性。
- en: We will firstly analyze the simplest ways that a jQuery Plugin can be implemented,
    learn the various conventions of jQuery Plugin development and the basic characteristics
    that every plugin should satisfy in order to follow jQuery principles. We will
    then proceed with an introduction to the most widely used design patterns and
    analyze the characteristics and benefits of each of them. By the end of this chapter,
    we will be able to implement extensible jQuery Plugins using the development pattern
    that best suits each use case.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先分析 jQuery 插件可以实现的最简单方式，学习 jQuery 插件开发的各种约定以及每个插件应满足的基本特性，以遵循 jQuery 原则。然后，我们将介绍最常用的设计模式，并分析每种模式的特点和优势。到本章结束时，我们将能够使用最适合每种情况的开发模式实现可扩展的
    jQuery 插件。
- en: 'In this chapter we will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Introduce the jQuery Plugin API and its conventions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 jQuery 插件 API 及其约定
- en: Analyze the characteristics that make an excellent plugin
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析构成优秀插件的特点
- en: Learn how to create a plugin by extending the `$.fn` object
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习通过扩展`$.fn`对象来创建插件
- en: Learn how to implement generic plugins that are extensible in order to make
    them reusable in more use cases
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何实现可扩展的通用插件，以使它们在更多用例中可重用
- en: Learn how to provide options and methods to your plugins
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何为插件提供选项和方法
- en: Introduce the most common design patterns for jQuery plugin development and
    analyze the common implementation problems that each of them helps to solve
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 jQuery 插件开发的最常见设计模式，并分析它们各自有助于解决的常见实现问题
- en: Introducing jQuery Plugins
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入 jQuery 插件
- en: The key concept of jQuery plugins lies in extending the jQuery API by making
    their functionality accessible as a method on jQuery **Composite Collection**
    Objects. A jQuery plugin is simply a function that is defined as a new method
    on the `$.fn` object, which is the **Prototype Object** that every jQuery Collection
    Object inherits from.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 插件的关键概念在于通过将其功能作为 jQuery **复合集合**对象上的方法来扩展 jQuery API。一个 jQuery 插件只是一个定义为`$.fn`对象上的新方法的函数，该对象是每个
    jQuery 集合对象所继承的**原型对象**。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'By defining a method on the `$.fn` object, we are actually extending the core
    jQuery API itself, since this makes the method available on all created jQuery
    Collection Objects from that point onwards. As a result, after a plugin has been
    loaded in a web page, its functionality is available as a method on every object
    returned by the `$()` function:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`$.fn`对象上定义方法，我们实际上是扩展了核心 jQuery API 本身，因为这使得该方法在此后创建的所有 jQuery 集合对象上都可用。因此，在网页中加载了插件后，其功能将作为`$()`函数返回的每个对象的方法可用：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The main convention of the jQuery plugin API is that the jQuery Collection
    Object that the plugin was invoked on is made available to the plugin''s method
    as its execution context. In other words, we can use the `this` identifier in
    the plugin method, as shown below:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 插件 API 的主要约定是，调用插件的 jQuery 集合对象作为其执行上下文可用于插件的方法中。换句话说，我们可以在插件方法中使用`this`标识符，如下所示：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Following jQuery principles
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遵循 jQuery 原则
- en: One of the goals when creating a plugin is to make it feel like a part of jQuery
    itself. After reading the previous chapters, you should be familiar with some
    of the principles that all jQuery methods follow and the characteristics that
    make its approach special. Implementing a plugin that follows these principles
    makes users feel more comfortable with its API, be more productive, and make fewer
    implementation errors, which leads to an increase in the plugin's popularity and
    adoption.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 创建插件时的一个目标是使其感觉像 jQuery 本身的一部分。阅读前几章后，您应该熟悉一些所有 jQuery 方法遵循的原则以及使其方法独特的特点。实现遵循这些原则的插件使用户更加熟悉其
    API，更具生产力，并且减少了实现错误，从而增加了插件的流行度和采用率。
- en: 'Two of the most important characteristics that a great jQuery plugin should
    have are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优秀的 jQuery 插件应具备的两个最重要特征如下：
- en: It should apply on all the elements of the jQuery Collection Object it is invoked
    on whenever applicable
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该在适用的情况下应用于被调用的jQuery集合对象的所有元素
- en: It should allow further chaining of other jQuery methods
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该允许其他jQuery方法的进一步链接
- en: Let's now move on and analyze each of these principles.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续分析这些原则的每一个。
- en: Working on Composite Collection Objects
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在复合集合对象上操作
- en: One of the most important features of jQuery methods is that they are applied
    on every item of the Composite Collection Object that they are invoked on. As
    an example, the `$.fn.addClass()` method adds one or more CSS classes to every
    item of the collection after individually checking whether each class has already
    been defined on each individual element.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery方法最重要的一个特点是，它们应用于被调用的复合集合对象的每个项。例如，`$.fn.addClass()`方法在分别检查每个类是否已经在每个单独的元素上定义之后，将一个或多个CSS类添加到集合的每个项上。
- en: As a result, our jQuery plugins should also follow this principle by operating
    on every element of a collection, when such a thing seems logical. If you are
    using only jQuery methods in your plugin's implementation, most of the time, you
    get this for free. On the other hand, an important consideration to bear in mind
    is that not all jQuery methods operate on every element of a collection object.
    Methods like `$.fn.html()`, `$.fn.css()` and `$.fn.data()` apply on all the items
    of the collection when used as setter methods, but operate only on the first element
    when used as getters.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我们的jQuery插件也应该遵循这个原则，即在逻辑上合理时操作集合的每个元素。如果您的插件实现中仅使用jQuery方法，大多数情况下，您可以免费获得这一点。另一方面，需要牢记的一点是，并非所有的jQuery方法都作用于集合对象的每个元素。像`$.fn.html()`、`$.fn.css()`和`$.fn.data()`这样的方法用作setter方法时会作用于集合的所有项，但用作getter时只作用于第一个元素。
- en: 'Let''s see an example implementation of a plugin that uses `$.fn.animate()`
    to create a shake effect on all items of a jQuery object:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用`$.fn.animate()`在jQuery对象的所有项目上创建抖动效果的插件的示例实现：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Invoking this plugin with `$('button').vibrate();` applies the shaking animation
    on every matched element of the page. To achieve that, the plugin changes the
    `left` CSS property of all matched elements using the `$.fn.animate()` method,
    which conveniently operates on every element. On the other hand, since the `$.fn.css()`
    method applies only on the first element of the collection when used as a getter,
    we had to iterate over all the elements using the `$.fn.each()` method and ensure
    that each of them was not statically positioned, in which case the `left` CSS
    property would not affect its appearance.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 用`$('button').vibrate();`调用此插件将对页面中的每个匹配元素应用抖动动画。为了实现这一点，插件使用`$.fn.animate()`方法改变所有匹配元素的`left`
    CSS属性，该方法方便地操作每个元素。另一方面，由于`$.fn.css()`方法作为getter使用时只应用于集合的第一个元素，我们必须使用`$.fn.each()`方法迭代所有元素，并确保每个元素都不是静态定位，否则`left`
    CSS属性将不会影响其外观。
- en: Obviously, using only jQuery methods is not always sufficient for the implementation
    of a plugin. In most cases, a new plugin will have to use at least one non-jQuery
    API for its implementation, requiring us to iterate over the items of the collection
    and apply the logic of the plugin to each of them individually. The same approach
    should be used when each element of the collection has to be handled slightly
    differently based on its state.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，仅仅使用jQuery方法并不总是足够实现插件。在大多数情况下，一个新插件将至少需要使用一个非jQuery API来实现，这要求我们迭代集合的项目，并逐个应用插件的逻辑。当集合的每个元素的状态有所不同时，也应该使用相同的方法进行处理。
- en: As a result, it is quite common for plugins to wrap almost all of their implementations
    inside a `$.fn.each()` invocation. By recognizing the common needs that are covered
    by explicit iteration, the jQuery team and most jQuery plugin boilerplates now
    make it part of their standard practice.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，插件通常会在`$.fn.each()`的调用中包装几乎所有的实现。通过识别显式迭代所涵盖的常见需求，jQuery团队和大多数jQuery插件样板现在将其作为标准做法的一部分。
- en: Allowing further chaining
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 允许进一步的链接
- en: 'In general, when your plugin''s code does not need to return anything, all
    that you have to do to enable further chaining is to add a `return this;` statement
    to its last line, as we saw in the previous example. Make sure that all the code
    paths return a reference of the invocation context (`this`) or another relevant
    jQuery collection object, in the same way that `$.fn.parent()` and `$.fn.find()`
    do. Alternatively, when all your code is wrapped inside another jQuery method,
    such as `$.fn.each()`, it is common practice to simply return the result of that
    invocation, as demonstrated below:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当您的插件代码不需要返回任何内容时，为了启用进一步的链式操作，您只需在其最后一行添加一个`return this;`语句，就像我们在上一个示例中看到的那样。确保所有的代码路径都返回调用上下文（`this`）的引用或另一个相关的jQuery集合对象，就像`$.fn.parent()`和`$.fn.find()`一样。或者，当您的所有代码都包裹在另一个jQuery方法内部时，例如`$.fn.each()`，通常的做法是简单地返回该调用的结果，如下所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Keep in mind that, if your code manipulates the collection object that it was
    invoked on, instead of returning the `this` reference, you might need to return
    the new collection that was the result of your plugin's manipulations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果您的代码操作了它被调用的集合对象，而不是返回`this`引用，您可能需要返回插件操作的新集合对象。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You should avoid basing your plugin's implementation on a return value in order
    to allow further chaining. Instead of doing that, it is preferable to initialize
    the plugin on its first invocation and then provide some overloaded ways to invoke
    it, as a way of returning values.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该避免将插件的实现基于返回值以允许进一步的链式操作。而不是这样做，最好是在其第一次调用时初始化插件，然后提供一些重载的方式来调用它，作为返回值的一种方式。
- en: Working with $.noConflict()
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用$.noConflict()操作
- en: The first step to improve a plugin's implementation is to make it work in environments
    that do not have access to the `$` identifier. An example of this is when a web
    page uses the `jQuery.noConflict()` method, which prevents jQuery from assigning
    itself to the `$` global identifier (or `window.$`) and keeps it available only
    on the `jQuery` namespace (`window.jQuery`).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 改进插件实现的第一步是使其在无法访问`$`标识符的环境中工作。其中一个示例是当网页使用`jQuery.noConflict()`方法时，它会阻止jQuery将自身分配给`$`全局标识符（或`window.$`），并且仅将其保留在`jQuery`命名空间（`window.jQuery`）上。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `jQuery.noConflict()` method allows us to prevent jQuery from conflicting
    with other libraries and implementations that also happen to use the `$` variable.
    For more information, you can visit the jQuery documentation page at: [http://api.jquery.com/jQuery.noConflict/](http://api.jquery.com/jQuery.noConflict/)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`jQuery.noConflict()`方法允许我们防止jQuery与其他库和实现发生冲突，这些库和实现也可能使用`$`变量。有关更多信息，请访问jQuery文档页面：[http://api.jquery.com/jQuery.noConflict/](http://api.jquery.com/jQuery.noConflict/)'
- en: In such cases, the plugin definition would throw an **$ is not defined** error
    or even worse; it might try to use the `$` variable that the developer has reserved
    to use in an implementation, leading to errors that are hard to debug.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，插件定义会抛出**$ is not defined**错误，甚至更糟的是；它可能会尝试使用开发人员保留用于实现的`$`变量，导致难以调试的错误。
- en: 'Fortunately, the changes required to fix this problem are easy to implement
    and do not affect the functionality of the plugin. All that we have to do is rename
    all of the occurrences of the `$` identifier in our plugin with `jQuery`, as shown
    below:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，修复这个问题所需的更改很容易实现，并且不会影响插件的功能。我们所要做的就是将插件中所有的`$`标识符的出现都重命名为`jQuery`，如下所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Wrapping with an IIFE
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用IIFE包装
- en: The next best practice to follow is to wrap the definition and implementation
    of our plugin with an IIFE. This not only makes our plugin look like the **Module
    Pattern** but also makes our implementation more robust by adding several other
    benefits to it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循的下一个最佳实践是使用IIFE包装我们的插件的定义和实现。这不仅使我们的插件看起来像**模块模式**，而且通过为其增加几个其他好处，使我们的实现更加健壮。
- en: 'First of all, the IIFE pattern allows us to create and use private variables
    and functions in the context of the plugin''s definition. These variables are
    shared across all the instances of the plugin in a similar way to how static variables
    work in other programming languages, enabling us to use them as synchronization
    points between the plugin instances:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，IIFE模式允许我们在插件定义的上下文中创建和使用私有变量和函数。这些变量与插件的所有实例共享，类似于其他编程语言中静态变量的工作方式，使我们能够将它们用作插件实例之间的同步点：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Otherwise, we would have to use something like `$.simplePlugin101._callCounter`
    or `$.simplePlugin101._utilityLogMethod()` to emulate privacy, which is just a
    naming convention and does not provide any actual privacy.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们将不得不使用类似`$.simplePlugin101._callCounter`或`$.simplePlugin101._utilityLogMethod()`这样的东西来模拟隐私，这只是一种命名约定，并不提供任何实际的隐私。
- en: The second benefit, as demonstrated in the above example, is that it allows
    us to use the `$` identifier again to access jQuery with no concerns about conflicts.
    In order to achieve this, we are passing the jQuery namespace variable as an invocation
    parameter to our IIFE and use the `$` identifier to name the respective parameter.
    In this way, we effectively alias the jQuery namespace to `$` in the context created
    by the IIFE, enabling us to use the minimal `$` identifier in our implementation
    to keep our code slim and readable, even if `jQuery.noConflict()` is used.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如上例所示，第二个好处是，它允许我们再次使用`$`标识符来访问jQuery，而不必担心冲突。为了实现这一点，我们将jQuery命名空间变量作为调用参数传递给我们的IIFE，并使用`$`标识符来命名相应的参数。通过这种方式，我们有效地将jQuery命名空间别名为`$`，使我们可以在IIFE创建的上下文中使用最小的`$`标识符来使我们的代码简洁可读，即使使用了`jQuery.noConflict()`也是如此。
- en: 'Additionally, adding the `use strict;` statement on the top of our IIFE helps
    us to eliminate any leaking of variables into the global namespace. For example,
    the following code would throw a **ReferenceError: assignment to undeclared variable
    x** error during the invocation of the plugin''s method, enabling us to catch
    those errors during the development phase of the plugin helping produce a more
    robust final implementation:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '另外，在我们的IIFE顶部添加`use strict;`语句有助于消除变量泄漏到全局命名空间的问题。例如，以下代码在调用插件方法时会抛出**ReferenceError:
    assignment to undeclared variable x**错误，这使我们能够在插件开发阶段捕获这些错误，从而产生更健壮的最终实现：'
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about JavaScript''s strict execution mode, you can visit:
    [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于JavaScript严格执行模式的信息，请访问：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)
- en: 'Finally, this pattern, as with all the namespace aliasing practices that use
    IIFEs, can also help increase the gains when minifying your plugin''s source code,
    when compared to an implementation that references the jQuery namespace variable
    directly. In an attempt to maximize the benefits of this technique, it''s also
    common to alias all the global namespace variables that our plugin accesses, as
    demonstrated below:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，与所有使用IIFE的命名空间别名实践一样，此模式也可以帮助增加在缩小插件源代码时的收益，与直接引用jQuery命名空间变量的实现相比。为了最大化此技术的好处，还常常将插件访问的所有全局命名空间变量都别名化，如下所示：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Creating reusable plugins
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可重复使用的插件
- en: After analyzing the most important aspects of the development of jQuery plugins,
    we are now ready to analyze an implementation that is used for something more
    than a simple demonstration. In order to create a really useful and reusable plugin,
    it must be designed such that its operations are not restricted by the demands
    of its original use case.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析了jQuery插件开发的最重要方面之后，我们现在准备分析一个用于更多功能的实现，而不仅仅是一个简单的演示。为了创建一个真正有用且可重复使用的插件，必须设计得这样，使其操作不受其原始用例的要求限制。
- en: The most popular plugins, like the most useful jQuery methods, are those that
    provide a high degree of configuration of their functionality. Creating a plugin
    that is configurable adds a degree of flexibility to its implementation, which
    enables us to match the needs of several other use cases that are governed by
    the same operation principles.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的插件，就像最有用的jQuery方法一样，是那些提供了高度配置其功能的插件。创建可配置的插件为其实现增加了一定的灵活性，使我们能够满足由相同操作原则控制的其他多个用例的需求。
- en: As we said earlier, a jQuery plugin is just a function attached to the `$.fn`
    object and, as a result, we can make its implementation more abstract and generic
    in the same way as with plain functions of our modules. As in simple functions,
    the easiest way to differentiate the operation of a jQuery plugin is by using
    invocation parameters. A plugin that exposes a lot of configuration parameters
    has great potential of being able to be match the requirements of several different
    use cases.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，一个jQuery插件只是附加到`$.fn`对象的函数，因此我们可以将其实现更加抽象和通用，就像我们的模块的简单函数一样。与简单函数一样，区分jQuery插件的操作最简单的方法是使用调用参数。一个暴露了许多配置参数的插件有很大的潜力能够满足几种不同用例的要求。
- en: Accepting configuration parameters
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受配置参数
- en: In contrast to how we implement functions that usually accept up to five arguments
    and still have a manageable and relatively clean API, this practice does not work
    so well with jQuery plugins. In order to expose a clear API and maintain a high
    level of usability, regardless of the various configuration options that are exposed,
    most jQuery plugins provide a minimal API that accepts up to three invocation
    arguments. This is achieved by using dedicated setting objects with a specific
    format, as a way of encapsulating multiple options and passing them as a single
    argument. Another approach is to expose an API with two parameters, where the
    first one is a regular value that defines the operation of the plugin and the
    second one is used to wrap the less important configuration options.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们通常接受高达五个参数但仍具有可管理和相对清晰API的函数的实现方式形成对比，这种做法在jQuery插件中效果不佳。为了暴露清晰的API并保持高可用性，无论暴露了哪些不同的配置选项，大多数jQuery插件都提供了一个最小的API，接受高达三个调用参数。这是通过使用具有特定格式的专用设置对象来实现的，作为一种封装多个选项并将它们作为单个参数传递的方法。另一种方法是使用两个参数暴露API，其中第一个是定义插件操作的常规值，第二个用于包装不太重要的配置选项。
- en: A great example of both of these practices is the `$.ajax(settings)` method,
    which is invoked with a single settings object as a parameter to define how it
    should operate, but also exposes another overloaded way to be invoked with two
    arguments. The two argument overload is invoked with `$.ajax(url, settings)`,
    where the first is the target URL for the HTTP request and the second is an object
    with the rest configuration options. What applies to both of them is that the
    method itself contains a set of sensible defaults that are used instead of any
    configuration parameter that the user has not defined. Moreover, the second overload
    also defines the second parameter as optional and, if that was not provided during
    its invocation, it bases its operation on the default settings.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些做法的一个很好的例子是`$.ajax(settings)`方法，它通过单个设置对象作为参数调用以定义其操作方式，但还暴露了另一个重载的方式，以两个参数调用。两个参数重载通过`$.ajax(url,
    settings)`调用，其中第一个是HTTP请求的目标URL，第二个是具有其余配置选项的对象。对它们都适用的是，方法本身包含一组明智的默认值，用于替代用户未定义的任何配置参数。此外，第二种重载还将第二个参数定义为可选参数，如果在其调用过程中未提供，则其操作将基于默认设置。
- en: 'Adopting the settings object practice in our plugins not only brings all the
    aforementioned benefits, but also allows us to extend the implementation in a
    more scalable way, since the addition of an extra configuration parameter has
    little effect on the rest of its API. As an example of this, we will reimplement
    the `$.fn.vibrate` plugin that we saw earlier in this chapter in a more generic
    way, so that a setting object with default values is used for its configuration:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的插件中采用设置对象实践不仅带来所有上述的好处，还允许我们以更具可扩展性的方式扩展其实现，因为添加额外的配置参数对其API的其余部分几乎没有影响。作为这一点的例子，我们将在更通用的方式中重新实现我们在本章中早些时候看到的`$.fn.vibrate`插件，以便使用具有默认值的设置对象来进行配置：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In contrast to the original fixed implementation, this one accepts a single
    object as an invocation parameter which wraps four different options that can
    be used to diversify the operation of the plugin. The options object allows us
    to diversify the operation of the plugin by exposing four customization points:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始固定实现相比，这个实现接受一个作为调用参数的单个对象，其中包装了四个可以用于使插件操作多样化的不同选项。通过暴露四个定制点，选项对象允许我们通过暴露四个定制点来使插件的操作多样化：
- en: The number of loops that the shake effect should run
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抖动效果应该运行的循环数
- en: The amplitude of the animation, as a means of controlling how much an element
    should move away from its original position
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画的振幅，作为控制元素应该离其原始位置移动多少的手段
- en: The period of each loop, as a means of controlling how fast the movement will
    be
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个循环的周期，作为控制运动速度的手段
- en: The direction of the animation, which is horizontal when `left` is used or vertical
    when `top` is used
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画的方向，当使用`left`时是水平的，或者当使用`top`时是垂直的
- en: By following a widely accepted best practice, we have defined all the default
    values for the configuration options as a separate object. This pattern not only
    allows us to gather all the related values under a single object, but also enables
    us to use the `$.extend()` method as an effective way of composing all the defined
    options with the default values of the undefined ones. We can thus avoid checking
    explicitly for the existence of each individual property, reducing the complexity
    and the size of our code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循广泛接受的最佳实践，我们将所有配置选项的默认值定义为一个单独的对象。这种模式不仅允许我们将所有相关值收集到单个对象下，而且还使我们能够使用`$.extend()`方法有效地将所有已定义选项与未定义选项的默认值组合在一起。因此，我们可以避免明确检查每个单独属性的存在，从而减少了代码的复杂性和大小。
- en: In brief, the `$.extend()` method returns the object passed as its first argument
    after merging the properties of the subsequent objects together into the first
    object. As a result, the returned object will contain all the default values except
    those that were defined in the options object that was passed as an invocation
    parameter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`$.extend()`方法在将后续对象的属性合并到第一个对象中后返回第一个参数传递的对象。因此，返回的对象将包含除了在调用参数中定义的选项对象中定义的默认值之外的所有默认值。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about the `$.extend()` helper method, you can visit the
    documentation page at: [http://api.jquery.com/jQuery.extend/](http://api.jquery.com/jQuery.extend/)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`$.extend()`助手方法的更多信息，您可以访问文档页面：[http://api.jquery.com/jQuery.extend/](http://api.jquery.com/jQuery.extend/)
- en: Moreover, instead of using a simple variable, we are exposing the default options
    object as a property of the plugin's function, enabling users to change them to
    better suit their needs. As an example, consider a case in which a smooth animation
    is required for the needs of a specific application. By setting `$.fn.vibrate.defaultOptions.period
    = 250,` the developer would completely remove the need to specify the `period`
    option in every invocation of the plugin, which would lead to an implementation
    with less repetitive code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们没有使用简单的变量，而是将默认选项对象公开为插件函数的属性，使用户可以根据自己的需要进行更改。例如，考虑需要特定应用程序的平滑动画的情况。通过设置`$.fn.vibrate.defaultOptions.period
    = 250`，开发人员将完全消除在每次调用插件时指定`period`选项的需要，这将导致具有更少重复代码的实现。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The jQuery library itself adopts this practice for defining the default configuration
    parameters of the `$.ajax()` method. Because of the increased complexity of this
    method, jQuery provides us with the `jQuery.ajaxSetup()` method as a way of setting
    up the default parameters for every AJAX request.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery库本身采用了此实践来定义`$.ajax()`方法的默认配置参数。由于此方法的复杂性增加，jQuery为我们提供了`jQuery.ajaxSetup()`方法，作为设置每个AJAX请求的默认参数的一种方式。
- en: Finally, in order to create a generic variant of the original implementation
    and utilize the aforementioned configuration options, we replaced the four fixed
    invocations of the `$.fn.animate()` method of the original implementation with
    a `for` loop that utilized the `loops` option. Inside the `for` loop itself, we
    construct the parameters for each call of the `$.fn.animate()` method and briefly
    alternate the direction of the animated movement on each subsequent execution
    of the loop, and also ensure that the first and last movements have half of the
    time duration and half of the shift of all of the other steps.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了创建原始实现的通用变体并利用上述配置选项，我们用使用了`for`循环来替换了原始实现的`$.fn.animate()`方法的四个固定调用。在`for`循环内部，我们构造每次调用`$.fn.animate()`方法的参数，并在每次循环的后续执行中简要地交替动画移动的方向，并确保第一个和最后一个动作的时间持续时间和所有其他步骤的位移的一半。
- en: 'The final implementation can be configured to produce different animations,
    based on the needs of each specific use case, ranging from short horizontal animations
    that are ideal for notifying a user about an invalid action, to vertical long
    animations that look like a levitation effect. The plugin can be invoked with
    any combination of the aforementioned options, use the default values for missing
    options and even operate with no invocation argument, as shown below:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的实现可以配置为产生不同的动画，根据每个特定用例的需求而变化，从适用于通知用户无效操作的短水平动画，到看起来像漂浮效果的垂直长动画。插件可以以任何组合的前述选项调用，对于缺失选项使用默认值，甚至在没有调用参数的情况下运行，如下所示：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Writing stateful jQuery plugins
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写具有状态的 jQuery 插件
- en: The plugin implementations that we have looked at so far were stateless since,
    after completing their execution, they revert their manipulations on the DOM's
    state and don't leave allocated objects in the browser's memory. As a result,
    subsequent invocations of stateless plugins always produce the same results.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看过的插件实现是无状态的，因为在完成执行后，它们会恢复对 DOM 状态的操作，并且不会在浏览器内存中保留分配的对象。因此，对无状态插件的后续调用始终产生相同的结果。
- en: As you can probably guess, such plugins have limited applications since they
    can't be used to create a series of complex interactions with the user of the
    web page. In order to orchestrate complex user interactions, a plugin needs to
    preserve an internal state with the actions taken up to that point in order to
    change its operation mode appropriately and handle subsequent interactions. Comparing
    the characteristic of stateful and stateless plugins could be defined as the equivalent
    to comparing plain (static) functions with methods that are part of an object
    and can operate on its state.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到，这种插件的应用范围有限，因为它们无法用于创建与网页用户的一系列复杂交互。为了协调复杂的用户交互，插件需要保持内部状态，以记录到目前为止采取的操作，并适当地改变其操作模式并处理后续交互。比较具有状态和无状态插件的特性可以定义为将普通（静态）函数与是对象的一部分并可以对其状态进行操作的方法进行比较。
- en: Another popular category of plugins, in which having an internal state is essential,
    is the family of plugins that manipulate the DOM tree. These plugins usually create
    complex element structures such as a rich text editors, date pickers and calendars,
    commonly by building on a user-defined empty `<div>` element.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的插件类别是必须具有内部状态的类别，这是操纵 DOM 树的插件系列。这些插件通常创建复杂的元素结构，如富文本编辑器、日期选择器和日历，通常是通过在用户定义的空白
    `<div>` 元素上构建。
- en: Implementing a stateful jQuery Plugin
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个具有状态的 jQuery 插件
- en: As an example of the patterns used for the implementation of plugins of this
    family, we will write a generic **Element Mutation** **Observer** plugin. This
    plugin will provide us with a convenient way of adding event listeners for changes
    to the DOM tree that originate from any of the elements that this plugin was invoked
    on. As a way of achieving that, the following implementation uses the **MutationObserver**
    API, which, at the time of writing, is implemented by all modern browsers and
    is available to more than 86% of web users.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实现这类插件的模式的示例，我们将编写一个通用的 **元素变异观察器** 插件。该插件将为我们提供一种方便的方法，用于添加对来自该插件所调用的任何元素的
    DOM 树更改的事件侦听器。为了实现这一点，以下实现使用了 **MutationObserver** API，在撰写本文时，该 API 已由所有现代浏览器实现，并且可供超过
    86% 的网络用户使用。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on the Mutation Observer, you can visit: [https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Mutation Observer 的更多信息，请访问：[https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)
- en: 'Let''s now proceed with the implementation and analyze the practices that were
    used:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续实施并分析所使用的做法：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Firstly, we define our plugin inside an IIFE, as recommended earlier in this
    chapter. Right after the declaration of the plugin on the `$.fn` object, we use
    the `$.fn.each()` method as a direct approach to ensure that the functionality
    of our plugin is applied to every item of the jQuery Collection Object that it
    was invoked on.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在 IIFE 内部定义我们的插件，正如本章前面建议的那样。在插件在 `$.fn` 对象上的声明之后，我们使用 `$.fn.each()` 方法作为直接方法，以确保我们的插件的功能应用于调用它的
    jQuery Collection Object 的每个项目。
- en: Two of the main issues that stateful plugin implementations have is the lack
    of a mechanism to preserve the internal state of each instantiation of the plugin
    and a way of avoiding being initialized many times on the same page element. In
    order to solve both of these problems, we need to use something like a hash table
    in which the key is the element itself and the value is an object with the state
    of the plugin's instance.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态插件实现的两个主要问题之一是缺乏保留每个插件实例内部状态的机制，以及避免在同一页面元素上多次初始化的方法。为了解决这两个问题，我们需要使用类似哈希表的东西，其中键是元素本身，值是插件实例状态的对象。
- en: Fortunately, this is more or less how the `$.fn.data()` method works by associating
    DOM elements and JavaScript object values using specific string keys. By using
    the `$.fn.data()` method and the plugin's name as an association key, we are able
    to store and retrieve the state object of our plugin very easily.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这或多或少是`$.fn.data()`方法的工作原理，通过使用特定的字符串键将 DOM 元素和 JavaScript 对象值关联起来。通过使用`$.fn.data()`方法和插件的名称作为关联键，我们能够非常容易地存储和检索我们插件的状态对象。
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Using the `$.fn.data()` method for this use case is considered a best practice
    and is used by most stateful plugin implementations and boilerplates since it
    is a robust part of jQuery that enables us to reduce the size of our plugin's
    implementation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种用例，使用`$.fn.data()`方法被认为是一种最佳实践，并且被大多数有状态插件实现和样板文件使用，因为它是 jQuery 的一个强大的部分，可以使我们减少插件实现的大小。
- en: If an existing state object is not found then we can assume that the plugin
    is not yet initialized on that specific element and start its initialization right
    away. The state object of this plugin will contain the instance of the active
    MutationObserver responsible for tracking the changes that happen on the observed
    DOM element, and an array with all the callbacks that have subscribed to it to
    get notifications about changes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到现有的状态对象，则可以假定插件尚未在该特定元素上初始化，并立即开始初始化。该插件的状态对象将包含负责跟踪观察的 DOM 元素上发生的更改的活动
    MutationObserver 实例，并且一个订阅它以获得关于更改通知的所有回调的数组。
- en: After creating a new MutationObserver instance, we configure it to look for
    three specific types of DOM changes and instruct it to invoke all the callbacks
    of the plugin's state object whenever such DOM changes occur. Finally, we create
    the state object itself to hold the observer and the associated callbacks and
    use the `$.fn.data()` method as a setter and associate it with the page element.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的 MutationObserver 实例后，我们将其配置为查找三种特定类型的 DOM 更改，并指示它在发生此类 DOM 更改时调用插件状态对象的所有回调。最后，我们创建状态对象本身来保存观察者和关联的回调，并使用`$.fn.data()`方法作为设置器，并将其与页面元素关联。
- en: After ensuring that the plugin is instantiated and initialized on the provided
    element, we check whether the plugin is invoked with a function as a parameter
    and, if so, we add it to the list of the plugin's callbacks.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在确保插件在提供的元素上被实例化和初始化之后，我们检查插件是否以函数作为参数调用，如果是，则将其添加到插件的回调列表中。
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Keep in mind that using a single MutationObserver instance per element and having
    it notify about DOM changes by iterating over an array of callbacks greatly reduces
    the memory requirements of the implementation, just like when we are using a single
    delegate observer.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，对于每个元素使用单个 MutationObserver 实例，并通过迭代回调数组通知 DOM 更改，可以大大减少实现的内存需求，就像我们使用单个委托观察器时一样。
- en: 'An example of using our newly implemented plugin to observe for changes of
    a specific DOM element would look like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们新实现的插件来观察特定 DOM 元素的更改的示例如下：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Destroying a plugin instance
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 销毁插件实例
- en: 'An extra consideration that a stateful plugin has to take into account is offering
    the developer a way to reverse the changes that it introduced to the state of
    the page. The most common and simple API for achieving this is to invoke the plugin
    with the `destroy` literal as its first parameter. Let''s proceed with the required
    implementation changes:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态插件必须考虑的额外因素是为开发人员提供一种方式来撤销它对页面状态引入的更改。实现这一点的最常见和简单的 API 是使用`destroy`字面量作为其第一个参数调用插件。让我们继续进行所需的实现更改：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In order to adapt our implementation to the above requirement, all we had to
    do was to check whether the plugin was invoked with the `destroy` string value
    as its first parameter, right after retrieving the plugin''s state object. If
    we find that the plugin has already been instantiated on the specified element
    and that the `destroy` string value has been used, we can proceed to stop the
    Mutation Observer itself and clear the association that `$.fn.data()` created
    by using the `$.fn.removeData()` method. Finally, at the end of the `if` statement
    we added a `return` statement since, after completing the destruction of the plugin
    instance, we no longer need to execute any other code. An example of destroying
    a plugin instance with this implementation would look like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的实现适应上述需求，我们所要做的就是在检索插件状态对象后检查插件是否以`destroy`字符串值作为其第一个参数调用。如果我们发现插件已经被实例化在指定的元素上，并且已经使用了`destroy`字符串值，我们就可以继续停止
    Mutation Observer 本身，并清除`$.fn.data()`创建的关联，方法是使用`$.fn.removeData()`方法。最后，在`if`语句的结尾处，我们添加了一个`return`语句，因为在完成销毁插件实例后，我们不再需要执行任何其他代码。使用此实现销毁插件实例的示例如下所示：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Implementing getter and setter methods
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现获取器和设置器方法
- en: By using the same technique that we demonstrated earlier for the implementation
    of the `destroy` method of our plugin, we can provide several other overloaded
    ways to invoke our plugin that work like normal methods. This pattern is not only
    used by plain jQuery plugins, but is also adopted by more complex plugin architectures,
    as with jQuery-UI.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用我们先前展示的与插件的`destroy`方法的实现相同的技术，我们可以提供几种其他重载的方式来调用我们的插件，这些方式就像普通的方法一样工作。这种模式不仅被普通的
    jQuery 插件所使用，而且还被更复杂的插件架构所采用，就像 jQuery-UI 一样。
- en: On the other hand, we might end up with a plugin implementation that results
    in a large number of invocation overloads, which is something that would make
    it difficult to use and document. A way to work around this is to combine the
    getter and setter methods of your API into multi-purpose methods. This not only
    reduces the API surface of your plugin so that a developer has to remember fewer
    method names but it also increases the productivity since the same pattern is
    used in many jQuery methods like `$.fn.html()`, `$.fn.css()`, `$.fn.prop()`, `$.fn.val()`,
    and `$.fn.data()`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可能会得到一个插件实现，结果是大量调用重载，这会使其难以使用和文档化。解决这个问题的一种方法是将 API 的获取器和设置器方法合并成多用途方法。这不仅减少了插件的
    API 表面，使开发人员需要记住的方法名称更少，而且还增加了生产力，因为在许多 jQuery 方法中都使用了相同的模式，比如`$.fn.html()`、`$.fn.css()`、`$.fn.prop()`、`$.fn.val()`和`$.fn.data()`。
- en: 'As a demonstration of this, let''s see how we can add a new method to our MutationObserver
    plugin that works both as a getter and a setter for the registered callbacks:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对此的演示，让我们看看如何为我们的 MutationObserver 插件添加一个新方法，该方法既作为获取器又作为注册回调的设置器：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As shown in the above code, we have created an overloaded invocation method
    which uses the `callbacks` string value as the first argument of the plugin invocation.
    This getter and setter method allows us to retrieve or overwrite all of the callbacks
    that are registered on the MutationObserver and works in addition to the pre-existing
    methods for invoking the plugin, by using a function parameter and the `destroy`
    method.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如上面的代码所示，我们已经创建了一个重载的调用方法，该方法使用`callbacks`字符串值作为插件调用的第一个参数。这个获取器和设置器方法允许我们检索或覆盖注册在
    MutationObserver 上的所有回调，并且与使用函数参数和`destroy`方法的预先存在的调用插件方法一起使用。
- en: The getter and setter implementation is based on the assumption that, when trying
    to use the `callbacks` method as a getter, you don't need to pass any extra parameters
    and, when trying to use it as a setter, you will pass an extra array as an invocation
    parameter. In order to support the getter variant, which prevents further chaining
    and only operates on the first element of the composite collection, we had to
    declare and use the `result` variable which is initialized to the value of the
    `this` identifier. If the `callbacks` getter is used, we assign the `callbacks`
    of the first element of the collection to the `result` variable and break out
    of the `$.fn.each()` iteration by returning `false` to finish the execution of
    the plugin's method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: getter 和 setter 的实现基于这样的假设：当尝试将 `callbacks` 方法用作 getter 时，你不需要传递任何额外的参数；当尝试将其用作
    setter 时，你将传递一个额外的数组作为调用参数。为了支持 getter 变体，该变体防止进一步的链式操作，仅对复合集合的第一个元素进行操作，我们不得不声明并使用
    `result` 变量，该变量初始化为 `this` 标识符的值。如果使用 `callbacks` getter，则将集合的第一个元素的 `callbacks`
    分配给 `result` 变量，并通过返回 `false` 以结束插件方法的执行来退出 `$.fn.each()` 迭代。
- en: 'Here is an example use case for our newly implemented getter and setter method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们新实现的 getter 和 setter 方法的一个示例用例：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Keep in mind that invocation overloads that prevent further chaining by returning
    non-jQuery object results should be well documented since this technique conflicts
    with the chaining principle that everyone expects to work.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，防止进一步链式调用的调用重载应该有很好的文档记录，因为这种技术与每个人都期望工作的链式原则相冲突。
- en: Using our plugin in our Dashboard application
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的仪表板应用程序中使用我们的插件
- en: 'After completing our `mutationObserver` plugin, lets now see how we can use
    it for the implementation of the `counter` sub-module that we used in our Dashboard''s
    implementation in previous chapters:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 完成我们的 `mutationObserver` 插件后，现在让我们看看如何将其用于我们在前几章中在仪表板实现中使用的 `counter` 子模块的实现：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see in the above implementation, our plugin abstracts nicely and
    replaces the old implementation by providing a generic, flexible and reusable
    API. Instead of listening for click events on the different buttons of the page,
    the implementation is now using the `mutationObserver` plugin and observes the
    `boxContainer` element for the additions or removals of child elements. Moreover,
    this implementation change does not affect the functionality of the `counter`
    module which appears to work in the same way since all the changes are encapsulated
    in the module.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上面的实现中所看到的，我们的插件很好地抽象并替换了旧的实现，提供了一个通用、灵活和可重用的 API。现在，该实现不再监听页面上不同按钮的点击事件，而是使用
    `mutationObserver` 插件并观察 `boxContainer` 元素以查看子元素的添加或移除。此外，此实现更改不会影响 `counter`
    模块的功能，因为所有更改都封装在模块中。
- en: Using the jQuery Plugin Boilerplate
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 jQuery 插件模板
- en: The jQuery Boilerplate project, which is available at [https://github.com/jquery-boilerplate/jquery-patterns](https://github.com/jquery-boilerplate/jquery-patterns),
    offers several templates that can be used as starting points for the implementation
    of robust and extensible plugins. These templates incorporate a lot of best practices
    and design patterns such as those analyzed earlier in this chapter. Each of the
    templates packs a number of best practices that work well together, in an attempt
    to provide good starting points that better match the various use cases.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery Boilerplate 项目位于 [https://github.com/jquery-boilerplate/jquery-patterns](https://github.com/jquery-boilerplate/jquery-patterns)，提供了几个模板，可用作实现稳健且可扩展插件的起点。这些模板融合了许多最佳实践和设计模式，例如本章前面分析的那些。每个模板都包含了一些良好结合在一起的最佳实践，旨在提供更适合各种用例的良好起点。
- en: 'Perhaps the most widely used template is `jquery.basic.plugin-boilerplate`
    from Adam Sontag and Addy Osmani, which even though it is characterized as a generic
    template for beginners and above, successfully covers most aspects of jQuery plugin
    development. What makes this template unique is the Object-Oriented approach that
    it follows which is presented in such a way that it helps you write better structured
    code, without making it harder to introduce customizations on the implementation.
    Let''s proceed and analyze its source code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 或许最广泛使用的模板是Adam Sontag和Addy Osmani的`jquery.basic.plugin-boilerplate`，即使它被描述为一个适用于初学者及以上的通用模板，但仍成功地涵盖了jQuery插件开发的大多数方面。
    使这个模板独特的是它遵循的面向对象的方法，它以这样一种方式呈现，帮助您编写更好结构化的代码，而不会增加引入自定义实现的难度。 让我们继续分析其源代码：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The semi-colon right before the IIFE is there to avoid errors in case of unfortunate
    script concatenation (and possibly minification) with a file that might be missing
    an ending semi-colon. Right below, the boilerplate uses the `pluginName` variable
    as a DRY way of naming our plugin and using its name for any other case. As an
    added benefit, all that we have to do if we need to rename our plugin is change
    the value of this variable and rename the `.js` file of our plugin accordingly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: IIFE之前的分号是为了在不幸的脚本连接（以及可能的最小化）中避免错误，可能缺少结束分号的文件。 正如下面所示，样板使用`pluginName`变量作为DRY方式命名我们的插件并为任何其他情况使用其名称。
    作为附加好处，如果我们需要重命名插件，所有我们需要做的就是更改此变量的值，并相应地重命名我们插件的`.js`文件。
- en: 'Following the best practices that we saw earlier, a variable is used to hold
    the default options of the plugin and, as we can see a few lines later, it is
    merged with the user-provided options using the `$.extend()` method. Keep in mind
    that, if we want to expose the default options, all that we have to do is define
    it as part of the plugin''s namespace: `$.fn[pluginName].defaultOptions = defaults;`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循我们之前看到的最佳实践，使用一个变量来保存插件的默认选项，并且正如我们稍后看到的，它使用`$.extend()`方法将其与用户提供的选项合并。 请记住，如果我们想公开默认选项，所有我们需要做的就是将其定义为插件命名空间的一部分：`$.fn[pluginName].defaultOptions
    = defaults;`
- en: The actual plugin definition can be found near the end of this boilerplate code.
    Following the already discussed best practices, it iterates over the items of
    the collection using `$.fn.each()` and returns its result, which is equivalent
    to returning `this`. It then ensures that a plugin state instance exists for each
    item of the collection by using the `$.data()` method and the prefixed plugin
    name as an association key.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的插件定义可以在此样板代码的末尾找到。 遵循已经讨论过的最佳实践，它使用`$.fn.each()`迭代集合的项并返回其结果，这相当于返回`this`。
    然后，它通过使用`$.data()`方法和带有前缀的插件名称作为关联键，确保每个集合项都存在一个插件状态实例。
- en: The `Plugin` constructor function is used for the creation of the plugin's state
    object which, after storing the DOM element and the final plugin options as properties
    of the object, invokes the `init()` method of its prototype. The `init()` method
    is the suggested place to define our initialization code, for example, it could
    instantiate a new MutationObserver as we did earlier in this chapter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Plugin`构造函数用于创建插件状态对象，该对象在存储DOM元素和最终插件选项作为对象属性后，调用其原型的`init()`方法。 `init()`方法是定义初始化代码的建议位置，例如，它可以像本章前面所做的那样实例化新的MutationObserver。'
- en: Adding methods to your plugin
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向您的插件添加方法
- en: 'By default, every method that is defined as part of the prototype is only available
    for internal use. On the other hand, we can easily extend the above implementation
    to make a method available to all our users, as shown below:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，作为原型的一部分定义的每个方法仅供内部使用。 另一方面，我们可以轻松地扩展上述实现，以使方法对所有用户可用，如下所示：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: One guideline to follow when working with this boilerplate is to extend your
    plugin by adding extra methods to the `Plugin`'s prototype. Additionally, try
    to keep any modifications to the plugin's definition as small as possible, ideally
    single line method invocations.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此样板时要遵循的一个准则是通过向`Plugin`的原型添加额外方法来扩展您的插件。此外，尽量保持对插件定义的任何修改尽可能小，理想情况下是单行方法调用。
- en: 'In order to make the implementation more scalable, with regards to how the
    plugin methods are invoked and if we want to add an abstract approach for methods
    that are intended for internal or private use by the plugin, we can introduce
    the following changes:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使实现更具可扩展性，关于插件方法的调用方式以及如果我们想为插件添加一个抽象方法，该方法是为插件的内部或私有使用而设计的，我们可以引入以下更改：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the above implementation, we used the first argument to identify the method
    that needs to be invoked and then invoked it with the rest arguments. We also
    added a check to prevent the invocation of methods that start with an underscore
    which, according to common conventions, are intended to be for internal or private
    use. As a result, in order to add an extra method to your plugin's public API,
    we just need to declare it in the `Plugin.prototype` that we saw earlier.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述实现中，我们使用第一个参数来识别需要调用的方法，然后用剩余的参数来调用它。我们还添加了一个检查，以防止调用以下划线开头的方法，根据通常的约定，这些方法是用于内部或私有使用的。因此，为了向插件的公共
    API 添加额外的方法，我们只需在之前看到的`Plugin.prototype`中声明它。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Another great way to implement your plugin when you are already using jQuery-UI
    in your application is to use the `$.widget()` method which is also known as jQuery-UI
    Widget Factory. Its implementation abstracts several parts of the boilerplate
    code that we saw in this chapter and helps create complex and robust plugins.
    For more information, you can read the documentation at: [http://api.jqueryui.com/jQuery.widget/](http://api.jqueryui.com/jQuery.widget/)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当您已经在应用程序中使用 jQuery-UI 时，实现插件的另一种绝佳方式是使用`$.widget()`方法，也称为 jQuery-UI Widget
    工厂。其实现抽象了我们在本章中看到的几部分样板代码，并帮助创建复杂而健壮的插件。有关更多信息，您可以阅读文档：[http://api.jqueryui.com/jQuery.widget/](http://api.jqueryui.com/jQuery.widget/)
- en: Choosing a name
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择一个名字
- en: Lastly, after learning the best practices that we need to create a jQuery plugin,
    let's say something about the naming conventions and where to publish your new
    and shiny plugin.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在学习了我们需要创建 jQuery 插件的最佳实践之后，让我们谈谈命名约定和在哪里发布您的新而闪亮的插件。
- en: 'As you have probably already seen, most jQuery plugins use the following naming
    convention: jQuery-myPluginName for their project sites and repositories and store
    their implementations in a file named `jquery.mypluginname.js`. After settling
    on some prospective names for your plugin, take a moment and search the web to
    verify that there is no one else with the same project name. The jQuery documentation
    suggests searching for plugins on NPM and refining your results by using the `jquery-plugin`
    keyword. This is obviously the best way to publish your plugin so that it can
    be easily found by others.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经看到的那样，大多数 jQuery 插件使用以下命名约定：jQuery-myPluginName 作为其项目站点和存储库，并将其实现存储在名为`jquery.mypluginname.js`的文件中。在为插件选择一些可能的名称之后，请花一点时间在网络上搜索以验证是否有其他人使用相同的项目名称。jQuery
    文档建议在 NPM 上搜索插件，并使用`jquery-plugin`关键字来细化您的结果。这显然是发布您的插件的最佳方式，以便其他人可以轻松找到它。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about NPM, you can visit: [https://www.npmjs.com/](https://www.npmjs.com/)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 NPM 的更多信息，请访问：[https://www.npmjs.com/](https://www.npmjs.com/)
- en: Another popular place for searching and hosting JavaScript libraries is GitHub.
    You can find its repository search page at [https://github.com/search?l=JavaScript](https://github.com/search?l=JavaScript),
    where it filters the search results to include only JavaScript projects and searches
    for existing plugins and already used project names. Since in our case we are
    focusing on jQuery plugins, you will get better results by searching for project
    names that follow the aforementioned naming convention, jQuery-myPluginName.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索和托管 JavaScript 库的另一个热门地方是 GitHub。您可以在[https://github.com/search?l=JavaScript](https://github.com/search?l=JavaScript)找到其存储库搜索页面，其中它将搜索结果过滤为仅包含
    JavaScript 项目，并搜索现有插件和已使用的项目名称。由于在我们的情况下，我们专注于 jQuery 插件，因此通过搜索遵循前述命名约定的项目名称，jQuery-myPluginName，您将获得更好的结果。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Until recently, developers could search for existing plugins and register a
    new one at the official jQuery Plugin Registry ([http://plugins.jquery.com/](http://plugins.jquery.com/)).
    Unfortunately, it has been discontinued and now only allows searching for older
    plugins with no new submissions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，开发人员可以在官方的 jQuery 插件注册表 ([http://plugins.jquery.com/](http://plugins.jquery.com/))中搜索现有的插件并注册新的插件。不幸的是，它已经停止服务，现在只允许搜索旧的插件，不再接受新的提交。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we learned how jQuery can be extended by implementing and using
    plugins. We first saw an example of the simplest way that a jQuery plugin can
    be implemented and analyzed the characteristics that make a great plugin, and
    one which follows the principles of the jQuery library.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过实现和使用插件来扩展 jQuery。我们首先看到了一个 jQuery 插件可以实现的最简单方式的示例，并分析了使一个优秀的插件的特点，以及符合
    jQuery 库原则的插件。
- en: We were then introduced to the most common development patterns in the developer
    community for creating jQuery Plugins. We analyzed the implementation problems
    that each of them solves and the use cases that are a better match for them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后介绍了开发者社区中最常见的用于创建 jQuery 插件的开发模式。我们分析了每种模式解决的实现问题以及更适合它们的使用案例。
- en: After completing this chapter, we are now able to abstract parts of our applications
    into reusable and extensible jQuery plugins that are structured using the development
    pattern that best matches each use case.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，我们现在能够将应用程序的部分抽象为可重用和可扩展的 jQuery 插件，这些插件使用最适合每个使用案例的开发模式进行结构化。
- en: In the next chapter, we will present several optimization techniques that can
    be used to improve the performance of our jQuery applications, especially when
    they become large and complex. We will discuss simple practices such as using
    CDNs to load third-party libraries and continue with more advanced subjects such
    as lazy loading the modules of an implementation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍几种优化技术，可用于改善我们的 jQuery 应用程序的性能，特别是当它们变得庞大和复杂时。我们将讨论简单的实践，例如使用 CDN
    加载第三方库，并继续讨论更高级的主题，例如延迟加载实现的模块。
