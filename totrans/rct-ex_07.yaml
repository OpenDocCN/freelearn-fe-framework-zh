- en: Chapter 7. React Addons
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七章。React插件
- en: In the previous chapter, we learned to use React on the server side. We understood
    pre-rendering of the React components and changes in the component life cycle
    when using React on server. We also saw how to use server-side API of React using
    Express.js.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何在服务器端使用React。我们了解了在服务器端使用React时React组件的预渲染以及组件生命周期的变化。我们还看到了如何使用Express.js调用React的服务器端API。
- en: In this chapter, we will look at React addons—utility packages that are not
    a part of React core, however, they make development process fun and enjoyable.
    We will learn to use immutability helpers, cloning of components, and test utilities
    in this chapter. We will not be covering other addons such as `Animation`, `Perf`,
    and `PureRenderMixin`. These addons will be covered in the following chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨React插件——这些不是React核心库的一部分的实用程序包，但它们使开发过程变得有趣和愉快。我们将学习使用不可变辅助工具、组件克隆和测试实用工具。我们不会涵盖其他插件，如`Animation`、`Perf`和`PureRenderMixin`。这些插件将在下一章中介绍。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Getting started with React addons
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始学习React插件
- en: Immutability helpers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变辅助工具
- en: Cloning React components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆React组件
- en: Test helpers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试辅助工具
- en: Getting started with Addons
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始学习插件
- en: After completing the previous project about using React on server side, Mike's
    team got some free time before starting the next project. Mike decided to utilize
    this time by learning about React addons.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成关于在服务器端使用React的上一项目之后，迈克的团队在开始下一个项目之前有一些空闲时间。迈克决定利用这段时间来学习React插件。
- en: '"Shawn, we got some free time. Let''s use it to get started with React addons."'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，我们有了一些空闲时间。让我们利用这段时间开始学习React插件。"'
- en: '"What are React addons? Are they related to React core library?" Shawn asked.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '"什么是React插件？它们与React核心库有关吗？"肖恩问道。'
- en: '"React addons are utility modules that are not a part of the React core library.
    However, they are blessed by the React team. In future, some of them might be
    included in the React core. These libraries provide helpers for writing immutable
    code, utilities for testing React apps, and ways to measure and improve the performance
    of React apps." explained Mike.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '"React插件是React核心库之外的实用模块。然而，它们得到了React团队的认可。在未来，其中一些可能会被包含在React核心中。这些库提供了编写不可变代码的辅助工具、测试React应用的实用工具以及衡量和改进React应用性能的方法。"迈克解释道。'
- en: '"Each addon has its own npm package, making it to simple to use. For example,
    to use the Update addon, we need to install and require its npm package."'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '"每个插件都有自己的npm包，这使得使用变得非常简单。例如，要使用Update插件，我们需要安装并引入其npm包。"'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Immutability helpers
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变辅助工具
- en: '"Shawn, as we are learning about addons, let''s add the sorting feature to
    our app so that the users can sort the books by their titles. I have already added
    the required markup for it."'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，随着我们学习插件，让我们给我们的应用添加排序功能，这样用户就可以按标题排序书籍。我已经添加了所需的标记。"'
- en: '![Immutability helpers](img/4730_07_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![不可变辅助工具](img/4730_07_01.jpg)'
- en: '"Can you try writing the code for sorting when a user clicks on the **Title**
    heading?" Mark asked.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '"你能尝试编写当用户点击**标题**时进行排序的代码吗？"马克问道。'
- en: '"Here it is. I introduced the sorting state to indicate the direction of sorting—ascending
    or descending."'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '"这就是它。我引入了排序状态来指示排序方向——升序或降序。"'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '"When the user clicks on **Title**, it will sort the books stored in the existing
    state in ascending or descending order using the sort-by npm package and update
    the state with the sorted books."'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '"当用户点击**标题**时，它将使用sort-by npm包按升序或降序对现有状态中存储的书籍进行排序，并使用排序后的书籍更新状态。"'
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '"Shawn, this is functional; however, it''s not following the React way. React
    assumes that the state object is immutable. Here we are using reference to the
    books from the existing state when we are assigning value to `unsortedBooks`."'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，这是功能性的；然而，它并不遵循React的方式。React假设状态对象是不可变的。当我们为`unsortedBooks`赋值时，我们正在使用现有状态中对书籍的引用。"'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '"Later, we are mutating `unsortedBooks` into `sortedBooks`; however, as a side-effect,
    we are also mutating the current value of `this.state`."'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '"稍后，我们将`unsortedBooks`转换为`sortedBooks`；然而，作为副作用，我们也在修改`this.state`的当前值。"'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Immutability helpers](img/4730_07_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![不可变辅助工具](img/4730_07_02.jpg)'
- en: '"As you can see, even if we commented call to this.`setState`, our current
    state is still mutated." Mark explained.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '"正如你所见，即使我们注释掉了对this.`setState`的调用，我们的当前状态仍然被修改了。"马克解释道。'
- en: '"This can be easily fixed using `Object.assign` from ES6\. We can simply create
    a new array and copy the current value of `this.state.books` in it. We can then
    sort the new array and call `setState` with the new sorted array." informed Shawn.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '"这可以通过使用ES6中的 `Object.assign` 轻易地修复。我们可以简单地创建一个新的数组，并将 `this.state.books` 的当前值复制到其中。然后我们可以对新的数组进行排序，并使用新的排序数组调用
    `setState`。" 肖恩告知。'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `Object.assign` method copies the values of all the enumerable properties
    from multiple source objects in a target. More details can be found at the following:
    [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign` 方法将多个源对象的所有可枚举属性值复制到目标对象。更多详细信息可以在以下链接找到：[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)。'
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Immutability helpers](img/4730_07_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![不可变辅助工具](img/4730_07_03.jpg)'
- en: '"Yes. This works. But the `Object.assign` method will make a shallow copy of
    `this.state.books`. It will create a new `unsortedBooks` object, however, it will
    still use the same references from `this.state.books` in `unsortedBooks`. Let''s
    say, for some reason, we want the titles of all books in uppercase letters, then
    we may accidently mutate `this.state` too," Mike explained.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的。这行得通。但是 `Object.assign` 方法将创建 `this.state.books` 的浅拷贝。它将创建一个新的 `unsortedBooks`
    对象，然而，它仍然会在 `unsortedBooks` 中使用 `this.state.books` 的相同引用。假设，由于某种原因，我们想要将所有书籍的标题转换为大写字母，那么我们可能会意外地变异
    `this.state`，" 迈克解释道。'
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Immutability helpers](img/4730_07_04.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![不可变辅助工具](img/4730_07_04.jpg)'
- en: '"As you can see, even after using `Object.assign`, `this.state.books` was still
    mutated. Actually, this has nothing to do with React as such. It is due to the
    way JavaScript passes references of arrays and objects around. However, due to
    this, if we have arrays and objects in our deeply nested state, it becomes hard
    to prevent mutations." Mike further explained.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '"正如您所看到的，即使使用了 `Object.assign`，`this.state.books` 仍然发生了变异。实际上，这与React本身无关。这是由于JavaScript传递数组和对象引用的方式造成的。然而，由于这个原因，如果我们深层次的状态中有数组和对象，就很难防止变异。"
    迈克进一步解释道。'
- en: '"Do we always have to perform a deep copy of the state object to be on the
    safer side?" Shawn asked.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们是否总是必须执行深拷贝状态对象以确保安全？" 肖恩问道。'
- en: '"Well, deep copies can be expensive and sometimes hard to achieve with deeply
    nested state. Fortunately, React provides the Update addon with immutability helpers,
    which we can use to solve this issue." added Mike.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '"嗯，深拷贝可能很昂贵，有时在深层次嵌套的状态中很难实现。幸运的是，React提供了带有不可变辅助工具的Update插件，我们可以使用它来解决这个问题的。"
    迈克补充道。'
- en: '"While using immutability helpers, we need to answer the following three questions:"'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '"在使用不可变辅助工具时，我们需要回答以下三个问题："'
- en: What needs to be changed?
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要更改什么？
- en: Where it needs to be changed?
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要在哪里更改？
- en: How it needs to be changed?
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要如何更改？
- en: '"In this case, we need to change the `this.state` to display the sorted books."'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '"在这种情况下，我们需要更改 `this.state` 以显示排序后的书籍。"'
- en: '"The second question is that where should the mutation happen inside `this.state`?
    The mutation should happen in `this.state.books`."'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '"第二个问题是，`this.state` 内部应该在哪个位置发生变异？变异应该发生在 `this.state.books` 上。"'
- en: '"The third question is that how should the mutation happen? Are we going to
    delete something or add any new element or restructure existing elements? In this
    case, we want to sort the elements as per some criterion."'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '"第三个问题是变异应该如何发生？我们是打算删除某些内容，还是添加新的元素，或者重构现有元素？在这种情况下，我们想要根据某些标准对元素进行排序。"'
- en: '"The Update addon accepts two parameters. The first parameter is the object
    that we want to mutate. The second parameter tells us where and how should the
    mutation take place in the first parameter. In this case, we want to mutate `this.state`.
    In `this.state`, we want to update the books with the sorted books. Therefore,
    our code will look similar to the following:"'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '"Update插件接受两个参数。第一个参数是我们想要变异的对象。第二个参数告诉我们第一个参数中变异应该发生在哪里以及如何进行。在这种情况下，我们想要变异
    `this.state`。在 `this.state` 中，我们想要用排序后的书籍更新书籍。因此，我们的代码将类似于以下内容："'
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Available commands
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可用命令
- en: The Update addon provides different commands to perform the mutations in arrays
    and objects. The syntax of these commands is inspired by MongoDB's query language.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Update插件提供了不同的命令来执行数组和对象的变异。这些命令的语法受到了MongoDB查询语言的启发。
- en: '"Most of these commands operate on array objects allowing us to push in an
    array or unshift an element from the array. It also supports replacing the target
    entirely using the set command. Other than this, it also provides the merge command
    to merge new keys with an existing object." Mike explained.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '"大多数这些命令都操作数组对象，允许我们向数组中推入一个数组或从数组中unshift一个元素。它还支持使用set命令完全替换目标。除此之外，它还提供了merge命令来合并新键与现有对象。"
    迈克解释道。'
- en: '"Shawn, my favorite command provided by this addon is apply. It takes a function
    and applies that function to the current value of the target that we want to modify.
    It gives more flexibility to make changes in the complex data structures. It''s
    also a hint for your next task. Try to use it to sort the books by title without
    mutating." Mike challenged.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，这个插件提供的我最喜欢的命令是apply。它接受一个函数，并将该函数应用于我们想要修改的目标的当前值。它为在复杂数据结构中做出更改提供了更多的灵活性。这也是你下一个任务的提示。尝试使用它来按标题对书籍进行排序，而不进行修改。"
    迈克提出了挑战。'
- en: '"Sure. Here you go," said Shawn.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '"当然。给你，" 肖恩说。'
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Available commands](img/4730_07_05.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![可用命令](img/4730_07_05.jpg)'
- en: '"Perfect, Shawn. Using the Update addon makes it very easy to manage complex
    state without actually mutating it."'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '"太好了，肖恩。使用Update插件使得管理复杂状态变得非常容易，而实际上并没有修改它。"'
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Check [https://facebook.github.io/immutable-js/docs/](https://facebook.github.io/immutable-js/docs/)
    for a complete solution for using immutable data structures in JavaScript.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅[https://facebook.github.io/immutable-js/docs/](https://facebook.github.io/immutable-js/docs/)以获取在JavaScript中使用不可变数据结构的完整解决方案。
- en: Cloning components
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克隆组件
- en: '"Shawn, props are also immutable in React. In most of the cases, the child
    component just uses props passed by the parent component. However, sometimes we
    want to extend the incoming props with some new data before rendering the child
    component. It''s a typical use case to update styles and CSS classes. React provides
    an addon to clone a component and extending its props. It''s called the **cloneWithProps**
    addon." said Mike.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，在React中，props也是不可变的。在大多数情况下，子组件只是使用父组件传递的props。然而，有时我们在渲染子组件之前想要扩展传入的props以添加一些新数据。这是一个典型的用例，用于更新样式和CSS类。React提供了一个插件来克隆组件并扩展其props。它被称为**cloneWithProps**插件。"
    迈克说。'
- en: '"Mike, that addon is deprecated. I had looked at it in the past and React has
    deprecated it. It also has lot of issues related to refs of the child component
    not getting passed to the newly-cloned child components," Shawn informed.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '"迈克，这个插件已经过时了。我以前看过它，React已经将其弃用。它还与子组件的refs未传递给新克隆的子组件等问题有关。" 肖恩通知说。'
- en: '"True. However, React also has a top-level `React.cloneElement` API method,
    which allows us to clone and extend a component. It has a very simple API and
    it can be used instead of the cloneWithProps addon." Mike explained.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '"确实如此。然而，React还有一个顶级的`React.cloneElement` API方法，它允许我们克隆并扩展一个组件。它有一个非常简单的API，并且可以用作cloneWithProps插件的替代品。"
    迈克解释道。'
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '"This method can be used to clone the given element and merge the new props
    with existing props. It replaces existing children with new children. Therefore,
    we have to keep this in mind while dealing with the child components."'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '"这个方法可以用来克隆给定的元素，并将新属性与现有属性合并。它用新子元素替换现有子元素。因此，在处理子组件时，我们必须记住这一点。"'
- en: '"The `cloneElement` function also passes ref of the old child component to
    the newly-cloned component. Therefore, if we have any callbacks based on refs,
    they will continue to work even after cloning."'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '"`cloneElement`函数还会将旧子组件的ref传递给新克隆的组件。因此，如果我们有任何基于refs的回调，它们在克隆后仍然会继续工作。"'
- en: '"Shawn, here is your next challenge. We show listing of books in our app. In
    fact, in all of our apps, we show the listing of other things such as products,
    items, and so on. We want to show the rows with alternate colors in all of these
    listings instead of just white background. As the code for this feature will be
    the same across all the apps, I am thinking about creating a separate component
    that will accept rows as input and render them with alternate colors. Such components
    can be used in all of our apps. I think that you can make use of `React.cloneElement`
    for this." Mike explained the next task.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，你的下一个挑战来了。我们在我们的应用中显示书籍列表。实际上，在我们的所有应用中，我们都显示其他事物的列表，如产品、项目等。我们希望在所有这些列表中显示带有交替颜色的行，而不是只有白色背景。因为这个功能的代码将在所有应用中都是相同的，所以我正在考虑创建一个单独的组件，该组件将接受行作为输入，并以交替颜色渲染它们。这样的组件可以用于我们的所有应用。我认为你可以使用`React.cloneElement`来完成这个任务。"
    迈克解释了下一个任务。'
- en: '"Sounds like a good idea to extract this as a separate component. We need it
    in almost all the apps. Our QA was complaining about the lack of colors in our
    search app yesterday." Shawn remembered.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '"将这个功能提取为一个单独的组件听起来是个好主意。我们几乎在所有应用中都需要它。昨天我们的 QA 团队抱怨我们的搜索应用缺少颜色。" 肖恩回忆道。'
- en: '"Let''s add some alternate colors then." Mike chuckled.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '"让我们添加一些交替颜色吧。" 迈克轻声笑了。'
- en: '"First, let''s see how we are displaying books currently."'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '"首先，让我们看看我们目前是如何显示书籍的。"'
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '"The `BookList` component just renders the rows passed to it as it is using
    `this.props.children`."'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '"`BookList` 组件只是按照原样渲染传递给它的行，因为它使用了 `this.props.children`。"'
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '"Mike, I am naming the component `RowAlternator`. The `RowAlternator` component
    will get the dynamic array of children rows and it will render them with alternate
    colors. We can pass multiple colors to `RowAlternator` too. In this way, the client
    code using this component can control the colors that they want to use as alternate
    colors."'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '"迈克，我打算将这个组件命名为 `RowAlternator`。`RowAlternator` 组件将获取动态的子行数组，并以交替颜色渲染它们。我们也可以向
    `RowAlternator` 传递多个颜色。这样，使用这个组件的客户端代码就可以控制它们想要使用的交替颜色。"'
- en: '"Sounds good, Shawn. I think this much API is enough for now."'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '"听起来不错，肖恩。我认为现在这个 API 已经足够了。"'
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '"As we don''t know how many children elements we will get in `RowAlternator`,
    we will just iterate over all of them and set style with alternate colors. We
    are also using `React.cloneElement` here to clone the passed child and extend
    its style prop with appropriate background color."'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '"由于我们不知道在 `RowAlternator` 中我们会得到多少子元素，所以我们只是遍历所有元素并使用交替颜色设置样式。我们在这里也使用了 `React.cloneElement`
    来克隆传递的子元素，并使用适当的背景颜色扩展其样式属性。"'
- en: '"Let''s change our `BookList` component now in order to use `RowAlternator`."'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '"现在让我们更改 `BookList` 组件，以便使用 `RowAlternator`。"'
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '"We are all set. The listing now shows alternate colors as we wanted, as shown
    in the following image:"'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们已经准备好了。现在列表显示了我们所想要的交替颜色，如下面的图片所示："'
- en: '![Cloning components](img/4730_07_06.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![克隆组件](img/4730_07_06.jpg)'
- en: '"Perfect, Shawn. As you already noticed, using `React.cloneElement` makes sense
    when we are building a component with dynamic children, where we don''t have control
    on the render method of these children, but want to extend their props based on
    some criteria." Mike was happy.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '"太好了，肖恩。正如你已经注意到的，当我们构建一个具有动态子元素的组件时，使用 `React.cloneElement` 是有意义的，在这些子元素的渲染方法上我们没有控制权，但基于某些标准想要扩展它们的属性。"
    迈克很高兴。'
- en: Helpers for testing React apps
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 React 应用程序的帮助器
- en: '"Shawn, we have not added any tests for our app yet, however, the time has
    come to start slowly adding test coverage. With the Jest library and Test Utilities
    addon, it becomes very easy to set up and start testing the React apps." Mark
    explained the next task.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，我们还没有为我们的应用添加任何测试，但是现在是时候开始慢慢添加测试覆盖率了。有了 Jest 库和测试实用工具插件，设置和开始测试 React
    应用程序变得非常简单。" 马克解释了下一个任务。'
- en: '"I have heard about Jest. Isn''t it a testing library by Facebook?" Shawn asked.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '"我听说过 Jest。它不是 Facebook 的一个测试库吗？" 肖恩问道。'
- en: Setting up Jest
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 Jest
- en: '"Yes. It''s built on top of Jasmine. It''s very easy to set up. First, we have
    to install the `jest-cli` and `babel-jest` packages."'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的。它是建立在 Jasmine 之上的。设置起来非常简单。首先，我们必须安装 `jest-cli` 和 `babel-jest` 包。"'
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '"After that, we need to configure `package.json`, as follows:"'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '"之后，我们需要配置 `package.json`，如下所示："'
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '"By default, Jest mocks all modules, however, here we are telling Jest not
    to mock React and the related libraries. We are also specifying the extensions
    for our test file that will be identified by Jest as test files."'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '"默认情况下，Jest 模拟所有模块，但是在这里我们告诉 Jest 不要模拟 React 和相关库。我们还指定了 Jest 将识别为测试文件的测试文件扩展名。"'
- en: '"Create a `__test__` folder, where we will be adding our tests. Jest will run
    the tests from files in this folder. Let''s add an empty file too. We have to
    make sure that the file should end with `-test.js` so that Jest will pick up it
    to run the tests." Mike explained.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '"创建一个 `__test__` 文件夹，我们将在这里添加我们的测试。Jest 将从这个文件夹中的文件运行测试。让我们也添加一个空文件。我们必须确保文件以
    `-test.js` 结尾，这样 Jest 才能将其识别为测试文件。" 迈克解释道。'
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '"Now let''s verify that we can run the tests from the command line."'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '"现在让我们验证我们是否可以从命令行运行测试。"'
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: You should see an output that is similar to the preceding output. It may change
    based on the Jest version. Consult [https://facebook.github.io/jest/docs/getting-started.html](https://facebook.github.io/jest/docs/getting-started.html)
    to set up Jest, in case of any issues.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个与前面输出类似的输出。它可能会根据 Jest 版本而变化。如有任何问题，请咨询[https://facebook.github.io/jest/docs/getting-started.html](https://facebook.github.io/jest/docs/getting-started.html)以设置
    Jest。
- en: '"Shawn, we are all set with Jest. It''s time to start writing the tests now.
    We will test whether the top-level `App` component gets mounted correctly. However,
    first, we need to understand a bit more about using Jest," said Mike.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，我们已经准备好使用 Jest 了。现在是时候开始编写测试了。我们将测试顶层`App`组件是否正确挂载。然而，首先，我们需要更多地了解 Jest
    的使用方法，"迈克说。'
- en: '"By default, Jest mocks all the modules that are required in a test file. Jest
    does this to isolate the module that is under test from all the other modules.
    In this case, we want to test the `App` component. If we just require it, then
    Jest will provide a mocked version of `App`."'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '"默认情况下，Jest 模拟了测试文件中需要的所有模块。Jest 这样做是为了隔离正在测试的模块与其他所有模块。在这种情况下，我们想测试`App`组件。如果我们只是导入它，那么
    Jest 将提供`App`的模拟版本。"'
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '"As we we want to test the `App` component itself, we need to specify Jest
    not to mock it. Jest provides the `jest.dontmock()` function for this purpose."'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '"因为我们想测试`App`组件本身，所以我们需要指定 Jest 不要模拟它。Jest 提供了`jest.dontmock()`函数来实现这个目的。"'
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Check [https://facebook.github.io/jest/docs/automatic-mocking.html](https://facebook.github.io/jest/docs/automatic-mocking.html)
    for more details about automatic mocking feature of Jest.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅[https://facebook.github.io/jest/docs/automatic-mocking.html](https://facebook.github.io/jest/docs/automatic-mocking.html)以获取
    Jest 自动模拟功能的更多详细信息。
- en: '"Next up, we will add imports for the React and TestUtils addon."'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '"接下来，我们将添加 React 和 TestUtils 插件的导入语句。"'
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '"The TestUtils addon provides utility functions to render the components, finding
    sub-components in rendered components and mimicking events on the rendered component.
    It helps in testing both the structure and behavior of the React components."
    Mike added.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '"TestUtils 插件提供了渲染组件、在渲染组件中查找子组件以及模拟渲染组件上的事件的实用函数。它有助于测试 React 组件的结构和行为。"迈克补充道。'
- en: Testing structure of React components
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 React 组件的结构
- en: '"We will start with the `renderIntoDocument` function. This function renders
    the given component into a detached DOM node in the document. It returns `ReactComponent`,
    which can be used for further testing."'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们将从`renderIntoDocument`函数开始。这个函数将给定的组件渲染到文档中的一个分离的 DOM 节点中。它返回`ReactComponent`，可以用于进一步的测试。"'
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '"We rendered the `App` component in DOM and asserted that initially books and
    searching state are being set correctly." Mike explained.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们在 DOM 中渲染了`App`组件，并断言初始书籍和搜索状态被正确设置。"迈克解释道。'
- en: '"Mike, this is awesome. We are not testing real DOM, but testing the React
    components instead."'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '"迈克，这太棒了。我们不是在测试真实的 DOM，而是在测试 React 组件。"'
- en: '"Yes. The TestUtils addon comes with finder methods that can be used to find
    the child components in a given component tree. They are useful to find the child
    components such as input box and submit button and simulate click events or change
    events."'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的。TestUtils 插件附带了一些查找方法，可以用来在给定的组件树中查找子组件。它们对于查找子组件，如输入框和提交按钮，并模拟点击事件或更改事件很有用。"'
- en: '`findAllInRenderedTree(tree, predicate function)`: This is useful for finding
    all the components in a given tree that returns the truth value for the predicate
    function.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findAllInRenderedTree(tree, predicate function)`：这对于在给定的树中找到返回谓词函数真值的所有组件很有用。'
- en: '`scryRenderedDOMComponentsWithClass(tree, className)`: This is useful for finding
    all the DOM components with a given class name.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scryRenderedDOMComponentsWithClass(tree, className)`：这对于找到具有给定类名的所有 DOM 组件很有用。'
- en: '`findRenderedDOMComponentWithClass(tree, className)`: Instead of finding all
    the DOM components with a given class, this method expects that only one such
    component is present. It throws an exception if there are multiple components
    with a given class name.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findRenderedDOMComponentWithClass(tree, className)`：与找到具有给定类的所有 DOM 组件不同，此方法期望只有一个这样的组件存在。如果有多个具有给定类名的组件，它将抛出异常。'
- en: '`scryRenderedDOMComponentsWithTag(tree, tagName)`: It''s similar to finding
    the DOM components with the class name, however, instead of class name, it finds
    the components based on a given tag name.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scryRenderedDOMComponentsWithTag(tree, tagName)`：它与根据类名查找 DOM 组件类似，但是，它基于给定的标签名来查找组件。'
- en: '`findRenderedDOMComponentWithTag(tree, tagName)`: Instead of finding all the
    components with a given tag, it expects that only one such component is present.
    It also throws exception when more than one such components exists.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findRenderedDOMComponentWithTag(tree, tagName)`: 与查找具有给定标签的所有组件不同，它期望只有一个这样的组件存在。如果存在多个此类组件，它也会抛出异常。'
- en: '`scryRenderedComponentsWithType(tree, componentType)`: This method finds all
    the components with a given type. It''s useful to find all the composite components
    created by the user.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scryRenderedComponentsWithType(tree, componentType)`: 此方法查找所有具有给定类型的组件。这对于查找用户创建的所有复合组件非常有用。'
- en: '`findRenderedComponentWithType (tree, componentType)`: This is similar to all
    the previous finder methods. It raises exception if more than one component with
    a given type is present.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findRenderedComponentWithType (tree, componentType)`: 这与所有之前的查找方法类似。如果存在具有给定类型的多个组件，它将引发异常。'
- en: Testing behavior of React components
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试React组件的行为
- en: '"Let''s use these functions to assert that the search for books starts when
    a user enters a search term and clicks the **Submit** button. We will simulate
    the event of entering search term by the user." said Mike.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '"让我们使用这些函数来断言，当用户输入搜索词并点击**提交**按钮时，搜索书籍开始。我们将通过模拟用户输入搜索词的事件来实现这一点。"迈克说。'
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '"We render the `App` component, find the input node, set the value of the input
    node to the search term, and simulate the change event using `TestUtils.Simulate()`.
    This function simulates the given event dispatch on a DOM node. The `Simulate`
    function has a method for every event that React understands. Therefore, we can
    simulate all events such as change, click, and so on. We can test the user behavior
    using this method," Mike explained.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们渲染`App`组件，找到输入节点，将输入节点的值设置为搜索词，并使用`TestUtils.Simulate()`模拟更改事件。这个函数模拟在DOM节点上给定事件的派发。`Simulate`函数为React理解的所有事件都有一个方法。因此，我们可以模拟所有事件，如更改、点击等。我们可以使用这种方法来测试用户行为。"迈克解释道。'
- en: '"Got it. Therefore, after changing the search term, we click the submit button
    and verify that the state gets updated as per our expectations," informed Shawn.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '"明白了。因此，在更改搜索词后，我们点击提交按钮并验证状态是否按预期更新。"肖恩说道。'
- en: '"Yes, Shawn. Now, can you check whether the Spinner is shown once the user
    clicks the **Submit** button? You can use one of the finder method that we discussed
    earlier." Mike explained the next task.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的，肖恩。现在，你能检查一下用户点击**提交**按钮后是否显示Spinner吗？你可以使用我们之前讨论过的查找方法之一。"迈克解释了下一个任务。'
- en: '"Yes. Once the component state changes after clicking the **Submit** button,
    we can search the rendered component tree to see whether the Spinner component
    is present or not."'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的。在点击**提交**按钮后，组件状态发生变化后，我们可以搜索渲染的组件树，以查看Spinner组件是否存在。"。'
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '"We are using `TestUtils.findRenderedComponentWithType` here to check whether
    Spinner is present in the tree rendered by the `App` component or not. However,
    before adding this assertion, we need to import the Spinner component at the top
    of the test file as `findRenderedComponentWithType` expects a second argument
    to be a React component."'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们在这里使用`TestUtils.findRenderedComponentWithType`来检查Spinner是否存在于由`App`组件渲染的树中。然而，在添加此断言之前，我们需要在测试文件顶部导入Spinner组件，因为`findRenderedComponentWithType`期望第二个参数是一个React组件。"。'
- en: '"Excellent, Shawn. As you can see, the testing behavior of the React component
    becomes very easy with the `TestUtils.Simulate` and `finder` methods." Mike explained.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '"非常好，肖恩。正如你所看到的，使用`TestUtils.Simulate`和`finder`方法，React组件的测试行为变得非常简单。"迈克解释道。'
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we have not added a test to asynchronously load the books from Open
    Library API as it is out of the scope of this chapter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有添加测试来异步从Open Library API加载书籍，因为这超出了本章的范围。
- en: Shallow rendering
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浅渲染
- en: '"Shawn, TestUtils also provides one more way to test the components in an isolated
    fashion using the Shallow rendering. Shallow rendering allows us render the top-level
    component and assert the facts about the return value of it''s render method.
    It does not render children components or instantiate them. Therefore, our tests
    are not affected by the behavior of the children components. Shallow rendering
    also does not require a DOM, unlike the previous methods, where we rendered the
    component in a detached DOM," Mike explained.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: “肖恩，TestUtils还提供了一种使用浅渲染以隔离方式测试组件的方法。浅渲染允许我们渲染顶级组件并断言其渲染方法的返回值。它不会渲染子组件或实例化它们。因此，我们的测试不受子组件行为的影响。与之前的方法不同，浅渲染不需要DOM，”迈克解释道。
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '"This creates a shallow renderer object, in which we will render the component
    that we want to test. Shallow renderer has a render method similar to `ReactDOM.render`,
    which can be used to render the component."'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: “这创建了一个浅渲染器对象，我们将在这个对象中渲染我们想要测试的组件。浅渲染器有一个类似于`ReactDOM.render`的`render`方法，可以用来渲染组件。”
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '"After render method is called, we should call `renderer.getRenderedOutput`,
    which returns the shallowly rendered output of rendering the component. We can
    start asserting facts about the component on the output of `getRenderedOutput`."'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: “在调用渲染方法之后，我们应该调用`renderer.getRenderedOutput`，它返回渲染组件的浅渲染输出。我们可以在`getRenderedOutput`的输出上开始断言关于组件的事实。”
- en: '"Let''s see the output we get from `getRenderedOutput`."'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: “让我们看看从`getRenderedOutput`得到的输出。”
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '"As you can see, based on the rendered output, we can assert the facts about
    props of the current component. However, if we want to test anything about children
    component, we need to explicitly reach out to them through `this.props.children[0].props.children[1].props.children`."'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: “正如你所见，基于渲染输出，我们可以断言关于当前组件props的事实。然而，如果我们想测试关于子组件的任何事情，我们需要通过`this.props.children[0].props.children[1].props.children`显式地访问它们。”
- en: '"This makes it hard to test the behavior of the children components using shallow
    rendering. However, it''s useful for testing small components in an isolated way
    as it does not get affected by children component due to shallow rendering," said
    Mike.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: “这使得使用浅渲染测试子组件的行为变得困难。然而，由于浅渲染不受子组件的影响，它对于以隔离方式测试小型组件是有用的，”迈克说。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started with understanding the React addons and how to use
    them. We used immutability helpers and test utility functions provided by the
    addons. We also looked into how to clone the components.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先了解了React插件及其使用方法。我们使用了插件提供的不可变辅助工具和测试实用函数。我们还探讨了如何克隆组件。
- en: In the next chapter, we will make our React app more performant. You will be
    learning about addons that will improve the performance of the React apps. Specifically,
    you will learn how to measure the performance of our apps and how React can make
    faster updates without changing most of the UI.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使我们的React应用更加高效。你将学习到可以提升React应用性能的插件。具体来说，你将学习如何测量我们应用的性能以及React如何在不改变大部分UI的情况下进行更快的更新。
- en: Let's make our React apps faster!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们的React应用更快吧！
