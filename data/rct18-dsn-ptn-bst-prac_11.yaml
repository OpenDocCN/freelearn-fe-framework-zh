- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Managing Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理数据
- en: 'In this chapter, we will explore two beneficial tools: the **React Context
    API** and **React Suspense**. The Context API simplifies the process of sharing
    data across our entire application without the need to pass it down through multiple
    layers. On the other hand, React Suspense enables specific parts of our app to
    wait for certain actions before being displayed, resulting in a smoother loading
    experience.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨两个有益的工具：**React Context API**和**React Suspense**。Context API简化了在整个应用程序中共享数据的过程，无需通过多层传递。另一方面，React
    Suspense允许应用程序的特定部分在显示之前等待某些操作，从而实现更平滑的加载体验。
- en: By utilizing these tools collectively, we can enhance data management and improve
    the overall performance of our app. Join us on this journey as we delve into the
    efficient handling of data in React.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过共同利用这些工具，我们可以增强数据管理并提高应用程序的整体性能。加入我们，深入了解React中数据的有效处理。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The React Context API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Context API
- en: How to consume a context with `useContext`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`useContext`消费上下文
- en: How to use React Suspense with SWR (Stale-While-Revalidate)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用SWR（Stale-While-Revalidate）与React Suspense
- en: How to use Redux Toolkit
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Redux Toolkit
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章，你需要以下内容：
- en: Node.js 19+
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 19+
- en: Visual Studio Code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: 'You can find the code for this chapter in the book’s GitHub repository: [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter11).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的GitHub仓库中找到本章的代码：[https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter11)。
- en: Introducing the React Context API
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍React Context API
- en: The **React Context API** has come a long way since it was first introduced
    as an experimental feature. Since version 16.3.0, it has been officially added
    to React and has become a game-changer for many developers. In fact, many are
    now using the new Context API instead of Redux. The Context API allows you to
    share data between components without having to pass a prop to every child component.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**React Context API**自从首次作为实验性功能引入以来已经走了很长的路。自16.3.0版本以来，它已被正式添加到React中，并成为许多开发者的游戏改变者。事实上，现在许多人正在使用新的Context
    API而不是Redux。Context API允许你在不向每个子组件传递prop的情况下在组件之间共享数据。'
- en: To illustrate how to use the new Context API, let’s revisit the example from
    *Chapter 8*, *React Hooks*, where we fetched GitHub issues using React Hooks,
    but this time by using the Context API instead.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何使用新的Context API，让我们回顾一下第8章的例子，*React Hooks*，其中我们使用React Hooks获取GitHub问题，但这次我们使用Context
    API。
- en: Creating our first context
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的第一个上下文
- en: The first thing you need to do is to create the issue context. For this, you
    can create a folder called `contexts` inside your **src** folder, where you will
    add the `Issue.tsx` file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的第一件事是创建问题上下文。为此，你可以在你的**src**文件夹中创建一个名为`contexts`的文件夹，在那里你将添加`Issue.tsx`文件。
- en: 'Then, you need to import some functions from React and `axios`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要从React和`axios`导入一些函数：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'At this point, it is clear that you should install `axios`. If you still don’t
    have it, just do the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，很明显你应该安装`axios`。如果你还没有安装，只需做以下操作：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we need to declare our interfaces:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要声明我们的接口：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first thing we need to do after this is to create our context by using
    the `createContext` function and defining the value we want to export:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们需要做的第一件事是使用`createContext`函数创建我们的上下文，并定义我们想要导出的值：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once we have `IssueContext`, we need to create a component where we can receive
    props, set some states, and perform the fetch by using `useEffect`, and then we
    render `IssueContext.Provider` where we specify the context (value) we will export:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`IssueContext`，我们需要创建一个组件，在那里我们可以接收props，设置一些状态，并使用`useEffect`执行fetch，然后我们在`IssueContext.Provider`中渲染，指定我们想要导出的上下文（值）：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you know, every time you want to use a function inside the `useEffect` Hook,
    you need to wrap your function with the `useCallback` Hook. A good practice if
    you want to use async/await is to have it in a separate function and not directly
    in `useEffect`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，每次你想在`useEffect` Hook中使用一个函数时，你都需要用`useCallback` Hook将你的函数包装起来。如果你想要使用async/await，一个好的做法是将其放在一个单独的函数中，而不是直接在`useEffect`中。
- en: Once we perform the fetch and get the data in our `issues` state, we will add
    all the values we want to export as context, then when we render `IssueContext.Provider`,
    we will pass the context on the `value` prop, and finally, we will render the
    children of the component.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在 `issues` 状态中执行获取并获取数据，我们将添加我们想要导出为上下文的所有值，然后当渲染 `IssueContext.Provider`
    时，我们将通过 `value` 属性传递上下文，最后，我们将渲染组件的子元素。
- en: Wrapping our components with the provider
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用提供者包裹我们的组件
- en: The way you consume a context is divided into two parts. The first one is where
    you wrap your app with your context provider, so this code can be added to `App.tsx`
    (normally, all the providers are defined in parent components).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 消费上下文的方式分为两部分。第一部分是你将你的应用程序包裹在你的上下文提供者中，因此这段代码可以添加到 `App.tsx` 中（通常，所有提供者都在父组件中定义）。
- en: 'Notice here that we are importing the `IssueProvider` component:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里我们正在导入 `IssueProvider` 组件：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, we are wrapping the `Issues` component with `IssueProvider`.
    This means that inside the `Issues` component, we can consume our context and
    get the issues value.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在用 `IssueProvider` 包裹 `Issues` 组件。这意味着在 `Issues` 组件内部，我们可以消费我们的上下文并获取问题值。
- en: Many people find this concept confusing. If you forget to wrap your components
    with the provider, you won’t be able to access your context within them. The challenging
    aspect is that you might not receive an error message; instead, you will encounter
    undefined data, making it difficult to pinpoint the problem.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人发现这个概念很令人困惑。如果你忘记将你的组件包裹在提供者中，你将无法在它们内部访问上下文。挑战之处在于你可能不会收到错误消息；相反，你将遇到未定义的数据，这使得很难定位问题。
- en: Now that we comprehend the significance of correctly wrapping our components
    with providers, let’s explore how we can precisely consume our context using the
    `useContext` Hook within our `Issues` component.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了正确包裹组件以提供者的重要性，让我们探索如何在 `Issues` 组件中使用 `useContext` 钩子精确地消费我们的上下文。
- en: Consuming context with useContext
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 useContext 消费上下文
- en: If you’ve already placed `IssueProvider` in `App.tsx`, now you can consume your
    context in your `Issues` component by using the `useContext` Hook.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在 `App.tsx` 中放置了 `IssueProvider`，现在你可以在你的 `Issues` 组件中使用 `useContext` 钩子来消费你的上下文。
- en: 'Notice here that we are importing the `IssueContext` context (between `{ }`):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里我们正在导入 `IssueContext` 上下文（在 `{ }` 之间）：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you did everything correctly, you should be able to see the issues list:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一切操作正确，你应该能够看到问题列表：
- en: '![](img/B18414_11_01.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18414_11_01.png)'
- en: 'Figure 11.1: ContentPI Issues from Context'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：来自上下文的 ContentPI 问题
- en: The **Context API** is super useful when you want to separate your application
    from your data and do all the fetching in there. Of course, there are multiple
    uses for the **Context API**, which can also be used for theming or to pass functions;
    it all depends on your application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要将应用程序与数据分离并在其中执行所有获取操作时，**Context API** 非常有用。当然，**Context API** 有多种用途，也可以用于主题或传递函数；这完全取决于你的应用程序。
- en: In the next section, we are going to learn how to implement **React Suspense**
    using the SWR library.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用 SWR 库实现 **React Suspense**。
- en: Introducing React Suspense with SWR
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SWR 引入 React Suspense
- en: React Suspense was introduced in React 16.6\. Suspense lets you suspend component
    rendering until a condition is met. You can render a loading component or anything
    you want as a fallback of Suspense.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: React Suspense 在 React 16.6 版本中被引入。Suspense 允许你在满足某个条件之前暂停组件的渲染。你可以渲染一个加载组件或任何你想要的作为
    Suspense 的后备内容。
- en: 'Right now, there are only two use cases for this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个用法只有两种：
- en: '**Code splitting**: When you split your application and you’re waiting to download
    a chunk of your app when a user wants to access it.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码拆分**：当你拆分应用程序并且用户想要访问它时正在等待下载应用程序的一个块。'
- en: '**Data fetching**: When you’re fetching data.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据获取**：当你正在获取数据。'
- en: In both scenarios, you can render a fallback, which can normally be a loading
    spinner, some loading text, or even better, a placeholder skeleton.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，你可以渲染一个后备内容，这通常可以是一个加载指示器，一些加载文本，或者更好的是，一个占位符骨架。
- en: Introducing SWR
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 SWR
- en: '**Stale-While-Revalidate** (**SWR**) is a React Hook for data fetching; it
    is an HTTP cache invalidation strategy. SWR is a strategy to first return the
    data from cache (stale), then send the fetch request (revalidate), and finally,
    return with up-to-date data, and was developed by **Vercel**, the company that
    created **Next.js**.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**Stale-While-Revalidate** （**SWR**）是一个用于数据获取的 React 钩子；它是一个 HTTP 缓存失效策略。SWR
    是一种策略，首先从缓存（过时）返回数据，然后发送获取请求（重新验证），最后返回最新的数据，并由 **Vercel** 公司开发，该公司创建了 **Next.js**。'
- en: Building a Pokedex!
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Pokedex！
- en: 'I could not find a better example to explain React Suspense and SWR than building
    a **Pokedex**. We will use a public Pokemon API ([https://pokeapi.co](https://pokeapi.co)):
    *gotta catch ‘em all*!'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我找不到比构建一个 **宝可梦图鉴** 更好的例子来解释 React Suspense 和 SWR。我们将使用一个公开的宝可梦 API ([https://pokeapi.co](https://pokeapi.co))：*必须全部捕捉*！
- en: 'The first thing you need to do is to install some packages:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的第一件事是安装一些包：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For this example, you will need to create the Pokemon directory at `src/components/Pokemon`.
    The first thing we need to do to work with SWR is to create a fetcher file where
    we will perform our requests.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，你需要在 `src/components/Pokemon` 创建 Pokemon 目录。我们需要做的第一件事是为了使用 SWR 创建一个
    fetcher 文件，我们将在这里执行我们的请求。
- en: 'This file should be created at `src/components/Pokemon/fetcher.ts`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件应在 `src/components/Pokemon/fetcher.ts` 创建：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you notice, we are returning an object with an `error` if the response is
    not successful. This is because sometimes we can get a 404 error from the API
    that can cause the app to break.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到，我们在响应不成功时返回一个带有 `error` 的对象。这是因为有时我们可以从 API 获取 404 错误，这可能导致应用程序崩溃。
- en: 'Once you have created your fetcher, let’s modify `App.tsx` to configure `SWRConfig`
    and enable Suspense:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了你的 fetcher，让我们修改 `App.tsx` 以配置 `SWRConfig` 并启用 Suspense：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, we need to wrap our `PokeContainer` component inside `SWRConfig`
    to be able to fetch the data. The `PokeContainer` component will be our parent
    component, where we will add our first `Suspense`. This file exists at `src/components/Pokemon/PokeContainer.tsx`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们需要将 `PokeContainer` 组件包裹在 `SWRConfig` 中，以便能够获取数据。`PokeContainer` 组件将是我们的父组件，我们将在这里添加第一个
    `Suspense`。此文件位于 `src/components/Pokemon/PokeContainer.tsx`：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, we are defining a fallback for our first `Suspense`, which is
    just `Loading Pokedex...` text. You can render whatever you want in there, React
    components or plain text. Then, we have our Pokedex component inside Suspense.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们为第一个 `Suspense` 定义了一个回退，它只是 `Loading Pokedex...` 文本。你可以在那里渲染任何你想要的内容，React
    组件或纯文本。然后，我们在 Suspense 内部放置了 Pokedex 组件。
- en: 'Now let’s take a look at our Pokedex component where we are going to fetch
    data for the first time by using the `useSWR` Hook:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们的 Pokedex 组件，我们将使用 `useSWR` 钩子来获取第一次数据：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we are fetching the first 150 Pokemon because I’m old school
    and those were the first generation. Right now, I don’t know how many Pokemon
    exist. Also, if you notice, we are grabbing the `results` variable that comes
    from the data (this is the actual response from the API). Then we map our results
    to render each Pokemon, but we add a Suspense component to each one with a `<LoadingSkeleton
    />` fallback (`<StyledGrid />` has some CSS styles to make it look nicer), and
    finally, we pass `pokemonName` to our `<Pokemon>` component, and this is because
    the first fetch just brings us the name of the Pokemon, but we need to do another
    fetch to bring the actual Pokemon data (name, types, power, and so on).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在获取前 150 个宝可梦，因为我是个老派的人，这些是第一代。现在，我不知道有多少宝可梦存在。此外，如果你注意到，我们正在获取数据中的
    `results` 变量（这是 API 的实际响应）。然后我们将结果映射以渲染每个宝可梦，但我们为每个宝可梦添加了一个带有 `<LoadingSkeleton
    />` 回退的 Suspense 组件（`<StyledGrid />` 有一些 CSS 样式使其看起来更美观），最后，我们将 `pokemonName`
    传递给 `<Pokemon>` 组件，这是因为第一次获取只带来了宝可梦的名字，但我们需要进行另一次获取以带来实际的宝可梦数据（名称、类型、力量等）。
- en: 'Then, finally, our Pokemon component will perform a specific fetch by the Pokemon
    name and will render the data:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，最后，我们的宝可梦组件将通过宝可梦名称执行特定的获取，并将数据渲染出来：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Basically, in this component, we put together all the Pokemon data (ID, name,
    sprites, and types) and we render the information. As you have seen, I’m using
    styled components, which are amazing, so if you want to know the styles that I’m
    using for Pokedex, here is the `Pokemon.styled.ts` file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，在这个组件中，我们将所有宝可梦数据（ID、名称、精灵和类型）组合在一起，并渲染信息。正如你所看到的，我正在使用样式组件，它们非常棒，所以如果你想了解我用于
    Pokedex 的样式，这里就是 `Pokemon.styled.ts` 文件：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, our `LoadingSkeleton` component should be like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的`LoadingSkeleton`组件应该像这样：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This library is amazing. It lets you create skeleton placeholders to wait for
    the data. Of course, you can build as many forms as you want. You have probably
    seen this effect on sites such as LinkedIn or YouTube.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库非常棒。它让你可以创建骨架占位符来等待数据。当然，你可以构建你想要的任何数量的表单。你可能已经在LinkedIn或YouTube等网站上看到过这种效果。
- en: Testing React Suspense
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试React Suspense
- en: 'Once you have all the pieces of the code working, there is a trick you can
    do in order to see all the Suspense fallbacks. Normally, if you have a high-speed
    connection, it is hard to see it, but you can slow down your connection to see
    how everything is being rendered. You can do this by selecting **Slow 3G** in
    your **Network** tab on your Chrome inspector:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有的代码片段都开始工作，你可以使用一个技巧来查看所有的Suspense回退。通常，如果你有高速连接，很难看到它，但你可以通过在Chrome检查器的**网络**标签页中选择**慢速3G**来降低你的连接速度，看看一切是如何渲染的：
- en: '![](img/B18414_11_02.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18414_11_02.png)'
- en: 'Figure 11.2: Slow 3G connection'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：慢速3G连接
- en: 'Once you set the **Slow 3G** preset and you run your project, the first fallback
    you will see is **Loading Pokedex...**:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了**慢速3G**预设并运行你的项目，你将看到的第一个回退是**正在加载宝可梦...**：
- en: '![](img/B18414_11_03.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18414_11_03.png)'
- en: 'Figure 11.3: Loading Pokedex'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：加载宝可梦
- en: 'Then, you will see the Pokemon fallbacks that are rendering `SkeletonLoading`
    for each Pokemon that is being loaded:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你会看到宝可梦的回退，每个正在加载的宝可梦都会渲染`SkeletonLoading`：
- en: '![](img/B18414_11_04.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18414_11_04.png)'
- en: 'Figure 11.4: SkeletonLoading'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：SkeletonLoading
- en: 'Normally those loaders have animation, but you won’t see that in this book,
    of course! And then you will start seeing how the data is rendering and some images
    start appearing:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这些加载器有动画，但在这本书中当然不会看到！然后你将开始看到数据是如何渲染的，一些图片开始出现：
- en: '![](img/B18414_11_05.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18414_11_05.png)'
- en: 'Figure 11.5: Loading Pokedex'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：加载宝可梦图鉴
- en: 'If you wait until all the data has downloaded correctly, you should now see
    the Pokedex with all the Pokemon:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你等待所有数据正确下载，你现在应该能看到包含所有宝可梦的宝可梦图鉴：
- en: '![](img/B18414_11_06.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18414_11_06.png)'
- en: 'Figure 11.6: Displaying the entire Pokedex'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：显示整个宝可梦图鉴
- en: Pretty nice, huh? But there is something else to mention; as I mentioned before,
    SWR will bring the data from the cache first and then will revalidate the data
    all the time to see whether there are new updates. This means that any time the
    data changes, SWR will perform another fetch to revalidate whether the old data
    is still valid or needs to be replaced by a new one.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 真的很不错，对吧？但还有其他要说的；正如我之前提到的，SWR会首先从缓存中获取数据，然后会持续验证数据，以查看是否有新的更新。这意味着每次数据发生变化时，SWR都会执行另一个获取操作来重新验证旧数据是否仍然有效或需要用新数据替换。
- en: 'You can see this effect even if you move out from the Pokedex tab to another
    and then come back. You’ll see that your **Network** terminal, for the first time,
    looks like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你从宝可梦标签页移到另一个标签页然后再返回，你也能看到这个效果。你会发现你的**网络**终端，第一次，看起来是这样的：
- en: '![](img/B18414_11_07.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18414_11_07.png)'
- en: 'Figure 11.7: Requests'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：请求
- en: 'As you can see, we performed 151 initial requests (1 for the Pokemon lists
    and 150 others, 1 for each Pokemon), but if you change the tab and come back,
    you will see how SWR is fetching again:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们执行了151个初始请求（1个用于宝可梦列表和150个其他请求，每个宝可梦1个），但如果你切换标签页然后返回，你会看到SWR再次进行获取：
- en: '![](img/B18414_11_08.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18414_11_08.png)'
- en: 'Figure 11.8: 151 requests'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8：151个请求
- en: Now you can see that it is performing 302 requests (another 151). This is very
    useful when you have real-time data that you want to fetch every second or every
    minute.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到它正在执行302个请求（另外151个）。当你需要每秒或每分钟获取实时数据时，这非常有用。
- en: Currently, React Suspense lacks a defined pattern of use, which implies that
    there are various ways to utilize it, and there are no established best practices
    for it yet. I have found that SWR is the easiest and most understandable approach
    to working with React Suspense. I believe it is a powerful library that can be
    utilized effectively even without the need for Suspense.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，React Suspense缺乏一个定义的使用模式，这意味着有各种方法可以利用它，而且还没有建立最佳实践。我发现SWR是处理React Suspense最容易、最易懂的方法。我相信这是一个功能强大的库，即使不需要Suspense也可以有效地使用。
- en: 'After exploring the flexibility of React Suspense, let’s redirect our attention
    to another formidable tool within the React ecosystem: Redux Toolkit. This tool
    is revolutionizing the approach to Redux, and in the subsequent section, we will
    delve into its essential features and demonstrate its application through practical
    code examples.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了 React Suspense 的灵活性之后，让我们将注意力转向 React 生态系统中的另一个强大工具：Redux Toolkit。这个工具正在改变
    Redux 的方法，在接下来的章节中，我们将深入探讨其基本特性和通过实际代码示例展示其应用。
- en: 'Redux Toolkit: a modern approach to Redux'
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux Toolkit：Redux 的现代方法
- en: '**Redux Toolkit** is the official, opinionated, and batteries-included toolset
    for efficient Redux development. It was created to help developers write better
    and more efficient Redux code with less boilerplate. In this section, we’ll explore
    the key features of Redux Toolkit, along with code examples to demonstrate how
    to use it in your application.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**Redux Toolkit** 是官方的、有偏见的、包含所有电池的工具集，用于高效的 Redux 开发。它是为了帮助开发者用更少的样板代码编写更好、更高效的
    Redux 代码而创建的。在本节中，我们将探讨 Redux Toolkit 的关键特性，并伴随代码示例来展示如何在您的应用程序中使用它。'
- en: Key features
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键特性
- en: 'Redux Toolkit comes with several key features that simplify the Redux development
    process:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Redux Toolkit 包含几个关键特性，简化了 Redux 开发过程：
- en: '**configureStore**: A function that sets up a Redux store with sensible defaults.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**configureStore**：一个设置具有合理默认值的 Redux 存储的函数。'
- en: '**createSlice**: A function that automatically generates action creators and
    reducers based on a provided configuration.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**createSlice**：一个基于提供的配置自动生成动作创建器和还原器的函数。'
- en: '**createAction**: A utility function to create action creators with a specific
    type and payload.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**createAction**：一个创建具有特定类型和有效负载的动作创建器的实用函数。'
- en: '**createReducer**: A utility function that simplifies reducer creation using
    **Immer**, enabling direct state manipulation.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**createReducer**：一个简化还原器创建的实用函数，使用 **Immer**，允许直接状态操作。'
- en: Getting started
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: 'First, install Redux Toolkit and its peer dependencies:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装 Redux Toolkit 和其依赖项：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Creating a store
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建存储
- en: 'To create a store, we’ll use the `configureStore` function provided by Redux
    Toolkit (`store.ts`):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建存储，我们将使用 Redux Toolkit 提供的 `configureStore` 函数（`store.ts`）：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Creating a slice
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个切片
- en: 'A slice represents a portion of the Redux store that corresponds to a specific
    feature or domain. To create a slice, use the `createSlice` function (`createSlice.ts`):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个切片代表 Redux 存储中与特定功能或领域相对应的部分。要创建一个切片，请使用 `createSlice` 函数（`createSlice.ts`）：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Combining reducers
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并还原器
- en: 'If you have multiple slices, you can use the `combineReducers` function from
    Redux Toolkit to create a root reducer (`rootReducer.ts`):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个切片，您可以使用 Redux Toolkit 中的 `combineReducers` 函数来创建一个根还原器（`rootReducer.ts`）：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Connecting components to the store
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将组件连接到存储
- en: 'To connect a React component to the Redux store, use the `useSelector` and
    `useDispatch` Hooks from the `react-redux` package (`Counter.ts`):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 React 组件连接到 Redux 存储，请使用来自 `react-redux` 包的 `useSelector` 和 `useDispatch`
    钩子（`Counter.ts`）：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Integrating the store with a React application
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将存储与 React 应用程序集成
- en: 'Finally, wrap your React application with the `Provider` component from `react-redux`
    and pass your store as a prop:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用来自 `react-redux` 的 `Provider` 组件包裹您的 React 应用程序，并将您的存储作为属性传递：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this section, we’ve explored Redux Toolkit’s key features, including `configureStore`,
    `createSlice`, `createAction`, and `createReducer`. By utilizing these features,
    developers can write more efficient and maintainable Redux code with less boilerplate.
    The provided code examples demonstrate how to create a simple counter application
    using Redux Toolkit, illustrating the steps required to set up the store, create
    slices and reducers, and connect components to the store. By leveraging Redux
    Toolkit, you can simplify your Redux development process and build more robust
    applications.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了 Redux Toolkit 的关键特性，包括 `configureStore`、`createSlice`、`createAction`
    和 `createReducer`。通过利用这些特性，开发者可以用更少的样板代码编写更高效、更易于维护的 Redux 代码。提供的代码示例演示了如何使用 Redux
    Toolkit 创建一个简单的计数器应用程序，说明了设置存储、创建切片和还原器以及将组件连接到存储所需的步骤。通过利用 Redux Toolkit，您可以简化
    Redux 开发过程并构建更健壮的应用程序。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: I really hope you enjoyed reading this chapter, which contains a lot of information
    about the React Context API and how to implement React Suspense with SWR. We covered
    the basics of the Context API, including how to create and consume contexts, as
    well as how to use the `useContext` Hook for simpler consumption.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我真心希望你喜欢阅读这一章，其中包含了大量关于 React Context API 以及如何使用 SWR 实现React Suspense的信息。我们涵盖了
    Context API 的基础知识，包括如何创建和消费上下文，以及如何使用 `useContext` 钩子进行更简单的消费。
- en: Additionally, we explored React Suspense and how it can improve the user experience
    by allowing us to handle loading states more effectively. We also learned about
    SWR and how it can simplify data fetching and caching with React Suspense. Finally,
    we learned how to implement the new Redux Toolkit. By utilizing these powerful
    tools, you can build more efficient and user-friendly React applications.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还探讨了 React Suspense 以及它如何通过允许我们更有效地处理加载状态来提升用户体验。我们还学习了 SWR 以及它是如何通过 React
    Suspense 简化数据获取和缓存的。最后，我们学习了如何实现新的 Redux Toolkit。通过利用这些强大的工具，你可以构建更高效、更友好的 React
    应用程序。
- en: In the next chapter, we will learn how to use **Server-Side Rendering** in React
    with **Next.js**.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在 React 中使用 **Server-Side Rendering** 和 **Next.js**。
