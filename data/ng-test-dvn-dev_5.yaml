- en: Chapter 5. Protractor, a Step Ahead
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章。Protractor，更进一步
- en: End-to-end testing is real fun as long as it interacts directly with the browser,
    but a good developer should know the advanced features of Protractor to perform
    large-scale application testing. Besides that, debugging is kind of a challenge
    in e2e testing as it depends on the DOM element of the browser.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试真的很有趣，只要直接与浏览器交互，但是一个好的开发者应该了解Protractor的高级功能，以进行大规模的应用程序测试。此外，在端到端测试中调试是一种挑战，因为它取决于浏览器的DOM元素。
- en: 'Protractor has some APIs for debugging. This chapter will mostly cover those
    APIs and features, including the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor有一些用于调试的API。本章将主要涵盖这些API和功能，包括以下内容：
- en: Setting up and configuring Protractor
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和配置Protractor
- en: Some advanced Protractor APIs such as browser, locator, and action
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些高级的Protractor API，比如browser，locator和action
- en: Debugging Protractor with the `browser.pause()` and `browser.debug()` APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`browser.pause()`和`browser.debug()`API来调试Protractor
- en: Advanced setup and configuration
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级设置和配置
- en: In the previous chapter, we saw a basic and commonly used setup and configuration
    for Protractor. Here, we will take a look at some advanced configurations that make
    installation simpler and more powerful.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了Protractor的基本和常用的设置和配置。在这里，我们将看一些高级配置，使安装更简单和更强大。
- en: Installing Protractor globally
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局安装Protractor
- en: 'Here are the steps to install Protractor globally:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是全局安装Protractor的步骤：
- en: 'Once Node.js has been installed and is available in command prompt, type the
    following command to install Protractor globally on the system:'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Node.js被安装并在命令提示符中可用，输入以下命令在系统上全局安装Protractor：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding command uses Node's `npm` command to install Protractor globally
    so that we can use Protractor just with the `protractor` command.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 上一条命令使用了Node的`npm`命令全局安装Protractor，这样我们就可以只用`protractor`命令来使用Protractor了。
- en: 'Test whether the Protractor version can be determined as follows:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试Protractor版本是否可以如下确定：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Advanced configuration
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级配置
- en: 'In this section, we will be configuring Protractor a bit more using the following
    steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用以下步骤对Protractor进行更详细的配置：
- en: 'Update the protractor `config` file to support multiple browsers in a single
    test suite. The `multiCapabilities` parameter is an array that takes multiple
    `browserName` objects for any test suite, as shown here:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新protractor的`config`文件以支持单个测试套件中的多个浏览器。`multiCapabilities`参数是一个数组，可以为任何测试套件传递多个`browserName`对象，如下所示：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can set advanced settings for browsers in the `capabilities` parameter;
    for example, for `chrome`, we can pass extra parameters as `chromeOptions`, as
    follows:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在`capabilities`参数中为浏览器设置高级设置；例如，对于`chrome`，我们可以传递额外的参数作为`chromeOptions`，如下所示：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Sometimes, we may need to run Protractor directly without Selenium or WebDriver.
    This is possible by passing a parameter in the `config.js` file. The parameter
    is `directConnect: true` in the configuration object, as shown here:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '有时，我们可能需要直接运行Protractor而不使用Selenium或WebDriver。这可以通过在`config.js`文件中传递一个参数来实现。该参数是配置对象中的`directConnect:
    true`，如下所示：'
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Great! We have configured Protractor a step ahead.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们已经配置了Protractor更进一步。
- en: Protractor APIs
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Protractor API
- en: The main activities of an e2e test for any web page are to get the DOM elements
    of that page, interact with them, assign an action to them, and share information
    with them; then, the user can get the current state of the website. To enable
    us to perform all these actions, Protractor provides a wide array of APIs (some
    are from the web driver). In this chapter, we will look at some commonly used
    APIs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试任何网页的主要活动是获取该页面的DOM元素，与它们交互，为它们分配一个动作，并与它们共享信息；然后，用户可以获取网站的当前状态。为了使我们能够执行所有这些操作，Protractor提供了各种各样的API（其中一些来自web
    driver）。在本章中，我们将看一些常用的API。
- en: In the previous chapter, we saw how Protractor works with an Angular project,
    where we had to interact with UI elements. For that, we used a few Protractor
    APIs, such as `element.all`, `by.css`, `first`, `last`, and `getText`. However,
    we didn't see or understand the workings of these APIs in depth. To understand
    the workings of APIs in Protractor is very simple, but in real life we will mostly
    have to work with bigger, complex projects. Hence, it's important that we understand
    and know more about these APIs in order to interact with the UI and play with
    its events.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了Protractor如何与Angular项目一起工作，我们需要与UI元素进行交互。为此，我们使用了一些Protractor API，比如`element.all`，`by.css`，`first`，`last`和`getText`。然而，我们没有深入了解这些API的工作原理。要理解Protractor中API的工作原理非常简单，但在现实生活中，我们大多数时候将不得不处理更大、更复杂的项目。因此，重要的是我们了解并更多地了解这些API，以便与UI进行交互并玩耍。
- en: Browser
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器
- en: Protractor works with Selenium WebDriver, which is a browser automation framework.
    We can use a method from the Selenium WebDriver API to interact with the browser
    from the test spec. We will take a look at a few of them in the following sections.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor与Selenium WebDriver一起工作，后者是一个浏览器自动化框架。我们可以使用Selenium WebDriver API中的方法来与测试规范中的浏览器进行交互。我们将在接下来的章节中看一些这些方法。
- en: 'To navigate the browser to a specific web address and load the mock modules
    for that page before the Angular load, we will use the `.get()` method by passing
    the specific address or relative path:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要将浏览器导航到特定的网址并在Angular加载之前加载该页面的模拟模块，我们将使用`.get()`方法，通过传递特定的地址或相对路径：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To get the current page''s web URL, use the `CurrentUrl()` method, as shown
    here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取当前页面的网址，使用`CurrentUrl()`方法，如下所示：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To navigate to another page and browse it using in-page navigation, `setLocation` is
    used, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要导航到另一个页面并使用页面内导航进行浏览，使用`setLocation`，如下所示：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To get the title of the current page (basically, the title that is set in the
    HTML page), the `getTitle` method is used, as shown here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取当前页面的标题（基本上是在HTML页面中设置的标题），使用`getTitle`方法，如下所示：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To reload the current page with the mocks module before the Angular load, the
    `refresh()` method is used, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Angular加载之前使用模拟模块重新加载当前页面，使用`refresh()`方法，如下所示：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To pause the test process, the `pause()` method is used. This is useful for debugging
    the test process, and we will use this test debugging section:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要暂停测试过程，使用`pause()`方法。这对于调试测试过程非常有用，我们将使用这个测试调试部分：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To debug the test process, the `debugger()` method is used. This method is
    different and can be considered an advanced level of the `pause()` method. This
    is useful for advanced debugging of the test process, along with injecting custom
    helper function into the browser. We will use this test debugging section as well:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试测试过程，使用`debugger()`方法。这个方法是不同的，可以被认为是`pause()`方法的高级版本。这对于测试过程的高级调试以及将自定义辅助函数注入到浏览器中非常有用。我们也将使用这个测试调试部分：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To close the current browser, `close()` is used. This is useful for complex
    multimodule testing, when we sometimes need to close the current browser before
    opening a new one:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭当前浏览器，使用`close()`。这对于复杂的多模块测试非常有用，有时我们需要在打开新浏览器之前关闭当前浏览器：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To support Angular in Protractor, we have to set the `useAllAngularAppRoots`
    params to `true`. The logic behind doing this is that, when we set this parameter
    to `true`, it will search for all Angular apps in the page while the element finder
    traverses through the page:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Protractor中支持Angular，我们必须将`useAllAngularAppRoots`参数设置为`true`。这样做的逻辑是，当我们将此参数设置为`true`时，它将在元素查找器遍历页面时搜索所有Angular应用程序：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Elements
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Elements
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Protractor itself exposes some global functions, and `element` is one of them.
    This function takes a locator (a kind of selector--we will discuss it in the next
    step) and returns an `ElementFinder`. This function basically finds a single element
    based on the locator, but it supports multiple element singing along with chaining
    another method as `element.all`, which also takes a locator and returns an `ElementFinderArray`.
    Both of them support chaining methods for the next action.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor本身暴露了一些全局函数，`element`就是其中之一。这个函数接受一个定位器（一种选择器--我们将在下一步中讨论），并返回一个`ElementFinder`。这个函数基本上是根据定位器找到单个元素，但它支持多个元素的选择，以及链式调用另一个方法`element.all`，它也接受一个定位器并返回一个`ElementFinderArray`。它们都支持链式方法进行下一步操作。
- en: element.all
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: element.all
- en: 'As we already know, `element.all` returns an `ElementArrayFinder` that supports
    chaining methods for the next action. We will look at a few of them and how they
    actually work:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经知道的那样，`element.all`返回一个`ElementArrayFinder`，支持链式方法进行下一步操作。我们将看一下其中一些方法以及它们的实际工作方式：
- en: 'To select multiple elements as an array with a specific locator, we should
    use `element.all`, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择多个具有特定定位器的元素数组，我们应该使用`element.all`，如下所示：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After getting a bunch of elements as an array, we may need to select a specific
    element. In that case, we should be chaining `get(position)` by passing the specific
    array index as the position number:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在将一堆元素作为数组获取之后，我们可能需要选择特定的元素。在这种情况下，我们应该通过传递特定的数组索引作为位置号来链接`get(position)`：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After getting a bunch of elements as an array, we might need to select child
    elements again with a preferred locator, and for that we can chain the `.all(locator)`
    method again with the existing elements, as shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在将一堆元素作为数组获取之后，我们可能需要再次选择子元素并使用首选的定位器，为此我们可以再次使用现有元素链接`.all(locator)`方法，如下所示：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After getting the desired elements, we might want to check whether the number
    of elements selected is as expected. There is a method, `count()`, that is used
    to chain to get the total number of selected elements:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 获取所需的元素之后，我们可能想要检查所选择的元素数量是否符合预期。有一个名为`count()`的方法，用于链到获取所选元素的总数：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Similar to the `get(position)` method, we can get the first element from the
    array by chaining the `first()` method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与`get(position)`方法类似，我们可以通过链接`first()`方法从数组中获取第一个元素：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similar to the `first()`method, we can get the last element from the array
    by chaining the `last()` method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与`first()`方法类似，我们可以通过链接`last()`方法从数组中获取最后一个元素：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As long as we have a bunch of elements as an array, we may need to traverse
    though the elements to take any action. In that case, we may need to go through
    a loop by chaining the `each()` method:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们有一堆元素作为数组，我们可能需要遍历这些元素以执行任何操作。在这种情况下，我们可能需要通过链接`each()`方法来进行循环：
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Just like the `each()` method, there is another method, `filter()`, to chain
    with the element array to traverse through the items and assign a filter to them:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`each()`方法一样，还有另一个方法`filter()`，可以与元素数组链接以遍历项目并为它们分配一个过滤器：
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: element
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: element
- en: The `element` class returns `ElementFinder`, which means a single element in
    the element array, and this also supports chaining methods for the next action.
    In the previous examples, we saw how to obtain a single selected element from
    the element array so that all of the chaining methods work on that single element
    as well. There are a lot of chaining methods for working on a single element,
    and we will look at a few that are most commonly used.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`element`类返回`ElementFinder`，这意味着元素数组中的单个元素，它也支持链接方法以进行下一个操作。在前面的示例中，我们看到了如何从元素数组中获取单个选择的元素，以便所有链接方法也适用于该单个元素。有许多用于操作单个元素的链接方法，我们将看一些最常用的方法。'
- en: 'By passing a specific locator as an argument to the `element` method, we can
    select a single DOM element, as shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将特定的定位器作为参数传递给`element`方法，我们可以选择单个DOM元素，如下所示：
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After getting a specific single element, we may need to find the child element
    of the element on which we have to chain the `element.all` method with the rerun
    `elementFinder` object. For this, pass a specific locator to find the child `elementFinderArray`,
    as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 获取特定的单个元素后，我们可能需要找到该元素的子元素，然后使用`element.all`方法与重新运行的`elementFinder`对象链接。为此，将特定的定位器传递给`elementFinderArray`以查找子元素，如下所示：
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After selecting a specific element, we might need to check whether that element
    is present while chaining the `isPresent()` method, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择特定元素后，我们可能需要检查该元素是否存在，同时链接`isPresent()`方法，如下所示：
- en: '[PRE24]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Actions
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作
- en: Actions mainly change the method that affects or triggers the selected DOM element.
    The goal of selecting a DOM element is to interact with it by triggerring some
    actions so that it can act like a real user. There are some commonly used actions
    for specific interaction. We will look at a few of them here.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 操作主要是改变影响或触发所选DOM元素的方法。选择DOM元素的目的是通过触发一些操作与其交互，以便它可以像真正的用户一样行动。有一些常用的用于特定交互的操作。我们将在这里看一些。
- en: 'To get the inner text or contained text of any element, we have to chain the
    `getText()`method with the `elementFinder` object after selecting the specific
    element, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取任何元素的内部文本或包含的文本，我们必须在选择特定元素后，将`getText()`方法与`elementFinder`对象链接，如下所示：
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To get the inner HTML of any element, we have to chain the `getInnerHtml()`method
    with the `elementFinder` object after selecting the specific element, as shown
    here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取任何元素的内部HTML，我们必须在选择特定元素后，将`getInnerHtml()`方法与`elementFinder`对象链接，如下所示：
- en: '[PRE26]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can find any specific attribute value of any element by passing the attribute
    key to the `getAttribute()` method, which will chain with the selected `elementFinder`
    object, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将属性键传递给`getAttribute()`方法，我们可以找到任何元素的特定属性值，并将其与所选的`elementFinder`对象链接，如下所示：
- en: '[PRE27]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In most cases, we need to clear the value of the input field. For that, we
    can chain the `clear()`method with the selected `elementFinder` object, as shown:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们需要清除输入字段的值。为此，我们可以将`clear()`方法与所选的`elementFinder`对象链接，如下所示：
- en: '[PRE28]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that it's only the input or texture that may have some value and needs
    you to clear/reset the value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，只有输入或文本可能具有一些值，并且需要您清除/重置该值。
- en: 'When we need to trigger a click event on any button, link, or image, after
    selecting a specific `elementFinder` object, we will need to chain the `click()`
    method, and it will act like a real click on that element:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要在选择特定的`elementFinder`对象后触发按钮、链接或图像的点击事件时，我们需要链接`click()`方法，它将像真正的点击那个元素一样：
- en: '[PRE29]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Sometimes, we might need to trigger the `submit()` method for form submission.
    In that case, we have to chain the `submit()` method with the selected element.
    The selected element should be a `form` element:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能需要触发`submit()`方法进行表单提交。在这种情况下，我们必须将`submit()`方法与所选元素链接起来。所选元素应该是一个`form`元素：
- en: '[PRE30]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Locators
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位器
- en: Locators inform Protractor how to find a certain element in the DOM element.
    Protractor exports `locator` as a global factory function, which will be used
    with a global `by` object. We can use them in many ways based on our DOM, but
    let's look at some of the most commonly used ones.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 定位器告诉Protractor如何在DOM元素中找到某个元素。Protractor将`locator`作为全局工厂函数导出，将与全局`by`对象一起使用。根据我们的DOM，我们可以以许多方式使用它们，但让我们看看一些最常用的方式。
- en: 'We can select any element by passing any of the CSS selectors to the `by.css`
    method, as shown here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将任何CSS选择器之一传递给`by.css`方法来选择任何元素，如下所示：
- en: '[PRE31]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can select any element by passing its element ID to the `by.id` method,
    as shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将其元素ID传递给`by.id`方法来选择任何元素，如下所示：
- en: '[PRE32]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can also select a specific element or elements by tag name by passing it
    to `by.tagName`, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过将其传递给`by.tagName`来选择特定的元素或元素标签名，如下所示：
- en: '[PRE33]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To select the DOM element of any specific input field, we can pass the name
    in the `by.name` method, as shown:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择任何特定输入字段的DOM元素，我们可以在`by.name`方法中传递名称，如下所示：
- en: '[PRE34]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Besides a CSS selector or ID, we can select a specific button by passing its
    text label to `by.buttonText`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 除了CSS选择器或ID之外，我们还可以通过将其文本标签传递给`by.buttonText`来选择特定的按钮：
- en: '[PRE35]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can find an element by passing the model name defined as an `ng-model` on
    `by.model`, as shown here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将模型名称定义为`ng-model`传递给`by.model`来查找元素，如下所示：
- en: '[PRE36]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Similarly, we can find a specific DOM element by passing its binding defined
    with `ng-bind` in `by.bindings`, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以通过在`by.bindings`中定义的绑定`ng-bind`来查找特定的DOM元素，如下所示：
- en: '[PRE37]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Besides all the locators explained earlier, there is another way to find a
    specific DOM element: a custom locator. Here, we have to create a custom locator
    using `by.addLocator` by passing the locator name and callback. Then, we have
    to pass that custom locator with `by.customLocatorName(args)`, as shown here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前解释的所有定位器，还有另一种找到特定DOM元素的方法：自定义定位器。在这里，我们必须使用`by.addLocator`创建一个自定义定位器，通过传递定位器名称和回调。然后，我们必须通过`by.customLocatorName(args)`传递该自定义定位器，如下所示：
- en: '[PRE38]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Protractor tests - postmortem
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Protractor测试-事后分析
- en: It's kind of difficult to debug e2e tests as they depend on the entire ecosystem
    of an application. Sometimes they depend on prior actions such as login, and sometimes
    they depend on permissions. Another major barrier to debugging e2e is its dependency
    on WebDriver. As it acts differently with different operating systems and browsers,
    this makes it difficult to debug e2e. Besides that, it generates long error messages,
    which makes it difficult to separate browser related issues and test process errors.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 调试e2e测试有点困难，因为它们依赖于应用程序的整个生态系统。有时它们依赖于先前的操作，比如登录，有时它们依赖于权限。调试e2e的另一个主要障碍是它依赖于WebDriver。由于它在不同的操作系统和浏览器上的行为不同，这使得调试e2e变得困难。除此之外，它生成了很长的错误消息，这使得很难区分与浏览器相关的问题和测试过程中的错误。
- en: Still, we will try to debug all e2e tests and see how that works for our case.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们将尝试调试所有的e2e测试，看看对我们的情况有何作用。
- en: Types of failure
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 失败类型
- en: There might be various reasons for the failure of a test suite as long as it
    depends on WebDriver and various parts throughout the system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件失败可能有各种原因，因为它依赖于WebDriver和系统中的各个部分。
- en: 'Let''s look at some known failure types:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些已知的失败类型：
- en: '**WebDrive failure**: WebDriver throws an error when a command can''t be completed.
    For example, a browser can''t get the address that''s defined to help it navigate,
    or maybe an element is not found as expected.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebDrive失败**：当命令无法完成时，WebDriver会抛出错误。例如，浏览器无法获取定义的地址来帮助它导航，或者可能找不到预期的元素。'
- en: '**WebDriver unexpected failure**: Sometimes, WebDriver fails and gives an error
    when it fails to update the web driver manager. This is a browser and OS-related
    issue, although it''s not common.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebDriver意外失败**：有时，WebDriver会因无法更新Web驱动程序管理器而失败并报错。这是一个与浏览器和操作系统相关的问题，尽管不常见。'
- en: '**Protractor failure for Angular**: Protractor will fail when Angular is not found
    in the library as expected because the Protractor test depends on Angular itself.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular的Protractor失败**：当Protractor在库中找不到预期的Angular时，Protractor会失败，因为Protractor测试依赖于Angular本身。'
- en: '**Protractor Angular2 failure**: Protractor will fail for an Angular project''s
    test spec when the `useAllAngular2AppRoots` parameter is missing in the configuration
    because, without this, the test process will look at one single root element while
    expecting more elements in the process.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Protractor Angular2失败**：当配置中缺少`useAllAngular2AppRoots`参数时，Protractor将在Angular项目的测试规范中失败，因为没有这个参数，测试过程将只查看一个单一的根元素，而期望在过程中有更多的元素。'
- en: '**Protractor failure for timeout**: Sometimes, Protractor fails for the timeout
    when the test spec falls into a loop or a long pool and fails to return data in
    time. However, a timeout is configurable, so it can be increased as needed.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Protractor超时失败**：有时，当测试规范陷入循环或长时间等待并且无法及时返回数据时，Protractor会因超时而失败。但是，超时是可配置的，因此可以根据需要增加。'
- en: '**Expectation failure**: This is a common failure in the test spec.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**期望失败**：这是测试规范中常见的失败。'
- en: Loading an existing project
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载现有项目
- en: 'The code used in this test comes from [Chapter 4](ch04.html "Chapter 4. End-to-End
    Testing with Protractor"), *End to End Testing with Protractor*. We will copy
    the code to a new directory: `angular-protractor-debug`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本测试中使用的代码来自[第4章](ch04.html "第4章。使用Protractor进行端到端测试")*使用Protractor进行端到端测试*。我们将代码复制到一个新目录：`angular-protractor-debug`。
- en: As a reminder, the application was a to-do application that had some items in
    the to-do list, and we added some items to it. It has a single component class,
    `AppComponent`, which has a list of items, and an `add` method.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，该应用程序是一个待办事项应用程序，其中有一些待办事项列表，并且我们向其中添加了一些项目。它有一个单一的组件类`AppComponent`，其中有一个项目列表和一个`add`方法。
- en: 'The current directory should be structured as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当前目录应该按以下结构组织：
- en: '![Loading an existing project](graphics/image_05_001.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![加载现有项目](graphics/image_05_001.jpg)'
- en: 'After verifying that the folder structure is the same as shown in the preceding
    screenshot, the first job is to get the required dependencies, `node_modules`,
    locally by running the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证文件夹结构与前面截图中显示的相同之后，第一步是通过运行以下命令在本地获取所需的依赖项`node_modules`：
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This will install all the required modules. Now, let''s build and run the project
    with the `npm` command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装所有所需的模块。现在，让我们使用`npm`命令构建和运行项目：
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Everything should be fine now: the project should run on `http://localhost:3000`,
    and the output should be as shown:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切应该都没问题了：项目应该在`http://localhost:3000`上运行，并且输出应该如下所示：
- en: '![Loading an existing project](graphics/image_05_002.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![加载现有项目](graphics/image_05_002.jpg)'
- en: With that, we are ready to go on to the next step of implementing a debugger
    in our Angular project.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就可以继续实现在我们的Angular项目中加入调试器的下一步了。
- en: Including the debugger in the project
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在项目中包含调试器
- en: Before adding the debugger to our project, let's run the e2e test in our existing
    project. We hope to pass without any failure in the e2e test specs.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在将调试器添加到我们的项目之前，让我们在现有项目中运行e2e测试。我们希望在e2e测试规范中没有任何失败的情况下通过。
- en: 'Let''s run it using the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令运行它：
- en: '[PRE41]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As expected, our tests passed. The result is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，我们的测试通过了。结果如下：
- en: '![Including the debugger in the project](graphics/image_05_003.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![将调试器包含在项目中](graphics/image_05_003.jpg)'
- en: 'We can add our debugging code in the same place where the passed test specs
    are, but let''s keep the passed test case separate and play with the debugger
    in a different directory. Let''s create a new directory, `debug/`. We will need
    two files in the directory: one for the configuration and the other for the spec.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在已通过的测试规范所在的位置添加我们的调试代码，但让我们将已通过的测试用例与调试器分开，并在不同的目录中进行调试。让我们创建一个新目录，`debug/`。我们需要该目录中的两个文件：一个用于配置，另一个用于规范。
- en: For the Protractor configuration file, we can copy the `protractor.conf.js`
    file and rename it to `debugConf.js`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Protractor配置文件，我们可以复制`protractor.conf.js`文件并将其重命名为`debugConf.js`。
- en: Everything in the configuration will be the same as the previous configuration.
    However, we need to increase the default timeout for the Jasmine test, or the
    test will timeout during debugging.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 配置中的一切都与先前的配置相同。但是，我们需要增加Jasmine测试的默认超时时间，否则在调试过程中测试将超时。
- en: 'Let''s increase the timeout to `3000000` ms:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将超时时间增加到`3000000`毫秒：
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Next, we will need a spec file to which to write the test spec and debug tests.
    Save the new spec file as `app.debug.e2e.ts`. Oh yes, we will need to change the
    config file once again to define the spec files for debugging.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将需要一个规范文件来编写测试规范和调试测试。将新的规范文件保存为`app.debug.e2e.ts`。哦是，我们需要再次更改配置文件以定义调试的规范文件。
- en: '[PRE43]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We can make a simple test spec file for `app.debug.e2e.ts`. Then, we can add
    debug codes and play with them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为`app.debug.e2e.ts`创建一个简单的测试规范文件。然后，我们可以添加调试代码并进行调试。
- en: 'Simple test specs are as shown:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的测试规范如下所示：
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Pausing and debugging
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂停和调试
- en: 'To debug any test spec, we must pause the test process and see what is going
    on step-by-step. Protractor also has built-in methods to pause the process. Here
    are two methods to pause and debug the test process:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试任何测试规范，我们必须暂停测试过程并逐步查看发生了什么。Protractor也有内置方法来暂停测试过程。以下是两种暂停和调试测试过程的方法：
- en: '`browser.pause()`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`browser.pause()`'
- en: '`browser.debugger()`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`browser.debugger()`'
- en: Using pause
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用暂停
- en: Debugging Protractor tests becomes easy and simple with the `browser.pause()`
    command. Using the `pause()` method, we can enter the Protractor debugger control
    flow and execute some commands to check out what's happening in the control flow
    of the test. Mostly, developers use debuggers in tests when the test fails with
    an unknown error and there are long error messages.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`browser.pause()`命令，调试Protractor测试变得简单而容易。使用`pause()`方法，我们可以进入Protractor调试器控制流，并执行一些命令来检查测试控制流中发生了什么。大多数情况下，开发人员在测试失败并出现未知错误以及出现长错误消息时使用调试器。
- en: After using the `browser.pause()` command, we can use a few more commands based
    on our needs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`browser.pause()`命令后，我们可以根据需要使用更多命令。
- en: 'Let''s take a brief look:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要看一下：
- en: '`c`: If we type `c` as a command, it will move one step forward in the test,
    and we will see how the test command works in depth. If we plan to move forward
    with a test, it''s better to do it quickly as there is a timeout issue ( the Jasmine
    default timeout), which we''ve learned about. We will see an example later on.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c`：如果我们将`c`作为一个命令输入，它将在测试中向前移动一步，我们将深入了解测试命令的工作原理。如果我们计划继续进行测试，最好快点进行，因为会有超时问题（Jasmine默认超时），我们已经了解过了。稍后我们会看到一个例子。'
- en: '`repl`: By typing `repl` as a command, we can enter the interactive mode of
    debugging. It''s known as as the interactive mode as, from there, we can interact
    directly with the browser from the terminal by typing WebDriver commands. A response,
    result, or error from the browser will be displayed on the terminal as well. We
    will see more hands-on examples later.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repl`：通过输入`repl`作为命令，我们可以进入调试的交互模式。它被称为交互模式，因为我们可以直接从终端与浏览器交互，通过输入WebDriver命令。浏览器的响应、结果或错误也将显示在终端上。稍后我们将看到更多实际的例子。'
- en: '`Ctrl + C`: Press ***Ctrl*** + C to exit pause mode and continue the test.
    When we will use this, the test will continue from the point where it paused.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ctrl + C`：按下***Ctrl*** + C退出暂停模式并继续测试。当我们使用这个时，测试将从暂停的地方继续。'
- en: A quick example
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个快速的例子
- en: To use `browser.pause()` in test specifications, we will have to add the method
    to the test spec at the places we want to pause the test and watch the control
    flow for debugging. Here, we just have one test spec with a wrong/failing test
    case, we know it will fail, and we will find out why it failed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要在测试规范中使用`browser.pause()`，我们将在测试规范中的希望暂停测试并观察控制流的地方添加该方法。在这里，我们只有一个测试规范，有一个错误/失败的测试用例，我们知道它会失败，我们将找出失败的原因。
- en: 'We will have to add the `pause()` method, as shown, to the test `spec it()
    {}` function:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如所示将`pause()`方法添加到测试`spec it() {}`函数中：
- en: '[PRE45]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It's time to run the test. As we've separated the test spec for the debugger,
    we will run the test via Protractor (not `npm`).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候运行测试了。由于我们已经将调试器的测试规范分开，我们将通过Protractor（而不是`npm`）运行测试。
- en: 'Let''s run the test with the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用以下命令运行测试：
- en: '[PRE46]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As we have placed the `browser.pause()` method before the `expect()` method,
    it will pause there. We can see in the control flow that this makes it wait for
    Angular:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`expect()`方法之前放置了`browser.pause()`方法，它将在那里暂停。我们可以看到在控制流中，这使得它等待Angular：
- en: '![A quick example](graphics/image_05_004.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![一个快速的例子](graphics/image_05_004.jpg)'
- en: 'We will move forward; for that, let''s type `C`. It will run `executeAsyncScript`
    and will wait for Angular to load:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续前进；为此，让我们输入`C`。它将运行`executeAsyncScript`并等待Angular加载：
- en: '![A quick example](graphics/image_05_005.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![一个快速的例子](graphics/image_05_005.jpg)'
- en: 'We will move another step ahead by typing `C`. It will try to select the element
    based on the locator provided by us, that is, `element(by.id(''my_id'')`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再向前迈出一步，输入`C`。它将尝试根据我们提供的定位器选择元素，即`element(by.id('my_id')`：
- en: '![A quick example](graphics/image_05_006.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![一个快速的例子](graphics/image_05_006.jpg)'
- en: 'We are close to getting the test result now. For that, we will have to move
    another step forward by typing `C`. Now, it will try to select the element based
    on the locator, and it will fail to select that. This will give a result with
    an error message, as expected:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们接近获得测试结果了。为此，我们将再向前迈出一步，输入`C`。现在，它将尝试根据定位器选择元素，并且将无法选择。这将产生一个带有错误消息的结果，正如预期的那样：
- en: '![A quick example](graphics/image_05_007.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![一个快速的例子](graphics/image_05_007.jpg)'
- en: Debugging with interactive mode
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用交互模式进行调试
- en: To enter interactive mode, we have to type `repl`, after which we can run any
    command used in the test spec.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入交互模式，我们必须输入`repl`，之后可以运行测试规范中使用的任何命令。
- en: 'Let''s find the element and its text:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找到元素及其文本：
- en: '[PRE47]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The result is the same as we got previously, by moving forward step by step,
    by typing `C`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与之前一样，通过逐步前进，输入`C`。
- en: '**Result**: `NoSuchElementError: No element found using locator: By (css selector,`
    `*[id="my_id"])`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**：`NoSuchElementError: 使用定位器未找到元素：By (css 选择器，` `*[id="my_id"])`'
- en: 'Now, let''s see how interactive mode works for a valid locator, when the `element`will
    be found:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当`element`将被找到时，交互模式如何为有效的定位器工作：
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**Result**: `test`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**：`测试`'
- en: Using the debugger
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用调试器
- en: Debugging with the `browser.debugger()` command is a bit complex and more advanced
    than using `browser.pause()`. With the `browser.pause()` command, we can pause
    the control flow of the test and inject the custom helper functions into the browser
    so that debugging happens in the same way as we would debug in a browser console.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `browser.debugger()` 命令进行调试比使用 `browser.pause()` 更复杂和更高级。使用 `browser.pause()`
    命令，我们可以暂停测试的控制流，并将自定义辅助函数注入到浏览器中，以便调试的方式与我们在浏览器控制台中调试的方式相同。
- en: This debugging should be under node in debug mode, like here in Protractor debugging.
    This debugging is not useful for someone bad at node debugging.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这种调试应该在节点调试模式下进行，就像在 Protractor 调试中一样。这种调试对于不擅长节点调试的人来说并不有用。
- en: 'Here is an example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: To use the `browser.debugger()` method in the test spec, we will have to add
    the method to the test spec at the points where we want to set a breakpoint and
    watch the control flow.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要在测试规范中使用 `browser.debugger()` 方法，我们将不得不在测试规范中添加该方法，以设置断点并观察控制流。
- en: 'For us, we have to add the `debugger()` method, as follows, to the `test spec
    it() {}` function, and this will be our breakpoint:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，我们必须添加 `debugger()` 方法，如下所示，到 `test spec it() {}` 函数中，这将是我们的断点：
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now let''s run it:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行它：
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To run the debugger, we have to add `debug` to the command after `protractor`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行调试器，我们必须在 `protractor` 后面添加 `debug`。
- en: 'After running the command, we have to move forward by typing `C`, but here
    we need to do it just once. The output is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，我们必须输入 `C` 继续，但这里我们只需要这样做一次。输出如下：
- en: '![Using the debugger](graphics/image_05_008.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![使用调试器](graphics/image_05_008.jpg)'
- en: Self-test questions
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: Q1\. `Selenium WebDriver` is a browser automation framework.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Q1\. `Selenium WebDriver` 是一个浏览器自动化框架。
- en: 'True'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真
- en: 'False'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假
- en: Q2\. Using `browser.debugger()` is a simple way to debug Protractor.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Q2\. 使用 `browser.debugger()` 是调试 Protractor 的一种简单方法。
- en: 'True'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真
- en: 'False'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假
- en: Q3\. What are `by.css()`, `by.id()`, and `by.buttonText()` called?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Q3\. `by.css()`、`by.id()` 和 `by.buttonText()` 被称为什么？
- en: Elements
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素
- en: Locators
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定位器
- en: Actions
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作
- en: Browsers
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Protractor has various kinds of API. In this chapter, we tried to understand
    some of the most commonly used APIs with some examples. We also covered API types
    (such as browser, elements, locator, and actions), and how they are chained with
    one another, in some detail.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor 有各种类型的 API。在本章中，我们试图了解一些最常用的 API，并提供了一些示例。我们还详细介绍了 API 类型（如浏览器、元素、定位器和操作），以及它们如何相互链接。
- en: Debugging was introduced in this chapter, and we tried to learn a simple way
    to debug, using `browser.pause()`, in more detail, and then we moved on to a complex
    method (`browser.debugger()`), and understood that complex developers need node
    debugger experience.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中介绍了调试，并尝试学习了一种简单的调试方法，使用 `browser.pause()`，然后我们转向了一种复杂的方法（`browser.debugger()`），并了解到复杂的开发人员需要节点调试器经验。
- en: In the next chapter, we will delve into more real-life projects; further, we
    will go through the top-down and bottom-up approaches and learn them both.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入研究更多的现实项目；此外，我们将学习自上而下和自下而上的方法，并学会它们。
