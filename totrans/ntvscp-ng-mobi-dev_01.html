<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Get Into Shape with @NgModule</h1>
                
            
            <article>
                
<p class="mce-root">In this chapter, we are going to kick things off with some solid project organization exercises to prepare us for building an amazing app with NativeScript for Angular. We want to give you some insights into a few important and powerful concepts to think about as you plan your architecture, to pave your way to a smooth development experience with scalability in mind.</p>
<p class="mce-root">Combining Angular with NativeScript provides a wealth of useful paradigms and tools to construct and plan your app. As often said, with great power comes great responsibility, and as awesome as this tech combination is to create amazing apps, they can also be used for creating an overengineered and difficult to debug app. Let's take a few chapters to walk through some exercises you can use to help avoid common pitfalls and truly unlock the full potential of this stack.</p>
<p class="mce-root">We will introduce you to Angular's <kbd class="calibre11">@NgModule</kbd> decorator, which we will use exclusively to help organize our app's code into logical units with explicit purpose and portability in mind. We will also introduce a few Angular concepts we will use in our architecture, such as dependency injectable services. After doing our diligence in building a solid foundation to work with, we will rapidly approach running our app for the first time towards the end of third chapter.</p>
<p class="mce-root">In this chapter, we will be covering the following topics:</p>
<ul class="calibre13">
<li class="calibre14">What is NativeScript for Angular?</li>
<li class="calibre14">Setting up your native mobile app</li>
<li class="calibre14">Project Organization</li>
<li class="calibre14">Architecture planning</li>
<li class="calibre14"><kbd class="calibre11">@NgModule</kbd> decorator</li>
<li class="calibre14"><kbd class="calibre11">@Injectable</kbd> decorator</li>
<li class="calibre14">Breaking your app into modules</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mental preparation</h1>
                
            
            <article>
                
<p class="mce-root">Before diving right into coding, you can greatly enhance the development experience for your project by mapping out the various services and features your app needs. Doing so will help reduce code duplication, frame your data flow, and lead the way for rapid feature development in the future.</p>
<p class="mce-root">A service is a class that typically handles processing and/or provides data to your app. Your usage of these services does not need to know the specifics of where the data came from, just that it can ask the service for its purpose and it will happen.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The sketch exercise</h1>
                
            
            <article>
                
<p class="mce-root">A good exercise for this is to sketch out a rough idea of one of your app views. You may not know what it will look like yet and that's okay; this is purely an exercise to think about the user expectations as a first step to guiding your thought process into the various sections or modules you need to construct to meet those expectations. It will also help you think about the various states the app needs to manage.</p>
<p class="mce-root">Take, for example, the app we are going to build, <strong class="calibre1">TNSStudio</strong> (<strong class="calibre1">Telerik NativeScript</strong> (<strong class="calibre1">TNS</strong>))<em class="calibre21">.</em> We will dive into more detail of what our app is and what exactly it will do in <a target="_blank" href="part0037.html#1394Q0-289fe2426d594f99a90e4363b2c9c34d" class="calibre3">Chapter 2</a>, <em class="calibre21">Feature Modules</em>.</p>
<div class="mce-root1"><img class="image-border" src="../images/00005.jpeg"/></div>
<p class="mce-root">Starting from top to bottom, we can see a header with a menu button, a logo, and a record button. Then, we have a listing of user recorded tracks, each with a (re)record button and a solo or mute button.</p>
<p class="mce-root">From this one sketch, we may think about several services the app may need to provide:</p>
<ul class="calibre13">
<li class="calibre14">A Player Service</li>
<li class="calibre14">A Recorder Service</li>
<li class="calibre14">A Persistent Store service to remember which volume level settings the user sets for each track in the recording mix and/or if the user is authenticated</li>
</ul>
<p class="mce-root">We can also gain some insight into the various states the app may need to manage:</p>
<ul class="calibre13">
<li class="calibre14">A listing of user recordings/tracks</li>
<li class="calibre14">Whether the app is playing audio or not</li>
<li class="calibre14">Whether the app is in the recording mode or not</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Low-level thinking</h1>
                
            
            <article>
                
<p class="mce-root">It's also advantageous to provide some low-level services that provide a convenient API to access things, such as HTTP remote requests and/or logging. Doing so will allow you to create unique characteristics that you or your team like to work with when interacting with low-level APIs. For instance, maybe your backend API requires a unique header to be set in addition to a special authentication header for each request. Creating a low-level wrapper around an HTTP service will allow you to isolate those unique characteristics and provide a consistent <span>API</span> for your app to interact with, to guarantee all the <span>API</span> calls are enhanced with what they need in one place.</p>
<p class="mce-root">Additionally, your team may desire an ability to funnel all the logging code to a third-party log analyzer (for debugging or other performance-related metrics). Creating low-level wrappers with the lean code around some framework services will allow your app to adapt to these potential needs quickly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Modularize with @NgModule</h1>
                
            
            <article>
                
<p class="mce-root">We can then think about breaking these services up into organizational units or modules.</p>
<p class="mce-root">Angular provides us with the <kbd class="calibre11">@NgModule</kbd> decorator, which will help us define what these modules look like and what they provide to our app. In an effort to keep our app's bootstrap/launch time as fast as possible, we can organize our modules in such a way to allow some service/features to be lazily loaded after our app has launched. Bootstrapping one module with a small subset of required code that our app needs to launch will help keep this launch phase to a minimum.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Our app's module breakdown</h1>
                
            
            <article>
                
<p class="mce-root">Here's how we will break down our app organization by module:</p>
<ol class="calibre16">
<li value="1" class="calibre14"><kbd class="calibre11">CoreModule</kbd>: Low-level services, components, and utilities that provide a nice foundation layer. Things such as interacting with logging, dialogs, HTTP, and other various commonly used services.</li>
<li value="2" class="calibre14"><kbd class="calibre11">AnalyticsModule</kbd><strong class="calibre1">**</strong>: Potentially, you could have a module that provides various services to handle analytics for your app.</li>
</ol>
<ol start="3" class="calibre16">
<li value="3" class="calibre14"><kbd class="calibre11">PlayerModule</kbd><strong class="calibre1">*</strong>: Provides everything our app needs to play audio.</li>
<li value="4" class="calibre14"><kbd class="calibre11">RecorderModule</kbd><strong class="calibre1">*</strong>: Provides everything our app needs to record audio.</li>
</ol>
<div class="packt_infobox"><em class="calibre23">(*)</em>These are considered <em class="calibre23">Feature Modules.<br class="calibre24"/></em> <em class="calibre23">(**)</em>We will omit this module from the example in this book but wanted to mention it here for context.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The module benefits</h1>
                
            
            <article>
                
<p class="mce-root">Using a similar organization provides several advantageous things for you and your team:</p>
<ul class="calibre13">
<li class="calibre14"><strong class="calibre1">High degree of usability</strong>: By designing a low-level <kbd class="calibre11">CoreModule</kbd>, you and your team have the opportunity to design how you like to work with commonly used services, in a unique way, across not only the app you are building now but more in the future. You can easily move <kbd class="calibre11">CoreModule</kbd> into a completely different app and gain all the same unique <span>API</span>s you have designed for this app when working with low-level services.</li>
<li class="calibre14"><strong class="calibre1">Viewing your own app code as a 'Feature Module'</strong>: Doing so will help you focus on just the unique abilities your app should provide outside of what the <kbd class="calibre11">CoreModule</kbd> provides as well as reduce the duplication of the code.</li>
<li class="calibre14"><strong class="calibre1">Encourages and enhances rapid development</strong>: By confining commonly used functionality to our <kbd class="calibre11">CoreModule</kbd>, we relieve the burden of having to worry about those details in our feature modules. We can simply inject those services provided by our <kbd class="calibre11">CoreModule</kbd> and use those <span>API</span>s and never repeat ourselves.</li>
<li class="calibre14"><strong class="calibre1">Maintainability</strong>: In the future, if an underlying detail needs to change because of how your app needs to work with a low-level service, it need only be changed in one place (in the <kbd class="calibre11">CoreModule</kbd> service) versus having redundant code potentially spread across different sections of your app.</li>
<li class="calibre14"><strong class="calibre1">Performance</strong>: Splitting your app into modules will allow you to load only the modules you need at startup, then later, lazily load other features on demand. Ultimately, this leads to a faster app startup time.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Considerations?</h1>
                
            
            <article>
                
<p class="mce-root">You may be thinking, why not just combine the player/recorder modules together into one module?</p>
<p class="mce-root"><strong class="calibre1">Answer:</strong> Our app is only going to allow recording when a registered user is authenticated. Therefore, it is beneficial to consider the potential of authenticated contexts and what features are only accessible to authenticated users (if any). This will allow us to further fine tune the loading performance of our app to what is needed when it's needed only.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting started</h1>
                
            
            <article>
                
<p class="mce-root">We are going to assume that you have NativeScript installed properly on your computer. If you do not, please follow the install instructions at <a href="https://nativescript.org" target="_blank" class="calibre3">https://nativescript.org</a>. Once installed, we need to create our app framework using a shell prompt:</p>
<pre class="calibre22"><strong class="calibre1">tns create TNSStudio --ng</strong></pre>
<p class="mce-root">The <kbd class="calibre11">tns</kbd> stands for Telerik NativeScript<strong class="calibre1">.</strong> It is the primary <strong class="calibre1">command-line user interface</strong><span> (</span><strong class="calibre1">CLI</strong><span>)</span> tool you will use to create, build, deploy, and test any NativeScript app.</p>
<p class="mce-root">This command will create a new folder called <kbd class="calibre11">TNSStudio</kbd>. Inside is your primary project folder including everything required to build an app. It will contain everything relating to this project. After the project folder has been created, you need to do one more thing to have a fully runnable app. That's, adds the runtimes for Android and/or iOS:</p>
<pre class="calibre22"><strong class="calibre1">cd TNSStudio</strong><br class="title-page-name"/><strong class="calibre1">tns platform add ios</strong><br class="title-page-name"/><strong class="calibre1">tns platform add android</strong></pre>
<p class="mce-root">If you are on a Macintosh, you can build for both iOS and Android. If you are running on a Linux or Windows device, Android is the only platform you can compile for on your local machine.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Create our module shells</h1>
                
            
            <article>
                
<p class="mce-root">Without writing the implementation of our services yet, we can define what our <kbd class="calibre11">CoreModule</kbd> will generally look like with <kbd class="calibre11">NgModule</kbd> by starting to define what it should provide:</p>
<p class="mce-root">Let's create <kbd class="calibre11">app/modules/core/core.module.ts</kbd>:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { NgModule } from '@angular/core';<br class="title-page-name"/>@NgModule({})<br class="title-page-name"/>export class CoreModule { }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Injectable services</h1>
                
            
            <article>
                
<p class="mce-root">Now, let's create the boilerplate we need for our services. Note here that the injectable decorator is imported from Angular to declare that our service will be made available through Angular's <strong class="calibre1">Dependency Injection</strong> (<strong class="calibre1">DI</strong>) system, which allows these services to be injected into any class constructor that may need it. The DI system provides a nice way to guarantee that these services will be instantiated as singletons and shared across our app. It's also worth noting that we could alternatively provide these services on the component level if we didn't want them to be singletons and instead have unique instances created for certain branches of our component tree, which will make up our user interface. In this case, though, we want these created as singletons. We will be adding the following to our <kbd class="calibre11">CoreModule</kbd>:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre11">LogService</kbd>: Service to funnel all our console logging through.</li>
<li class="calibre14"><kbd class="calibre11">DatabaseService</kbd>: Service to handle any persistent data our app needs. For our app, we will implement the native mobile device<strong class="calibre1">'</strong>s storage options, such as application settings, as a simple key/value store. However, you could implement more advanced storage options here, such as remote storage through Firebase for example.</li>
</ul>
<p class="mce-root">Create <kbd class="calibre11">app/modules/core/services/log.service.ts</kbd>:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Injectable } from '@angular/core';<br class="title-page-name"/>@Injectable()<br class="title-page-name"/>export class LogService {<br class="title-page-name"/>}</pre>
<p class="mce-root">Also, create <kbd class="calibre11">app/modules/core/services/database.service.ts</kbd>:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Injectable } from '@angular/core';<br class="title-page-name"/>@Injectable()<br class="title-page-name"/>export class DatabaseService {<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Consistency and standards</h1>
                
            
            <article>
                
<p class="mce-root">For consistency and to reduce the length of our imports as well as prepare for better scalability, let's also create an <kbd class="calibre11">index.ts</kbd> file in <kbd class="calibre11">app/modules/core/services</kbd>, which will export a <kbd class="calibre11">const</kbd> collection of our services as well as export these services (in an alphabetical order to keep things tidy):</p>
<pre class="calibre22">import { DatabaseService } from './database.service';<br class="title-page-name"/>import { LogService } from './log.service';<br class="title-page-name"/><br class="title-page-name"/>export const PROVIDERS: any[] = [<br class="title-page-name"/>  DatabaseService,<br class="title-page-name"/>  LogService<br class="title-page-name"/>];<br class="title-page-name"/><br class="title-page-name"/>export * from './database.service';<br class="title-page-name"/>export * from './log.service';</pre>
<p class="mce-root">We will follow a similar pattern of the organization throughout the book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Finalizing CoreModule</h1>
                
            
            <article>
                
<p class="mce-root">We can now modify our <kbd class="calibre11">CoreModule</kbd> to use what we have created. We will take this opportunity to also import the <kbd class="calibre11">NativeScriptModule</kbd> which our app will need to work with other NativeScript for Angular features which we will want accessible globally for our app. Since we know we will want those features, globally, we can also specify that they are exported so when we import and use our <kbd class="calibre11">CoreModule</kbd>, we won't need to worry about importing <kbd class="calibre11">NativeScriptModule</kbd> elsewhere. Here's what our <kbd class="calibre11">CoreModule</kbd> modifications should look like:</p>
<pre class="calibre22">// nativescript<br class="title-page-name"/>import { NativeScriptModule } from 'nativescript-angular/nativescript.module';<br class="title-page-name"/>// angular<br class="title-page-name"/>import { NgModule } from '@angular/core';<br class="title-page-name"/>// app<br class="title-page-name"/>import { PROVIDERS } from './services';<br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  imports: [<br class="title-page-name"/>    NativeScriptModule<br class="title-page-name"/>  ],<br class="title-page-name"/>  providers: [<br class="title-page-name"/>    ...PROVIDERS<br class="title-page-name"/>  ],<br class="title-page-name"/>  exports: [<br class="title-page-name"/>    NativeScriptModule<br class="title-page-name"/>  ]<br class="title-page-name"/>})<br class="title-page-name"/>export class CoreModule { }</pre>
<p class="mce-root">We now have a good starting base for our <kbd class="calibre11">CoreModule</kbd>, the details of which we will implement in the following chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="mce-root">We created a solid foundation for our app in this chapter. You learned how to think about your app's architecture in terms of modules. You also learned how to utilize Angular's <kbd class="calibre11">@NgModule</kbd> decorator to frame out these modules. And finally, we now have a great base architecture to work from to build our app on top of.</p>
<p class="mce-root">Now that you have some of the key concepts under your belt, we can now move onto the heart of our app, the feature modules. Let's dive into the main features of our app to continue constructing our service layers in <a target="_blank" href="part0037.html#1394Q0-289fe2426d594f99a90e4363b2c9c34d" class="calibre3">Chapter 2</a>, <em class="calibre21">Feature Modules</em>. We will soon be creating some views for our app and running the app on iOS and Android in <a href="part0046.html#1BRPS0-289fe2426d594f99a90e4363b2c9c34d" class="calibre3">Chapter 3</a>, <em class="calibre21">Our First View via Component Building</em>.</p>


            </article>

            
        </section>
    </body></html>