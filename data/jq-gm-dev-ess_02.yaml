- en: Chapter 2. Creating Our First Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。创建我们的第一个游戏
- en: If you lay your eyes on an electronic device, chances are that there is a browser
    running on it! You probably have more than one installed on each of your PCs and
    some more running on your portable devices. If you want to distribute your games
    to a wide audience for a minimal cost of entry, making it run in the browser makes
    a lot of sense.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看着电子设备，很有可能上面运行着一个浏览器！你可能在每台PC上安装了一个以上的浏览器，并在你的便携设备上运行了更多。如果你想以最低的入门成本将你的游戏分发给广泛的受众，使其在浏览器中运行是非常有意义的。
- en: Flash was for a long time the go-to platform for games in browsers, but it has
    been losing speed in the last few years. There are many reasons for this and there
    have been countless arguments about whether this is a good thing or not. There
    is, however, a consensus on the fact that you can now make games run in the browser
    without plugins at a reasonable speed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Flash长时间以来一直是浏览器中游戏的首选平台，但在过去几年中它的速度逐渐减慢。有很多原因造成了这种情况，并且关于这是否是一件好事有无数的争论。然而，有一个共识是现在你可以在浏览器中以合理的速度运行游戏而无需插件。
- en: This book will focus on 2D games as they are the ones that run well on current
    browsers and the features they depend on are standardized. This means that an
    update of the browser shouldn't break your games and that for the most part you
    don't have to worry too much about difference between browsers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将重点关注2D游戏，因为它们在当前浏览器上运行良好，并且它们依赖的功能已经标准化。这意味着浏览器的更新不应该破坏你的游戏，而且在大多数情况下，你不必过多担心不同浏览器之间的差异。
- en: You will, however, in the near future be able to develop modern 3D games, like
    you would on a game console and have them run on browsers. If that's what you
    thrive on, this book will provide you with fluency in the basic knowledge that
    you will need to make those games.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你很快将能够开发现代3D游戏，就像在游戏机上一样，并让它们在浏览器上运行。如果这是你擅长的领域，这本书将为你提供制作这些游戏所需的基本知识。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating animated sprites
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动画精灵
- en: Moving sprite around
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动精灵
- en: Preloading assets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预加载资源
- en: Main game loop implementation using a finite state machine
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用有限状态机实现主游戏循环
- en: Basic collision detection
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本碰撞检测
- en: How does this book work?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这本书是如何工作的？
- en: Making games has this amazing advantage that you immediately see the result
    of the code you just wrote move before your eyes. This is the reason why everything
    you learn in this book will directly be applied to some practical examples. In
    this chapter, we will write a small game together inspired by the classic *Frogger*.
    In the following chapters, we will then make a platformer and a role playing game
    (RPG).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 制作游戏有这个惊人的优势，你可以立即看到你刚写的代码的结果在你眼前移动。这就是为什么这本书中学到的一切都将直接应用于一些实际例子的原因。在本章中，我们将一起编写一个受经典游戏*青蛙过河*启发的小游戏。在接下来的章节中，我们将制作一个平台游戏和一个角色扮演游戏（RPG）。
- en: I really encourage you to write your own version of the games presented here
    and modify the code provided to see the effects it has. There is no better way
    of learning than to get your hands dirty!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的鼓励你写下你自己版本的这里所介绍的游戏，并修改提供的代码以查看其效果。没有比动手做更好的学习方式了！
- en: Let's get serious – the game
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们认真对待 - 游戏
- en: The game we will implement now is inspired by *Frogger*. In this old school
    arcade game, you played the role of a frog trying to cross the screen by jumping
    on logs and avoiding cars.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将要实现的游戏灵感来自*青蛙过河*。在这个老派街机游戏中，你扮演一个青蛙，试图通过跳上原木并避开汽车来穿过屏幕。
- en: '![Let''s get serious – the game](img/5060OT_02_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![让我们认真对待 - 游戏](img/5060OT_02_01.jpg)'
- en: 'In our version, the player is a developer who has to cross the network cable
    by jumping packets and then cross the browser "road" by avoiding bugs. To sum
    up, the game specifications are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的版本中，玩家是一个开发人员，他必须通过跳跃数据包来穿越网络电缆，然后通过避开错误来穿越浏览器的"道路"。总而言之，游戏规格如下：
- en: If the player presses the up arrow key once, the "frog" will go forward one
    step.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家按一次向上箭头键，"青蛙"将前进一步。
- en: By pressing the right and left arrow key, the player can move horizontally.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过按右箭头和左箭头键，玩家可以水平移动。
- en: In the first part (the network cable) the player has to jump on packets coming
    from the left of the screen and moving to the right. The packets are organized
    in lines where packets of each line travel at different speeds. Once the player
    is on a packet, he/she will move along with it. If a packet drives the player
    outside of the screen, or if the player jumps on the cable without reaching a
    packet, he/she will die and start at the beginning of the same level once again.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一部分（网络电缆）中，玩家必须跳跃到从屏幕左边出现并向右移动的数据包上。数据包按行组织，每行的数据包以不同的速度行进。一旦玩家站在数据包上，他/她将随之移动。如果数据包把玩家带到屏幕外，或者玩家跳到电缆上未到达数据包，他/她将会死亡，然后重新开始同一级别。
- en: In the second part (the browser part) the player has to cross the browser screen
    by avoiding the bugs coming from the left. If the player gets hit by a bug he/she
    will start at the beginning of the same level once again.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二部分（浏览器部分）中，玩家必须躲避从左边出现的错误以穿过浏览器屏幕。如果玩家被错误击中，他/她将会重新开始同一级别。
- en: These are very simple rules, but as you will see they will already give us plenty
    of things to think about.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则非常简单，但正如您将看到的，它们已经给我们提供了很多值得思考的地方。
- en: Learning the basics
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习基础
- en: Throughout this book, we will use DOM elements to render game elements. Another
    popular solution would be to use the Canvas element. There are plus and minus
    points for both technologies and there are a few effects that are simply not possible
    to produce with only DOM elements.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用DOM元素来渲染游戏元素。另一个流行的解决方案是使用Canvas元素。这两种技术都有各自的优点和缺点，也有一些效果仅通过DOM元素是无法实现的。
- en: However, for the beginner, the DOM offers the advantage of being easier to debug,
    to work on almost all existing browsers (yes, even on Internet Explorer 6), and
    in most cases to offer reasonable speed for games. The DOM also abstracts the
    dirty business of having to target individual pixels and tracking which part of
    the screen has to be redrawn.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于初学者来说，DOM提供了易于调试的优势，几乎在所有现有的浏览器上运行（是的，即使在Internet Explorer 6上也是如此），而且在大多数情况下可以提供合理的游戏速度。DOM还抽象了繁琐的工作，无需单独针对像素进行操作以及跟踪屏幕的哪一部分需要重新绘制。
- en: Even though Internet Explorer supports most of the features we will see in this
    book, I would not recommend creating a game that supports it. Indeed, its market
    share is negligible nowadays ([http://www.ie6countdown.com/](http://www.ie6countdown.com/))
    and you will encounter some performance issues.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 即使Internet Explorer支持本书中所介绍的大部分功能，我也不建议创建支持IE的游戏。事实上，如今它的市场份额微不足道（[http://www.ie6countdown.com/](http://www.ie6countdown.com/)），而且您可能会遇到一些性能问题。
- en: Now from some game terminology, sprites are the moving part of a game. They
    may be animated or nonanimated (in the sense of changing their aspect versus simply
    moving around). Other parts of the game may include the background, the UI, and
    tiles (we will look more into this in [Chapter 4](ch04.html "Chapter 4. Looking
    Sideways"), *Looking Sideways*).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在介绍一些游戏术语，精灵是游戏的移动部分。它们可以是动画的或非动画的（在改变外观与简单移动之间）。其他游戏的部分可能包括背景、用户界面和图块（我们将在[第4章](ch04.html
    "Chapter 4. Looking Sideways")中深入讨论，*向旁边看*）。
- en: Framework
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架
- en: During this book, we will write some code; part of the code belongs to an example
    game and is used to describe scenes or logic that are specific to it. Some code,
    however, is very likely to be reused in each of your games. For this reason, we
    will regroup some of those functions into a framework that we will cleverly call
    `gameFramework` or `gf` in short.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将编写一些代码；部分代码属于一个示例游戏，并用于描述特定于该游戏的场景或逻辑。但是，某些代码很可能会在您的每个游戏中被重用。因此，我们将把一些这样的功能集中到一个被巧妙地称为`gameFramework`或简称`gf`的框架中。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)账户下载您购买过的Packt书籍的示例代码文件。如果您在其他地方购买了本书，可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，文件将直接通过电子邮件发送给您。
- en: A very simple way to define a namespace in JavaScript is to create an object
    and add all your function directly to it. The following code gives you an example
    of what this might look like for two functions, `shake` and `stir`, in the namespace
    `cocktail`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中定义命名空间的一个非常简单的方法是创建一个对象，并直接将所有函数添加到其中。以下代码为名称空间`cocktail`中的两个函数`shake`和`stir`提供了示例。
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This has the advantage of avoiding collision with other libraries that use similar
    names for their objects or functions. Therefore, from now on when you see any
    function added to the namespace, it will mean that we think those functions will
    be used by the other games we will create later in this book or that you might
    want to create yourself.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的优点是避免与其他使用类似名称的库的对象或函数发生冲突。因此，从现在开始，当您看到任何添加到命名空间的函数时，意味着我们认为这些函数将被其他我们稍后在本书中创建的游戏所使用，或者您可能想要自己创建的游戏使用。
- en: The following code is another notation for namespace. Which one you use is a
    personal preference and you should really use the one that feels right to you!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是另一种命名空间的表示法。您可以使用其中之一是个人偏好，您真的应该使用感觉正确的那个！
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Typically, you would keep the code of the framework in a JS file (let's say
    `gameFramework.js`) and the code of the game in another JS file. Once your game
    is ready to be published, you may want to regroup all your JavaScript code into
    one file (including jQuery if you wish so) and minimize it. However, for the whole
    development phase it will be way more convenient to keep them separate.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会将框架的代码保存在一个 JS 文件中（假设为`gameFramework.js`），并将游戏的代码保存在另一个 JS 文件中。一旦您的游戏准备发布，您可能希望将所有
    JavaScript 代码重新组合到一个文件中（包括 jQuery 如果您愿意的话）并将其最小化。但是，在整个开发阶段，将它们分开将更加方便。
- en: Sprites
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 精灵
- en: Sprites are the basic building blocks of your game. They are basically images
    that can be animated and moved around the screen. To create them you can use any
    image editor. If you work on OS X, there is a free one that I find has been particularly
    well done, Pixen ([http://pixenapp.com/](http://pixenapp.com/)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵是您的游戏的基本构建块。它们基本上是可以在屏幕上移动和动画的图像。要创建它们，您可以使用任何图像编辑器。如果您使用的是 OS X，有一个我觉得特别好的免费软件，叫做
    Pixen ([http://pixenapp.com/](http://pixenapp.com/))。
- en: 'There are many ways to draw sprites using the DOM. The most obvious one is
    to use the `img` element. This causes several inconveniences. First, if you want
    to animate the image you have two options, neither of which are exempt of drawbacks:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多使用 DOM 绘制精灵的方法。最明显的方法是使用`img`元素。这会带来几个不便。首先，如果要对图像进行动画处理，您有两个选项，但两者都不是没有缺点：
- en: You can use animated gifs. With this method you have no way to access the index
    of the current frame through JavaScript, and no control over when the animation
    starts to play or when it ends. Furthermore, having many animated GIFs tends to
    slow things down a lot.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用动画 GIF。通过这种方法，您无法通过 JavaScript 访问当前帧的索引，并且无法控制动画何时开始播放或何时结束。此外，拥有许多动画 GIF
    会导致速度大大减慢。
- en: You can change the source of the image. This is already a better solution, but
    provides worse performance if proposed and requires a large number of individual
    images.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以更改图像的来源。这已经是一个更好的解决方案，但是提出的性能较差，而且需要大量单独的图像。
- en: Another disadvantage is that you cannot choose to display only one part of the
    image; you have to show the entire image each time. Finally, if you want to have
    a sprite made of a repeating image, you will have to use many `img` elements.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是您无法选择仅显示图像的一部分；您必须每次都显示整个图像。最后，如果您想要一个由重复图像组成的精灵，您将不得不使用许多`img`元素。
- en: For the sake of completeness, we should mention here one advantage of `img`;
    it's really easy to scale an `img` element—just adjust the width and height.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，我们应该在这里提到`img`的一个优点；缩放`img`元素非常容易——只需调整宽度和高度。
- en: 'The proposed solution uses simple divs of defined dimensions and sets an image
    in the background. To generate animated sprites, you could change the background
    image, but instead we use the background position CSS property. The image used
    in this situation is called a sprite sheet and typically looks something like
    the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 提出的解决方案使用了定义尺寸的简单 div，并在背景中设置了图像。要生成动画精灵，您可以更改背景图像，但我们使用的是背景位置 CSS 属性。在此情况下使用的图像称为精灵表，通常看起来像以下的屏幕截图：
- en: '![Sprites](img/5060OT_02_02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![精灵](img/5060OT_02_02.jpg)'
- en: 'The mechanism by which the animation is generated is shown in the following
    screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 生成动画的机制如下屏幕截图所示：
- en: '![Sprites](img/5060OT_02_06.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Sprites](img/5060OT_02_06.jpg)'
- en: Another advantage is that you can use a single sprite sheet to hold multiple
    animations. This way you will avoid having to load many different images. Depending
    on the situation, you may still want to use more than one sprite sheet, but it's
    a good thing to try to minimize their number.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是你可以使用单个雪碧图来容纳多个动画。这样你就可以避免加载许多不同的图像。根据情况，您可能仍然希望使用多个雪碧图，但尽量减少它们的数量是件好事。
- en: Implementing animations
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现动画
- en: It's very simple to implement this solution. We will use `.css()` to change
    the background properties and a simple `setInterval` to change the current frame
    of the animation. Therefore, let's say that we have a sprite sheet containing
    4 frames of a walk cycle where each frame measures 64 by 64 pixels.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个解决方案非常简单。我们将使用`.css()`来改变背景属性，并使用简单的`setInterval`来改变动画的当前帧。因此，假设我们有一个包含4帧行走循环的雪碧图，其中每帧测量`64
    by 64`像素。
- en: First, we simply have to create a `div` with the sprite sheet as its background.
    This `div` should measure 64 by 64 pixels, otherwise the next frame would leak
    onto the current one. In the following example, we add the sprite to a `div` with
    the ID `mygame`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们只需创建一个带有雪碧图作为其背景的`div`。这个`div`应该测量`64 by 64`像素，否则下一帧会泄漏到当前帧。在下面的示例中，我们将雪碧图添加到ID为`mygame`的`div`中。
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As the background image is by default aligned with the upper-left corner of
    the `div`, we will only see the first frame of the walk-cycle sprite sheet. What
    we want is to be able to change what frame is visible. The following function
    changes the background position to the correct position based on the argument
    passed to it. Take a look at the following code for the exact meaning of the arguments:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于背景图像默认与`div`的左上角对齐，所以我们只会看到行走循环雪碧图的第一帧。我们想要的是能够改变哪个帧是可见的。以下函数根据传递给它的参数将背景位置更改为正确的位置。请查看以下代码以了解参数的确切含义：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now we have to call this at regular intervals to produce the animation. We will
    use `setInterval` with an interval of 60 milliseconds, that is, around 17 frames
    per second. This should be enough to give the impression of walking; however,
    this really has to be fine-tuned to match your sprite sheet. To do this we use
    an anonymous function that we pass to `setInterval`, which will in turn call our
    function with the correct parameter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须定期调用这个函数来生成动画。我们将使用间隔为60毫秒的`setInterval`，即每秒约17帧。这应该足以给人一种行走的印象；然而，这确实必须进行微调，以匹配您的雪碧图。为此，我们使用一个匿名函数传递给`setInterval`，该函数将进一步使用正确的参数调用我们的函数。
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You probably noticed that we're doing something special to compute the current
    frame. The goal is to cover values from 0 to 3 (as they're 4 frames) and to loop
    back to 0 when we reach 4\. The operation we use for this is called modulo (`%`)
    and it's the rest of the integer division (also known as Euclidean division).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到我们正在做一些特殊的事情来计算当前帧。目标是覆盖从0到3的值（因为有4帧），并在达到4时循环回到0。我们用于此的操作称为模数（`%`），它是整数除法的余数（也称为欧几里德除法）。
- en: For example, at the third frame we have 3 / 4 which is equal to 0 plus a remainder
    of 3, so 3 % 4 = 3\. When the frame number reaches 4 we have 4 / 4 = 1 plus a
    remainder of 0, so 4 % 4 = 0\. This mechanism is used in a lot of situations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在第三帧我们有`3 / 4`等于0加上余数3，所以`3 % 4 = 3`。当帧数达到4时，我们有`4 / 4 = 1`加上余数0，所以`4 % 4
    = 0`。这个机制在很多情况下都被使用。
- en: Adding animations to our framework
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将动画添加到我们的框架
- en: 'As you can see there are more and more variables needed to generate an animation:
    the URL of the image, the number of frames, their dimension, the rate of the animation,
    and the current frame. Furthermore, all those variables are associated with one
    animation, so if we need a second one we have to define twice as many variables.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，生成动画需要越来越多的变量：图像的URL、帧数、它们的尺寸、动画的速率和当前帧。此外，所有这些变量都与一个动画相关联，因此如果我们需要第二个动画，我们必须定义两倍数量的变量。
- en: The obvious solution is to use objects. We will create an animation object that
    will hold all the variables we need (for now, it won't need any method). This
    object, like all the things belonging to our framework, will be in the `gameFramework`
    namespace. Instead of giving all the values of each of the properties of the animation
    as an argument, we will use a single object literal, and all the properties that
    aren't defined will default to some well-thought-out values.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的解决方案是使用对象。我们将创建一个动画对象，它将保存我们需要的所有变量（现在，它不需要任何方法）。这个对象，像我们框架中所有的东西一样，将位于`gameFramework`命名空间中。与其将动画的每个属性的所有值作为参数给出，不如使用单个对象文字，并且所有未定义的属性将默认为一些经过深思熟虑的值。
- en: 'To do this, jQuery offers a very convenient method: `$.extend`. This is a very
    powerful method and you should really take a look at the API documentation ([http://api.jquery.com/](http://api.jquery.com/))
    to see everything that it can do. Here we will pass to it three arguments: the
    first one will be extended with the values of the second one and the resulting
    object will be extended with the values of the third.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，jQuery 提供了一个非常方便的方法：`$.extend`。这是一个非常强大的方法，你应该真正看一下 API 文档（[http://api.jquery.com/](http://api.jquery.com/)）来看看它能做什么。这里我们将向它传递三个参数：第一个将被第二个的值扩展，结果对象将被第三个的值扩展。
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To use this function we will simply create a new instance of it with the desired
    values. Here you can see the values used in the preceding examples:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此功能，我们只需使用所需值创建一个新实例即可。这里你可以看到在前面的示例中使用的值：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we didn't need to specify `width:` `64` because it's the default
    value! This pattern is very convenient and you should keep it in mind each time
    you need default values and also the flexibility to override them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们不需要指定`width:` `64`，因为这是默认值！这种模式非常方便，每次需要默认值和灵活性来覆盖它们时都应该记住它。
- en: 'We can rewrite the function to use the animation object:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重写函数以使用动画对象：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now we will create a function for our framework based on the technique we've
    already seen, but this time it will use the new animation object. This function
    will start animating a sprite, either once or in a loop. There is one thing we
    have to be careful about—if we define an animation for a sprite that is already
    animated we need to deactivate the current animation and replace it with the new
    one.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将根据我们已经看到的技术为我们的框架创建一个函数，但这次它将使用新的动画对象。这个函数将开始对精灵进行动画处理，可以是一次或循环播放。有一件事我们必须注意——如果我们为已经在动画中的精灵定义动画，我们需要停用当前动画，并用新动画替换它。
- en: To do this we will need an array to hold the list of all intervals' handles.
    Then we'll only need to check if one exists for this sprite and clear it, then
    define it again.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将需要一个数组来保存所有间隔句柄的列表。然后我们只需要检查这个精灵是否存在一个间隔句柄，并清除它，然后再次定义它。
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will provide a convenient, flexible, and quite high-level way to set an
    animation for a sprite.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提供一个方便、灵活且相当高级的方法来为精灵设置动画。
- en: Moving sprites around
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在画布上移动精灵
- en: 'Now that we know how to animate a sprite, we need to move it around to make
    it interesting. A few things are necessary for this; first, the div that we use
    has to be positioned absolutely. This is very important for two reasons:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何对精灵进行动画处理了，我们需要将其移动到使其有趣的位置。这需要一些必要条件；首先，我们使用的 div 必须绝对定位。这对于两个原因非常重要：
- en: It's a nightmare for the developer to manipulate other positioning as soon as
    the scene becomes complicated.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对开发人员来说，一旦场景变得复杂起来，操作其他定位就成了噩梦。
- en: It's by far the least expansive way for the browser to compute the position
    of an element.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是浏览器计算元素位置最不昂贵的方式。
- en: What we want then is the sprite to be positioned relative to the div that holds
    the game. This means that it too has to be positioned, absolutely, relatively,
    or fixed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们想要的是精灵相对于包含游戏的 div 定位。这意味着它也必须被定位，绝对，相对或固定。
- en: 'Once those two conditions are met, we can simply use the `top` and `left` CSS
    properties to choose where the sprite appears on the screen, as shown in the following
    screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦满足这两个条件，我们就可以简单地使用`top`和`left`CSS 属性来选择精灵在屏幕上出现的位置，如下图所示：
- en: '![Moving sprites around](img/5060OT_02_07.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![在画布上移动精灵](img/5060OT_02_07.jpg)'
- en: 'The following code sets the correct parameters for the container div and adds
    a sprite:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码设置了容器 div 的正确参数并添加了一个精灵：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we will use this piece of code a lot, we will factor it into a function of
    our framework event if it's trivial. As we did for the animation constructor,
    we will use an object literal to define the optional arguments.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将经常使用这段代码，因此即使它很简单，我们也会将其合并到我们的框架函数中。与我们对动画构造函数所做的一样，我们将使用对象字面量来定义可选参数。
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will then write a function that moves a sprite along the x axis and another
    one along the y axis. One typical convention in graphic programming is to have
    the x axis going from left to right and the y axis going from top to bottom. Those
    functions will take the ID of the element to move and the position to move it
    to. To mimic the way some jQuery functions work, our functions will return the
    current position of the sprite if you don't provide a second argument.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将编写一个函数，使一个精灵沿着 x 轴移动，另一个精灵沿着 y 轴移动。图形编程中的一个典型约定是将 x 轴从左到右，y 轴从上到下。这些函数将接受要移动的元素的
    ID 和要移动到的位置作为参数。为了模仿一些 jQuery 函数的工作方式，如果你不提供第二个参数，我们的函数将返回精灵的当前位置。
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With those three simple functions, you have all the basic tools that you need
    to generate the graphics of your game.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这三个简单的函数，你就拥有了生成游戏图形所需的所有基本工具。
- en: Preloading
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预加载
- en: There is, however, one last thing that is required in most cases; asset loading.
    To avoid starting the game before some of the images are loaded you need to load
    them before. Most users expect the game to start loading only when they decide
    to start it. Furthermore, they want some feedback about the progress of the loading
    process.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在大多数情况下还需要最后一件事情；资源加载。为了避免在一些图片加载完成之前启动游戏，你需要在游戏开始之前加载它们。大多数用户希望游戏只在他们决定启动它时开始加载。此外，他们想要一些关于加载过程进度的反馈。
- en: In JavaScript, you have the possibility to define, for each image, a function
    that will be called once the image has finished loading. This, however, has a
    limitation that it won't provide you with information about the other images.
    And you can't simply define a callback for the last image that you start to run
    as you have no guarantee about the order in which your images will load, and in
    most cases images don't load one after the other, but rather a bunch at a time.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，你有可能为每张图片定义一个在图片加载完成后将被调用的函数。然而，这有一个限制，它不会提供关于其他图片的信息。而且你不能简单地为最后一张开始运行的图片定义一个回调，因为你无法保证图片加载的顺序，而且在大多数情况下，图片不是依次加载的，而是一次性加载一堆。
- en: There are many possible solutions, most of them equally good. As this code is
    run in most cases only once and before the game starts, performance is not of
    great concern here. What you really want is a robust, flexible system to know
    when all the images are loaded and the possibility to track the overall progress.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可能的解决方案，大多数都同样出色。由于这段代码大多数情况下只运行一次，而且在游戏开始之前，性能在这里并不是特别重要。真正想要的是一个稳健、灵活的系统，能够知道所有图片都加载完毕的情况，并且能够追踪总体进度。
- en: 'Our solution will use two functions: one to add images to a list of image to
    preload and the other one to start the preloading.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解决方案将使用两个函数：一个用于将图片添加到预加载列表中，另一个用于开始预加载。
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This first function doesn't do a lot. It simply takes an URL, checks if it's
    already present in the array where we store the images to preload, and if the
    new image is not in the array, add it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个函数并不做太多事情。它只是获取一个 URL，检查它是否已经存在于我们存储预加载图片的数组中，如果新图片不在数组中，则将其添加进去。
- en: The next function takes two callbacks. The first one is called once all the
    images are loaded and the second one (if defined) is called with the current progress
    as a percentage.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数接受两个回调函数。第一个回调函数在所有图片加载完成时调用，第二个回调函数（如果定义了）以百分比的形式调用当前进度。
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this function, we start by defining a new `Image` object for every URL that
    was added to the list. They will automatically start loading. Then we define a
    function that we will call at regular intervals. It will use the `complete` properties
    of images to check if each image is loaded. If the number of loaded images equals
    the total number of images, it means that we are done preloading.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们首先为添加到列表中的每个 URL 定义一个新的 `Image` 对象。它们将自动开始加载。然后我们定义一个将定期调用的函数。它将使用图片的
    `complete` 属性来检查每个图片是否已加载。如果加载完毕的图片数量等于总图片数量，这意味着我们已经完成了预加载。
- en: 'What could be useful is to automatically add the images used for animations
    to the preload list. To do this, we just need to add three lines at the end of
    the animation object in the following way:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的是自动将用于动画的图像添加到预加载列表中。为此，只需在动画对象的末尾添加三行代码，如下所示：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Initializing the game
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化游戏
- en: The framework part of the game is done. Now we want to implement the graphics
    and game logic. We can divide the game's code into two parts, one that will be
    executed only once at the beginning, and one that will be called periodically.
    We will call the first one the initialization.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的框架部分已经完成。现在我们想要实现图形和游戏逻辑。我们可以将游戏的代码分为两部分，一部分仅在开头执行一次，另一部分会定期调用。我们将第一个称为初始化。
- en: This part should be executed as soon as the images are done loading; this is
    the reason why we will pass it as the end callback for the `startPreloading` function.
    This means that at the very beginning we need to add all the images that we will
    use to the preload list. Then once the user launches the game (for example, by
    clicking an image with the ID `startButton`) we will call the preloader.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 只要图像加载完成，就应立即执行这部分；这就是为什么我们将它作为`startPreloading`函数的结束回调。这意味着在一开始时，我们需要将所有要使用的图像添加到预加载列表中。然后，一旦用户启动游戏（例如通过点击ID为`startButton`的图像），我们将调用预加载程序。
- en: The following code uses the standard jQuery way to execute a function once the
    page is ready. I won't give you the complete code here because some of it is quite
    repetitive, but I will give at least one example of each of the actions performed
    here and you can always look at the complete source code if you're curious.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用标准的jQuery方式在页面准备就绪后执行函数。我不会在这里提供完整的代码，因为一些代码相当重复，但我会至少给出每个这里执行的动作的一个示例，如果你感兴趣，你可以随时查看完整的源代码。
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is a list of what we need to do in the initialize function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在初始化函数中需要做的事情列表：
- en: Create the sprites that compose the game scene
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建组成游戏场景的精灵
- en: Create the GUI elements
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建GUI元素
- en: 'The following diagram shows how we will build our game scene:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了我们将如何构建游戏场景：
- en: '![Initializing the game](img/5060OT_02_03.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![初始化游戏](img/5060OT_02_03.jpg)'
- en: 'No more than eight sprites: one for the background, one for the player, three
    for the network packets, and three for the bugs. To make things simpler we will
    use only one sprite for each band of packets/bugs. The three bands of packets
    will have the same animation and the same for the three bands of bugs.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不超过八个精灵：一个用于背景，一个用于玩家，三个用于网络数据包，和三个用于虫子。为了简化事情，我们只使用每个数据包/虫子组的一个精灵。这三组数据包将有相同的动画，三组虫子也一样。
- en: To avoid making the elements pop up as they are added, we will first add them
    to an invisible element and make this element visible only once all the sprites
    are created.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免添加元素时它们突然出现，我们将它们首先添加到一个不可见的元素中，直到所有精灵都创建完毕后才使此元素可见。
- en: The only GUI element will be a small `div` containing the number of lives the
    player has.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的GUI元素将是包含玩家生命数的小`div`。
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The last line of this function is starting the main loop. The main loop is the
    code that will be executed periodically. It contains most (if not all) of the
    game logic that doesn't immediately depend on an input from the player.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的最后一行是启动主循环。主循环是会定期执行的代码。它包含大部分（如果不是全部）与玩家输入没有直接关联的游戏逻辑。
- en: Main loop
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主循环
- en: 'The main loop will typically contain a **finite** **state** **machine** **(FSM)**.
    An FSM is defined by a series of states and the list of transitions from one state
    to another. The FSM for a simple game where the player would have to click three
    boxes that appear one after the other would look like the following diagram:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环通常包含一个**有限状态机（FSM）**。FSM由一系列状态和从一个状态到另一个状态的转换列表定义。简单游戏的FSM，玩家需要依次点击三个出现的方框，看起来会像以下的图表：
- en: '![Main loop](img/5060OT_02_04.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![主循环](img/5060OT_02_04.jpg)'
- en: 'When you implement an FSM, you really need to consider two things: how the
    game should behave in each state, and what conditions make the game transition
    to a new state. The advantage of FSMs is that they provide a formal way to organize
    your game logic. It will make it easier to read your code and you can add/or change
    your logic at a later time if you need it. I would recommend you to first draw
    the FSM for your game and keep it somewhere to help you debug your game.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实现FSM时，你需要考虑两件事：游戏在每个状态下应该如何行为，以及什么条件使游戏转移到新状态。FSM的优势在于它们提供了一种正式的方法来组织游戏逻辑。这将使您更容易阅读您的代码，并且如果需要的话，您可以随时添加/更改您的逻辑。我建议你先为你的游戏绘制FSM，并将其放在某个地方，以帮助你调试你的游戏。
- en: 'For our *Frogger* game there are 10 states. The initial state is `START` and
    the two final states are `GAMEOVER` and `WON`. Here is a description of what happens
    exactly in each state:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的*Frogger*游戏，有10个状态。初始状态是`START`，两个最终状态分别是`GAMEOVER`和`WON`。以下是每个状态中确切发生的描述：
- en: 'All states: The packets and bugs move to the right'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有状态：数据包和虫子向右移动
- en: '`STARTPOS`: Nothing special happens'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STARTPOS`：没有特殊情况发生'
- en: '`LINE1`: The player moves at the same speed as the packets of the first line;
    if the player goes out of the screen it dies and goes back to `START`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINE1`：玩家以第一行数据包的速度移动；如果玩家走出屏幕，就会死亡并回到`START`'
- en: '`LINE2`: The player moves at the same speed as the packets of the second line,
    if the player goes out of the screen it dies and goes back to `START`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINE2`：玩家以第二行数据包的速度移动，如果玩家走出屏幕，就会死亡并回到`START`'
- en: '`LINE3`: The player moves at the same speed as the packets of the third line,
    if the player goes out of the screen it dies and goes back to `START`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINE3`：玩家以第三行数据包的速度移动，如果玩家走出屏幕，就会死亡并回到`START`'
- en: '`REST`: Nothing special happens'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REST`：没有特殊情况发生'
- en: '`LINE4`: If the player gets hit by a bug from the line, it dies and goes back
    to `REST`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINE4`：如果玩家被第四行的虫子击中，就会死亡并回到`REST`'
- en: '`LINE5`: If the player gets hit by a bug from the line, it dies and goes back
    to `REST`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINE5`：如果玩家被第一行的虫子击中，就会死亡并回到`REST`'
- en: '`LINE6`: If the player gets hit by a bug from the line, it dies and goes back
    to `REST`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINE6`：如果玩家被第六行的虫子击中，就会死亡并回到`REST`'
- en: '`WON` and `GAMEOVER`: Nothing special happens'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WON`和`GAMEOVER`：没有特殊情况发生'
- en: 'On all states except `WON` and `GAMEOVER` the player can move around. This
    will trigger the following transitions:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`WON`和`GAMEOVER`状态外，玩家可以四处移动。这将触发以下转换：
- en: 'Successful jump: Go to the next state'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功跳跃：转到下一个状态
- en: 'Successful left/right slide: Stay in the same state'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功向左/向右滑动：保持在相同状态
- en: 'Failed jump of left/right slide: If the number of remaining lives is greater
    than zero, go back to the last "safe" state (`START` or `REST`), otherwise transition
    to `GAMEOVER`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向左/向右滑动失败的跳转：如果剩余生命大于零，回到上次的“安全”状态（`START`或`REST`），否则转移到`GAMEOVER`
- en: Main loop implementation
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主循环实现
- en: The most readable way to write an FSM is to use switch statements. We will use
    two, one in the main loop to update the game, and the other in the part that handles
    keyboard input.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 编写FSM最易读的方法是使用switch语句。我们将使用两个，一个在主循环中更新游戏，另一个用于处理键盘输入。
- en: The following code is an extract of the main loop. We first initiate a few variables
    that we will need to define the behavior of the game, and then code the FSM described
    in the preceding section. To move the packets and bugs we will use a trick and
    simply change the `background-position`. This is a less flexible solution than
    the function that we wrote earlier, but in this situation it is faster and makes
    it easy to give the impression of an infinite number of elements with a single
    sprite.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是主循环的一部分。我们首先初始化一些变量，这些变量将用于定义游戏的行为，然后编写前面部分描述的FSM。为了移动数据包和虫子，我们将使用一个技巧，简单地改变`background-position`。这比我们之前编写的函数少了灵活性，但在这种情况下更快，并且很容易让人以一个精灵给出无限数量的元素的假象。
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: At this point, the game displays all the moving parts. There still isn't any
    way for the player to control its avatar. To do this we will use the `keydown`
    event handler. We will implement two different solutions to move the sprite around.
    For the horizontal movement, we will use the `gf.x` function that we wrote earlier.
    This makes sense because it's a very small movement, but for the vertical jump
    we will use `$.animate` to make the avatar move to its destination in many steps
    and create a more fluid movement.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，游戏显示了所有移动的部分。 仍然没有办法让玩家控制其化身。 为了做到这一点，我们将使用 `keydown` 事件处理程序。 我们将实现两种不同的方案来移动角色。
    对于水平移动，我们将使用之前编写的 `gf.x` 函数。 这是有道理的，因为这是一个非常小的移动，但对于垂直跳跃，我们将使用 `$.animate` 以使化身在许多步骤中移动到目的地，并创建更流畅的移动。
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here we start to check the state of the game to be sure that the player is allowed
    to move. Then we check which key was pressed. The left and right parts are self-explanatory,
    but the jump part is subtler.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们开始检查游戏的状态，以确保玩家被允许移动。 然后我们检查按下了哪个键。 左右部分都很简单明了，但跳跃部分要微妙些。
- en: We need to check the state of the game to find out where the player should jump.
    Then we use a callback that we pass to the `animate` function in order to update
    the state of the game only once the animation is done.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要检查游戏的状态来找出玩家应该跳到哪里。 然后，我们使用传递给 `animate` 函数的回调来更新游戏的状态，这样只有在动画完成后才会更新游戏的状态。
- en: 'That''s it, you can now control the player. If you jump on a packet the player
    will move with it, and when you reach the end you will win the game. However,
    you may have noticed we forgot something important: there is no way for the player
    to die! To add this feature we will need to detect whether the player is at a
    place that is safe or not.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，你现在可以控制玩家了。如果你跳上了一个数据包，玩家将会随着它移动，当你到达终点时，你就赢得了游戏。 不过，你可能已经注意到我们忘记了一些重要的东西：没有办法让玩家死亡！
    要添加这个功能，我们需要检测玩家是否处于安全位置。
- en: Collision detection
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: We will use some sort of collision detection, but a very simple version that
    is designed only for this situation. In the later chapters, we will see more general
    solutions, but this isn't necessary here.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用某种碰撞检测，但这只是针对这种情况设计的非常简单的版本。 在后面的章节中，我们将会看到更一般的解决方案，但在这里不是必要的。
- en: There are six spots where collision detection matters in this game; the three
    lines of packets in the first part, and the three lines of bugs in the second
    part. Both represent the exact same situation. There is a succession of elements
    separated by some empty space. The distance between each element is constant along
    with its size. We don't need to know on which packet the player has jumped or
    which bugs hit the player, what matters is only if the player stands on a packet
    or if he/she was hit by a bug.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，碰撞检测有六个重要的地方；第一部分中的三行数据包和第二部分中的三行臭虫。 两者代表完全相同的情况。 一系列的元素被一些空间分隔开。 每个元素之间的距离是恒定的，大小也是恒定的。
    我们不需要知道玩家跳到了哪个数据包上，或者哪些臭虫打中了玩家，重要的是玩家是否站在了一个数据包上，或者是否被臭虫击中了。
- en: 'For this reason we will use the **modulo technique** we used before to reduce
    the problem complexity. What we will consider is the following situation:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们将使用我们之前使用过的**取模技巧**来降低问题的复杂性。 我们要考虑的是以下的情况：
- en: '![Collision detection](img/5060OT_02_05.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞检测](img/5060OT_02_05.jpg)'
- en: To know if the player touches the element or not we just need to compare its
    x co-ordinate with the element position.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道玩家是否触碰了元素，我们只需比较其 x 坐标与元素位置即可。
- en: The following code does just that. First, it checks the game state to know what
    collision to detect (if any), then uses modulo to bring the player back to the
    simplified situation we want to consider. And finally, it checks the coordinates
    of the player.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码就做到了这一点。 首先，它检查游戏状态以了解要检测的碰撞（如果有的话），然后使用取模运算将玩家带回我们想要考虑的简化情况。 最后，它检查玩家的坐标。
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There is one small thing you have to be careful about: modulo can have a negative
    value. This is why we check for this and simply add the width of the repeating
    part to go back to a positive value.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件小事情你需要注意：取模运算可能会得到负值。 这就是为什么我们需要检查并简单地加上重复部分的宽度以转换为正值。
- en: This is a pretty fast way to detect the solution and there are many such cases
    where you can design your own collision detection and make it very efficient because
    you know exactly what to check in your particular situation.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种相当快速的检测解决方案的方法，有许多这样的情况，你可以设计自己的碰撞检测，并且使其非常有效，因为你知道在你特定的情况下需要检查什么。
- en: 'Now we can call this method in our game. There are two places where this should
    be done: in the main loop and in the input handler. When we detect that the player
    died, we need to decrease its life and move it to the right place. Furthermore,
    we want to detect that the player has no more life and change the game''s state
    to `GAMEOVER` in this situation. The following function does just that:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在我们的游戏中调用这个方法。有两个地方应该这样做：在主循环中和在输入处理程序中。当我们检测到玩家死亡时，我们需要减少其生命并将其移动到正确的位置。此外，我们希望在这种情况下检测到玩家没有生命了，并将游戏状态更改为`GAMEOVER`。以下函数就是这样做的：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can add the collision detection in the main loop. We will need to check
    for another thing: the player shouldn''t go out of the screen in one of the packets.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在主循环中添加碰撞检测。我们还需要检查另一件事：玩家不应该在其中一个数据包中走出屏幕。
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the input handler, we will add the code into the callback executed at the
    end of the jump animation. For example, to check collision for a jump from the
    start to the first line we will write the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入处理程序中，我们将代码添加到跳跃动画结束时执行的回调中。例如，要检查从起始位置跳到第一行的碰撞，我们将编写以下内容：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here you see why we didn't use `gameState` in the `kill` function. In this situation,
    the player is still in its previous state. It still hasn't "landed" so to say.
    Only if the jump was safe, we will change the player's state to the next line.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到为什么我们在`kill`函数中没有使用`gameState`。在这种情况下，玩家仍处于其先前的状态。它仍然没有“着陆”，可以这么说。只有在跳跃安全时，我们才会将玩家的状态更改为下一行。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We now have a game that completely implements the specification that we defined
    at the beginning of the chapter. The code is not yet optimized and that will be
    the subject of our next chapter, but to make a game that is nice to play it would
    really need more polish. You could add a high-score system, integration with social
    networks, and sound and touch device compatibility.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个完全实现了我们在本章开头定义的规范的游戏。代码还没有优化，这将是我们下一章的主题，但为了制作一个好玩的游戏，它确实需要更多的打磨。你可以添加一个高分系统，与社交网络集成，以及声音和触摸设备兼容性。
- en: 'We will cover those topics and more in the future chapters. However, there
    are a lot of things you can do with what you have already learned now to make
    the game better: you may want to add an animation for when the player dies, a
    nicer GUI, nicer graphics, the ability to jump back, and more than one level.
    It''s these small things that will make your game stand out and you should really
    invest a big part of your time to give this professional finish to your game!'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在未来的章节中涵盖这些主题及更多内容。然而，有很多事情你现在已经学到了，可以用来改善游戏：你可能想为玩家死亡时添加动画，一个更好的 GUI，更漂亮的图形，能够向后跳跃，以及不止一个关卡。正是这些小细节将使你的游戏脱颖而出，你真的应该投入大部分时间来给你的游戏以专业的完成！
