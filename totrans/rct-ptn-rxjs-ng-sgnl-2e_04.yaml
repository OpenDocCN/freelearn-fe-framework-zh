- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Handling Errors Reactively
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式处理错误
- en: Errors in programming happen all the time, and RxJS is no exception. Handling
    those errors is a crucial part of every application. As I always say to my students
    in every training session, implementing a process that only covers happy cases
    determines the failure of your application. However, in RxJS, there are a lot
    of error handling strategies that you need to learn in order to handle errors
    efficiently.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中的错误时常发生，RxJS也不例外。处理这些错误是每个应用程序的关键部分。正如我在每次培训课程中总是对我的学生说的，只涵盖愉快情况的流程会导致你的应用程序失败。然而，在RxJS中，有许多错误处理策略你需要学习，以便有效地处理错误。
- en: We will start by explaining the contract of the Observable in RxJS, which is
    crucial to understanding what comes after. Then, we will learn the different error
    handling patterns and the operators provided by RxJS for that purpose. Next, we
    will shed light on the different error handling strategies and the use case of
    every strategy. Finally, we will practice one of the error handling strategies
    in our recipe app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先解释RxJS中可观察者的合约，这是理解接下来内容的关键。然后，我们将学习不同的错误处理模式和RxJS提供的用于此目的的操作符。接下来，我们将阐明不同的错误处理策略和每种策略的用例。最后，我们将在我们的食谱应用中实践一种错误处理策略。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding the anatomy of an Observable contract
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解可观察者合约的结构
- en: Exploring error handling patterns and strategies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索错误处理模式和策略
- en: Handling errors in our recipe app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的食谱应用中处理错误
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you have a basic understanding of RxJS. The source
    code of this chapter (except the samples) is available at [https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap04](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap04).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设你已对RxJS有基本的了解。本章的源代码（除示例外）可在[https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap04](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap04)找到。
- en: Please also refer to the *Technical requirements* section in [*Chapter 3*](B21180_03.xhtml#_idTextAnchor047),
    *Fetching Data* *as Streams*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[*第3章*](B21180_03.xhtml#_idTextAnchor047)，*作为流获取数据*中的*技术要求*部分。
- en: Understanding the anatomy of an Observable contract
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解可观察者合约的结构
- en: 'Understanding the anatomy of an **Observable contract** is crucial in order
    to learn error handling patterns. Let’s dig deep into the Observable execution
    timeline by exploring the marble diagram explained in [*Chapter 1*](B21180_01.xhtml#_idTextAnchor016),
    *Diving into the* *Reactive Paradigm*:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了学习错误处理模式，理解**可观察者合约**的结构至关重要。让我们通过探索[*第1章*](B21180_01.xhtml#_idTextAnchor016)，*深入反应范式*中解释的宝石图来深入了解可观察者执行时间线：
- en: '![Figure 4.1 – The marble diagram elements](img/B21180_04_1.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 宝石图元素](img/B21180_04_1.jpg)'
- en: Figure 4.1 – The marble diagram elements
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 宝石图元素
- en: 'Let’s examine the previous diagram. If we take a look at the stream’s lifecycle,
    we can figure out that a stream has two final statuses:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查之前的图。如果我们看一下流的生存周期，我们可以弄清楚流有两个最终状态：
- en: '**Completion status**: Where the stream has ended without errors and will not
    emit any further values. It is a shutdown, i.e., the Observable completes.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成状态**：流在没有错误的情况下结束，不会发出任何进一步的值。这是一个关闭，即可观察者完成。'
- en: '**Error status**: Where the stream has ended with an error and will not emit
    any further values after the error is thrown. It is also a shutdown.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误状态**：流在出现错误后结束，错误发生后不会发出任何进一步的值。它也是一个关闭。'
- en: Only one of those two states can occur, not both, and every stream can error
    out once. This is the Observable contract.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种状态中只有一个可以发生，不是两者同时发生，每个流最多只能出现一次错误。这就是可观察者合约。
- en: At this point, you may be wondering, How we can recover from an error then?
    This is what we will be learning in the following sections.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能想知道，我们如何从错误中恢复？这就是我们在接下来的几节中要学习的内容。
- en: Exploring error handling patterns and strategies
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索错误处理模式和策略
- en: 'The first classic pattern we will learn for handling errors is based on the
    `subscribe()` method. The `subscribe()` method takes as input the object Observer,
    which has three callbacks:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习的第一个经典错误处理模式基于`subscribe()`方法。`subscribe()`方法接受作为输入的Observer对象，它有三个回调：
- en: 'A **success callback**: This is called every time the stream emits a value
    and receives as input the value emitted'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成功回调**：每次流发出值时都会调用，并接收发出的值作为输入'
- en: 'An **error callback**: This is called when an error occurs and receives as
    input the error itself'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误回调**：当发生错误时调用，并接收错误本身作为输入'
- en: 'A **completion callback**: This is called when the stream completes'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成回调**：当流完成时调用'
- en: 'This is a basic example of a `subscribe` implementation:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`subscribe`实现的简单示例：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the code sample, `stream$` represents our Observable, and we passed an object
    that has three callbacks to the `subscribe` method:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例中，`stream$`代表我们的Observable，我们将一个包含三个回调的对象传递给`subscribe`方法：
- en: A success callback that logs the received value in the console
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功回调，用于在控制台记录接收到的值
- en: An error callback that logs the received error in the console
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将接收到的错误记录在控制台中的错误回调
- en: A complete callback that logs the stream completion
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的回调，用于记录流的完成
- en: So, in order to handle errors, the first possibility is implementing the error
    callback and tracing the error message, displaying an error popup to the user,
    or doing any other custom behavior. Pretty simple!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了处理错误，第一种可能性是实现错误回调并跟踪错误消息，显示错误弹出窗口给用户，或执行任何其他自定义行为。很简单！
- en: But wait! In [*Chapter 3*](B21180_03.xhtml#_idTextAnchor047), *Fetching Data
    as Streams*, we saw that we need to avoid the explicit `subscribe()` to streams
    and learned the reasons and limitations behind this, namely, that it is impossible
    to recover from the error or emit an alternative fallback.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！在[*第3章*](B21180_03.xhtml#_idTextAnchor047)，*作为流获取数据*中，我们看到了我们需要避免对流的显式`subscribe()`，并了解了背后的原因和限制，即无法从错误中恢复或发出替代回退。
- en: That’s right; in most cases, we will not be using `subscribe()` explicitly.
    I just wanted to show you the classic way to do this, which is not the best way.
    Instead, let’s see some advanced error handling patterns and learn more operators
    that will help us in the error handling process.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对，在大多数情况下，我们不会显式使用`subscribe()`。我只是想向你展示做这件事的经典方式，但这并不是最好的方式。相反，让我们看看一些高级错误处理模式，并学习更多有助于我们错误处理过程的操作符。
- en: 'I think you may be familiar with the try-catch statement available in many
    programming languages, which consists of a `try` block followed by one or more
    `catch` clauses. In the `try` block, you place your risky statements, and inside
    `catch`, you handle the possible exceptions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为你可能熟悉许多编程语言中可用的`try-catch`语句，它由一个`try`块后跟一个或多个`catch`子句组成。在`try`块中，你放置你的风险语句，并在`catch`中处理可能的异常：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: RxJS ships with the `catchError` operator, which provides us with something
    similar to the try-catch statement. The `catchError` operator is defined in the
    RxJS official documentation as an operator that “*catches errors on the Observable
    to be handled by returning a new Observable or throwing* *an error*.”
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS附带`catchError`操作符，它为我们提供了类似于`try-catch`语句的功能。`catchError`操作符在RxJS官方文档中定义为“*在Observable上捕获错误，通过返回一个新的Observable或抛出一个错误来处理*”的操作符。
- en: The `catchError` operator subscribes to the source Observable that might error
    out and emits values to the observer until an error occurs. When an error happens,
    the `catchError` operator executes a callback function, passing in the error.
    This callback function is responsible for handling errors and always returns an
    Observable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`catchError`操作符订阅可能发生错误的源Observable，并向观察者发出值，直到发生错误。当发生错误时，`catchError`操作符执行一个回调函数，传入错误。此回调函数负责处理错误，并始终返回一个Observable。'
- en: If there are no errors, the output Observable returned by `catchError` works
    exactly the same way as the source Observable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误，`catchError`返回的输出Observable与源Observable的工作方式完全相同。
- en: 'You can use `catchError` multiple times in an Observable chain, like so:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Observable链中多次使用`catchError`，如下所示：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After calling the `catchError` operator, we need to implement the callback
    function that will handle the error. When it comes to handling errors, there are
    three strategies:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`catchError`操作符之后，我们需要实现一个处理错误的回调函数。当涉及到错误处理时，有三种策略：
- en: The replace strategy
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换策略
- en: The rethrow strategy
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新抛出策略
- en: The retry strategy
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试策略
- en: Let’s break down these three strategies one by one in the following sections
    and explore some examples and use cases.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的几个部分中逐一分析这三种策略，并探讨一些示例和用例。
- en: The replace strategy
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换策略
- en: 'The **replace strategy** is named as such because the Observable returned by
    the error handling function will replace the Observable that has just errored
    out. This replacement Observable is then subscribed to, and its values are used
    instead of the errored-out input Observable. The following code is an example
    of this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**替换策略**之所以被命名为这样，是因为错误处理函数返回的Observable将替换掉刚刚发生错误的Observable。然后，这个替换Observable被订阅，并且它的值被用来代替出错输入Observable。以下代码是一个例子：'
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let’s break down what is happening in this example.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下这个例子中发生的情况。
- en: First, we have an Observable, `stream$`, created from an array of string values,
    `['5', '10', '6', 'Hello', '2']`, using the `from` creation operator. This operator
    creates an Observable that, when subscribing to it, will emit the array’s values
    one by one and then complete.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一个由字符串值数组`['5', '10', '6', 'Hello', '2']`使用`from`创建操作符创建的Observable，`stream$`。这个操作符创建了一个Observable，当订阅它时，将依次发出数组的值，然后完成。
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more details about the `from` operator, please refer to the official documentation:
    [https://rxjs.dev/api/index/function/from#description](https://rxjs.dev/api/index/function/from#description).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`from`操作符的更多详细信息，请参阅官方文档：[https://rxjs.dev/api/index/function/from#description](https://rxjs.dev/api/index/function/from#description)。
- en: 'Next, we combined two operators in the pipe method of `stream$`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`stream$`的管道方法中组合了两个操作符：
- en: 'The `map` operator: This is used to transform the string values emitted to
    integers using the `parseInt()` method. If the value emitted is not a number,
    then an error is thrown with a `"This is not a` `number"` message.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`操作符：这个操作符用于使用`parseInt()`方法将发出的字符串值转换为整数。如果发出的值不是数字，则抛出一个带有消息`"This is
    not a"`的`number`错误。'
- en: 'The `catchError` operator: We pass the error handling function to it, which
    will log the caught error and return `of()`. `of()` creates an Observable that
    has no values to emit, so it will immediately complete.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catchError`操作符：我们向其中传递错误处理函数，该函数将记录捕获到的错误并返回`of()`。`of()`创建了一个没有要发出值的Observable，因此它将立即完成。'
- en: Then, we subscribe to the `stream$` and log a custom message in every callback
    to see what exactly happens at execution time.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们订阅了`stream$`，并在每个回调中记录一个自定义消息，以查看执行时间确实发生了什么。
- en: At execution time, `stream$` will emit the string values of the array one by
    one (`'5'`, `'10'`, and `'6'`, respectively). The `map` takes those values one
    by one as input and returns `5`, `10`, and `6`, respectively. `catchError()` takes
    the values emitted from the map operator and forwards them as output; the error
    handling function will not get called, as there is no error. Hence, the subscribers
    will receive `5`, `10`, and `6`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行时间，`stream$`将依次发出数组的字符串值（分别是`'5'`、`'10'`和`'6'`）。`map`操作符逐个将这些值作为输入，并分别返回`5`、`10`和`6`。`catchError()`操作符接收来自`map`操作符发出的值，并将它们作为输出转发；由于没有错误，错误处理函数将不会被调用。因此，订阅者将接收到`5`、`10`和`6`。
- en: The `catchError()` operator comes into play when the `'Hello'` value is emitted.
    The map operator will throw an error, and the error handling function in `catchError()`
    will, consequently, get called. The error handling function, in our case, simply
    logs an error in the console and returns an Observable (created by the `of()`
    operator) that will immediately complete. This Observable will replace the current
    Observable that had an error; that’s why we call it the replacement Observable.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当发出`'Hello'`值时，`catchError()`操作符开始发挥作用。`map`操作符将抛出一个错误，并且`catchError()`中的错误处理函数将相应地被调用。在我们的例子中，错误处理函数只是简单地记录一个错误到控制台，并返回一个由`of()`操作符创建的将立即完成的Observable。这个Observable将替换掉有错误的当前Observable；这就是为什么我们称之为替换Observable。
- en: '`catchError()` will subscribe under the hood to the returned Observable. The
    `of()` Observable will complete immediately. Then, `stream$` is completed, so
    the next value, `''2''`, will not get emitted.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`catchError()`在底层订阅了返回的Observable。`of()` Observable将立即完成。然后，`stream$`完成，所以下一个值`''2''`将不会发出。'
- en: As you may have noticed, the error callback in the `subscribe()` method will
    not get called because we handled it in `catchError`. I added it on purpose to
    understand the behavior of error handling with `catchError`. Therefore, when an
    error occurs, the current stream that had an error out will get replaced by the
    stream returned from the `catchError()`; the values of the replaced Observable
    will then get emitted instead of the original stream values. This is what we call
    **fallback values**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所注意到的，`subscribe()`方法中的错误回调不会被调用，因为我们已经在`catchError`中处理了它。我故意添加它来理解使用`catchError`的错误处理行为。因此，当发生错误时，当前出错流将被`catchError()`返回的流所替换；替换后的Observable的值将代替原始流值被发出。这就是我们所说的**回退值**。
- en: So, to summarize, the replace strategy is useful when we want to handle the
    error inside the stream itself and don’t want the error to get propagated to the
    subscribers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结来说，替换策略在我们要在流内部处理错误，并且不希望错误传播给订阅者时非常有用。
- en: The rethrow strategy
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新抛出策略
- en: The `catchError`. Notifying the subscribers about the error will help them perform
    side effects, such as displaying an error message in a popup.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`catchError`。通知订阅者关于错误的信息将帮助他们执行副作用，例如在弹出窗口中显示错误消息。'
- en: 'To understand more about this strategy, let’s look at the following example;
    it is the same as the one in the previous section, with the only difference being
    the error handling function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地了解这种策略，让我们看看以下示例；它与上一节中的示例相同，唯一的区别在于错误处理函数：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the error handling function, we return an Observable that is created using
    the `throwError` operator. The `throwError` operator creates an Observable that
    never emits any value; instead, it errors out immediately using the same error
    caught by `catchError`. In this way, the error will get pushed to the subscribers
    and can be further handled by the rest of the Observable chain if needed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在错误处理函数中，我们返回一个使用`throwError`操作符创建的Observable。`throwError`操作符创建一个永远不会发出任何值的Observable；相反，它会立即使用`catchError`捕获的错误出错。这样，错误将被推送到订阅者，如果需要，可以由Observable链的其余部分进一步处理。
- en: As you may have noticed, the same error was logged both in the `catchError`
    block and the subscriber error handler function, as expected, so the rethrow strategy
    has worked.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所注意到的，与预期的一样，相同的错误同时在`catchError`块和订阅者错误处理函数中被记录，因此重新抛出策略已经生效。
- en: Please note that in the previous examples, we simply log the error in the console
    for demonstration purposes. However, in a real-world scenario, you can do much
    more, such as showing messages to the users.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在之前的示例中，我们只是为了演示目的在控制台中简单地记录了错误。然而，在现实世界的场景中，你可以做更多的事情，例如向用户显示消息。
- en: The retrying strategy
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重试策略
- en: 'With the `retry` operator to give another chance to the stream. The `retry`
    operator retries an Observable a specific number of times and is useful for retrying
    HTTP requests or connections. We can see an example here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`retry`操作符给流提供另一次机会。`retry`操作符会重试一个Observable特定次数，这对于重试HTTP请求或连接非常有用。这里我们可以看到一个例子：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you may have noticed, the values of the source stream were emitted two times
    since we called the `retry` operator with `2` as a parameter; we gave the Observable
    two chances before throwing the error.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所注意到的，源流的值被发出了两次，因为我们用`2`作为参数调用了`retry`操作符；在抛出错误之前，我们给了Observable两次机会。
- en: Now, in this case, we are retrying immediately. However, what if we want to
    retry in only specific cases or wait for a delay before retrying? This is where
    the `retryWhen` operator comes into play!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这种情况下，我们正在立即重试。但是，如果我们只想在特定情况下重试或者等待一段时间后再重试呢？这就是`retryWhen`操作符发挥作用的地方！
- en: 'To understand the `retryWhen` operator, there’s nothing better than a marble
    diagram:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`retryWhen`操作符，没有什么比一个弹珠图更好的了：
- en: '![Figure 4.2 – The retryWhen operator](img/B21180_04_2.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – retryWhen操作符](img/B21180_04_2.jpg)'
- en: Figure 4.2 – The retryWhen operator
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – retryWhen操作符
- en: 'Let’s explain what’s going on here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下这里发生了什么：
- en: The Observable in the first line is the **notifier Observable** that is going
    to determine when the retry should occur
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行的Observable是**通知Observable**，它将决定重试何时发生
- en: The Observable in the second line is the **source Observable** that will error
    out after emitting **1** and **2**
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行的Observable是**源Observable**，在发出**1**和**2**之后将会出错
- en: When we subscribe to the source Observable it will emit `retryWhen` forwards
    those values as output. Then, the source Observable errors out and completes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们订阅源Observable时，它将发出`retryWhen`并将这些值作为输出。然后，源Observable出错并完成。
- en: Nothing will happen until the notifier Observable emits the first value, `retryWhen`
    will subscribe to the source Observable because it is already completed, so even
    if it is completed, it can be retried.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通知器Observable发出第一个值之前，什么都不会发生，`retryWhen`将订阅源Observable，因为它已经完成了，所以即使它已经完成，也可以重试。
- en: The notifier Observable is then going to emit another **r** value, and the same
    thing occurs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通知器Observable将发出另一个**r**值，发生同样的情况。
- en: Next, `retryWhen` starts to emit the first **1** value, but soon after, the
    notifier Observable completes; that’s why the **2** value will not get emitted.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`retryWhen`开始发出第一个**1**值，但很快，通知器Observable就完成了；这就是为什么**2**值不会发出。
- en: As you may have guessed, `retryWhen` retries the source Observable each time
    the notifier emits a value! This means that you can use this notifier Observable
    to emit values at the moment you want your source Observable to get retried and
    complete it at the moment you want your retry attempts to stop.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，每当通知器发出值时，`retryWhen`都会重试源Observable！这意味着你可以使用这个通知器Observable在你想要源Observable重试并完成的时候发出值，并在你想要停止重试尝试的时候完成它。
- en: 'Now, let’s have a look at the signature of the `retryWhen` operator:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`retryWhen`操作符的签名：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `notifier` parameter represents the callback that returns the notifier Observable
    and gets the error Observable as the argument. The error Observable will emit
    every time the source Observable errors out. So, `retryWhen` will subscribe to
    the notifier Observable and behave as described previously.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`notifier`参数表示返回通知器Observable并获取错误Observable作为参数的回调。每当源Observable出错时，错误Observable都会发出。因此，`retryWhen`将订阅通知器Observable并按之前描述的方式行为。'
- en: 'Here is the same example given in the replace and rethrow strategies, but using
    `retryWhen` instead:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是替换和重新抛出策略中给出的相同示例，但使用`retryWhen`代替：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the previous code, the first error is thrown when receiving the value `'Hello'`,
    which is not a number. The `retryWhen` operator will catch this error and get
    executed. Then, the notifier callback (the argument of `retryWhen`) simply takes
    the error Observable as input and returns it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，第一次错误是在接收到值`'Hello'`时抛出的，这不是一个数字。`retryWhen`操作符将捕获这个错误并执行。然后，通知回调（`retryWhen`的参数）简单地以错误Observable作为输入并返回它。
- en: We also used the pipe to call the `tap` operator in order to log a message in
    the console (`'Retrying the source Observable...'` ). The `tap()` operator is
    used to perform a side effect for each emitted value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了`pipe`来调用`tap`操作符，以便在控制台记录一条消息（`'Retrying the source Observable...'`）。`tap()`操作符用于对每个发出的值执行副作用。
- en: Note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more details about the `tap` operator, please refer to this link from the
    official documentation: [https://rxjs.dev/api/operators/tap](https://rxjs.dev/api/operators/tap).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`tap`操作符的更多详细信息，请参阅官方文档中的此链接：[https://rxjs.dev/api/operators/tap](https://rxjs.dev/api/operators/tap)。
- en: If you execute that code, you will find out that it runs infinitely. Why? Because
    the source will always error out, and `retryWhen` will, consequently, subscribe
    infinitely to the source Observable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行这段代码，你会发现它会无限运行。为什么？因为源总是会出错，而`retryWhen`将无限期地订阅源Observable。
- en: If the source always errors out, it is not correct to retry immediately. However,
    the error will not always occur, for example, in the case of HTTP requests. Sometimes,
    the HTTP request fails because the server is down, or there is another temporary
    reason that may disappear, and the request might go through in the next attempts
    without any problem.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源总是出错，立即重试是不正确的。然而，错误并不总是发生，例如，在HTTP请求的情况下。有时，HTTP请求失败是因为服务器宕机，或者有其他可能消失的临时原因，而在下一次尝试中可能没有任何问题。
- en: In that case, you can use the immediate retry or even a delayed retry, which
    retries after a certain delay, where we can wait, for example, for 5 seconds after
    the error occurs before retrying. That’s what we will be learning in the next
    section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，你可以使用立即重试，甚至延迟重试，在一定的延迟后重试，例如，在发生错误后等待5秒钟再重试。这就是我们将在下一节学习的内容。
- en: 'Now, let’s have a look at another operator that will help us implement the
    retry strategy: the `delayWhen` operator. The `delayWhen()` operator is used to
    delay values emitted from the source Observable by a given duration. It is similar
    to the `delay()` operator, but the delay duration is determined by an input Observable.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一个将帮助我们实现重试策略的操作符：`delayWhen`操作符。`delayWhen()`操作符用于通过给定的时间延迟从源Observable发出的值。它与`delay()`操作符类似，但延迟持续时间由一个输入Observable确定。
- en: 'For more detail, let’s take a look at a marble diagram:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 更多细节，让我们看看一个弹珠图：
- en: '![Figure 4.3 – The delayWhen operator](img/B21180_04_3.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – delayWhen操作符](img/B21180_04_3.jpg)'
- en: Figure 4.3 – The delayWhen operator
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – delayWhen操作符
- en: 'The first Observable is the source Observable. Each of the values, **a**, **b**,
    and **c**, has its own duration selector Observable, respectively, in the diagram:
    the **a** duration selector Observable, the **b** duration selector Observable,
    and the **c** duration selector Observable, which will emit one value, **x**,
    and then complete.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个Observable是源Observable。图中的每个值，**a**、**b**和**c**，分别有自己的持续时间选择器Observable，分别是：**a**持续时间选择器Observable、**b**持续时间选择器Observable和**c**持续时间选择器Observable，它们将发出一个值**x**，然后完成。
- en: Every value emitted by the source Observable will be delayed before being emitted
    to the output Observable. In fact, when the source Observable emits the value
    `delayWhen` operator will not immediately emit the value to the source Observable;
    instead, it will wait for the **a** duration selector Observable to emit a value
    at **ta+delay**, and at that exact time, the value **a** will get emitted to the
    Output Observable.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 源Observable发出的每个值在发出到输出Observable之前都会被延迟。实际上，当源Observable发出值时，`delayWhen`操作符不会立即将值发出到源Observable；相反，它将等待**a**持续时间选择器Observable在**ta+delay**处发出值，并且在这个确切的时间，值**a**将被发出到输出Observable。
- en: This carries on for the other values; the **b** value will show up in the Output
    Observable at **tb+delay** when the **b** duration selector emits a value, and
    the value **c** will get emitted at **tc+delay** when the **c** duration selector
    Observable emits a value. Note that here, **tb** and **tc** represent the emission
    time of the values **a** and **b** by the source Observable, respectively.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这对其他值也是如此；当**b**持续时间选择器发出值时，**b**值将在输出Observable的**tb+delay**处显示，当**c**持续时间选择器Observable发出值时，值**c**将在**tc+delay**处发出。请注意，在这里，**tb**和**tc**分别代表源Observable发出值**a**和**b**的时间。
- en: As you may have noticed, the value **b** was emitted before **c** by the source
    Observable (as **tb** precedes **tc**); however, the value **b** was shown after
    the value **c** in the output Observable (as **tb+delay** succeeds **tc+delay**);
    that’s because the selector of **b** (the **b** duration selector in *Figure 4**.3*)
    is emitted after the selector of **c** (the **c** duration selector also shown
    in *Figure 4**.3*).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，源Observable在**b**在**c**之前发出（因为**tb**在**tc**之前）；然而，在输出Observable中，**b**的值在**c**的值之后显示（因为**tb+delay**在**tc+delay**之后）；这是因为**b**的选择器（*图4.3*中的**b**持续时间选择器）在**c**的选择器（*图4.3*中也显示的**c**持续时间选择器）之后发出。
- en: So, as you can see, the delay is completely flexible through the `durationSelector`
    function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如你所看到的，延迟完全可以通过`durationSelector`函数来灵活调整。
- en: 'Another function, the `timer` function, can be useful in the delayed retry
    strategy:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个函数，`timer`函数，在延迟重试策略中可能很有用：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This `timer` function returns an Observable and takes two arguments:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`timer`函数返回一个Observable，并接受两个参数：
- en: '`due`: A time period or exact date before which no values will be emitted'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`due`：一个时间周期或确切日期，在此日期之前不会发出任何值'
- en: '`scheduler`: A periodic interval, in case we want to emit new values periodically'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scheduler`：一个周期性间隔，如果我们想定期发出新值'
- en: An example is `timer(5000,1000)`. The first value of the returned Observable
    will get emitted after 5 seconds, and a new value is emitted each second. The
    second argument is optional, which means that `timer(5000)` will emit a value
    after 5 seconds and then complete.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是`timer(5000,1000)`。返回的Observable的第一个值将在5秒后发出，并且每秒发出一个新值。第二个参数是可选的，这意味着`timer(5000)`将在5秒后发出一个值然后完成。
- en: 'Now, it is time to combine the `delayWhen` and `retryWhen` operators to see
    how we can retry a failing HTTP request 5 seconds after each error:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将`delayWhen`和`retryWhen`操作符结合起来，看看我们如何在每次错误后5秒重试失败的HTTP请求了：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will not find the preceding code in the GitHub repository, as it serves
    merely as an illustrative example. However, you can copy and paste it into the
    `RecipesService` class in order to test the delayed retry. Additionally, remember
    to stop `the recipes-book-api` mocked server to simulate retry attempts.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 GitHub 仓库中找不到前面的代码，因为它仅仅是一个说明性的示例。然而，你可以将其复制并粘贴到 `RecipesService` 类中以测试延迟重试。此外，记得停止
    `recipes-book-api` 模拟服务器以模拟重试尝试。
- en: Our source Observable, in this case, is the result of an HTTP `get` request.
    Each time the request fails, the `delayWhen` operator creates a duration selector
    Observable through the `timer` function. This duration selector Observable is
    going to emit the `0` value after 5 seconds and then complete. Therefore, the
    notifier Observable of `retryWhen` will emit a value, and at that moment, the
    source Observable will get retried, after 5 seconds to be exact.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的源 Observable 是 HTTP `get` 请求的结果。每次请求失败时，`delayWhen` 操作符通过 `timer`
    函数创建一个持续时间选择器 Observable。这个持续时间选择器 Observable 将在 5 秒后发出 `0` 值并完成。因此，`retryWhen`
    的通知 Observable 将发出一个值，此时，源 Observable 将在 5 秒后重试。
- en: 'When you open the console, you will see this output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开控制台时，你会看到以下输出：
- en: '![Figure 4.4 – The failing HTTP request](img/B21180_04_4.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 失败的 HTTP 请求](img/B21180_04_4.jpg)'
- en: Figure 4.4 – The failing HTTP request
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 失败的 HTTP 请求
- en: As you may have noticed, every time the GET HTTP request fails, it is retried
    again after 5 seconds. That’s how we achieved a delayed retry! So, to wrap up,
    each of the error handling strategies has its own techniques and serves a different
    purpose. In the following section, we will explore when to use each strategy.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，每次 GET HTTP 请求失败后，都会在 5 秒后再次尝试。这就是我们实现延迟重试的方法！所以，总结一下，每种错误处理策略都有其自己的技术，并服务于不同的目的。在下一节中，我们将探讨何时使用每种策略。
- en: Choosing the right error handling strategy
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择合适的错误处理策略
- en: Choosing the most appropriate error handling strategy in RxJS depends on various
    factors, such as the nature of the application, the type of errors encountered,
    and the desired user experience. Here’s some guidance on when to use each strategy.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RxJS 中选择最合适的错误处理策略取决于各种因素，例如应用程序的性质、遇到的错误类型以及期望的用户体验。以下是一些关于何时使用每种策略的指导。
- en: 'The replace strategy involves replacing the error with a fallback value or
    Observable. It’s suitable in the following scenarios:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 替换策略涉及用回退值或 Observable 替换错误。它适用于以下场景：
- en: You have a predefined fallback value or behavior to use when an error occurs,
    such as displaying placeholder content or default settings. For example, in a
    weather application, if fetching current weather data fails, you can replace the
    error with a default weather forecast for the user’s location.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发生错误时，你有预定义的回退值或行为可以使用，例如显示占位符内容或默认设置。例如，在一个天气应用程序中，如果获取当前天气数据失败，你可以用用户位置的默认天气预报替换错误。
- en: The error is recoverable and doesn’t require immediate intervention from the
    user.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误是可恢复的，并且不需要用户立即干预。
- en: You want to provide a seamless user experience by gracefully handling errors
    without disrupting the application flow.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你希望通过优雅地处理错误而不中断应用程序流程来提供无缝的用户体验。
- en: 'The rethrow strategy involves rethrowing the error to propagate it to the subscriber
    for handling. It’s suitable in the following scenarios:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 重新抛出策略涉及重新抛出错误以将其传播给订阅者进行处理。它适用于以下场景：
- en: You want to delegate error-handling responsibility to the subscriber or consumer
    of the Observable. For example, in an authentication service, if login fails due
    to invalid credentials, you can rethrow the error to allow the UI component to
    display an error message to the user.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你希望将错误处理的责任委托给 Observable 的订阅者或消费者。例如，在一个身份验证服务中，如果由于凭据无效导致登录失败，你可以重新抛出错误以允许
    UI 组件向用户显示错误消息。
- en: The error requires specific handling logic or customization based on the context
    in which it occurs.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误需要根据其发生的上下文进行特定的处理逻辑或定制。
- en: You want to provide flexibility for different parts of the application to handle
    errors differently.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你希望为应用程序的不同部分提供灵活性，以便它们可以以不同的方式处理错误。
- en: 'The retry strategy involves retrying the operation that resulted in the error
    a certain number of times. It’s suitable in the following scenarios:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 重试策略涉及重试导致错误的操作一定次数。它适用于以下场景：
- en: The error is transient or intermittent, such as network errors or temporary
    service disruptions where retrying the operation may succeed after subsequent
    attempts. For example, in a file upload service, if uploading a file fails due
    to a network error, you can retry the upload operation multiple times before giving
    up to ensure the file is successfully uploaded.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误是瞬时的或间歇性的，例如网络错误或暂时性的服务中断，在后续尝试之后重试操作可能会成功。例如，在一个文件上传服务中，如果由于网络错误上传文件失败，你可以在放弃之前多次重试上传操作，以确保文件成功上传。
- en: Retrying the operation has a reasonable chance of success and can mitigate the
    impact of transient failures.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试操作有合理的成功机会，并且可以减轻瞬时故障的影响。
- en: You want to improve the reliability and robustness of operations that are prone
    to occasional failures.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你希望提高容易偶尔出现故障的操作的可靠性和鲁棒性。
- en: 'Additionally, consider the following factors when choosing an error handling
    strategy:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在选择错误处理策略时，还应考虑以下因素：
- en: '**User experience**: Consider how each strategy affects the user experience,
    such as whether it leads to delays, retries, or fallbacks.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户体验**：考虑每种策略如何影响用户体验，例如它是否会导致延迟、重试或回退。'
- en: '**Application requirements**: Align the chosen strategy with the specific requirements
    and constraints of your application, such as reliability, responsiveness, and
    error tolerance.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序要求**：将所选策略与您应用程序的具体要求和限制相一致，例如可靠性、响应性和错误容忍度。'
- en: '**Performance implications**: Retry strategies may introduce additional overhead,
    especially if the operation involves expensive or time-consuming tasks.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能影响**：重试策略可能会引入额外的开销，尤其是在操作涉及昂贵或耗时任务时。'
- en: Ultimately, the most appropriate error handling strategy depends on the specific
    context and requirements of your application. It’s often beneficial to experiment
    with different strategies and observe their effects in real-world scenarios to
    determine the optimal approach.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，最合适的错误处理策略取决于您应用程序的具体上下文和要求。通常，尝试不同的策略并在实际场景中观察它们的效果，以确定最佳方法是有益的。
- en: Now that we have learned the different strategies and operators to handle errors,
    let’s practice in our Recipes Book app in the next section.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了处理错误的不同策略和运算符，让我们在下一节中在我们的食谱应用程序中进行实践。
- en: Handling errors in our recipe app
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理我们的食谱应用程序中的错误
- en: The first thing we are going to do is stop our mock service. Yes, you heard
    it right; stop it. This way, the call to the `getRecipes` service will fail because
    the server is down.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一件事是停止我们的模拟服务。是的，你没听错；停止它。这样，对`getRecipes`服务的调用将会失败，因为服务器已关闭。
- en: Now, if you refresh the front app, you will see that nothing, including our
    list of recipes, is displayed. Why do we get this behavior? Because we did not
    handle the errors. The error was thrown, the stream was completed, and nothing
    happened afterward. We have a white screen where nothing is displayed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你刷新前端应用程序，你会看到没有任何内容显示，包括我们的食谱列表。为什么我们会得到这种行为？因为我们没有处理错误。错误被抛出，流完成，之后什么也没有发生。我们有一个空白屏幕，上面什么也没有显示。
- en: 'Now open the console, and you will see the failed request:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开控制台，你会看到失败的请求：
- en: '![](img/B21180_04_5.jpg)![](img/B21180_04_6.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/B21180_04_5.jpg)![图片2](img/B21180_04_6.jpg)'
- en: Figure 4.5 – The console showing the failed request
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 显示失败请求的控制台
- en: A failing HTTP request would never have broken our app if it was handled correctly.
    That’s why you should be very careful when raising HTTP requests in your front
    application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正确处理，失败的HTTP请求永远不会破坏我们的应用程序。这就是为什么你在前端应用程序中发起HTTP请求时应该非常小心。
- en: So, how can we fix this? Which strategy that we’ve previously discussed will
    fit the best?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该如何解决这个问题？我们之前讨论过的哪种策略最适合？
- en: If we choose the rethrow or retry strategy, then we will block the display of
    the recipes list. The user will get a blank page and will have to wait for the
    request to get executed successfully in order to see the list of recipes rendered
    in the screen. This is a valid option when you handle processes in the background
    that are not related to the UI display; however, if you raise requests in order
    to get results and display them in your UI components, then you should provide
    a replacement for that data to continue rendering the page. The user interface
    should keep on working regardless of whether or not there is an error; if there
    is an error, then we will display an empty list; if not, we will display the returned
    list from the server.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择重新抛出或重试策略，那么我们将阻止显示食谱列表。用户将看到一个空白页面，必须等待请求成功执行才能看到屏幕上渲染的食谱列表。当你处理与UI显示无关的后台进程时，这是一个有效的选项；然而，如果你提出请求以获取结果并在你的UI组件中显示它们，那么你应该提供数据的替代品以继续渲染页面。无论是否有错误，用户界面都应该继续工作；如果有错误，我们将显示一个空列表；如果没有，我们将显示从服务器返回的列表。
- en: That’s why the replacement strategy fits the most in this particular case. In
    fact, we want to get the list of recipes from the service, but if the service
    fails for whatever reason, I don’t want my application to be frozen; I want to
    see a collection of zero elements (no elements), an empty table, or a list, and
    that is all. So, what we are going to do is use `catchError` and return an empty
    Observable, which is our fallback value.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这个替换策略最适合这个特定情况。实际上，我们希望从服务中获取食谱列表，但如果服务因任何原因失败，我不想我的应用程序冻结；我想看到包含零个元素（没有元素）、一个空表或一个列表，仅此而已。所以，我们将要做的是使用`catchError`并返回一个空的Observable，这是我们备选值。
- en: 'Our service will look like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务将看起来像这样：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This approach ensures that your application remains functional, displaying
    an empty list if you access the app. Moreover, you have the flexibility to customize
    the user interface by incorporating a message such as `recipes-list.component.html`
    as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确保了你的应用程序保持功能正常，如果你访问应用程序，将显示一个空列表。此外，你可以通过包含类似`recipes-list.component.html`的消息来自定义用户界面，如下所示：
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you may have noticed, we used the new built-in control flow mechanism explained
    in [*Chapter 3*](B21180_03.xhtml#_idTextAnchor047), *Fetching Data as Streams*.
    By employing the `@else` block to the first `if` condition, we’re able to display
    the message when no value is emitted from the `recipes$` Observable. Additionally,
    the `@empty` statement added to the `@for` statement allows us to show the same
    message when the list of recipes is empty.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，我们使用了在[*第3章*](B21180_03.xhtml#_idTextAnchor047)中解释的新内置控制流机制，*作为流获取数据*。通过将`@else`块应用于第一个`if`条件，我们能够在`recipes$`Observable没有发出任何值时显示消息。此外，添加到`@for`语句中的`@empty`语句允许我们在食谱列表为空时显示相同的消息。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the Observable contract and explored some
    of the most commonly used RxJS error handling strategies available and the different
    operators, namely `catchError()`, `delayWhen()`, `retry()`, and `retryWhen()`.
    We also shed light on the different strategies for error handling and when to
    choose each strategy. Finally, we handled the error in our Recipes Book app for
    the first implemented feature.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Observable合约，并探讨了RxJS中最常用的错误处理策略和一些不同的操作符，即`catchError()`、`delayWhen()`、`retry()`和`retryWhen()`。我们还阐明了不同的错误处理策略以及何时选择每种策略。最后，我们在我们的食谱书应用中处理了第一个实现的功能的错误。
- en: 'Now that we know how to handle errors in RxJS, let’s move on to the next reactive
    pattern: combining streams.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何在RxJS中处理错误，让我们继续下一个反应式模式：合并流。
