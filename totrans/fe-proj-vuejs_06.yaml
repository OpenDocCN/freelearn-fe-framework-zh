- en: 6\. Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will understand how routing and Vue Router work. We will
    also set up, implement, and manage the routing system in our app with Vue Router.
    Then we will look at dynamic routing for passing parameter values and nested routes
    for better reusability in complex applications. In addition, we will look at JavaScript
    Hooks, which can be used for features such as authentication and error handling.
    By the end of this chapter, you will be ready to handle static and dynamic routing
    in any Vue application.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`website.com/about` into their URL bar, they are routed to the about page.'
  prefs: []
  type: TYPE_NORMAL
- en: With **Single-Page Applications** (**SPAs**), routing allows navigation within
    the application to be done smoothly and without the need for page refreshing.
    In web development, routing is the matching mechanism by which we decide how to
    connect HTTP requests to the code that handles them. We use routing whenever there
    is a need for URL navigation in our application. Most modern web applications
    contain a lot of different URLs, even single-page ones. Thus, routing plays a
    significant role in creating a navigation system and helps users move around our
    application and the web quickly.
  prefs: []
  type: TYPE_NORMAL
- en: In short, routing is a way for an application to interpret what resource users
    want based on the URL provided. It is a system for web-based resource navigation
    with URLs, such as paths to assets (images and videos), scripts, and stylesheets.
  prefs: []
  type: TYPE_NORMAL
- en: Vue Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue Router, as stated in the Vue.js documentation, is officially recommended
    as a router service for any Vue.js application. It provides a single entry point
    for communication between components with routes, hence controlling the flow of
    the application effectively, regardless of the user's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: With a wide range of features, it eases the process of switching pages without
    the need to refresh the page.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Vue Router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Vue Router is not installed by default; however, it can easily be enabled when
    creating an application with Vue CLI. Create an application by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Select the `Manually select features` option as shown in *Figure 6.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Select the manual preset to create a new Vue.js project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.1: Select the manual preset to create a new Vue.js project'
  prefs: []
  type: TYPE_NORMAL
- en: After choosing the option to manually select features, you will be shown a list
    of features as presented in *Figure 6.2*. At the time of writing, by default `Babel`
    and `Linter / Formatter` are selected. Using the *down arrow* key, navigate to
    the `Router` option. With the option highlighted, press the *spacebar* to enable
    it, and then press *Enter* to continue.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Add Vue Router to the project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.2: Add Vue Router to the project'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you will be shown a prompt asking if you want to use `history mode` for
    router configuration, as shown in *Figure 6.3*. Enable history mode by entering
    `Y`. History mode allows navigating between pages without the reload required
    by the default hash mode. We''ll compare the two modes more closely later in the
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: Configure Vue Router with history mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.3: Configure Vue Router with history mode'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, continue with the rest of the process and we will have a Vue.js application
    with Vue Router ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to add Vue Router to an existing Vue.js application, you
    can install it as an application''s dependency with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm install vue-router`'
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to understand the basics of how `vue-router` performs synchronization
    between the browser URL and the application's view.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's look at the `router-view` element.
  prefs: []
  type: TYPE_NORMAL
- en: The router-view Element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `router-view` element is a **functional** component in which the app routing
    system loads the matched and up-to-date view content of any given URL path received
    from the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, `router-view` is a Vue component whose job is to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Render different child components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mount and unmount itself automatically at any nesting level, depending on the
    route's given path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without `router-view`, it is almost impossible to have dynamic content rendered
    correctly for users at runtime. For example, when a user navigates to the `Home`
    page, `router-view` knows and renders the content related to that page only.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how we can set the entry point (default route)
    of an application by passing it a prop.
  prefs: []
  type: TYPE_NORMAL
- en: Using Props to Define the Entry Point of an Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since `router-view` is a component, it can also receive props. The only prop
    it receives is `name`, which is the same name registered in the corresponding
    route's record defined in the `router` object at the initialization phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any other additional attributes are passed directly to the child component
    of `router-view` during rendering. Here is an example with a class attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If `router-view` renders as a child component, we can create an associated
    template where the layout is defined. A very simple example of a template is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The child component receives the passed attribute class, and the actual output
    after rendering becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Of course, for our template to be useful, it should also contain the `<router-view/>`
    element so that content we want to route has somewhere to be rendered. One common
    setup is to have a navigation menu within the template and `router-view` underneath.
    That way the content changes between pages but the menu stays the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to `App.vue` and ensure your template has the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s remove all the code within `<div id="app">` and leave only one single
    `<router-view/>` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now comment out all the code for `routes` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our app output will be rendered as a blank page running on `localhost:8080`,
    as shown in *Figure 6.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: Hello Vue Router application in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.4: Hello Vue Router application in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: The output is an empty page because we have not set up any router configurations
    in our file, including mapping the paths with the related view. Without this step,
    the routing system will not be able to pick the right view and render it into
    our `router-view` element dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to set up Vue Router.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Vue Router for Vue to Use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we add Vue Router to our project, Vue CLI creates and adds a `router` folder
    to the code directory, containing a single auto-generated `index.js` file. This
    file contains the necessary configurations for our router.
  prefs: []
  type: TYPE_NORMAL
- en: We will navigate to the file and go through the basic predefined configuration
    for Vue Router.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you will notice that we need to import both `Vue` and `VueRouter` from
    the `vue` and `vue-router` packages, respectively. Then we call `Vue.use (VueRouter)`
    to install it as a plugin for use within our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`Vue.use` is a global method, as discussed in *Chapter 5*, *Global Component
    Composition*. It triggers the internal `install` method of `VueRouter` together
    with the Vue constructor as soon as Vue is available as a global variable of the
    application. This method has a built-in mechanism to prevent installing a plugin
    more than once.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing `Vue.use(VueRouter)`, the following objects are available for
    access in any component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`this.$router` – The global router object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`this.$route` – The current route object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`this` points to the component in context.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have registered the use of Vue Router in our application, let's
    move on to the next step – defining the routes for the configuration object of
    the router instance.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a web application, a `route` is a URL path pattern and is mapped to a specific
    handler. The `handler`, in modern web development, is a component, defined and
    located in a physical file. For example, when the user enters the route `localhost:8080//home`,
    if `Home` is mapped to this specific route, the routing system knows to trigger
    the handler `Home` to render the content accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: As seen in the preceding example, it is crucial to set up the routes (or paths)
    for navigation within the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each route is an object literal whose properties are declared by the `RouteConfig` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'All the routes needed for an application are located within the `Array` instance
    of `routes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's come back to the previous file, and uncomment the code inside `routes`.
    There will be two predefined routes, `home` and `about`, each as an object and
    located in the `routes` array, for our convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at the first route as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `path` property is a `/about` path will be translated into `<app domain>/about`
    (`localhost:8080/about` or `example.com/about`).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, Vue Router understands `/` – the empty path – as the default path
    for loading the application when there is no other indicator after the forward
    slash `/`, for example when the user navigates to `<app-domain>` or `<app-domain>/`.
  prefs: []
  type: TYPE_NORMAL
- en: The next property is `name`, which is a string, indicating the name given to
    the targeted route. Even though it is **optional**, it's strongly recommended
    to have every route defined with a name, for better code maintenance and route
    tracking purposes, which we will discuss further later in this chapter, in the
    *Passing route parameters* section.
  prefs: []
  type: TYPE_NORMAL
- en: The last property is `component`, which is a Vue component instance. `router-view`
    uses this property as a reference to the view component to render the page content
    when the path is active.
  prefs: []
  type: TYPE_NORMAL
- en: Here we have the route defined as the `home` route, mapped as the default path
    to the application and tied to the `Home` component for content.
  prefs: []
  type: TYPE_NORMAL
- en: Vue CLI also auto-generates two simple components for these two sample routes
    – `Home` and `About`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll go over some tips that can be helpful when loading
    components to be used with routes.
  prefs: []
  type: TYPE_NORMAL
- en: Tips on Loading Components for Route Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Certainly, we need to import the component to tie it to the targeted route
    in the same `index.js` file. The classic and most popular way is to import it
    at the top of the file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Often this will be added under the main imports as shown in *Figure 6.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5: Import Home component on line 3 – src/router/index.js'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.5: Import Home component on line 3 – src/router/index.js'
  prefs: []
  type: TYPE_NORMAL
- en: However, a more efficient way is to lazy-load the component.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lazy loading**, also known as on-demand loading is a technique that aims
    to optimize the content of a website or web application at runtime. It helps to
    reduce the time consumption and amount of resources required to download for an
    application on the first load. This optimization is critical to ensure the best
    user experience possible, where every millisecond of waiting matters. Besides
    this, lazy loading also allows better code-splitting at the route level, along
    with performance optimization in large or complex applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can lazy-load the component with the benefit of using `webpack`. Instead
    of importing the `About` component at the top of the file, as we did with `Home`
    (see *Figure 6.5*), we can instead dynamically add the following right after defining
    the name for the `about` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here we dynamically lazy-load the `About` view component for the `about` route.
    During compilation, `webpack` generates a separate chunk with the designated name
    (`"about"`) for the `about` route, and only loads it when the user visits this
    route.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, since the user will likely land on the default path on the first
    go, it is better to not lazy-load the default component (`Home` in our app) but
    to import it in the normal way. Hence, the tip here is to determine which components
    should be lazy-loaded when designing your routing and combine the two methods
    for the most benefit.
  prefs: []
  type: TYPE_NORMAL
- en: We will now see how to set up the router instance.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Router Instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After defining the routes, the final step is to create the `router` instance
    based on the given configuration options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A configuration is an object consisting of different properties that help to
    form the app's router. We will now examine these properties in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`routes` is a must-have option to pass to the constructor. Without this, the
    router won''t be able to recognize the paths and direct users to the suitable
    view content accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`mode` determines the router''s mode. There are two modes in `VueRouter` for
    URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`history` mode: This leverages the default `history.pushState()` API by means
    of the `HTML5 History` API. It allows us to achieve URL navigation without a page
    reload and makes the URL path human-readable, such as `yourapplication.com/about`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hash` mode: This uses a hash symbol (`#`) to simulate a URL, for example,
    `yourapplication.com/#about` for an `about` page or `youapplication/#/` for the
    `home` URL of your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: base
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`base` determines the base URL for the app. It will be set as `process.env.BASE_URL`
    to allow developers to control this from outside of the application code (from
    a `.env` file, for example). Hence developers can set the directory from which
    the code should be served upon running.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With `base` finally out of the way now, we have the `router` instance created.
    All that is left is to export it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then import it in `main.js`, right before the creation of the main app instance''s
    `new Vue` object. We still need to specify `router` in the instance configuration,
    as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With this updated code, our application will now render as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: Home page of the Hello Vue Router application in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.6: Home page of the Hello Vue Router application in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we navigate to `localhost:8080/about`, we will see the rendered content
    of the `about` component from the auto-generated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The website should look similar to that shown in *Figure 6.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7: About page of the "Hello Vue Router" application in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.7: About page of the "Hello Vue Router" application in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at how lazily loading components can be used to speed
    up large and complex SPAs. We also looked at some of the options that can be set
    when setting up your router, such as routes, mode, and base. In the next section,
    we will learn how to implement and add a message feed page with the help of Vue
    Router.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.01: Implementing and Adding a Message Feed Page Using Vue Router'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to create a new page that displays a list of messages to the user.
    Users will be able to visit this page whenever they enter the `localhost:8080/messages`
    path in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: To access the code files for this exercise, refer to [https://packt.live/35alpze](https://packt.live/35alpze).
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the application generated with `vue create` as a starting point or create
    a new one with `vue-cli`. Ensure you had the router enabled when generating your
    project as described earlier in the chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s create a new view component called `MessageFeed` by adding a `MessageFeed.vue`
    file to the `./src/views/` folder:![Figure 6.8: The views directory hierarchy'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_06_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a router file at `src/router/index.js`. It should import `VueRouter`
    and tell Vue to use the router as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, in `./src/router/index.js`, we declare a route designated for `MessageFeed`,
    named `messageFeed` and with its path set to `/messages`. We will also lazy-load
    the component. This step will be completed by appending an object with the required
    information to the `routes` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, in the same file, create a `router` instance using the `routes` we
    defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the application using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Upon visiting `localhost:8080/messages` in the browser, the page should appear
    with the correct content – the `Message Feed` page as shown in the following screenshot:![Figure
    6.9: Message feed page rendered by the application'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_06_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.9: Message feed page rendered by the application'
  prefs: []
  type: TYPE_NORMAL
- en: This demonstrates how simple it is to add a new page route to a Vue.js application
    using Vue Router, while keeping your code organized and easy to read. Now that
    we have our routes ready to use, we can provide users with the ability to navigate
    between pages, without typing the full path.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Navigation Links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If `router-view` is in charge of rendering the correct active view content relative
    to the URL path, `router-link` is a Vue component that helps users to navigate
    within an app that has routing enabled. By default, it renders an anchor tag `<a>`
    with a correct `href` link generated by its `to` prop.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example app generated by Vue CLI, since there are two routes pre-populated,
    there are also two `router-link` instances added to the `<template>` section of
    `App.vue` right before `<router-view/>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Since we are using the `base` option with the `history` mode, the `to` prop
    of each `router-link` should receive an identical value with the `path` property
    declared in the targeted `route` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, because our routes are named, another alternative to the `to`
    prop is to have the same value as the name, instead of the path. Using the name
    is highly recommended to avoid complex link refactoring in case we have to adjust
    the paths given to some routes in our app. Hence, we can rewrite our links as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also choose to bind a location descriptor object to the `to` prop, in
    a similar format as a `route` object. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In addition, an extra `CSS` class `router-link-active` will be added to the
    `<a>` tag, when the related route is `active`. This class can be customized through
    the `active-class` prop of the `router-link` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `DevTools`, we can see the `router-link` component rendered as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10: router-link in the browser''s DevTools'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.10: router-link in the browser''s DevTools'
  prefs: []
  type: TYPE_NORMAL
- en: 'The view in the browser will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11: Home page of Hello Vue Router app with navigation links'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.11: Home page of Hello Vue Router app with navigation links'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that since we have access to `this.$router` within a component, we can
    trigger a navigation route programmatically by using `this.$router.push()` and
    pass a path or a router object in a similar way to using `to`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we created an example page that rendered a list of messages
    at the `/messages` route location. We also looked at how you can use the `<router-link/>`
    element to navigate between our views in a way similar to traditional HTML `<a>`
    tags.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how you can programmatically send a user to their last viewed
    route in a manner similar to the web browser's *back* button.
  prefs: []
  type: TYPE_NORMAL
- en: Tip to Implement the Back Button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes we would like to navigate back to the previous page. Using `this.$router.push()`
    can achieve this, but this adds more routes in the history stack, instead of going
    back. The correct technique is to use `this.$router.go(steps)`, in which `steps`
    is an integer indicating the number of steps to go back/forward in the history
    stack. This functionality works similarly to `window.history.go(steps)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides this, you can also navigate forward to a page that was loaded before
    and still exists in the history stack by using the same method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we looked at how you can manually access the router's history
    in order to send a user to the page they were previously on.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll make use of navigation links to add our new message
    feed page to our application's `nav` menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.02: Adding the Navigation Link to the MessageFeed Route'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will add a quick link to the `MessageFeed` route we created in *Exercise
    6.01*, *Implementing and Adding a Message Feed Page Using Vue Router*, using the
    `to` prop and `router-link` as explained in the preceding topic.
  prefs: []
  type: TYPE_NORMAL
- en: To access the code files for this exercise, refer to [https://packt.live/3lr8cYR](https://packt.live/3lr8cYR).
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the starter application generated by Vue as a starting point or create
    a new one with `Vue cli`. Ensure you have the router enabled when generating your
    project as described earlier in the chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `./src/App.vue` file, besides the auto-generated `router-link` components
    for `home` and `about`, add another `router-link` component that points to the
    `/messages` path under the `Message Feed` title:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will see the navigation links available in any view and they will not disappear
    when users navigate away since they are not a part of the `router-view` component.
    Our screen should look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.12\. Home page of the Hello Vue Router app with updated navigation
    links'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_06_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 6.12\. Home page of the Hello Vue Router app with updated navigation
    links
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s change the `to` value to point to the object named `messageFeed`, which
    is the same as the `name` given for this route in `./src/App.vue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The navigation should work as before; clicking on the `Message Feed` link should
    direct you to `/messages`, as shown in the following screenshot:![Figure 6.13:
    Message Feed page of Hello Vue Router after clicking on the Message Feed link'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_06_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.13: Message Feed page of Hello Vue Router after clicking on the Message
    Feed link'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, open the `index.js` file located in the `./src/router/` folder and change
    the path defined for the `messageFeed` route from `/messages/` to `/messagesFeed`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the application using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the app''s `Home` page and click on `Message Feed` again. It should
    display the same `messages feed` page as before but note that the URL path changed
    to `/messagesFeed`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.14: Message Feed page rendered with the updated URL path'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_06_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.14: Message Feed page rendered with the updated URL path'
  prefs: []
  type: TYPE_NORMAL
- en: Note how easy it is to set up the link to the `/messages` path with just one
    line of code, as well as updating the related path without refactoring. So far,
    we have just defined some simple routes without any additional parameters for
    the targeted route. This will be our next challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Passing Route Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections of this chapter, each route was a standalone view and
    did not need to pass or connect any data to the other routes. But the power of
    routing is not limited only to this. With **named** routes, we can also easily
    enable data communication between routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example app, we want our `about` page to be able to receive a data string
    called `user` as the user''s name from the link trigger. This can be achieved
    by changing the `to` prop from a string literal to an object literal of `:to="{
    name: ''about'' }"`, and then adding a new `params: { user: ''Adam'' }` property
    to that object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This change informs the router to pass the desired parameters to the `About`
    page when users click on the targeted link. These additional parameters are not
    visible on the rendered `href` link, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15: Generated href link is without parameters'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.15: Generated href link is without parameters'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the Vue system is tracking these additional parameters. Using the
    Vue DevTools, we can view the parameters by expanding the `to` prop as shown in
    *Figure 6.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16: The params of the to object in Vue DevTools'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.16: The params of the to object in Vue DevTools'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `About.vue` file, since we have access to the currently active `$route`
    (see the *Vue Router* section earlier in this chapter), we can retrieve the data
    passed with the link as `$route.params.user` and print out the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17: The About page renders the user passed through route params'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.17: The About page renders the user passed through route params'
  prefs: []
  type: TYPE_NORMAL
- en: Any prop user of `params` will not be visible on the URL path, thus keeping
    the path clean and securing the data transferred between views from the user.
  prefs: []
  type: TYPE_NORMAL
- en: But using `$route.params.user` is not convenient or readable and doesn't keep
    the component reusable in the long run. We can improve this by decoupling the
    passed `params` with the `props` within the component.
  prefs: []
  type: TYPE_NORMAL
- en: We will now see how to decouple the `params` with the help of `props`.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling Params with Props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `index.js` file, let''s adjust the configuration of the `about` route
    with an additional property called `props`. By setting this property''s value
    to `true`, the router will automatically understand and map `$route.params` into
    the `props` component accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `About.vue` file, we will declare the `props` type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the `<template>` section, we will replace `$route.params.user` with `user`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will still be the same, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18: The About page renders the user passed through route params'
  prefs: []
  type: TYPE_NORMAL
- en: and mapped to props
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.18: The About page renders the user passed through route params and
    mapped to props'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this, you can also define the data that you want to pass within
    the `props` property of the `route` configuration. Instead of a Boolean value,
    `props` can now be declared as an object with the required data, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'With a similar step, we will declare `age` as a `props` component in `About.vue`,
    and print it out to the screen as text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the `About` page is clicked, the page will render as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19: About page rendered with the props preset in the router configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.19: About page rendered with the props preset in the router configuration'
  prefs: []
  type: TYPE_NORMAL
- en: Our previous user data is not visible anymore! This is because, now, `props`
    is declared with static data in the configuration of the `About` route and can't
    be overridden from outside. Its value is and will remain the same throughout the
    process of navigating around the app, regardless of what values we pass in `params`
    of the `to` prop in the targeted `router-link` component.
  prefs: []
  type: TYPE_NORMAL
- en: We will now learn how to pass the content of the selected message to a new message
    page and print it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.03: Passing the Content of the Selected Message to a New Message
    Page and Having It Printed Out'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We shall continue from *Exercise 6.02*, *Adding the Navigation Link to the MessageFeed
    Route*, where we defined the `MessageFeed` route with a URL path to `messages`.
    This view will render a list of predefined messages in the `data` property of
    the `view` component's options.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we will create a new `message` page, designated to render
    the content of a message selected by the user. It should be reusable.
  prefs: []
  type: TYPE_NORMAL
- en: To access the code files for this exercise, refer to [https://packt.live/36mTwTY](https://packt.live/36mTwTY).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `./src/views/` folder, we create a new single-file component called
    `Message.vue`. This component receives a `content` prop of type `string` and renders
    it under a `<p>` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s register the created view component to the existing `routes` in `./src/router/index.js`.
    We will define the new route as a `message` with the path to `/message`. It will
    also accept `props: true` in order to map all parameters passed to the route to
    the related prop accordingly. The full list of routes to be used is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since the route is registered and ready to be used, we need to make changes
    to the `<template>` section of `./src/views/MessageFeed.vue` to ensure each message
    line is now clickable and will redirect the user to the new route when clicked.
    Let''s replace the `<p>` tag with `router-click`. And because we have named our
    new route as `message`, we will set `to` to bind to `{ name: ''message'' }`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Under `template`, we''ll add a `script` tag containing some sample data for
    our `messages`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you open the `./messages` page, all the messages are now clickable as
    shown in the following screenshot:![Figure 6.20: Message Feed page after changing
    messages to be clickable'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_06_20.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.20: Message Feed page after changing messages to be clickable'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now when the user clicks on a message, it will open a new page. However, the
    page content will be empty, as we have not passed any content parameter to the
    `<route-click>` component, as shown in the following screenshot:![Figure 6.21:
    Message page with no content generated'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_06_21.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.21: Message page with no content generated'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s go back to `./src/views/MessageFeed.vue` and add `params: { content:
    m }`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now when you click on the first message, `Hello, how are you?`, the output
    will be the following:![Figure 6.22: Message page with the clicked message''s
    content rendered'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15218_06_22.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.22: Message page with the clicked message''s content rendered'
  prefs: []
  type: TYPE_NORMAL
- en: Simple, isn't it? We have completed the flow from a feed of messages to a detailed
    page of a single selected message dynamically with `router-link` and the combination
    of `params` and `props` of the component. However, there is one significant downside
    to this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Let's refresh the page while you are still on the `./message` path of the first
    message. The output will be the same as in *Step 5* – an empty content page. Upon
    refresh, the route is triggered without any `content` `params` passed, unlike
    when the user clicked on a specific link, and the `params` passed previously were
    not saved or cached. Hence there is no content.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will learn how to intercept the navigation flow
    and solve this problem with **Router Hooks**.
  prefs: []
  type: TYPE_NORMAL
- en: Router Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The general flow of route navigation is described in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.23: Navigation resolution flow diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.23: Navigation resolution flow diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once navigation is triggered on a certain route, Vue Router provides several
    primary navigation guards, or Hooks, for developers to guard or intercept that
    navigation process. These guards can be hooked either globally or in the component,
    depending on the type. Some examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Globally: `beforeEach`, `beforeResolve`, and `afterEach`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Per component: `beforeEnter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In-component: `beforeRouteUpdate`, `beforeRouteEnter`, and `beforeRouterLeave`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As seen in *Figure 6.23*, navigation is considered completed only after all
    the Hooks or guards have been resolved, including any asynchronous guard. Now,
    let's see how to set up `beforeEach` Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up beforeEach Hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`beforeEach` is a global Hook and is called at the very beginning of navigation,
    `beforeRouteLeave` of the previous view component). It should be defined as a
    global method of the `router` instance during initialization in the `index.js`
    file and takes the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, `beforeEachCallback` is a `hook` function that receives
    three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we could write this directly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we want to display a different page to display a generic message
    whenever a user navigates to `About` without a param value for the user, we can
    hook `beforeEach` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, we check if the destination route is `about` and if it doesn't have any
    additional params passed, nor any value for the `user` param passed, we will navigate
    to an `error` route instead. Otherwise, just proceed as normal with `next()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`next()` is required to be called `if` and once for `else`), or else there
    will be errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We still need to create an `error` page with an `Error.vue` view component
    that displays a simple message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, make sure to register the path accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `Home` view, after clicking on the `About` link, the app will render
    the `Error` page instead of the `About` page as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.24: Error page displayed when About is clicked without any param
    passed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.24: Error page displayed when About is clicked without any param passed'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s go to the `App.vue` file and assign the `to` prop to bind to an
    `{ name: ''about'', params: { user: ''Adam'' }}` object instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s navigate back to our app''s `Home` page and click on the `About` link.
    Since we have a proper `params` passed, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.25: About page displayed when there is a user passed in the params'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.25: About page displayed when there is a user passed in the params'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, from now on, every time we refresh the `About` page, we will get redirected
    to the `Error` page instead since there is no `user` param passed on refreshing.
  prefs: []
  type: TYPE_NORMAL
- en: We shall now look at a few key distinguishing points between the `beforeEach`
    and `beforeResolve` Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Differentiating Between the beforeEach and beforeResolve Hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also register the global Hook with `beforeResolve` with the same syntax.
    However, unlike `beforeEach`, which is triggered at the creation phase of navigation,
    `beforeResolve` will be triggered just before the navigation is carried out and
    confirmed, **after all the Hooks (both global and in-component) are resolved**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The output results will remain the same as in *Figure 6.25*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.26: About page displayed when there is a user passed in the params'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.26: About page displayed when there is a user passed in the params'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at the `afterEach` Hook in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The afterEach Hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `afterEach()` Hook is the last global navigation guard to be triggered after
    the navigation is confirmed (which means after `beforeResolve()`). Unlike the
    other global guards, the Hook function to pass to `afterEach()` does not receive
    a `next` function, hence it won't affect the navigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the `to` and `from` parameters are read-only `Route` objects.
    Hence the best use case for `afterEach` is to save data such as the last visited
    `Route` object for a `Back` button, the passed `params` of the `route` destination,
    or page view tracking. For example, we can have a default value of `user`, assign
    it, and save it whenever needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in the `App.js` file, instead of `Adam`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change it to `Alex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The output now when clicking on the `About` link is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.27: About page displaying the new user''s name – Alex'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.27: About page displaying the new user''s name – Alex'
  prefs: []
  type: TYPE_NORMAL
- en: 'But on reload, the `About` page renders with the default user – `Adam` – instead
    since there is a user passed to the `params`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.28: About page displaying the default user value on reload – Adam'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.28: About page displaying the default user value on reload – Adam'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at the `afterEach` Hook. We used the `afterEach`
    Hook to pass data through to the `about` page without having to have that data
    contained in the URL. This same technique can be used for updating other behavior
    such as the desired target page when pressing the `back` button.
  prefs: []
  type: TYPE_NORMAL
- en: Personalizing Hooks per Route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of defining a global Hook, which can cause unseen bugs and requires
    a route check, we can define a `beforeEnter` guard directly in the targeted route''s
    configuration object, for example, our `About` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'With this approach, both on reload and on clicking a link to navigate to the
    `About` page, the output is now consistent, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.29: About page rendered with the user value Adam'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.29: About page rendered with the user value Adam'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: With `beforeEnter()`, `to` is write-able and you will have access to `this`
    (which points to the specific route – `About`). It will only be triggered when
    users trigger navigation to the `About` page.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at the different router Hooks available in Vue, including
    `beforeEach`, `beforeResolve`, and `afterEach`. We saw how each of these Hooks
    is called at a different point in the routing process. As a practical example,
    we looked at a route that, if not provided a parameter, instead directs the user
    to an error page. These Hooks can be very useful especially when setting up an
    authenticated route. In the next section, we'll look at setting up in-component
    Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up in-Component Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we can also use in-component Hooks as component life cycle Hooks where
    we want to scope those Hooks to component-level for better code maintenance or
    enhance the workflow where the same component needs to behave differently in a
    certain use case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can have the `About` component now with the `beforeRouteEnter()` Hook defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we don't have access to the `this` scope of the component during
    `beforeRouteEnter`, because the view component is still being created at the moment
    of triggering. Luckily, we can access the instance through a callback passed to
    `next()`. Whenever the navigation is confirmed, which means the component is created,
    the callback will be triggered, and the component instance will be available as
    the sole argument (`comp`) of the callback.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For `beforeRouteUpdate` and `beforeRouteLeave`, the component has been created,
    hence this instance is available and there won't be a need for a callback for
    `next()`. In fact, a callback function is only supported in `next()` within the
    use of `beforeRouteEnter()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`beforeRouteUpdate` is called when the same component is reused for a different
    route. This applies when we use dynamic routing, which will be discussed in the
    next section.'
  prefs: []
  type: TYPE_NORMAL
- en: '`beforeRouteLeave` is triggered when the component is going to be deactivated
    or before the user navigates away from the current view. This is called right
    before the `beforeEach` guard of the new navigation and is usually used in editor
    components to prevent users from navigating away without saving.'
  prefs: []
  type: TYPE_NORMAL
- en: In this guard, we can cancel the new navigation by passing `false` to the `next()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine that we add the following Hook to the component''s option
    in the `About.vue` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'When we navigate away from the `About` page, a pop-up dialog will appear asking
    for confirmation as shown in the following screenshot and then continue navigating accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.30: Dialog asking to confirm before navigating away from the About
    page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.30: Dialog asking to confirm before navigating away from the About
    page'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at setting up in-component Hooks, that is, Hooks
    that are scoped to specific components. We set up an in-component Hook for our
    `About` component that asks a user to confirm before leaving the page. In the
    next section, we will move our message list into an external file to be loaded
    only when `MessageFeed` is in view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.04: Extracting a Messages List to an External File and Loading It
    Only When MessageFeed Is in View'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Going back to *Exercise 6.03*, *Passing the Content of the Selected Message
    to a New Message Page and Having It Printed Out*, now we will do a bit of code
    enhancement using the `beforeEnter` and `beforeRouteEnter` router hooks. This
    exercise is meant to make you more familiar with using router hooks.
  prefs: []
  type: TYPE_NORMAL
- en: To access the code files for this exercise, refer to [https://packt.live/3lg1F2R](https://packt.live/3lg1F2R).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extract the `messages` static data from `./src/views/MessageFeed.vue`
    and save it in `./src/assets/messages.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `./src/views/MessageFeed.vue`, we will replace the local data property with
    `props: { messages: { type: String, default: [] }}`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to load the list of `messages` and assign it to the `messages`
    `params` upon navigation to the `messages` route. We will do this by using the
    `beforeEnter` Hook in the route''s configuration object. Don''t forget to add
    `props: true` to normalize the `params` into related `props` for rendering. You
    can do that by modifying your `route` defined in `src/router/index.js` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will lazy-load the list of messages with `import`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, retrieve the needed information as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The full code for the route in `src/router/index.js` should be the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When viewing the website, we should see a message feed similar to that of the
    last exercise. This is shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.31: Message Feed page after refactoring'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_06_31.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.31: Message Feed page after refactoring'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have learned and practiced how to configure routers, pass
    parameters, and intercept navigation between pages in the application using different
    routing Hooks. In the next section, we are going to look at a more advanced topic
    – **dynamic routing**.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If there is a lot of data that follows the same format, such as a list of users,
    or a list of messages, and it's required to create a page for each of them, we
    need to use a routing pattern. With a routing pattern, we can create a new route
    dynamically from the same component based on some additional information. For
    example, we want to render the `User` view component for every user but with different
    `id` values. Vue Router provides us with the ability to use dynamic segments denoted
    by a colon (`:`) to achieve dynamic routing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using `params`, which doesn''t persist its value on refresh or appear
    in the URL, we define the required `params` directly in the path as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `:id` means the `params` here are not static. When the
    route matches the given pattern, Vue Router will render the corresponding component
    with the appropriate content, while keeping the URL as it should be. And the value
    of `:id` will be exposed as this `$route.params.id` in that view component''s
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: When users select URLs such as `/user/1` and `/user/2` (`./src/App.vue`), Vue
    will automatically generate sub-pages using our template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigation paths will be mapped to the same route pattern and component, but
    with different information, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.32: Navigate to /user/2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.32: Navigate to /user/2'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on `User 1`, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.33: Navigate to /user/1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.33: Navigate to /user/1'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also normalize `id` to the `props` of the `User` component with `props:
    true` and combine it with `beforeRouteEnter()` to load data of the selected user
    before the instance is created and rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can adjust `<template>` to print out the details of the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The output when selecting `/user/1` will now be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.34: Navigate to /user/1 with updated UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.34: Navigate to /user/1 with updated UI'
  prefs: []
  type: TYPE_NORMAL
- en: 'And if we are in the `user/:id` route and change the `:id` to another user,
    we need to update the local data accordingly since `beforeRouteEnter` will not
    be triggered again in this case. In fact, all the lifecycle Hooks of the components
    will not be called, as the component instance is not re-created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we looked at dynamic routing by setting up a route that extracts
    a parameter from the given URL. This technique allows you to create user-friendly
    URLs and pass information to routes dynamically. In the next section, we will
    look at catching error paths.
  prefs: []
  type: TYPE_NORMAL
- en: Catching Error Paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Other important routes that we always need to remember to handle besides the
    `Home` page ('`/`') include `error` routes, such as `404 Not found` when the URL
    path doesn't match any registered path, among others.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `404 Not found`, we can use the `regex` asterisk `*`, which stands for
    *matching everything* to collect all the cases that don''t match the routes. This
    router''s configuration should be located at the end of the array routes to avoid
    matching the wrong path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'When we type a wrong path for `/users`, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.35: Redirect to 404 when the ''/users'' path is not found'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_35.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.35: Redirect to 404 when the ''/users'' path is not found'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at how the `*` regex wildcard can be used to create
    a catch-all `404` page displayed to anyone that navigates to a non-existent route.
    Next, we will be implementing a message route that passes relevant data in the
    URL itself using a dynamic routing pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.05: Implementing a Message Route for Each Message with a Dynamic
    Routing Pattern'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Going back to our message feed in *Exercise 6.04*, *Extracting a Messages List
    to an External File and Loading Only When MessageFeed Is in View*, we will refactor
    our `Message` path to use routing patterns to dynamically navigate to a specific
    message path upon the user's selection. This will get you familiar with creating
    and maintaining dynamic routes in combination with other navigation Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: To access the code files for this exercise, refer to [https://packt.live/32sWogX](https://packt.live/32sWogX).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open `./src/router/index.js` and have the path configuration of the
    message route change to `/message/:id`, where `id` will be the index of that `message`
    in the list of messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now navigate to `./src/views/MessageFeed.vue` and change the `to` prop of `router-link`
    for each message to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s go back to `./src/router/index.js` and define `beforeEnter` as an asynchronous
    Hook for lazy-loading the content of the message into the content prop of our
    `Message` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the application using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When clicking on the first message in the `Message Feed`, the next page will
    be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.36: The page displayed when visiting the /message/0 path'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_06_36.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.36: The page displayed when visiting the /message/0 path'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to use dynamic routing, you can play around even
    further with more layers of routing patterns, such as `message/:id/author/:aid`.
    However, for such a case, we normally use a better approach, **nested routes**.
  prefs: []
  type: TYPE_NORMAL
- en: Nested Routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In reality, many applications are composed of components that consist of several
    multiple-level nested components. For example, `/user/settings/general` indicates
    that a general view is nested in the `settings` view and this `settings` view
    is nested within the `user` view. It represents the `General information` section
    of a user's settings page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, we want the URL to correspond to such a structure, as demonstrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.37: User with two nested views – Info and Extra'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_37.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.37: User with two nested views – Info and Extra'
  prefs: []
  type: TYPE_NORMAL
- en: Vue Router makes it easy to achieve this structure using `nested` route configurations
    and the `router-view` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the `User.vue` view in our previous example (located in `./src/views/`)
    and add a nested `router-view` component in the `<template>` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to start rendering components to this `router-view`, we will configure
    the `user` route to have the children option, which accepts an array of route
    configurations for the child routes. For our example, we''ll be adding an `info`
    and `extra` page for each user. These child routes will be accessed as `/user/:id/info`
    and `/user/:id/extra` giving each user a unique `info` and `extra` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Not all the nested paths need to start with `/` as their parent path, which
    will avoid them being treated as a root path and make things easier for Vue Router
    to compute the matching route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we will have to create two new views in the folder that will render
    all the information about a user based on the `id` received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We also create `UserExtra.vue`, which will render extra information (if there
    is any). In this example, it will render only simple text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The nested views are ready! Whenever the user clicks on the `Info` link, it
    will load the `UserInfo` view into it and update the URL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.38: User page with nested UserInfo view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_38.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.38: User page with nested UserInfo view'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user clicks on `Extra`, they will see the same as is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.39: User page with nested UserExtra view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_39.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.39: User page with nested UserExtra view'
  prefs: []
  type: TYPE_NORMAL
- en: In this section we looked at nested routes, that is, routes that have multiple
    children. In our example, the child routes were user info and user extra. This
    pattern allows us to create pages that extend their parent pages. In the preceding
    example, we can now make edits to the `About a user` header and have it take effect
    on all child routes. As projects grow, making use of this pattern will allow you
    to avoid having duplicate code across multiple views.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will use what we've learned so far to create navigation
    tabs for our message view component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.06: Building Navigation Tabs within the Message View'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will adapt the knowledge learned from the *Nested Routes* section to build
    a `Message` view from *Exercise 6.05*, *Implementing a Message Route for Each
    Message with a Dynamic Routing Pattern*.
  prefs: []
  type: TYPE_NORMAL
- en: To access the code files for this exercise, refer to [https://packt.live/2U9Bn6I](https://packt.live/2U9Bn6I).
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, let''s make some changes to our `messages` database in `src/assets/messages.js`
    by adding the following `author` and `sent` fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create a `MessageAuthor.vue` view that renders only the name
    of the creator of the message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we will create a `MessageInfo.vue` view that renders the `message.sent`
    value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we are done with the components, we need to register the new nested route
    under the children of the `message` route, inside our router at `src/router/index.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, in `Message.vue`, we will refactor the code to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And now we can navigate between the `Author` and `Info` tabs within a `Message`
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.40: Message page with Info selected'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_06_40.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.40: Message page with Info selected'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the application using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following when you select the `Author` option:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.41: Message page with Author selected'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_06_41.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.41: Message page with Author selected'
  prefs: []
  type: TYPE_NORMAL
- en: With this exercise, we have covered almost all the basic functionalities of
    Vue Router, especially on handling dynamic and nested routing. In the final section,
    we will go through how to create a reusable layout for view- templating our application.
  prefs: []
  type: TYPE_NORMAL
- en: Using Layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to implement layouts in a Vue.js application. One of them
    is using `slot` and creating a static wrapper layout component on top of `router-view`.
    Despite its flexibility, this approach results in a heavy performance cost, both
    in the unnecessary re-creation of the component and in the extra data-fetching
    required on every route change.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will discuss a better approach, which is to take advantage
    of the power of the dynamic component. The components are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `App.vue` file, we will change the default view generated by Vue CLI
    to only `<router-view>` and a wrapper around it. This wrapper is a dynamic component
    that will render whatever component is defined in the `layout` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, we will define `layout` in `data` to be the `default.vue` layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the `layouts` folder, we will create the `default` layout component
    with a simple header navigation, a `main` slot to render the actual content (which
    is whatever `<router-view>` renders), and a footer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Going back to our `App.vue` file, in order to make the layout `component` render
    in response to corresponding route changes, `router-view` should control which
    layout to render. In other words, `layout` should be updatable and decided by
    the view component rendered inside `router-view`. To achieve this, we will define
    the `currentLayout` property as synchronous with `layout` using `sync` on `<router-view>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'And upon creating an instance of the `Home.vue` component, we will emit an
    `update:currentLayout` event with the desired layout to be updated and rendered
    accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.42: Home page rendered with a layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_42.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.42: Home page rendered with a layout'
  prefs: []
  type: TYPE_NORMAL
- en: Since the `layout` component is not part of the `router-view` component, it
    will only re-render whenever the layout changes from within the view. This will
    maintain the performance of the app during user navigation.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at how the dynamic `component` component can be used
    to provide different layouts for different routes. This gives us the ability to
    have different common layouts, for example, one global menu for user-facing pages
    and another for admin pages, rendered based on the routes used. In the next section,
    we'll build on what we learned here by creating a message application with dynamic
    nested routing and layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 6.01: Creating a Message SPA with Dynamic, Nested Routing, and Layouts'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This activity aims to leverage your knowledge about Vue Router regarding registering
    routes and handling dynamic routes, nested routes, and route Hooks to create a
    **Message** **SPA**. This application will allow users to compose new messages,
    view a message feed, and navigate between messages to see their details:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `MessageEditor` view (at `src/views/MessageEditor.vue`) that will render
    a view with `textarea` to the user and a `submit` button to save the message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the `editor` route with `MessageEditor` as its view in `src/router/index.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `MessageList` view (at `src/views/MessageList.vue`) that will render
    a list of `message id` values wrapped by an `a` tag, which will direct to the
    single message page with the given `id` upon selection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the `list` route with `MessageList` as its view in `src/router/index.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Messages` view (at `src/views/Messages.vue`), which will render links
    to either `editor` or `list` as its nested routes and render the nested view accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user navigates away from `editor`, should some content not yet have
    been submitted, display a message asking if they want to save before navigating
    away. `Yes` will continue, `No` will abort the navigation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Message` view (at `src/views/Message.vue`), which will render message
    content from `props` and have a `back` button to go back to the previous view.
    By default, it should go to `messages`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the `Message` view with the dynamic route of `message/:id` in `src/router/index.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Improve the UI by creating two different simple layouts, one for `messages`
    (with the title only) and one for `message` (with both the `title` and the `back`
    button).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `/list` view that displays a feed of messages should look as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.43: The /list view in the Messages app'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_43.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.43: The /list view in the Messages app'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `/editor` view that allows the user to compose and send a new message looks
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.44: The /editor view in the Messages app'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_44.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.44: The /editor view in the Messages app'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `/message/:id` dynamic route (here, `/message/0` for a message with the
    `id` of `0`) in the `Message` app looks as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.45: The /message/0 view in the Message app'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_45.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.45: The /message/0 view in the Message app'
  prefs: []
  type: TYPE_NORMAL
- en: 'An alert will be displayed when the user tries to navigate away with an unsaved
    message as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.46: The /editor view when the user tries to navigate away with an
    unsaved message'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_46.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.46: The /editor view when the user tries to navigate away with an
    unsaved message'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor393).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we have learned about the most basic and useful functionalities
    offered by Vue Router for building routing for any Vue.js application in an effective
    and organized manner.
  prefs: []
  type: TYPE_NORMAL
- en: '`router-view` and `router-link` allow app developers to easily set up the navigation
    paths to their related views and maintain the SPA concept. The fact that they
    are Vue components themselves provides us as developers with the benefits of the
    Vue architecture, giving us flexibility in implementing nested views or layouts.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the route as an object with different properties simplifies the architecture
    process, including refactoring existing paths and adding a new route to the system.
    Using router parameters and patterns provides dynamic routing with reusable views
    and allows communication and data preservation between pages.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, with Hooks, we saw how we can intercept the navigation flow, setting
    up authentication where needed, redirecting to the desired path, or even loading
    and keeping some important data before the users land on the targeted page. There
    is an unlimited number of use cases where these Hooks can be extremely useful,
    such as when implementing a back button for instance.
  prefs: []
  type: TYPE_NORMAL
- en: With these, we are now capable of composing a Vue.js application with a proper
    navigation system for users to explore, while maintaining the data flow in every
    navigation use case (dynamic routes and nested views) and the application design layout.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you are going to explore how to apply transitions to the
    routing and different animations for beautiful loading effects for your Vue components
    and application.
  prefs: []
  type: TYPE_NORMAL
