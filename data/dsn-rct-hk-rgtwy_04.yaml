- en: '*Chapter 4*: Use State to Jumpstart Components'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第四章*：使用状态启动组件'
- en: In the previous chapter, we learned how *React* designs a *hook* infrastructure
    to provide the persistency of a function component. In this chapter, we will begin
    learning about the built-in hooks in *React*, starting with the `useState` hook.
    We will first explain how the concept of *state* is used in *React*, and then
    we will walk through the data structure and source code behind `useState` and
    describe some common use cases for changing states. We'll give `useState` a test
    drive, and at the end of the chapter, we'll provide two practical examples of
    applying `useState` to the `Avatar` and `Tooltip` components.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了*React*如何设计一个*hook*基础设施来提供函数组件的持久性。在本章中，我们将开始学习*React*中的内置钩子，从`useState`钩子开始。我们首先解释*状态*的概念在*React*中的使用，然后我们将遍历`useState`背后的数据结构和源代码，并描述一些更改状态的常见用例。我们将对`useState`进行测试，并在本章末尾提供两个将`useState`应用于`Avatar`和`Tooltip`组件的实际示例。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: State in React
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 中的状态
- en: '`useState` design'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useState` 设计'
- en: Dispatching states
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分派状态
- en: Test driving the `useState` hook
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试`useState`钩子
- en: '`useState` examples'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useState` 示例'
- en: Questions and answers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题与答案
- en: Appendix
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附录
- en: State in React
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 中的状态
- en: By now, you should have some idea of what a *state* is. To recap, a state is
    a piece of *memory* stored inside a fiber, introduced in [*Chapter 3*](B17963_03_Epub.xhtml#_idTextAnchor080)*,
    Hooking into React*. When combined with *props*, a state can represent a *UI*
    screen deterministically.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该对什么是*状态*有一些了解。为了回顾，状态是存储在纤维中的一部分*内存*，在[*第三章*](B17963_03_Epub.xhtml#_idTextAnchor080)*，*Hooking
    into React*中引入的。当与*属性*结合时，状态可以确定性地表示一个*UI*屏幕。
- en: '![Figure 4.1 – A fiber tree with a source fiber'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.1 – 包含源纤维的纤维树'
- en: '](img/Figure_4.01_B17963.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.01_B17963.jpg](img/Figure_4.01_B17963.jpg)'
- en: Figure 4.1 – A fiber tree with a source fiber
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 4.1 – 包含源纤维的纤维树
- en: For example, let's say we build a site and end up with a fiber tree (such as
    the one seen in *Figure 4.1)*. When a user makes an action (such as a click),
    the action sends a signal via an event handler to a fiber (the red dot in *Figure
    4.1*). We call this fiber a *source fiber*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们构建了一个网站，最终得到一个纤维树（如图*4.1*所示）。当用户进行操作（如点击）时，操作通过事件处理程序向纤维（如图*4.1*中的红色点）发送信号。我们称这个纤维为*源纤维*。
- en: Now, say the dispatched event changes a counter from `0` to `1`. *React* should
    schedule an update based on this user action and then prepare all of the **Document
    Object Model** (**DOM**) elements for the screen. Assuming the red lines are the
    fibers that need to be changed, how does React figure this out?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设派发的事件将计数器从`0`更改为`1`。*React*应根据此用户操作安排更新，并为屏幕准备所有**文档对象模型**(**DOM**)元素。假设红色线条是需要更改的纤维，React
    如何找出这一点？
- en: 'Upon receiving this update request, *React* goes through the fiber tree from
    the root. Quite a few fibers (shown as the gray lines) do not have anything to
    do with this update, so they are cloned from the previous scene. When the update
    arrives at the source fiber, let''s imagine the fiber carries a function component
    and invokes an update function called `updateFunctionComponent`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到此更新请求后，*React*从根开始遍历纤维树。相当多的纤维（显示为灰色线条）与此更新无关，因此它们是从上一场景克隆的。当更新到达源纤维时，让我们想象纤维携带一个函数组件并调用一个名为`updateFunctionComponent`的更新函数：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We introduced the first part of the `updateFunctionComponent` function in [*Chapter
    3*](B17963_03_Epub.xhtml#_idTextAnchor080), *Hooking into React*. The second part
    of this function takes the children that the `Component` function returns and
    converts them into fibers via `reconcileChildren`. At the end of the process,
    the first child fiber tells the engine what to work on next. This continues until
    all of the fibers under the source fiber are visited – that is, the red areas
    shown in *Figure 4.1*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第三章*](B17963_03_Epub.xhtml#_idTextAnchor080)，*Hooking into React*中介绍了`updateFunctionComponent`函数的第一部分。该函数的第二部分接受`Component`函数返回的子元素，并通过`reconcileChildren`将它们转换为纤维。在过程结束时，第一个子纤维告诉引擎下一步要做什么。这会一直持续到访问源纤维下的所有纤维——即*Figure
    4.1*中显示的红色区域。
- en: In this way, a state change propagates into the children fibers through that
    branch. When a parent gets updated, a child gets a new set of props before updating,
    thereby carrying the impact of the state. This is essentially how a state plays
    in the *React* ecosystem. Now, let's dive in and see how *React* creates the `useState`
    hook to support this behavior.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，状态变化通过该分支传播到子纤维中。当一个父组件更新时，子组件在更新之前会得到一组新的props，从而携带状态的影响。这就是状态在React生态系统中发挥作用的基本方式。现在，让我们深入探讨React是如何创建`useState`钩子来支持这种行为的。
- en: useState design
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`useState`设计'
- en: '*React* provides a `useState` hook to manage the state within function components.
    The following code example shows its common usage:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: React提供了一个`useState`钩子来管理函数组件内的状态。以下代码示例展示了它的常见用法：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `useState` function takes an `initialState` argument as the input argument
    and returns a `state` object and a `dispatch` function. The `dispatch` function
    can be used to request a state change into a `newState` *object*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState`函数接受一个`initialState`参数作为输入参数，并返回一个`state`对象和一个`dispatch`函数。`dispatch`函数可以用来请求将状态更改为`newState`
    *对象*。'
- en: Have you ever wondered how *React* designs the `useState` hook behind the scenes?
    Why does it return an array? How do we know if a new dispatch is successful or
    not? Most importantly, how can we be sure about the current state in each render?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经好奇过React在幕后是如何设计`useState`钩子的？为什么它返回一个数组？我们如何知道新的分发是否成功？最重要的是，我们如何确保每次渲染的当前状态？
- en: To answer these questions, we will open up the engine and take a look inside.
    We will read through a stripped-down version of the source code to gain a bird's-eye
    view of the architecture relating to this hook before we get into its various
    uses. Let's start with the data structure first.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这些问题，我们将打开引擎并查看其内部结构。在我们深入研究其各种用途之前，我们将阅读源代码的简化版本，以获得有关此钩子架构的鸟瞰图。让我们首先从数据结构开始。
- en: useState data structure
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`useState`数据结构'
- en: 'The data structure to make useState work includes a `Hook` type, a `Queue`
    type as well as an `Update` type, as shown in *Figure 4.2*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使`useState`工作所需的数据结构包括一个`Hook`类型、一个`Queue`类型以及一个`Update`类型，如图*4.2*所示：
- en: '![Figure 4.2 – The data structure of the useState hook'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 – useState钩子的数据结构'
- en: '](img/Figure_4.2_B17963.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.2_B17963.jpg)'
- en: Figure 4.2 – The data structure of the useState hook
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – useState钩子的数据结构
- en: A Hook uses a `state` property to store the state as well as a `next` property
    that points to the next hook. We have already explained this architecture in [*Chapter
    3*](B17963_03_Epub.xhtml#_idTextAnchor080), *Hooking into React*. What's new now
    is that in order to support the dispatch functionality, a `queue` property is
    added, where it provides a `dispatch` function to dispatch an `action` object
    with a new state. Within the queue, a list of updates is stored under a property
    called `pending`. The job of the queue is to maintain a list of pending updates
    to this fiber – this way, a user can dispatch multiple updates to the fiber.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个钩子使用一个`state`属性来存储状态，以及一个指向下一个钩子的`next`属性。我们已经在[*第三章*](B17963_03_Epub.xhtml#_idTextAnchor080)，“React中的钩子”中解释了这种架构。现在新的地方是，为了支持分发功能，添加了一个`queue`属性，其中它提供了一个`dispatch`函数来分发一个带有新状态的`action`对象。在队列中，一系列更新存储在一个名为`pending`的属性下。队列的职责是维护一个待处理的更新列表，以便于这个纤维——这样，用户就可以向纤维分发多个更新。
- en: An update is defined to hold an `action` function that needs to be provided
    by the user to calculate the next state. Each update is linked to another update
    via a property called `next` to form a circular linked list (see *Figure 4.3)*.
    The linked list is similar to how hooks are linked, except updates are linked
    in a circle, where the last update always points to the first update.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 更新被定义为包含一个需要由用户提供的`action`函数，以计算下一个状态。每个更新通过一个名为`next`的属性链接到另一个更新，形成一个循环链表（见图4.3）。链表类似于钩子的链接方式，除了更新是环形链接的，最后一个更新始终指向第一个更新。
- en: '![Figure 4.3 – A hook''s queue with its pending updates'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3 – 钩子的队列及其待处理的更新'
- en: '](img/Figure_4.03_B17963.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.03_B17963.jpg)'
- en: Figure 4.3 – A hook's queue with its pending updates
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 钩子的队列及其待处理的更新
- en: In the preceding figure, there are three updates in the queue with `pending
    property` points to the last one making `pending.next` point to the first update
    of the list. This circular list becomes handy when we need to insert or remove
    updates at the head or tail of the list.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，队列中有三个更新，`pending property`指向最后一个，使`pending.next`指向列表的第一个更新。当我们需要在大脑或尾部插入或删除更新时，这个循环列表变得很有用。
- en: Now that we have seen the data structure of `useState`, it's time for us to
    go over the source code and see how this data structure is utilized in the implementation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了`useState`的数据结构，是时候查看源代码，看看这个数据结构是如何在实现中使用的。
- en: 'The source code of `useState` is structured in a typical *hook* way in that
    it takes a path of either `mountState` or `updateState`, depending on if the fiber
    is under `mount` or `update` (as explained in [*Chapter 3*](B17963_03_Epub.xhtml#_idTextAnchor080),
    *Hooking into React*):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState`的源代码以典型的*hook*方式结构化，它根据纤维是否处于`mount`或`update`状态（如[*第3章*](B17963_03_Epub.xhtml#_idTextAnchor080)，*React中的钩子*）来接受`mountState`或`updateState`路径：'
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Mounting a state
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挂载状态
- en: 'When a component is under `mount`, the `mountState` gets a hook by creating
    one:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个组件处于`mount`状态时，`mountState`通过创建一个钩子来获取钩子：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, it starts to perform the initialization work of the hook. Depending on
    the form in which the `initialState` object is provided, it can initialize the
    hook''s `state` object with a value or a function:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它开始执行钩子的初始化工作。根据提供的`initialState`对象的形式，它可以使用值或函数初始化钩子的`state`对象：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After initializing the state, it creates an empty `queue` object with no pending
    update. Moreover, it sets up a `dispatch` function and stores it under the `queue`
    object. Let's have a close look at this function, as it's one of the crucial parts
    of the `useState` hook.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化状态后，它创建一个空的`queue`对象，没有挂起的更新。此外，它设置一个`dispatch`函数并将其存储在`queue`对象下。让我们仔细看看这个函数，因为它是`useState`钩子的重要部分之一。
- en: Dispatching an action
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分发一个动作
- en: The `dispatch` function is designed to dispatch an action with a new state.
    It's created with the help of a utility function, `dispatchAction`, which takes
    a fiber, a queue, and an action.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispatch`函数被设计用来分发一个带有新状态的动作。它是通过一个实用函数`dispatchAction`创建的，该函数接受一个纤维、一个队列和一个动作。'
- en: 'Upon assigning the `dispatchAction` function to the queue, it binds the updating
    fiber and the queue so that the `dispatch` function can accept the `action` object
    as the only input argument:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`dispatchAction`函数分配给队列后，它将更新纤维和队列绑定在一起，这样`dispatch`函数就可以接受`action`对象作为唯一的输入参数：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The function takes an `action` object from its input argument then creates a
    new `update` object and appends this to the `queue` object. The preceding code
    relating to `pending` are all list operations, all of which append the `update`
    object to the end of the list while making sure the queue continues to form a
    circular linked list, as illustrated in *Figure 4.3*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数从输入参数中获取一个`action`对象，然后创建一个新的`update`对象并将其追加到`queue`对象中。前面的与`pending`相关的代码都是列表操作，所有这些都将`update`对象追加到列表的末尾，同时确保队列继续形成一个循环链表，如图*4.3*所示。
- en: 'An `action` object can be in the form of a value or a functional updater, exactly
    as the `initialState` object is, thereby supporting both formats when we invoke
    the `dispatch` object. This is shown in the following example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`action`对象可以是值或函数更新器，正如`initialState`对象一样，因此在我们调用`dispatch`对象时支持这两种格式。以下是一个示例：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After the queue is updated, it requests an update through a `scheduleUpdateOnFiber`
    function that essentially kicks *React* into the update process we introduced
    at the beginning of this chapter. This is the main pathway for how *React* handles
    a user action.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在队列更新后，它通过一个`scheduleUpdateOnFiber`函数请求更新，这个函数本质上会将*React*启动到我们在本章开头介绍的更新过程中。这是*React*处理用户动作的主要途径。
- en: '*React* comes with lots of optimizations inside the engine. Some of these are
    not publicly accessible because they are part of the engine code. For example,
    there is a hidden pathway where the dispatch or the entire update can be canceled
    without invoking the `scheduleUpdateOnFiber` function. If you are interested,
    you can find out more about this pathway in the *Appendix A – Skipping the dispatch*
    section at the end of this chapter.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*React*在引擎内部有很多优化。其中一些不是公开可访问的，因为它们是引擎代码的一部分。例如，有一个隐藏的路径，可以在不调用`scheduleUpdateOnFiber`函数的情况下取消分发或整个更新。如果你感兴趣，你可以在本章末尾的*附录A
    – 跳过分发*部分找到更多关于这个路径的信息。'
- en: Updating a state
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新状态
- en: 'After the component is mounted, the next time it gets updated and reaches to
    the `useState` hook, it goes into `updateState` and gets a hook by cloning one:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 组件挂载后，下一次它被更新并到达`useState`钩子时，它会进入`updateState`并通过克隆一个钩子来获取：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once we have the hook, we can check if it gets any pending updates under the
    `queue.pending` object. The reason the `pending` object can have any update is
    that the `dispatch` function has been previously invoked. It goes through the
    first `pending.next` updates and iterates through them following the `update.next`
    update. For each update, it takes the stored `action` object and applies it to
    the previous stored state to form a `newState` object that gets stored back to
    the hook in the end.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了钩子，我们可以在`queue.pending`对象下检查它是否有任何挂起的更新。`pending`对象可以有更新，是因为`dispatch`函数已经被调用过。它通过第一个`pending.next`更新，并按照`update.next`更新的顺序迭代它们。对于每个更新，它都会取存储的`action`对象并将其应用于之前存储的状态，形成一个`newState`对象，最后将其存储回钩子中。
- en: 'The updated `newState` object gets compared to the previous `state` object
    to determine if it changes:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的`newState`对象与之前的`state`对象进行比较，以确定是否发生变化：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If it turns out the `newState` object differs from the previous state, *React*
    sets a `didReceiveUpdate` flag, indicating whether the updating fiber contains
    any change. The reason why *React* uses a global flag here is that there can be
    lots of other hooks attached to this fiber, therefore, it has to wait until all
    of the hooks are processed before it can determine if the fiber should be updated
    or bailed out. If you are interested in the details of the bailing out process,
    please refer to the pathway in the *Appendix B – Bailing out an update* section
    at the end of this chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`newState`对象与之前的状态不同，*React*会设置一个`didReceiveUpdate`标志，指示更新纤维是否包含任何更改。*React*在这里使用全局标志的原因是，可以有很多其他钩子附加到这个纤维上，因此，它必须等待所有钩子处理完毕后，才能确定纤维是否应该更新或退出。如果您对退出过程的细节感兴趣，请参阅本章末尾的*附录B
    – 退出更新*部分的路径。
- en: Returning the hook
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回钩子
- en: 'For either the `mountState` or `updateState` function, the `state` and the
    `dispatch` function are returned:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`mountState`或`updateState`函数，返回`state`和`dispatch`函数：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'They are returned in an array with two elements. The array format used here
    is interesting, as we could have used another format, such as an object with keys:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 它们以包含两个元素的数组形式返回。这里使用的数组格式很有趣，因为我们本可以使用另一种格式，例如具有键的对象：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding key-value design would have worked as well. Instead, *React*
    decides to use an array due to one advantage that this has – that is, we don''t
    have to remember the key name when referencing any of the values. Here are some
    examples demonstrating this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的关键值设计同样可以工作。相反，*React*决定使用数组，因为这样做有一个优势——那就是我们不必记住键名来引用任何值。以下是一些演示这一点的例子：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we can rename the `state` and the `dispatch` functions using
    any name we want, as long as it fits logically at that moment. This becomes pretty
    handy practically.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以使用任何我们想要的名称来重命名`state`和`dispatch`函数，只要它在当时逻辑上合适即可。这在实际操作中非常方便。
- en: All in all, the `state` and `dispatch` functions are directly mapped to the
    `state` object and the `queue.dispatch` function from the underlying hook. If
    the state has not changed, it gets the previous state returned. The `dispatch`
    function is created during the mount and keeps the same function instance for
    all future updates.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，`state`和`dispatch`函数直接映射到底层钩子的`state`对象和`queue.dispatch`函数。如果状态没有变化，它返回之前的状态。`dispatch`函数在挂载期间创建，并保持所有未来更新的相同函数实例。
- en: A walkthrough of useState
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useState的流程解析
- en: We have just gone through all of the `useState` hook's code. Just to make you
    feel better, *React* contains five times the amount of code that we just showed.
    With the stripped-down version, it's easy to understand the key workflow as it
    relates to the problem it's designed to solve and what approach it takes. Let's
    take a look at the workflow sketch in *Figure 4.4*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚已经走过了`useState`钩子的所有代码。为了让您感觉更好，*React*包含的代码量是我们所展示的代码量的五倍。使用简化版，它很容易理解与它设计解决的问题相关的关键工作流程以及它采取的方法。让我们看看*图4.4*中的工作流程草图。
- en: '![Figure 4.4 – The useState hook workflow'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 – useState钩子工作流程'
- en: '](img/Figure_4.4_B17963.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 – useState钩子工作流程](img/Figure_4.4_B17963.jpg)'
- en: Figure 4.4 – The useState hook workflow
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – useState钩子工作流程
- en: Let's explain what we are seeing in *Figure 4.4*. In an update, as a `useState`
    hook is invoked, it first checks if it's under `mount` or `update`. If it's under
    the `mount`, it stores the `initialState`, creates a `dispatch` function, and
    then returns. If under the `update`, it checks for any `pending` updates and applies
    them to a new `state`. In both cases, `[state, dispatch]` is returned.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来解释一下我们在 *图 4.4* 中看到的内容。在更新过程中，当调用 `useState` 钩子时，它首先检查是否处于 `mount` 或 `update`
    状态。如果是 `mount` 状态，它将存储 `initialState`，创建一个 `dispatch` 函数，然后返回。如果是 `update` 状态，它将检查任何
    `pending` 更新并将它们应用到新的 `state` 上。在两种情况下，都返回 `[state, dispatch]`。
- en: When a `dispatch` function is invoked, it creates an update with the provided
    `action` object and appends it to the `pending` updates. Then, a request for a
    new update is scheduled to *React*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `dispatch` 函数时，它会创建一个带有提供的 `action` 对象的更新并将其附加到 `pending` 更新中。然后，将请求新的更新安排到
    *React*。
- en: It's important to note that the new update is the place where a `state` object
    is assigned. The purpose of the `dispatch` function is only to request a change,
    but *the real change does not apply until the next update*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，新的更新是分配 `state` 对象的地方。`dispatch` 函数的目的是仅请求更改，但 *真正的更改不会在下一个更新中应用*。
- en: Now that we have gone through the design behind `useState`, we can talk about
    how to dispatch states in general in the next section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 `useState` 背后的设计，我们就可以在下一节讨论如何一般性地分发状态。
- en: Dispatching states
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发状态
- en: 'In this chapter, we have learned that the `dispatch` function, provided by
    the `useState` hook, allows us to request a change of state any time we want to.
    The input argument that represents an action can be a string, a number, an object,
    an array, or any *JavaScript* expression:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到由 `useState` 钩子提供的 `dispatch` 函数允许我们在想要更改状态时进行请求。表示动作的输入参数可以是字符串、数字、对象、数组或任何
    *JavaScript* 表达式：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We know that, internally, the input argument supports a functional update format
    as well:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，内部输入参数也支持函数式更新格式：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The benefit of using a functional update format here is that it has an opportunity
    to read the previous state before making a move toward the next state. This sometimes
    becomes useful if you build a new state that requires an old state.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用函数式更新格式的优点是，它有机会在向下一个状态移动之前读取前一个状态。如果你构建的新状态需要旧状态，这有时会很有用。
- en: 'A dispatched state is compared with the current state before making a final
    call if it changes. This means that not all dispatches end up with a state change.
    Take the following code as an example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更改，在最终调用之前会将分发的状态与当前状态进行比较。这意味着并非所有分发的最终结果都会导致状态改变。以下代码可以作为例子：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If the state starts with its number as `1`, we can change the state to `3` with
    the first click. For later clicks, it can't change the number to `3` because it's
    already `3`. Therefore, upon multiple clicks, the changes taken are `1, 3`, instead
    of `1, 3, 3, …` – no matter how many times the user clicks. Let's take a look
    at how this comparison is performed in detail.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态以数字 `1` 开始，我们可以在第一次点击时将状态更改为 `3`。对于后续的点击，由于它已经是 `3`，因此无法将数字更改为 `3`。因此，在多次点击后，所做的更改是
    `1, 3`，而不是 `1, 3, 3, …` – 无论用户点击多少次。让我们详细看看这种比较是如何进行的。
- en: Comparing states
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较状态
- en: We mentioned earlier that *React* uses the `Object.is` function whenever it
    compares two states. This is a *JavaScript* native function, which is quite similar
    to the *JavaScript* strict equality operator (`===`) and is used to determine
    whether two values are the same value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，*React* 在比较两个状态时始终使用 `Object.is` 函数。这是一个 *JavaScript* 原生函数，与 *JavaScript*
    严格相等运算符 (`===`) 非常相似，用于确定两个值是否相同。
- en: 'For a primitive type, such as a number or a string, this comparison is straightforward:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原始类型，例如数字或字符串，这种比较是直接的：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It's not difficult to understand that comparing the numbers `1` and `1` should
    return `true` and comparing the two strings `Hello` and `World` should return
    `false`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 理解比较数字 `1` 和 `1` 应返回 `true` 以及比较两个字符串 `Hello` 和 `World` 应返回 `false` 并不难。
- en: '*JavaScript* comes with seven primitive data types: string, number, bigint,
    Boolean, undefined, symbol, and null. These data types *cannot* be altered once
    they are created in memory:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScript* 有七个原始数据类型：字符串、数字、BigInt、布尔值、undefined、symbol 和 null。这些数据类型 *一旦在内存中创建后就不能更改*：'
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A *primitive comparison* is something we commonly understand as a *comparison
    by value*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*原始比较* 是我们通常理解为 *按值比较* 的一种。'
- en: 'For a non-primitive type in *JavaScript*, such as an object or an array, a
    reference (also known as a pointer) is used to point to a particular memory space:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*JavaScript*中的非原始类型，例如对象或数组，使用引用（也称为指针）来指向特定的内存空间：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This means that if you allocate two new objects, they can''t point to the same
    memory space. Therefore, comparing the two objects `{}` and `{}` should return
    `false`, even if both contain exactly the same *content*. In contrast, comparing
    the same object (for example, `v` and `v`) should return `true`, no matter how
    the content of the object changes. Let''s take a look at an example to understand
    this better:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你分配了两个新的对象，它们不能指向相同的内存空间。因此，比较两个对象`{}`和`{}`应该返回`false`，即使它们包含完全相同的*内容*。相比之下，比较相同的对象（例如，`v`和`v`）应该返回`true`，无论对象的内容如何变化。让我们通过一个例子来更好地理解这一点：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Can you guess if the previous dispatch does anything upon a user click? The
    answer is *no*. Changing an object's content doesn't qualify as a change from
    the `Object.is` function's point of view, as the `v` variable still points to
    the same memory location, even when one of its properties has changed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到之前的派遣在用户点击时是否做了什么吗？答案是*没有*。从`Object.is`函数的角度来看，改变一个对象的内容并不算作变化，因为`v`变量仍然指向相同的内存位置，即使其中一个属性已经改变。
- en: 'The only way to cause a change in this case is to dispatch a state pointing
    to a different memory space, and we can do this by creating a new one:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，唯一引起变化的方法是派遣一个指向不同内存空间的状态，我们可以通过创建一个新的来做到这一点：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A new object is created with the help of JavaScript's `{ ...v }`) by cloning
    the content of `v` while changing the `abc` property to `3`. For readers who are
    interested in learning more about the *JavaScript* *ES6* *syntax*, please refer
    to the *JavaScript ES6* section of [*Chapter 10*](B17963_10_Epub.xhtml#_idTextAnchor363),
    *Building a Website with React*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过JavaScript的`{ ...v }`帮助创建一个新的对象，同时将`abc`属性更改为`3`，克隆`v`的内容。对于对学习更多关于*JavaScript*
    *ES6* *语法*感兴趣的读者，请参阅[*第10章*](B17963_10_Epub.xhtml#_idTextAnchor363)的*JavaScript
    ES6*部分，*使用React构建网站*。
- en: 'It might take some time to get used to using the `Object.is` function or the
    strict equality operator (`===`). A simple question to ask yourself is this: *is
    the value to compare mutable?* If it is, it''s compared by *reference*. If it''s
    not, it''s compared by *value*.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 适应使用`Object.is`函数或严格相等运算符（`===`）可能需要一些时间。你可以问自己一个简单的问题：*要比较的值是否可变？* 如果是，它通过*引用*进行比较。如果不是，它通过*值*进行比较。
- en: '*In React, if you can''t manage a value change, you can''t dispatch a change
    correctly*. So, it''s important to understand `object.is`, as it''s used extensively
    for all hook value comparisons, as you''ll see during the rest of this book.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在*React*中，如果你无法管理值的变化，你就不能正确地派遣变化。因此，理解`object.is`非常重要，因为它被广泛用于所有钩子值比较，正如你在本书的其余部分将看到的那样。
- en: Multiple dispatches
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多次派遣
- en: 'An interesting case arises when we perform multiple dispatches inside of one
    event handler. In *React,* multiple dispatches in a row are designed to be processed
    together, as in the following example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在一个事件处理器内部执行多次派遣时，会出现一个有趣的情况。在*React*中，连续的多次派遣被设计成一起处理，如下面的例子所示：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Upon the user clicking, if we invoke the dispatch (P-Code) function twice, it
    would only cause one change in the end because each dispatch appends an update
    to the queue. When we reach the next update, all registered actions in the queue
    are iterated to form a single new state. In our case, the state changes from `1`
    to `5`, skipping `3`. But why do two dispatches trigger only one update? Doesn't
    each dispatch invoke the `scheduleUpdateOnFiber` function?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击时，如果我们两次调用派遣（P-Code）函数，最终只会引起一个变化，因为每次派遣都会将一个更新添加到队列中。当我们达到下一次更新时，队列中所有注册的动作都会被迭代以形成一个单一的新状态。在我们的例子中，状态从`1`变为`5`，跳过了`3`。但为什么两个派遣只触发一个更新？难道每个派遣没有调用`scheduleUpdateOnFiber`函数吗？
- en: Each dispatch does invoke `scheduleUpdateOnFiber` to kick *React* into the update
    process. However, this function is designed in such a way that it waits for all
    dispatches from the same action before making a final update. Therefore, with
    this functionality, multiple dispatches can be joined into one update operation
    as a deferred run.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每次派遣都会调用`scheduleUpdateOnFiber`来启动*React*的更新过程。然而，这个函数被设计成这样的方式，它在做出最终更新之前会等待来自同一动作的所有派遣。因此，使用这个功能，多个派遣可以被合并为一个更新操作，作为一个延迟执行。
- en: A benefit of this is that you can write a `dispatch` statement as easily as
    an assignment statement without worrying that it might bring unnecessary work
    to the DOM. This is not only practically easy to use but also makes the update
    pretty performant.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个好处是，你可以像写赋值语句一样轻松地写一个`dispatch`语句，而不必担心它可能会给DOM带来不必要的操作。这不仅在实际使用中很方便，而且使更新非常高效。
- en: Now that we have gone over the `dispatch` function, we can put the `useState`
    hook to use.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`dispatch`函数，我们可以开始使用`useState`钩子。
- en: Test driving the useState hook
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动useState钩子
- en: A state is one of the most common techniques in *React* for driving user interactions.
    Let's consider a component with a button. Each time we click the button, it increments
    a number and appends it to the `Hello World` string (see *Figure 4.5*).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是*React*中驱动用户交互的最常见技术之一。让我们考虑一个带有按钮的组件。每次我们点击按钮时，它都会增加一个数字并将其附加到`Hello World`字符串上（见图*图4.5*）。
- en: '![Figure 4.5 – The Hello World counter'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5 – Hello World计数器'
- en: '](img/Figure_4.05_B17963.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.05_B17963.jpg)'
- en: Figure 4.5 – The Hello World counter
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – Hello World计数器
- en: 'We can capture this *UI* behavior in a `Title` component:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`Title`组件中捕获这种行为：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we use `[count, setCount]` to keep track of the `count` state. Then, we
    display `count` in the `h1` element of the page and dispatch `setCount` in the
    click handler of the `button` element. Each time the button is clicked, it should
    increment the `count` value.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`[count, setCount]`来跟踪`count`状态。然后，我们在页面的`h1`元素中显示`count`，并在`button`元素的点击处理程序中调用`setCount`。每次点击按钮时，它应该增加`count`值。
- en: 'In order to confirm what happened under the hood, let''s add `console.log`
    to two locations:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认底层发生了什么，让我们在两个位置添加`console.log`：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The first one is placed after `setCount` to confirm what the `count` value
    is after each dispatch. The second one is placed before the `return` statement
    so that we can confirm when an update has arrived and what the `count` value is
    in that update. They are marked at `➀` and `➁`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个放在`setCount`之后，以确认每次`dispatch`后的`count`值。第二个放在`return`语句之前，以便我们可以确认更新何时到达以及在那个更新中`count`值是多少。它们标记为`➀`和`➁`：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: From the `updated` series at `➁`, the number is incremented by`1` from the `clicked`
    series at `➀`. The `count` value started at `0` during the mount, and with each
    click, it quickly gets to a new update with an updated number, as shown in *Figure
    4.6*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从`➁`版本的`updated`系列开始，数字从`➀`版本的`clicked`系列增加`1`。在挂载期间，`count`值从`0`开始，每次点击后，它都会快速更新到一个新的带有更新数字的状态，如图*图4.6*所示。
- en: The `clicked` series at `➀` confirms that the `count` value doesn't get updated
    to the new `count + 1` value after the dispatch. Instead, it continues to hold
    the current state in the update where the `onClick` object is defined.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`➀`版本的`clicked`系列确认在`dispatch`之后，`count`值不会更新到新的`count + 1`值。相反，它继续保留在定义`onClick`对象的更新中的当前状态。'
- en: '![Figure 4.6 – The Hello World counter'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6 – Hello World计数器'
- en: '](img/Figure_4.06_B17963.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.06_B17963.jpg)'
- en: Figure 4.6 – The Hello World counter
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – Hello World计数器
- en: Great! This is how we use `useState` in general. Let's take a look at another
    popular use of `useState`, which is to install it in a parent component and allow
    the child component to drive it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！这就是我们通常使用`useState`的方式。让我们看看`useState`的另一个流行用法，即在父组件中安装它并允许子组件驱动它。
- en: Letting a child drive
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让孩子开车
- en: 'It''s very common to send a `dispatch` function from a parent component to
    a child component and expect the child to request the state change from the parent:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从父组件向子组件发送`dispatch`函数并期望子组件从父组件请求状态变化是非常常见的：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding example, the `Title` component has a button, and when it is
    clicked, it changes the `count` state in the `App` component. We will set up two
    `console.log` statements to confirm the updates:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`Title`组件有一个按钮，当它被点击时，它会改变`App`组件中的`count`状态。我们将设置两个`console.log`语句来确认更新：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It's working as expected – the clicks come from the child, but everything else
    is the same as the previous example. Basically, we have given the child the ability
    to change the `count` value created at the parent level.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 它按预期工作 – 点击来自子组件，但其他一切与上一个例子相同。基本上，我们已经赋予了子组件改变在父级创建的`count`值的能力。
- en: This is actually quite handy. It tells us that no matter where we define the
    state, if its child (or grandchild) needs it, it can access it via a prop. This
    includes the state and the capability of changing the state. This is one of the
    most effective strategies for using state in *React* and we call it *lifting up*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上非常方便。它告诉我们，无论我们在哪里定义状态，如果其子组件（或孙组件）需要它，它都可以通过 prop 访问它。这包括状态和改变状态的能力。这是在
    *React* 中使用状态的最有效策略之一，我们称之为 *提升*。
- en: Lifting up to the parent
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向父组件提升
- en: Due to its design, *React* doesn't allow information to be sent to an element
    directly. Instead, the required mechanism is to use a *prop* that passes the information
    from a parent to a child, then to a child's child, and so on.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其设计，*React* 不允许直接将信息发送到元素。相反，所需的机制是使用一个 *prop*，将信息从父组件传递到子组件，然后到子组件的子组件，依此类推。
- en: 'In another way, to share information between two children, the information
    needs to be available to the parent first before sending it to each of the children:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，为了在两个子组件之间共享信息，信息需要首先对父组件可用，然后再发送给每个子组件：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding setup, we have a parent, `App`, rendering two children, `Title`
    and `Content`. The `count` object installed in the `Title` object can''t be accessed
    by either its sibling, `Content`, or its parent, `App`. So, to make the `count`
    object available to access, we need to relocate the `count` object to `App`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的设置中，我们有一个父组件 `App`，渲染两个子组件 `Title` 和 `Content`。安装到 `Title` 对象中的 `count`
    对象不能被其兄弟组件 `Content` 或其父组件 `App` 访问。因此，为了使 `count` 对象可访问，我们需要将 `count` 对象移到 `App`：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding code, `useState` is declared in `App`, therefore, we can send
    the `onClick` object to `Title`, and we can send the `count` object to `Content`.
    Therefore, we can allow the sharing of things with a sibling by *lifting* those
    things to the parent. This highlights an important aspect of *React''s* design:
    *if your parent has it, you can have it*. This is one of the most basic and effective
    behaviors we rely on when designing a *React* app.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`useState` 在 `App` 中声明，因此我们可以将 `onClick` 对象发送到 `Title`，并将 `count` 对象发送到
    `Content`。因此，我们可以通过 *提升* 这些东西到父组件来允许与兄弟组件共享东西。这突出了 *React* 设计的一个重要方面：*如果你的父组件有它，你也可以有它*。这是我们设计
    *React* 应用时最基本和最有效的行为之一。
- en: Important Note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you are a *React* beginner, you should try to work with props as often as
    you can. Not only are they easy to understand, but they're also a way to make
    sure everything is wired up correctly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个 *React* 初学者，你应该尽可能多地尝试使用 props。它们不仅易于理解，而且也是确保一切连接正确的途径。
- en: Now that we have had a test drive of the `useState` hook, let's look at two
    more practical examples of how real applications use `useState` to drive *UI*
    behavior.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 `useState` 钩子进行了测试，让我们看看更多实际应用如何使用 `useState` 来驱动 *UI* 行为。
- en: useState examples
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useState 示例
- en: In this section, we are going to look at two examples of how the `useState`
    hook is applied in practice.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨两个示例，展示 `useState` 钩子在实践中的应用。
- en: Making an avatar component
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建头像组件
- en: Let's say you want to display an image of a person that you have pulled from
    the internet. Most of the time, it will turn out to be a good picture (see *Figure
    4.7*). But sometimes, an image can be unavailable to download due to network or
    permission issues. When this happens, the browser throws a broken icon (the logo
    in the middle of *Figure 4.7*), which is not as nice to look at. The latest UX
    research shows that if we replace any broken image icons with something more unique
    (such as a user's name or initials, as shown on the right of *Figure 4.7*), this
    improves the user experience.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想显示从互联网上获取的人物的图片。大多数情况下，它将是一张好图片（见 *Figure 4.7*）。但有时，由于网络或权限问题，图片可能无法下载。当这种情况发生时，浏览器会抛出一个损坏的图标（*Figure
    4.7* 中中间的标志），看起来并不那么美观。最新的用户体验研究显示，如果我们用更独特的东西（如 *Figure 4.7* 右侧所示的用户名或首字母）替换任何损坏的图像图标，这将提高用户体验。
- en: '![Figure 4.7 – An avatar component using useState'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.7 – 使用 useState 的头像组件'
- en: '](img/Figure_4.07_B17963.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.07_B17963.jpg](img/Figure_4.07_B17963.jpg)'
- en: Figure 4.7 – An avatar component using useState
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 4.7 – 使用 useState 的头像组件
- en: 'In order to switch between an image and text, we can apply `useState` to define
    a condition. We will also need an event handler to notify us when an image URL
    is broken. If we put this logic together, we get an `Avatar` component:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在图像和文本之间切换，我们可以使用 `useState` 来定义一个条件。我们还需要一个事件处理器来通知我们当图像 URL 损坏时。如果我们把这些逻辑组合起来，我们得到一个
    `Avatar` 组件：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code, first, we define a state, `error`, with `useState`. and
    then we set the initial state to `false`, assuming that there's no error before
    loading the image.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们使用`useState`定义了一个状态，`error`，并将其初始状态设置为`false`，假设在加载图像之前没有错误发生。
- en: 'In the component''s `return`, it follows this simple logic:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件的`return`中，它遵循以下简单逻辑：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If `error` is `true`, it will display `A`. Otherwise, it will display `B`. In
    our case, `A` will return the user's initials and `B` will return an image. Therefore,
    it initially displays the image. If the image loads successfully, the job is done.
    However, if the image happens to fail, it fires an `onError` event handler. In
    the `onError` event handler, it makes a dispatch to flip the `error` flag to `true`.
    In the next update, as the `error` flag changes to `true`, it displays the user's
    initials. So, the job is done – sweet!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`error`为`true`，它将显示`A`。否则，它将显示`B`。在我们的例子中，`A`将返回用户的首字母，而`B`将返回一个图像。因此，它最初显示图像。如果图像成功加载，任务就完成了。然而，如果图像加载失败，它将触发一个`onError`事件处理程序。在`onError`事件处理程序中，它将发送一个指令将`error`标志翻转为`true`。在下一次更新中，随着`error`标志变为`true`，它将显示用户的首字母。所以，任务完成了——太棒了！
- en: 'To make it easy to use, the `Avatar` component is built with two props, `src`
    and `username`, where the first prop is the image URL and the second prop is the
    username string. Here''s what the code looks like:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于使用，`Avatar`组件由两个属性构建，`src`和`username`，其中第一个属性是图像URL，第二个属性是用户名字符串。以下是代码的示例：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Playground – Avatar Component
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏场 – 头像组件
- en: Feel free to play with this example online at [https://codepen.io/windmaomao/pen/VwzaqEo](https://codepen.io/windmaomao/pen/VwzaqEo).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎在线尝试这个示例：[https://codepen.io/windmaomao/pen/VwzaqEo](https://codepen.io/windmaomao/pen/VwzaqEo)。
- en: The `AvatarStyle` component is a style component that allows us to write CSS
    inside of a component. If you are interested in learning more about this approach,
    please refer to the *Adopting CSS-in-JS approach* section in [*Chapter 10*](B17963_10_Epub.xhtml#_idTextAnchor363),
    *Building a Website with React,* for more details.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`AvatarStyle`组件是一个样式组件，它允许我们在组件内部编写CSS。如果你对这种方法感兴趣，请参阅[*第10章*](B17963_10_Epub.xhtml#_idTextAnchor363)中的*采用CSS-in-JS方法*部分，*使用React构建网站*，以获取更多详细信息。'
- en: Making a custom tooltip component
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义提示组件
- en: Here is another example of using `useState`. Say you have an avatar (you could
    borrow the one from the previous example), and when hovering over it, you'd like
    to see some tooltip text (as shown in *Figure 4.8*). This has to be a custom tooltip
    because we want it to allow a custom border, color, font, and even the inclusion
    of paragraphs. A browser's built-in tooltips won't provide these options in the
    `title` attribute.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用`useState`的另一个示例。假设你有一个头像（你可以从上一个示例中借用），当鼠标悬停在它上面时，你希望看到一些提示文本（如图*图4.8*所示）。这必须是一个自定义提示，因为我们希望它允许自定义边框、颜色、字体，甚至包括段落。浏览器的内置提示不会在`title`属性中提供这些选项。
- en: '![Figure 4.8 – A custom tooltip component using useState'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.8 – 使用useState的自定义提示组件'
- en: '](img/Figure_4.08_B17963.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.08_B17963.jpg)'
- en: Figure 4.8 – A custom tooltip component using useState
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – 使用useState的自定义提示组件
- en: 'In order to support this pop-up effect, we can use `useState` to set up a Boolean
    state to indicate when the mouse hovers over the avatar area. We also need both
    event handlers to monitor when the mouse enters or leaves the avatar area. We
    can put this logic into a `Tooltip` component:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这个弹出效果，我们可以使用`useState`设置一个布尔状态来指示鼠标是否悬停在头像区域上。我们还需要两个事件处理程序来监控鼠标进入或离开头像区域。我们可以将这个逻辑放入一个`Tooltip`组件中：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We define a state, `entered`, and set its initial value to `false` (as when
    we first see this component, the tooltip will not be visible). We wire `setEntered`
    to the `onMouseEnter` and `onMouseLeave` event handlers to flip the state.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个状态，`entered`，并将其初始值设置为`false`（因为我们第一次看到这个组件时，提示不会可见）。我们将`setEntered`连接到`onMouseEnter`和`onMouseLeave`事件处理程序以翻转状态。
- en: 'Notice that this time the `?` operator isn''t used for the conditional display
    of the tooltip – instead, a `&&` operator is used:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这次我们没有使用`?`运算符进行提示的条件显示，而是使用了`&&`运算符：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: That's because in `Tooltip`, there's no `B`. Depending on whether the mouse
    is in the right area or not, `A` is either displayed or hidden. Therefore, the
    `&&` operator is serving as a short circuit – if the condition isn't met, it skips
    the next statement.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在`Tooltip`中没有`B`。根据鼠标是否在正确区域，`A`将被显示或隐藏。因此，`&&`运算符充当短路——如果条件不满足，它将跳过下一个语句。
- en: 'The `Tooltip` component takes both `children` and `tooltip` as props, and this
    allows it to host any component as the `Avatar` object and any component as the
    tooltip content, as shown in the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tooltip`组件接受`children`和`tooltip`作为属性，这允许它托管任何组件作为`Avatar`对象，以及任何组件作为提示内容，如下面的代码所示：'
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code block, we define a custom `TooltipBox` component to pass
    in the `Tooltip` component via the `tooltip` prop.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们定义了一个自定义的`TooltipBox`组件，通过`tooltip`属性传入`Tooltip`组件。
- en: Playground – Tooltip Component
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 - 提示组件
- en: Feel free to play with this example online at [https://codepen.io/windmaomao/pen/qBXZvKV](https://codepen.io/windmaomao/pen/qBXZvKV).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自由地在这个示例上在线玩耍：[https://codepen.io/windmaomao/pen/qBXZvKV](https://codepen.io/windmaomao/pen/qBXZvKV)。
- en: This is the best part of the `Tooltip` component. It's not just designed as
    a component to suit the needs for one use case – instead, it's designed to be
    a mechanism that allows you to craft flexible tooltip behavior.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Tooltip`组件的最好部分。它不仅仅被设计为一个满足单一用例需求的组件——相反，它被设计为一个机制，允许你构建灵活的提示行为。
- en: With `useState`, we can tailor our function components to be stateful engines,
    making it possible to handle a range of user interactions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`useState`，我们可以定制我们的函数组件成为有状态的引擎，使得处理各种用户交互成为可能。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned what the concept of *state* is in *React*. You
    dug deeper into the `useState` design, which is divided into mounting a state
    and updating a state. We learned about various ways of dispatching states and
    ways to determine if a state has changed. Then, we also learned that a dispatch
    can support a value format or a functional updater format, and we learned that
    we can dispatch multiple times in one event handler. Then, we took `useState`
    for a test drive and learned how to send the state change to a child component
    via props. We also learned a common technique called *lifting up*, which involves
    lifting a state up to a parent. Last but not least, we designed two components
    – an avatar component and a tooltip component – to learn how to apply `useState`
    in the design of components.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了在*React*中*状态*的概念。你深入了解了`useState`的设计，它分为挂载状态和更新状态。我们学习了各种分发状态的方法以及确定状态是否改变的方法。然后，我们还了解到分发可以支持值格式或函数更新器格式，并且我们了解到我们可以在一个事件处理器中多次分发。然后，我们测试了`useState`，学习了如何通过属性将状态变化发送到子组件。我们还学习了一种称为*提升*的常见技术，它涉及将状态提升到父组件。最后但同样重要的是，我们设计了两个组件——头像组件和提示组件——来学习如何在组件设计中应用`useState`。
- en: In the next chapter, we will explore our second hook in the *React* family.
    We will also see how *React* defines an action called **effect** and allows you
    to invoke it after a state change.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索*React*家族中的第二个钩子。我们还将看到*React*如何定义一个称为**effect**的动作，并允许你在状态变化后调用它。
- en: Questions and answers
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题和答案
- en: 'Here are some questions and answers to refresh your knowledge:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些问题和答案来刷新你的知识：
- en: What is `useState`?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是`useState`？
- en: The `useState` hook is a built-in hook in *React* that allows you to define
    a state within a functional component and dispatch an action to change it.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`useState`钩子是*React*中的一个内置钩子，它允许你在函数组件中定义状态并分发一个动作来改变它。'
- en: What is the most common use of `useState`?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useState`最常用的用途是什么？'
- en: The `useState` hook is probably the most common hook in the *React* hook family.
    Whenever you need a variable to change *UI* elements, you can normally resort
    to `useState` to accomplish this. Touching a widget, clicking a vote-up button,
    hovering over an icon, toggling a checkbox, and much more can be implemented with
    the use of `useState`.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`useState`钩子可能是*React*钩子家族中最常见的钩子。无论何时你需要一个变量来改变*UI*元素，你通常都可以求助于`useState`来完成这个任务。触摸小部件、点击点赞按钮、悬停在图标上、切换复选框等等，都可以使用`useState`来实现。'
- en: Appendix
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: Appendix A – Skipping the dispatch
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录A - 跳过分发
- en: 'We say that not all dispatched states end up with a change. But actually, not
    all dispatches end up with a successful dispatch. When a mouse clicks, it goes
    into the `dispatch` function. It has a special pathway, and when you hit that
    condition and find out there''s no state change, it can return early without performing
    a dispatch:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说并非所有分发的状态都会导致变化。但实际上，并非所有分发都会导致成功的分发。当鼠标点击时，它会进入`dispatch`函数。它有一个特殊的路径，当你满足那个条件并发现没有状态变化时，它可以提前返回而不执行分发：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding `dispatchAction` function, a new state is computed when it
    detects there's no work currently under the fiber. The way it calculates the `newState`
    value is similar to how the calculation in the `updateState` function works, except
    it only deals with one `action` object here. Basically, it asks if the action
    causes a state change from the last updated state.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`dispatchAction`函数中，当它检测到纤维下目前没有工作时要计算一个新的状态。它计算`newState`值的方式与`updateState`函数中的计算方式类似，只是这里只处理一个`action`对象。基本上，它询问这个动作是否导致从最后更新的状态中发生状态变化。
- en: If it turns out that there's no change, it returns without an update, pretending
    nothing happened. This results in no *UI* updates whatsoever. This pathway is
    important because it can come very often (for instance, when the user keeps performing
    the same action over and over again without any state change).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最终结果显示没有任何变化，它将不带更新返回，假装什么都没发生。这导致没有任何*UI*更新。这个路径很重要，因为它可能会非常频繁地发生（例如，当用户反复执行相同的操作而没有任何状态变化时）。
- en: Appendix B – Bailing out an update
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录B – 回退更新
- en: 'For any fiber that has been updated, there is a collective flag that is added
    to it called `didReceiveUpdate`, which indicates if a change has taken place for
    the fiber. After the work starts on the fiber, any hook that causes a change can
    set this flag to `true`. Afterward, if the work is done and if the flag is still
    `false`, that means there''s been absolutely no change for the fiber, so *React*
    bails out the fiber by cloning it from the previous scene and then moves on to
    the next fiber to work:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何已经更新的纤维，都会有一个集体标志被添加到它上面，称为`didReceiveUpdate`，它表示纤维是否发生了变化。在开始对纤维进行工作之后，任何导致变化的钩子都可以将这个标志设置为`true`。之后，如果工作完成且标志仍然是`false`，这意味着纤维绝对没有任何变化，所以*React*通过从上一个场景克隆它来回退纤维，然后继续处理下一个纤维：
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding `updateFunctionComponent` function, after the `Component` function
    is invoked, it checks two flags. One is `isFiberMounting`, as when the site is
    under mount, nothing can be bailed out since all of the fibers still need to be
    created. Another flag is `didReceiveUpdate`. When both are false, it kicks into
    the bailout of the fiber.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`updateFunctionComponent`函数中，在调用`Component`函数之后，它检查两个标志。一个是`isFiberMounting`，因为在站点处于挂载状态时，由于所有纤维仍然需要创建，所以无法进行回退。另一个标志是`didReceiveUpdate`。当这两个标志都为假时，它将触发纤维的回退。
- en: It bails out the fiber by cloning the children fibers from the current tree,
    which in turn carries all finished work over, including the old props and rendered
    *DOM*. Basically, by bailing out, it doesn't need to do the regular reconciliation
    work to figure out the new children fibers. And even better, if it turns out there's
    no work under the children of this fiber, the entire branch bails out. This corresponds
    to all the gray lines in *Figure 4.1*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过从当前树中克隆子纤维来回退纤维，这反过来又携带了所有完成的工作，包括旧的属性和渲染的*DOM*。基本上，通过回退，它不需要执行常规的协调工作来找出新的子纤维。而且更好，如果发现这个纤维的子纤维下没有工作，整个分支都会回退。这对应于*图4.1*中的所有灰色线条。
