- en: Styles - Applying Styles to Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式 - 将样式应用于组件
- en: 'In this chapter, you''ll learn about the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Basic component styles
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本组件样式
- en: Scoped component styles
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域组件样式
- en: Extending component styles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展组件样式
- en: Moving styles to themes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将样式移动到主题中
- en: Other styling options
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他样式选项
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The majority of styles that are applied to **Material-UI** components are part
    of the theme styles. In some cases, you need the ability to style individual components
    without changing the theme. For example, a button in one feature might need a
    specific style applied to it that shouldn't change every other button in the app.
    Material-UI provides several ways to apply custom styles to components as a whole,
    or to specific parts of components.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于 **Material-UI** 组件的大多数样式都是主题样式的一部分。在某些情况下，你可能需要有能力为单个组件设置样式，而不改变主题。例如，一个功能中的按钮可能需要应用特定的样式，而不应该改变应用中的其他按钮。Material-UI
    提供了多种方法来为组件整体或组件的特定部分应用自定义样式。
- en: Basic component styles
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本组件样式
- en: Material uses **JavaScript Style Sheets** (**JSS**) to style its components.
    You can apply your own JSS using the utilities provided by Material-UI.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 材料设计使用 **JavaScript 样式表**（**JSS**）来为其组件设置样式。你可以使用 Material-UI 提供的实用工具来应用自己的
    JSS。
- en: How to do it...
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The `withStyles()` function is a higher-order function that takes a style object
    as an argument. The function that it returns takes the component to style as an
    argument. Here''s an example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`withStyles()` 函数是一个高阶函数，它接受一个样式对象作为参数。它返回的函数将用于样式的组件作为参数。以下是一个示例：'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s what this component looks like:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个组件的外观：
- en: '![](img/ddf2a5c8-d5af-4772-af49-732af579ecdb.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ddf2a5c8-d5af-4772-af49-732af579ecdb.png)'
- en: How it works...
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s take a closer look at the `styles` defined by this example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个示例中定义的 `styles`：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `styles` that you pass to `withStyles()` can be either a plain object or
    a function that returns a plain object, as is the case with this example. The
    benefit of using a function is that the `theme` values are passed to the function
    as an argument, in case your `styles` need access to the `theme` values. There
    are two styles defined in this example: `card` and `cardActions`. You can think
    of these as **Cascading Style Sheets** (**CSS**) classes. Here''s what these two
    styles would look like as CSS:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你传递给 `withStyles()` 的 `styles` 可以是一个普通对象，也可以是一个返回普通对象的函数，就像这个示例一样。使用函数的好处是，`theme`
    值作为参数传递给函数，以防你的 `styles` 需要访问 `theme` 值。在这个示例中定义了两种样式：`card` 和 `cardActions`。你可以把它们看作是
    **级联样式表**（**CSS**）类。以下是这两个样式作为 CSS 的样子：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'By calling `withStyles(styles)(MyComponent)`, you''re returning a new component
    that has a `classes` property. This object has all of the classes that you can
    apply to components now. You can''t just do something such as this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `withStyles(styles)(MyComponent)`，你返回一个新的组件，它有一个 `classes` 属性。这个对象包含了你现在可以应用于组件的所有类。你不能只是做如下这样的事情：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When you define your `styles`, they have their own build process and every class
    ends up getting its own generated name. This generated name is what you'll find
    in the classes object, so this is why you would want to use it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义你的 `styles` 时，它们有自己的构建过程，每个类最终都会得到一个自己的生成名称。这个生成名称就是你在 `classes` 对象中找到的，这就是为什么你会想使用它的原因。
- en: There's more...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'Instead of working with higher-order functions that return new components,
    you can leverage Material-UI style hooks. This example already relies on the `useState()`
    hook from React, so using another hook in the component feels like a natural extension
    of the same pattern that is already in place. Here''s what the example looks like
    when refactored to take advantage of the `makeStyles()` function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与返回新组件的高阶函数一起工作，你可以利用 Material-UI 样式钩子。这个示例已经依赖于 React 的 `useState()` 钩子，所以在这个组件中使用另一个钩子感觉像是现有模式的一个自然扩展。以下是重构后利用
    `makeStyles()` 函数的示例：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `useStyles()` hook is built using the `makeStyles()` function—which takes
    the exact same `styles` argument as `withStyles()`. By calling `useStyles()` within
    the component, you have your classes object. Another important thing to point
    out is that `makeStyles` is imported from `@material-ui/styles`, not `@material-ui/core/styles`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`useStyles()` 钩子是通过 `makeStyles()` 函数构建的——它接受与 `withStyles()` 相同的 `styles`
    参数。通过在组件内部调用 `useStyles()`，你将拥有你的类对象。另一个需要指出的重要事情是，`makeStyles` 是从 `@material-ui/styles`
    而不是 `@material-ui/core/styles` 导入的。'
- en: See also
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'Material-UI CSS in JS documentation: [https://material-ui.com/css-in-js/basics/](https://material-ui.com/css-in-js/basics/).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Material-UI CSS in JS 文档：[https://material-ui.com/css-in-js/basics/](https://material-ui.com/css-in-js/basics/).
- en: Scoped component styles
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域组件样式
- en: Most Material-UI components have a CSS API that is specific to the component.
    This means that instead of having to assign a class name to the `className` property
    for every component that you need to customize, you can target specific aspects
    of the component that you want to change. Material-UI has laid the foundation
    for scoping component styles; you just need to leverage the APIs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Material-UI 组件都有一个针对组件的特定 CSS API。这意味着，您不需要为每个需要定制的组件分配类名到 `className` 属性，而是可以针对您想要更改的组件的特定方面进行定位。Material-UI
    为作用域组件样式奠定了基础；您只需利用这些 API。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s say that you have the following style customizations that you want to
    apply to the `Button` components used throughout your application:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有以下想要应用到您应用程序中所有 `Button` 组件上的样式定制：
- en: Every button needs a margin by default.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，每个按钮都需要一个边距。
- en: Every button that uses the `contained` variant should have additional top and
    bottom padding.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个使用 `contained` 变体的按钮都应该有额外的顶部和底部填充。
- en: Every button that uses the `contained` variant and the primary color should
    have additional top and bottom padding, as well as additional left and right padding.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个使用 `contained` 变体和主要颜色的按钮都应该有额外的顶部和底部填充，以及额外的左右填充。
- en: 'Here''s an example that shows how to use the `Button` CSS API to target these
    three different `Button` types with `styles`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示了如何使用 `Button` CSS API 通过 `styles` 来针对这三种不同的 `Button` 类型：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here''s what the three rendered buttons look like:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是三个渲染按钮的样式：
- en: '![](img/9ff32b1e-8808-4bc6-8646-0cb9dffdbfa6.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9ff32b1e-8808-4bc6-8646-0cb9dffdbfa6.png)'
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Button` CSS API takes named styles and applies them to the component. These
    same names are used in the styles in this code. For example, `root` applies to
    every `Button` component, whereas `contained` only applies the styles to the `Button`
    components that use the `contained` variant and the `containedPrimary` style only
    applies to `Button` components that use the `contained` variant and the `primary`
    color.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button` CSS API 接受命名样式并将它们应用到组件上。这些相同的名称也用于此代码中的样式。例如，`root` 应用于每个 `Button`
    组件，而 `contained` 只应用于使用 `contained` 变体和 `containedPrimary` 样式的 `Button` 组件，`containedPrimary`
    样式只应用于使用 `contained` 变体和 `primary` 颜色的 `Button` 组件。'
- en: There's more...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Each style is destructured from the classes property, then applied to the appropriate
    `Button` component. However, you don''t actually need to do all of this work.
    Since the Material-UI CSS API takes care of applying `styles` to components in
    a way that matches what you''re actually targeting, you can just pass the classes
    directly to the buttons and get the same result. Here''s a simplified version
    of this example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个样式都是从类属性中解构出来的，然后应用到适当的 `Button` 组件上。然而，您实际上并不需要做所有这些工作。由于 Material-UI CSS
    API 会以匹配您实际目标的方式将 `styles` 应用到组件上，因此您可以直接将类传递给按钮，并获得相同的结果。以下是这个示例的简化版本：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The output looks the same because only buttons that match the constraints of
    the CSS API get the styles applied to them. For example, the first `Button` has
    the `root`, `contained`, and `containedPrimary` styles passed to the classes property,
    but only `root` is applied because it isn't using the `contained` variant of the
    `primary` color. The second `Button` also has all three styles passed to it, but
    only `root` and `contained` are applied. The third `Button` has all three styles
    applied to it because it meets the criteria of each style.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来相同，因为只有符合 CSS API 约束的按钮才会应用样式。例如，第一个 `Button` 将 `root`、`contained` 和 `containedPrimary`
    样式传递给类属性，但只有 `root` 被应用，因为它没有使用 `contained` 变体的 `primary` 颜色。第二个 `Button` 也传递了所有三种样式，但只有
    `root` 和 `contained` 被应用。第三个 `Button` 因为符合每种样式的标准，所以应用了所有三种样式。
- en: See also
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Material-UI style override documentation: [https://material-ui.com/customization/overrides/](https://material-ui.com/customization/overrides/).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Material-UI 样式覆盖文档：[https://material-ui.com/customization/overrides/](https://material-ui.com/customization/overrides/).
- en: Extending component styles
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展组件样式
- en: You can extend `styles` that you apply to one component with `styles` that you
    apply to another component. Since your `styles` are JavaScript objects, one option
    is to extend one style object with another. The only problem with this approach
    is that you end up with a lot of duplicate `styles` properties in the CSS output.
    A better alternative is to use the `jss` extend plugin.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用另一个组件应用的`styles`来扩展一个组件应用的`styles`。由于你的`styles`是JavaScript对象，一个选项是将一个样式对象扩展到另一个样式对象上。这种方法的唯一问题是，你会在CSS输出中得到大量的重复`styles`属性。一个更好的选择是使用`jss`扩展插件。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s say that you want to render three buttons and share some of the `styles`
    among them. One approach is to extend generic `styles` with more specific `styles`
    using the `jss` extend plugin. Here''s how to do it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要渲染三个按钮并共享一些`styles`。一种方法是使用`jss`扩展插件将通用`styles`扩展到更具体的`styles`。下面是如何做到这一点：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here''s what the rendered buttons look like:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是渲染后的按钮外观：
- en: '![](img/40a18103-6747-4ac2-ab1c-f85ffbd91e7f.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40a18103-6747-4ac2-ab1c-f85ffbd91e7f.png)'
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The easiest way to use the `jss` extend plugin in your Material-UI application
    is to use the default JSS plugin presets, which includes `jss` extend. Material-UI
    has several JSS plugins installed by default, but `jss` extend isn''t one of them.
    Let''s take a look at the `App` component in this example to see how this JSS
    plugin is made available:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Material-UI应用中使用`jss`扩展插件的最简单方法是使用默认的JSS插件预设，这包括`jss`扩展。Material-UI默认安装了几个JSS插件，但`jss`扩展不是其中之一。让我们看看这个例子中的`App`组件，看看这个JSS插件是如何提供的：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `JssProvider` component is how JSS is enabled in Material-UI applications.
    Normally, you wouldn't have to interface with it directly, but this is necessary
    when adding a new JSS plugin. The `jss` property takes the JSS preset object that
    includes the `jss extend` plugin. The `generateClassName` property takes a function
    from Material-UI that helps generate class names that are specific to Material-UI.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`JssProvider`组件是JSS在Material-UI应用中启用的方式。通常，你不需要直接与之交互，但在添加新的JSS插件时这是必要的。`jss`属性接受包含`jss
    extend`插件的JSS预设对象。`generateClassName`属性接受一个来自Material-UI的函数，该函数有助于生成特定于Material-UI的类名。'
- en: 'Next, let''s take a closer look at some `styles`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更仔细地看看一些`styles`：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `extend` property takes the name of a style that you want to extend. In
    this case, the `contained` style extends `root`. The `containedPrimary` extends
    `contained` and `root`. Now let''s take a look at how this translates into CSS.
    Here''s what the `root` style looks like:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`extend`属性接受你想要扩展的样式的名称。在这种情况下，`contained`样式扩展了`root`。`containedPrimary`扩展了`contained`和`root`。现在让我们看看这如何转换为CSS。这是`root`样式的样子：'
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, here''s the `contained` style:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这是`包含`样式：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, here''s the `containedPrimary` style:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是`containedPrimary`样式：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that the properties from the more-generic properties are included in the
    more-specific styles. There are some properties duplicated, but this is in CSS,
    instead of having to duplicate JavaScript object properties. Furthermore, you
    could put these extended `styles` in a more central location in your code base,
    so that multiple components could use them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，更通用的属性中的属性包含在更具体的样式里。有一些属性是重复的，但在CSS中，你不需要重复JavaScript对象属性。此外，你还可以将这些扩展的`styles`放在代码库的更中心位置，这样多个组件就可以使用它们。
- en: See also
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Material-UI JSS documentation: [https://material-ui.com/customization/css-in-js/](https://material-ui.com/customization/css-in-js/).'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Material-UI JSS文档：[https://material-ui.com/customization/css-in-js/](https://material-ui.com/customization/css-in-js/)。
- en: Moving styles to themes
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将样式移动到主题中
- en: As you develop your Material-UI application, you'll start to notice style patterns
    that repeat themselves. In particular, styles that apply to one type of component,
    such as buttons, evolve into a theme.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你开发Material-UI应用，你将开始注意到重复出现的样式模式。特别是，应用于一种类型组件（如按钮）的样式会演变成一个主题。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s revisit the example from the *Scoped component styles* section:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下来自*作用域组件样式*部分的例子：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here''s what these buttons look like after they have these styles applied to
    them:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用了这些样式后的按钮外观：
- en: '![](img/b67dffd6-dbc1-4f24-8d48-7ef9f1772bb8.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b67dffd6-dbc1-4f24-8d48-7ef9f1772bb8.png)'
- en: 'Now, let''s say you''ve implemented these same styles in several places throughout
    your app because this is how you want your buttons to look. At this point, you''ve
    evolved a simple component customization into a theme. When this happens, you
    shouldn''t have to keep implementing the same styles over and over again. Instead,
    the styles should be applied automatically by using the correct component and
    the correct property values. Let''s move these styles into `theme`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你已经在应用程序的几个地方实现了这些相同的样式，因为这是你希望按钮看起来的方式。在这个时候，你已经将简单的组件定制发展成了一个主题。当这种情况发生时，你不需要反复实现相同的样式。相反，应该通过使用正确的组件和正确的属性值来自动应用样式。让我们将这些样式移动到`theme`中：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, you can use `Button` components without having to apply the same styles
    every time.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在不每次都应用相同样式的条件下使用`Button`组件。
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s take a closer look at how your styles fit into a Material-UI theme:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看你的样式是如何融入Material-UI主题的：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `overrides` property is an object that allows you to override component-specific
    properties of the theme. In this case, it's the `MuiButton` component styles that
    you want to override. Within `MuiButton`, you have the same CSS API that is used
    to target specific aspects of components. This makes moving your `styles` into
    the `theme` straightforward, because there isn't much to change.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`overrides`属性是一个对象，允许你覆盖主题的特定组件属性。在这种情况下，你想覆盖的是`MuiButton`组件的样式。在`MuiButton`中，你有用于针对组件特定方面的相同CSS
    API。这使得将`styles`移动到`theme`中变得简单，因为没有什么需要改变。'
- en: One thing that did have to change in this example is the way spacing works.
    In normal `styles` that are applied via `withStyles()`, you have access to the
    current theme because it's passed in as an argument. You still need access to
    the spacing data, but there's no `theme` argument because you're not in a function.
    Since you're just extending the default `theme`, you can access it by calling
    `createMuiTheme()` without any arguments, as this example shows.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中必须改变的一点是间距的工作方式。在通过`withStyles()`应用的正常`styles`中，你可以访问当前的主题，因为它作为参数传递。你仍然需要访问间距数据，但由于你不在函数中，所以没有`theme`参数。由于你只是扩展了默认的`theme`，你可以通过调用`createMuiTheme()`而不传递任何参数来访问它，就像这个示例所展示的那样。
- en: See also
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考也
- en: 'Material-UI style overrides documentation: [https://material-ui.com/customization/overrides/](https://material-ui.com/customization/overrides/).'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Material-UI样式覆盖文档：[https://material-ui.com/customization/overrides/](https://material-ui.com/customization/overrides/)。
- en: Other styling options
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他样式选项
- en: There are other styling options available to your Material-UI app beyond `withStyles()`.
    There's the `styled()` higher-order component function that emulates styled components.
    You can also jump outside the Material-UI style system and use inline CSS styles
    or import CSS modules and apply those styles.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`withStyles()`之外，你的Material-UI应用程序还有其他样式选项。有`styled()`高阶组件函数，它模仿了styled组件。你也可以跳出Material-UI样式系统，使用内联CSS样式或导入CSS模块并应用这些样式。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Here''s a modified version of the *Scoped component styles* example that showcases
    a few of the alternative style mechanisms available to you in your Material-UI
    applications:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个修改过的`Scoped component styles`示例，展示了你在Material-UI应用程序中可用的几种替代样式机制：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first button uses inline CSS properties, expressed as a plain JavaScript
    object and passed to the `style` property of the `Button` component. The second
    `Button` uses the `styled()` function to build a `MyStyledButton` component. This
    function works in much the same way as `withStyles`, the main difference being
    that its signature is geared toward people used to the styled-component's approach
    to styling components.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个按钮使用内联CSS属性，以纯JavaScript对象的形式表达，并传递给`Button`组件的`style`属性。第二个`Button`使用`styled()`函数构建一个`MyStyledButton`组件。这个函数与`withStyles`非常相似，主要区别在于它的签名是针对习惯于styled-component样式组件方法的人。
- en: 'The third `button` uses a style from an imported CSS module. Here''s what the
    module looks like:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个`button`使用从导入的CSS模块中导入的样式。模块看起来是这样的：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Be careful with CSS modules and inline styles. These approaches work fine, but
    since they're not tightly integrated with the Material-UI styling and theming
    mechanisms, they require more work to ensure that your styles fit with the rest
    of the Material-UI components.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用CSS模块和内联样式时要小心。这些方法工作得很好，但由于它们并没有紧密集成到Material-UI的样式和主题机制中，因此需要更多的工作来确保你的样式与Material-UI组件的其他样式相匹配。
- en: See also
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考也
- en: 'Material-UI style overrides documentation: [https://material-ui.com/customization/overrides/](https://material-ui.com/customization/overrides/).'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Material-UI样式覆盖文档：[https://material-ui.com/customization/overrides/](https://material-ui.com/customization/overrides/).
- en: 'Material-UI JSS documentation: [https://material-ui.com/css-in-js/api/](https://material-ui.com/css-in-js/api/).'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Material-UI JSS文档：[https://material-ui.com/css-in-js/api/](https://material-ui.com/css-in-js/api/).
