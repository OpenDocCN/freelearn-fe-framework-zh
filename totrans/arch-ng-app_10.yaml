- en: NgRx – In Depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will go into more advanced NgRx topics. As you implement your first
    applications using NgRx, you will notice that it means creating a lot of boilerplate
    and you may not feel as fast as when you were NOT using NgRx. For that reason,
    the entity library exists to help alleviate some of the boilerplate creation—more
    on that later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The router and its state is another thing that can be interesting to keep track
    of. The URL of where you are currently, the router parameter, as well as query
    parameters are all interesting pieces of information that might come in handy.
    They might come in handy should you be in a situation where you might want to
    reinstate the app, also called **rehydration**.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will dive into how to build your own micro implementation of NgRx using
    RxJS, so you get a feel for what's going on. Hopefully, that will be a real eye-opening
    moment in understanding the underlying ideas of what makes NgRx and Redux tick.
  prefs: []
  type: TYPE_NORMAL
- en: To round off this chapter and this book, we will explain what schematics is
    and how it will help you quickly scaffold the various parts that you need to be
    a really efficient user of NgRx.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Leverage the entity library and how it makes our life easier using NgRx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capture the router state as well as customize what gets saved down by writing
    our own customization code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a micro implementation of NgRx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demystify schematics and see how it can make us an even faster and more efficient
    user of NgRx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '@ngrx/entity'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The demo code for this section can be found in the code repository for this
    book under `Chapter10/Entity`.
  prefs: []
  type: TYPE_NORMAL
- en: The entity library is here to help us manage collections and basically, write
    less and do more. This means that so far we have been writing a lot of code when
    creating reducers and selectors that we simply won't need to do when we leverage
    the full power of the entity library.
  prefs: []
  type: TYPE_NORMAL
- en: Setting it up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start by downloading the entity library. To do this, we need to run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an entity state based on the model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an entity adapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the initial state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the reducer and set up the state in the `StoreModule.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start off by creating our model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is just a simple model with fields `id` and `name`. We then
    create our entity state, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be the return type our reducer needs to abide by. Type `EntityState`
    looks like the following, if you peek into the NgRx source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By extending the preceding interface `EntityState,` when we create type `State`
    we will also get the properties `ids` and `entities`. We will see later in this
    section how these properties are populated, once we start using the utility methods
    the entity library gives us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create our adapter. An instance of the adapter sits on
    a range of methods, allowing us to write a great deal less code. We create the
    adapter with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we are almost ready; we just need to get the initial state from
    the adapter and provide that to our reducer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the initial state, we need to talk to our adapter, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What's happening here is that we need to create an object representing the initial
    state. It needs to be of type `State` and therefore it needs to have the properties
    `ids`, `entities`, and `selectedUserId` defined. Then, we call `getInitialState()`
    on the adapter to produce our initial state. So, what do we need the initial state
    for? We'll need to set it as the default value of our reducer's state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create our reducer and set its default state to our initial state
    instance, created previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note here how we call our `userAdapter` and invoke the method `addOne()`; this
    means that we don''t have to write code that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step to setting everything up is to add the state to the `StoreModule`
    so that NgRx knows about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That concludes the required setup. The next steps we want to take in the following
    sections are how to display the data in a component, and also how to perform a
    full CRUD and thereby leveraging more of what the `EntityAdapter` has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting our data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have learnt by now that to select data in NgRx, we need to inject the store
    service and call `select` on it, either with a string as an argument or with a
    function. Let''s inject the store service and have a look at the state that comes
    back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding component won''t display the users in a neat list just yet; we
    will explain why later. In the meantime, we will just focus on what is logged
    to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecf91d61-2e05-4d72-ac6e-2a5a54a1ae44.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What we see here is the state of our store, which contains a user''s property
    at the highest level, it has `entities`, `ids` and `selectedUserId` as properties.
    This is to be expected so far. What does surprise us a little is the fact that
    the entities dictionary is an object and not a list. How do we output that in
    a list form using `*ngFor`? Well, we can easily solve that with a `map()` operator,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: OK, so now we drill down to `state.users.entities` to get to our users but we
    need to add the `map()` operation to turn our entities dictionary into a list.
    So, the console now shows us an empty array as the initial value of `users$`,
    which makes perfect sense. The UI is still empty, as we have an empty array and
    therefore nothing to show. In the following section, we will cover how to add,
    remove, and update the state using the `EntityAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the full CRUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we mean by CRUD is the ability to add, edit, read, and delete the data
    from the store. The point of using the entity library is for it to do most of
    the heavy lifting. The time has come to revisit our reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using the `userAdapter` instance to carry out adding one item
    to the store. There is a lot more the adapter can do for us though—here is a full
    list of its capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Creating users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we can see, `EntityStateAdapter` has methods for the full CRUD. Let''s look
    at adding the capability to add a user to our component. We need to make the following
    additions to our component:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an input field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dispatch an `ADD_USER` action with our new user as payload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The required code changes are in bold, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This code demonstrates how we add an input element and connect that to the
    field `user` on our class through `ngModel`. We also added the `add()` method
    that dispatches a user to our reducer. Adding a user should now look like the
    following in the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26348501-a729-444c-a0da-2bac9b6bcf29.png)'
  prefs: []
  type: TYPE_IMG
- en: Updating users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two things we need to do to support updating users:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a component that supports updating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a CASE to our reducer that listens to an action and calls the appropriate
    `adapter` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a component that takes a `user` as input and is able to invoke
    a `save` as output thereby calling the parent component. In short, this component
    allows us to edit a user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to add this component to `app.module.ts` so that other components
    within this module can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to add the component to the parent components template, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This code shows us how we add the `EditUserComponent` to the markup, as well
    as us adding the `update()` method that, when invoked, dispatches the action `UPDATE_USER`.
    This will lead to our reducer being invoked which leads us to our final piece
    of the puzzle, the required changes we need to make to the reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We now support the ability to update our users list.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last piece of supporting CRUD is the ability to remove users from the list.
    This case is very similar to all the other cases:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to add support for it to `app.component.ts`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to update the reducer, and the reducer needs to call the appropriate
    adapter method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with the component and add support in the markup, as well as adding
    a `remove()` method to the component class, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The remaining part is updating our reducer to say the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '@ngrx/router-store'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to be able to trace where we are in the application—*where—*is represented
    by our route, route parameters, as well as by query parameters. By saving where
    we are, down to our store, we are able to easily serialize the stores information
    to a storage for later retrieval and deserialization, which means we can re-instate
    the app with not only the state, but also our page location.
  prefs: []
  type: TYPE_NORMAL
- en: Installation and set up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The router store is in an NPM package and we can therefore type the following
    to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we need to do is to import the correct modules and set those
    up in the `import` properties of our root module, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We don't do a lot here. We call the `forRoot()` method on the `StoreRouterConnectingModule,`
    and we also add a new reducer entry in the form of a router that points to `routerReducer`
    as the reducer that will handle any changes to the `router` property.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating the router state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have just set up the router store. This means that we automatically write
    to a property `router` in our store every time we navigate. We can prove this
    is the case by editing the `app.component.ts` to subscribe to that slice of state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we subscribe to the state router and thereby listen to every time the
    route changes. We log the said object and it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6151db2f-b7b4-45af-bd21-0a905f2781a4.png)'
  prefs: []
  type: TYPE_IMG
- en: This screenshot shows us the object our router state now contains. We can see
    the `url` property points to `/` which means our default route has been loaded.
    We can also see that this object contains router parameters and query parameters
    in the `root` property. So, there is some interesting information in there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens when we route somewhere like `/testing`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba557ce4-7997-478e-9e72-a55d3c850f25.png)'
  prefs: []
  type: TYPE_IMG
- en: Our router state has been updated and we can see that our `url` property points
    to `/testing`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have subscribed to the router state and listened to when the route
    is changing. There is a second way. We could be listening to when a specific action
    is being dispatched. The action being dispatched for routing is the string `ROUTER_NAVIGATION`.
    We can therefore easily build an effect for this so we can carry out side effects
    when the route changes. We may want to carry out AJAX requests or store things
    in a local cache. Only you know what you want to do. Let''s build that effect.
    We will return back to an existing file, `routing.effects.ts`, and extend it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Custom serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The object being stored is a bit verbose though. It contains a lot of information
    and we may only be interested in parts of it. We can actually solve that by building
    our own custom serializer. We need to do the following to accomplish that:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class that implements the interface `RouterStateSerializer` and decide
    what we want to return
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace the router key `RouterStateSerializer` with our custom implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s begin. We first create a class, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RouterStateSeralizer` interface forces us to specify a `type T`, which
    could be anything. `T` is what we want to return from the routing object. Remember
    the reason for doing what we are doing is to grab a subset of interesting information
    from the routing object. The full routing information is contained within our
    input parameter `routerState` that is of type `RouterStateSnapshot`. A comment
    though is that `MyState` is a bit anemic, as it only contains a single property,
    `url`. You can of course extend this according to the needs of your application.
    You most likely want to grab the `router` and `query` parameters. We will grab
    those as well before we are done with this section but let''s start with this
    to showcase how it works. The next step is to grab the data from the `routerState`
    parameter. For now, we dig out the `url`—let''s update the code to reflect that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now tell the provider to use our implementation instead. We need to
    go to the `app.module.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now imported the `MySerializer` class and the `RouterStateSeralizer`
    interface and we are replacing the provider key using the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to take this for a spin. So, we fire up the app and see what
    happens if we navigate around in the app. Here is a quick reminder of what our
    app looks like right now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87df3b0a-3fc4-4f79-9a26-abe98e9ddcbf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking either the Testing or Products link will take us to `/testing` or
    `/products,` respectively. Let''s do just that and see what that looks like. We
    have a look at the console and lo and, behold! Our router object is considerably
    smaller:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72311ccd-62ff-4d7c-95de-5a4b4748fa1a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our object now contains pretty much only the `url` property. This is what gets
    stored down in the state of our application. If we want more things stored than
    that, then we can easily extend the `MySerializer` class—suggested additions are
    router and query parameters. Let''s make the following alterations to the `MySerializer`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigating to `http://localhost:4200/products?page=1` will now produce the
    following in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77337137-0f5a-4c76-88c0-c6d7ba03b73c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The difference is now that we have a `queryParams` property, which points to
    an object with content `{ page: 1 }`. This is what we expected. Digging out the
    router parameters is equally easy. But for us to have router parameters that are
    populated in the first place, we need to have a route with a routing parameter.
    Instead of `/products,` we need something such as `products/:id`. Let''s start
    by adding that to our list of routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And we of course need to add a component. It does nothing special other than
    exist for our demo purposes. Remember the emphasis is on understanding the serialization
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, it''s time to return back to our browser and enter the `url`,
    `products/1?page=1`. Let''s have a look at the console now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69e1890f-dd94-4e31-839f-bf2507ed448c.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we see how our `params` property has been added to our custom object.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating through dispatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our router store properly set up, we can actually start thinking
    in terms of dispatching actions, even for routes. OK, what does that mean? Well,
    imagine we are thinking more and more in dispatching actions; it makes our world
    simpler. When you dispatch an action, an HTTP call happens, and, in dispatching
    an action, the application routes you where you want to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'This isn''t really a feature of the router store, but a way you can look at
    it. A way to implement this is by writing your own effect that responds to a route
    action, and, as a result, you call the router service and perform the navigation.
    Let''s summarize what we just said in a bullet list and carry out the resulting
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up some routing constants.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up some routing actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write an effect that listens to routing actions and performs routing inside
    of the effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is Step 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, our next step is to define a set of action creators so we can set off a
    certain behavior when a specific action occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next step is our effect, which would now be able to respond to the preceding
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Understanding NgRx – building our own micro implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have done this experiment once before in [Chapter 8](e29180be-1bdf-4fdb-805b-333607fd6e0d.xhtml),
    *Redux*. The point was to gain a deeper understanding of what goes on behind the
    scenes. The difference between implementing Redux and implementing NgRx is the
    use of a library for publish/ subscribe, which is the way you choose to convey
    to a listener that a change has occurred. In our Redux implementation in [Chapter
    8](e29180be-1bdf-4fdb-805b-333607fd6e0d.xhtml), *Redux*, we gave you the choice
    between implementing the Gang of Four publish-subscribe pattern without the help
    of a library, or using `EventEmitter` to achieve the same thing. In NgRx, that
    component is RxJS. So, let''s crack on with the implementation. Before doing so,
    let''s describe what we aim to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: We aim to implement a store that holds a state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be possible to dispatch an action to said store so that its inner
    state changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any change to the store should go through a reducer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn to handle side effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A store at its heart is just a class wrapping a state. A store needs to be
    able to deal with changes; the change should come via method dispatch. The following
    pseudo code represents what the store might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We mentioned in the beginning of this main section that NgRx uses RxJS at its
    core. We mentioned that it was so the store could convey changes to its listeners.
    Let''s mention the core concepts of RxJS that might fit the preceding problem
    description. In RxJS, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Observable**: It is able to emit values and you can attach subscribers to
    it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observer**: This is the object that is called so that we end up getting the
    values as a subscriber'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscriber**: This is a combination of an Observable and an Observer in that
    it can be subscribed to but it is also possible to add values to it after the
    subscription has happened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thinking about the store for a bit, we realize we need to be able to add values
    to it at any point and we need to be able to subscribe to it. This seems to fit
    the behavior of the `Subject`. Let''s continue our pseudo coding of the `Store`
    but let a `Subject` be part of it now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We implemented the `dispatch()` method with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, let''s care about implementing subscription functionality. Let''s
    imagine the store will be used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'For that to be possible, we could just add the `subscribe()` method to our
    store. If we were to do that ourselves, we would have to take care of a list of
    listeners and ensure listeners are told when a change happens to the state. A
    better option is to just let our store inherit from `Subject`. That would take
    care of the subscription bit. Let''s see what that might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code reimplements the `dispatch()` method and we also set up
    a subscription in the constructor to ensure our latest state is updated. There
    is a thing we need to improve here and that is how we add state to our store.
    With Redux, the incoming state change should be reduced into the old state, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The way to achieve this is to refactor our code a little and create another
    `Subject` that will be the target of a call to dispatch, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Merging the states in a better way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding code, we used an `Object.assign()` to merge the old state
    with the new state. We can do this even better by using the `scan()` operator
    on our dispatcher member, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: An important thing to note in the preceding code is that we removed the state
    member from the store. It's simply not needed as we only care about the latest
    value being emitted anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a reducer and integrating it with the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An important concept of Redux is to guard who and what can affect your store.
    The *who* is reducers. By allowing only reducers to affect your store, we are
    more in control of what happens. A simple reducer is just a function that takes
    a state and action as parameters and is able to produce a new state based on the
    old state and existing state, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'So, where does a reducer come into the picture in Redux? Well, the state of
    the store is made up of an object, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The way a store goes about calculating the next state of a store is by creating
    a function that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding code, we are able to let different reducer functions handle
    different parts of our state. Let''s add such a function to our store along with
    some reducers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We have made quite a few changes to our store at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: We have added two reducers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we inherit from a `BehaviorSubject`; this is so we can remember what the
    old state was so when we call `calcState()` we are able to produce a new state
    based on the old state + action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added the method `calcState()` that takes the old state and an action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dispatcher now takes an action instead of a state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `super()` constructor in the constructor now takes an initial value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have set ourselves up quite well for our next step, namely on how to get
    a part of the state.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with slices of state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The reason for wanting only part of the state is that we will use NgRx in a
    context where there will be many components that only care about rendering a little
    part of the application''s full state. For example, we may have a product list
    component, a product detail component, and so on. For that reason, we need to
    implement support for getting a slice of state. Thanks to the fact that our store
    inherits from a `BehaviorSubject,` implementing a slice of state is child''s play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Should we want a more advanced `select` method, we can let it take a function
    instead, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Handling side effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is a side effect? A side effect is something that isn''t part of the normal
    code flow but something that accesses outside resources, such as filesystems or
    resources on other networks. In the context of Redux, side effects are most often
    used for carrying out AJAX calls. Once that call comes back, we most likely need
    to update the state of the store because something has changed. How would we implement
    such a function? One is add a method `effect()` that would take a function. The
    said function would take dispatch method as a parameter so that the parameter
    function can carry out a dispatch, should it have a need for it, once the side
    effect has run its course. Let''s imagine it is being used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows how we in our side effect would want to carry out
    an AJAX call and fetch our products. Once we are done with our fetch, we want
    to dispatch the fetched products so they become part of the store''s state. Let''s
    attempt to implement the preceding `effect()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Adds a new case `LOAD_PRODUCTS` to the `productsReducer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements the `effect()` method on the `Store` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines a `getProducts()` method to simulate AJAX calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demonstrates the use of the effect method by carrying out a call to `getProducts`
    and ends up dispatching the fetched products to the store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have now fully implemented the store and effects libraries for NgRx—we should
    be proud of ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: '@ngrx/schematics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Schematics is dependent on all of the libraries you can possibly use with NgRx;
    it''s therefore a good idea to start out by installing these libraries before
    we do anything else. Just type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Schematics itself is a library that Angular-CLI uses to generate different
    constructs needed for Angular development, such as components services, filters,
    and much more. `@ngrx/schematics` provides blueprints to schematics so you can
    get help generating constructs that you need when working with NgRx, in other
    words it makes development a lot faster. You can get help with generating the
    following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting it up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`@ngrx/schematics` is an NPM library and as such can be easily installed by
    typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: That's it. That's all that was needed to do the set up. To use it, you just
    need a terminal window and enter the appropriate commands. We will look at that
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Generating constructs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generating what you need is as simple as typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This will create files in the appropriate place. This is a real time saver,
    so learn to use it. Almost all of the commands come with a lot of options so it's
    worth checking out how they can be configured in the official documentation, which
    can be found here [https://github.com/ngrx/platform/tree/master/docs/schematics.](https://github.com/ngrx/platform/tree/master/docs/schematics)
  prefs: []
  type: TYPE_NORMAL
- en: Generating actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do this by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'It will generate an actions file for us called `jedi.actions.ts` with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code gives us nice scaffolded files with some nice defaults and
    it creates a `enum` type that we can use in conjunction with reducers and selectors.
    Looking at the preceding code, we realize that we need to extend `JedisActionTypes`
    if we want things such as `ADD`, `CREATE,` and other CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This will inject a store into your component and create the component itself—the
    typical way to call this one is by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jedis.component.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jedis.component.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jedis.component.css`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jedis.component.spec.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And in `jedis.component.ts` and the store will be injected in the constructor,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Generating an effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You generate an effect by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jedis.effect.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jedis.effect.spec.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `effects` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Generating an entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This generates a whole bunch of files that you can think of to work with an
    entity. To run the command, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The following files are generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`product.actions.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product.model.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product.reducer.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product.reducer.spec.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's worth mentioning that the `product.reducer.ts` file not only generates
    the full reducer function but also creates and initializes the `EntityAdapter`.
    That's a lot of boilerplate that you don't have to write. You also get all the
    actions and all selectors—a truly powerful command.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generating a feature gives you a lot of files. Let''s have a look at what the
    command looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`category.actions.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`category.reducer.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`category.reducer.spec.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`category.effects.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`category.effects.spec.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This again is a lot of files you don't have to write by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a reducer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This generates a reducer and a test file. If all you want is a reducer then
    this command is for you. To use it, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`travel.reducer.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`travel.reducer.spec.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This command sets you up completely for using the `@ngrx/store`. It also allows
    you to set up feature stores. So, by typing the following two commands, you can
    generate a whole lot of files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will generate a module as well as add a feature state. Running
    the following command will add the set up needed to work with the store, as well
    as set up the devtools that come with NgRx:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this, the final chapter of the book, we have looked at how to truly master
    NgRx and all its accompanying helper libraries. We have also gone through how
    to build your own micro implementation of NgRx to establish that we really know
    what is going on behind the scenes. We have looked at various ways to improve
    our speed and productivity by looking at the entity library and schematics library,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: You, as a reader, have been taken through a long journey of Flux and Redux patterns
    throughout the course of this book. In addition, Functional programming, Reactive
    Programming, and deep RxJS knowledge have been added to your tool belt. This has
    built up to two full chapters covering everything NgRx has to offer. The aim of
    this book was to give you a broad and deep enough context of the underlying thoughts
    and paradigms behind NgRx and the library itself. The hope is that after, reading
    this book, you will feel full of confidence and know how to tackle existing and
    future projects using Angular and NgRx.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you for taking the time to read this book, and do not hesitate to reach
    out with queries in any way, shape, or form.
  prefs: []
  type: TYPE_NORMAL
