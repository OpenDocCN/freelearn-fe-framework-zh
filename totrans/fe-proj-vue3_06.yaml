- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Global Component Composition
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局组件组合
- en: In the previous chapter, we learned how to use Composition API to create component
    logic and how to write custom reusable composables in a Vue application. There
    are many approaches to sharing similar logic between other components besides
    composables. In this chapter, we will learn how to use mixins, plugins, and how
    to render dynamic components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用 Composition API 来创建组件逻辑，以及如何在 Vue 应用中编写自定义的可复用可组合组件。除了可组合组件之外，还有许多方法可以在其他组件之间共享类似的逻辑。在本章中，我们将学习如何使用混入（mixins）、插件，以及如何渲染动态组件。
- en: By the end of this chapter, you will be ready to organize your code using mixins
    and plugins, achieve global composition, and keep code **DRY** (**Don’t Repeat
    Yourself**) in any project. You will also understand the advantages and drawbacks
    of global composition, thus deciding the right approach to maximize a component’s
    flexibility.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将准备好使用混入和插件来组织代码，实现全局组合，并在任何项目中保持代码 **DRY**（**不要重复自己**）。您还将了解全局组合的优点和缺点，从而决定最佳方法以最大化组件的灵活性。
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Understanding mixins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解混入
- en: Understanding plugins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解插件
- en: Registering components globally
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局注册组件
- en: Understanding component tags
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解组件标签
- en: Writing functional components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写函数组件
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, you need to set up a basic Vue project following the instructions
    in [*Chapter 1*](B18645_01.xhtml#_idTextAnchor015), *Starting Your First Vue Project*.
    It’s recommended to create a single-file Vue component to practice the examples
    and concepts mentioned easily.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您需要按照 [*第 1 章*](B18645_01.xhtml#_idTextAnchor015) 中 *启动您的第一个 Vue 项目* 的说明设置一个基本的
    Vue 项目。建议创建一个单文件 Vue 组件来练习提到的示例和概念。
- en: 'You can find this chapter’s source code here: [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的源代码：[https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06)。
- en: Understanding mixins
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解混入
- en: With mixins, we can add additional methods, data properties, and life cycle
    methods to a component’s `option` object.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用混入，我们可以向组件的 `option` 对象中添加额外的函数、数据属性和生命周期方法。
- en: 'In the following example, we first define a mixin that contains a `greet` method
    and a `greeting` data field:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们首先定义一个包含 `greet` 方法和 `greeting` 数据字段的混入：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then we can use the `greeter` mixin by importing and assigning it as part of
    the `mixins` field in the component’s `option` object, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过导入并将它作为组件 `option` 对象中的 `mixins` 字段的一部分来使用 `greeter` 混入，如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`mixins` is an array that accepts any mixin as its element, while a `mixin`
    is in fact a component’s `option` object. Mixins allow multiple components to
    share common data and logic definitions independently.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`mixins` 是一个数组，它接受任何混入作为其元素，而实际上 `mixin` 是一个组件的 `option` 对象。混入允许多个组件独立地共享公共数据和逻辑定义。'
- en: 'Once we add a mixin to a component, Vue will merge all the data and methods
    into the existing data and methods (mix in). A `mixin`’s properties and methods
    are then available in the component for use as its own data and methods, like
    how we use the `greet` method from the `greeter` mixin in the following template:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将混入添加到组件中，Vue 将将所有数据和函数合并到现有的数据和函数中（混入）。然后，混入的属性和方法将可在组件中使用，作为其自己的数据和函数，就像我们在以下模板中使用
    `greeter` 混入的 `greet` 方法一样：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And in the browser, we will see the following message:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，我们将看到以下消息：
- en: '![Figure 6.1 – Display Hello World using a greeter mixin](img/B18645_06_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 使用 greeter 混入显示 Hello World](img/B18645_06_01.jpg)'
- en: Figure 6.1 – Display Hello World using a greeter mixin
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 使用 greeter 混入显示 Hello World
- en: When there is an overlapping of naming data properties or methods, Vue will
    prioritize the component’s own options. We can explain this mechanism as the component
    adopting the mixin as its default options unless a similar declaration already
    exists. In this case, the instance will ignore the mixin’s definition and take
    the component’s definition instead.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据属性或方法名称发生重叠时，Vue 将优先考虑组件自己的选项。我们可以将这种机制解释为组件采用混入作为其默认选项，除非已经存在类似的声明。在这种情况下，实例将忽略混入的定义，而采用组件的定义。
- en: 'For example, let’s add a `data()` initializer, which returns `greeting` data
    with the value `Hi` to the component that uses the `greeter` mixin:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们向使用 `greeter` 混合的组件添加一个 `data()` 初始化器，该初始化器返回值为 `Hi` 的 `greeting` 数据：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`greeter` also defines `greeting`, but so does the component. In this case,
    the component *wins*, and we will see `Hi` displayed instead of `Hello` (as defined
    in the mixin), as in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`greeter` 也定义了 `greeting`，但组件也是如此。在这种情况下，组件会**获胜**，我们将看到显示的是 `Hi` 而不是 `Hello`（如混合中定义的），如下面的截图所示：'
- en: '![Figure 6.2 – Component displays Hi World with overridden greeting data value](img/B18645_06_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 组件显示带有覆盖的问候数据值的“Hi World”](img/B18645_06_02.jpg)'
- en: Figure 6.2 – Component displays Hi World with overridden greeting data value
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 组件显示带有覆盖的问候数据值的“Hi World”
- en: However, this mechanism doesn’t apply to life cycle hooks. The hooks defined
    in the mixins will take priority in execution, and Vue always triggers the component’s
    hooks last. If there is more than one mixin added to the component, the execution
    order follows their order of appearance in the `mixins` field.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，此机制不适用于生命周期钩子。在混合中定义的钩子将具有优先执行权，Vue 总是最后触发组件的钩子。如果向组件添加了多个混合，则执行顺序遵循它们在 `mixins`
    字段中出现的顺序。
- en: 'We can observe this execution order in the following example. Let’s create
    two mixins that implement the `mounted` life cycle hook – `firstMixin` and `secondMixin`,
    as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下示例中观察到此执行顺序。让我们创建两个实现 `mounted` 生命周期钩子的混合，即 `firstMixin` 和 `secondMixin`，如下所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then we also implement the same hook in the component, as shown in the following
    code block:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们也在组件中实现了相同的钩子，如下面的代码块所示：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The full code will look like the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码将如下所示：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The browser’s console output for this component will be as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件的浏览器控制台输出如下：
- en: "![Figure 6.3 – Console log outputs demonstrate the order of execution for the\
    \ hooks of mixins and components\uFEFF](img/B18645_06_03.jpg)"
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 控制台日志输出显示了混合和组件钩子的执行顺序](img/B18645_06_03.jpg)'
- en: Figure 6.3 – Console log outputs demonstrate the order of execution for the
    hooks of mixins and components
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 控制台日志输出显示了混合和组件钩子的执行顺序
- en: Now let’s practice what we have learned so far by implementing your first mixin
    in the next exercise.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过在下一个练习中实现你的第一个混合来练习我们迄今为止所学的内容。
- en: Exercise 6.01 – creating your mixin
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.01 – 创建你的混合
- en: In this exercise, we will create a mixin called `debugger`. It contains a `debug`
    method that receives `Object` as its argument and returns a string representing
    its structure using the `JSON.stringify()` function. This method is handy for
    printing data in a readable format when debugging Vue.js on the browser instead
    of the console.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在此练习中，我们将创建一个名为 `debugger` 的混合。它包含一个接收 `Object` 作为其参数的 `debug` 方法，并使用 `JSON.stringify()`
    函数返回表示其结构的字符串。此方法在调试浏览器上的 Vue.js 而不是控制台时打印可读格式的数据时很有用。
- en: To access the code file for this exercise, refer to [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Exercise6.01](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Exercise6.01).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Exercise6.01](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Exercise6.01)。
- en: 'Execute the following steps to complete this exercise:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成此练习：
- en: 'Use the application generated with `npm init vue@3` as a starting point, or
    within the root folder of the code repository, navigate to the `Chapter06/Exercise6.01`
    folder, by using the following commands in order:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以使用 `npm init vue@3` 生成的应用程序作为起点，或者在你的代码仓库的根目录中，使用以下命令导航到 `Chapter06/Exercise6.01`
    文件夹：
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Open the exercise project in your VS Code (by using the `code .` command within
    the project directory), or your preferred IDE.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 VS Code 中打开练习项目（在项目目录中使用 `code .` 命令），或者使用你喜欢的 IDE。
- en: 'Create a new `src/mixins` folder and a `src/mixins/debugger.js` file where
    we will define the skeleton of our mixin:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `src/mixins` 文件夹和一个 `src/mixins/debugger.js` 文件，我们将在这里定义我们的混合的框架：
- en: '[PRE9]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We add a `debug` method under `methods`. The `debug` method will take an `obj`
    parameter and return the output of `JSON.stringify` for that input parameter.
    We will use `JSON.stringify(obj, null, 2)` to output two-space pretty-printed
    JSON:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 `methods` 下添加一个 `debug` 方法。`debug` 方法将接受一个 `obj` 参数，并返回该输入参数的 `JSON.stringify`
    输出。我们将使用 `JSON.stringify(obj, null, 2)` 来输出两空格缩进的格式化 JSON：
- en: '[PRE10]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We are now able to import the `debugger` mixin in `src/App.vue` and register
    it under the `mixins` property:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在`src/App.vue`中导入`debugger`混合，并在`mixins`属性下注册它：
- en: '[PRE17]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To see the `debug` method in action, we will add a `data` method that returns
    a `myObj` data property and a `created` hook where we will compute the output
    of `debug` for `myObj`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看`debug`方法的作用，我们将添加一个`data`方法，它返回一个`myObj`数据属性，以及一个`created`钩子，我们将计算`myObj`的`debug`输出：
- en: '[PRE23]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You should get the following output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '![Figure 6.4 – Browser console output due to the created hook](img/B18645_06_04.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 由于 created 钩子导致的浏览器控制台输出](img/B18645_06_04.jpg)'
- en: Figure 6.4 – Browser console output due to the created hook
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 由于 created 钩子导致的浏览器控制台输出
- en: '`debug` is also available in the template. We can display its output wrapped
    with a `pre` tag so that whitespace is respected:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`debug`在模板中也是可用的。我们可以使用`pre`标签包裹其输出，以便尊重空白字符：'
- en: '[PRE40]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The application, as well as this template, will look as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序以及此模板将如下所示：
- en: '![Figure 6.5 – Browser printing myObj using the debug method from the mixin](img/B18645_06_05.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 使用混合中的 debug 方法打印 myObj 的浏览器打印](img/B18645_06_05.jpg)'
- en: Figure 6.5 – Browser printing myObj using the debug method from the mixin
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 使用混合中的 debug 方法打印 myObj 的浏览器打印
- en: We have learned how we can use mixins to inject shared logic and data into multiple
    components in a manner that is quite explicit (a `mixins` property). However,
    due to the mechanism of data overriding and executing for hooks, mixins can lead
    to potential bugs and unwanted behaviors in a large code base. *Thus, we recommend
    considering creating shared logic and data as composable with Composition API
    whenever* *possible instead*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用混合将共享逻辑和数据以相当明确的方式（`mixins`属性）注入到多个组件中。然而，由于数据覆盖和钩子执行的机制，混合可能导致大型代码库中的潜在错误和不受欢迎的行为。*因此，我们建议在可能的情况下，将共享逻辑和数据作为可组合的
    Composition API 创建，而不是使用混合*。
- en: We will now look at how to inject instance and global functionality and distribute
    it through plugins.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨如何注入实例和全局功能，并通过插件进行分发。
- en: Understanding plugins
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解插件
- en: Vue plugins are a way to add custom functionality to Vue.js globally. Classic
    examples of plugin candidates are translation/internationalization libraries (such
    as `i18n-next`) and HTTP clients (such as the `axios`, `fetch`, and `GraphQL`
    clients). The plugin initializer has access to the `Vue` instance, so it can be
    a good way to wrap global directives and components and inject resources across
    the application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 插件是向 Vue.js 全局添加自定义功能的一种方式。插件候选者的经典例子是翻译/国际化库（例如`i18n-next`）和 HTTP 客户端（例如`axios`、`fetch`和`GraphQL`客户端）。插件初始化器可以访问`Vue`实例，因此它是一个很好的方式来包装全局指令和组件，并在整个应用程序中注入资源。
- en: 'A Vue plugin is an object that exposes an `install` method. The `install` function
    is called with an `app` instance and `options`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 插件是一个暴露`install`方法的对象。`install`函数使用`app`实例和`options`调用：
- en: '[PRE45]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Within the `install` method, we can register directives and components and
    add global and instance properties and methods:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`install`方法中，我们可以注册指令和组件，并添加全局和实例属性和方法：
- en: '[PRE46]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can register a plugin using the `use` instance method, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`use`实例方法注册一个插件，如下所示：
- en: '[PRE47]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can pass an options as the second argument to the `use()` method. These
    options are passed to the plugin:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将选项作为`use()`方法的第二个参数传递。这些选项将传递给插件：
- en: '[PRE48]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`use()` does not allow you to register the same plugin twice, avoiding edge
    case behavior when attempting to instantiate or install the same plugin multiple
    times.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`use()`不允许您注册相同的插件两次，避免了在尝试多次实例化或安装相同插件时出现的边缘情况行为。'
- en: A popular HTTP client to use in combination with Vue is Axios. It is common
    to configure Axios with interceptors or Axios options to achieve things such as
    retries, passing cookies, or following redirects.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在与 Vue 结合使用时，Axios 是一个流行的 HTTP 客户端。通常，使用拦截器或 Axios 选项配置 Axios 以实现重试、传递 cookie
    或跟随重定向等功能。
- en: Axios can be installed using `npm install –save axios`. In the next exercise,
    we will create a plugin wrapping Axios inside our application.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`npm install –save axios`安装 Axios。在下一个练习中，我们将在应用程序内部创建一个包装 Axios 的插件。
- en: Exercise 6.02 – creating a custom Axios plugin
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.02 – 创建自定义 Axios 插件
- en: In order to avoid having to add `import axios from 'axios'` or having to wrap
    our custom Axios instance under an `http` or `transport` internal module, we’ll
    inject our custom Axios instance into the Vue object and Vue component instances
    under `Vue.axios` and `this.axios`. This will make it easier and more ergonomic
    to use in our application, which needs to call out to an API using Axios as the
    HTTP client.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免添加 `import axios from 'axios'` 或将我们的自定义 Axios 实例包装在 `http` 或 `transport`
    内部模块下，我们将我们的自定义 Axios 实例注入到 Vue 对象和 Vue 组件实例中，在 `Vue.axios` 和 `this.axios` 下。这将使它在我们的应用程序中使用更加方便和舒适，该应用程序需要调用
    API 并使用 Axios 作为 HTTP 客户端。
- en: To access the code file for this exercise, refer to [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Exercise6.02](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Exercise6.02).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Exercise6.02](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Exercise6.02)。
- en: 'Execute the following steps to complete this exercise:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: 'Use the application generated with `npm init vue@3` as a starting point, or
    within the root folder of the code repository, navigate into the `Chapter06/Exercise6.02`
    folder, by using the following commands in order:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用由 `npm init vue@3` 生成的应用程序作为起点，或者在代码仓库的根目录中，通过以下命令导航到 `Chapter06/Exercise6.02`
    文件夹：
- en: '[PRE49]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Open the exercise project in VS Code (by using the `code .` command within the
    project directory) or your preferred IDE.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开练习项目（通过在项目目录中使用 `code .` 命令）或使用您首选的 IDE。
- en: 'To organize our code properly, we will create a new folder in `src/plugins`
    and a new file for our `axios` plugin at `src/plugins/axios.js`. In the new file,
    we will scaffold the `axios` plugin:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了正确组织代码，我们将在 `src/plugins` 中创建一个新的文件夹，并在 `src/plugins/axios.js` 中创建一个新的 `axios`
    插件文件。在新文件中，我们将构建 `axios` 插件：
- en: '[PRE51]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We will now register our `axios` plugin on the Vue.js instance in `src/main.js`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在 `src/main.js` 中注册我们的 `axios` 插件：
- en: '[PRE55]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We will now install Axios through npm using the following command. This will
    allow us to import Axios and expose it on Vue through a plugin:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用以下命令通过 npm 安装 Axios。这将允许我们导入 Axios 并通过插件将其暴露在 Vue 中：
- en: '[PRE61]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We will now add Axios to Vue as a global property in `src/plugins/axios.js`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将 Axios 添加到 Vue 中，作为 `src/plugins/axios.js` 中的全局属性：
- en: '[PRE62]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Axios is now available on Vue. In `src/App.vue`, we can make a request to an
    API that will populate a list of `todos`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Axios 现在在 Vue 中可用。在 `src/App.vue` 中，我们可以向 API 发送请求，这将填充 `todos` 列表：
- en: '[PRE68]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The following is the expected output:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的输出是预期的：
- en: '![Figure 6.6 – Global this.$axios todo display sample](img/B18645_06_06.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 全局 this.$axios todo 显示示例](img/B18645_06_06.jpg)'
- en: Figure 6.6 – Global this.$axios todo display sample
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 全局 this.$axios todo 显示示例
- en: 'We can also provide Axios as an injectable when necessary, instead of making
    it available in every component, by using `app.provide()` as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在必要时，我们也可以通过使用 `app.provide()` 如下提供 Axios 作为可注入项，而不是在所有组件中使其可用：
- en: '[PRE94]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now we can access Axios through `this.axios` in `src/App.vue` if we inject
    `''axios''` into this component by using the `inject` property:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们通过使用 `inject` 属性将 `'axios'` 注入到该组件中，我们就可以在 `src/App.vue` 中通过 `this.axios`
    访问 Axios：
- en: '[PRE101]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The output of the above code stays the same as in *Figure 6**.6*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出与 *图 6.6* 中的输出相同。
- en: With that, we have used a plugin to inject both global and instance-level properties
    and methods.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经使用插件注入了全局和实例级别的属性和方法。
- en: We will now look at how globally registering components can help reduce boilerplate
    for high-usage components in a code base.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨全局注册组件如何帮助减少代码库中高使用组件的样板代码。
- en: Globally registering components
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局注册组件
- en: A reason for using plugins is to reduce boilerplate in all Vue application files
    by removing `imports` and replacing it with access to `this`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用插件的原因之一是通过删除 `imports` 并用对 `this` 的访问来减少所有 Vue 应用程序文件中的样板代码。
- en: Vue.js components are usually defined in a single-file component and imported
    explicitly. Much for the same reasons as we define global methods and properties,
    we might want to register components globally. This will allow us to use these
    components in all our other component templates without having to import them
    and register them under the `components` property.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 组件通常在单个文件组件中定义，并显式导入。与定义全局方法和属性的原因类似，我们可能希望全局注册组件。这将允许我们在所有其他组件模板中使用这些组件，而无需导入和注册它们在
    `components` 属性下。
- en: A situation where this can be very useful is when using a design system or when
    a component is used across the code base.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况在使用设计系统或组件在代码库中跨模块使用时非常有用。
- en: Globally registering a component helps with some types of updates, such as if
    the filename is not exposed to the consumer so that when changing the filename,
    there is only one path to update as opposed to one per user.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 全局注册组件有助于某些类型的更新，例如，如果文件名没有暴露给消费者，那么在更改文件名时，只有一个路径需要更新，而不是每个用户一个。
- en: 'Let’s assume we have a `CustomButton` component in the `CustomButton.vue` file
    that looks as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个 `CustomButton.vue` 文件中的 `CustomButton` 组件，其外观如下：
- en: '[PRE115]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'We can register `CustomButton` globally as follows (this is usually done in
    the `main.js` file):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `CustomButton` 全局注册如下（这通常在 `main.js` 文件中完成）：
- en: '[PRE116]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'We can now use it in the `App.vue` file without locally registering it or importing
    it:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在 `App.vue` 文件中使用它，而无需本地注册或导入：
- en: '[PRE117]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'This renders as expected, with a button called **Click Me**:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按预期渲染，显示一个名为 **Click Me** 的按钮：
- en: '![Figure 6.7 – CustomButton rendering with a Click Me button](img/B18645_06_07.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7 – 使用 Click Me 按钮渲染 CustomButton](img/B18645_06_07.jpg)'
- en: Figure 6.7 – CustomButton rendering with a Click Me button
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 使用 Click Me 按钮渲染 CustomButton
- en: With that, we have explored how globally registering components can cut down
    on boilerplate when components are used often across a code base.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经探讨了全局注册组件如何减少在代码库中频繁使用组件时的样板代码。
- en: The next section is dedicated to deepening our understanding of Vue.js components
    by learning how to use them without `.``vue` files.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将致力于通过学习如何在不使用 `.vue` 文件的情况下使用 Vue.js 组件来加深我们对 Vue.js 组件的理解。
- en: Using non-SFC Vue components
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用非 SFC Vue 组件
- en: Most of the examples we have seen of Vue.js components have leveraged `.vue`
    single-file components. This is not the only way to define a Vue.js component.
    In this section, we will look at four different ways to define Vue.js components
    without using a `.``vue` file.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的大多数 Vue.js 组件示例都利用了 `.vue` 单文件组件。这不是定义 Vue.js 组件的唯一方法。在本节中，我们将探讨四种不同的方法来定义
    Vue.js 组件，而不使用 `.vue` 文件。
- en: Evaluating these options will help us understand what a Vue.js component is
    at its core.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 评估这些选项将帮助我们理解 Vue.js 组件的核心是什么。
- en: Runtime definition with a string template
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用字符串模板进行运行时定义
- en: A component can use a `template` property that accepts a string value. This
    is commonly called a **string template**. This template is evaluated at runtime
    (in the browser).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以使用接受字符串值的 `template` 属性。这通常被称为 **字符串模板**。此模板在运行时（在浏览器中）被评估。
- en: 'We can define a component in the `StringTemplate.js` file by defining an object
    with a `template` property:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `StringTemplate.js` 文件中通过定义一个具有 `template` 属性的对象来定义一个组件：
- en: '[PRE118]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'This can then be consumed from the `App.vue` file, as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以从 `App.vue` 文件中消费它，如下所示：
- en: '[PRE119]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Unfortunately, the browser won’t display the content of `StringTemplate`, and
    in the console log, you will find the following Vue warning:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，浏览器不会显示 `StringTemplate` 的内容，在控制台日志中，您将找到以下 Vue 警告：
- en: '![Figure 6.8 – Vue runtime compiler missing warning](img/B18645_06_08.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8 – Vue 运行时编译器缺失警告](img/B18645_06_08.jpg)'
- en: Figure 6.8 – Vue runtime compiler missing warning
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – Vue 运行时编译器缺失警告
- en: For this component to work, we need to include the Vue runtime compiler. We
    can do so by manually adding `'vue/dist/vue.esm-bundler.js'` as a `vue` alias
    for the Vite engine to resolve.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此组件正常工作，我们需要包含 Vue 运行时编译器。我们可以通过手动添加 `'vue/dist/vue.esm-bundler.js'` 作为 Vite
    引擎的 `vue` 别名来解决。
- en: 'Your `vite.config.js` file should look like the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `vite.config.js` 文件应如下所示：
- en: '[PRE120]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'After re-starting the development server, a message from the `StringTemplate`
    component appears in the browser:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动开发服务器后，浏览器中会出现 `StringTemplate` 组件的消息：
- en: '[PRE121]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Next, let’s explore how to create components using the `render` function.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索如何使用 `render` 函数创建组件。
- en: Understanding the render function
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解渲染函数
- en: Behind the scenes, the `template` section gets compiled into a `render` function
    at build time.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`template` 部分在构建时被编译成一个 `render` 函数。
- en: Starting from Vue 3, a `render` method in a component’s options no longer takes
    a `createElement` argument and then returns a virtual DOM node received from the
    execution of `createElement`. Instead, Vue provides an `h` function, which performs
    the same thing.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Vue 3 开始，组件选项中的 `render` 方法不再接受 `createElement` 参数并返回从 `createElement` 执行中接收到的虚拟
    DOM 节点。相反，Vue 提供了一个 `h` 函数，它执行相同的功能。
- en: 'We can define a component in a JavaScript file (`RenderFunction.js`) with a
    `render` property like so:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一个 JavaScript 文件（`RenderFunction.js`）中定义一个组件，并具有一个 `render` 属性，如下所示：
- en: '[PRE122]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'This can be rendered in the `App.vue` file as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在 `App.vue` 文件中如下渲染：
- en: '[PRE123]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'This component displays an `h2` with the text `Render Function Component` in
    the browser:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件在浏览器中显示一个带有文本 `Render Function Component` 的 `h2`：
- en: '[PRE124]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Beyond writing components in non `.vue` files, `render` functions can be useful
    for highly dynamic components.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在非 `.vue` 文件中编写组件外，`render` 函数对于高度动态的组件也很有用。
- en: JSX
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSX
- en: '**JSX** is a superset of JavaScript that allows HTML-style tags and interpolation
    using braces in React, like SFC to Vue.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSX** 是 JavaScript 的超集，它允许在 React 中使用 HTML 样式的标签和花括号进行插值，类似于 SFC 到 Vue。'
- en: React, like Vue, does not render the raw JSX to the DOM. React also use `render`
    to render a component’s content to the Virtual DOM. The Virtual DOM is then *reconciled*
    (synced) with the real DOM.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Vue 一样，React 也不会将原始 JSX 渲染到 DOM 中。React 也使用 `render` 将组件的内容渲染到虚拟 DOM 中。然后虚拟
    DOM 与真实 DOM 进行 *协调*（同步）。
- en: 'Vite and Vue CLI both support the JSX compiler out of the box for the Vue application.
    You just need to turn on JSX support during the installation configuration when
    using `create-vue`. This means we can write the following `JSXRender.js` file,
    which is the equivalent of the `RenderFunction` component:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Vite 和 Vue CLI 都默认支持 Vue 应用的 JSX 编译器。您只需在安装配置时使用 `create-vue` 打开 JSX 支持。这意味着我们可以编写以下
    `JSXRender.js` 文件，它是 `RenderFunction` 组件的等价物：
- en: '[PRE125]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The equivalent `render` function without JSX looks as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 没有 JSX 的等效 `render` 函数如下所示：
- en: '[PRE126]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The following `App.vue` file renders `JSXRender` to the browser:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `App.vue` 文件将 `JSXRender` 渲染到浏览器：
- en: '[PRE127]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Now, we can see `h2` from `JSXRender` on the screen with the expected content:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在屏幕上看到 `JSXRender` 中的 `h2`，内容符合预期：
- en: '[PRE128]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: We will now look at how components can be rendered dynamically from runtime
    data using the Vue.js `component` tag.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨如何使用 Vue.js 的 `component` 标签从运行时数据动态渲染组件。
- en: Understanding components
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解组件
- en: JSX and `render` functions are great for situations where the component being
    rendered needs to be very dynamic. We can also achieve this capability using the
    Vue `component`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 和 `render` 函数非常适合那些需要渲染的组件非常动态的情况。我们也可以使用 Vue 的 `component` 实现这种能力。
- en: 'To render a dynamic component, we use a `component` tag with a bound `is` property
    (here, we are using the shorthand `:is`, which is equivalent to `v-bind:is`):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染动态组件，我们使用一个带有绑定 `is` 属性的 `component` 标签（在这里，我们使用的是简写 `:is`，它等同于 `v-bind:is`）：
- en: '[PRE129]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: We will now learn how to render dynamic components using a name or component
    reference.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将学习如何使用名称或组件引用来渲染动态组件。
- en: Rendering dynamic components by name or component reference
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过名称或组件引用渲染动态组件
- en: Let’s say we have a grid that contains items whose display can be toggled between
    a card display (a design element with an image and text) or an image-only view.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个网格，其中包含可以切换显示为卡片显示（带有图像和文本的设计元素）或仅图像视图的项目。
- en: 'First, we need to import the relevant components and register them as components.
    We will also set some fixture data to loop through for the grid:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入相关组件并将它们注册为组件。我们还将设置一些固定数据以循环显示网格：
- en: '[PRE130]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'We can then reference the components by name – that is, `Card` and `ImageEntry`
    – and set `itemComponent` as the value for `is`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按名称引用组件——即 `Card` 和 `ImageEntry`——并将 `itemComponent` 作为 `is` 的值：
- en: '[PRE131]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: In the preceding code, Vue will render the `Card` component since we set the
    `itemComponent` value as `card`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，Vue 将渲染 `Card` 组件，因为我们设置了 `itemComponent` 的值为 `card`。
- en: 'If we set `itemComponent` to `image-entry`, Vue renders the `ImageEntry` component.
    This switch can be made as follows using `v-model`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `itemComponent` 设置为 `image-entry`，Vue 将渲染 `ImageEntry` 组件。这个切换可以通过以下方式使用
    `v-model` 来实现：
- en: '[PRE132]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'We can also pass components to `is` using the component reference itself (instead
    of using the name). For example, we could set `itemComponent` to `Card`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用组件引用本身将组件传递给 `is`（而不是使用名称）。例如，我们可以将 `itemComponent` 设置为 `Card`：
- en: '[PRE133]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: In this case, switching between card and image views would be more difficult
    since we would need to use component references instead of using names.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，切换卡片和图像视图会更困难，因为我们需要使用组件引用而不是使用名称。
- en: 'We can pass props to components that have been dynamically rendered with `component`
    like we would pass regular props either with `v-bind:prop-name` or the `:``prop-name`
    shorthand:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像传递常规属性一样，使用 `component` 动态渲染的组件传递属性，无论是使用 `v-bind:prop-name` 还是 `:prop-name`
    简写：
- en: '[PRE134]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Given the following `Card` and `ImageEntry` components, we get an application
    that has toggleable views for grid items.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下 `Card` 和 `ImageEntry` 组件，我们得到一个具有可切换视图的网格项应用程序。
- en: '`Card.vue` renders the image and the title and has a `150px` maximum width:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`Card.vue` 渲染图像和标题，最大宽度为 `150px`：'
- en: '[PRE135]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Your output will display the entries in the card view, as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出将显示卡片视图中的条目，如下所示：
- en: '![Figure 6.9 – Grid rendering entries in the card view](img/B18645_06_09.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9 – 卡片视图中的网格渲染条目](img/B18645_06_09.jpg)'
- en: Figure 6.9 – Grid rendering entries in the card view
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – 卡片视图中的网格渲染条目
- en: 'Use `ImageEntry.vue` to render only the image at double the width of the card
    view:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ImageEntry.vue` 仅渲染卡片视图宽度的两倍宽度的图像：
- en: '[PRE136]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'You will now see the entries in the image view, as shown in the following screenshot:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在将看到图像视图中的条目，如下面的屏幕截图所示：
- en: '![Figure 6.10 – Grid rendering entries in the image view](img/B18645_06_10.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10 – 图像视图中的网格渲染条目](img/B18645_06_10.jpg)'
- en: Figure 6.10 – Grid rendering entries in the image view
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – 图像视图中的网格渲染条目
- en: A caveat of the `component` tag is that the rendered dynamic component gets
    completely torn down when it is not displayed anymore. In this example, the dynamic
    components being rendered do not have any state, so this teardown does not create
    any issues.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`component` 标签的一个注意事项是，当不再显示时，渲染的动态组件会被完全拆解。在这个例子中，正在渲染的动态组件没有任何状态，因此这种拆解不会引起任何问题。'
- en: We will now learn how a dynamic component state is cached.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将学习如何缓存动态组件状态。
- en: Caching a dynamic component state with keep-alive
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `keep-alive` 缓存动态组件状态
- en: Components that are dynamically rendered through the `component` tag can have
    state, such as in a multipart form, with a `name` field and an `address` field
    on the next page.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `component` 标签动态渲染的组件可以有状态，例如在多部分表单中，下一页有一个 `name` 字段和一个 `address` 字段。
- en: 'Let’s implement this with a `component` tag, as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 `component` 标签来实现这一点，如下所示：
- en: '[PRE137]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'And in the `FirstStep` component, we will implement an `input` field that requires
    the user’s name, as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `FirstStep` 组件中，我们将实现一个需要用户姓名的 `input` 字段，如下所示：
- en: '[PRE138]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'And for `SecondStep.vue`, we will implement another input field with two buttons
    to navigate back and forward, as shown in the following code block:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `SecondStep.vue`，我们将实现另一个带有两个按钮的输入字段，用于导航后退和前进，如下面的代码块所示：
- en: '[PRE139]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'By doing this, we can enter data in the **Name** field:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们可以在 **名称** 字段中输入数据：
- en: '![Figure 6.11 – “My name is” is entered in the name field](img/B18645_06_11.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.11 – “我的名字是”已输入到名称字段中](img/B18645_06_11.jpg)'
- en: Figure 6.11 – “My name is” is entered in the name field
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 – “我的名字是”已输入到名称字段中
- en: 'If we navigate, using **Next**, to the address part of the form and then use
    **Back**, the name will disappear, as shown in the following screenshot:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 **下一步** 导航到表单的地址部分，然后使用 **后退**，名称将消失，如下面的屏幕截图所示：
- en: '![Figure 6.12 – Empty Name field upon clicking Next and then Back in the address
    step](img/B18645_06_12.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.12 – 点击下一步然后后退到地址步骤时名称字段为空](img/B18645_06_12.jpg)'
- en: Figure 6.12 – Empty Name field upon clicking Next and then Back in the address
    step
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – 点击下一步然后后退到地址步骤时名称字段为空
- en: This is due to the component being unmounted when it is not the currently rendered
    dynamic component.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为组件在不是当前渲染的动态组件时会被卸载。
- en: 'To fix this, we can use the `keep-alive` element around the `component` tag:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以在 `component` 标签周围使用 `keep-alive` 元素：
- en: '[PRE140]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'In this manner, filling out the name and going back from the address section
    of the form shows the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，填写姓名并从表单的地址部分返回将显示以下内容：
- en: '![Figure 6.12 – “My name is” is still the value in the Name field after navigation](img/B18645_06_13.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.12 – “我的名字是”在导航后仍然是名称字段中的值](img/B18645_06_13.jpg)'
- en: Figure 6.12 – “My name is” is still the value in the Name field after navigation
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – 导航后“我的名字是”仍然是名称字段中的值
- en: We have learned how to use the `component` tag to denote an area within which
    we can dynamically display a component based on a string or the component itself
    (as imported). We have also explored how to work around the main gotcha of `component`;
    namely, how to use `keep-alive` to maintain the component state when it is not
    the component being actively used in the `component` tag.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用 `component` 标签来表示一个区域，在这个区域内我们可以根据字符串或组件本身（如导入的）动态显示组件。我们还探讨了如何解决
    `component` 的主要问题；即如何使用 `keep-alive` 在 `component` 标签中维护不是当前正在使用的组件的状态。
- en: Now let’s practice what we learned in the next exercise.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在下一个练习中练习我们所学的内容。
- en: Exercise 6.03 – creating a dynamic card layout with the component tag
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.03 – 使用组件标签创建动态卡片布局
- en: 'A modern application layout is a grid with cards. Card layouts have the benefit
    of being well suited to mobile, desktop, and tablet displays. In this exercise,
    we will create a dynamic card layout with three different modes and a way to select
    between the three of them. This layout will allow the user to select how much
    information is displayed on the screen to suit their preference:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用布局是一个由卡片组成的网格。卡片布局的优点是非常适合移动、桌面和平板显示器。在这个练习中，我们将创建一个具有三种不同模式和选择其中一种方式的功能的动态卡片布局。这个布局将允许用户选择屏幕上显示多少信息以适应他们的偏好：
- en: The `Rich` view will display all the details for an item, including the image,
    the title, and the description
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rich`视图将显示项目的所有详细信息，包括图片、标题和描述'
- en: The `Compressed` view will display all the details but not the image preview
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Compressed`视图将显示所有详细信息，但不显示图片预览'
- en: The `List` view will only display the title and should be a vertical layout
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List`视图将只显示标题，应该是一个垂直布局'
- en: Each of the card views will be implemented as a separate component that will
    then be dynamically rendered using the `component` tag.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 每个卡片视图都将作为一个单独的组件实现，然后使用`component`标签动态渲染。
- en: To access the code file for this exercise, refer to [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Exercise6.03](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Exercise6.03).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Exercise6.03](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Exercise6.03)。
- en: 'Execute the following steps to complete this exercise:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: 'Use the application generated with `npm init vue@3` as a starting point, or
    within the root folder of the code repository, navigate into the `Chapter06/Exercise6.03`
    folder, by using the following commands in order:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用由`npm init vue@3`生成的应用程序作为起点，或者在代码仓库的根目录中，使用以下命令按顺序导航到`Chapter06/Exercise6.03`文件夹：
- en: '[PRE141]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Open the exercise project in your VS Code (by using the `code .` command within
    the project directory) or your preferred IDE.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的VS Code中打开练习项目（在项目目录中使用`code .`命令）或您首选的IDE。
- en: 'Create the rich layout at `src/components/Rich.vue`. It contains three props
    called `url` (the image URL), `title`, and `description` and renders the image,
    the title, and the description, respectively:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/components/Rich.vue`中创建丰富的布局。它包含三个属性，称为`url`（图片URL）、`title`和`description`，分别渲染图片、标题和描述：
- en: '[PRE143]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Set up `src/App.vue` with some fixture data:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一些固定数据设置`src/App.vue`：
- en: '[PRE168]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Import the `Rich` view component into `src/App.vue` and register it locally:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Rich`视图组件导入到`src/App.vue`并本地注册：
- en: '[PRE192]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Once we have got the `Rich` view component, wire it into the application in
    `src/App.vue`, render it with `component`, and pass the relevant props through:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们得到了`Rich`视图组件，将其连接到`src/App.vue`中的应用程序中，使用`component`渲染它，并通过以下方式传递相关属性：
- en: '[PRE196]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'This is a good point to add a bit of styling to make the grid look like a grid:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个添加一些样式使网格看起来像网格的好地方：
- en: '[PRE213]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'This displays the following output:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下输出：
- en: '![Figure 6.14 – Rich component rendering dynamically](img/B18645_06_14.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![图6.14 – 动态渲染的Rich组件](img/B18645_06_14.jpg)'
- en: Figure 6.14 – Rich component rendering dynamically
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14 – 动态渲染的Rich组件
- en: 'Now, implement the `Compressed` view, which is just the `Rich` view without
    the image in the `Compressed.vue` file:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`Compressed.vue`文件中实现`Compressed`视图，它只是没有图片的`Rich`视图：
- en: '[PRE232]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'Import and register the `Compressed` component in `src/App.vue`. Then create
    our `layoutOptions` array with two elements. Each has two fields: `name` of the
    layout and the `component` instance for the two components – `Rich` and `Compressed`
    respectively, as shown in the following code block:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/App.vue`中导入并注册`Compressed`组件。然后创建我们的`layoutOptions`数组，包含两个元素。每个元素有两个字段：布局的`name`和两个组件实例，分别是`Rich`和`Compressed`，如下面的代码块所示：
- en: '[PRE258]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE269]'
- en: 'Add `select` to switch between views. It will take options from the `layoutOptions`
    array using `v-for`, and bind its selected value to `layout` using `v-model`:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`select`以在视图之间切换。它将从`layoutOptions`数组中使用`v-for`获取选项，并使用`v-model`将其选中值绑定到`layout`：
- en: '[PRE270]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE280]'
- en: 'Using `select`, we can switch to the **Compressed** layout, which looks as
    follows:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`select`，我们可以切换到**Compressed**布局，其外观如下：
- en: '![Figure 6.15 – Compressed layout with options dropdown for selection](img/B18645_06_15.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![图6.15 – 带有选项下拉选择器的压缩布局](img/B18645_06_15.jpg)'
- en: Figure 6.15 – Compressed layout with options dropdown for selection
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15 – 带有选项下拉选择器的压缩布局
- en: 'Add the `List` layout to `src/components/List.vue`. The `List` view is the
    compressed view but without the description:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`List`布局添加到`src/components/List.vue`。`List`视图是压缩视图，但没有描述：
- en: '[PRE281]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'Import the `List` component into `src/App.vue` and register it locally:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`List`组件导入到`src/App.vue`并本地注册：
- en: '[PRE294]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE308]'
- en: 'When switching to the **List** layout, the items are displayed in a horizontal
    row, as follows:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 当切换到**List**布局时，项目以水平行显示，如下所示：
- en: '![Figure 6.16 – List view with incorrect horizontal stacking](img/B18645_06_16.jpg)'
  id: totrans-502
  prefs: []
  type: TYPE_IMG
  zh: '![图6.16 – 带有错误水平堆叠的列表视图](img/B18645_06_16.jpg)'
- en: Figure 6.16 – List view with incorrect horizontal stacking
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 – 带有错误水平堆叠的列表视图
- en: 'To fix this horizontal stacking, create a new `grid-column` class that sets
    `flex-direction: column` (as opposed to `row`, which is the default) and conditionally
    applies it when the layout is `List`:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '为了修复这种水平堆叠，创建一个新的`grid-column`类，设置`flex-direction: column`（与默认的`row`相反）并在布局为`List`时条件性地应用它：'
- en: '[PRE309]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE322]'
- en: 'Our **List** layout now looks as follows:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的**List**布局如下所示：
- en: '![Figure 6.17 – List view with vertical stacking](img/B18645_06_17.jpg)'
  id: totrans-520
  prefs: []
  type: TYPE_IMG
  zh: '![图6.17 – 带有垂直堆叠的列表视图](img/B18645_06_17.jpg)'
- en: Figure 6.17 – List view with vertical stacking
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 – 带有垂直堆叠的列表视图
- en: With that, we have learned how to use the `component` tag to dynamically render
    different components both by name and by using the component object itself. We
    have also explored the pitfalls of stateful dynamic components, namely the teardown
    of components when they are not displayed anymore and how to circumvent them using
    the `keep-alive` element.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学会了如何使用`component`标签通过名称和通过使用组件对象本身动态渲染不同的组件。我们还探讨了有状态动态组件的陷阱，即组件不再显示时的组件拆解以及如何使用`keep-alive`元素来规避它们。
- en: We will now look at how simple components can be implemented using only a `render`
    function or `template` tag using functional components.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨如何使用函数式组件仅通过`render`函数或`template`标签来实现简单的组件。
- en: Writing functional components
  id: totrans-524
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写函数式组件
- en: 'In Vue 2.0, you can declare a component as a functional one by setting the
    `functional` field to `true` in the component’s options:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 2.0中，您可以通过在组件选项中将`functional`字段设置为`true`来声明一个组件为函数式组件：
- en: '[PRE323]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: 'This can also be done by setting `functional` directly on the `template` tag:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以通过直接在`template`标签上设置`functional`来实现：
- en: '[PRE324]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: And you can set how to render the component using the `render()` method of the
    component or the `template` section. However, if both fields exist, Vue takes
    the `render()` method.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过组件的`render()`方法或`template`部分来设置组件的渲染方式。然而，如果两个字段都存在，Vue将采用`render()`方法。
- en: 'In Vue 3.0 onward, however, Vue removed the `functional` attribute and you
    can only declare a functional component using a JavaScript function, which is
    the `render` function Vue will trigger to create the component:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从Vue 3.0开始，Vue移除了`functional`属性，您只能使用JavaScript函数声明函数式组件，这是Vue将触发以创建组件的`render`函数：
- en: '[PRE325]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: 'Once declared as functional, the component does not have any reactive state,
    and you can’t access `this` instance since it is not available. Instead, Vue triggers
    the `render` function and passes to it the component’s props and necessary context
    including `attrs`, `slots`, and the passed event handler’s `emit`:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明为函数式组件，该组件就没有任何响应式状态，并且由于它不可用，您无法访问`this`实例。相反，Vue触发`render`函数，并将组件的属性和必要上下文传递给它，包括`attrs`、`slots`以及传递的事件处理器的`emit`：
- en: '[PRE326]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: 'You can also define the accepted props and events by directly setting its field
    `props` and `emits`:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过直接设置其字段`props`和`emits`来定义接受的属性和事件：
- en: '[PRE327]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: 'To start using JSX code, you will need to create the Vue project with JSX support
    enabled using Vite. Otherwise, in `vite.config.js`, you will need to manually
    import `vueJsx` from the `''@vitejs/plugin-vue-jsx''` package, as follows:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用JSX代码，您需要使用Vite创建带有JSX支持的Vue项目。否则，在`vite.config.js`中，您需要手动从`'@vitejs/plugin-vue-jsx'`包导入`vueJsx`，如下所示：
- en: '[PRE328]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: 'And then add the imported `vueJsx` plugin to the `plugins` array, as seen in
    the following code:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将导入的`vueJsx`插件添加到`plugins`数组中，如下所示：
- en: '[PRE329]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: With the preceding configuration, your Vue project created by Vite now supports
    functional components with JSX, which we will demonstrate in the following example.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的配置，您现在使用Vite创建的Vue项目支持带有JSX的函数式组件，我们将在以下示例中演示。
- en: 'The following code block is an example of how we define a functional component,
    `GreetComponent.jsx`:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是定义函数式组件 `GreetComponent.jsx` 的示例：
- en: '[PRE330]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: 'We also declare `props` and `emits` explicitly for `GreetComponent`:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还显式地声明了 `GreetComponent` 的 `props` 和 `emits`：
- en: '[PRE331]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: Note that here, since we use JSX syntax to define the component, we need to
    make sure the file extension of `GreetComponent` is `.jsx` and not `.js` (`GreetComponent.jsx`).
    Also, we need to make sure we turn on JSX support when creating the project with
    the `create-vue` command (Vite).
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里，由于我们使用 JSX 语法来定义组件，我们需要确保 `GreetComponent` 的文件扩展名是 `.jsx` 而不是 `.js` (`GreetComponent.jsx`)。此外，我们需要确保在用
    `create-vue` 命令（Vite）创建项目时启用 JSX 支持。
- en: 'Now we can import and use `GreetComponent` in `App.vue` as a regular component:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `App.vue` 中将 `GreetComponent` 作为常规组件导入和使用：
- en: '[PRE332]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: 'This renders the following to the browser:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在浏览器中渲染以下内容：
- en: '![Figure 6.18 – Functional component rendering](img/B18645_06_18.jpg)'
  id: totrans-549
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.18 – 函数式组件渲染](img/B18645_06_18.jpg)'
- en: Figure 6.18 – Functional component rendering
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.18 – 函数式组件渲染
- en: 'You can also combine with Composition API to create functional components with
    states. In the following example, we create a `Message` component with a reactive
    message:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以结合 Composition API 创建具有状态的函数式组件。在下面的示例中，我们创建了一个具有响应式消息的 `Message` 组件：
- en: '[PRE333]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: Note that here, we display the `message` value by using `message.value`, not
    `message` directly.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里，我们通过使用 `message.value` 而不是直接使用 `message` 来显示 `message` 值。
- en: At this point, we have learned how to write functional components – stateless
    or stateful – using Composition API. We will now build a to-do application that
    uses all the patterns we have looked at throughout this chapter.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何使用 Composition API 编写函数式组件 – 无状态或带状态 – 现在，我们将构建一个使用本章中查看的所有模式的待办事项应用。
- en: Activity 6.01 – building a Vue.js application with plugins and reusable components
  id: totrans-555
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 6.01 – 使用插件和可重用组件构建 Vue.js 应用程序
- en: To access the code file for this activity, refer to [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Activity6.01](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Activity6.01)
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此活动的代码文件，请参阅 [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Activity6.01](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter06/Activity6.01)
- en: In this activity, we will build a to-do app that integrates `jsonplaceholder`
    as a data source.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将构建一个集成 `jsonplaceholder` 作为数据源的待办事项应用。
- en: Our to-do app will load todos and display them as a list. It will display a
    checkbox based on whether the to-do has been completed, as well as the name of
    the to-do.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的待办事项应用将加载待办事项并将它们显示为列表。它将根据待办事项是否完成显示复选框，以及待办事项的名称。
- en: When checking off a to-do, the application will sync it to the API.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 当勾选待办事项时，应用程序将同步它到 API。
- en: We will inject Axios as a plugin to query against [https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com).
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将作为插件注入 Axios 以查询 [https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com)。
- en: 'Follow these steps to complete this activity:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此活动：
- en: Install `axios` in the project.
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中安装 `axios`。
- en: To inject `axios` as a property into `this` component instances, create a `src/plugins/axios.js`
    plugin file that, on install, will mean component instances have an injectable
    `axios` property.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将 `axios` 注入为属性到 `this` 组件实例中，创建一个 `src/plugins/axios.js` 插件文件，在安装时，这意味着组件实例将有一个可注入的
    `axios` 属性。
- en: For the plugin to work, import and register it in `src/main.js`.
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使插件工作，请将其导入并注册到 `src/main.js` 中。
- en: We also want to inject our API’s `$baseUrl` into all our components as a global
    scope. We will create a plugin inline with the `src/main.js` file to do this.
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望将我们的 API 的 `$baseUrl` 注入到所有组件中作为全局作用域。我们将创建一个与 `src/main.js` 文件内联的插件来完成此操作。
- en: We now want to fetch all the to-dos from `src/App.vue`. A good place to do this
    is in the `mounted` life cycle method.
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想要从 `src/App.vue` 中获取所有待办事项。一个好的地方是在 `mounted` 生命周期方法中做这件事。
- en: To display the to-do list, we will create a `TodoList` component in `src/components/TodoList.vue`
    that takes a `todos` prop, loops through the items, and defers rendering of the
    to-do under a `todo` scoped slot that binds the to-do.
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示待办事项列表，我们将在 `src/components/TodoList.vue` 中创建一个 `TodoList` 组件，该组件接受一个 `todos`
    属性，遍历项目，并在 `todo` 作用域插槽中延迟渲染待办事项，该插槽绑定待办事项。
- en: We can now use the `TodoList` component to render out the *todos* we have already
    fetched in `src/App.vue`.
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用 `TodoList` 组件在 `src/App.vue` 中渲染我们已获取的 *todos*。
- en: We now need to create a `TodoEntry` component where we will implement most of
    the to-do-specific logic. A good practice for components is to have the props
    be very specific to the component’s role. In this case, the properties of the
    `todo` object we will tackle are `id`, `title`, and `completed`, so those should
    be the props that our `TodoEntry` component receives. We will not make `TodoEntry`
    a functional component since we will need a component instance to create HTTP
    requests.
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个`TodoEntry`组件，我们将在这里实现大部分待办事项特定的逻辑。对于组件来说，一个好的做法是让props非常具体地对应组件的角色。在这种情况下，我们将处理的`todo`对象的属性是`id`、`title`和`completed`，因此这些应该是我们的`TodoEntry`组件接收的props。我们不会将`TodoEntry`做成一个函数组件，因为我们需要组件实例来创建HTTP请求。
- en: We will then update `src/App.vue` so that it consumes `TodoEntry` (making sure
    to bind `id`, `title`, and `completed`).
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将更新`src/App.vue`，使其消费`TodoEntry`（确保绑定`id`、`title`和`completed`）。
- en: Add the ability to toggle the `todo`. We will implement the majority of this
    in `src/components/TodoEntry.vue`. We will listen to the `input` change event.
    On changing, we will want to read the new value and send a `PATCH` request to
    `/todos/{todoId}` with an object containing `completed` set to the new value.
    We will also want to emit a `completedChange` event in Vue.js so that the `App`
    component can update the data that’s in memory.
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加切换`todo`的功能。我们将大部分实现放在`src/components/TodoEntry.vue`中。我们将监听`input`变化事件。在变化时，我们将读取新值并向`/todos/{todoId}`发送一个包含`completed`设置为新值的`PATCH`请求。我们还将想要在Vue.js中发出一个`completedChange`事件，以便`App`组件可以更新内存中的数据。
- en: In `App.vue`, we will want to update the relevant `todo` when `completeChange`
    is triggered. Since `completeChange` does not include the ID of the `todo`, we
    will need to read that from the context when setting the `handleCompleteChange`
    function to listen to `completeChange`.
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App.vue`中，当触发`completeChange`时，我们希望更新相关的`todo`。由于`completeChange`不包含`todo`的ID，我们需要在设置`handleCompleteChange`函数以监听`completeChange`时从上下文中读取该ID。
- en: 'The expected output is as follows:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 6.19 – Our to-do app using jsonplaceholder data](img/B18645_06_19.jpg)'
  id: totrans-574
  prefs: []
  type: TYPE_IMG
  zh: '![图6.19 – 使用jsonplaceholder数据的我们的待办事项应用](img/B18645_06_19.jpg)'
- en: Figure 6.19 – Our to-do app using jsonplaceholder data
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19 – 使用jsonplaceholder数据的我们的待办事项应用
- en: Summary
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we have looked at global composition patterns and advanced
    component setups that we can take advantage of to create a reusable code base
    for a Vue.js application. We learned about mixins, plugins, how to use component
    tags for dynamic component rendering, and functional components, both stateful
    and stateless.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了全局组合模式和高级组件设置，我们可以利用这些模式为 Vue.js 应用程序创建一个可重用的代码库。我们学习了混合（mixins）、插件，如何使用组件标签进行动态组件渲染，以及有状态和无状态的函数组件。
- en: So far, we have learned how to build applications in terms of components, mixins,
    and plugins. To build applications that span multiple pages, we need to implement
    routing. This is what we will tackle in the next chapter.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何从组件、混合和插件的角度构建应用程序。要构建跨越多个页面的应用程序，我们需要实现路由。这就是我们在下一章将要解决的问题。
