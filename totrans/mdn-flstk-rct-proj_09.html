<html><head></head><body>
<div id="_idContainer073" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-118"><a id="_idTextAnchor119" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-119" class="calibre5"><a id="_idTextAnchor120" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Adding Authentication with JWT</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">After developing and deploying our first full-stack application, we now have a way for anyone to create posts on our blog. </span><span class="kobospan" id="kobo.3.2">However, since the author is an input field, anyone could enter any author, impersonating others! </span><span class="kobospan" id="kobo.3.3">That’s not good. </span><span class="kobospan" id="kobo.3.4">In this chapter, we are going to add authentication</span><a id="_idIndexMarker376" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.4.1"> with </span><strong class="bold"><span class="kobospan" id="kobo.5.1">JSON Web Token</span></strong><span class="kobospan" id="kobo.6.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.7.1">JWT</span></strong><span class="kobospan" id="kobo.8.1">) and functionalities to sign up and log into our application by adding additional routes using </span><span><span class="kobospan" id="kobo.9.1">React Router.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.10.1">In this chapter, we are going to cover the following </span><span><span class="kobospan" id="kobo.11.1">main topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.12.1">What </span><span><span class="kobospan" id="kobo.13.1">is JWT?</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.14.1">Implementing login, signup, and authenticated routes in the backend </span><span><span class="kobospan" id="kobo.15.1">using JWT</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.16.1">Integrating login and signup in the frontend using React Router </span><span><span class="kobospan" id="kobo.17.1">and JWT</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.18.1">Advanced </span><span><span class="kobospan" id="kobo.19.1">token handling</span></span></li>
</ul>
<h1 id="_idParaDest-120" class="calibre5"><a id="_idTextAnchor121" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.20.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.21.1">Before we start, please install all the requirements from </span><a href="B19385_01.xhtml#_idTextAnchor016" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.22.1">Chapter 1</span></em></span></a><span class="kobospan" id="kobo.23.1">, </span><em class="italic"><span class="kobospan" id="kobo.24.1">Preparing for Full-Stack Development</span></em><span class="kobospan" id="kobo.25.1">, and </span><a href="B19385_02.xhtml#_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.26.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.27.1">, </span><em class="italic"><span class="kobospan" id="kobo.28.1">Getting to Know Node.js </span></em><span><em class="italic"><span class="kobospan" id="kobo.29.1">and MongoDB</span></em></span><span><span class="kobospan" id="kobo.30.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.31.1">The versions listed in those chapters are the ones used in this book. </span><span class="kobospan" id="kobo.31.2">While installing a newer version should not be an issue, please note that certain steps might work differently. </span><span class="kobospan" id="kobo.31.3">If you are having an issue with the code and steps provided in this book, please try using the versions mentioned in </span><a href="B19385_01.xhtml#_idTextAnchor016" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.32.1">Chapter 1</span></em></span></a><span class="kobospan" id="kobo.33.1"> and </span><a href="B19385_02.xhtml#_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.34.1">Chapter 2</span></em></span></a><span><span class="kobospan" id="kobo.35.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.36.1">You can find the code for this chapter on </span><span><span class="kobospan" id="kobo.37.1">GitHub: </span></span><a href="https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch6" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.38.1">https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch6</span></span></a><span><span class="kobospan" id="kobo.39.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.40.1">The CiA video for this chapter can be found </span><span><span class="kobospan" id="kobo.41.1">at: </span></span><a href="https://youtu.be/LloHmkgRLWk" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.42.1">https://youtu.be/LloHmkgRLWk</span></span></a><span><span class="kobospan" id="kobo.43.1">.</span></span></p>
<h1 id="_idParaDest-121" class="calibre5"><a id="_idTextAnchor122" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.44.1">What is JWT?</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.45.1">JWT, pronounced “jot”, is an</span><a id="_idIndexMarker377" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.46.1"> open industry standard (RFC 7519) for safely passing claims between multiple parties. </span><span class="kobospan" id="kobo.46.2">Claims can be information about a certain party or object, such as the email address, user ID, and roles of a user. </span><span class="kobospan" id="kobo.46.3">In our case, we will pass JWTs between our backend </span><span><span class="kobospan" id="kobo.47.1">and frontend.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.48.1">JWT is used by many products and services and is supported by third-party authentication providers, such as Auth0, Okta, and Firebase Auth. </span><span class="kobospan" id="kobo.48.2">It is easy to parse JWTs as we only need to base64 decode them and parse the JSON string. </span><span class="kobospan" id="kobo.48.3">After verifying the signature, we can be sure that the JWT is authentic and trust the claims </span><span><span class="kobospan" id="kobo.49.1">within it.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.50.1">JWTs consist of the </span><span><span class="kobospan" id="kobo.51.1">following components:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.52.1">Header</span></strong><span class="kobospan" id="kobo.53.1">: Containing</span><a id="_idIndexMarker378" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.54.1"> the algorithm and </span><span><span class="kobospan" id="kobo.55.1">token type</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.56.1">Payload</span></strong><span class="kobospan" id="kobo.57.1">: Containing </span><a id="_idIndexMarker379" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.58.1">the data/claims of </span><span><span class="kobospan" id="kobo.59.1">the token</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.60.1">Signature</span></strong><span class="kobospan" id="kobo.61.1">: For verifying </span><a id="_idIndexMarker380" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.62.1">that the token was created by a </span><span><span class="kobospan" id="kobo.63.1">legit source</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.64.1">These three components form a JWT as they’re joined into a single string, separated by a period (</span><strong class="source-inline"><span class="kobospan" id="kobo.65.1">.</span></strong><span class="kobospan" id="kobo.66.1">), </span><span><span class="kobospan" id="kobo.67.1">as follows:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.68.1">
header.payload.signature</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.69.1">Let’s look at each </span><span><span class="kobospan" id="kobo.70.1">component separately.</span></span></p>
<h2 id="_idParaDest-122" class="calibre7"><a id="_idTextAnchor123" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.71.1">JWT header</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.72.1">The JWT </span><a id="_idIndexMarker381" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.73.1">header typically consists of a token type (in our case, JWT), specified by the </span><strong class="source-inline"><span class="kobospan" id="kobo.74.1">typ</span></strong><span class="kobospan" id="kobo.75.1"> property, and the algorithm used to create the signature (in our case, we will use HMAC SHA256, a SHA256 hash-based message authentication code), specified by the </span><strong class="source-inline"><span class="kobospan" id="kobo.76.1">alg</span></strong><span class="kobospan" id="kobo.77.1"> property. </span><span class="kobospan" id="kobo.77.2">The header is defined as a JSON object, </span><span><span class="kobospan" id="kobo.78.1">like so:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.79.1">
{
  "alg": "HS256",
  "typ": "JWT"
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.80.1">This</span><a id="_idIndexMarker382" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.81.1"> JSON object is then base64 encoded and forms the first part of </span><span><span class="kobospan" id="kobo.82.1">the JWT.</span></span></p>
<h2 id="_idParaDest-123" class="calibre7"><a id="_idTextAnchor124" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.83.1">JWT payload</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.84.1">The main part of the</span><a id="_idIndexMarker383" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.85.1"> JWT is the payload, which contains all claims. </span><span class="kobospan" id="kobo.85.2">Claims are information about an entity (such as the user) and additional data. </span><span class="kobospan" id="kobo.85.3">The JWT standard distinguishes between three types </span><span><span class="kobospan" id="kobo.86.1">of claims:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.87.1">Registered claims</span></strong><span class="kobospan" id="kobo.88.1">: These are</span><a id="_idIndexMarker384" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.89.1"> predefined claims and it’s recommended that they’re set. </span><span class="kobospan" id="kobo.89.2">They include information about </span><span><span class="kobospan" id="kobo.90.1">the following:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.91.1">The issuer (</span><strong class="source-inline1"><span class="kobospan" id="kobo.92.1">iss</span></strong><span class="kobospan" id="kobo.93.1">), which is the entity that created </span><span><span class="kobospan" id="kobo.94.1">the token.</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.95.1">The expiration time (</span><strong class="source-inline1"><span class="kobospan" id="kobo.96.1">exp</span></strong><span class="kobospan" id="kobo.97.1">), which tells us when the </span><span><span class="kobospan" id="kobo.98.1">token expires.</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.99.1">The subject (</span><strong class="source-inline1"><span class="kobospan" id="kobo.100.1">sub</span></strong><span class="kobospan" id="kobo.101.1">), which tells us about the entity identified by the token (such as the user who generated the token during </span><span><span class="kobospan" id="kobo.102.1">a login).</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.103.1">The audience (</span><strong class="source-inline1"><span class="kobospan" id="kobo.104.1">aud</span></strong><span class="kobospan" id="kobo.105.1">), which tells us about the intended recipients of </span><span><span class="kobospan" id="kobo.106.1">the token.</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.107.1">The issued at time (</span><strong class="source-inline1"><span class="kobospan" id="kobo.108.1">iat</span></strong><span class="kobospan" id="kobo.109.1">), which tells us when the token </span><span><span class="kobospan" id="kobo.110.1">was created.</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.111.1">The not before time (</span><strong class="source-inline1"><span class="kobospan" id="kobo.112.1">nbf</span></strong><span class="kobospan" id="kobo.113.1">), which specifies a time before which the token is not </span><span><span class="kobospan" id="kobo.114.1">valid yet.</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.115.1">The JWT ID (</span><strong class="source-inline1"><span class="kobospan" id="kobo.116.1">jti</span></strong><span class="kobospan" id="kobo.117.1">), which provides a unique identifier for the JWT. </span><span class="kobospan" id="kobo.117.2">It’s used to prevent </span><a id="_idIndexMarker385" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.118.1">JWTs from </span><span><span class="kobospan" id="kobo.119.1">being replayed.</span></span></li></ul></li>
</ul>
<p class="callout-heading"><span class="kobospan" id="kobo.120.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.121.1">The JSON object properties defined in the JWT standard are all three-letter names to keep the JWT as compact </span><span><span class="kobospan" id="kobo.122.1">as possible.</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.123.1">Public claims</span></strong><span class="kobospan" id="kobo.124.1">: These </span><a id="_idIndexMarker386" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.125.1">are additional claims that are commonly used and shared across many services. </span><span class="kobospan" id="kobo.125.2">A list of those can be </span><a id="_idIndexMarker387" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.126.1">found on the </span><strong class="bold"><span class="kobospan" id="kobo.127.1">Internet Assigned Numbers Authority</span></strong><span class="kobospan" id="kobo.128.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.129.1">IANA</span></strong><span class="kobospan" id="kobo.130.1">) website: </span><a href="https://www.iana.org/assignments/jwt/jwt.xhtml" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.131.1">https://www.iana.org/assignments/jwt/jwt.xhtml</span></a><span class="kobospan" id="kobo.132.1">. </span><span class="kobospan" id="kobo.132.2">If we want to store additional information, we should always consult this list first to see if we can use a standardized </span><span><span class="kobospan" id="kobo.133.1">claim name.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.134.1">Private claims</span></strong><span class="kobospan" id="kobo.135.1">: These </span><a id="_idIndexMarker388" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.136.1">are custom-defined claims, which are neither registered nor public. </span><span class="kobospan" id="kobo.136.2">If we need a special claim that isn’t defined yet, we can make a private claim that only our services </span><span><span class="kobospan" id="kobo.137.1">will understand.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.138.1">All claims are optional, but it makes sense to at least include one claim to identify the subject, such as the </span><strong class="source-inline"><span class="kobospan" id="kobo.139.1">sub</span></strong> <span><span class="kobospan" id="kobo.140.1">registered claim.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.141.1">Putting together what we’ve learned, we can create the following </span><span><span class="kobospan" id="kobo.142.1">example payload:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.143.1">
{
  "sub": "1234567890",
  "name": "Daniel Bugl",
  "admin": true
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.144.1">In our example, the </span><strong class="source-inline"><span class="kobospan" id="kobo.145.1">sub</span></strong><span class="kobospan" id="kobo.146.1"> claim is a registered claim, the </span><strong class="source-inline"><span class="kobospan" id="kobo.147.1">name</span></strong><span class="kobospan" id="kobo.148.1"> claim is a public claim, and the </span><strong class="source-inline"><span class="kobospan" id="kobo.149.1">admin</span></strong><span class="kobospan" id="kobo.150.1"> claim is a </span><span><span class="kobospan" id="kobo.151.1">private claim.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.152.1">The payload is also base64 encoded and forms the second part of the JWT. </span><span class="kobospan" id="kobo.152.2">As such, this information is publicly readable by anyone who has access to the token. </span><span class="kobospan" id="kobo.152.3">Do not put secret information into the payload or header of a JWT! </span><span class="kobospan" id="kobo.152.4">However, the information cannot be </span><em class="italic"><span class="kobospan" id="kobo.153.1">changed</span></em><span class="kobospan" id="kobo.154.1"> without invalidating the existing signature, making all claims tamper-proof. </span><span class="kobospan" id="kobo.154.2">Only a backend service with access to the private key can generate a new signature to create a </span><span><span class="kobospan" id="kobo.155.1">valid JWT.</span></span></p>
<h2 id="_idParaDest-124" class="calibre7"><a id="_idTextAnchor125" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.156.1">JWT signature</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.157.1">The </span><a id="_idIndexMarker389" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.158.1">final part of a JWT is its signature. </span><span class="kobospan" id="kobo.158.2">The signature is what proves that all the information that we’ve defined up until now has not been tampered with. </span><span class="kobospan" id="kobo.158.3">The signature is created by taking the base64-encoded header and payload, joining those strings with a period symbol, and using the specified algorithm to sign it with a </span><span><span class="kobospan" id="kobo.159.1">secret key:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.160.1">
HMACSHA256(
  base64UrlEncode(header) + "." </span><span class="kobospan1" id="kobo.160.2">+ base64UrlEncode(payload),
  secret
)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.161.1">Now that we’ve learned about the different components of a JWT, let’s put this all together to create a </span><span><span class="kobospan" id="kobo.162.1">valid JWT.</span></span></p>
<h2 id="_idParaDest-125" class="calibre7"><a id="_idTextAnchor126" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.163.1">Creating a JWT</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.164.1"> Follow these steps</span><a id="_idIndexMarker390" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.165.1"> to create </span><span><span class="kobospan" id="kobo.166.1">a JWT:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.167.1">Go to the </span><a href="https://jwt.io/" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.168.1">https://jwt.io/</span></a><span class="kobospan" id="kobo.169.1"> website and scroll down to the </span><span><strong class="bold"><span class="kobospan" id="kobo.170.1">Debugger</span></strong></span><span><span class="kobospan" id="kobo.171.1"> section.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.172.1">Enter our previously defined header </span><span><span class="kobospan" id="kobo.173.1">and payload.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.174.1">Enter </span><strong class="source-inline1"><span class="kobospan" id="kobo.175.1">full-stack</span></strong><span class="kobospan" id="kobo.176.1"> as </span><span><span class="kobospan" id="kobo.177.1">the secret.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.178.1">The encoded JWT should update on the fly as you’re changing </span><span><span class="kobospan" id="kobo.179.1">the values.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.180.1">As you can see, we have successfully created our </span><span><span class="kobospan" id="kobo.181.1">first JWT:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer067">
<span class="kobospan" id="kobo.182.1"><img alt="Figure 6.1 – Our first JWT, created with the jwt.io debugger" src="image/B19385_06_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.183.1">Figure 6.1 – Our first JWT, created with the jwt.io debugger</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.184.1">The</span><a id="_idIndexMarker391" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.185.1"> generated JWT consists of three components, each of them base64-encoded and separated by periods. </span><span class="kobospan" id="kobo.185.2">In the debugger, they are highlighted in three different colors. </span><span class="kobospan" id="kobo.185.3">Try changing the base64 string in the “Encoded” section by removing some characters; you will see that the JWT is now invalid due to an ”Invalid Signature” issue. </span><span class="kobospan" id="kobo.185.4">Now that we’ve created our first JWT, let’s learn how to </span><span><span class="kobospan" id="kobo.186.1">use it.</span></span></p>
<h2 id="_idParaDest-126" class="calibre7"><a id="_idTextAnchor127" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.187.1">Using JWT</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.188.1">In the login</span><a id="_idIndexMarker392" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.189.1"> process, we are going to generate a JWT for the logged-in user in the backend. </span><span class="kobospan" id="kobo.189.2">This JWT will be returned to the user’s browser. </span><span class="kobospan" id="kobo.189.3">When the user wants to access a protected route, we can send the JWT to the backend server by using the </span><strong class="source-inline"><span class="kobospan" id="kobo.190.1">Authorization</span></strong><span class="kobospan" id="kobo.191.1"> header with the </span><strong class="source-inline"><span class="kobospan" id="kobo.192.1">Bearer</span></strong><span class="kobospan" id="kobo.193.1"> schema, </span><span><span class="kobospan" id="kobo.194.1">as follows:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.195.1">
Authorization: Bearer &lt;token&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.196.1">The backend</span><a id="_idIndexMarker393" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.197.1"> can then check for this header, verify the signature of the token, and grant the user access to certain routes. </span><span class="kobospan" id="kobo.197.2">By sending the token in a header instead of a cookie, we don’t have to deal with CORS issues that we would have when dealing </span><span><span class="kobospan" id="kobo.198.1">with cookies.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.199.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.200.1">Be careful not to send too much data in the header since some servers do not accept more than 8 KB in headers. </span><span class="kobospan" id="kobo.200.2">This means that, for example, complex role information should not be stored in the JWT claims as it might take up too much space. </span><span class="kobospan" id="kobo.200.3">Instead, this kind of information could be stored in the database associated with a user ID from </span><span><span class="kobospan" id="kobo.201.1">the JWT.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.202.1">An interesting advantage of using a JWT is that the authentication server and the actual backend for our app do not have to be the same. </span><span class="kobospan" id="kobo.202.2">We could have a separate authentication service, get a JWT, and in the backend verify the signature of the JWTs to guarantee that they were generated by the authentication service. </span><span class="kobospan" id="kobo.202.3">This allows us to use external services for authentication, such as Auth0, Okta, or </span><span><span class="kobospan" id="kobo.203.1">Firebase Auth.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.204.1">The following diagram shows the authorization flow for </span><span><span class="kobospan" id="kobo.205.1">a JWT:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer068">
<span class="kobospan" id="kobo.206.1"><img alt="Figure 6.2 – Authorization flow for a JWT" src="image/B19385_06_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.207.1">Figure 6.2 – Authorization flow for a JWT</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.208.1">As we can see, the</span><a id="_idIndexMarker394" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.209.1"> application requests authorization to the authorization server, which can also be either a third-party provider, a separate service, or part of the backend service. </span><span class="kobospan" id="kobo.209.2">Then, when authorization is granted (if the login details are correct), the authorization server returns a JWT. </span><span class="kobospan" id="kobo.209.3">This JWT can then be used to access protected routes on APIs. </span><span class="kobospan" id="kobo.209.4">Before granting access, the JWT signature is validated to ensure that it has not been </span><span><span class="kobospan" id="kobo.210.1">tampered with.</span></span></p>
<h2 id="_idParaDest-127" class="calibre7"><a id="_idTextAnchor128" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.211.1">Storing JWT</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.212.1">We should take great care </span><a id="_idIndexMarker395" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.213.1">about where we store the JWT. </span><span class="kobospan" id="kobo.213.2">Local storage is </span><em class="italic"><span class="kobospan" id="kobo.214.1">not</span></em><span class="kobospan" id="kobo.215.1"> a good way to store authentication information such as a JWT. </span><span class="kobospan" id="kobo.215.2">Cross-site scripting can be used to steal all data in local storage. </span><span class="kobospan" id="kobo.215.3">For short-lived tokens, we can store them in a JavaScript runtime variable (such as a React context). </span><span class="kobospan" id="kobo.215.4">For longer-term storage, we could use an </span><strong class="source-inline"><span class="kobospan" id="kobo.216.1">httpOnly</span></strong><span class="kobospan" id="kobo.217.1"> cookie, which has additional </span><span><span class="kobospan" id="kobo.218.1">security guarantees.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.219.1">Now that we’ve learned how JWT works, let’s put theory into practice and implement login, signup, and authenticated routes in the backend </span><span><span class="kobospan" id="kobo.220.1">using JWT.</span></span></p>
<h1 id="_idParaDest-128" class="calibre5"><a id="_idTextAnchor129" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.221.1">Implementing login, signup, and authenticated routes in the backend using JWTs</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.222.1">Now that we’ve learned about JWTs, we’ll implement them in our backend. </span><span class="kobospan" id="kobo.222.2">First, we need to create a user model in our database, after which we can create routes to sign up and log into our app. </span><span class="kobospan" id="kobo.222.3">Finally, we will implement authenticated routes that are only accessible with </span><span><span class="kobospan" id="kobo.223.1">a JWT.</span></span></p>
<h2 id="_idParaDest-129" class="calibre7"><a id="_idTextAnchor130" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.224.1">Creating the user model</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.225.1">We’ll start the backend </span><a id="_idIndexMarker396" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.226.1">implementation by creating a user model, </span><span><span class="kobospan" id="kobo.227.1">as follows:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.228.1">Copy the </span><strong class="source-inline1"><span class="kobospan" id="kobo.229.1">ch5</span></strong><span class="kobospan" id="kobo.230.1"> folder to a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.231.1">ch6</span></strong><span class="kobospan" id="kobo.232.1"> folder, </span><span><span class="kobospan" id="kobo.233.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.234.1">$ cp -R ch5 ch6</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.235.1">Open the </span><strong class="source-inline1"><span class="kobospan" id="kobo.236.1">ch6</span></strong><span class="kobospan" id="kobo.237.1"> folder in </span><span><span class="kobospan" id="kobo.238.1">VS Code.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.239.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.240.1">backend/src/db/models/user.js</span></strong><span class="kobospan" id="kobo.241.1"> file and define a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.242.1">userSchema</span></strong> <span><span class="kobospan" id="kobo.243.1">inside it:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.244.1">
import mongoose, { Schema } from 'mongoose'
const userSchema = new Schema({</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.245.1">A user should have a required unique </span><strong class="source-inline1"><span class="kobospan" id="kobo.246.1">username</span></strong><span class="kobospan" id="kobo.247.1"> and a </span><span><span class="kobospan" id="kobo.248.1">required </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.249.1">password</span></strong></span><span><span class="kobospan" id="kobo.250.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.251.1">
  username: { type: String, required: true, unique: true },
  password: { type: String, required: true },
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.252.1">Create and export </span><span><span class="kobospan" id="kobo.253.1">the model:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.254.1">
export const User = mongoose.model('user', userSchema)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.255.1">At this point, let’s also adjust the post model so that we can store a reference to a user ID instead of the username as the author. </span><span class="kobospan" id="kobo.255.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.256.1">backend/src/db/models/post.js</span></strong><span class="kobospan" id="kobo.257.1">, </span><span><span class="kobospan" id="kobo.258.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.259.1">
    author: </span><strong class="bold1"><span class="kobospan1" id="kobo.260.1">{ type: Schema.Types.ObjectId, ref: 'user', required: true }</span></strong><span class="kobospan1" id="kobo.261.1">,</span></pre><p class="calibre3"><span class="kobospan" id="kobo.262.1">We changed the type to </span><strong class="source-inline"><span class="kobospan" id="kobo.263.1">ObjectId</span></strong><span class="kobospan" id="kobo.264.1">, with a reference to the </span><strong class="source-inline"><span class="kobospan" id="kobo.265.1">user</span></strong><span class="kobospan" id="kobo.266.1"> model, and made </span><strong class="source-inline"><span class="kobospan" id="kobo.267.1">author</span></strong><span class="kobospan" id="kobo.268.1"> required (as you will need to be logged in to create a post after we add an </span><a id="_idIndexMarker397" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.269.1">authenticated route later in </span><span><span class="kobospan" id="kobo.270.1">this chapter).</span></span></p><p class="calibre3"><span class="kobospan" id="kobo.271.1">Making </span><strong class="source-inline"><span class="kobospan" id="kobo.272.1">author</span></strong><span class="kobospan" id="kobo.273.1"> required means that the unit tests will need to be adjusted, but doing so is left as an exercise </span><span><span class="kobospan" id="kobo.274.1">for you.</span></span></p></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.275.1">Now that we’ve successfully created the user model, let’s move on to creating the signup service so that we have a way to create </span><span><span class="kobospan" id="kobo.276.1">new users.</span></span></p>
<h2 id="_idParaDest-130" class="calibre7"><a id="_idTextAnchor131" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.277.1">Creating the signup service</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.278.1">When a user signs up, we need to </span><a id="_idIndexMarker398" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.279.1">hash the password provided by the user before storing it in the database. </span><span class="kobospan" id="kobo.279.2">We should never store passwords in plaintext as that would mean that if our database gets leaked, an attacker will have access to the passwords of all users. </span><span class="kobospan" id="kobo.279.3">Hashing is a one-way function that turns a string into a different string in a deterministic way. </span><span class="kobospan" id="kobo.279.4">This means that, for example, if we do </span><strong class="source-inline"><span class="kobospan" id="kobo.280.1">hash("password1")</span></strong><span class="kobospan" id="kobo.281.1">, we get a specific string every time we do it. </span><span class="kobospan" id="kobo.281.2">However, if we do </span><strong class="source-inline"><span class="kobospan" id="kobo.282.1">hash("password2")</span></strong><span class="kobospan" id="kobo.283.1">, we get a completely different string. </span><span class="kobospan" id="kobo.283.2">By choosing a good hash function, we can ensure that reversing a hash is so computationally expensive that it is impossible to do in a reasonable time. </span><span class="kobospan" id="kobo.283.3">When the user signs up, we can store the hash of their password. </span><span class="kobospan" id="kobo.283.4">When a user then enters their password to log in, we can hash their entered password again and compare it to the hash in </span><span><span class="kobospan" id="kobo.284.1">the database.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.285.1">Let’s start implementing the </span><a id="_idIndexMarker399" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.286.1">signup service with </span><span><span class="kobospan" id="kobo.287.1">hashed passwords:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.288.1">Install the </span><strong class="source-inline1"><span class="kobospan" id="kobo.289.1">bcrypt</span></strong><span class="kobospan" id="kobo.290.1"> npm package. </span><span class="kobospan" id="kobo.290.2">We are going to use this to hash the password before </span><span><span class="kobospan" id="kobo.291.1">storing it:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.292.1">$ cd backend</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.293.1">$ npm install bcrypt@5.1.1</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.294.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.295.1">backend/src/services/users.js</span></strong><span class="kobospan" id="kobo.296.1"> file and import </span><strong class="source-inline1"><span class="kobospan" id="kobo.297.1">bcrypt</span></strong><span class="kobospan" id="kobo.298.1"> and the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.299.1">User</span></strong></span><span><span class="kobospan" id="kobo.300.1"> model:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.301.1">
import bcrypt from 'bcrypt'
import { User } from '../db/models/user.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.302.1">Define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.303.1">createUser</span></strong><span class="kobospan" id="kobo.304.1"> function that takes </span><strong class="source-inline1"><span class="kobospan" id="kobo.305.1">username</span></strong><span class="kobospan" id="kobo.306.1"> and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.307.1">password</span></strong></span><span><span class="kobospan" id="kobo.308.1"> values:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.309.1">
export async function createUser({ username, password }) {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.310.1">Inside this function, we use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.311.1">bcrypt.hash</span></strong><span class="kobospan" id="kobo.312.1"> function to create a hash from the plaintext password using 10 salt rounds (repeating the hashing 10 times to make it even harder to </span><span><span class="kobospan" id="kobo.313.1">reverse it):</span></span><pre class="source-code"><span class="kobospan1" id="kobo.314.1">
  const hashedPassword = await bcrypt.hash(password, 10)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.315.1">Now, we can</span><a id="_idIndexMarker400" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.316.1"> create a new user and store it in </span><span><span class="kobospan" id="kobo.317.1">our database:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.318.1">
  const user = new User({ username, password: hashedPassword })
  return await user.save()
}</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.319.1">For brevity, we won’t cover creating tests for the user services. </span><span class="kobospan" id="kobo.319.2">Refer to </span><a href="B19385_03_split_000.xhtml#_idTextAnchor050" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.320.1">Chapter 3</span></em></span></a><span class="kobospan" id="kobo.321.1">, </span><em class="italic"><span class="kobospan" id="kobo.322.1">Implementing a Backend Service Using Express, Mongoose ODM, and Jest</span></em><span class="kobospan" id="kobo.323.1">, for information on how to create tests for your service functions. </span><span class="kobospan" id="kobo.323.2">You can write similar tests to what we did for the posts </span><span><span class="kobospan" id="kobo.324.1">service functions.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.325.1">After creating the signup service, we can create the </span><span><span class="kobospan" id="kobo.326.1">signup route.</span></span></p>
<h2 id="_idParaDest-131" class="calibre7"><a id="_idTextAnchor132" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.327.1">Creating the signup route</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.328.1">Now, let’s expose the signup service</span><a id="_idIndexMarker401" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.329.1"> function by adding an API route </span><span><span class="kobospan" id="kobo.330.1">for it:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.331.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.332.1">backend/src/routes/users.js</span></strong><span class="kobospan" id="kobo.333.1"> file and import the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.334.1">createUser</span></strong></span><span><span class="kobospan" id="kobo.335.1"> service:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.336.1">
import { createUser } from '../services/users.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.337.1">Define a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.338.1">userRoutes</span></strong><span class="kobospan" id="kobo.339.1"> function and expose a </span><strong class="source-inline1"><span class="kobospan" id="kobo.340.1">POST /api/v1/user/signup</span></strong><span class="kobospan" id="kobo.341.1"> route. </span><span class="kobospan" id="kobo.341.2">This route creates a new user from the request body and return </span><span><span class="kobospan" id="kobo.342.1">the username:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.343.1">
export function userRoutes(app) {
  app.post('/api/v1/user/signup', async (req, res) =&gt; {
    try {
      const user = await createUser(req.body)
      return res.status(201).json({ username: user.username })
    } catch (err) {
      return res.status(400).json({
        error: 'failed to create the user, does the username already exist?'
</span><span class="kobospan1" id="kobo.343.2">      })
    }
  })
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.344.1">In this case, we define a singular </span><strong class="source-inline"><span class="kobospan" id="kobo.345.1">user</span></strong><span class="kobospan" id="kobo.346.1"> route instead of calling it </span><strong class="source-inline"><span class="kobospan" id="kobo.347.1">users</span></strong><span class="kobospan" id="kobo.348.1"> as we are only dealing with one user at a time. </span><span class="kobospan" id="kobo.348.2">To keep things simple, the error handling is very rudimentary. </span><span class="kobospan" id="kobo.348.3">It would be a good idea to distinguish between the different errors that can happen and show a different error message, depending on </span><span><span class="kobospan" id="kobo.349.1">the error.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.350.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.351.1">backend/src/app.js</span></strong><span class="kobospan" id="kobo.352.1"> and</span><a id="_idIndexMarker402" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.353.1"> import the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.354.1">userRoutes</span></strong></span><span><span class="kobospan" id="kobo.355.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.356.1">
import { postRoutes } from './routes/posts.js'
</span><strong class="bold1"><span class="kobospan1" id="kobo.357.1">import { userRoutes } from './routes/users.js'</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.358.1">In the same file, call the </span><strong class="source-inline1"><span class="kobospan" id="kobo.359.1">userRoutes</span></strong><span class="kobospan" id="kobo.360.1"> function after the </span><strong class="source-inline1"><span class="kobospan" id="kobo.361.1">postRoutes</span></strong><span class="kobospan" id="kobo.362.1"> function to </span><span><span class="kobospan" id="kobo.363.1">mount them:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.364.1">
postRoutes(app)
</span><strong class="bold1"><span class="kobospan1" id="kobo.365.1">userRoutes(app)</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.366.1">Make sure the </span><strong class="source-inline1"><span class="kobospan" id="kobo.367.1">dbserver</span></strong><span class="kobospan" id="kobo.368.1"> container is running </span><span><span class="kobospan" id="kobo.369.1">in Docker.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.370.1">Start the backend by running the following command in a Terminal inside the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.371.1">backend/</span></strong></span><span><span class="kobospan" id="kobo.372.1"> folder:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.373.1">$ cd backend </span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.374.1">$ npm run dev</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.375.1">Now, make a request to the new </span><strong class="source-inline1"><span class="kobospan" id="kobo.376.1">POST /api/v1/user/signup</span></strong><span class="kobospan" id="kobo.377.1"> route. </span><span class="kobospan" id="kobo.377.2">You will see that creating a user works if </span><strong class="source-inline1"><span class="kobospan" id="kobo.378.1">username</span></strong><span class="kobospan" id="kobo.379.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.380.1">password</span></strong><span class="kobospan" id="kobo.381.1"> values are provided properly. </span><span class="kobospan" id="kobo.381.2">Enter the following code in your browser console while the backend is running, on a blank tab or </span><span><span class="kobospan" id="kobo.382.1">at </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.383.1">http://localhost:3001/</span></strong></span><span><span class="kobospan" id="kobo.384.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.385.1">
const res = await fetch('http://localhost:3001/api/v1/user/signup', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ username: 'dan', password: 'hunter2' })
})
console.log(await res.json())</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.386.1">If we try creating </span><a id="_idIndexMarker403" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.387.1">another user with the same username (by executing the same fetch again), it will fail because the </span><strong class="source-inline1"><span class="kobospan" id="kobo.388.1">username</span></strong><span class="kobospan" id="kobo.389.1"> field is defined to be unique </span><span><span class="kobospan" id="kobo.390.1">in Mongoose.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.391.1">Now that we have successfully created our first user, let’s continue by creating the login service to allow our user to </span><span><span class="kobospan" id="kobo.392.1">log in.</span></span></p>
<h2 id="_idParaDest-132" class="calibre7"><a id="_idTextAnchor133" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.393.1">Creating the login service</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.394.1">So far, we have only created a user in our </span><a id="_idIndexMarker404" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.395.1">database. </span><span class="kobospan" id="kobo.395.2">As we aren’t authorizing the user yet, we haven’t dealt with JWTs yet. </span><span class="kobospan" id="kobo.395.3">Let’s start doing </span><span><span class="kobospan" id="kobo.396.1">that now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.397.1">Open a new Terminal and install the </span><strong class="source-inline1"><span class="kobospan" id="kobo.398.1">jsonwebtoken</span></strong><span class="kobospan" id="kobo.399.1"> library, which contains functions to deal with the creation and verification </span><span><span class="kobospan" id="kobo.400.1">of JWTs:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.401.1">$ cd backend</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.402.1">$ npm install jsonwebtoken@9.0.2</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.403.1">Edit the </span><strong class="source-inline1"><span class="kobospan" id="kobo.404.1">backend/src/services/users.js</span></strong><span class="kobospan" id="kobo.405.1"> file and import </span><strong class="source-inline1"><span class="kobospan" id="kobo.406.1">jwt</span></strong><span class="kobospan" id="kobo.407.1"> from the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.408.1">jsonwebtoken</span></strong></span><span><span class="kobospan" id="kobo.409.1"> library:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.410.1">
import jwt from 'jsonwebtoken'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.411.1">Define a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.412.1">loginUser</span></strong><span class="kobospan" id="kobo.413.1"> function, which takes a username </span><span><span class="kobospan" id="kobo.414.1">and password:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.415.1">
export async function loginUser({ username, password }) {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.416.1">Now, fetch a user with the given </span><strong class="source-inline1"><span class="kobospan" id="kobo.417.1">username</span></strong><span class="kobospan" id="kobo.418.1"> from </span><span><span class="kobospan" id="kobo.419.1">our database:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.420.1">
  const user = await User.findOne({ username })
  if (!user) {
    throw new Error('invalid username!')
  }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.421.1">Then, use </span><strong class="source-inline1"><span class="kobospan" id="kobo.422.1">bcrypt.compare</span></strong><span class="kobospan" id="kobo.423.1"> to compare the entered password to the hashed password from </span><span><span class="kobospan" id="kobo.424.1">the database:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.425.1">
  const isPasswordCorrect = await bcrypt.compare(password, user.password)
  if (!isPasswordCorrect) {
    throw new Error('invalid password!')
  }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.426.1">If the user </span><a id="_idIndexMarker405" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.427.1">correctly enters a username and password, we use </span><strong class="source-inline1"><span class="kobospan" id="kobo.428.1">jwt.sign()</span></strong><span class="kobospan" id="kobo.429.1"> to create a new JWT and sign it with a secret. </span><span class="kobospan" id="kobo.429.2">For the secret, we use an </span><span><span class="kobospan" id="kobo.430.1">environment variable:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.431.1">
  const token = jwt.sign({ sub: user._id }, process.env.JWT_SECRET, {
    expiresIn: '24h',
  })</span></pre><p class="calibre3"><span class="kobospan" id="kobo.432.1">In the last argument, we also specify that our token should be valid for </span><span><span class="kobospan" id="kobo.433.1">24 hours.</span></span></p></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.434.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.435.1">We are using the user ID, not the username, to identify the user. </span><span class="kobospan" id="kobo.435.2">This is done to future-proof the system as the user ID is a value that will never change. </span><span class="kobospan" id="kobo.435.3">In the future, we might want to add a way to change the username. </span><span class="kobospan" id="kobo.435.4">It would be hard to deal with such a change if we always use the username to identify </span><span><span class="kobospan" id="kobo.436.1">the user.</span></span></p>
<ol class="calibre15">
<li value="7" class="calibre11"><span class="kobospan" id="kobo.437.1">Lastly, we return </span><span><span class="kobospan" id="kobo.438.1">the token:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.439.1">
  return token
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.440.1">Now, we define the </span><strong class="source-inline1"><span class="kobospan" id="kobo.441.1">JWT_SECRET</span></strong><span class="kobospan" id="kobo.442.1"> environment variable by editing the </span><strong class="source-inline1"><span class="kobospan" id="kobo.443.1">.</span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.444.1">env</span></strong></span><span><span class="kobospan" id="kobo.445.1"> file:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.446.1">
JWT_SECRET=replace-with-random-secret</span></pre><p class="calibre3"><span class="kobospan" id="kobo.447.1">Make sure you generate a safe JWT secret for the production environment, which you never expose or use in development environments or for debugging! </span><span class="kobospan" id="kobo.447.2">If you want to deploy your app to Google Cloud Run again, you would also need to add this secret as an environment </span><span><span class="kobospan" id="kobo.448.1">variable there.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.449.1">We’ll also </span><a id="_idIndexMarker406" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.450.1">add one to </span><strong class="source-inline1"><span class="kobospan" id="kobo.451.1">.env.template</span></strong><span class="kobospan" id="kobo.452.1"> as </span><span><span class="kobospan" id="kobo.453.1">an example:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.454.1">
JWT_SECRET=replace-with-random-secret</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.455.1">After successfully creating a login service to create and sign JWTs, we can create the </span><span><span class="kobospan" id="kobo.456.1">login route.</span></span></p>
<h2 id="_idParaDest-133" class="calibre7"><a id="_idTextAnchor134" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.457.1">Creating the login route</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.458.1">We still need to expose the login</span><a id="_idIndexMarker407" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.459.1"> service as an API route for users to be able to log in. </span><span class="kobospan" id="kobo.459.2">Let’s do </span><span><span class="kobospan" id="kobo.460.1">that now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.461.1">Edit the </span><strong class="source-inline1"><span class="kobospan" id="kobo.462.1">backend/src/routes/users.js</span></strong><span class="kobospan" id="kobo.463.1"> file and import the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.464.1">loginUser</span></strong></span><span><span class="kobospan" id="kobo.465.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.466.1">
import { createUser</span><strong class="bold1"><span class="kobospan1" id="kobo.467.1">, loginUser</span></strong><span class="kobospan1" id="kobo.468.1"> } from '../services/users.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.469.1">Add a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.470.1">POST /api/v1/user/login</span></strong><span class="kobospan" id="kobo.471.1"> route inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.472.1">userRoutes</span></strong><span class="kobospan" id="kobo.473.1"> function, where we call the </span><strong class="source-inline1"><span class="kobospan" id="kobo.474.1">loginUser</span></strong><span class="kobospan" id="kobo.475.1"> function and return </span><span><span class="kobospan" id="kobo.476.1">the token:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.477.1">
  app.post('/api/v1/user/login', async (req, res) =&gt; {
    try {
      const token = await loginUser(req.body)
      return res.status(200).send({ token })
    } catch (err) {
      return res.status(400).send({
        error: 'login failed, did you enter the correct username/password?'
</span><span class="kobospan1" id="kobo.477.2">      })
    }
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.478.1">If the backend is </span><a id="_idIndexMarker408" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.479.1">not running anymore, start it again. </span><span class="kobospan" id="kobo.479.2">Then, make a request to </span><strong class="source-inline1"><span class="kobospan" id="kobo.480.1">/api/v1/user/login</span></strong><span class="kobospan" id="kobo.481.1"> to test it out by entering the following code in your </span><span><span class="kobospan" id="kobo.482.1">browser console:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.483.1">
const res = await fetch('http://localhost:3001/api/v1/user/login', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ username: 'dan', password: 'hunter2' })
})
console.log(await res.json())</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.484.1">We have successfully created a valid JWT! </span><span class="kobospan" id="kobo.484.2">To verify that the JWT is valid, we can paste it into the debugger at </span><a href="https://jwt.io/" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.485.1">https://jwt.io/</span></a><span class="kobospan" id="kobo.486.1">. </span><span class="kobospan" id="kobo.486.2">Make sure that you also change the secret in the </span><strong class="bold"><span class="kobospan" id="kobo.487.1">Verify Signature</span></strong><span class="kobospan" id="kobo.488.1"> section on the page, as shown in the </span><span><span class="kobospan" id="kobo.489.1">following screenshot:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer069">
<span class="kobospan" id="kobo.490.1"><img alt="Figure 6.3 – Verifying the JWT created from the login service" src="image/B19385_06_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.491.1">Figure 6.3 – Verifying the JWT created from the login service</span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.492.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.493.1">When copying the token from the JSON response in your browser, make sure that you are copying the full string value, and not the truncated one (with </span><strong class="source-inline1"><span class="kobospan" id="kobo.494.1">…</span></strong><span class="kobospan" id="kobo.495.1"> in the middle of the string). </span><span class="kobospan" id="kobo.495.2">Otherwise, the JWT might not decode properly in </span><span><span class="kobospan" id="kobo.496.1">the debugger.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.497.1">After successfully logging our user in and creating a token for them, we can now protect certain routes and make sure that only logged-in users can </span><span><span class="kobospan" id="kobo.498.1">access them.</span></span></p>
<h2 id="_idParaDest-134" class="calibre7"><a id="_idTextAnchor135" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.499.1">Defining authenticated routes</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.500.1">Now that we have </span><a id="_idIndexMarker409" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.501.1">successfully created a valid JWT, we can start protecting routes. </span><span class="kobospan" id="kobo.501.2">To do so, we are going to use the </span><strong class="source-inline"><span class="kobospan" id="kobo.502.1">express-jwt</span></strong><span class="kobospan" id="kobo.503.1"> library, </span><span><span class="kobospan" id="kobo.504.1">as follows:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.505.1">Install the </span><strong class="source-inline1"><span class="kobospan" id="kobo.506.1">express-jwt</span></strong> <span><span class="kobospan" id="kobo.507.1">npm package:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.508.1">$ cd backend</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.509.1">$ npm install express-jwt@8.4.1</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.510.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.511.1">backend/src/middleware</span></strong><span class="kobospan" id="kobo.512.1"> folder. </span><span class="kobospan" id="kobo.512.2">Inside it, create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.513.1">backend/src/middleware/jwt.js</span></strong><span class="kobospan" id="kobo.514.1"> file and import </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.515.1">expressjwt</span></strong></span><span><span class="kobospan" id="kobo.516.1"> there:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.517.1">
import { expressjwt } from 'express-jwt'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.518.1">Create and export a </span><strong class="source-inline1"><span class="kobospan" id="kobo.519.1">requireAuth</span></strong><span class="kobospan" id="kobo.520.1"> middleware by using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.521.1">expressjwt</span></strong><span class="kobospan" id="kobo.522.1"> function and </span><a id="_idIndexMarker410" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.523.1">your secret and </span><span><span class="kobospan" id="kobo.524.1">algorithm settings:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.525.1">
export const requireAuth = expressjwt({
  secret: () =&gt; process.env.JWT_SECRET,
  algorithms: ['HS256'],
})</span></pre><p class="calibre3"><span class="kobospan" id="kobo.526.1">We need to use a function for the secret because </span><strong class="source-inline"><span class="kobospan" id="kobo.527.1">dotenv</span></strong><span class="kobospan" id="kobo.528.1"> isn’t initialized at import time yet, so the environment variable will only be available later. </span><span class="kobospan" id="kobo.528.2">Specifying the algorithms is required to prevent potential </span><span><span class="kobospan" id="kobo.529.1">downgrade attacks.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.530.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.531.1">backend/src/routes/posts.js</span></strong><span class="kobospan" id="kobo.532.1"> and import the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.533.1">requireAuth</span></strong></span><span><span class="kobospan" id="kobo.534.1"> middleware:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.535.1">
import { requireAuth } from '../middleware/jwt.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.536.1">Add the middleware to the create route. </span><span class="kobospan" id="kobo.536.2">Middleware in Express can be added to specific routes by passing it as a second argument to the function, </span><span><span class="kobospan" id="kobo.537.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.538.1">
  app.post('/api/v1/posts'</span><strong class="bold1"><span class="kobospan1" id="kobo.539.1">, requireAuth</span></strong><span class="kobospan1" id="kobo.540.1">, async (req, res) =&gt; {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.541.1">Repeat the same for the </span><span><span class="kobospan" id="kobo.542.1">edit route:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.543.1">
  app.patch('/api/v1/posts/:id'</span><strong class="bold1"><span class="kobospan1" id="kobo.544.1">, requireAuth</span></strong><span class="kobospan1" id="kobo.545.1">, async (req, res) =&gt; {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.546.1">Now, do this for the </span><span><span class="kobospan" id="kobo.547.1">delete route:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.548.1">
  app.delete('/api/v1/posts/:id'</span><strong class="bold1"><span class="kobospan1" id="kobo.549.1">, requireAuth</span></strong><span class="kobospan1" id="kobo.550.1">, async (req, res) =&gt; {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.551.1">Try accessing the routes without being logged in. </span><span class="kobospan" id="kobo.551.2">You will see that they fail with a </span><strong class="bold"><span class="kobospan" id="kobo.552.1">401 Unauthorized</span></strong><span class="kobospan" id="kobo.553.1"> status. </span><span class="kobospan" id="kobo.553.2">Execute the following code into your </span><span><span class="kobospan" id="kobo.554.1">browser console:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.555.1">
const res = await fetch('http://localhost:3001/api/v1/posts', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({ title: 'Test Post' })
})
console.log(await res.json())</span></pre><p class="calibre3"><span class="kobospan" id="kobo.556.1">You can see</span><a id="_idIndexMarker411" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.557.1"> the results of executing the code in the </span><span><span class="kobospan" id="kobo.558.1">following screenshot:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer070">
<span class="kobospan" id="kobo.559.1"><img alt="Figure 6.4 – Attempting to access a protected route ﻿without a JWT and then with a JWT" src="image/B19385_06_4.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.560.1">Figure 6.4 – Attempting to access a protected route without a JWT and then with a JWT</span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.561.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.562.1">Instead of using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.563.1">express-jwt</span></strong><span class="kobospan" id="kobo.564.1"> library, we could also manually extract the token from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.565.1">Authorization</span></strong><span class="kobospan" id="kobo.566.1"> header and use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.567.1">jwt.verify</span></strong><span class="kobospan" id="kobo.568.1"> function from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.569.1">jsonwebtoken</span></strong><span class="kobospan" id="kobo.570.1"> library to </span><span><span class="kobospan" id="kobo.571.1">verify it.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.572.1">The routes are protected now, but we aren’t considering which user accessed them. </span><span class="kobospan" id="kobo.572.2">Let’s do that now by accessing the currently logged-in user from </span><span><span class="kobospan" id="kobo.573.1">the token.</span></span></p>
<h2 id="_idParaDest-135" class="calibre7"><a id="_idTextAnchor136" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.574.1">Accessing the currently logged-in user</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.575.1">After adding authenticated</span><a id="_idIndexMarker412" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.576.1"> routes, we successfully protected some routes so that they can only be accessed by logged-in users. </span><span class="kobospan" id="kobo.576.2">However, it’s still possible to edit posts of other users or create posts under a different username. </span><span class="kobospan" id="kobo.576.3">Let’s </span><span><span class="kobospan" id="kobo.577.1">change that:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.578.1">Edit the </span><strong class="source-inline1"><span class="kobospan" id="kobo.579.1">backend/src/services/posts.js</span></strong><span class="kobospan" id="kobo.580.1"> file and add a </span><strong class="source-inline1"><span class="kobospan" id="kobo.581.1">userId</span></strong><span class="kobospan" id="kobo.582.1"> argument to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.583.1">createPost</span></strong><span class="kobospan" id="kobo.584.1"> function, </span><em class="italic"><span class="kobospan" id="kobo.585.1">removing</span></em> <strong class="source-inline1"><span class="kobospan" id="kobo.586.1">author</span></strong><span class="kobospan" id="kobo.587.1"> from </span><span><span class="kobospan" id="kobo.588.1">the object:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.589.1">
export async function createPost(</span><strong class="bold1"><span class="kobospan1" id="kobo.590.1">userId,</span></strong><span class="kobospan1" id="kobo.591.1"> { title, </span><strong class="bold1"><span class="kobospan1" id="kobo.592.1">author,</span></strong><span class="kobospan1" id="kobo.593.1"> contents, tags }) {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.594.1">Instead of setting the author through the request body, we will set the author to the ID of the </span><span><span class="kobospan" id="kobo.595.1">logged-in user:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.596.1">
  const post = new Post({ title, author</span><strong class="bold1"><span class="kobospan1" id="kobo.597.1">: userId</span></strong><span class="kobospan1" id="kobo.598.1">, contents, tags })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.599.1">We adjust the </span><strong class="source-inline1"><span class="kobospan" id="kobo.600.1">updatePost</span></strong><span class="kobospan" id="kobo.601.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.602.1">deletePost</span></strong><span class="kobospan" id="kobo.603.1"> functions similarly (adding the </span><strong class="source-inline1"><span class="kobospan" id="kobo.604.1">userId</span></strong><span class="kobospan" id="kobo.605.1"> argument, removing the </span><strong class="source-inline1"><span class="kobospan" id="kobo.606.1">author</span></strong><span class="kobospan" id="kobo.607.1"> argument, and removing the author variable from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.608.1">$set </span></strong><span class="kobospan" id="kobo.609.1">object), ensuring that the currently logged-in user is the author of </span><span><span class="kobospan" id="kobo.610.1">the post:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.611.1">
export async function updatePost(</span><strong class="bold1"><span class="kobospan1" id="kobo.612.1">userId,</span></strong><span class="kobospan1" id="kobo.613.1"> postId, { title,</span><strong class="bold1"><span class="kobospan1" id="kobo.614.1"> author,</span></strong><span class="kobospan1" id="kobo.615.1"> contents, tags }) {
  return await Post.findOneAndUpdate(
    { _id: postId</span><strong class="bold1"><span class="kobospan1" id="kobo.616.1">, author: userId</span></strong><span class="kobospan1" id="kobo.617.1"> },
    { $set: { title,</span><strong class="bold1"><span class="kobospan1" id="kobo.618.1"> author,</span></strong><span class="kobospan1" id="kobo.619.1"> contents, tags } },
    { new: true },
  )
}
export async function deletePost(</span><strong class="bold1"><span class="kobospan1" id="kobo.620.1">userId,</span></strong><span class="kobospan1" id="kobo.621.1"> postId) {
  return await Post.deleteOne({ _id: postId</span><strong class="bold1"><span class="kobospan1" id="kobo.622.1">, author: userId</span></strong><span class="kobospan1" id="kobo.623.1"> })
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.624.1">In our case, we simply fetch a post with the given ID and an author as the current user. </span><span class="kobospan" id="kobo.624.2">We could still extend this code to first fetch the post with the given ID, check if it exists (if not, return a </span><strong class="bold"><span class="kobospan" id="kobo.625.1">404 Not Found</span></strong><span class="kobospan" id="kobo.626.1"> error), and if it does exist, verify that the </span><a id="_idIndexMarker413" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.627.1">author is the currently logged-in user (if not, return a </span><strong class="bold"><span class="kobospan" id="kobo.628.1">403 </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.629.1">Forbidden</span></strong></span><span><span class="kobospan" id="kobo.630.1"> error).</span></span></p></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.631.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.632.1">This is a breaking API change and requires changing the tests. </span><span class="kobospan" id="kobo.632.2">For brevity, we will not go through adjusting the tests step by step here, so this is left as an exercise </span><span><span class="kobospan" id="kobo.633.1">for you.</span></span></p>
<ol class="calibre15">
<li value="4" class="calibre11"><span class="kobospan" id="kobo.634.1">Edit the </span><strong class="source-inline1"><span class="kobospan" id="kobo.635.1">backend/src/routes/posts.js</span></strong><span class="kobospan" id="kobo.636.1"> file and use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.637.1">req.auth.sub</span></strong><span class="kobospan" id="kobo.638.1"> variable to pass the user ID to the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.639.1">createPost</span></strong></span><span><span class="kobospan" id="kobo.640.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.641.1">
    const post = await createPost(</span><strong class="bold1"><span class="kobospan1" id="kobo.642.1">req.auth.sub,</span></strong><span class="kobospan1" id="kobo.643.1"> req.body)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.644.1">Do the same for the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.645.1">updatePost</span></strong></span><span><span class="kobospan" id="kobo.646.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.647.1">
    const post = await updatePost(</span><strong class="bold1"><span class="kobospan1" id="kobo.648.1">req.auth.sub,</span></strong><span class="kobospan1" id="kobo.649.1"> req.params.id, req.body)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.650.1">Also, do this for the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.651.1">deletePost</span></strong></span><span><span class="kobospan" id="kobo.652.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.653.1">
    const { deletedCount } = await deletePost(</span><strong class="bold1"><span class="kobospan1" id="kobo.654.1">req.auth.sub, </span></strong><span class="kobospan1" id="kobo.655.1">req.params.id)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.656.1">Try creating a new post; you will see that it is created by the user identified in the JWT. </span><span class="kobospan" id="kobo.656.2">You can do this by executing the following code in the browser console (don’t forget to replace </span><strong class="source-inline1"><span class="kobospan" id="kobo.657.1">&lt;TOKEN&gt;</span></strong><span class="kobospan" id="kobo.658.1"> with your previously </span><span><span class="kobospan" id="kobo.659.1">generated JWT):</span></span><pre class="source-code"><span class="kobospan1" id="kobo.660.1">
const res = await fetch('http://localhost:3001/api/v1/posts', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer &lt;TOKEN&gt;'
    },
    body: JSON.stringify({ title: 'Test Post' })
})
console.log(await res.json())</span></pre><p class="calibre3"><span class="kobospan" id="kobo.661.1">Editing and </span><a id="_idIndexMarker414" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.662.1">deleting your posts is also possible, but not for posts from other </span><span><span class="kobospan" id="kobo.663.1">users anymore!</span></span></p></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.664.1">Info</span></p>
<p class="callout"><span class="kobospan" id="kobo.665.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.666.1">express-jwt</span></strong><span class="kobospan" id="kobo.667.1"> middleware stores all decoded claims from the JWT in a </span><strong class="source-inline1"><span class="kobospan" id="kobo.668.1">req.auth</span></strong><span class="kobospan" id="kobo.669.1"> object. </span><span class="kobospan" id="kobo.669.2">So, we can access any claims made when creating our JWT here. </span><span class="kobospan" id="kobo.669.3">Of course, the middleware validates the JWT signature against the defined secret first, to ensure that it received an </span><span><span class="kobospan" id="kobo.670.1">authentic JWT.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.671.1">Now that we’ve set up the login, signup, and authenticated routes, let’s continue by integrating login and signup in </span><span><span class="kobospan" id="kobo.672.1">the frontend.</span></span></p>
<h1 id="_idParaDest-136" class="calibre5"><a id="_idTextAnchor137" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.673.1">Integrating login and signup in the frontend using React Router and JWT</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.674.1">Now that we have successfully implemented authorization in the backend, let’s start extending the frontend with signup and login pages and connecting them to the backend. </span><span class="kobospan" id="kobo.674.2">First, we are going to learn how to implement multiple pages in a React app using React Router. </span><span class="kobospan" id="kobo.674.3">Then, we are going to implement the signup UI and connect it to the backend. </span><span class="kobospan" id="kobo.674.4">Afterward, we are going to implement a login UI, store the token in the frontend, and set up automatic redirects when we are successfully logged in. </span><span class="kobospan" id="kobo.674.5">Finally, we are going to update the code for creating posts to pass the token in the Authorization header and properly access our </span><span><span class="kobospan" id="kobo.675.1">authenticated route.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.676.1">Let’s get started with the frontend integration by setting up </span><span><span class="kobospan" id="kobo.677.1">React Router.</span></span></p>
<h2 id="_idParaDest-137" class="calibre7"><a id="_idTextAnchor138" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.678.1">Using React Router to implement multiple routes</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.679.1">React Router is a</span><a id="_idIndexMarker415" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.680.1"> library that allows us to manage routing in our app by defining multiple pages on different routes, just like what we have done in Express for API routes, but for</span><a id="_idIndexMarker416" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.681.1"> the frontend! </span><span class="kobospan" id="kobo.681.2">Let’s set up </span><span><span class="kobospan" id="kobo.682.1">React Router:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.683.1">Install the </span><strong class="source-inline1"><span class="kobospan" id="kobo.684.1">react-router-dom</span></strong><span class="kobospan" id="kobo.685.1"> library in the frontend project (the root of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.686.1">ch6</span></strong><span class="kobospan" id="kobo.687.1"> folder, not inside the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.688.1">backend</span></strong></span><span><span class="kobospan" id="kobo.689.1"> folder</span></span><span><span class="kobospan" id="kobo.690.1">):</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.691.1">$ npm install react-router-dom@6.21.0</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.692.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.693.1">src/App.jsx</span></strong><span class="kobospan" id="kobo.694.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.695.1">createBrowserRouter</span></strong><span class="kobospan" id="kobo.696.1"> function and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.697.1">RouterProvider</span></strong></span><span><span class="kobospan" id="kobo.698.1"> component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.699.1">
import { createBrowserRouter, RouterProvider } from 'react-router-dom'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.700.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.701.1">router</span></strong><span class="kobospan" id="kobo.702.1"> and define the routes. </span><span class="kobospan" id="kobo.702.2">First, we’ll define an index route for rendering our </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.703.1">Blog</span></strong></span><span><span class="kobospan" id="kobo.704.1"> component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.705.1">
const router = createBrowserRouter([
  {
    path: '/',
    element: &lt;Blog /&gt;,
  },
])</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.706.1">Then, in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.707.1">App</span></strong><span class="kobospan" id="kobo.708.1"> component, replace the </span><strong class="source-inline1"><span class="kobospan" id="kobo.709.1">&lt;Blog&gt;</span></strong><span class="kobospan" id="kobo.710.1"> component with </span><strong class="source-inline1"><span class="kobospan" id="kobo.711.1">&lt;RouterProvider&gt;</span></strong><span class="kobospan" id="kobo.712.1">, </span><span><span class="kobospan" id="kobo.713.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.714.1">
export function App() {
  return (
    &lt;QueryClientProvider client={queryClient}&gt;
      </span><strong class="bold1"><span class="kobospan1" id="kobo.715.1">&lt;RouterProvider router={router} /&gt;</span></strong><span class="kobospan1" id="kobo.716.1">
    &lt;/QueryClientProvider&gt;
  )
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.717.1">Start the frontend by running the following command in the root of the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.718.1">ch6</span></strong></span><span><span class="kobospan" id="kobo.719.1"> folder:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.720.1">$ npm run dev</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.721.1">The blog</span><a id="_idIndexMarker417" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.722.1"> should render the same way as before, but now, we can start defining new routes! </span><span class="kobospan" id="kobo.722.2">You can verify that React Router is working by going to a page that we did not define – for example, </span><strong class="source-inline1"><span class="kobospan" id="kobo.723.1">http://localhost:5173/test</span></strong><span class="kobospan" id="kobo.724.1">. </span><span class="kobospan" id="kobo.724.2">React Router will display the default 404 page, as shown in the </span><span><span class="kobospan" id="kobo.725.1">following screenshot:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer071">
<span class="kobospan" id="kobo.726.1"><img alt="Figure 6.5 – The default 404 page provided by React Router" src="image/B19385_06_5.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.727.1">Figure 6.5 – The default 404 page provided by React Router</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.728.1">Now that we </span><a id="_idIndexMarker418" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.729.1">have successfully set up React Router, we can move on to creating the </span><span><span class="kobospan" id="kobo.730.1">signup page.</span></span></p>
<h2 id="_idParaDest-138" class="calibre7"><a id="_idTextAnchor139" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.731.1">Creating the signup page</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.732.1">We will start by updating our </span><a id="_idIndexMarker419" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.733.1">folder structure so that it supports multiple pages. </span><span class="kobospan" id="kobo.733.2">Then, we will implement a </span><strong class="source-inline"><span class="kobospan" id="kobo.734.1">Signup</span></strong><span class="kobospan" id="kobo.735.1"> component and define a </span><strong class="source-inline"><span class="kobospan" id="kobo.736.1">/signup</span></strong><span class="kobospan" id="kobo.737.1"> route to link to it. </span><span class="kobospan" id="kobo.737.2">Follow </span><span><span class="kobospan" id="kobo.738.1">these steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.739.1">Create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.740.1">src/pages/</span></strong></span><span><span class="kobospan" id="kobo.741.1"> folder.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.742.1">Move the </span><strong class="source-inline1"><span class="kobospan" id="kobo.743.1">src/Blog.jsx</span></strong><span class="kobospan" id="kobo.744.1"> file into the </span><strong class="source-inline1"><span class="kobospan" id="kobo.745.1">src/pages/</span></strong><span class="kobospan" id="kobo.746.1"> folder. </span><span class="kobospan" id="kobo.746.2">When VS Code asks you to update all imports, select </span><strong class="bold"><span class="kobospan" id="kobo.747.1">Yes</span></strong><span class="kobospan" id="kobo.748.1">. </span><span class="kobospan" id="kobo.748.2">Alternatively, update the import in </span><strong class="source-inline1"><span class="kobospan" id="kobo.749.1">src/App.jsx</span></strong><span class="kobospan" id="kobo.750.1">, </span><span><span class="kobospan" id="kobo.751.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.752.1">
import { Blog } from './</span><strong class="bold1"><span class="kobospan1" id="kobo.753.1">pages/</span></strong><span class="kobospan1" id="kobo.754.1">Blog.jsx'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.755.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.756.1">src/api/users.js</span></strong><span class="kobospan" id="kobo.757.1"> file and define an API function for the </span><strong class="source-inline1"><span class="kobospan" id="kobo.758.1">signup</span></strong><span class="kobospan" id="kobo.759.1"> route, </span><span><span class="kobospan" id="kobo.760.1">as</span></span><span><a id="_idIndexMarker420" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.761.1"> follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.762.1">
export const signup = async ({ username, password }) =&gt; {
  const res = await fetch(`${import.meta.env.VITE_BACKEND_URL}/user/signup`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ username, password }),
  })
  if (!res.ok) throw new Error('failed to sign up')
  return await res.json()
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.763.1">We are checking for </span><strong class="source-inline"><span class="kobospan" id="kobo.764.1">res.ok</span></strong><span class="kobospan" id="kobo.765.1"> here, which will be </span><strong class="source-inline"><span class="kobospan" id="kobo.766.1">false</span></strong><span class="kobospan" id="kobo.767.1"> when the response status code is an error code, such </span><span><span class="kobospan" id="kobo.768.1">as </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.769.1">400</span></strong></span><span><span class="kobospan" id="kobo.770.1">.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.771.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.772.1">src/pages/Signup.jsx</span></strong><span class="kobospan" id="kobo.773.1"> file, import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.774.1">useState</span></strong><span class="kobospan" id="kobo.775.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.776.1">useMutation</span></strong><span class="kobospan" id="kobo.777.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.778.1">useNavigate</span></strong><span class="kobospan" id="kobo.779.1"> hooks from </span><strong class="source-inline1"><span class="kobospan" id="kobo.780.1">react-router-dom</span></strong><span class="kobospan" id="kobo.781.1">, as well as the </span><strong class="source-inline1"><span class="kobospan" id="kobo.782.1">signup</span></strong><span class="kobospan" id="kobo.783.1"> function, and define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.784.1">Signup</span></strong> <span><span class="kobospan" id="kobo.785.1">component there:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.786.1">
import { useState } from 'react'
import { useMutation } from '@tanstack/react-query'
import { useNavigate } from 'react-router-dom'
import { signup } from '../api/users.js'
export function Signup() {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.787.1">In this component, we first create state hooks for the </span><strong class="source-inline1"><span class="kobospan" id="kobo.788.1">username</span></strong><span class="kobospan" id="kobo.789.1"> and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.790.1">password</span></strong></span><span><span class="kobospan" id="kobo.791.1"> fields:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.792.1">
  const [username, setUsername] = useState('')
  const [password, setPassword] = useState('')</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.793.1">Then, we use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.794.1">useNavigate</span></strong><span class="kobospan" id="kobo.795.1"> hook to get a function to navigate to a </span><span><span class="kobospan" id="kobo.796.1">different route:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.797.1">
  const navigate = useNavigate()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.798.1">We also define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.799.1">useMutation</span></strong><span class="kobospan" id="kobo.800.1"> hook to send the </span><strong class="source-inline1"><span class="kobospan" id="kobo.801.1">signup</span></strong><span class="kobospan" id="kobo.802.1"> request. </span><span class="kobospan" id="kobo.802.2">On success, we navigate to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.803.1">/login</span></strong><span class="kobospan" id="kobo.804.1"> route, which we will </span><span><span class="kobospan" id="kobo.805.1">define soon:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.806.1">
  const signupMutation = useMutation({
    mutationFn: () =&gt; signup({ username, password }),
    onSuccess: () =&gt; navigate('/login'),
    onError: () =&gt; alert('failed to sign up!'),
  })</span></pre><p class="calibre3"><span class="kobospan" id="kobo.807.1">In case of an error, we could also use the </span><strong class="source-inline"><span class="kobospan" id="kobo.808.1">signupMutation.isError</span></strong><span class="kobospan" id="kobo.809.1"> state and the response from the backend to show a more nicely formatted </span><span><span class="kobospan" id="kobo.810.1">error message.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.811.1">Then, we define a </span><a id="_idIndexMarker421" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.812.1">function to handle the submission of the form, as we did for the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.813.1">CreatePost</span></strong></span><span><span class="kobospan" id="kobo.814.1"> component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.815.1">
  const handleSubmit = (e) =&gt; {
    e.preventDefault()
    signupMutation.mutate()
  }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.816.1">Now, we create a simple form to enter a username, password, and a button to submit the request, similar to the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.817.1">CreatePost</span></strong></span><span><span class="kobospan" id="kobo.818.1"> component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.819.1">
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;label htmlFor='create-username'&gt;Username: &lt;/label&gt;
        &lt;input
          type='text'
          name='create-username'
          id='create-username'
          value={username}
          onChange={(e) =&gt; setUsername(e.target.value)}
        /&gt;
      &lt;/div&gt;
      &lt;br /&gt;
      &lt;div&gt;
        &lt;label htmlFor='create-password'&gt;Password: &lt;/label&gt;
        &lt;input
          type='password'
          name='create-password'
          id='create-password'
          value={password}
          onChange={(e) =&gt; setPassword(e.target.value)}
        /&gt;
      &lt;/div&gt;
      &lt;br /&gt;
      &lt;input
        type='submit'
        value={signupMutation.isPending ? </span><span class="kobospan1" id="kobo.819.2">'Signing up...' </span><span class="kobospan1" id="kobo.819.3">: 'Sign Up'}
        disabled={!username || !password || signupMutation.isPending}
      /&gt;
    &lt;/form&gt;
  )
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.820.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.821.1">src/App.jsx</span></strong><span class="kobospan" id="kobo.822.1"> and </span><a id="_idIndexMarker422" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.823.1">import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.824.1">Signup</span></strong> <span><span class="kobospan" id="kobo.825.1">page component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.826.1">
import { Signup } from './pages/Signup.jsx'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.827.1">Add a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.828.1">/signup</span></strong><span class="kobospan" id="kobo.829.1"> route that points to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.830.1">Signup</span></strong> <span><span class="kobospan" id="kobo.831.1">page component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.832.1">
const router = createBrowserRouter([
  {
    path: '/',
    element: &lt;Blog /&gt;,
  },
</span><strong class="bold1"><span class="kobospan1" id="kobo.833.1">  {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.834.1">    path: '/signup',</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.835.1">    element: &lt;Signup /&gt;,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.836.1">  },</span></strong><span class="kobospan1" id="kobo.837.1">
])</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.838.1">After defining the signup page, we still need a way to link to it. </span><span class="kobospan" id="kobo.838.2">Let’s add the </span><span><span class="kobospan" id="kobo.839.1">link now.</span></span></p>
<h2 id="_idParaDest-139" class="calibre7"><a id="_idTextAnchor140" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.840.1">Linking to other routes using the Link component</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.841.1">Now that we</span><a id="_idIndexMarker423" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.842.1"> have multiple pages in our blog app, we need to link between them. </span><span class="kobospan" id="kobo.842.2">To do this, we can use the </span><strong class="source-inline"><span class="kobospan" id="kobo.843.1">Link</span></strong><span class="kobospan" id="kobo.844.1"> component provided by React Router. </span><span class="kobospan" id="kobo.844.2">We could also use a normal link by using </span><strong class="source-inline"><span class="kobospan" id="kobo.845.1">&lt;a href=""&gt;</span></strong><span class="kobospan" id="kobo.846.1">, but that would cause a full page refresh. </span><span class="kobospan" id="kobo.846.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.847.1">Link</span></strong><span class="kobospan" id="kobo.848.1"> component uses client-side routing and thus avoids doing a full refresh of the page. </span><span class="kobospan" id="kobo.848.2">Instead, it immediately renders the new component on the </span><span><span class="kobospan" id="kobo.849.1">client side.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.850.1">Follow these steps to create a link from the index page to the </span><span><span class="kobospan" id="kobo.851.1">signup page:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.852.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.853.1">src/components/Header.jsx</span></strong><span class="kobospan" id="kobo.854.1"> file and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.855.1">Link</span></strong><span class="kobospan" id="kobo.856.1"> component </span><span><span class="kobospan" id="kobo.857.1">from </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.858.1">react-router-dom</span></strong></span><span><span class="kobospan" id="kobo.859.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.860.1">
import { Link } from 'react-router-dom'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.861.1">Define a component and return the </span><strong class="source-inline1"><span class="kobospan" id="kobo.862.1">Link</span></strong><span class="kobospan" id="kobo.863.1"> component to define a link to the signup route, </span><span><span class="kobospan" id="kobo.864.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.865.1">
export function Header() {
  return (
    &lt;div&gt;
      &lt;Link to='/signup'&gt;Sign Up&lt;/Link&gt;
    &lt;/div&gt;
  )
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.866.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.867.1">src/pages/Blog.jsx</span></strong><span class="kobospan" id="kobo.868.1"> and import the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.869.1">Header</span></strong></span><span><span class="kobospan" id="kobo.870.1"> component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.871.1">
import { Header } from '../components/Header.jsx'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.872.1">Then, render the </span><strong class="source-inline1"><span class="kobospan" id="kobo.873.1">Header</span></strong><span class="kobospan" id="kobo.874.1"> component in the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.875.1">Blog</span></strong></span><span><span class="kobospan" id="kobo.876.1"> component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.877.1">
  return (
    &lt;div style={{ padding: 8 }}&gt;
</span><strong class="bold1"><span class="kobospan1" id="kobo.878.1">      &lt;Header /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.879.1">      &lt;br /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.880.1">      &lt;hr /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.881.1">      &lt;br /&gt;</span></strong><span class="kobospan1" id="kobo.882.1">
      &lt;CreatePost /&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.883.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.884.1">src/pages/Signup.jsx</span></strong><span class="kobospan" id="kobo.885.1"> and import the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.886.1">Link</span></strong></span><span><span class="kobospan" id="kobo.887.1"> component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.888.1">
import { useNavigate</span><strong class="bold1"><span class="kobospan1" id="kobo.889.1">, Link</span></strong><span class="kobospan1" id="kobo.890.1"> } from 'react-router-dom'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.891.1">Add the </span><strong class="source-inline1"><span class="kobospan" id="kobo.892.1">Link</span></strong><span class="kobospan" id="kobo.893.1"> component</span><a id="_idIndexMarker424" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.894.1"> to link back to the </span><span><span class="kobospan" id="kobo.895.1">index page:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.896.1">
  return (
    &lt;form onSubmit={handleSubmit}&gt;
</span><strong class="bold1"><span class="kobospan1" id="kobo.897.1">      &lt;Link to='/'&gt;Back to main page&lt;/Link&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.898.1">      &lt;hr /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.899.1">      &lt;br /&gt;</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.900.1">Now that we’ve successfully linked our signup page, let’s continue by creating the </span><span><span class="kobospan" id="kobo.901.1">login page.</span></span></p>
<h2 id="_idParaDest-140" class="calibre7"><a id="_idTextAnchor141" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.902.1">Creating the login page and storing the JWT</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.903.1">Now that we</span><a id="_idIndexMarker425" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.904.1"> have successfully defined the signup page, we can create the </span><a id="_idIndexMarker426" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.905.1">login page. </span><span class="kobospan" id="kobo.905.2">However, first, we need to come up with a way to store the JWT. </span><span class="kobospan" id="kobo.905.3">We shouldn’t store it in local storage as a potential attacker can steal the token from there (through, for example, script injection). </span><span class="kobospan" id="kobo.905.4">In a </span><strong class="bold"><span class="kobospan" id="kobo.906.1">single-page application</span></strong><span class="kobospan" id="kobo.907.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.908.1">SPA</span></strong><span class="kobospan" id="kobo.909.1">), where we have no page reloads, a safe and simple way to</span><a id="_idIndexMarker427" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.910.1"> store the token is to store it in the runtime using a React context. </span><span class="kobospan" id="kobo.910.2">Let’s do </span><span><span class="kobospan" id="kobo.911.1">that now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.912.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.913.1">src/contexts/</span></strong><span class="kobospan" id="kobo.914.1"> folder. </span><span class="kobospan" id="kobo.914.2">Inside it, create a </span><strong class="source-inline1"><span class="kobospan" id="kobo.915.1">src/contexts/AuthContext.jsx</span></strong><span class="kobospan" id="kobo.916.1"> file and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.917.1">createContext</span></strong><span class="kobospan" id="kobo.918.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.919.1">useState</span></strong><span class="kobospan" id="kobo.920.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.921.1">useContext</span></strong><span class="kobospan" id="kobo.922.1"> functions </span><span><span class="kobospan" id="kobo.923.1">from </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.924.1">react</span></strong></span><span><span class="kobospan" id="kobo.925.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.926.1">
import { createContext, useState, useContext } from 'react'
import PropTypes from 'prop-types'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.927.1">Then, define the </span><span><span class="kobospan" id="kobo.928.1">following context:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.929.1">
export const AuthContext = createContext({
  token: null,
  setToken: () =&gt; {},
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.930.1">Next, define an </span><strong class="source-inline1"><span class="kobospan" id="kobo.931.1">AuthContextProvider</span></strong><span class="kobospan" id="kobo.932.1"> component that provides the context with a </span><span><span class="kobospan" id="kobo.933.1">state hook:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.934.1">
export const AuthContextProvider = ({ children }) =&gt; {
  const [token, setToken] = useState(null)
  return (
    &lt;AuthContext.Provider value={{ token, setToken }}&gt;
      {children}
    &lt;/AuthContext.Provider&gt;
  )
}
AuthContextProvider.propTypes = {
  children: PropTypes.element.isRequired,
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.935.1">Also, define</span><a id="_idIndexMarker428" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.936.1"> a hook to use the context with a </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.937.1">useState</span></strong></span><span><span class="kobospan" id="kobo.938.1">-like</span></span><span><a id="_idIndexMarker429" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.939.1"> API:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.940.1">
export function useAuth() {
  const { token, setToken } = useContext(AuthContext)
  return [token, setToken]
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.941.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.942.1">src/App.jsx</span></strong><span class="kobospan" id="kobo.943.1"> and </span><span><span class="kobospan" id="kobo.944.1">import </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.945.1">AuthContextProvider</span></strong></span><span><span class="kobospan" id="kobo.946.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.947.1">
import { AuthContextProvider } from './contexts/AuthContext.jsx'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.948.1">Wrap </span><strong class="source-inline1"><span class="kobospan" id="kobo.949.1">RouterProvider</span></strong><span class="kobospan" id="kobo.950.1"> with </span><strong class="source-inline1"><span class="kobospan" id="kobo.951.1">AuthContextProvider</span></strong><span class="kobospan" id="kobo.952.1"> to </span><a id="_idIndexMarker430" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.953.1">make it </span><a id="_idIndexMarker431" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.954.1">available to </span><span><span class="kobospan" id="kobo.955.1">all pages:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.956.1">      &lt;AuthContextProvider&gt;</span></strong><span class="kobospan1" id="kobo.957.1">
        &lt;RouterProvider router={router} /&gt;
</span><strong class="bold1"><span class="kobospan1" id="kobo.958.1">      &lt;/AuthContextProvider&gt;</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.959.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.960.1">src/api/users.js</span></strong><span class="kobospan" id="kobo.961.1"> and define a new </span><span><span class="kobospan" id="kobo.962.1">login function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.963.1">
export const login = async ({ username, password }) =&gt; {
  const res = await fetch(`${import.meta.env.VITE_BACKEND_URL}/user/login`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ username, password }),
  })
  if (!res.ok) throw new Error('failed to login')
  return await res.json()
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.964.1">Copy over the </span><strong class="source-inline1"><span class="kobospan" id="kobo.965.1">src/pages/Signup.jsx</span></strong><span class="kobospan" id="kobo.966.1"> file to a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.967.1">src/pages/Login.jsx</span></strong><span class="kobospan" id="kobo.968.1"> file and adjust the import and component name. </span><span class="kobospan" id="kobo.968.2">Also, add a new import for the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.969.1">useAuth</span></strong></span><span><span class="kobospan" id="kobo.970.1"> hook:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.971.1">
import { </span><strong class="bold1"><span class="kobospan1" id="kobo.972.1">login</span></strong><span class="kobospan1" id="kobo.973.1"> } from '../api/users.js'
</span><strong class="bold1"><span class="kobospan1" id="kobo.974.1">import { useAuth } from '../contexts/AuthContext.jsx'</span></strong><span class="kobospan1" id="kobo.975.1">
export function </span><strong class="bold1"><span class="kobospan1" id="kobo.976.1">Login</span></strong><span class="kobospan1" id="kobo.977.1">() {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.978.1">Next, edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.979.1">src/pages/Login.jsx</span></strong><span class="kobospan" id="kobo.980.1">, add the </span><strong class="source-inline1"><span class="kobospan" id="kobo.981.1">useAuth</span></strong><span class="kobospan" id="kobo.982.1"> hook, adjust the </span><strong class="source-inline1"><span class="kobospan" id="kobo.983.1">signupMutation</span></strong><span class="kobospan" id="kobo.984.1"> to call </span><a id="_idIndexMarker432" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.985.1">login, set the token, and navigate to the index page </span><a id="_idIndexMarker433" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.986.1">upon successfully </span><span><span class="kobospan" id="kobo.987.1">logging in:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.988.1">
  </span><strong class="bold1"><span class="kobospan1" id="kobo.989.1">const [, setToken] = useAuth()</span></strong><span class="kobospan1" id="kobo.990.1">
  const </span><strong class="bold1"><span class="kobospan1" id="kobo.991.1">login</span></strong><span class="kobospan1" id="kobo.992.1">Mutation = useMutation({
    mutationFn: () =&gt; </span><strong class="bold1"><span class="kobospan1" id="kobo.993.1">login</span></strong><span class="kobospan1" id="kobo.994.1">({ username, password }),
</span><strong class="bold1"><span class="kobospan1" id="kobo.995.1">    onSuccess: (data) =&gt; {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.996.1">      setToken(data.token)</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.997.1">      navigate('/')</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.998.1">    },</span></strong><span class="kobospan1" id="kobo.999.1">
    onError: () =&gt; alert('failed to </span><strong class="bold1"><span class="kobospan1" id="kobo.1000.1">login</span></strong><span class="kobospan1" id="kobo.1001.1">!'),
  })
  const handleSubmit = (e) =&gt; {
    e.preventDefault()
    </span><strong class="bold1"><span class="kobospan1" id="kobo.1002.1">login</span></strong><span class="kobospan1" id="kobo.1003.1">Mutation.mutate()
  }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1004.1">Adjust the submit button, </span><span><span class="kobospan" id="kobo.1005.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1006.1">
      &lt;input
        type='submit'
        value={</span><strong class="bold1"><span class="kobospan1" id="kobo.1007.1">login</span></strong><span class="kobospan1" id="kobo.1008.1">Mutation.isPending ? </span><strong class="bold1"><span class="kobospan1" id="kobo.1009.1">'Logging in...' </span><span class="kobospan1" id="kobo.1009.2">: 'Log In'</span></strong><span class="kobospan1" id="kobo.1010.1">}
        disabled={!username || !password || </span><strong class="bold1"><span class="kobospan1" id="kobo.1011.1">login</span></strong><span class="kobospan1" id="kobo.1012.1">Mutation.isPending}
      /&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1013.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1014.1">src/App.jsx</span></strong><span class="kobospan" id="kobo.1015.1"> and import the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1016.1">Login</span></strong></span><span><span class="kobospan" id="kobo.1017.1"> page:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1018.1">
import { Login } from './pages/Login.jsx'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1019.1">Lastly, define </span><a id="_idIndexMarker434" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1020.1">the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1021.1">/login</span></strong><span class="kobospan" id="kobo.1022.1"> route, </span><span><span class="kobospan" id="kobo.1023.1">as </span></span><span><a id="_idIndexMarker435" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.1024.1">follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1025.1">
  {
    path: '/login',
    element: &lt;Login /&gt;,
  },</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.1026.1">With that, our signup and login pages are working properly, but we still need to link to the login page and show the currently logged-in user on the index page. </span><span class="kobospan" id="kobo.1026.2">Let’s do </span><span><span class="kobospan" id="kobo.1027.1">that now.</span></span></p>
<h2 id="_idParaDest-141" class="calibre7"><a id="_idTextAnchor142" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1028.1">Using the stored JWT and implementing a simple logout</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1029.1">In this section, we are going to check if the user is logged in already by checking if there is a valid JWT stored in the context. </span><span class="kobospan" id="kobo.1029.2">Then, we are going to use the auth context hook to log our user out again by simply removing the token from it. </span><span class="kobospan" id="kobo.1029.3">This is not a full logout as the JWT is still technically valid. </span><span class="kobospan" id="kobo.1029.4">For a full logout, we would have to invalidate the token in the backend (for example, by blacklisting that token in the authentication service database). </span><span class="kobospan" id="kobo.1029.5">This process is</span><a id="_idIndexMarker436" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1030.1"> called </span><span><strong class="bold"><span class="kobospan" id="kobo.1031.1">token revocation</span></strong></span><span><span class="kobospan" id="kobo.1032.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1033.1">Let’s start using the stored JWT</span><a id="_idIndexMarker437" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1034.1"> and implement a </span><a id="_idIndexMarker438" class="calibre6 pcalibre1 pcalibre"/><span><span class="kobospan" id="kobo.1035.1">simple logout:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1036.1">Install the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1037.1">jwt-decode</span></strong><span class="kobospan" id="kobo.1038.1"> library</span><a id="_idIndexMarker439" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1039.1"> in the </span><a id="_idIndexMarker440" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1040.1">root of our project (</span><span><span class="kobospan" id="kobo.1041.1">the frontend):</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1042.1">$ npm install jwt-decode@4.0.0</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1043.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1044.1">src/components/Header.jsx</span></strong><span class="kobospan" id="kobo.1045.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1046.1">jwtDecode</span></strong><span class="kobospan" id="kobo.1047.1"> function and the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1048.1">useAuth</span></strong></span><span><span class="kobospan" id="kobo.1049.1"> hook:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1050.1">
import { jwtDecode } from 'jwt-decode'
import { useAuth } from '../contexts/AuthContext.jsx'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1051.1">Get the token from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1052.1">useAuth</span></strong><span class="kobospan" id="kobo.1053.1"> hook in the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1054.1">Header</span></strong></span><span><span class="kobospan" id="kobo.1055.1"> component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1056.1">
export function Header() {
</span><strong class="bold1"><span class="kobospan1" id="kobo.1057.1">  const [token, setToken] = useAuth()</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1058.1">Add a check for if the token is properly set. </span><span class="kobospan" id="kobo.1058.2">If it is, parse the token and render the user ID </span><span><span class="kobospan" id="kobo.1059.1">from it:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1060.1">
  if (token) {
    const { sub } = jwtDecode(token)
    return (
      &lt;div&gt;
        Logged in as &lt;b&gt;{sub}&lt;/b&gt;</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.1061.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.1062.1">In this case, we are only decoding the token in one place. </span><span class="kobospan" id="kobo.1062.2">If this functionality is used in multiple places, it would make sense to abstract the decoding into a </span><span><span class="kobospan" id="kobo.1063.1">separate hook.</span></span></p>
<ol class="calibre15">
<li value="5" class="calibre11"><span class="kobospan" id="kobo.1064.1">Additionally, we’ll show a button to log out here, which just resets </span><span><span class="kobospan" id="kobo.1065.1">the token:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1066.1">
        &lt;br /&gt;
        &lt;button onClick={() =&gt; setToken(null)}&gt;Logout&lt;/button&gt;
      &lt;/div&gt;
    )
  }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1067.1">While we’re at it, let’s also add a link to the login page to the header, if the user isn’t logged </span><span><span class="kobospan" id="kobo.1068.1">in yet:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1069.1">
  return (
    &lt;div&gt;
      </span><strong class="bold1"><span class="kobospan1" id="kobo.1070.1">&lt;Link to='/login'&gt;Log In&lt;/Link&gt; |</span></strong><span class="kobospan1" id="kobo.1071.1"> &lt;Link to='/signup'&gt;Sign Up&lt;/Link&gt;
    &lt;/div&gt;
  )</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.1072.1">Congratulations! </span><span class="kobospan" id="kobo.1072.2">We have</span><a id="_idIndexMarker441" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1073.1"> successfully implemented a simple JWT user authentication</span><a id="_idIndexMarker442" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1074.1"> flow. </span><span class="kobospan" id="kobo.1074.2">However, you may have noticed that all the users in our blog appear as their user ID, not with their username. </span><span class="kobospan" id="kobo.1074.3">Let’s </span><span><span class="kobospan" id="kobo.1075.1">change that.</span></span></p>
<h2 id="_idParaDest-142" class="calibre7"><a id="_idTextAnchor143" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1076.1">Fetching the usernames</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1077.1">To show the</span><a id="_idIndexMarker443" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1078.1"> usernames instead of the user IDs, we are going to create a </span><strong class="source-inline"><span class="kobospan" id="kobo.1079.1">User</span></strong><span class="kobospan" id="kobo.1080.1"> component that will fetch user information from an endpoint in our backend, which we are going to create now. </span><span class="kobospan" id="kobo.1080.2">For now, we will only show the username, but in the future, this feature could be used to fetch other information, such as the avatar or full name of </span><span><span class="kobospan" id="kobo.1081.1">the user.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.1082.1">Implementing the backend endpoint</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.1083.1">Let’s get started by</span><a id="_idIndexMarker444" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1084.1"> implementing the backend endpoint for fetching </span><span><span class="kobospan" id="kobo.1085.1">user information:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1086.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1087.1">backend/src/services/users.js</span></strong><span class="kobospan" id="kobo.1088.1"> and add a new function to get user information by </span><strong class="source-inline1"><span class="kobospan" id="kobo.1089.1">id</span></strong><span class="kobospan" id="kobo.1090.1">. </span><span class="kobospan" id="kobo.1090.2">As a fallback, we return the user ID if we can’t find a </span><span><span class="kobospan" id="kobo.1091.1">matching user:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1092.1">
export async function getUserInfoById(userId) {
  try {
    const user = await User.findById(userId)
    if (!user) return { username: userId }
    return { username: user.username }
  } catch (err) {
    return { username: userId }
  }
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.1093.1">We</span><a id="_idIndexMarker445" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1094.1"> specifically make sure we only return the username here, to avoid leaking the password or other sensitive </span><span><span class="kobospan" id="kobo.1095.1">user information!</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.1096.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1097.1">backend/src/routes/users.js</span></strong><span class="kobospan" id="kobo.1098.1"> and import the newly defined </span><span><span class="kobospan" id="kobo.1099.1">function there:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1100.1">
import { createUser, loginUser</span><strong class="bold1"><span class="kobospan1" id="kobo.1101.1">, getUserInfoById</span></strong><span class="kobospan1" id="kobo.1102.1"> } from '../services/users.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1103.1">Then, define a new route inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1104.1">userRoutes</span></strong><span class="kobospan" id="kobo.1105.1"> function, which will get a user with a specific ID. </span><span class="kobospan" id="kobo.1105.2">For this route, we use the plural </span><strong class="source-inline1"><span class="kobospan" id="kobo.1106.1">users</span></strong><span class="kobospan" id="kobo.1107.1"> as we are dealing with multiple </span><span><span class="kobospan" id="kobo.1108.1">users here:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1109.1">
  app.get('/api/v1/users/:id', async (req, res) =&gt; {
    const userInfo = await getUserInfoById(req.params.id)
    return res.status(200).send(userInfo)
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1110.1">Since we are already working on the backend, let’s also change the existing </span><strong class="source-inline1"><span class="kobospan" id="kobo.1111.1">author</span></strong><span class="kobospan" id="kobo.1112.1"> filter so that it works with usernames. </span><span class="kobospan" id="kobo.1112.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1113.1">backend/src/services/posts.js</span></strong><span class="kobospan" id="kobo.1114.1"> and import the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1115.1">User</span></strong></span><span><span class="kobospan" id="kobo.1116.1"> model:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1117.1">
import { User } from '../db/models/user.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1118.1">Refactor the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1119.1">listPostsByAuthor</span></strong><span class="kobospan" id="kobo.1120.1"> function by finding a user with the given username, then </span><a id="_idIndexMarker446" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1121.1">listing all posts by the user ID (if one </span><span><span class="kobospan" id="kobo.1122.1">was found):</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1123.1">
export async function listPostsByAuthor(</span><strong class="bold1"><span class="kobospan1" id="kobo.1124.1">authorUsername</span></strong><span class="kobospan1" id="kobo.1125.1">, options) {
</span><strong class="bold1"><span class="kobospan1" id="kobo.1126.1">  const user = await User.findOne({ username: authorUsername })</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1127.1">  if (!user) return []</span></strong><span class="kobospan1" id="kobo.1128.1">
  return await listPosts({ author</span><strong class="bold1"><span class="kobospan1" id="kobo.1129.1">: user._id</span></strong><span class="kobospan1" id="kobo.1130.1"> }, options)
}</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.1131.1">Now that we have an endpoint that returns user information for a given user ID, let’s use it in </span><span><span class="kobospan" id="kobo.1132.1">the frontend!</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.1133.1">Implementing a User component to fetch and render the username</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.1134.1">In the frontend, we </span><a id="_idIndexMarker447" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1135.1">are going to create a component that will fetch and render the username. </span><span class="kobospan" id="kobo.1135.2">React Query helps us a lot here because we don’t need to worry about fetching the same user IDs multiple times – it will cache the result for us and instantly return it, instead of making </span><span><span class="kobospan" id="kobo.1136.1">another request.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1137.1">Follow these steps to implement a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1138.1">User</span></strong></span><span><span class="kobospan" id="kobo.1139.1"> component:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1140.1">First, we need to define the API function. </span><span class="kobospan" id="kobo.1140.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1141.1">src/api/users.js</span></strong><span class="kobospan" id="kobo.1142.1"> and add a function to get the user info </span><span><span class="kobospan" id="kobo.1143.1">by </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1144.1">id</span></strong></span><span><span class="kobospan" id="kobo.1145.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1146.1">
export const getUserInfo = async (id) =&gt; {
  const res = await fetch(`${import.meta.env.VITE_BACKEND_URL}/users/${id}`, {
    method: 'GET',
    headers: { 'Content-Type': 'application/json' },
  })
  return await res.json()
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1147.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.1148.1">src/components/User.jsx</span></strong><span class="kobospan" id="kobo.1149.1"> file and import </span><strong class="source-inline1"><span class="kobospan" id="kobo.1150.1">useQuery</span></strong><span class="kobospan" id="kobo.1151.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.1152.1">PropTypes</span></strong><span class="kobospan" id="kobo.1153.1">, and the </span><span><span class="kobospan" id="kobo.1154.1">API function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1155.1">
import { useQuery } from '@tanstack/react-query'
import PropTypes from 'prop-types'
import { getUserInfo } from '../api/users.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1156.1">Now, define the </span><a id="_idIndexMarker448" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1157.1">component and get the user info via the </span><span><span class="kobospan" id="kobo.1158.1">query hook:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1159.1">
export function User({ id }) {
  const userInfoQuery = useQuery({
    queryKey: ['users', id],
    queryFn: () =&gt; getUserInfo(id),
  })
  const userInfo = userInfoQuery.data ?? </span><span class="kobospan1" id="kobo.1159.2">{}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1160.1">We render the username if available and fall back to the </span><span><span class="kobospan" id="kobo.1161.1">ID otherwise:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1162.1">
  return &lt;strong&gt;{userInfo?.username ?? </span><span class="kobospan1" id="kobo.1162.2">id}&lt;/strong&gt;
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1163.1">Lastly, we define the prop types for </span><span><span class="kobospan" id="kobo.1164.1">the component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1165.1">
User.propTypes = {
  id: PropTypes.string.isRequired,
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1166.1">Now, we</span><a id="_idIndexMarker449" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1167.1"> can make use of the newly created component and import it </span><span><span class="kobospan" id="kobo.1168.1">in </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1169.1">src/components/Header.jsx</span></strong></span><span><span class="kobospan" id="kobo.1170.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1171.1">
import { User } from './User.jsx'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1172.1">Then, we can edit the existing code to render the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1173.1">User</span></strong><span class="kobospan" id="kobo.1174.1"> component instead of directly rendering the </span><span><span class="kobospan" id="kobo.1175.1">user ID:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1176.1">
        Logged in as </span><strong class="bold1"><span class="kobospan1" id="kobo.1177.1">&lt;User id={sub} /&gt;</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1178.1">Next, we repeat the same process for </span><strong class="source-inline1"><span class="kobospan" id="kobo.1179.1">src/components/Post.jsx</span></strong><span class="kobospan" id="kobo.1180.1"> and import the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1181.1">User</span></strong></span><span><span class="kobospan" id="kobo.1182.1"> component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1183.1">
import { User } from './User.jsx'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1184.1">Then, we adjust the code to render the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1185.1">User</span></strong></span><span><span class="kobospan" id="kobo.1186.1"> component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1187.1">
          Written by </span><strong class="bold1"><span class="kobospan1" id="kobo.1188.1">&lt;User id={author} /&gt;</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.1189.1">Now, our usernames will all render properly again, as shown in the </span><span><span class="kobospan" id="kobo.1190.1">following screenshot:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer072">
<span class="kobospan" id="kobo.1191.1"><img alt="Figure 6.6 – Properly fetching and showing the username" src="image/B19385_06_6.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1192.1">Figure 6.6 – Properly fetching and showing the username</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1193.1">Now that usernames show up properly, we need to do one more thing: send the JWT header when </span><span><span class="kobospan" id="kobo.1194.1">creating posts.</span></span></p>
<h2 id="_idParaDest-143" class="calibre7"><a id="_idTextAnchor144" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1195.1">Sending the JWT header when creating posts</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1196.1">When creating a</span><a id="_idIndexMarker450" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1197.1"> post, we don’t need to send the author anymore. </span><span class="kobospan" id="kobo.1197.2">Instead, we need to send the JWT with the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1198.1">Authentication</span></strong></span><span><span class="kobospan" id="kobo.1199.1"> header.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1200.1">Let’s refactor the code so that we can </span><span><span class="kobospan" id="kobo.1201.1">do this:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1202.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1203.1">src/api/posts.jsx</span></strong><span class="kobospan" id="kobo.1204.1"> and adjust the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1205.1">createPost</span></strong><span class="kobospan" id="kobo.1206.1"> function so that it accepts a JWT as the</span><a id="_idIndexMarker451" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1207.1"> first argument, which is then passed on inside an </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1208.1">Authentication</span></strong></span><span><span class="kobospan" id="kobo.1209.1"> header:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1210.1">
export const createPost = async (</span><strong class="bold1"><span class="kobospan1" id="kobo.1211.1">token,</span></strong><span class="kobospan1" id="kobo.1212.1"> post) =&gt; {
  const res = await fetch(`${import.meta.env.VITE_BACKEND_URL}/posts`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
</span><strong class="bold1"><span class="kobospan1" id="kobo.1213.1">     Authorization: `Bearer ${token}`,</span></strong><span class="kobospan1" id="kobo.1214.1">
    },
    body: JSON.stringify(post),
  })
  return await res.json()
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1215.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.1216.1">src/components/CreatePost.jsx</span></strong><span class="kobospan" id="kobo.1217.1"> and import the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1218.1">useAuth</span></strong></span><span><span class="kobospan" id="kobo.1219.1"> hook:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1220.1">
import { useAuth } from '../contexts/AuthContext.jsx'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1221.1">Get the JWT from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1222.1">useAuth</span></strong><span class="kobospan" id="kobo.1223.1"> hook inside </span><span><span class="kobospan" id="kobo.1224.1">the component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1225.1">
export function CreatePost() {
</span><strong class="bold1"><span class="kobospan1" id="kobo.1226.1">  const [token] = useAuth()</span></strong></pre></li> <li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.1227.1">Remove</span></em><span class="kobospan" id="kobo.1228.1"> the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1229.1">author</span></strong></span><span><span class="kobospan" id="kobo.1230.1"> state:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1231.1">  const [author, setAuthor] = useState('')</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1232.1">Also, </span><em class="italic"><span class="kobospan" id="kobo.1233.1">remove</span></em><span class="kobospan" id="kobo.1234.1"> the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1235.1">author</span></strong><span class="kobospan" id="kobo.1236.1"> state from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1237.1">createPost</span></strong><span class="kobospan" id="kobo.1238.1"> function and instead pass in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1239.1">token</span></strong><span class="kobospan" id="kobo.1240.1"> state as the </span><span><span class="kobospan" id="kobo.1241.1">first argument:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1242.1">
     mutationFn: () =&gt; createPost(</span><strong class="bold1"><span class="kobospan1" id="kobo.1243.1">token,</span></strong><span class="kobospan1" id="kobo.1244.1"> { title, </span><strong class="bold1"><span class="kobospan1" id="kobo.1245.1">author,</span></strong><span class="kobospan1" id="kobo.1246.1"> contents }),</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.1247.1">Before rendering the component, check if the user is logged in by checking if a token exists. </span><span class="kobospan" id="kobo.1247.2">If the user is not logged in, we tell them to log </span><span><span class="kobospan" id="kobo.1248.1">in first:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1249.1">  if (!token) return &lt;div&gt;Please log in to create new posts.&lt;/div&gt;</span></strong><span class="kobospan1" id="kobo.1250.1">
  return (
    &lt;form onSubmit={handleSubmit}&gt;</span></pre></li> <li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.1251.1">Remove</span></em><span class="kobospan" id="kobo.1252.1"> the </span><a id="_idIndexMarker452" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1253.1">following code to remove the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1254.1">author</span></strong></span><span><span class="kobospan" id="kobo.1255.1"> field:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.1256.1">      &lt;br /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1257.1">      &lt;div&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1258.1">        &lt;label htmlFor='create-author'&gt;Author: &lt;/label&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1259.1">        &lt;input</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1260.1">          type='text'</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1261.1">          name='create-author'</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1262.1">          id='create-author'</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1263.1">          value={author}</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1264.1">          onChange={(e) =&gt; setAuthor(e.target.value)}</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1265.1">        /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1266.1">      &lt;/div&gt;</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.1267.1">Now, creating a post works successfully again! </span><span class="kobospan" id="kobo.1267.2">It stores the user ID of the currently logged-in user in the database as the author and resolves it to the username when showing </span><span><span class="kobospan" id="kobo.1268.1">the post.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1269.1">Next, we’ll learn about advanced </span><span><span class="kobospan" id="kobo.1270.1">token handling.</span></span></p>
<h1 id="_idParaDest-144" class="calibre5"><a id="_idTextAnchor145" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1271.1">Advanced token handling</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1272.1">You </span><a id="_idIndexMarker453" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1273.1">may have noticed that our simple authentication solution is still missing some features that a fully-fledged solution should have, such as </span><span><span class="kobospan" id="kobo.1274.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.1275.1">Using asymmetric keys for the tokens so that we can verify the authenticity (using the public key) without exposing our secret (the private key) to all services. </span><span class="kobospan" id="kobo.1275.2">Up until now, we have been using a symmetric key, which means that we need the same secret to generate and verify </span><span><span class="kobospan" id="kobo.1276.1">a JWT.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1277.1">Storing tokens in safe </span><strong class="source-inline1"><span class="kobospan" id="kobo.1278.1">httpOnly</span></strong><span class="kobospan" id="kobo.1279.1"> cookies so that they can be accessed again, even when the page is refreshed </span><span><span class="kobospan" id="kobo.1280.1">or closed.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1281.1">Invalidating tokens after logging out on </span><span><span class="kobospan" id="kobo.1282.1">the backend.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1283.1">Implementing these things requires a lot of effort manually, so it is best practice to use an authentication solution such as Auth0 or Firebase Auth. </span><span class="kobospan" id="kobo.1283.2">These solutions work similarly to our simple JWT implementation, but they provide an external authentication service to create and handle the tokens for us. </span><span class="kobospan" id="kobo.1283.3">This chapter intended to introduce how those providers work behind the scenes so that you can easily understand and integrate any of the providers as you see fit in </span><span><span class="kobospan" id="kobo.1284.1">your projects.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1285.1">So far, all users have been considered equal, with everyone being allowed to create posts, but only update and delete their own posts. </span><span class="kobospan" id="kobo.1285.2">For a public blog, it would be good to have a way for administrators to delete other people’s posts to moderate the content on the platform. </span><span class="kobospan" id="kobo.1285.3">A good way to add roles is to store and fetch them from the database. </span><span class="kobospan" id="kobo.1285.4">While adding roles in the JWT is technically possible, it has some downsides, such as the need to invalidate existing tokens and create a new token when the </span><span><span class="kobospan" id="kobo.1286.1">roles change.</span></span></p>
<h1 id="_idParaDest-145" class="calibre5"><a id="_idTextAnchor146" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1287.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1288.1">In this chapter, we learned how JWTs work in depth. </span><span class="kobospan" id="kobo.1288.2">First, we learned about the theory of authentication and JWTs, and how to manually create them. </span><span class="kobospan" id="kobo.1288.3">Then, we implemented login, signup, and authenticated routes in the backend. </span><span class="kobospan" id="kobo.1288.4">Next, we integrated these routes in the frontend by creating new pages and routing between them using React Router. </span><span class="kobospan" id="kobo.1288.5">Finally, we wrapped up this chapter by learning about advanced token handling and giving pointers on more things to learn about authentication and </span><span><span class="kobospan" id="kobo.1289.1">role management.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1290.1">In the next chapter, </span><a href="B19385_07.xhtml#_idTextAnchor147" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.1291.1">Chapter 7</span></em></span></a><span class="kobospan" id="kobo.1292.1">, </span><em class="italic"><span class="kobospan" id="kobo.1293.1">Improving the Load Time Using Server-Side Rendering</span></em><span class="kobospan" id="kobo.1294.1">, we are going to learn how to implement server-side rendering to improve the initial load time of our blog. </span><span class="kobospan" id="kobo.1294.2">We are already doing a lot of requests on the first load (fetching all blog posts, then the usernames of each author). </span><span class="kobospan" id="kobo.1294.3">We can bundle them together by doing this on </span><span><span class="kobospan" id="kobo.1295.1">the backend.</span></span></p>
</div>
</body></html>