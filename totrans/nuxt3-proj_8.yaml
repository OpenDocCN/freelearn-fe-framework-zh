- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a Custom Translation Module in a Nuxt 3 Monorepo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B19760_08.xhtml#_idTextAnchor165), we will learn how to build
    a custom `translation` module within a Nuxt 3 monorepo. This chapter is designed
    to guide you through the complexities of monorepo setup and modular development,
    providing a complete foundation for managing large-scale projects efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by setting up a monorepo using `pnpm` workspaces, emphasizing
    the benefits of centralized management for multiple interlinked projects. You
    will also learn how to craft a custom `translation` module, embedding it seamlessly
    into a Nuxt application, by detailing the steps to create, configure, and extend
    this module with additional functionality through components and plugins.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter demonstrates the modularity and reusability that monorepos facilitate.
    Each section aims to equip you with the skills to enhance your Nuxt applications
    with scalable and maintainable modules, preparing you for future projects that
    require advanced architecture solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Nuxt monorepo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a custom `translation` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring `translation` module options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expanding the module with plugins, components, and composables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Future directions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter can be found at .
  prefs: []
  type: TYPE_NORMAL
- en: The CiA video for this chapter can be found on [https://packt.link/kdT64](https://packt.link/kdT64)
  prefs: []
  type: TYPE_NORMAL
- en: Essential background – fundamentals of testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’re diving into setting up a Nuxt 3 monorepo for creating
    a custom `translation` module. A monorepo is a strategy where you manage all your
    project’s parts within a single repository. It’s like keeping all your development
    eggs in one basket, which simplifies many aspects of development, especially for
    large projects. In our setup, the monorepo will include not just a Nuxt application
    but a series of packages and apps, each contributing different functionalities
    to the overarching system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Monorepos are valuable for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unified version control**: Everything from code to documentation is stored
    in one place, making it easier to track changes and maintain versions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplified dependency management**: All parts of the project use the same
    dependencies, which means they all get updated at once, reducing compatibility
    issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced code reusability**: Monorepos allow teams to easily share common
    code and resources across multiple projects within the same repository. This facilitates
    reusing packages, reducing redundancy, and enhancing consistency across different
    applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we understand monorepos’ role in handling complex projects efficiently,
    we’ve set the stage for exploring how they facilitate the development of extensive
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Nuxt monorepo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we begin by establishing the foundational structure for our
    Nuxt monorepo. Instead of starting with the typical Nuxt project creation command,
    we’ll approach this setup by first crafting a dedicated environment that supports
    a multi-package architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a new directory specifically for this chapter’s project
    to keep our workspace organized and separate from other projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use `pnpm` to initialize a new project. This step involves creating a
    `package.json` file that will define our workspace and manage our project’s dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can open the newly created project directory in Visual Studio Code
    or your preferred IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'To designate our directory as a monorepo, we introduce a `pnpm-workspace.yaml`
    file. This configuration file plays a crucial role in managing multiple packages
    within a single repository efficiently. In this, we specify where the packages
    of our monorepo are located. The structure we’ve chosen categorizes our workspace
    into two primary directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`packages/*`: This directory is reserved for shared libraries or modules that
    can be reused across multiple applications within the monorepo. In our case, this
    is where the `translation` module will reside.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apps/*`: Dedicated to housing applications that may depend on any shared modules.
    Our Nuxt application demonstrating the use of the `translation` module will be
    placed here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, we’re ready to set up the website application that we’ll use to include
    the custom Nuxt module inside it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a website application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set up our project directories properly within the monorepo, begin by creating
    an `apps` directoy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `apps` directory, we’ll establish a new Nuxt application using the
    latest version of Nuxt 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After initializing the Nuxt application, you can typically start the application
    by navigating into the `demo-website` directory and running `pnpm dev`. However,
    leveraging the full capability of our monorepo setup facilitated by `pnpm` workspaces,
    we can streamline this process. First, ensure the project name within the `apps/demo-website/package.json`
    file is set appropriately to reflect our specific setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After updating the project name, you can now execute commands from the root
    of the monorepo. This is done using `pnpm`’s `--filter` option, which targets
    specific subprojects. To run our Nuxt application from the monorepo root, use
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This command tells `pnpm` to apply the `dev` script specifically to the `demo-website`
    project, allowing you to manage and run multiple projects within your monorepo
    seamlessly from a central location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going further, you can create a custom script in the root `package.json` file,
    which calls this command under the hood:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run this command in the root folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The application should start, and you should see a welcome page as usual. With
    our application set up, let’s continue to create a `translation` module.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a custom translation module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we continue creating our custom `translation` module, the first step in
    this process is to set up a dedicated directory for our shared packages. Navigate
    to the root of your monorepo and create a directory named `packages`. This directory
    will host all our shared logic, including the new `translation` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once inside the `packages` directory, we will use Nuxt’s module template to
    kickstart our `translation` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This command sets up a new module with a starter template provided by Nuxt,
    complete with several essential directories and files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`module.ts`: This is the core file where our module is defined. It acts as
    the entry point and defines the configuration and setup of the module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runtime/plugin.ts`: This file serves as an example plugin. It’s a place to
    extend the module with additional functionalities such as Vue plugins and helper
    functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playground/`: Contains a Nuxt application with our module already installed.
    This environment is useful for testing and demonstrating the module’s functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test/`: A directory set up for writing tests for the module to ensure its
    functionality and stability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s discover the `module.ts` file to understand its structure and components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This script outlines the basic structure of a Nuxt `pnpm` module using `defineNuxtModule`.
    The `meta` property defines the module’s name and configuration key. The `setup`
    function is where module-specific logic is added, such as registering plugins,
    using Nuxt hooks, adding an auto import directory, or even extending routes.
  prefs: []
  type: TYPE_NORMAL
- en: The `createResolver` function helps in resolving paths correctly, ensuring that
    any URL is added without issues related to path resolution.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s use this module in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the module in our application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, rename the newly created module directory from `my-module` to `translation`
    to better reflect its purpose. This involves updating the name in the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, update the name in the package configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Then, ensure that build files of the modules are generated. To do so, run the
    following command in the `translation`
  prefs: []
  type: TYPE_NORMAL
- en: 'module root folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This prepares local files for development.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the module configured, you can now add it to our demo website. From the
    root of your monorepo, run the following command to link the module locally to
    your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `--workspace` flag tells `pnpm` to resolve the translation package from
    the local workspace instead of fetching it from an external registry. This setup
    ensures that the web app recognizes our packages and that any changes to the module
    are immediately available to the application during development.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that the module was added successfully, check the `package.json`
    file of your demo website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `translation` dependency should now be listed and pointing to your local
    workspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the module to your Nuxt configuration to activate it within your
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, start your application to see the module in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Look for the console output or other indicators from the module’s default setup
    to confirm that it’s functioning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: Translation plugin injected](img/B19760_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Translation plugin injected'
  prefs: []
  type: TYPE_NORMAL
- en: This message, if visible, confirms that the `translation` module’s example plugin
    is actively injecting functionality into your Nuxt application.
  prefs: []
  type: TYPE_NORMAL
- en: With these steps completed, your demo website now successfully incorporates
    the `translation` module. We’re now ready to customize the module further and
    define specific options specified to our project’s needs.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring translation module options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start adding options for our `translation` module, it’s essential
    to understand how Nuxt modules typically offer configuration flexibility. Similar
    to how the official Nuxt `i18n` module allows configuration of `defaultLocale`
    and `locales` through the Nuxt config, we aim to provide a similar configurability
    in our custom module. This setup will enable users to define and manage locales
    dynamically through the module’s options.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `translation` module, we begin by defining the expected options for
    configuration. This involves setting up an interface in `types.ts` that outlines
    the structure of the configuration options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, `ModuleOptions` allows for specifying a `defaultLocale` instance and an
    array of `locales` instances, each with a name and a file path pointing to the
    translations. We’ll discuss later on how to import these files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step involves integrating these types into the main module file. Import
    the defined types into `module.ts` and use them to strongly type the module’s
    configuration. Make sure to remove the empty defined interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `defaults` object is updated to provide a fallback for `defaultLocale` and
    an empty array for locales, ensuring that the module can initialize even if specific
    configurations are not provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'To utilize the module’s capabilities fully, add it to the `nuxt.config.ts`
    file of your Nuxt application, specifying the options like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon specifying these options, Nuxt’s intelligent configuration handling should
    offer autocomplete suggestions for `translation` options, reflecting the integration
    of our module options into the Nuxt ecosystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: IntelliSense translation options](img/B19760_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: IntelliSense translation options'
  prefs: []
  type: TYPE_NORMAL
- en: When adjusting settings in the Nuxt configuration file, you should be able to
    see IntelliSense suggestions that validate the correct integration of our module
    options, confirming that the setup is recognized by Nuxt.
  prefs: []
  type: TYPE_NORMAL
- en: After setting up basic configuration handling in our module, the subsequent
    task involves implementing logic within the module to dynamically load and apply
    the specified locales based on the provided configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: Reading local files inside the module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s integrate local file reading capabilities into our Nuxt module to handle
    translations effectively. This functionality will enable our module to dynamically
    load translation files specified in the module’s configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by defining the expected structure of the translation files. Assume each
    file contains flat key-value pairs representing localized strings. For instance,
    set up the English and French localization files within the demo website:'
  prefs: []
  type: TYPE_NORMAL
- en: 'English localization file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'French localization file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, modify your Nuxt configuration file and add these files to the `locales`
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s go back to the module to process these files. Start by defining
    a type for the messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Remember that we’re assuming the `locales` translation files will be a flat
    key-value pair. You can handle nested objects, but to simplify the process, we’ll
    only use one level of keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, update your module’s `setup` function to loop through the locales,
    resolve their paths, read their contents, and then parse them into a usable format.
    Here’s how you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a code breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`localesResolver`: Resolves paths relative to the project’s source directory,
    which is stored in `nuxt.options.srcDir`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readFileSync`: Synchronously reads the content of the file at the resolved
    path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JSON.parse`: Converts the JSON string from the file into a JavaScript object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nuxt.options.runtimeConfig.public.translation`: Stores messages in the Nuxt
    runtime config, making them accessible throughout the application via the `useRuntimeConfig()`
    composable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To verify the integration, modify the main application component to display
    the loaded messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart your Nuxt application and navigate to the home page. You should now
    see the translation options displayed, as well as the localization messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: Displaying translation array output](img/B19760_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Displaying translation array output'
  prefs: []
  type: TYPE_NORMAL
- en: Now that our module can load translation messages, we’ll enhance its functionality
    by adding a plugin to create a global helper function. This function will allow
    us to easily retrieve and display translated strings throughout the Nuxt application.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding the module with plugins, composables, and components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll start by developing a composable that manages the user’s preferred language.
    This composable will help in retrieving the correct locale from cookies or default
    to the configured locale from our module options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the module, create a new file for the composable: `runtime/composables/useTranslation.ts`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Develop the composable function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a code breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`useRuntimeConfig`: Accesses runtime configuration, which includes translation
    settings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useCookie`: A `ref` that manages cookie values: `get` – `set`, particularly
    for storing user’s locale preference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`computed`: Reactively calculates the correct messages to use based on the
    current locale'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When developing a Nuxt module, it’s essential to import any function or composable
    that is auto-imported by default in a Nuxt app explicitly from `#imports`. This
    approach ensures that the module can utilize Nuxt’s auto-import feature, which
    is not inherently available in the module’s scope as it would be within a Nuxt
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure our composable is easily accessible within the Nuxt app, we’ll automate
    its import. Update the `module.ts` file to auto-import the `composables` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`addImportsDir` automatically imports files from the specified directory, making
    the composables readily available to the Nuxt app without manual `import` statements.
    Thus, this folder will act exactly like the `composables` folder, which is inside
    your Nuxt application!'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the composable ready, let’s test its functionality. Update `app.vue` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This setup should display a welcome message based on the default or user-defined
    locale. Because we didn’t update the default locale, the module will use `''en''`
    as the default value, as it is configured in the module file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4: Messages array based on the default locale](img/B19760_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Messages array based on the default locale'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s ensure that our module can respect locale overrides specified in
    the Nuxt configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'By setting `defaultLocale` to `''fr''` and accessing the app in a private window
    (to clear previous cookies), a French translation should appear, demonstrating
    the flexibility and dynamic capability of our `translation` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5: Messages array based on the default locale](img/B19760_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Messages array based on the default locale'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move forward to enhance the module with a plugin that provides a
    global `$t` global function for fetching translated messages directly. This will
    simplify the use of translations throughout the application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a $t helper function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we create a new `translate.ts` file inside the `runtime/plugins` directory
    of the module. This file will contain the logic for our translation function.
    Here’s how to write a plugin to fetch translations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a code breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: We’re importing `useTranslation`, which manages the translation state and provides
    translations based on the current locale.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’re defining plugins using `defineNuxtPlugin`. The `#imports` alias is used
    here to automatically resolve to the correct utility versions provided by Nuxt.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’re implementing a `t` translator function that takes a key as an argument.
    It attempts to retrieve the translation for this key from the `messages` object
    obtained from `useTranslation`. If a translation for the key doesn’t exist, it
    defaults back to the key itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’re providing `Translator` as a global helper function by adding `return
    { provide: { t } }` to the end of the plugin definition function. By providing
    `t`, any component within the application can use this function to render translated
    text using: `$t`. Nuxg automatically add `$` to any function provided by nuxt
    module to access it globally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, integrate this plugin into our Nuxt module by updating the `module.ts`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, update your application’s main component, `app.vue`, to use the `$``t`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Once implemented, test by running your application and navigating. You should
    see the translated strings rendering based on the active locale:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6: $t function output](img/B19760_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: $t function output'
  prefs: []
  type: TYPE_NORMAL
- en: For the final expansion, we’ll create a component that allows users to switch
    languages directly from their web interface.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a language switcher component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll create a language switcher component using the menu component from the
    `@nuxt/ui` package. Firstly, install the `@nuxt/ui` package within our module’s
    scope. From the root of your project, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `module.ts` file, verify and install `@nuxt/ui` if it’s not already
    present in the host application, and ensure to auto-import the new `components`
    directory. Nuxt Kit provides various helper functions to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hasNuxtModule`: Checks whether `@nuxt/ui` is already installed in the host
    application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`installModule`: Dynamically installs `@nuxt/ui` if it is not found'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addComponentsDir`: Adds the directory containing our custom components to
    Nuxt’s auto-import feature, allowing these components to be used without manual
    import'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s the updated version of the `module.ts` setup function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a new `LanguageSwitcher.vue` component within the `runtime/components`
    directory. This component will utilize the `USelectMenu` UI component from `@nuxt/ui`
    to render a dropdown for language selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an explanation of the components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`USelectMenu`: A UI component from `@nuxt/ui` that renders a dropdown menu.
    It binds to the `locale` reactive variable and updates it based on user selection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`locales`: An array of available languages that populate the dropdown options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To ensure the `LanguageSwitcher` component is functioning correctly, run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This prepares the module with the new component. Then, update the `app.vue`
    file in your Nuxt application to use the `LanguageSwitcher` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Refresh your browser to test the functionality. You should see a welcome message
    as well as a select menu that contains two locales: `en` and `fr`. Changing the
    language using the dropdown should dynamically update the welcome message, demonstrating
    the reactive translation updates across the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7: LanguageSelector component](img/B19760_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: LanguageSelector component'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we managed to use the `@nuxt/ui` package within the module without
    direct installation in the host application, exemplifying the flexibility of Nuxt
    modules. We can still install this package in our host application, and this won’t
    result in any error due to the `hasNuxtModule` checker function.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve finished implementing our custom modules in Nuxt 3, let’s look
    ahead to how we can further refine and expand these concepts in real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: Future directions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we conclude this chapter, it’s important to reflect on the underlying principles
    that guided our journey through building a custom `i18n` module within a monorepo
    structure. The focus was not on the aesthetics of the application but on the architecture—specifically,
    the creation of a module system. This approach is particularly beneficial for
    large-scale projects where managing complexity efficiently is crucial.
  prefs: []
  type: TYPE_NORMAL
- en: POS system example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In real-world scenarios, especially in enterprise environments, applications
    are rarely simple. They often consist of numerous interconnected parts, such as
    a **point-of-sale** (**POS**) system, which might include modules for handling
    orders, promotions, customer management, and more. Each of these modules can be
    designed to operate independently, containing its own pages, logic, components,
    and state management.
  prefs: []
  type: TYPE_NORMAL
- en: In such a system, different modules can be developed and maintained independently.
    For instance, a promotions module might handle all promotional offers and discount
    logic. If the business decided to overhaul its promotions strategy, only the promotions
    module would need to be updated or replaced, minimizing risk and disruption to
    other parts of the system.
  prefs: []
  type: TYPE_NORMAL
- en: E-commerce platform example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modular systems are particularly beneficial in complex e-commerce platforms,
    where different functionalities such as product catalog management, order processing,
    payment integrations, and user profiles are essential yet distinct components.
    Each module can be separately developed, tested, and deployed, allowing for flexible
    updates and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the payment integration module might support various payment gateways
    and handle all the complexities of transactions. If new payment methods need to
    be added or existing ones need updates due to regulatory changes, developers can
    focus solely on this module. This modular approach speeds up development and deployment
    and ensures that updates in one area, such as payment processing, do not inadvertently
    affect unrelated parts such as the product catalog or user management systems.
  prefs: []
  type: TYPE_NORMAL
- en: Final thoughts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal of this chapter was to underscore the transformative impact of modular
    architecture on the development and scalability of large-scale applications. By
    adopting a modular approach, developers can efficiently manage complex systems,
    facilitating easier updates, testing, and expansion. Moving forward, apply the
    strategies explored here to structure your projects effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, this journey highlighted the great developer experience provided
    by Nuxt, which simplifies the creation of custom modules. Nuxt’s framework supports
    extensive customization, allowing for seamless integration of options, components,
    plugins, and composables. This flexibility ensures our applications meet current
    needs while also being well prepared for future advancements and integrations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we spotlit the creation of a custom `translation` module within
    a Nuxt 3 monorepo, designed to streamline the management of large-scale projects.
    We began by establishing a monorepo setup using `pnpm`, which allowed us to structure
    our project into separate but interconnected workspaces. This foundation supported
    the development of our `translation` module, starting from a basic Nuxt module
    template. By configuring module options, we customized the module to handle multiple
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: Further enhancing the module, we integrated plugins, components, and composables,
    providing a dynamic and user-friendly way to switch languages and manage translations.
  prefs: []
  type: TYPE_NORMAL
- en: This practical application demonstrated how modular architecture enhances code
    reuse while also simplifying enhancements and scalability. The concluding discussion
    on future directions explored the potential for where we can use this modular
    approach in other domains, such as e-commerce or enterprise systems, illustrating
    the broad applicability and flexibility of the techniques learned.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter serves as a blueprint for developers looking to fully utilize Nuxt’s
    modular capabilities in their projects.
  prefs: []
  type: TYPE_NORMAL
- en: Practice questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Describe the process of setting up a monorepo with `pnpm` for a Nuxt 3 project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the key benefits of using a monorepo structure in large-scale Nuxt
    3 projects?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you initiate a new Nuxt 3 module within a monorepo?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you add a Nuxt module to a Nuxt application within the same monorepo?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does the `addPlugin` function do within a Nuxt module?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the role of `runtimeConfig` in a Nuxt module?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe the purpose of using `createResolver` within a Nuxt module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain how the `hasNuxtModule` and `installModule` functions are used in a
    module setup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you add and use a composable within a Nuxt module?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you configure a Nuxt module to automatically import components from
    a specified directory when the module is used in a project?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nuxt modules: [https://nuxt.com/docs/guide/concepts/modules](https://nuxt.com/docs/guide/concepts/modules)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Module author guide: [https://nuxt.com/docs/guide/going-further/modules/](https://nuxt.com/docs/guide/going-further/modules/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pnpm` workspaces: [https://pnpm.io/workspaces](https://pnpm.io/workspaces)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nuxt lifecycle hooks: [https://nuxt.com/docs/guide/going-further/hooks](https://nuxt.com/docs/guide/going-further/hooks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nuxt auto-imports concept: [https://nuxt.com/docs/guide/concepts/auto-imports](https://nuxt.com/docs/guide/concepts/auto-imports)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
