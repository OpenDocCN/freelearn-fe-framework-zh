- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Automated Testing, CI, and Release to Production
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试、持续集成和发布到生产环境
- en: Ship it, or it never happened! In *Chapter 3*, *Creating a Basic Angular App*,
    you created a local weather application that could retrieve current weather data.
    You have created some amount of value in doing this; however, if you don't put
    your app on the web, you end up creating zero value. This motivation to ship your
    work is prevalent in many industries. However, delivering a piece of work to someone
    else or opening it up to public scrutiny can be terrifying. In software engineering,
    delivering anything is difficult; delivering something to production is even more
    difficult. This chapter is going to help you implement a **Continuous Integration**
    (**CI**) pipeline. A CI pipeline is going to help you achieve frequent, reliable,
    high-quality, and flexible releases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 发布它，否则它从未发生过！在**第3章**中，您在**创建基本Angular应用**时创建了一个可以检索当前天气数据的应用程序。您在这个过程中创造了一定的价值；然而，如果您不将您的应用放到网络上，您最终创造的价值为零。将您的作品发布出去的这种动机在许多行业中都很普遍。然而，将作品交付给他人或公开接受审查可能会令人恐惧。在软件工程中，交付任何东西都是困难的；将东西交付到生产环境则更加困难。本章将帮助您实现**持续集成**（**CI**）管道。持续集成管道将帮助您实现频繁、可靠、高质量和灵活的发布。
- en: Frequent and reliable releases are only possible if we have a set of automated
    tests that can quickly verify the correctness of our code for us. The app we created
    in the previous chapter has failing unit and **end-to-end** (**e2e**) tests. We
    need to fix these unit tests and then ensure that they never break again by leveraging
    GitHub flow and CircleCI. Then we're going to cover how you can deliver your Angular
    app to the web. In *Chapter 9*, *DevOps Using Docker*, we are going to cover **Continuous
    Delivery** (**CD**) pipelines, which can also automate your delivery.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在我们有一套可以快速验证我们代码正确性的自动化测试时，才能实现频繁和可靠的发布。我们在上一章创建的应用程序有失败的单元测试和**端到端**（**e2e**）测试。我们需要修复这些单元测试，然后通过利用GitHub工作流和CircleCI确保它们不再中断。然后我们将介绍如何将您的Angular应用交付到网络上。在第9章**使用Docker进行DevOps**中，我们将介绍**持续交付**（**CD**）管道，它也可以自动化您的交付。
- en: 'Check out my 2018 talk, *Ship It or It Never Happened: The Power of Docker,
    Heroku & CircleCI*, at [https://bit.ly/ship-it-or-it-never-happened](https://bit.ly/ship-it-or-it-never-happened).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我的2018年演讲，*发布它，否则它从未发生过：Docker、Heroku和CircleCI的力量*，链接为[https://bit.ly/ship-it-or-it-never-happened](https://bit.ly/ship-it-or-it-never-happened)。
- en: 'This chapter covers:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下内容：
- en: Unit testing with test doubles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试替身进行单元测试
- en: Angular unit tests using Jasmine
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jasmine进行Angular单元测试
- en: Angular e2e tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular端到端测试
- en: GitHub flow
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub工作流
- en: Production readiness
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产就绪
- en: CI using CircleCI
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CircleCI进行持续集成
- en: Deploying an app on the web using Vercel Now
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vercel Now在网络上部署应用
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the following linked repository. The repository contains the code in its final
    and complete state. You can verify your progress at the end of this chapter by
    looking for the end-of-chapter snapshot of code under the `projects` folder.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书样本代码的最新版本可在以下链接的GitHub仓库中找到。该仓库包含代码的最终和完整状态。您可以通过查看“projects”文件夹下的章节末尾代码快照来验证本章的进度。
- en: 'For *Chapter 4*:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**第4章**：
- en: Clone the repo [https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app
    )
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆以下仓库 [https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
- en: Execute `npm install` on the root folder to install dependencies
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根文件夹中执行`npm install`以安装依赖项
- en: 'The code sample for this chapter is in the following sub-folder:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章的代码示例位于以下子文件夹中：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To run the Angular app for this chapter, execute:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的Angular应用，请执行以下命令：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To run Angular unit tests for this chapter, execute:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的Angular单元测试，请执行以下命令：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To run Angular e2e tests for this chapter, execute:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的Angular端到端测试，请执行以下命令：
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To build a production-ready Angular app for this chapter, execute:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建本章的生产就绪Angular应用，请执行以下命令：
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the `dist/ch4` folder at the root of the repository will contain the
    compiled result.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，仓库根目录下的`dist/ch4`文件夹将包含编译结果。
- en: Beware that the source code in the book or on GitHub may not always match the
    code generated by the Angular CLI. There may also be slight differences in implementation
    between the code in the book and what's on GitHub because the ecosystem is ever-evolving.
    It is natural for the sample code to change over time. Also, on GitHub, expect
    to find corrections, fixes to support newer versions of libraries, or side-by-side
    implementations of multiple techniques for the reader to observe. You are only
    expected to implement the ideal solution recommended in the book. If you find errors
    or have questions, please create an issue or submit a pull request on GitHub for
    the benefit of all readers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，书中或GitHub上的源代码可能并不总是与Angular CLI生成的代码相匹配。由于生态系统不断演变，书中代码与GitHub上代码之间的实现也可能存在细微差异。随着时间的推移，示例代码发生变化是自然的。此外，在GitHub上，您可能会找到更正、支持库新版本的修复，或者为读者观察而并排实现多种技术的示例。您只需实现书中推荐的理想解决方案即可。如果您发现错误或有疑问，请为所有读者创建GitHub上的问题或提交拉取请求。
- en: You can read more about updating Angular in *Appendix C*, *Keeping Angular and
    Tools Evergreen*. You can find this appendix online from [https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.)
    or at [https://expertlysimple.io/stay-evergreen](https://expertlysimple.io/stay-evergreen).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在**附录C**，*保持Angular和工具常青*中了解更多关于更新Angular的内容。您可以从[https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.)或[https://expertlysimple.io/stay-evergreen](https://expertlysimple.io/stay-evergreen)在线找到这个附录。
- en: Throughout this chapter, you need to sign up for accounts at CircleCI and Vercel
    Now. But before we can deploy our app, we need to ensure we have automated tests in
    place to ensure the quality of our app over time. First, we will deep dive into
    unit testing fundamentals to familiarize you with the benefits of test-driven
    development and cover principles like FIRST and SOLID.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您需要在CircleCI和Vercel Now上注册账户。但在我们可以部署我们的应用程序之前，我们需要确保我们已自动部署测试来确保我们的应用程序的质量随时间保持。首先，我们将深入探讨单元测试基础，让您熟悉测试驱动开发的益处，并介绍如FIRST和SOLID等原则。
- en: Unit testing
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit testing is crucial to ensure that the behavior of your application doesn't
    unintentionally change over time. Unit tests are going to enable you and your
    team to continue making changes to your application without introducing changes
    to previously verified functionality. Developers write unit tests, where each
    test is scoped to test only the code that exists in the **Function Under Test**
    (**FUT**) or **Class Under Test** (**CUT**). Angular components and services are
    all classes; however, you are also encouraged to develop reusable functions. Unit
    tests should be plentiful, automated, and fast. You should write unit tests alongside
    the original code. If they are separated from the implementation, even by a day
    or two, you are going to start forgetting the details of your code. Because of
    that, you may forget to write tests for potential edge cases.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试对于确保您的应用程序的行为不会无意中随时间改变至关重要。单元测试将使您和您的团队能够继续对应用程序进行更改，而不会引入先前已验证的功能的变化。开发者编写单元测试，其中每个测试的范围仅限于测试**待测试函数**（**FUT**）或**待测试类**（**CUT**）中的代码。Angular组件和服务都是类；然而，也鼓励您开发可重用的函数。单元测试应该数量充足、自动化且快速。您应该在原始代码旁边编写单元测试。如果它们与实现分离，即使是一两天，您也可能开始忘记代码的细节。正因为如此，您可能会忘记为潜在的边缘情况编写测试。
- en: 'Unit tests should adhere to the FIRST principle:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应遵循**FIRST原则**：
- en: '**F**ast'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**F**ast'
- en: '**I**solated'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**solated'
- en: '**R**epeatable'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**R**epeatable'
- en: '**S**elf-verifying'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**elf-verifying'
- en: '**T**imely'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**T**imely'
- en: A unit test should be fast, taking only milliseconds to run, so that we can
    have thousands of them running in just a few minutes. For fast tests to be possible,
    a unit test should be isolated. It shouldn't talk to a database, make requests
    over the network, or interact with the DOM. Isolated tests are going to be repeatable,
    so that every run of the test returns the same result. Predictability means we
    can assert the correctness of a test without relying on any outside environment,
    which makes our tests self-verifying. As mentioned earlier, you should write unit
    tests promptly; otherwise, you lose the benefits of writing unit tests.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该快速，只需毫秒即可运行，这样我们就可以在几分钟内运行数千个测试。为了实现快速测试，单元测试应该是隔离的。它不应该与数据库通信、通过网络发送请求或与DOM交互。隔离的测试将是可重复的，因此每次测试运行都会返回相同的结果。可预测性意味着我们可以断言测试的正确性，而不依赖于任何外部环境，这使得我们的测试可以自我验证。如前所述，你应该及时编写单元测试；否则，你会失去编写单元测试的好处。
- en: It is possible to adhere to the FIRST principle if your tests focus only on
    a single FUT/CUT. But what about other classes, services, or parameters we must
    pass into the FUT/CUT? A unit test can isolate the behavior of the FUT/CUT by
    leveraging test doubles. A test double allows us to control outside dependencies,
    so instead of injecting an `HttpService` to your component, you may instead inject
    a fake or mocked `HttpService`. Using test doubles, we can control the effects
    of outside dependencies and create fast and repeatable tests.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的测试只关注单个FUT/CUT，那么你就可以坚持FIRST原则。但其他类、服务或我们必须传递给FUT/CUT的参数怎么办？单元测试可以通过利用测试双倍来隔离FUT/CUT的行为。测试双倍允许我们控制外部依赖，因此，而不是向你的组件注入`HttpService`，你可以注入一个假的或模拟的`HttpService`。使用测试双倍，我们可以控制外部依赖的影响，并创建快速且可重复的测试。
- en: How much testing is enough testing? You should have at least as much test code
    as production code. If you don't, then you're nowhere near writing enough tests.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 多少测试才算足够？你应该至少有与生产代码一样多的测试代码。如果没有，那么你离编写足够的测试还差得远。
- en: 'Unit tests aren''t the only kind of tests you can create, but they are by far
    the kind you should create the most of. Let''s consider the three major classes
    of tests you can create: unit, integration, and UI.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试并不是你可以创建的唯一类型的测试，但它们是你应该创建最多的一种。让我们考虑你可以创建的三个主要测试类别：单元、集成和UI。
- en: As we've said, unit tests only focus on a single FUT/CUT at a time. Integration
    tests test the integration of various components so that they can include database
    calls, network requests, and interaction with the DOM. Due to their nature, integration
    tests are slow to run, and they need to be frequently maintained. Increases in
    runtime and maintenance mean that over time, integration tests are more expensive
    than unit tests. UI tests test the application as if a user is using it, filling
    in fields, clicking on buttons, and observing the expected outcome.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，单元测试一次只关注一个FUT/CUT。集成测试测试各种组件的集成，以便它们可以包括数据库调用、网络请求以及与DOM的交互。由于它们的性质，集成测试运行速度较慢，并且需要频繁维护。运行时间和维护的增加意味着随着时间的推移，集成测试比单元测试更昂贵。UI测试模拟用户使用应用程序，填写字段、点击按钮并观察预期的结果。
- en: You may imagine that these tests are the slowest and most fragile kind of tests.
    The UI of an application changes frequently, and it is very tough to create repeatable
    tests with UI testing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想象这些测试是最慢且最脆弱的测试类型。应用程序的UI经常变化，使用UI测试创建可重复的测试非常困难。
- en: We can leverage a mixture of integration and UI testing to create acceptance
    tests. Acceptance tests are written to automate the business acceptance of the
    functionality that we deliver. Angular's e2e tests are a way to create acceptance
    tests.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用集成和UI测试的混合来创建验收测试。验收测试是为了自动化我们交付的功能的业务验收而编写的。Angular的端到端测试是一种创建验收测试的方法。
- en: 'We can visualize the pros and cons of the three major classes of automated
    testing with Mike Cohn''s Testing Pyramid, shown as following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用迈克·科恩的测试金字塔可视化三种主要自动化测试类别的优缺点，如下所示：
- en: '![](img/B14094_04_01.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_04_01.png)'
- en: 'Figure 4.1: Mike Cohn''s Testing Pyramid'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：迈克·科恩的测试金字塔
- en: The testing pyramid effectively summarizes the relative amount of tests of each
    kind we should create for our applications while considering their speed and cost.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔有效地总结了在考虑速度和成本的情况下，我们应该为我们的应用程序创建的每种类型的测试的相对数量。
- en: 'In terms of implementation, unit tests are made up of three parts:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现方面，单元测试由三个部分组成：
- en: Arrange – setup
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排 – 设置
- en: Act – run the thing you want to test
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行动 - 运行你想要测试的东西
- en: Assert – verify the results
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言 - 验证结果
- en: During the arrange step, we set up test doubles, expected outcomes, and any
    other requisite dependencies. During the act step, we execute the line of code
    we're testing. Finally, in the assert stage, we verify if the outcome of the act
    step matches the expected results defined in the arrange step. We are going to
    see how arrange, act, and assert work in practice in the next section.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在安排步骤中，我们设置测试双、预期结果和任何其他必需的依赖项。在行动步骤中，我们执行我们正在测试的代码行。最后，在断言阶段，我们验证行动步骤的结果是否与安排步骤中定义的预期结果相匹配。我们将在下一节中看到安排、行动和断言在实际中的工作方式。
- en: Let's look into what unit tests mean in Angular.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在Angular中单元测试意味着什么。
- en: Angular unit tests
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular单元测试
- en: The definition of a unit test in Angular is slightly different from the strict
    definition of unit testing we defined in the previous section. Angular CLI auto-generates
    unit tests for us using the Jasmine framework. However, these so-called unit tests
    include DOM-interactions because they render the view of the component.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中单元测试的定义与我们之前定义的单元测试的严格定义略有不同。Angular CLI使用Jasmine框架为我们自动生成单元测试。然而，这些所谓的单元测试包括DOM交互，因为它们渲染组件的视图。
- en: 'Consider the architecture of an Angular component from *Chapter 1*, *Introduction
    to Angular and Its Concepts*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *第一章*，*Angular及其概念简介* 中考虑Angular组件的架构：
- en: '![](img/B14094_04_02.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_04_02.png)'
- en: 'Figure 4.2: Anatomy of a Component'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：组件的解剖结构
- en: Since Angular uses binding, the component class and its template are inseparable,
    effectively representing a unit. We can still write pure unit tests by testing
    individual functions, but otherwise, a component and its template are considered
    the smallest possible units to test.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Angular使用绑定，组件类及其模板是不可分割的，实际上代表了一个单元。我们仍然可以通过测试单个函数来编写纯单元测试，但除此之外，组件及其模板被认为是测试的最小单元。
- en: As your application grows, you may find that Angular unit tests are slow to
    run, because they render views and resolve the dependency tree. There are various
    ways to deal with this problem, including the parallelization of test runs, opting
    out of using the Angular TestBed, and more aggressive use of test doubles.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的增长，您可能会发现Angular单元测试运行缓慢，因为它们渲染视图并解析依赖关系树。有各种方法可以解决这个问题，包括测试运行的并行化、选择不使用Angular
    TestBed以及更积极地使用测试双。
- en: As you may note, we can inject services into the component or use other components
    in our template. We are going to leverage test double mechanisms provided by Jasmine
    to isolate our components from such external dependencies.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所注意到的，我们可以将服务注入到组件中或在我们的模板中使用其他组件。我们将利用Jasmine提供的测试双机制来隔离我们的组件，使其不受此类外部依赖的影响。
- en: Let's go over what Jasmine is.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Jasmine是什么。
- en: Jasmine
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jasmine
- en: Jasmine is a behavior-driven testing framework for browser and Node.js tests.
    Jasmine also supports Ruby and Python. Jasmine is a batteries-included framework.
    It supports elemental unit testing needs, such as test fixtures, asserts, mocks,
    spies, and reporters.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine是一个用于浏览器和Node.js测试的行为驱动测试框架。Jasmine还支持Ruby和Python。Jasmine是一个包含电池的框架。它支持基本的单元测试需求，如测试固定装置、断言、模拟、间谍和报告器。
- en: 'The naming convention of a Jasmine test file involves using `spec.ts` after
    the file name, as in `fileUnderTest.spec.ts`. Jasmine tests are organized in `describe`
    blocks, which can be grouped in levels to reflect the structure of a file, class,
    or multiple tests that belong to a single function. Individual test cases, or
    specs, are represented in `it` blocks. The following sample shows a file named
    `converters.ts` exporting a function that converts Celsius to Fahrenheit:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine测试文件的命名约定是在文件名后使用`spec.ts`，例如`fileUnderTest.spec.ts`。Jasmine测试组织在`describe`块中，这些块可以按层级分组，以反映文件、类或属于单个函数的多个测试的结构。单个测试用例或规格用`it`块表示。以下示例显示了一个名为`converters.ts`的文件导出一个将摄氏度转换为华氏度的函数：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Specs are organized in a manner so that when they execute, they read like a
    sentence. In this case, the outcome would be *Converters convertCtoF should convert
    0c to 32f*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 规格以这种方式组织，当它们执行时，它们读起来像一句话。在这种情况下，结果将是 *Converters convertCtoF 应将 0c 转换为 32f*。
- en: For more information on Jasmine, visit [https://jasmine.github.io](https://jasmine.github.io).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于Jasmine的信息，请访问 [https://jasmine.github.io](https://jasmine.github.io).
- en: Next, let's cover the major categories of features of Jasmine and most other
    testing frameworks – fixtures and matches – which help you write coherent unit
    tests using the act, arrange, and assert structure.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探讨Jasmine和大多数其他测试框架的主要功能类别——固定装置和匹配器——这些功能帮助你使用行动、安排和断言结构编写连贯的单元测试。
- en: Fixtures
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 固定装置
- en: 'As mentioned earlier, a unit test has three parts: arrange, act, and assert.
    The arrange part of unit tests can be repetitive as multiple test cases often
    require the same setup. Jasmine provides fixtures to help reduce the amount of
    repetition in your score.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，单元测试有三个部分：安排、行动和断言。单元测试的安排部分可能是重复的，因为多个测试案例通常需要相同的设置。Jasmine提供固定装置来帮助减少你的代码中的重复。
- en: 'Following are the four fixtures:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是四个固定装置：
- en: '`beforeAll()` – runs before all specs in `describe`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeAll()` – 在`describe`中的所有规格之前运行'
- en: '`afterAll()` – runs after all specs in `describe` per test fixtures'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterAll()` – 在每个测试固定装置之后运行所有`describe`中的规格'
- en: '`beforeEach()` – runs before each spec in `describe`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeEach()` – 在`describe`中的每个规格之前运行'
- en: '`afterEach()` – runs after each spec in `describe`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterEach()` – 在`describe`中的每个规格之后运行'
- en: The fixtures execute before and after a spec or a group of specs as scoped with
    their `describe` block.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 固定装置在指定其`describe`块的作用域内，在某个特定或一组特定规格之前和之后执行。
- en: Matchers
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配器
- en: 'In the assert part of a unit test, we need to let Jasmine know whether a spec
    passed or failed. We can do so by writing an assertion. There are two kinds of
    assertions:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试的断言部分，我们需要让Jasmine知道一个规格是通过了还是失败了。我们可以通过编写一个断言来实现这一点。有两种断言类型：
- en: '`fail(''message'')` – this explicitly fails a spec'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fail(''message'')` – 这会明确地使一个规格失败'
- en: '`expect()` – given a matcher, this dynamically asserts if the expected outcome matches
    the actual outcome'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect()` – 给定一个匹配器，动态断言预期的结果是否与实际结果匹配'
- en: 'The expect assertion requires matchers to determine the outcome of a test.
    The combination of expect and matcher is meant to read like a sentence. Following
    are common matchers that you may use:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect`断言需要匹配器来确定测试的结果。`expect`和匹配器的组合旨在读起来像一句话。以下是一些你可能使用的常见匹配器：'
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For the full extent of Jasmine matchers, see [https://jasmine.github.io/api/edge/matchers.html](https://jasmine.github.io/api/edge/matchers.html).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Jasmine匹配器的完整范围，请参阅[https://jasmine.github.io/api/edge/matchers.html](https://jasmine.github.io/api/edge/matchers.html)。
- en: Other libraries with richer features exist, such as Jest, Mocha, or testdouble.js.
    However, when getting started with a new framework like Angular, it's important
    to keep your toolset minimal. Sticking to defaults is a good idea.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着具有更丰富功能的其他库，例如Jest、Mocha或testdouble.js。然而，当开始使用像Angular这样的新框架时，保持你的工具集最小化是很重要的。坚持默认设置是一个好主意。
- en: Additionally, Jasmine provides spies, which support stubbing and mocking, with
    the `spyOn` function. We are going to cover these test doubles in more detail
    later in the chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Jasmine还提供了间谍（spies），通过`spyOn`函数支持存根（stubbing）和模拟（mocking）。我们将在本章的后面更详细地介绍这些测试替身。
- en: Anatomy of auto-generated unit tests
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动生成单元测试的解剖结构
- en: Out of the box, Angular is configured so that you can compose your unit tests
    with Jasmine. Karma is the test runner, which can continuously monitor changes
    to your code and automatically re-run your unit tests.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Angular配置为可以使用Jasmine编写单元测试。Karma是测试运行器，它可以持续监控代码的变化，并自动重新运行你的单元测试。
- en: Angular's default configuration leverages `TestBed`, which is an Angular-specific
    component that facilitates the provision of modules, dependency injection, mocking,
    the triggering of Angular life-cycle events like `ngOnInit`, and the execution
    of template logic.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的默认配置利用了`TestBed`，这是一个特定于Angular的组件，它简化了模块的提供、依赖注入、模拟、触发Angular生命周期事件（如`ngOnInit`）以及执行模板逻辑。
- en: As discussed before, when you leverage `TestBed`, it is not possible to call
    these tests unit tests in the strictest definition of the term. This is because,
    by default, `TestBed` injects actual instances of your dependencies. This means
    when you execute your test, you're also executing code in services or other components,
    whereas you should be testing only the code that resides in the service or component that
    is currently under test. We leverage test doubles to help us write isolated and
    repeatable unit tests.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当你利用`TestBed`时，在术语的最严格定义中，不可能将这些测试称为单元测试。这是因为，默认情况下，`TestBed`注入了你的依赖项的实际实例。这意味着当你执行测试时，你也在执行服务或其他组件中的代码，而你应该只测试当前正在测试的服务或组件中的代码。我们利用测试替身来帮助我们编写隔离和可重复的单元测试。
- en: 'In *Chapter 3*, *Creating a Basic Angular App*, the Angular CLI created unit
    test files as you created new components and services, such as `current-weather.component.spec.ts`
    and `weather.service.spec.ts`. Take a look at the following spec file and observe
    the `should create` test. The framework asserts that any component of the `CurrentWeatherComponent`
    type should not to be null or undefined, but instead should be truthy:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3章*，*创建一个基本的Angular应用*中，Angular CLI在你创建新的组件和服务时创建了单元测试文件，例如`current-weather.component.spec.ts`和`weather.service.spec.ts`。请查看以下spec文件，并观察`should
    create`测试。框架断言任何`CurrentWeatherComponent`类型的组件不应为null或undefined，而应该是真值：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `WeatherService` spec contains a similar test. However, you''ll note that
    each type of tests is set up slightly differently:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeatherService` spec包含一个类似的测试。然而，你会注意到每种类型的测试设置略有不同：'
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the `WeatherService` spec's `beforeEach` function, the CUT is injected into
    `TestBed`. On the other hand, the `CurrentWeatherComponent` spec has two `beforeEach`
    functions. The first `beforeEach` function declares and compiles the component's
    dependent modules asynchronously, while the second `beforeEach` function creates
    a test fixture and starts listening to changes in the component, ready to run
    the tests once the compilation is complete.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WeatherService` spec的`beforeEach`函数中，CUT被注入到`TestBed`中。另一方面，`CurrentWeatherComponent`
    spec有两个`beforeEach`函数。第一个`beforeEach`函数异步声明和编译组件的依赖模块，而第二个`beforeEach`函数创建测试固定装置并开始监听组件的变化，一旦编译完成，就准备好运行测试。
- en: Next, let's execute our unit tests to see how many are passing or failing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们执行我们的单元测试，看看有多少通过或失败。
- en: Unit test execution
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试执行
- en: 'The Angular CLI uses the Jasmine unit testing library to define unit tests
    and the Karma test runner to execute them. Best of all, these testing tools are
    configured to be run out of the box. You may execute the unit tests with the following
    command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI使用Jasmine单元测试库来定义单元测试，并使用Karma测试运行器来执行它们。最好的是，这些测试工具已经配置好可以直接运行。你可以使用以下命令执行单元测试：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The tests are run by the Karma test runner in a new Chrome browser window. The
    main benefit of Karma is that it brings live-reloading capabilities similar to
    what the Angular CLI achieves with webpack when developing your application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是由Karma测试运行器在一个新的Chrome浏览器窗口中运行的。Karma的主要好处是它带来了类似于Angular CLI在开发应用程序时使用webpack实现的实时重新加载功能。
- en: After the initial execution of the `npm test` command, you're likely to run
    into compilation errors, because when we implemented our application code we didn't
    update the corresponding unit test code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`npm test`命令的初始执行后，你很可能会遇到编译错误，因为我们实现应用程序代码时没有更新相应的单元测试代码。
- en: During the development process, it is normal to run into many errors. So, don't
    be frustrated! See *Appendix A*, *Debugging Angular*, to learn how to troubleshoot
    and debug errors using Chrome/Edge Dev Tools and VS Code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，遇到许多错误是正常的。所以，不要沮丧！参见*附录A*，*调试Angular*，了解如何使用Chrome/Edge Dev Tools和VS
    Code来调试错误。
- en: Let's how you can address these errors.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何解决这些错误。
- en: Compilation errors
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译错误
- en: It is important to update your unit test code as you develop your application
    code. Failing to do so usually results in compilation errors.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序代码时，更新你的单元测试代码是很重要的。不这样做通常会导致编译错误。
- en: Remember that test code is not built when you build your Angular app. You must
    execute `npm test` to build and run your test code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当你构建Angular应用时，测试代码不会被构建。你必须执行`npm test`来构建和运行你的测试代码。
- en: 'When you execute the tests, you should see an error message like the one following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行测试时，你应该会看到一个类似于以下错误消息：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first test we need to correct is under `app.component.spec.ts`, named `'should
    have as title "local-weather-app"'`. We deleted the app property `title` from
    `AppComponent` in the previous chapter because we were not using it. So, we don't
    need this unit test anymore.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要纠正的第一个测试位于`app.component.spec.ts`中，名为`'should have as title "local-weather-app"'`。我们在上一章中从`AppComponent`中删除了`title`属性，因为我们没有使用它。所以，我们不再需要这个单元测试。
- en: Delete the `should have as title 'local-weather-app'` unit test.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`should have as title 'local-weather-app'`单元测试。
- en: As discussed before, Jasmine combines the text provided in the `describe` and
    `it` functions. As a result, this test is called `'AppComponent should have as
    title 'local-weather-app''`. This is a convenient convention for quickly locating
    tests. As you write new tests, it is up to you to maintain readable descriptions
    of your specs.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前所述，Jasmine结合了`describe`和`it`函数中提供的文本。因此，这个测试被称为`'AppComponent should have
    as title 'local-weather-app''`。这是一个方便的约定，可以快速定位测试。当你编写新的测试时，维护你规格的可读描述取决于你。
- en: The second test to fix is under `AppComponent` and is named `should render title`.
    We render the words LocalCast Weather as the title now, so let's change the test.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个要修复的测试位于`AppComponent`下，名称为`should render title`。我们现在将“LocalCast Weather”作为标题渲染，所以让我们更改测试。
- en: 'Update the `should render title` test as shown:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`should render title`测试，如下所示：
- en: '[PRE11]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Commit your code changes.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交你的代码更改。
- en: We have fixed the logical issues in our unit tests. They should now execute
    without compilation errors. However, you should expect all of them fail because
    we haven't yet configured Angular's `TestBed`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经修复了单元测试中的逻辑问题。它们现在应该可以无编译错误地执行。然而，你应该预期它们都会失败，因为我们还没有配置Angular的`TestBed`。
- en: Test results
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试结果
- en: 'You should observe the last message on the Terminal to be `TOTAL: 2 FAILED,
    2 SUCCESS`. This is normal because we haven''t been paying attention to the tests
    at all, so let''s fix them all.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '你应该在终端上观察到最后一条信息是`TOTAL: 2 FAILED, 2 SUCCESS`。这是正常的，因为我们根本没有关注这些测试，所以让我们修复它们。'
- en: '![](img/B14094_04_03.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_04_03.png)'
- en: 'Figure 4.3: Karma Runner showing Jasmine unit test results'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：Karma Runner显示Jasmine单元测试结果
- en: Keep the Karma Runner window open side by side with VS Code so that you can
    instantly see the results of your changes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将Karma Runner窗口与VS Code并排打开，这样你可以立即看到你更改的结果。
- en: Let's now configure TestBed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来配置TestBed。
- en: Configuring TestBed
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置TestBed
- en: 'TestBed has three major features that assist you in creating unit-testable
    components:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: TestBed有三个主要功能，可以帮助你创建可单元测试的组件：
- en: Declarations – builds component classes, along with their template logic, to
    facilitate testing
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明 – 构建组件类及其模板逻辑，以方便测试
- en: Providers – provides component classes without template logic and dependencies
    that need to be injected
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者 – 提供没有模板逻辑和需要注入的依赖项的组件类
- en: Imports – imports support modules to be able to render template logic or other
    platform functionality
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入 – 导入支持模块以能够渲染模板逻辑或其他平台功能
- en: TestBed is not a hard requirement to write unit tests in Angular, a topic covered
    well at [https://angular.io/guide/testing](https://angular.io/guide/testing).
    My colleague and reviewer of this book, Brendon Caulkins, contributed a bed-less
    spec file to *Chapter 12*, *Recipes – Master/Detail, Data Tables, and NgRx* code
    samples, named `current-weather.component.nobed.spec.ts`. He cites significant
    performance increases in running the tests, with fewer imports and less maintenance,
    but a higher level of care and expertise required to implement the tests. If you're
    on a large project, you should seriously consider skipping the TestBed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: TestBed不是在Angular中编写单元测试的强制要求，这是一个在[https://angular.io/guide/testing](https://angular.io/guide/testing)中很好地介绍的话题。我的同事和本书的审稿人Brendon
    Caulkins为*第12章*，*配方 – 主/详细，数据表和NgRx*代码示例贡献了一个无床的spec文件，名为`current-weather.component.nobed.spec.ts`。他引用了在运行测试时性能显著提高，导入更少，维护更少，但需要更高水平的关注和专业知识来实现测试。如果你在一个大型项目中，你应该认真考虑跳过TestBed。
- en: You can find the sample code on GitHub at [https://github.com/duluca/local-weather-app/tree/master/projects/ch12](https://github.com/duluca/local-weather-app/tree/master/projects/ch12).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到示例代码，链接为[https://github.com/duluca/local-weather-app/tree/master/projects/ch12](https://github.com/duluca/local-weather-app/tree/master/projects/ch12)。
- en: Let's go over these features one by one while fixing the tests at hand so they
    can run successfully.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一介绍这些功能，同时修复手头的测试，以确保它们可以成功运行。
- en: Declarations
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明
- en: Declarations allow us to provide all components necessary to render the component
    under test. Normally, you will only be declaring the component that is under test.
    So, `app.component.spec.ts` declares `AppComponent` and `current-weather.component.spec.ts`
    declares `CurrentWeatherComponent` and so forth.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 声明使我们能够提供渲染待测试组件所需的所有组件。通常，你只需声明待测试的组件。因此，`app.component.spec.ts`声明了`AppComponent`，而`current-weather.component.spec.ts`声明了`CurrentWeatherComponent`等等。
- en: Note that we use `<app-current-weather>` within the template of `AppComponent`;
    however, this does not mean that we need to also declare `CurrentWeatherComponent`
    in `app.component.spec.ts`. Previous versions of Angular's TestBed required child
    components to be declared as part of the parent component's unit tests, causing
    significant overhead in creating unit tests. Including multiple components in
    declarations has the side effect of needing to inject all dependencies of all
    components declared, not just those of the one that is under test. This meant
    adding unrelated dependencies to our "unit" tests, making them integration tests.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在`AppComponent`的模板中使用了`<app-current-weather>`；然而，这并不意味着我们还需要在`app.component.spec.ts`中声明`CurrentWeatherComponent`。Angular的旧版本`TestBed`要求将子组件作为父组件单元测试的一部分进行声明，这导致了创建单元测试时的显著开销。在声明中包含多个组件会产生副作用，需要注入所有已声明组件的所有依赖项，而不仅仅是待测试组件的依赖项。这意味着将无关的依赖项添加到我们的“单元”测试中，使它们变成了集成测试。
- en: 'In this case, `CurrentWeatherComponent` is a hard-coded dependency of `AppComponent`.
    It is possible to decouple the two components further in two ways: one way is
    to inject the component dynamically using an `ng-container`, and the other would
    be to leverage the Angular Router and `router-outlet`. The `router-outlet` strategy
    is how we structure the vast majority of multi-screen Angular apps, which I cover
    in later chapters. Properly decoupling components using `ng-container` is left
    as an exercise for the reader.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`CurrentWeatherComponent`是`AppComponent`的硬编码依赖项。可以通过两种方式进一步解耦这两个组件：一种方式是使用`ng-container`动态注入组件，另一种方式是利用Angular
    Router和`router-outlet`。`router-outlet`策略是我们构建大多数多屏Angular应用的方式，我将在后面的章节中介绍。使用`ng-container`正确解耦组件的任务留给读者作为练习。
- en: 'You may try out declaring `CurrentWeatherComponent` in `app.component.spec.ts`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试在`app.component.spec.ts`中声明`CurrentWeatherComponent`：
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that doing so introduces `HttpClient`-related errors for `AppComponent`
    tests, even though `AppComponent` itself doesn''t import `WeatherService`. In
    fact, `CurrentWeatherComponent` imports `WeatherService`, which itself imports
    `HttpClient`. You can see how the complexity of the dependencies can quickly get
    out of hand. Angular unit tests are configured to not require the declaration
    of the child component, but note that the unit test framework is throwing a warning
    regarding the unknown element:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这样做会在`AppComponent`测试中引入与`HttpClient`相关的错误，尽管`AppComponent`本身没有导入`WeatherService`。实际上，`CurrentWeatherComponent`导入了`WeatherService`，而`WeatherService`本身又导入了`HttpClient`。你可以看到依赖项的复杂性是如何迅速失控的。Angular单元测试配置为不需要声明子组件，但请注意，单元测试框架正在抛出一个关于未知元素的警告：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In programming, warnings are almost as serious as errors. Not resolving warnings
    is bound to cause trouble down the line. We will cover how to properly resolve
    this issue when we cover mocks later.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，警告几乎和错误一样严重。不解决警告注定会在将来造成麻烦。当我们后面讨论模拟时，我们将介绍如何正确解决这个问题。
- en: Be sure to undo your change before moving on.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保撤销你的更改。
- en: For now, you don't need to declare child components for parent component tests,
    making it easier to have passing unit tests initially. There are certain cases
    where you must declare dependent components, such as when you are creating a custom
    control and you need to test whether your control works properly within the context
    of a component. An example of creating a custom control is included in *Chapter
    11*, *Recipes – Reusability, Routing, and Caching*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你不需要为父组件测试声明子组件，这使得最初通过单元测试变得更容易。在某些情况下，你必须声明依赖组件，例如当你创建自定义控件并需要测试你的控件是否在组件的上下文中正常工作时。创建自定义控件的例子包括在第11章的*配方
    - 可重用性、路由和缓存*中。
- en: In the next section, we will look at providers, which help us inject real and
    fake implementations of dependencies so that we can avoid testing dependencies
    like `WeatherService` and only test the "unit."
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨提供者，它们帮助我们注入依赖项的真实和模拟实现，这样我们就可以避免测试像`WeatherService`这样的依赖项，而只测试“单元”。
- en: Providers
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供者
- en: 'Providers allow us to provide components without template logic or services
    that are injected to our component under test. You''ll note that our `CurrentWeatherComponent`
    tests are not passing with an error complaining about the lack of provider for
    `HttpClient`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者允许我们在不使用模板逻辑或注入到待测试组件中的服务的情况下提供组件。你会注意到我们的`CurrentWeatherComponent`测试没有通过，出现了一个错误，抱怨缺少`HttpClient`的提供者：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is because `WeatherService`, which is injected into `CurrentWeatherComponent`,
    needs a provider for `HttpClient`. However, `CurrentWeatherComponent` has no knowledge
    of `HttpClient`. It only knows about `WeatherService`. You may guess that we're
    perhaps not strictly unit testing but actually integration testing, and you would
    be right.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为注入到 `CurrentWeatherComponent` 中的 `WeatherService` 需要一个 `HttpClient` 的提供者。然而，`CurrentWeatherComponent`
    并不知道 `HttpClient`。它只知道 `WeatherService`。你可能猜到我们可能并不是严格地进行单元测试，而是实际上在进行集成测试，你会是对的。
- en: 'However, let''s play along and add the provider for `WeatherService` to `current-weather.component.spec.ts`.
    Provide the `WeatherService` in the declarations in `current-weather.component.spec.ts`,
    as shown:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们继续并将在 `current-weather.component.spec.ts` 中添加 `WeatherService` 的提供者。在
    `current-weather.component.spec.ts` 中的声明中提供 `WeatherService`，如下所示：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, we have provided the actual implementation of `WeatherService`,
    which doesn't resolve the issue at hand. The implementation of `WeatherService`
    still depends on `HttpClient` and the error persists.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们提供了 `WeatherService` 的实际实现，但这并没有解决当前的问题。`WeatherService` 的实现仍然依赖于 `HttpClient`，错误仍然存在。
- en: Be sure to undo your change before moving on.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保撤销您的更改。
- en: Providers allow us to provide alternative implementations of a dependency, like
    a fake or a mock of that dependency.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者允许我们提供依赖项的替代实现，如该依赖项的伪造或模拟。
- en: 'If we deﬁne a fake implementation of `WeatherService` named `FakeWeatherService`,
    we can provide the fake instead of the actual implementation with `useClass` shown
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们定义一个名为 `FakeWeatherService` 的 `WeatherService` 伪造实现，我们可以通过以下 `useClass`
    方式提供伪造而不是实际实现：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A fake implementation would break the dependency on `HttpClient` and resolve
    our issue. I go over how to implement fakes in the upcoming section on test doubles.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 伪造实现将打破对 `HttpClient` 的依赖，并解决我们的问题。我将在下一节关于测试替身的部分中介绍如何实现伪造。
- en: 'Alternatively, if we create a mock for `WeatherService` named `mockWeatherService`,
    we can provide the mock with `useValue` shown as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们为 `WeatherService` 创建一个名为 `mockWeatherService` 的模拟，我们可以通过以下方式提供模拟的 `useValue`：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With a mock, we wouldn't even have to implement a fake class and ensure that
    we're only testing the component under test. The upcoming section on test doubles
    covers mocks in detail.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟，我们甚至不需要实现伪造类并确保我们只测试正在测试的组件。下一节关于测试替身的部分将详细介绍模拟。
- en: Now that we have a good understanding of what providers can and can't do for
    us, let's see how imports round out `TestBed`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地理解了提供者能为我们做什么以及不能做什么，让我们看看导入如何完善 `TestBed`。
- en: Imports
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入
- en: Imports help bring in code that can facilitate the rendering of views or other
    dependencies to the test. Currently, the tests are still failing, because `WeatherService`
    itself depends on `HttpClient`, so we need to provide `HttpClient`. If we do,
    then our unit test will attempt to make calls over HTTP. We don't want our tests
    to depend on other services, as this goes against the FIRST principles covered
    earlier in the chapter. So, we shouldn't provide the actual `HttpClient`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 导入有助于引入代码，这些代码可以促进视图或其他依赖项的渲染到测试中。目前，测试仍然失败，因为 `WeatherService` 本身依赖于 `HttpClient`，因此我们需要提供
    `HttpClient`。如果我们这样做，那么我们的单元测试将尝试通过 HTTP 进行调用。我们不希望我们的测试依赖于其他服务，因为这违反了本章前面提到的
    FIRST 原则。因此，我们不应该提供实际的 `HttpClient`。
- en: Angular provides a test double for `HttpClient` named `HttpClientTestingModule`.
    To leverage it, you must import it, which automatically provides the test double
    for you.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 为 `HttpClient` 提供了一个名为 `HttpClientTestingModule` 的测试替身。为了利用它，您必须导入它，这将自动为您提供测试替身。
- en: 'Import `HttpClientTestingModule` for `current-weather.component.spec.ts`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '为 `current-weather.component.spec.ts` 导入 `HttpClientTestingModule`:'
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Similar to `HttpClientTestingModule`, there's also a `RouterTestingModule` and
    a `NoopAnimationsModule`, which are mock versions of the real services, so the
    unit tests can focus on only testing the component or service code that you write.
    In later chapters, we also cover how you can write your own mocks.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `HttpClientTestingModule` 类似，还有一个 `RouterTestingModule` 和 `NoopAnimationsModule`，它们是真实服务的模拟版本，因此单元测试可以仅关注测试您编写的组件或服务代码。在后面的章节中，我们还将介绍如何编写您自己的模拟。
- en: Phew! Now, all your unit tests should be passing. As you can see, the `CurrentWeatherComponent`
    tests are not our unit tests, because they are using the actual `WeatherService`,
    which itself depends on `HttpClient`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 呼吸！现在，所有您的单元测试都应该通过。如您所见，`CurrentWeatherComponent` 测试不是我们的单元测试，因为它们正在使用实际的 `WeatherService`，而
    `WeatherService` 本身依赖于 `HttpClient`。
- en: Now, let's look into how test doubles can help us write unit tests that adhere
    to FIRST principles.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看测试替身如何帮助我们编写符合 FIRST 原则的单元测试。
- en: Test doubles
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试替身
- en: Only the code in the CUT should be exercised. In the case of the `CurrentWeatherComponent`,
    we need to ensure that the service code is not executed. For this reason, you
    should *never* provide the actual implementation of the service.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 应该只对 CUT（Cut，即代码单元测试中的“代码单元”）中的代码进行测试。在 `CurrentWeatherComponent` 的情况下，我们需要确保服务代码不被执行。因此，你应该*永远*不要提供服务的实际实现。
- en: 'We need to go over two types of test doubles:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要了解两种测试替身类型：
- en: Fakes
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟
- en: Mocks, stubs, or spies
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟、存根或间谍
- en: In general, it is easier to reason about fakes, so we will start with that.
    Once you're comfortable with unit testing and your existing set of tests are in
    working order, I highly recommend switching over to exclusively using mocks, as
    it'll make your tests more robust, efficient, and maintainable.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对模拟进行推理更容易，所以我们将从这里开始。一旦你对单元测试感到舒适，并且你的现有测试集处于正常工作状态，我强烈建议切换到仅使用模拟，这将使你的测试更加健壮、高效和易于维护。
- en: Fakes
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟
- en: A fake is an alternative, simplified implementation of an existing class. It's
    like a fake service, where no actual HTTP calls are made, but your service returns
    pre-baked responses. During unit testing, a fake is instantiated and is used like
    the real class. In the previous section, we used `HttpClientTestingModule`, which
    is a fake `HttpClient`. Our custom service is `WeatherService`, so we must provide
    our implementation of a test double.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是一个现有类的替代、简化实现。它就像一个模拟服务，其中不进行任何实际的 HTTP 调用，但你的服务返回预制的响应。在单元测试期间，模拟被实例化并像真实类一样使用。在前一节中，我们使用了
    `HttpClientTestingModule`，这是一个模拟的 `HttpClient`。我们的自定义服务是 `WeatherService`，因此我们必须提供我们的测试替身实现。
- en: We create a test double by creating a fake of the service. Since the fake of
    the `WeatherService` is used in tests for multiple components, your implementation
    should be in a separate file. For the sake of the maintainability and discoverability
    of your codebase, one class per file is a good rule of thumb to follow. Keeping
    classes in separate files saves you from committing certain coding sins, like
    mistakenly creating or sharing global state or standalone functions between two classes,
    keeping your code decoupled in the process.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建服务的模拟来创建测试替身。由于 `WeatherService` 的模拟在测试多个组件时使用，你的实现应该在一个单独的文件中。为了保持代码库的可维护性和可发现性，每个文件一个类是一个很好的经验法则。将类保存在单独的文件中可以防止你犯一些编程错误，比如在两个类之间错误地创建或共享全局状态或独立函数，从而在过程中保持代码解耦。
- en: We also need to ensure that APIs for the actual implementation and the test
    double don't go out of sync over time. We can accomplish this by creating an interface
    for the service.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保实际实现和测试替身的 API 随时间不会不同步。我们可以通过为服务创建一个接口来实现这一点。
- en: 'Add `IWeatherService` to `weather.service.ts`, as shown:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `IWeatherService` 添加到 `weather.service.ts` 中，如下所示：
- en: '[PRE19]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Update `WeatherService` so that it implements the new interface:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `WeatherService` 以实现新的接口：
- en: '[PRE20]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Create a new file `weather/weather.service.fake.ts`
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件 `weather/weather.service.fake.ts`
- en: 'Implement a basic fake in `weather.service.fake.ts`, as follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `weather.service.fake.ts` 中实现一个基本的模拟，如下所示：
- en: '[PRE21]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We're leveraging the existing `ICurrentWeather` interface that our fake data
    has correctly shaped, but we must also turn it into an `Observable`. This is easily
    achieved using `of`, which creates an observable sequence, given the provided
    arguments.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在利用现有的 `ICurrentWeather` 接口，我们的模拟数据已经正确地塑造了它，但我们必须将其转换为 `Observable`。这可以通过使用
    `of` 来轻松实现，它根据提供的参数创建一个可观察的序列。
- en: Now you're ready to provide the fake to `AppComponent` and `CurrentWeatherComponent`.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，你已经准备好为 `AppComponent` 和 `CurrentWeatherComponent` 提供模拟了。
- en: 'Update the provider in `current-weather.component.spec.ts` to use `WeatherServiceFake`
    so that the fake is used instead of the actual service:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `current-weather.component.spec.ts` 中的提供者，以使用 `WeatherServiceFake`，这样就会使用模拟而不是实际的服务：
- en: '[PRE22]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that this alternate implementation is provided under a different file named
    `current-weather.component.fake.spec`, part of the sub-folder `projects/ch4` on
    GitHub.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这个替代实现是在一个名为 `current-weather.component.fake.spec` 的不同文件中提供的，它是 GitHub 上
    `projects/ch4` 子文件夹的一部分。
- en: Remove `HttpClientTestingModule` from the imports, since it is no longer needed
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从导入中删除 `HttpClientTestingModule`，因为它不再需要
- en: 'As your services and components get more complicated, it''s easy to provide
    an incomplete or inadequate test double. You may see errors such as `NetworkError:
    Failed to execute ''send'' on ''XMLHttpRequest''`, `Can''t resolve all parameters`,
    or `[object ErrorEvent] thrown`. In case of the latter error, click on the **Debug**
    button in Karma to discover the view error details, which may look like **Timeout
    - Async callback was not invoked within timeout specified by jasmine**. Unit tests
    are designed to run in milliseconds, so it should be impossible to actually hit
    the default 5-second timeout. The issue is almost always with the test setup or
    configuration.'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '随着你的服务和组件变得越来越复杂，很容易提供一个不完整或不充分的测试替身。你可能会看到诸如 `NetworkError: Failed to execute
    ''send'' on ''XMLHttpRequest''`、`Can''t resolve all parameters` 或 `[object ErrorEvent]
    thrown` 这样的错误。在后者的情况下，点击 Karma 中的 **调试** 按钮以发现视图错误详情，这可能看起来像 **超时 - jasmine 指定的时间超出了异步回调**。单元测试设计为以毫秒为单位运行，所以实际上触碰到默认的
    5 秒超时是不可能的。问题几乎总是与测试设置或配置有关。'
- en: Verify that all tests are passing
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证所有测试是否通过
- en: With fakes, we were able to somewhat reduce test complexity and improve isolation.
    We can do much better with mocks, stubs, and spies.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用假对象，我们能够在一定程度上减少测试复杂性并提高隔离性。我们可以通过模拟、存根和间谍做得更好。
- en: Mocks, stubs, and spies
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟、存根和间谍
- en: A mock, stub, or spy does not contain any implementation whatsoever. Mocks are
    configured in the unit test file to respond to specific function calls with a
    set of responses that can be made to vary from test to test with ease.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟、存根或间谍不包含任何实现。模拟在单元测试文件中配置，以对特定的函数调用响应一系列响应，这些响应可以根据测试轻松地变化。
- en: Earlier in the *Declarations* section, we discussed the need to declare `CurrentWeatherComponent`
    in `app.component.spec.ts` to resolve the **not a known element** warning. If
    we declare the real `CurrentWeatherComponent`, then the `AppComponent` test configuration
    becomes overly complicated with a lot of configuration elements, because we must
    resolve the dependency tree for the child component, including `WeatherService`
    and `HttpClient`. In addition, creating a whole fake service just to provide fake
    weather data is overkill and is not a flexible solution. What if we wanted to
    test different service responses, given different inputs? We would have to start
    introducing logic into our fake service, and before you know it, you're dealing
    with two separate implementations of the `WeatherService`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *声明* 部分中较早的时候，我们讨论了在 `app.component.spec.ts` 中声明 `CurrentWeatherComponent`
    以解决**未知元素**警告的必要性。如果我们声明真实的 `CurrentWeatherComponent`，那么 `AppComponent` 的测试配置就会变得过于复杂，因为我们需要解决子组件的依赖关系树，包括
    `WeatherService` 和 `HttpClient`。此外，仅仅为了提供假天气数据就创建一个整个假服务是过度设计，并且不是一个灵活的解决方案。如果我们想根据不同的输入测试不同的服务响应怎么办？我们就必须开始在假服务中引入逻辑，然后不知不觉中，你就在处理
    `WeatherService` 的两个独立实现。
- en: An alternative to creating a fake would be to create an empty object that parades
    as the real thing but contains no implementation. These objects are called mocks.
    We will leverage two different techniques to create a mock component and a mock
    service below.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个假对象的替代方案是创建一个空对象，它冒充真实对象但没有任何实现。这些对象被称为模拟。我们将在下面利用两种不同的技术来创建模拟组件和模拟服务。
- en: Mock components
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟组件
- en: If we were to provide a `CurrentWeatherComponent` in `app.component.spec.ts`,
    we could resolve the **not a known element** warning and not have to worry about
    all the components and services that `CurrentWeatherComponent` depends on.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `app.component.spec.ts` 中提供一个 `CurrentWeatherComponent`，我们可以解决**未知元素**的警告，并且不需要担心
    `CurrentWeatherComponent` 所依赖的所有组件和服务。
- en: 'If you were to implement it by hand, a mock component would look like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你手动实现它，一个模拟组件看起来像这样：
- en: '[PRE23]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, this can get tedious really fast, which is why I published a unit
    test helper library called **angular-unit-test-helper** to make it easier to mock
    a component. With the library, you can just replace the component in the declaration
    with this function call:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这可能会很快变得繁琐，这就是为什么我发布了一个单元测试辅助库，名为 **angular-unit-test-helper**，以使模拟组件更容易。使用这个库，你只需用这个函数调用替换声明中的组件：
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s update `app.component.spec.ts` to use mocked components:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 `app.component.spec.ts` 以使用模拟组件：
- en: Execute `npm i -D angular-unit-test-helper`
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `npm i -D angular-unit-test-helper`
- en: 'Update `AppComponent` with the mocked components:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模拟组件更新 `AppComponent`：
- en: '[PRE25]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Remove the `providers` property altogether
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全删除 `providers` 属性
- en: Clean up unused imports
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理未使用的导入
- en: Observe that the unit test file remains lean and the warning is resolved. **angular-unit-test-helper**
    infers that `CurrentWeatherComponent` represents an HTML tag like `<app-current-weather>`
    and provides it in the window object of the browser. The `createComponentMock`
    function then properly decorates the empty class `CurrentWeatherComponent` by
    assigning the selector `'app-current-weather'` and an empty template. `TestBed`
    is then able to resolve `<app-current-weather>` as this mocked component. `createComponentMock`
    also allows you to provide a custom selector or a fake template that you can pass
    depending on your needs. This is a solution that scales, cutting imports by more
    than half and adhering to FIRST principles.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，单元测试文件保持简洁，警告已解决。**angular-unit-test-helper** 推断 `CurrentWeatherComponent`
    代表一个 HTML 标签，如 `<app-current-weather>`，并在浏览器的窗口对象中提供它。然后 `createComponentMock`
    函数通过分配选择器 `'app-current-weather'` 和一个空模板来正确装饰空的 `CurrentWeatherComponent` 类。然后
    `TestBed` 能够解析 `<app-current-weather>` 为这个模拟组件。`createComponentMock` 还允许你根据需要提供自定义选择器或假模板。这是一个可扩展的解决方案，减少了超过一半的导入，并遵循
    FIRST 原则。
- en: The concept of mocks extends to all kinds of objects we can define, including
    Angular services. By mocking a service, we don't have to worry about any dependencies
    that may be injected into that service.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟的概念扩展到我们可以定义的所有类型的对象，包括 Angular 服务。通过模拟服务，我们不必担心可能注入到该服务中的任何依赖项。
- en: Let's see how we can mock a service.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何模拟一个服务。
- en: Mock services
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟服务
- en: Let's write two new unit tests for `CurrentWeatherComponent` to demonstrate
    the value of mocking a service instead of implementing a fake for it. Mocks allow
    us to create an empty object and give us the option to supply only the functions
    that may be needed for a test. We can then stub out the return values of these
    functions per test or spy on them to see whether our code called them or not.
    Spying is especially useful if the function in question has no return value. We
    need to set up our spy in the arrange part of our spec.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 `CurrentWeatherComponent` 编写两个新的单元测试，以展示模拟服务而不是实现其假值的优点。模拟允许我们创建一个空对象，并给我们提供只提供可能需要的测试函数的选项。然后我们可以根据每个测试来模拟这些函数的返回值或监视它们以查看我们的代码是否调用了它们。监视特别有用，如果相关的函数没有返回值。我们需要在我们的规范安排部分设置我们的间谍。
- en: 'Let''s start by creating a spy `WeatherService`, using `jasmine.createSpyObj`,
    as shown:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个 `WeatherService` 间谍对象开始，使用 `jasmine.createSpyObj`，如下所示：
- en: '[PRE26]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Provide `weatherServiceSpy` as the value of `WeatherService` with `useValue`
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `useValue` 将 `weatherServiceSpy` 作为 `WeatherService` 的值。
- en: 'Finally, get the injected instance from `TestBed` and assign the value to `weatherServiceMock`,
    using the `injectSpy` method from angular-unit-test-helper as shown:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从 `TestBed` 获取注入的实例并将其分配给 `weatherServiceMock`，使用 `angular-unit-test-helper`
    中的 `injectSpy` 方法，如下所示：
- en: '[PRE27]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that `injectSpy` is a shorthand for `TestBed.inject(WeatherService)` as
    any.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`injectSpy` 是 `TestBed.inject(WeatherService)` 的简写，作为任何。
- en: 'In the preceding example, we have a mocked version of `WeatherService`, where
    declared that it has a function named `getCurrentWeather`. However, note that
    you''re now getting an error:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有一个模拟的 `WeatherService` 版本，其中声明它有一个名为 `getCurrentWeather` 的函数。然而，请注意，你现在得到了一个错误：
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is because `getCurrentWeather` is not returning an observable. Using `weatherServiceMock`,
    we can spy on whether `getCurrentWeather` is being called or not, but also stub
    out its return value depending on the test.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `getCurrentWeather` 不会返回一个可观察对象。使用 `weatherServiceMock`，我们可以监视 `getCurrentWeather`
    是否被调用，也可以根据测试来模拟其返回值。
- en: In order to manipulate the return value of `getCurrentWeather`, we need to update
    the **should create** test to reflect the arrange, act, and assert structure.
    To do this, we need to move `fixture.detectChanges()` from the second `beforeEach`,
    so we can control its execution order to be after the arrange part.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了操纵 `getCurrentWeather` 的返回值，我们需要更新 **should create** 测试以反映安排、执行和断言结构。为此，我们需要将
    `fixture.detectChanges()` 从第二个 `beforeEach` 中移除，这样我们就可以控制其执行顺序，使其在安排部分之后执行。
- en: '[PRE29]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the arrange part, we configure that `getCurrentWeather` should return an
    empty observable using the `RxJS\of` function. In the act part, we trigger TestBed's
    `detectChanges` function, which triggers lifecycle events like `ngOnInit`. Since
    the code we're testing is in `ngOnInit`, this is the right thing to execute. Finally,
    in the assert part, we confirm our assertion that the component was successfully
    created.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在安排部分，我们配置`getCurrentWeather`应使用`RxJS\of`函数返回一个空的Observable。在行为部分，我们触发TestBed的`detectChanges`函数，这会触发生命周期事件，如`ngOnInit`。由于我们正在测试的代码位于`ngOnInit`中，这是正确执行的操作。最后，在断言部分，我们确认组件已成功创建。
- en: 'In this next test, we can verify that the `getCurrentWeather` function is being
    called exactly once:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的测试中，我们可以验证`getCurrentWeather`函数确实被调用了一次：
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And finally, we can test out the fact that the values that are being returned
    are correctly assigned in the component class, but also that they are correctly
    rendered on the template:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以测试返回的值是否正确分配在组件类中，并且也正确渲染在模板上：
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding example, you can see that we're providing a `fakeWeather` object,
    where the city name is Bethesda. We are then able to assert that the current property
    has the correct `city`, and also that the `<div>` element with `class=mat-title`
    contains the text Bethesda.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，您可以看到我们提供了一个名为`fakeWeather`的模拟对象，其中城市名称为Bethesda。然后我们能够断言当前属性具有正确的`city`，并且具有`class=mat-title`的`<div>`元素包含文本Bethesda。
- en: 'You should now have seven passing tests:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该有七个通过测试：
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using mocks, stubs, and spies, we can rapidly test permutations of what outside
    dependencies can and cannot return and we are able to verify our assertions on
    the code that resides in the component or service class by observing the DOM.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用模拟（mocks）、存根（stubs）和间谍（spies），我们可以快速测试外部依赖项可以返回和不能返回的多种可能性，并且我们可以通过观察DOM来验证组件或服务类中驻留的代码的断言。
- en: To learn more about mocks, stubbing, and spies, refer to [https://jasmine.github.io](https://jasmine.github.io).
    Also, I've found Jasmine 2 Spy Cheat Sheet by Dave Ceddia, located at [https://daveceddia.com/jasmine-2-spy-cheat-sheet](https://daveceddia.com/jasmine-2-spy-cheat-sheet),
    to be a useful resource.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于模拟、存根和间谍的信息，请参阅[https://jasmine.github.io](https://jasmine.github.io)。此外，我发现Dave
    Ceddia的Jasmine 2 Spy Cheat Sheet非常有用，位于[https://daveceddia.com/jasmine-2-spy-cheat-sheet](https://daveceddia.com/jasmine-2-spy-cheat-sheet)。
- en: 'In general, your unit tests should be asserting one or two things at most.
    To achieve adequate unit test coverage, you should focus on testing the correctness
    of functions that contain business logic: usually wherever you see an `if` or
    `switch` statement.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您的单元测试应该最多断言一两个事情。为了达到足够的单元测试覆盖率，您应该专注于测试包含业务逻辑的函数的正确性：通常在您看到`if`或`switch`语句的地方。
- en: To write unit-testable code, be sure to adhere to the Single Responsibility
    and Open/Closed principles of the SOLID principles.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写可单元测试的代码，请确保遵循SOLID原则中的单一责任原则和开放/封闭原则。
- en: Check out the **ng-tester** library that my colleague Brendan Sawyer created
    at [https://www.npmjs.com/package/ng-tester](https://www.npmjs.com/package/ng-tester).
    It creates opinionated spec files for your Angular components that leverage **angular-unit-test-helper**
    to assist with mocking. In addition, the library demonstrates how to mock dependencies
    and create tests without using `TestBed`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我的同事Brendan Sawyer创建的**ng-tester**库，位于[https://www.npmjs.com/package/ng-tester](https://www.npmjs.com/package/ng-tester)。它为您的Angular组件创建具有**angular-unit-test-helper**的规范文件，以帮助进行模拟。此外，该库展示了如何模拟依赖项并在不使用`TestBed`的情况下创建测试。
- en: You may install the library `npm install -D ng-tester` and create a unit test
    with the command `npx ng generate ng-tester:unit`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过命令`npm install -D ng-tester`安装库，并使用命令`npx ng generate ng-tester:unit`创建单元测试。
- en: In addition to unit tests, the Angular CLI also generates and configures e2e
    tests for your application. Next, let's learn about e2e tests.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 除了单元测试之外，Angular CLI还会为您的应用程序生成和配置端到端测试。接下来，让我们了解端到端测试。
- en: Angular e2e tests
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular端到端测试
- en: While unit tests focus on isolating the CUT, e2e tests are about integration
    testing. The Angular CLI leverages Protractor along with WebDriver so that you
    can write **Automated Acceptance Tests** (**AAT**) from the perspective of a user
    interacting with your application in a browser. As a rule of thumb, you should
    always write an order of magnitude more unit tests than AATs, because your app
    changes frequently, and as a result, AATs are vastly more fragile and expensive
    to maintain compared to unit tests.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单元测试侧重于隔离 CUT，但 e2e 测试是关于集成测试。Angular CLI 利用 Protractor 和 WebDriver，以便您可以从用户与浏览器中交互的角度编写
    **自动化验收测试（AAT**）。作为一个经验法则，您应该始终编写比 AATs 多一个数量级的单元测试，因为您的应用程序经常变化，因此与单元测试相比，AATs
    的脆弱性和维护成本要高得多。
- en: If the term web driver sounds familiar, it's because it is an evolution of the
    canonical Selenium WebDriver. On March 30th, 2017, WebDriver was proposed as an
    official web standard at the W3C. You read more about it at [https://www.w3.org/TR/webdriver](https://www.w3.org/TR/webdriver).
    If you're familiar with Selenium, you should feel right at home, since a lot of
    the patterns and practices are nearly identical.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果“web driver”这个词听起来很熟悉，那是因为它是经典 Selenium WebDriver 的一种演变。在 2017 年 3 月 30 日，WebDriver
    被提议作为 W3C 的官方网络标准。您可以在 [https://www.w3.org/TR/webdriver](https://www.w3.org/TR/webdriver)
    上了解更多信息。如果您熟悉 Selenium，您应该会感到很自在，因为许多模式和做法几乎相同。
- en: 'The CLI provides e2e tests for the initial `AppComponent` and depending on
    the complexity and the feature set of your application. It''s up to you to follow
    the provided pattern to organize your tests better. There are two files generated
    per component under the e2e folder:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 为初始的 `AppComponent` 提供端到端测试，具体取决于您应用程序的复杂性和功能集。您需要遵循提供的模式来更好地组织您的测试。在 e2e
    文件夹下，每个组件都会生成两个文件：
- en: '[PRE33]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`app.e2e-spec.ts` is written in Jasmine and implements acceptance tests. The
    spec is dependent upon the page object (`po`) file, which is defined beside the
    `spec` file:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.e2e-spec.ts` 使用 Jasmine 编写并实现了验收测试。规范依赖于页面对象（`po`）文件，该文件定义在 `spec` 文件旁边：'
- en: '[PRE34]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Consider the following diagram, which represents the e2e test architecture
    visually:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图表，它以视觉方式表示 e2e 测试架构：
- en: '![](img/B14094_04_04.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_04_04.png)'
- en: 'Figure 4.4: The Architecture of e2e Tests'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：e2e 测试的架构
- en: The goal of the **'should display welcome message'** test is to verify that
    `app.component.html` displays the correct text. The page object file, `app.po.ts`,
    encapsulates web driver implementation to retrieve the message with the `getTitleText`
    function. Finally, the test is written as a Jasmine test in the `app.e2e-spec.ts`
    file. AATs are the most fragile kind of tests. Having a page object layer between
    the HTML and the spec files results in easy-to-maintain, human-readable tests.
    By separating concerns at this level, you keep the fragility of AATs to one location.
    By leveraging class inheritance, you can build a robust collection of page objects
    that can be easier to maintain over time.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**''should display welcome message''** 测试的目标是验证 `app.component.html` 是否显示了正确的文本。页面对象文件
    `app.po.ts` 封装了 WebDriver 实现，使用 `getTitleText` 函数检索消息。最后，测试在 `app.e2e-spec.ts`
    文件中以 Jasmine 测试的形式编写。AATs 是最脆弱的测试类型。在 HTML 和规范文件之间有一个页面对象层，这使得测试易于维护且易于阅读。通过在这一级别分离关注点，您可以将
    AATs 的脆弱性限制在一个位置。通过利用类继承，您可以构建一个健壮的页面对象集合，随着时间的推移更容易维护。'
- en: e2e test execution
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: e2e 测试执行
- en: 'You can execute e2e tests with the following command in the terminal; ensure
    that the `npm test` process is not running:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令在终端中执行 e2e 测试；确保 `npm test` 进程没有运行：
- en: '[PRE35]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that the test execution is different as compared to unit tests. While you
    can configure a watcher to continually execute unit tests with Karma, due to the
    user-driven and stateful nature of e2e tests, it is not a good practice to attempt
    a similar configuration with e2e tests. Running the tests once and stopping the
    test harness ensures a clean state with every run.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，测试执行与单元测试不同。虽然您可以使用 Karma 配置监视器来持续执行单元测试，但由于 e2e 测试的用户驱动和有状态性质，尝试对 e2e 测试进行类似的配置并不是一个好的做法。运行一次测试并停止测试工具确保每次运行都有一个干净的状态。
- en: The e2e page object and spec
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: e2e 页面对象和规范
- en: 'After executing the e2e tests, you should see an error message similar to the
    one here:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 e2e 测试后，您应该看到类似于以下错误消息：
- en: '[PRE36]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The test is failing because we significantly altered the structure of the HTML
    in `app.component.html` and the `getTitleText` method in our page object is no
    longer correct.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 测试失败是因为我们在 `app.component.html` 中的 HTML 结构以及页面对象的 `getTitleText` 方法中进行了重大修改，导致该方法不再正确。
- en: 'Begin by correcting `getTitleText` so it retrieves the correct text:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过纠正 `getTitleText` 以获取正确的文本：
- en: '[PRE37]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Note that the error message now says:'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，错误信息现在说：
- en: '[PRE38]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Update the `spec` to expect the correct header as follows:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `spec` 以期望正确的标题如下：
- en: '[PRE39]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Re-run the tests; they should be passing now:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行测试；现在它们应该通过了：
- en: '[PRE40]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Commit your code changes.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交您的代码更改。
- en: Our unit tests and e2e tests are now working.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单元测试和端到端测试现在正在工作。
- en: There are more robust tools for automated acceptance testing, such as [https://cypress.io](https://cypress.io)
    and [https://github.com/bigtestjs](https://github.com/bigtestjs). Consider using
    these tools instead of Angular's e2e tests.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自动化验收测试，还有更强大的工具，如 [https://cypress.io](https://cypress.io) 和 [https://github.com/bigtestjs](https://github.com/bigtestjs)。考虑使用这些工具而不是
    Angular 的 e2e 测试。
- en: You may find a sample implementation of Cypress, integrated with CircleCI, for
    the LemonMart project, covered in *Chapter 7*, *Creating a Router-First Line-of-Business
    App*, at [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 *第 7 章*，*创建以路由为第一线的业务应用* 中找到 LemonMart 项目的 Cypress 示例实现，该章节位于 [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)。
- en: Execute `npm run cypress:run` to see Cypress in action. Cypress can record and
    replay test runs for easy debugging; it is a robust tool for your next enterprise
    project.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `npm run cypress:run` 以查看 Cypress 的实际效果。Cypress 可以记录和重放测试运行，以便轻松调试；它是您下一个企业项目的强大工具。
- en: Going forward, make sure that your tests remain in working condition.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，确保您的测试保持正常工作状态。
- en: Next, we need to ready our app for production deployments, which means building
    the app in prod mode and setting the appropriate environment variables.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为生产部署准备我们的应用程序，这意味着以生产模式构建应用程序并设置适当的环境变量。
- en: Production readiness
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产准备就绪
- en: When you run `npm start`, Angular builds in debug mode, which enables faster
    build times, breakpoint debugging, and live reloading. This also means that the
    bundle size of a small app balloons to over 7 MB. A 7 MB bundle size results in
    over two minutes of loading time on a slow 3G connection when we expect our app
    to load in mere seconds. Additionally, in debug mode, we use environment variables
    meant for local development. However, in production, we need to use different
    settings so our application can run in a hosted environment correctly.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行 `npm start` 时，Angular 以调试模式构建，这可以加快构建时间，启用断点调试和实时重新加载。这也意味着一个小型应用捆绑包的大小会膨胀到超过
    7 MB。在慢速 3G 连接上，7 MB 的捆绑包大小会导致超过两分钟的加载时间，而我们的应用只需几秒钟即可加载。此外，在调试模式下，我们使用的是为本地开发而设计的环境变量。然而，在生产环境中，我们需要使用不同的设置，以便我们的应用程序可以在托管环境中正确运行。
- en: Let's start by implementing an `npm` script to help us build in prod mode.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先实现一个 `npm` 脚本来帮助我们以生产模式构建。
- en: Building for production
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建生产版本
- en: Angular ships with a robust build tool that can optimize the size of your bundle
    by removing redundant, unused, and inefficient code from the debug build and pre-compiling
    sections of code so browsers can interpret it faster. So, a 7 MB bundle can become
    700 KB and load in under 7 seconds even on a slow 3G connection.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 随带一个强大的构建工具，可以通过从调试构建中删除冗余、未使用和不高效代码以及预编译代码部分来优化捆绑包的大小，以便浏览器可以更快地解释它。因此，7
    MB 的捆绑包可以缩小到 700 KB，即使在慢速 3G 连接上也能在 7 秒内加载完成。
- en: By default, the `ng build` command builds your code in debug mode. By adding
    the `--prod` option to it, we can enable `prod` mode.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`ng build` 命令以调试模式构建您的代码。通过向其中添加 `--prod` 选项，我们可以启用 `prod` 模式。
- en: 'Add a new script called `build:prod` to `package.json`, as shown:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `package.json` 中添加一个名为 `build:prod` 的新脚本，如下所示：
- en: '[PRE41]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Test the script by executing:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令测试脚本：
- en: '[PRE42]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is a critical configuration for the efficient delivery of Angular apps.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这是高效交付 Angular 应用的关键配置。
- en: Do not ship an Angular app without first enabling prod mode.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用生产模式之前，不要发布 Angular 应用程序。
- en: Next, let's set the environment variables for prod.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们设置生产环境的环境变量。
- en: Setting environment variables
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置环境变量
- en: In *Chapter 3*, *Creating a Basic Angular App*, we configured the URL for the
    OpenWeatherMap APIs using environment variables stored in the `src/environment/environment.ts`
    file. We need to update our variables for production use because the environment
    that our Angular app lives in is changing. The settings that work in a local or
    test environment are not necessarily going to work in the hosting environment.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 3 章*，*创建基本的 Angular 应用* 中，我们使用存储在 `src/environment/environment.ts` 文件中的环境变量配置了
    OpenWeatherMap API 的 URL。我们需要更新我们的变量以用于生产，因为我们的 Angular 应用程序所在的环境正在发生变化。在本地或测试环境中工作的设置不一定适用于托管环境。
- en: 'Apply the following changes to `environment.prod.ts`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下更改应用到 `environment.prod.ts` 文件中：
- en: Set `production` to `true`
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `production` 设置为 `true`
- en: If necessary, provide a production `appId` variable
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如有必要，提供生产 `appId` 变量
- en: 'Update `baseUrl` to `https`:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将 `baseUrl` 更新为 `https`:'
- en: '[PRE43]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Setting `production` to `true` allows the application code to check the mode
    of the application to adjust its behavior. Also, we changed the `baseUrl` from
    HTTP to HTTPS, because our app is hosted over HTTPS. Browsers don't allow the
    serving of mixed content, which weakens the overall security benefits that HTTPS
    delivers. If we don't switch over to HTTPS, then our calls to the OpenWeatherMap
    APIs fail.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `production` 设置为 `true` 允许应用程序代码检查应用程序的模式以调整其行为。此外，我们将 `baseUrl` 从 HTTP 更改为
    HTTPS，因为我们的应用程序是通过 HTTPS 托管的。浏览器不允许提供混合内容，这会削弱 HTTPS 提供的整体安全优势。如果我们不切换到 HTTPS，那么我们对
    OpenWeatherMap API 的调用将失败。
- en: You can read more about mixed content at [https://developers.google.com/web/fundamentals/security/prevent-mixed-content/what-is-mixed-content](https://developers.google.com/web/fundamentals/security/prevent-mixed-content/what-is-mixed-content).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://developers.google.com/web/fundamentals/security/prevent-mixed-content/what-is-mixed-content](https://developers.google.com/web/fundamentals/security/prevent-mixed-content/what-is-mixed-content)
    上了解更多关于混合内容的信息。
- en: Next, let's set up CI to ensure that our tests are always passing before we
    deploy the app to production.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们设置 CI 以确保在将应用程序部署到生产之前，我们的测试总是通过。
- en: Continuous Integration
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: Before pushing your code to production, you should enable CI. This basic setup
    helps ensure our application code keeps working even when we make changes to our
    code, by automating the execution of our unit tests.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在将代码推送到生产之前，你应该启用 CI。这个基本设置有助于确保即使我们更改代码，我们的应用程序代码也能继续工作，因为它通过自动化执行我们的单元测试来实现。
- en: CircleCI
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CircleCI
- en: CircleCI makes it easy to get started, with a free tier and excellent documentation
    for beginners and pros alike. If you have unique enterprise needs, CircleCI can
    be brought on-premises, behind corporate firewalls, or as a private deployment
    in the cloud.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: CircleCI 为初学者和专业人士 alike 提供了免费层和优秀的文档，使其易于上手。如果你有独特的企业需求，CircleCI 可以在企业内部署，位于企业防火墙之后，或作为云中的私有部署。
- en: 'CircleCI has pre-baked build environments for the virtual configuration of
    free setups, but it can also run builds using Docker containers, making it a solution
    that scales to the user''s skills and needs, as covered in *Chapter 9*, *DevOps
    Using Docker*:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: CircleCI 为免费设置的虚拟配置预置了构建环境，但它也可以使用 Docker 容器运行构建，使其成为一个可以扩展到用户技能和需求解决方案，如在第
    9 章 *使用 Docker 的 DevOps* 中所述：
- en: Create a CircleCI account at [https://circleci.com/](https://circleci.com/).
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 [https://circleci.com/](https://circleci.com/) 创建 CircleCI 账户。
- en: Sign up with GitHub:![](img/B14094_04_05.png)
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 GitHub 注册:![](img/B14094_04_05.png)
- en: 'Figure 4.5: CircleCI Sign up page'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.5：CircleCI 注册页面
- en: Add a new project:![](img/B14094_04_06.png)
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新项目:![](img/B14094_04_06.png)
- en: 'Figure 4.6: CircleCI Projects page'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.6：CircleCI 项目页面
- en: On the next screen, you have an option to select **Linux** or **macOS** build
    environments. The macOS build environments are good for building iOS or macOS
    apps. However, there is no free tier for those environments; only Linux instances
    with 1x parallelism are free.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一屏，你可以选择 **Linux** 或 **macOS** 构建环境。macOS 构建环境适合构建 iOS 或 macOS 应用。然而，这些环境没有免费层；只有具有
    1x 并行性的 Linux 实例是免费的。
- en: Search for `local-weather-app` and click on **Set Up Project**.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索 `local-weather-app` 并点击 **Set Up Project**。
- en: Select **Linux**.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Linux**。
- en: Select **Language** as **Node**, which provides a sample `.yml` file.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Language** 设置为 **Node**，它提供了一个样本 `.yml` 文件。
- en: 'This section uses the **local-weather-app** repo. The `config.yml` file for
    this section is named `.circleci/config.ch4.yml`. You can also find a pull request
    that executes the yml file from this chapter on CircleCI: [https://github.com/duluca/local-weatherapp/pull/52](https://github.com/duluca/local-weatherapp/pull/52)
    using the `branch build_ch4`. Note that this branch has a modified configuration
    in `config.yml` and `Dockerfile` to use `projects/ch4` code from **local-weather-app**.'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本节使用 **local-weather-app** 仓库。本节的 `config.yml` 文件命名为 `.circleci/config.ch4.yml`。您还可以在
    CircleCI 上找到本章中执行 yml 文件的拉取请求：[https://github.com/duluca/local-weatherapp/pull/52](https://github.com/duluca/local-weatherapp/pull/52)
    使用 `branch build_ch4`。请注意，此分支在 `config.yml` 和 `Dockerfile` 中进行了修改配置，以使用 **local-weather-app**
    中的 `projects/ch4` 代码。
- en: 'In your source code, create a folder named `.circleci` and add a file named
    `config.yml`:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的源代码中，创建一个名为 `.circleci` 的文件夹，并添加一个名为 `config.yml` 的文件：
- en: '[PRE44]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Sync your changes to Github.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的更改同步到 Github。
- en: On CircleCI, click **Start building** to register your project.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 CircleCI 上，点击 **开始构建** 以注册您的项目。
- en: 'If everything goes well, you should have a passing, *green*, build. If not,
    you see a failed, *red*, build. The following screenshot shows a failed build,
    **#97**, and a subsequent build, **#98**, which was successful:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该有一个通过，*绿色* 的构建。如果不顺利，您会看到一个失败的，*红色* 的构建。以下截图显示了一个失败的构建，**#97**，以及随后的成功构建，**#98**：
- en: '![](img/B14094_04_07.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_04_07.png)'
- en: 'Figure 4.7: Green Build on CircleCI'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7：CircleCI 上的绿色构建
- en: Now that you have a green build, you can leverage CircleCI to enforce the execution
    of your automated pipeline with every code push. GitHub flow allows us to control
    how code flows into our repositories.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有了绿色构建，可以利用 CircleCI 在每次代码推送时强制执行您的自动化管道的执行。GitHub 流允许我们控制代码如何流入我们的仓库。
- en: GitHub flow
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub 流
- en: The main reason we're developing software is to deliver value. In automating
    the way we deliver software, we are creating a value delivery stream. It is easy
    to deliver broken software; however, to reliably deliver value, each change to
    the codebase should flow through a stream of checks and balances.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发软件的主要原因是为了提供价值。在自动化软件交付方式的过程中，我们正在创建一个价值交付流。交付有缺陷的软件很容易；然而，为了可靠地提供价值，每次对代码库的更改都应该通过一系列的检查和平衡流程。
- en: With control gates, we can enforce standards, make our quality control process
    repeatable for every team member, and have the ability to isolate changes. If
    something goes wrong or the work doesn't live up to your standards, you can easily discard
    the proposed changes and restart.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 通过控制门，我们可以强制执行标准，使我们的质量控制流程对每个团队成员都是可重复的，并且能够隔离更改。如果出现问题或工作不符合您的标准，您可以轻松地丢弃提议的更改并重新开始。
- en: GitHub flow is an essential part of defining a value delivery stream and implement
    control gates. As GitHub puts it, *"GitHub flow is a lightweight, branch-based
    workflow that supports teams and projects where deployments are made regularly."*
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 'GitHub 流程是定义价值交付流和实施控制门的关键部分。正如 GitHub 所说，*"GitHub 流是一个轻量级的基于分支的工作流程，支持定期部署的团队和项目。"* '
- en: 'GitHub flow consists of 6 steps, as shown in the following graphic from GitHub:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 流程包括 6 个步骤，如下所示，来自 GitHub 的以下图形：
- en: '![](img/B14094_04_08.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_04_08.png)'
- en: 'Figure 4.8: GitHub flow diagram'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8：GitHub 流图
- en: '**Branch** – always add new code for a bug or a feature in a new branch'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分支** – 总是在新分支中添加用于修复错误或新功能的代码'
- en: '**Commit** – make multiple commits to your branch'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**提交** – 对您的分支进行多次提交'
- en: '**Create a pull request** – signal the readiness of your work to your team
    members and view CI results in a pull request'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建拉取请求** – 向团队成员发出您的工作准备就绪的信号，并在拉取请求中查看 CI 结果'
- en: '**Discuss and review** – request a review of your code changes, address general or
    line-level comments, and make necessary modifications'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**讨论和审查** – 请求对您的代码更改进行审查，处理一般性或行级评论，并进行必要的修改'
- en: '**Deploy** – optionally test your code on a test server or in production with
    the ability to roll back to the master'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**部署** – 可选地在测试服务器或生产环境中测试您的代码，并具有回滚到主分支的能力'
- en: '**Merge** – apply your changes to the master branch'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**合并** – 将您的更改应用到主分支'
- en: Using GitHub flow, you can ensure that only high-quality code ends up in the
    master branch. A solid foundation sets other team members up for success when
    they start making their changes. In order to enforce GitHub flow, you need to
    restrict push access to the master branch.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GitHub 流，您可以确保只有高质量的代码最终进入主分支。坚实的基础为其他团队成员在开始他们的更改时设定了成功的基础。为了强制执行 GitHub
    流，您需要限制对主分支的推送访问。
- en: 'Let''s enable branch protection for the master branch:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 master 分支启用分支保护：
- en: Navigate to the GitHub settings tab for your project
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到您项目的 GitHub 设置标签页
- en: Select **Branches** from the left navigation pane
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧导航面板中选择**分支**
- en: Click the **Add rule** button
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加规则**按钮
- en: Configure your rule as shown in the following image:![](img/B14094_04_09.png)
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下图像配置您的规则！![图片](img/B14094_04_09.png)
- en: 'Figure 4.9: GitHub Branch protection rule'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.9：GitHub 分支保护规则
- en: 'After you''ve saved your changes, you should see your new rule on the **Branches**
    page as shown:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的更改后，您应该在 **分支** 页面上看到您的新规则，如下所示：
- en: '![](img/B14094_04_10.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_04_10.png)'
- en: 'Figure 4.10: GitHub Branches'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：GitHub 分支
- en: 'You are no longer able to commit code to your master branch directly. To commit
    code, you first need to create a branch from the master, commit your changes to
    the new branch, and when you''re ready, create a pull request using the new branch.
    If you''re not familiar with `git` commands, you can use GitHub Desktop to assist
    you with these operations. See the handy **Branch** menu in GitHub Desktop here:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您不再能够直接向 master 分支提交代码。要提交代码，您首先需要从 master 创建一个分支，将更改提交到新分支，然后准备好后，使用新分支创建拉取请求。如果您不熟悉
    `git` 命令，可以使用 GitHub Desktop 来协助您进行这些操作。请参阅 GitHub Desktop 中的实用 **分支** 菜单：
- en: '![](img/B14094_04_11.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_04_11.png)'
- en: 'Figure 4.11: GitHub Desktop Branch menu'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11：GitHub Desktop 分支菜单
- en: 'After creating a pull request, you can now observe checks running against your
    branch. Now that we have CircleCI configured, if everything went well, you should
    be able to merge a pull request, as shown:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 创建拉取请求后，您现在可以观察对您的分支运行的检查。现在我们已经配置了 CircleCI，如果一切顺利，您应该能够合并拉取请求，如下所示：
- en: '![](img/B14094_04_12.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_04_12.png)'
- en: 'Figure 4.12: GitHub.com Status Checks Passing'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12：GitHub.com 状态检查通过
- en: When the checks fail, you are forced to fix any issues before you can merge
    the new code. Also, you may run into merge conflicts if a team member merged to
    the master while you were working on your branch. In this case, you may use GitHub
    Desktop's **Update from master** feature to catch up your branch with the latest
    branch from the master.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当检查失败时，您必须修复任何问题后才能合并新代码。此外，如果团队成员在您正在工作分支的同时合并到 master，您可能会遇到合并冲突。在这种情况下，您可以使用
    GitHub Desktop 的 **从 master 更新** 功能来使您的分支与最新的 master 分支保持同步。
- en: 'Observe the state of a failing pull request in the following image:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 观察以下图像中失败的拉取请求的状态：
- en: '![](img/B14094_04_13.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_04_13.png)'
- en: 'Figure 4.13: GitHub.com status checks failing'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13：GitHub.com 状态检查失败
- en: Note that I have an additional check, DeepScan, which runs additional tests
    against my codebase. You can register your repo with DeepScan at [https://deepscan.io](https://deepscan.io).
    In *Chapter 9*, *DevOps Using Docker*, I demonstrate how you can enforce unit
    test code coverage using Coveralls.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我还有一个额外的检查，DeepScan，它会对我的代码库运行额外的测试。您可以在 [https://deepscan.io](https://deepscan.io)
    上注册您的仓库。在 *第 9 章*，*使用 Docker 的 DevOps* 中，我演示了如何使用 Coveralls 强制执行单元测试代码覆盖率。
- en: For more information, refer to [https://guides.github.com/introduction/flow](https://guides.github.com/introduction/flow).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅 [https://guides.github.com/introduction/flow](https://guides.github.com/introduction/flow)。
- en: Now that we have ensured that our automated checks are being enforced, we can
    be reasonably sure that we won't push a broken app to production. Next, let's
    learn how we can deploy our app to the cloud.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确保了我们的自动化检查正在执行，我们可以合理地确信我们不会将损坏的应用程序推送到生产环境。接下来，让我们学习如何将我们的应用程序部署到云端。
- en: Deploying to the Cloud
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到云端
- en: If delivering something to production is difficult from a coding perspective,
    it is very complicated to do it right from an infrastructure perspective. In *Chapter
    13*, *Highly Available Cloud Infrastructure on AWS*, I cover how to provision
    a world-class AWS **Elastic Container Service** (**ECS**) infrastructure for your
    applications, but that won't help if you need to demonstrate an idea quickly or
    don't need a highly configurable solution. Enter Vercel Now.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从编码的角度来看，将东西部署到生产环境很困难，那么从基础设施的角度来看，正确地做到这一点则非常复杂。在 *第 13 章*，*AWS 上的高可用云基础设施*
    中，我介绍了如何为您的应用程序配置世界级的 AWS **弹性容器服务**（**ECS**）基础设施，但这在您需要快速展示一个想法或不需要高度可配置的解决方案时不会有所帮助。这时就出现了
    Vercel Now。
- en: Vercel Now
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vercel Now
- en: Vercel Now, [https://vercel.com](https://vercel.com), is a multi-cloud service
    that enables real-time global deployments of applications directly from the CLI.
    Vercel Now works with static files, Node.js, PHP, Go applications, and any custom
    stack of software you're willing to write a custom builder for, which makes it
    quite straightforward to work with. Vercel Now, which is currently on version
    2, has a free tier that you can use to deploy the `dist` folder of your Angular
    applications very quickly. In *Chapter 9*, *DevOps Using Docker*, I demonstrate
    how you can also deploy a containerized version of your Angular app.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Vercel Now，[https://vercel.com](https://vercel.com)，是一个多云服务，它允许您直接从命令行实时全球部署应用程序。Vercel
    Now支持静态文件、Node.js、PHP、Go应用程序，以及您愿意为其编写自定义构建器的任何自定义软件堆栈，这使得与它一起工作变得相当简单。目前处于版本2的Vercel
    Now提供了一个免费层，您可以使用它来非常快速地部署Angular应用程序的`dist`文件夹。在*第9章*，*使用Docker的DevOps*中，我展示了您如何部署Angular应用程序的容器化版本。
- en: Refer to *Chapter 2*, *Setting Up Your Development Environment*, for instructions
    on installing Vercel Now.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考*第2章*，*设置您的开发环境*，以获取安装Vercel Now的说明。
- en: With the `now` tool, we're ready to deploy our app to the web.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`now`工具，我们已准备好将我们的应用程序部署到网络上。
- en: Deploying static files
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布静态文件
- en: After you build an Angular project, the build output resides in the `dist` folder.
    The files in this folder are considered static files; all a web server needs to
    do is deliver these files to a client browser, unmodified, and then the browser
    executes your code dynamically.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Angular项目后，构建输出位于`dist`文件夹中。这个文件夹中的文件被认为是静态文件；所有网络服务器需要做的就是将这些文件未修改地发送到客户端浏览器，然后浏览器动态执行您的代码。
- en: This means that any web server is able to serve up your Angular project. However,
    `now` makes it exceedingly easy, and free, to pull off.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着任何网络服务器都能够提供您的Angular项目。然而，`now`使这一过程变得极其简单且免费。
- en: Let's get started with deploying your Angular app using `now`'s static file
    hosting capabilities.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用`now`的静态文件托管功能部署您的Angular应用程序。
- en: 'Add two new scripts to `package.json`, as shown:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`package.json`中添加两个新的脚本，如下所示：
- en: '[PRE45]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: To deploy Chapter 4-specific code from [https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app),
    you need to execute `now --platform-version 2 dist/ch4`. Accept the default options
    for the CLI prompts. In my case, the app deployed to [https://ch4-dun.now.sh/](https://ch4-dun.now.sh/).
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要从[https://github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)部署第4章特定的代码，您需要执行`now
    --platform-version 2 dist/ch4`。接受CLI提示的默认选项。在我的情况下，应用程序部署到了[https://ch4-dun.now.sh/](https://ch4-dun.now.sh/)。
- en: Execute `npm run now:publish`.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`npm run now:publish`。
- en: Accept the default options for the CLI prompts.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受CLI提示的默认选项。
- en: 'In the terminal window, observe that the Angular project is built first and
    then uploaded to `now`:'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在终端窗口中，注意Angular项目首先构建然后上传到`now`：
- en: '[PRE46]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Follow the URL displayed on the screen to see that your app has been successfully
    deployed, in my case, [https://local-weather-app.duluca.now.sh](https://local-weather-app.duluca.now.sh).
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按屏幕上显示的URL查看，您的应用程序已成功部署，在我的情况下，[https://local-weather-app.duluca.now.sh](https://local-weather-app.duluca.now.sh)。
- en: Note the warning about a missing `now.json` file. When we run the command, we
    specify our platform version as version 2 with the option `--platform-version
    2`, so a configuration file is not strictly necessary. However, if you wish to
    customize any aspect of your deployment, perhaps by using a custom domain, selecting
    a geographical region, or using scaling options, you should configure this file.
    For further information on how to make the best of `now`, please refer to [https://vercel.com/docs](https://vercel.com/docs).
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意关于缺少`now.json`文件的警告。当我们运行命令时，我们使用选项`--platform-version 2`指定我们的平台版本为2，因此配置文件不是必需的。然而，如果您希望自定义部署的任何方面，例如使用自定义域名、选择地理位置或使用扩展选项，您应该配置此文件。有关如何充分利用`now`的更多信息，请参阅[https://vercel.com/docs](https://vercel.com/docs)。
- en: 'If your deployment went successfully you should see your app display the current
    weather from Bethesda, US:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的部署成功，您应该看到您的应用程序显示了美国贝塞斯达的当前天气：
- en: '![](img/B14094_04_14.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_04_14.png)'
- en: 'Figure 4.14: Successful deployment'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14：成功部署
- en: And you're done! Congratulations, your Angular app is live on the internet!
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！恭喜，您的Angular应用程序已上线！
- en: Summary
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the importance of unit testing and mastered
    Angular unit and e2e test configuration and setup. You learned how to configure
    Angular's TestBed and how to write unit tests using test doubles. You configured
    your Angular app for a production deployment. You ensured the quality of your
    application by creating a value delivery stream using a CI pipeline and GitHub
    flow. Finally, you successfully deployed a web application to the cloud.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了单元测试的重要性，并掌握了 Angular 单元和端到端测试的配置和设置。你学习了如何配置 Angular 的 TestBed 以及如何使用测试替身编写单元测试。你为生产部署配置了你的
    Angular 应用。通过使用 CI 管道和 GitHub 流创建价值交付流，你确保了应用程序的质量。最后，你成功地将一个网络应用程序部署到云端。
- en: Now you know what it takes to build a production-ready Angular application that
    is reliable, resilient, and containerized to allow for a flexible deployment strategy.
    In the next chapter, we go over how you can add Angular Material to your project
    and make your Local Weather App look great. In the process, you will learn about
    the negative performance impact that user control or UI component libraries can
    have on your application, including essential Material components; Angular Flex
    Layout; accessibility; typography; theming; and how to update Angular Material.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你知道了构建一个可靠、有弹性且容器化的生产就绪 Angular 应用程序需要哪些条件，它允许灵活的部署策略。在下一章中，我们将介绍如何将 Angular
    Material 添加到你的项目中，让你的本地天气预报应用看起来很棒。在这个过程中，你将了解用户控件或 UI 组件库可能对你的应用程序产生的负面影响，包括基本
    Material 组件；Angular Flex Layout；无障碍性；排版；主题；以及如何更新 Angular Material。
- en: Further reading
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Succeeding with Agile: Software Development Using Scrum*, Mike Cohn, 2009.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过敏捷成功：使用 Scrum 的软件开发*，迈克·科恩，2009年。'
- en: '*TestPyramid*, Martin Fowler, 2012, [https://martinfowler.com/bliki/TestPyramid.html](https://martinfowler.com/bliki/TestPyramid.html).'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试金字塔*，马丁·福勒，2012年，[https://martinfowler.com/bliki/TestPyramid.html](https://martinfowler.com/bliki/TestPyramid.html).'
- en: '*Jasmine 2 Spy Cheat Sheet*, Dave Ceddia, 2015, [https://daveceddia.com/jasmine-2-spy-cheat-sheet](https://daveceddia.com/jasmine-2-spy-cheat-sheet).'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Jasmine 2 间谍备忘单*，戴夫·塞迪亚，2015年，[https://daveceddia.com/jasmine-2-spy-cheat-sheet](https://daveceddia.com/jasmine-2-spy-cheat-sheet).'
- en: '*The Practical Test Pyramid*, Ham Vocke, 2018, [https://martinfowler.com/articles/practical-test-pyramid.html](https://martinfowler.com/articles/practical-test-pyramid.html).'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实用的测试金字塔*，汉姆·沃克，2018年，[https://martinfowler.com/articles/practical-test-pyramid.html](https://martinfowler.com/articles/practical-test-pyramid.html).'
- en: '*SOLID Principles*, Wikipedia, 2019, [https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID).'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SOLID 原则*，维基百科，2019年，[https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID).'
- en: Questions
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Answer the following questions as best as you can to ensure that you've understood
    the key concepts from this chapter without Googling. Do you need help answering
    the questions? See *Appendix D*, *Self-Assessment Answers* online at [https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf)
    or visit [https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地回答以下问题，以确保你已理解本章的关键概念，无需使用 Google。你需要帮助回答这些问题吗？请参阅 *附录 D*，*自我评估答案*，在线位于
    [https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf)
    或访问 [https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment)。
- en: What is the test pyramid?
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试金字塔是什么？
- en: What are fixtures and matchers?
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 固定装置和匹配器是什么？
- en: What are the differences between a mock, spy, and a stub?
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟、间谍和存根之间有什么区别？
- en: What is the benefit of building Angular in prod mode?
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生产模式下构建 Angular 的好处是什么？
- en: How does GitHub flow work?
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GitHub 流是如何工作的？
- en: Why should we protect the master branch?
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们应该保护主分支？
