- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking Your First Steps with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hello, readers!
  prefs: []
  type: TYPE_NORMAL
- en: This book assumes that you already know what React is and what problems it can
    solve for you. You may have written a small/medium application with React, and
    you want to improve your skills and answer all your questions. You should know
    that React is maintained by the developers at Meta and hundreds of contributors
    within the JavaScript community. React is one of the most popular libraries for
    creating UIs, and it is well known to be fast, thanks to its smart way of working
    with the **Document Object Model** (**DOM**). It comes with JSX, a new syntax
    for writing markup in JavaScript, which requires you to change your thinking regarding
    the separation of concerns. It has many cool features, such as server-side rendering,
    which gives you the power to write universal applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through some basic concepts that are essential
    to master in order to use React effectively, but are straightforward enough for
    beginners to figure out:'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between imperative and declarative programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React components and their instances, and how React uses elements to control
    the UI flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How React changed the way we build web applications, enforcing a different new
    concept of separation of concerns, and the reasons behind its unpopular design
    choice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why people feel JavaScript fatigue, and what you can do to avoid the most common
    errors developers make when approaching the React ecosystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow this book, you need to have some experience in using the terminal
    to run a few Unix commands. Also, you need to install **Node.js**. You have two
    options: the first one is to download Node.js directly from the official website
    ([https://nodejs.org](https://nodejs.org)), and the second option (recommended)
    is to install **Node Version Manager** (**NVM**) from [https://github.com/nvm-sh/nvm](https://github.com/nvm-sh/nvm).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you decide to go with NVM, you can install any version of Node.js you want
    and switch the versions with the `nvm install` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`node` is an alias for the latest version:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also install a global version of Node.js (`nvm` will install the latest
    version of Node.js locally to a user’s computer):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or you can install a very specific version:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After you have installed the different versions, you can switch between them
    by using the `nvm use` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, you can specify a default Node.js version by running the following
    command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In short, here is a list of the requirements to complete the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node.js (19+)**: [https://nodejs.org](https://nodejs.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NVM**: [https://github.com/nvm-sh/nvm](https://github.com/nvm-sh/nvm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VS Code**: [https://code.visualstudio.com](https://code.visualstudio.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TypeScript**: [https://www.npmjs.com/package/typescript](https://www.npmjs.com/package/typescript)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the code in the book’s GitHub repository: [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition).'
  prefs: []
  type: TYPE_NORMAL
- en: Differentiating between declarative and imperative programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When reading the React documentation or blog posts about React, you will have
    undoubtedly come across the term **declarative**. One of the reasons why React
    is so powerful is that it enforces a declarative programming paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, to master React, it is essential to understand what declarative programming
    means and what the main differences between imperative and declarative programming
    are. The easiest way to approach this is to think about imperative programming
    as a way of describing how things work, and declarative programming as a way of
    describing what you want to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Entering a bar for a beer is a real-life example in the imperative world, where
    normally you will give the following instructions to the bartender:'
  prefs: []
  type: TYPE_NORMAL
- en: Find a glass and collect it from the shelf.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the glass under the tap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull down the handle until the glass is full.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hand me the glass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the declarative world, you would just say, “Can I have a beer, please?”
  prefs: []
  type: TYPE_NORMAL
- en: The declarative approach assumes that the bartender already knows how to serve
    a beer, an important aspect of the way declarative programming works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move into a JavaScript example. Here we will write a simple function
    that, given an array of lowercase strings, returns an array with the same strings
    in uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'An imperative function to solve the problem would be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First, an empty array to contain the result is created. Then, the function loops
    through all the elements of the input array and pushes the uppercase values into
    the empty array. Finally, the output array is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'A declarative solution would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The items of the input array are passed to a `map` function that returns a
    new array containing the uppercase values. There are some significant differences
    to note: the former example is less elegant, and it requires more effort to be
    understood. The latter is terser and easier to read, which makes a huge difference
    in big code bases, where maintainability is crucial.'
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect worth mentioning is that in the declarative example, there is
    no need to use variables or to keep their values updated during the execution.
    Declarative programming tends to avoid creating and mutating a state.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final example, let’s see what it means for React to be declarative. The
    problem we will try to solve is a common task in web development: creating a toggle
    button.'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a simple UI component such as a toggle button. When you click it, it
    turns green (on) if it was previously gray (off), and switches to gray (off) if
    it was previously green (on).
  prefs: []
  type: TYPE_NORMAL
- en: 'The imperative way of doing this would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It is imperative because of all the instructions needed to change the classes.
    In contrast, the declarative approach using React would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In declarative programming, developers only describe what they want to achieve,
    and there’s no need to list all the steps to make it work. The fact that React
    offers a declarative approach makes it easy to use, and consequently, the resulting
    code is simple, which often leads to fewer bugs and more maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how React elements work and you will get
    more context on how props are being passed on a React component.
  prefs: []
  type: TYPE_NORMAL
- en: How React elements work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we assume that you are familiar with components and their instances,
    but there is another object you should know about if you want to use React effectively
    – the element. Elements are lightweight immutable descriptions of what should
    be rendered, while components are more complex stateful objects responsible for
    generating elements.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you `call` **createClass**, **extend Component**, or **declare a stateless
    function**, you are creating a component. React manages all the instances of your
    components at runtime, and there can be more than one instance of the same component
    in memory at a given point in time.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, React follows a declarative paradigm, and there’s no
    need to tell it how to interact with the DOM; you declare what you want to see
    on the screen, and React does the job for you. One of the tools that makes this
    process more expressive and readable is JSX, which allows you to write HTML-like
    syntax directly in your JavaScript code. JSX is not mandatory, but it’s widely
    used in the React community.
  prefs: []
  type: TYPE_NORMAL
- en: To control the UI flow, React uses a particular type of object called an element.
    These elements are created using the `React.createElement()` function, or more
    commonly, with JSX syntax. Elements contain only the information that is strictly
    needed to represent the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of an element created with JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This JSX code is converted into JavaScript objects like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The element’s type is crucial because it informs React on how to handle it.
    If the type is a string, the element represents a DOM node, while if it’s a function,
    the element represents a component.
  prefs: []
  type: TYPE_NORMAL
- en: You can nest DOM elements and components to create a render tree, representing
    the structure of your application’s user interface. By organizing your elements
    and components in a hierarchical manner, you can create complex and dynamic UIs.
  prefs: []
  type: TYPE_NORMAL
- en: React uses a technique called the Virtual DOM, which is an in-memory representation
    of the actual DOM. It compares the current and new trees to minimize the number
    of actual DOM updates. This process is called reconciliation and is used by both
    React DOM and React Native to create UIs for their respective platforms.
  prefs: []
  type: TYPE_NORMAL
- en: When an element’s type is a function, React invokes that function, passing in
    the element’s props to obtain the underlying elements. It recursively repeats
    this process on the result until it constructs a tree of DOM nodes that can be
    rendered on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, elements play a crucial role in React’s declarative paradigm, allowing
    you to create complex user interfaces without manually managing the creation and
    destruction of DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding how elements and components work together, and how React efficiently
    updates the UI using the Virtual DOM and reconciliation, you’ll be well equipped
    to build dynamic and efficient web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Unlearning everything
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with React for the first time, it’s essential to approach it with
    an open mind. This is because React represents a new way of designing web and
    mobile applications, breaking away from many traditional best practices.
  prefs: []
  type: TYPE_NORMAL
- en: In the last two decades, we’ve learned that separation of concerns is crucial,
    often involving separating logic from templates. We aim to write JavaScript and
    HTML in different files, and various templating solutions have been created to
    aid developers in achieving this goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the problem with this approach is that it often creates an illusion
    of separation. In reality, JavaScript and HTML are tightly coupled, no matter
    where they live. To illustrate this, let’s consider an example template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet is taken from the Mustache website, one of the most popular
    templating systems.
  prefs: []
  type: TYPE_NORMAL
- en: The first row tells Mustache to loop through a collection of items. Inside the
    loop, there is some conditional logic to check whether the `#first` and `#link`
    properties exist and, depending on their values, a different piece of HTML is
    rendered. Variables are wrapped in curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: If your application only has to display some variables, a templating library
    could represent a good solution, but when it comes to starting to work with complex
    data structures, things change. Templating systems and their **Domain-Specific
    Language** (**DSL**) offer a subset of features, and they try to provide the functionalities
    of a real programming language without reaching the same level of completeness.
    As shown in the example, templates highly depend on the models they receive from
    the logic layer to display the information.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, JavaScript interacts with the DOM elements rendered by the
    templates to update the UI, even if they are loaded from separate files. The same
    problem applies to styles – they are defined in a different file, but they are
    referenced in the templates, and the CSS selectors follow the structure of the
    markup, so it is almost impossible to change one without breaking the other, which
    is the definition of **coupling**. That is why the classic separation of concerns
    ended up being more the separation of technologies, which is, of course, not a
    bad thing, but it doesn’t solve any real problems.
  prefs: []
  type: TYPE_NORMAL
- en: React tries to move a step forward by putting the templates where they belong
    – next to the logic. The reason it does that is that React suggests you organize
    your applications by composing small bricks called components. The framework should
    not tell you how to separate the concerns because every application has its own,
    and only the developers should decide how to limit the boundaries of their applications.
  prefs: []
  type: TYPE_NORMAL
- en: The component-based approach drastically changes the way we write web applications,
    which is why the classic concept of separation of concerns is gradually being
    taken over by a much more modern structure. The paradigm enforced by React is
    not new, and it was not invented by its creators, but React has contributed to
    making the concept mainstream and, most importantly, popularized it in such a
    way that it is easier to understand for developers with different levels of expertise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rendering a React component looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We all agree that it seems a bit weird in the beginning, but that is just because
    we are not used to that kind of syntax. As soon as we learn it and we realize
    how powerful it is; we understand its potential. Using JavaScript for both logic
    and templating not only helps us separate our concerns in a better way, but it
    also gives us more power and more expressivity, which is what we need to build
    complex UIs.
  prefs: []
  type: TYPE_NORMAL
- en: That is why even if the idea of mixing JavaScript and HTML sounds weird in the
    beginning, it is vital to give React 5 minutes. The best way to get started with
    new technology is to try it on a small side project and see how it goes. In general,
    the right approach is always to be ready to unlearn everything and change your
    mindset if the long-term benefits are worth it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another concept that is pretty controversial and hard to accept, and
    that the engineers behind React are trying to push to the community: moving the
    styling logic inside the component, too. The end goal is to encapsulate every
    single technology used to create our components and separate the concerns according
    to their domain and functionalities. Here is an example of a style object taken
    from the React documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This set of solutions, where developers use JavaScript to write their styles,
    is known as **#CSSinJS**, and we will talk about it extensively in *Chapter 6*,
    *Making Your Components Look Beautiful*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to avoid JavaScript fatigue, which is caused
    by the large number of configurations that are needed to run a React application
    (webpack mainly).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding JavaScript fatigue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a prevailing opinion that React consists of a vast set of technologies
    and tools, and if you want to use it, you are forced to deal with package managers,
    transpilers, module bundlers, and an infinite list of different libraries. This
    idea is so widespread and shared among people that it has been clearly defined
    and given the name **JavaScript fatigue**.
  prefs: []
  type: TYPE_NORMAL
- en: Misconceptions about React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is not hard to understand the reasons behind JavaScript fatigue. All the
    repositories and libraries in the React ecosystem are made using shiny new technologies,
    the latest version of JavaScript, and the most advanced techniques and paradigms.
    Moreover, there is a massive amount of React boilerplate code on GitHub, each
    with tens of dependencies to offer solutions for any problem.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is essential to understand that React is a pretty tiny library,
    and it can be used inside any page (or even inside JSFiddle) in the same way everyone
    used to use jQuery or Backbone, just by including the script on the page before
    the closing body element.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with React without the fatigue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'React is split into two packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**react**: Implements the core features of the library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**react-dom**: Contains all the browser-related features'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason behind this is that the core package is used to support different
    targets, such as React DOM in browsers and React Native on mobile devices. Running
    a React application inside a single HTML page does not require any package manager
    or complex operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the URLs to be included in the HTML to start using React:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://unpkg.com/react@18.2.0/umd/react.production.min.js](mailto:https://unpkg.com/react@18.2.0/umd/react.production.min.js)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js](mailto:https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a simple UI, we could just use **createElement** (**_jsx** since React 17)
    and only when we start building something more complex can we include a transpiler
    to enable JSX and convert it into JavaScript. As the app grows, we may need a
    router, API endpoints, and external dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of the JavaScript ecosystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite the fast pace and constant change in the JavaScript ecosystem, it offers
    several advantages. The community plays a significant role in driving innovation
    and rapid evolution. As soon as a specification is announced or drafted, someone
    in the community implements it as a transpiler plugin or a polyfill, letting everyone
    else experiment with it while the browser vendors agree and start supporting it.
  prefs: []
  type: TYPE_NORMAL
- en: This makes JavaScript and the browser a unique environment compared to other
    languages or platforms. The downside is that things change quickly, but it is
    just a matter of finding the right balance between betting on new technologies
    versus staying safe.
  prefs: []
  type: TYPE_NORMAL
- en: Bye to Create-React-App, welcome to Vite!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recently, the React team decided to remove **create-react-app** from their official
    documentation, indicating that it is no longer the default method for setting
    up a new React project. Instead, React now recommends using a framework such as
    Next.js, Remix, or Gatsby for more comprehensive solutions. However, if these
    frameworks do not fit your needs and you are looking for a simpler alternative,
    you can opt for build tools like Vite or Parcel.
  prefs: []
  type: TYPE_NORMAL
- en: Vite as a solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Vite is a build tool and development server created by Evan You, the creator
    of Vue.js. It leverages the native ES modules feature in modern browsers for fast
    development and efficient production builds.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Vite with React, first, install Vite globally using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a new Vite project using the React TypeScript template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, move into the newly created project folder and start the development
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You should see the project running on port **5173** by default.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Vite default application'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to change the port to `3000`, you can modify the `vite.config.ts`
    file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: By using Vite, you can scaffold and run a React application with minimal dependencies
    and still have access to all the features needed to build a complete React application
    using the most advanced techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first chapter, we have learned about some basic concepts that are very
    important for following the rest of the book, and that are crucial to working
    with React daily. We now know how to write declarative code, and we have a clear
    understanding of the difference between the components we create and the elements
    that React uses to display their instances on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We learned the reasons behind the choice of locating logic and templates together,
    and why that unpopular decision has been a big win for React. We went through
    the reasons why it is common to feel fatigued in the JavaScript ecosystem, but
    we have also seen how to avoid those problems by following an iterative approach.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have seen what the new `create-vite` CLI is, and we are now ready
    to start writing some real code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn TypeScript and how to use it in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussion with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/React18DesignPatterns4e](https://packt.link/React18DesignPatterns4e)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2450023176943770109.png)'
  prefs: []
  type: TYPE_IMG
