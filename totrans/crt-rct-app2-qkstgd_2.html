<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating Our First Create React App Application</h1>
                </header>
            
            <article>
                
<p class="mce-root">In <a href="f616eaec-1edb-44b2-bc14-7fec21a70501.xhtml">Chapter 1</a>, <em>Introducing Create React App 2,</em> we started off by taking a good, long look at Create React App and some of the options it provides. We even got started with <kbd>create-react-app</kbd> and started learning React at a very basic level. What we need to do now, however, is start diving into building an application that will serve as the framework for adding more functionality and testing the limits of Create React App.</p>
<p>To make things extra easy, we're going to build a simple <strong>to do list</strong>, since that is an application that nearly everyone can understand. It even has a great non-digital analog to it, making it a simple thing to reason about!</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>Designing a web app</li>
<li>Building a simple project structure</li>
<li>Passing values to components via props</li>
<li>Passing functions to children components via props</li>
<li>Basic component styling with included CSS</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating our first major project</h1>
                </header>
            
            <article>
                
<p>It's now time for us to move forward and start building a real project that will function as the baseline project for all of the other features that we want to explore in this book! To do that, though, let's take a brief moment to talk about how we want to design our application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Designing our application</h1>
                </header>
            
            <article>
                
<p>It's very difficult to build a project when you're not sure precisely what you're building in the first place, right? When we talk about how to design, build, and plan an application, we need to talk about the problem we're ultimately trying to solve in the first place. With that in mind, let's talk about the theoretical vision for our application.</p>
<p>First off, we're going to build out a mixture between a <strong>pomodoro tracker</strong> and a to-do list. This will give us the functionality of a plain old to-do list, but also allow us to track time spent on each item as we go through the list. We'll keep the overall design of this application pretty simple; there's no reason to dive into a giant application. A relatively small and simple application will teach you all you need to get started quickly with Create React App.</p>
<p>This chapter is also going to be the only chapter that's really only focused on the React side of things and less on Create React App. Being able to get started with any tool is essentially useless if you don't know how to build something after you get up and moving, so that is what this chapter is designed to help you solve.</p>
<p>Our application will have a simple to-do interface with a <span class="packt_screen">Mark As Done</span> button for each. For each item, you'll be able to mark the item as complete after you add it and it will change the display of that item to let you know it's done. There's not really anything particularly fancy going on, just a very simple application design. Let's take a look at what the design for this might look like (at a very high level):</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-433 image-border" src="Images/8ea111d6-4175-4de0-a3ab-5102792a830d.png" style="width:24.42em;height:16.25em;" width="561" height="372"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building the baseline functionality for our application</h1>
                </header>
            
            <article>
                
<p>Now that we understand the design, we'll want to jump right in to creating the project and getting things built. While the application is not particularly tricky, there's a decent amount of complexity overall and a pretty good amount of code we'll end up having to write. To make things work, we'll separate out our application's concerns and make sure what we're building, even in its limited scope, is still very similar to what you'd build in a real world application!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating our project</h1>
                </header>
            
            <article>
                
<p>Similar to the previous project, we'll start off by creating a new project with Create React App, which we'll call <kbd>todoifier</kbd>:</p>
<pre><strong>$ create-react-app todoifier</strong></pre>
<p>After the project has been created, we'll also verify that everything was set up correctly and runs by running <kbd>start</kbd> on the project:</p>
<pre><strong>$ yarn start</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Initializing our components to build on top off</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span><span>Whenever you're building your project, you should strive to keep the top-level component, which is <kbd>src/App.js</kbd> in our case, as simple as possible and keep as little code in it as you possibly can. In our case, we're just going to remove everything (similar to the work we did in the previous chapter, <a href="f616eaec-1edb-44b2-bc14-7fec21a70501.xhtml">Chapter 1</a>, <em>Introducing Create React App 2</em>) and replace it with a simple replacement header and not much else:</span></span></p>
<div>
<pre><span>import</span><span> </span><span>React</span><span> </span><span>from</span><span> </span><span>'react'</span><span>;<br/></span><span>import</span><span> </span><span>'./App.css'</span><span>;<br/><br/></span><span>const</span><span> </span><span>App</span><span> </span><span>=</span><span> () </span><span>=&gt;</span><span> (<br/></span><span> </span><span>&lt;</span><span>div</span><span> </span><span>className</span><span>=</span><span>"App"</span><span>&gt;<br/></span><span>   </span><span>&lt;</span><span>h2</span><span>&gt;</span><span>Todoifier</span><span>&lt;/</span><span>h2</span><span>&gt;<br/></span><span> </span><span>&lt;/</span><span>div</span><span>&gt;<br/></span><span>);<br/><br/></span><span>export</span><span> </span><span>default</span><span> </span><span>App</span><span>;</span></pre></div>
<p>We'll also want to remove everything from <kbd>App.css</kbd>, since we're taking a blank-slate approach with this project as well!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building separate components in separate files</h1>
                </header>
            
            <article>
                
<p>One of the nicest things about Create React App is how simple it makes even the process of importing other files as their own separate React components without you really having to think about how Webpack is organizing everything. We're going to build a new simple component to get started with. Let's create a <kbd>Todo</kbd> component to keep track of each of the <kbd>Todo</kbd> items we'll need to add as we go along.</p>
<p class="mce-root">Back over in <kbd>src/Todo.js</kbd>, we'll want to duplicate everything from <kbd>App.js</kbd> (except the string in the <kbd>className</kbd> property and the function name):</p>
<pre>import React from 'react';<br/>import './Todo.css';<br/><br/>const Todo = () =&gt; &lt;div className="Todo"&gt;I am an item&lt;/div&gt;;<br/><br/>export default Todo;</pre>
<p class="mce-root">There's nothing exciting to talk about here, so we'll keep forging ahead! We should also create a <kbd>Todo.css</kbd> file to make sure our component does not remain unstyled:</p>
<pre>.Todo {<br/>  border: 2px solid black;<br/>  text-align: center;<br/>  background: #f5f5f5;<br/>  color: #333;<br/>  margin: 20px;<br/>  padding: 20px;<br/>}</pre>
<p class="mce-root">Without doing anything, we won't see the results of our fancy new <kbd>Todo</kbd> component that we just created, so we'll need to head back to <kbd>src/App.js</kbd> and change the code. We'll start by adding an <kbd>import</kbd> statement at the top for the <kbd>Todo</kbd> component! Remember, we're loading this file from the local filesystem and not some installed dependency:</p>
<pre class="mce-root">import Todo from './Todo';</pre>
<p class="mce-root">We'll also need to include the <kbd>Todo</kbd> component somewhere in the source so that it shows up when we re-render the page:</p>
<pre>const App = () =&gt; (<br/>  &lt;div className="App"&gt;<br/>    &lt;h2&gt;Todoifier&lt;/h2&gt;<br/>    &lt;br /&gt;<br/>    &lt;Todo /&gt;<br/>  &lt;/div&gt;<br/>);</pre>
<p class="mce-root"><span><span>All we've added here is the</span></span> <kbd>Todo</kbd> <span><span>component, which is getting rendered in the main root <kbd>div</kbd> of the <kbd>App</kbd> component. When the browser refreshes (assuming you've saved), you should see the <kbd>Todo</kbd> component show up and be ready to go!</span></span></p>
<p>The exciting part of this whole process is that we've already introduced better code standards and reusability by doing this. The <kbd>Todo</kbd> component has been fully extracted out, so if we wanted to include multiple <kbd>Todo</kbd> components in our <kbd>App</kbd>, we could do so without having to do anything more complicated than copying and pasting a few lines of code.</p>
<p>This sounds pretty great, so let's try it out ourselves and verify that it all works as we expect. Back in the <kbd>App</kbd> component, add a few more <kbd>Todo</kbd> components as JSX tags:</p>
<pre>const App = () =&gt; (<br/>  &lt;div className="App"&gt;<br/>    &lt;h2&gt;Todoifier&lt;/h2&gt;<br/>    &lt;br /&gt;<br/>    &lt;Todo /&gt;<br/>    &lt;Todo /&gt;<br/>  &lt;/div&gt;<br/>);</pre>
<p class="mce-root">When we have our <kbd>Todo</kbd> declared twice in the root of our <kbd>App</kbd> component, we should see those two show up:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-428 image-border" src="Images/a90cdac8-cead-492d-974b-1632fb3e266c.png" style="width:71.83em;height:35.00em;" width="862" height="420"/></p>
<p class="mce-root CDPAlignLeft CDPAlign"><span>With that, we've gotten a nice clean amount of reusability and have had to put in almost no effort! The problem that still exists, though, is that there is no variation here. The components are just blindly repeated over and over, and we'd much rather this do something such as display some different content per each <kbd>Todo</kbd>. We can make that work in React by introducing two new concepts: <strong>state</strong> and <strong>props</strong>! We'll get to state in a little bit, so let's start off with props to get this all implemented in the simplest way possible.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introducing props</h1>
                </header>
            
            <article>
                
<p>So, what are props? Props are shorthand for <em>properties</em>, and as you can guess, they define properties inside of our React components. Generally speaking, these get passed in from the parent, although they can get passed in from anywhere, truth be told.</p>
<p>Right now, we're just using a simple functional component, and that function doesn't specify any arguments as part of its signature, so if we want to start using props we'll have to change that first.</p>
<p>Let's open up our <kbd>Todo</kbd> component in <kbd>src/Todo.js</kbd>, and change the function declaration to also pass in a <kbd>props</kbd> argument:</p>
<pre class="mce-root">const Todo = props =&gt; {</pre>
<p class="mce-root">This would roughly be the equivalent of us writing the following in vanilla JavaScript:</p>
<pre class="mce-root">function Todo(props) {</pre>
<p class="mce-root">Next, we'll have to change the display text to actually use something from our <kbd>props</kbd> argument, so we'll add a reference to <kbd>{props.description}</kbd>:</p>
<pre class="mce-root">const Todo = props =&gt; &lt;div className="Todo"&gt;{props.description}&lt;/div&gt;;</pre>
<p class="mce-root">Save the file, because now we'll have to head back over to our primary <kbd>App</kbd> component (<kbd>src/App.js</kbd>) and start passing in the <kbd>description</kbd> as part of the properties passed in to our <kbd>Todo</kbd> components:</p>
<pre class="mce-root">const App = () =&gt; (<br/>  &lt;div className="App"&gt;<br/>    &lt;h2&gt;Todoifier&lt;/h2&gt;<br/>    &lt;br /&gt;<br/>    &lt;Todo description="Do the thing" /&gt;<br/>    &lt;Todo description="Do another thing" /&gt;<br/>  &lt;/div&gt;<br/>);</pre>
<p class="mce-root">After saving the file and seeing the browser window refresh, we should expect to see the properties we just entered now show up in the browser, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-429 image-border" src="Images/8f804268-9afe-4846-98cb-c0735cd3d98e.png" style="width:45.00em;height:19.75em;" width="1938" height="849"/></p>
<p class="mce-root">And there we are! Reusable, modifiable components, done with almost no effort at all!</p>
<p>The even better part is that any changes to <kbd>props</kbd> will trigger React to re-render that component (depending on what changed and where it changed). This is something that is profoundly useful, especially when you factor in that the old world had you checking for changes, and then trying to either delete and recreate elements on the fly or try to sneak the changes in without having to remove it all away.</p>
<p>Props are great, overall, but if we want to do something a little more permanent and something that is better for storing how something changes over time, we need to introduce the concept of state. Instead of props, state is meant to be used for something that is changing all of the time, generally local to a single component; you'll pass the state down to child components that need it via props.</p>
<p>The trouble is that we're currently using functional components, which is fine for now, but the minute we want to start tracking any sort of internal state, we'll need to switch to a different method of creating our React components.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing a class-based component</h1>
                </header>
            
            <article>
                
<p>In <strong><span>ECMAScript 6</span></strong> (<strong>ES6</strong>), we got our first taste of real object-oriented programming in JavaScript with <strong>Classes</strong>. A class is declared in a fundamentally different way than our functional components, but most of the core tenets remain the same and there's not a huge amount more we need to learn to start using them.</p>
<p>The first thing we'll need to do is make a small modification to the <kbd>import</kbd> statement in <kbd>src/Todo.js</kbd>. We'll need to <kbd>import</kbd> not just React itself: we'll also need to <kbd>import</kbd> a particular named export specified in React, something called <kbd>Component</kbd><strong>.</strong> <span><span>Let's take a look at what the new <kbd>import</kbd> statement looks like:</span></span></p>
<pre class="mce-root">import React, { Component } from 'react';</pre>
<p class="mce-root"><span><span>We have our <kbd>Component</kbd> imported as well, so let's explore the syntax for declaring a <kbd>class</kbd>:</span></span></p>
<pre>class Todo extends Component { /* ... */ }</pre>
<p>This tells JavaScript that we're building a new <kbd>Todo</kbd> class that inherits the functionality of <kbd>Component</kbd> (thus the <kbd>extends</kbd> keyword). Next, any React component we build as an ES6 class needs to have a <kbd>render()</kbd> function declared. To declare a function inside of a class, you just write the name, the arguments, and then the body inside of your class definition:</p>
<pre>functionName(argument1, argument2) { /* ... */ }</pre>
<p>React specifically requires us to declare a <kbd>render()</kbd> function with no arguments, as we mentioned earlier. Our <kbd>return</kbd> statement is identical to what we had in our previous functional component, so putting everything together we should end up with something similar to this:</p>
<pre class="mce-root">class Todo extends Component {<br/>  render() {<br/>    return &lt;div className="Todo"&gt;{this.props.description}&lt;/div&gt;;<br/>  }<br/>}</pre>
<p class="mce-root">Here, we write out our <kbd>render() { … }</kbd> function, which is largely unchanged except for one small change: <kbd>props.description</kbd> is now <kbd>this.props.description</kbd>!</p>
<p>The reason for this is that props is not something that is just an argument on a function anymore. It's actually part of a class-specific property, so we need to tell JavaScript that when we say <kbd>props</kbd>, we actually mean the <em>props local to this class</em>. We just shorthand that with <kbd>this.props</kbd>! With that out of the way, we can start diving even further into the world of state!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Bringing state into our component</h1>
                </header>
            
            <article>
                
<p>Part of declaring state to a class component is to start off with an initial or default state. We can't do that without telling JavaScript what to do when our class is actually instantiated, so our class will need to have a <kbd>constructor</kbd> to handle that work. In our <kbd>Todo</kbd> class, we'll build out our <kbd>constructor</kbd> function, which will take in <kbd>props</kbd> as its single argument:</p>
<pre class="mce-root">  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      description: props.description,<br/>      done: false<br/>    };<br/>  }</pre>
<p>JavaScript knows to use <kbd>constructor()</kbd> as our constructor since that is a language construct, and we know it needs to take in <kbd>props</kbd>. Since we're extending off of React's <kbd>Component</kbd> class, we need to call <kbd>super()</kbd> as our first line of code in <kbd>constructor()</kbd>. This tells JavaScript to instead use the code in <span><kbd>constructor()</kbd> of</span> <kbd>Component</kbd> to set up whatever it needs to. Next, we set the state by declaring a new variable attached to our class called, uninterestingly enough, <kbd>this.state</kbd>. We make it a plain object with a key of <kbd>description</kbd>, which just stores the passed-in description on the <kbd>props</kbd> argument. It also has a property called <kbd>done</kbd> that starts off with a default value of <kbd>false</kbd> (since we should not create our tasks as already done). This code by itself won't actually do anything, so let's also change our <kbd>render()</kbd> function to take advantage of our <kbd>state</kbd>:</p>
<pre>  render() {<br/>    return &lt;div className="Todo"&gt;{this.state.description}&lt;/div&gt;;<br/>  }</pre>
<p class="mce-root">Nothing has quite changed yet. Instead, we'll need to add some form of interactivity to make the case for using <kbd>state</kbd> really known!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding interactivity via state modifications</h1>
                </header>
            
            <article>
                
<p class="mce-root">We'll add a very simple <kbd>button</kbd> to our <kbd>Todo</kbd> component called <kbd>Mark as Done</kbd>. When clicked, this <kbd>button</kbd> should change our <kbd>state</kbd> <kbd>done</kbd> status for that <kbd>Todo</kbd> item to <kbd>true</kbd>. Now, we'll want to make sure that anything that does change is only changed on this component and not all components, which is a big part of using internal state! Let's first build out our <kbd>markAsDone()</kbd> function:</p>
<pre class="mce-root">markAsDone() {<br/>  this.setState({ done: true });<br/>}</pre>
<p class="mce-root">That being done, we can move on to implementing our functionality by including our <kbd>Mark as Done</kbd> button:</p>
<pre class="mce-root">  render() {<br/>    return (<br/>      &lt;div className={'Todo' + (this.state.done ? ' Done' : '')}&gt;<br/>        {this.state.description}<br/>        &lt;br /&gt;<br/>        &lt;button onClick={this.markAsDone}&gt;Mark as Done&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }</pre>
<p class="mce-root">Now, if we just hit save, wait for the refresh, and try to click the <kbd>markAsDone</kbd> button, we'll end up getting an error message:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/78fdf8b7-7d30-450a-844d-3f08127182f1.png" style="width:24.50em;height:21.50em;" width="644" height="568"/></p>
<p>Let's explore this error message a little more. We're getting a <span class="packt_screen">TypeError: this is undefined</span> message, here, and it's not the most clear error message in the world, certainly. This is one of the drawbacks of using ES6 classes with any sort of React component in combination with JavaScript event handlers. So in this case, when we have our <kbd>onClick</kbd> calling out to <kbd>this.markAsDone</kbd>, and the function goes into the body of <kbd>markAsDone</kbd>, it tries to call <kbd>this.setState</kbd> but it doesn't actually understand what <kbd>this</kbd> is trying to reference! This only happens with event handlers, so we don't need to worry about this all of the time. The good news is that there is a simple means of fixing this issue. Let's add one more line back to our <kbd>constructor</kbd>, as follows:</p>
<div>
<pre><span>this</span><span>.</span><span>markAsDone</span><span> </span><span>=</span><span> </span><span>this</span><span>.</span><span>markAsDone</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>);</span></pre></div>
<p class="mce-root">This tells JavaScript that if it ever sees a reference to <kbd>this</kbd> inside of the <kbd>markAsDone</kbd> function, it is a specific reference to the <kbd>Todo</kbd> class. Save the file and click the <span class="packt_screen">button—</span>it works! Well, you can't tell whether it works yet. We'll need to add a little bit of visual indication that it has worked.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Indicating our state with CSS</h1>
                </header>
            
            <article>
                
<p>We're very close to this working perfectly, but we're missing a little bit of code to tell our React component to know when to use certain CSS classes. Let's start by adding a new function, <kbd>cssClasses()</kbd>, which will return a list of CSS classes to include in our component:</p>
<pre>  cssClasses() {<br/>    let classes = ['Todo'];<br/>    if (this.state.done) {<br/>      classes = [...classes, 'Done'];<br/>    }<br/>    return classes.join(' ');<br/>  }</pre>
<p>There's nothing particularly special about this other than the use of the JavaScript spread operator (the <kbd>...classes</kbd> bit). This is just a way for us to add on to the end of the array in a safe way. Next, we'll change the logic where we declare <kbd>className</kbd> for our component to use this new function:</p>
<pre>  render() {<br/>    return (<br/>      &lt;div className={this.cssClasses()}&gt;<br/>// ...</pre>
<p>Finally, in <kbd>src/Todo.css</kbd>, add the new <kbd>.Done</kbd> CSS class definition:</p>
<pre>.Done {<br/>  background: #f58888;<br/>}</pre>
<p class="mce-root">And now, we can see the result when we click on one of the <span class="packt_screen">Mark as Done</span> buttons:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-430 image-border" src="Images/293ea9dd-06cc-4f8a-8da6-70cfa687c5f3.png" style="width:77.50em;height:49.17em;" width="1480" height="939"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Iterating our project further</h1>
                </header>
            
            <article>
                
<p>Okay, we have some state and some props in each component; we have components that can be used and reused as needed, we can see a little bit of interactivity, and we have great separation of each of our components. This brings us a little closer to writing more difficult and complex React components. More importantly, we're getting to build a larger, more complex application that will require some of the bells and whistles that we get as part of Create React App's toolset.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building a List component</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let’s take things a step further with our <kbd>Todo</kbd> components and actually create a dynamic list of components that we can add to! We’ll need to start by adding a new <kbd>TodoList</kbd> that is in charge of rendering our list of <kbd>Todo</kbd> components!</p>
<p>We'll start by adding two new files to handle our list of Todos: <kbd>src/TodoList.js</kbd> and <kbd>src/TodoList.css</kbd>. In our <kbd>src/TodoList.js</kbd> file, we'll start off with a pretty standard React scaffold (you'll be writing something similar to this pretty often, so this will become second nature very quickly):</p>
<pre class="mce-root">import React, { Component } from 'react';<br/>import Todo from './Todo';<br/>import './TodoList.css';<br/><br/>class TodoList extends Component {<br/><br/>}<br/><br/>export default TodoList;</pre>
<p>Note that the body of our class is empty right now. We'll next need to add a <kbd>render()</kbd> function, so let's jump right to that:</p>
<pre class="mce-root">render() {<br/>  return (<br/>    &lt;div className="TodoList"&gt;<br/>      &lt;Todo description="Item #1" /&gt;<br/>      &lt;Todo description="Item #2" /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</pre>
<p class="mce-root">We'll also need to modify our style sheet for the <kbd>TodoList</kbd> so it's not just completely default:</p>
<pre>.TodoList {<br/> margin: 20px;<br/> padding: 20px;<br/> border: 2px solid #00D8FF;<br/> background: #DDEEFF;<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding the TodoList to our App</h1>
                </header>
            
            <article>
                
<p class="mce-root">Right now, we just display a list of <kbd>Todo</kbd> items through copying and pasting the component a bunch of times, but that's not very interesting, nor is it good programming practice! Instead, let's add our <kbd>List</kbd> component to our <kbd>App</kbd> and have that be responsible for handling multiple items. We'll start off by importing our new <kbd>TodoList</kbd> component from the local filesystem into <kbd>src/App.js</kbd>:</p>
<pre class="mce-root">import TodoList from './TodoList';</pre>
<p class="mce-root">We'll also need to change the <kbd>render()</kbd> function to use the <kbd>TodoList</kbd> component, instead of the two <kbd>Todo</kbd> components directly:</p>
<pre class="mce-root">const App = () =&gt; (<br/>  &lt;div className="App"&gt;<br/>    &lt;h2&gt;Todoifier&lt;/h2&gt;<br/>    &lt;br /&gt;<br/>    &lt;TodoList /&gt;<br/>  &lt;/div&gt;<br/>);</pre>
<p>Everything should look almost the same, except since we changed the style sheet a little bit there should be a clean little blue box around the entire list. This helps us see the distinction between each component and the parent components surrounding it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding state to TodoList</h1>
                </header>
            
            <article>
                
<p class="mce-root">We'll need some <kbd>state</kbd> in <kbd>src/TodoList.js</kbd> before we can do much else, so we'll just create an initial <kbd>state</kbd> that's not too exciting but gets the job done. Add a <kbd>constructor</kbd> to the <kbd>TodoList</kbd> component and give it the following body:</p>
<pre>constructor(props) {<br/>  super(props);<br/>  this.state = { items: ['Item #1', 'Item #2'] };<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating and using a helper render() function</h1>
                </header>
            
            <article>
                
<p>Creating and initializing state but not doing anything with it doesn't help us very much, so we'll want to make sure that all of the JSX is built with the help of our state! We'll have to loop over each <kbd>Todo</kbd> item that is stored in our <kbd>state</kbd>, which we'll name <kbd>this.state.items</kbd>, and for each item we'll render the <kbd>Todo</kbd> component and, using props, pass in the <kbd>description</kbd> of that <kbd>Todo</kbd>.</p>
<p>We're going to use the <kbd>map</kbd> function here specifically since <kbd>map</kbd> will iterate over each item, perform a function, and then store the results as an array. JSX is expecting us to return either a single JSX element or an array of JSX elements, so this will fit our needs quite nicely. We'll also delegate this task to a new function called <kbd>renderItems()</kbd> to make sure each of our functions serves a single small purpose:</p>
<pre class="mce-root">renderItems() {<br/>  return this.state.items.map(description =&gt; (<br/>    &lt;Todo key={description} description={description} /&gt;<br/>  ));<br/>}</pre>
<p>The only new thing here is the addition of the <kbd>key</kbd> property. This is an important part of adding multiple items in React via JSX: React has to know how to reference the item in question in some sort of unique way. If React is going to change something, delete it, or otherwise affect the DOM, it has to have something to reference the specific item by.</p>
<div class="mce-root packt_tip"><br/>
We're not actually guaranteeing much of anything here with the list of names; if we end up with any duplicates it will cause us issues, but this is just our naive implementation for now.</div>
<p class="mce-root"><span><span>Return back to the <kbd>render()</kbd> function and we'll add a reference to our new <kbd>renderItems()</kbd> function instead of the multiple calls to <kbd>Todo</kbd>:</span></span></p>
<pre class="mce-root">render() {<br/>  return &lt;div className="TodoList"&gt;{this.renderItems()}&lt;/div&gt;;<br/>}</pre>
<p class="mce-root"><span><span>Just to be extra sure, let's also add a third item back in our <kbd>constructor</kbd> to our initial state. If we can verify this as well, then we know we've implemented everything correctly:</span></span></p>
<pre class="mce-root">constructor(props) {<br/>  super(props);<br/>  this.state = { items: ['Item #1', 'Item #2', 'Item #3'] };<br/>}</pre>
<p class="mce-root"><span><span>There we are! Three items, all working appropriately, and all functioning entirely off of the <kbd>state</kbd>! That's a pretty good measure of progress!</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a new Todo component</h1>
                </header>
            
            <article>
                
<p class="mce-root">Now that we have a good initial pass at dynamic state affecting our DOM, it's time to create a new component that will allow us to add additional <kbd>Todo</kbd> items to our <kbd>TodoList</kbd>. We'll call this, well, <kbd>NewTodo</kbd>! Create <kbd>src/NewTodo.js</kbd> and <kbd>src/NewTodo.css</kbd> to start, as per usual. Then, in <kbd>src/NewTodo.css</kbd>, give it some default style:</p>
<pre class="mce-root"> .NewTodo {<br/>  margin: 20px;<br/>  padding: 20px;<br/>  border: 2px solid #00FFD8;<br/>  background: #DDFFEE;<br/>  text-align: center;<br/> }</pre>
<p class="mce-root">And then, it's time for us to build out our <kbd>NewTodo</kbd> component! We start off with our React boilerplate code that we do all the time:</p>
<pre>import React, { Component } from 'react';<br/>import './NewTodo.css';<br/><br/>class NewTodo extends Component {<br/>}<br/><br/>export default NewTodo;</pre>
<p>Next, we'll build out our <kbd>constructor()</kbd> function:</p>
<pre>  constructor(props) {<br/>    super(props);<br/>    this.state = { item: '' };<br/>    this.handleUpdate = this.handleUpdate.bind(this);<br/>  }</pre>
<p>We start off with our call to <kbd>super()</kbd>, same as always. Next, we'll set up an initial state with an <kbd>item</kbd> property that starts off blank (more on this later). We'll also need to write something to handle updates, so we'll write a<strong> </strong><kbd>bind</kbd> statement on a <kbd>handleUpdate()</kbd> function (which we'll write next):</p>
<pre>  handleUpdate(event) {<br/>    this.setState({ item: event.target.value });<br/>  }</pre>
<p>So, when <kbd>handleUpdate()</kbd> is called, it is going to take a DOM event, which if we wanted to get the value of the input that is changing, we'd grab it via <kbd>event.target.value</kbd>. Finally, let's hit up our <kbd>render()</kbd> function:</p>
<pre class="mce-root">render() {<br/>  return (<br/>    &lt;div className="NewTodo"&gt;<br/>      &lt;input type="text" onChange={this.handleUpdate} /&gt;<br/>      &amp;nbsp;&amp;nbsp;<br/>      &lt;button&gt;Add&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</pre>
<p class="mce-root">Most of this code is unremarkable, but note that we have an <kbd>input</kbd> here, which is a <kbd>text</kbd> type, which reacts to every time the input's value is changed by delegating the handler to the <kbd>handleUpdate()</kbd> function we already wrote!</p>
<p>It's time to head back to our <kbd>TodoList</kbd>, import the <kbd>NewTodo</kbd> component, and add it near the top of our call to <kbd>render()</kbd>. At the top of <kbd>src/TodoList.js</kbd>, add the following:</p>
<div>
<pre><span>import</span><span> </span><span>NewTodo</span><span> </span><span>from</span><span> </span><span>'./NewTodo'</span><span>;</span></pre></div>
<p class="mce-root">And then, add <kbd>NewTodo</kbd> into the <kbd>render()</kbd> function:</p>
<pre class="mce-root">render() {<br/>  return (<br/>    &lt;div className="TodoList"&gt;<br/>      &lt;NewTodo /&gt;<br/>      {this.renderItems()}<br/>    &lt;/div&gt;<br/>  );<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Passing a function as a prop</h1>
                </header>
            
            <article>
                
<p>This introduces a very interesting <em>chicken and egg</em> sort of scenario: how do we add a component to a parent from the child component? The list of <kbd>Todo</kbd> items lives in <kbd>TodoList</kbd>, and our component where we need to add new Todos is a separate component that lives inside of <kbd>TodoList</kbd>! There's no internal state for a list of Todos in <kbd>NewTodo</kbd>, so how do we make this work?</p>
<p>Easy! We'll create a function in <kbd>TodoList</kbd>, which can modify its list of components, and then pass that function into our <kbd>NewTodo</kbd> component. So, inside of <kbd>src/TodoList.js</kbd>, we'll need to add a new function called <kbd>addTodo()</kbd> and we will have to make sure it includes a <kbd>bind()</kbd> statement so that no matter where that function lives, it knows how to handle references to <kbd>this</kbd>. In the <kbd>constructor</kbd>, add our <kbd>bind</kbd> statement:</p>
<pre class="mce-root">this.addTodo = this.addTodo.bind(this);</pre>
<p>Let's move on to writing our <kbd>addTodo()</kbd> function. We'll accept a single string, which will be the description that we add. The good news is that this function is super easy to write:</p>
<pre class="mce-root">addTodo(item) {<br/>  this.setState({ items: [...this.state.items, item] });<br/>}</pre>
<p>We're using some new JavaScript syntax here, an array spread. This allows us to essentially take a shortcut with adding new items! Essentially, we want to add new items onto the list of items in the <kbd>state</kbd>, but we want to do so in a way that is non-destructive. This will make a modified copy of the item list and preserve the original. We set the list of items equal to this newly-modified array and that's it! All we have to do next is just pass this new <kbd>addTodo</kbd> function to <kbd>NewTodo</kbd> as a prop:</p>
<pre class="mce-root">render() {<br/>  return (<br/>    &lt;div className="TodoList"&gt;<br/>      &lt;NewTodo addTodo={this.addTodo} /&gt;<br/>      {this.renderItems()}<br/>    &lt;/div&gt;<br/>  );<br/>}</pre>
<p>Let's hop back over to <kbd>src/NewTodo.js</kbd>. We'll need to duplicate our function name, so we'll add an <kbd>addTodo</kbd> function inside of <kbd>NewTodo</kbd>. This is going to be called via a JavaScript event handler, so we'll need to add a <kbd>bind</kbd> statement for it inside of our <kbd>constructor</kbd>:</p>
<div>
<pre><span>this</span><span>.</span><span>addTodo</span><span> </span><span>=</span><span> </span><span>this</span><span>.</span><span>addTodo</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>);</span></pre></div>
<p class="mce-root">And, note the following for our <kbd>addTodo()</kbd> function body:</p>
<pre class="mce-root">addTodo() {<br/>  this.props.addTodo(this.state.item);<br/>  this.setState({ item: '' });<br/>}</pre>
<p>Remember the <kbd>addTodo()</kbd> function that we passed down via props? We'll need to call that function via the props on the object and pass in the <kbd>item</kbd> property inside of our <kbd>state</kbd>. Remember, <kbd>item</kbd> is the value that is getting updated all of the time via our <kbd>onChange</kbd> event handlers! Finally, let's modify <kbd>render()</kbd> to put it all together:</p>
<pre class="mce-root"><br/>  render() {<br/>    return (<br/>      &lt;div className="NewTodo"&gt;<br/>        &lt;input<br/>          type="text"<br/>          onChange={this.handleUpdate}<br/>          value={this.state.item}<br/>        /&gt;<br/>        &amp;nbsp;&amp;nbsp;<br/>        &lt;button onClick={this.addTodo}&gt;Add&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }</pre>
<p>We need to add a new value property and set it to the current value of the <kbd>item</kbd> property from our <kbd>state</kbd>. Without doing this, we won't be able to see what is going on when we clear out the state's <kbd>item</kbd> property. Finally, we added a new <kbd>onClick</kbd> event handler that just calls out to <kbd>addTodo</kbd>, just like we prepared for!</p>
<p>Test it out and there we go: interactivity!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Removing items is important too</h1>
                </header>
            
            <article>
                
<p>If we're adding items, we should remove them too, so we'll implement a <kbd>removeTodo()</kbd> function in the <kbd>TodoList</kbd>, and then that will get passed down into each <kbd>Todo</kbd>. This is very similar to what we did in the <kbd>NewTodo</kbd> component. We'll need to follow the same steps: add a <kbd>bind</kbd> statement, write the <kbd>removeTodo()</kbd><strong> </strong>function, and implement calling it in the <kbd>Todo</kbd> component.</p>
<p class="mce-root">First, the <kbd>bind</kbd> in <kbd>src/TodoList.js</kbd> is as follows:</p>
<pre>  constructor(props) {<br/>    super(props);<br/>    this.state = { items: ['Item #1', 'Item #2', 'Item #3'] };<br/><br/>    this.addTodo = this.addTodo.bind(this);<br/>    this.removeTodo = this.removeTodo.bind(this);<br/>  }</pre>
<p class="mce-root">Next, we'll implement the <kbd>removeTodo()</kbd> function. We'll <kbd>filter</kbd> out any Todos that match the item we want to remove and set that as the new list of Todos:</p>
<pre class="mce-root">  removeTodo(removeItem) {<br/>    const filteredItems = this.state.items.filter(description =&gt; {<br/>      return description !== removeItem;<br/>    });<br/>    this.setState({ items: filteredItems });<br/>  }</pre>
<p class="mce-root"><span><span>The final thing we need to do is change the <kbd>renderItems()</kbd> call so that it passes this new function down to each <kbd>Todo</kbd>:</span></span></p>
<pre class="mce-root">  renderItems() {<br/>    return this.state.items.map(description =&gt; (<br/>      &lt;Todo<br/>        key={description}<br/>        description={description}<br/>        removeTodo={this.removeTodo}<br/>      /&gt;<br/>    ));<br/>  }</pre>
<p>Finally, we're ready to implement this in the child component. Open up <kbd>src/Todo.js</kbd>, and we'll implement a duplicate-named <kbd>removeTodo()</kbd> function inside of the <kbd>Todo</kbd> component. We'll also need a <kbd>bind</kbd>, so we'll start this implementation in the <kbd>constructor</kbd>:</p>
<pre class="mce-root">this.removeTodo = this.removeTodo.bind(this);</pre>
<p class="mce-root">And, we'll write the <kbd>removeTodo()</kbd> function:</p>
<pre class="mce-root">removeTodo() {<br/>  this.props.removeTodo(this.state.description);<br/>}</pre>
<p class="mce-root">The last thing we need to do is add a call, via a <kbd>button</kbd> and an <kbd>onClick</kbd> event handler, and call the component's <kbd>removeTodo()</kbd> function:</p>
<pre class="mce-root">render() {<br/> return (<br/> &lt;div className={this.cssClasses()}&gt;<br/> {this.state.description}<br/> &lt;br /&gt;<br/> &lt;button onClick={this.markAsDone}&gt;Mark as Done&lt;/button&gt;<br/> &lt;button onClick={this.removeTodo}&gt;Remove Me&lt;/button&gt;<br/> &lt;/div&gt;<br/> );<br/>}</pre>
<p class="mce-root"><span><span>After saving and the browser refreshing, you should now be able to add and remove items on the fly! Full interactivity! Refer to the following screenshot:</span></span></p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="Images/b9c39065-0d21-4a77-b830-7688b927f879.png" width="1826" height="1254"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>By now, you should have a strong grasp on React, how React functions, how to write good JSX and React code, and a bunch of the different gotchas and concerns you can run into. We covered all of this while still getting work done without ever having to go outside of Create React App. Now, we should have the following:</p>
<ul>
<li>A working Create React App project</li>
<li>A more complicated application structure</li>
<li>An understanding of how to affect parent structures by passing variables and functions as properties</li>
<li>How to bind functions that may be called from inside event handlers</li>
</ul>
<p class="mce-root">As we move on from this chapter, we'll dive more deeply into the other features of Create React App and the functionality it supports. It was important for us to have our application built and ready to go to give us room to iterate and explore the real depths of Create React App, so now that we're ready to go, we can have a lot more fun playing around with things!</p>


            </article>

            
        </section>
    </div>



  </body></html>