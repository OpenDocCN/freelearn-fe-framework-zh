- en: App Bars - The Top Level of Every Page
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: App Bars - 每个页面的顶层
- en: 'In this chapter, you''ll learn about the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Fixed position
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定位置
- en: Hide on scroll
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动时隐藏
- en: Toolbar abstraction
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具栏抽象
- en: With navigation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带导航
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: App Bars are the anchor point of any Material-UI application. They provide context
    and are usually always visible as the user navigates around the application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: App Bars 是任何 Material-UI 应用的锚点。它们提供上下文，并且通常在用户在应用程序中导航时始终可见。
- en: Fixed position
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固定位置
- en: You probably want your `AppBar` component to stay visible at all times. By using
    `fixed` positioning, `AppBar` components remain visible even as the user scrolls
    down the page.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望你的`AppBar`组件始终可见。通过使用`fixed`定位，`AppBar`组件即使在用户滚动页面时也保持可见。
- en: How to do it...
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'You can use the `fixed` value of the `position` property. Here''s how you do
    it:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`position`属性的`fixed`值。以下是实现方法：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s what the resulting `AppBar` component looks like:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果`AppBar`组件的样子：
- en: '![](img/a156389b-c1fe-4189-9a08-e7eabfe3aa52.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a156389b-c1fe-4189-9a08-e7eabfe3aa52.png)'
- en: How it works...
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If you scroll down, you''ll see how the `AppBar` component stays *fixed*, and
    the content scrolls behind it. Here''s what it looks like if you scroll to the
    bottom of the page in this example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向下滚动，你会看到`AppBar`组件如何保持*固定*，并且内容在其后面滚动。以下是在本例中滚动到页面底部时的样子：
- en: '![](img/9f5deb3f-b985-404c-be06-bbd933858303.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f5deb3f-b985-404c-be06-bbd933858303.png)'
- en: The `position` property defaults to `fixed`. However, explicitly setting this
    property can help readers better understand your code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`position`属性的默认值是`fixed`。然而，明确设置此属性可以帮助读者更好地理解你的代码。'
- en: There's more...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When the screen in this example first loads, some of the content is hidden behind
    the `AppBar` component. This is because the position is fixed and it has a higher
    `z-index` value than the regular content. This is expected, so that when you scroll,
    the regular content goes behind the `AppBar` component. The solution is to add
    a top margin to your content. The problem is that you don't necessarily know the
    height of the `AppBar`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当本例中的屏幕首次加载时，一些内容被隐藏在`AppBar`组件后面。这是因为位置是固定的，并且它比常规内容的`z-index`值更高。这是预期的，这样当滚动时，常规内容就会在`AppBar`组件后面。解决方案是为你的内容添加一个顶部边距。问题是，你并不一定知道`AppBar`的高度。
- en: You could just set a value that looks good. A better solution is to use the
    `toolbar mixin` styles. You can access this `mixin` object by making `styles`
    a function that returns an object. Then, you'll have access to the theme argument,
    which has a `toolbar mixin` object.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以设置一个看起来不错的值。更好的解决方案是使用`toolbar mixin`样式。你可以通过将`styles`设置为返回对象的函数来访问这个`mixin`对象。然后，你将能够访问主题参数，它包含一个`toolbar
    mixin`对象。
- en: 'Here''s what `styles` should be changed to:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`styles`应该更改的样子：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The new style that''s added is `toolbarMargin`. Notice that this is using the
    value from `theme.mixins.toolbar`, which is why you''re using a function now –
    so that you can access `theme`. Here''s what the `theme.mixins.toolbar` value
    looks like:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 新增的样式是`toolbarMargin`。注意，这使用的是来自`theme.mixins.toolbar`的值，这就是你现在为什么使用函数的原因——这样你就可以访问`theme`。以下是`theme.mixins.toolbar`的值：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The last step is to add a `<div>` element to the content underneath the `AppBar` component
    where this new `toolbarMargin` style can be applied:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在`AppBar`组件下方的`<div>`元素中添加一个元素，以便可以应用这个新的`toolbarMargin`样式：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, the beginning of the content is no longer hidden by the `AppBar` component
    when the screen first loads:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当屏幕首次加载时，内容的开头不再被`AppBar`组件隐藏：
- en: '![](img/55e859af-3b94-4063-ba3c-04efb17641f3.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55e859af-3b94-4063-ba3c-04efb17641f3.png)'
- en: See also
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Guide to CSS positioning: [https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Positioning](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Positioning)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS 定位指南：[https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Positioning](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Positioning)
- en: '`AppBar` demos: [https://material-ui.com/demos/app-bar/](https://material-ui.com/demos/app-bar/)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppBar` 演示：[https://material-ui.com/demos/app-bar/](https://material-ui.com/demos/app-bar/)'
- en: '`AppBar` API documentation: [https://material-ui.com/api/app-bar/](https://material-ui.com/api/app-bar/)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppBar` API 文档：[https://material-ui.com/api/app-bar/](https://material-ui.com/api/app-bar/)'
- en: '`Toolbar` API documentation: [https://material-ui.com/api/toolbar/](https://material-ui.com/api/toolbar/)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Toolbar` API 文档：[https://material-ui.com/api/toolbar/](https://material-ui.com/api/toolbar/)'
- en: Hide on scroll
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滚动时隐藏
- en: If you have a lot of content on your screen that requires the user to scroll
    vertically, the App Bar could be a distraction. One solution is to hide the `AppBar`
    component while the user is scrolling down.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你屏幕上有大量需要用户垂直滚动的内 容，App Bar 可能会分散用户的注意力。一种解决方案是在用户向下滚动时隐藏 `AppBar` 组件。
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To hide the `AppBar` component while the user is scrolling down, you have to
    know when the user is scrolling. This requires listening to the `scroll` event
    on the `window` object. You can implement a component that listens to this event
    and hides the `AppBar` component while scrolling. Here''s how it''s done:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要在用户向下滚动时隐藏 `AppBar` 组件，你必须知道用户何时在滚动。这需要监听 `window` 对象上的 `scroll` 事件。你可以实现一个组件来监听此事件，并在滚动时隐藏
    `AppBar` 组件。以下是实现方式：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you first load the screen, the toolbar and content appear as usual:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你首次加载屏幕时，工具栏和内容会像往常一样显示：
- en: '![](img/07cecedf-4bfe-4a7a-baed-a3458305b284.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/07cecedf-4bfe-4a7a-baed-a3458305b284.png)'
- en: 'When you scroll down, the `AppBar` component disappears, allowing more space
    for the content to be viewed. Here''s what the screen looks like when you scroll
    to the very bottom:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向下滚动时，`AppBar` 组件消失，为查看更多内容腾出空间。以下是当你滚动到屏幕底部时的屏幕外观：
- en: '![](img/f9b68129-30bf-4824-9732-46997c139b29.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f9b68129-30bf-4824-9732-46997c139b29.png)'
- en: The `AppBar` component will reappear as soon as you start scrolling back up.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始向上滚动，`AppBar` 组件就会立即重新出现。
- en: How it works...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Let''s take a look at the `state` method and the `onScroll()` method of the
    `ScrolledAppBar` component:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `ScrolledAppBar` 组件的 `state` 方法 和 `onScroll()` 方法：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When the component mounts, the `onScroll()` method is added as a listener to
    the `scroll` event on the `window` object. The `scrolling` state is a Boolean
    value that hides the `AppBar` component when true. The `scrollTop` state is the
    position of the previous scroll event. The `onScroll()` method figures out whether the
    user is scrolling by checking if the new scroll position is greater than the last
    scroll position.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件挂载时，`onScroll()` 方法被添加为监听 `window` 对象上的 `scroll` 事件的监听器。`scrolling` 状态是一个布尔值，当为
    true 时隐藏 `AppBar` 组件。`scrollTop` 状态是前一个滚动事件的位置。`onScroll()` 方法通过检查新的滚动位置是否大于最后一个滚动位置来确定用户是否在滚动。
- en: 'Next, let''s take a look at the `Fade` component that''s used to hide the `AppBar` component
    when scrolling, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看用于在滚动时隐藏 `AppBar` 组件的 `Fade` 组件，如下所示：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `in` property tells the `Fade` component to fade its children, `in`, when
    the value is true. In this example, the condition is true when the `scrolling`
    state is false.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`in` 属性告诉 `Fade` 组件在值为 true 时淡入其子组件，`in`。在这个例子中，当 `scrolling` 状态为 false 时，条件为
    true。'
- en: There's more...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Instead of fading the `AppBar` component in and out when the user scrolls,
    you can use a different effect. For example, the following code block demonstrates
    what it would look like if you wanted to use the `Grow` effect:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户滚动时，你不必淡入淡出 `AppBar` 组件，可以使用不同的效果。例如，以下代码块演示了如果你想使用 `Grow` 效果会是什么样子：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See also
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`Fade` API documentation: [https://material-ui.com/api/fade/](https://material-ui.com/api/fade/)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fade` API 文档：[https://material-ui.com/api/fade/](https://material-ui.com/api/fade/)'
- en: '`Grow` API documentation: [https://material-ui.com/api/grow/](https://material-ui.com/api/grow/)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Grow` API 文档：[https://material-ui.com/api/grow/](https://material-ui.com/api/grow/)'
- en: '`Slide` API documentation: [https://material-ui.com/api/slide/](https://material-ui.com/api/slide/)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slide` API 文档：[https://material-ui.com/api/slide/](https://material-ui.com/api/slide/)'
- en: Toolbar abstraction
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具栏抽象
- en: Toolbar code can get verbose if you have to render toolbars in several places.
    To address this, you can create your own `Toolbar` component that encapsulates
    the content patterns of toolbars, making it easier to render `AppBar` components
    in several places.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在多个地方渲染工具栏，工具栏代码可能会变得冗长。为了解决这个问题，你可以创建自己的 `Toolbar` 组件，该组件封装了工具栏的内容模式，使得在多个地方渲染
    `AppBar` 组件更容易。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s assume that your app renders `AppBar` components on several screens.
    Each `AppBar` component also renders `Menu` and `title` to the left, as well as `Button`
    to the right. Here''s how you can implement your own `AppBar` component so that
    it''s easier to use on several screens:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的应用在多个屏幕上渲染 `AppBar` 组件。每个 `AppBar` 组件也会将 `Menu` 和 `title` 渲染到左侧，以及 `Button`
    渲染到右侧。以下是如何实现你自己的 `AppBar` 组件，以便在多个屏幕上更容易使用：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here''s what the resulting toolbar looks like:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最终工具栏的外观：
- en: '![](img/e71a60e7-f95f-4558-8a8b-ca15580fac86.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e71a60e7-f95f-4558-8a8b-ca15580fac86.png)'
- en: 'And here''s what the menu looks like when the user clicks on the menu button
    beside the title:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击标题旁边的菜单按钮时，菜单看起来是这样的：
- en: '![](img/e2b2aadd-4b61-47c3-8664-0864502e8b92.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e2b2aadd-4b61-47c3-8664-0864502e8b92.png)'
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start by looking at the `render()` method of the `MyToolbar` component,
    as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看 `MyToolbar` 组件的 `render()` 方法开始，如下所示：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is where the `AppBar` component and the `Toolbar` components from Material-UI
    are rendered. A `Fragment` component is used because two elements are returned:
    the `AppBar` component and the `<div>` element that sets the top margin for the
    page content. Within the toolbar, you have the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `AppBar` 组件和 Material-UI 中的 `Toolbar` 组件被渲染的地方。使用了一个 `Fragment` 组件，因为返回了两个元素：`AppBar`
    组件和设置页面内容顶部边距的 `<div>` 元素。在工具栏中，您有以下内容：
- en: The menu button that displays the menu when clicked
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击时显示菜单的菜单按钮
- en: The menu itself
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单本身
- en: The title
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题
- en: The right-side button
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右侧按钮
- en: 'From the `MyToolbar` properties, there are two components that `render()` uses:
    `MenuItems` and `RightButton`. In addition to the `title` prop, these are the
    parts of the `AppBar` component that you want to customize. The approach here
    is to define default values for these properties so that the `AppBar` component
    can be rendered:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `MyToolbar` 属性中，`render()` 方法使用了两个组件：`MenuItems` 和 `RightButton`。除了 `title`
    属性外，这些是您想要自定义的 `AppBar` 组件的部分。这里的做法是为这些属性定义默认值，以便 `AppBar` 组件可以被渲染：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can pass custom values to these properties when you render `MyToolbar`.
    The defaults used here could be the values used for the home screen, for example.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当您渲染 `MyToolbar` 时，可以向这些属性传递自定义值。这里使用的默认值可能是用于主页的值。
- en: You don't actually have to provide default values for these properties. But
    if you do, for the home screen, say, then it's easier for other developers to
    look at your code and understand how it works.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您实际上不必为这些属性提供默认值。但如果您提供了，比如对于主页，那么其他开发者查看您的代码并理解其工作方式会更容易。
- en: There's more...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Let''s try setting some custom menu items and right-side buttons, using the
    `MenuItems` and `RightButton` properties respectively:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试设置一些自定义菜单项和右侧按钮，分别使用 `MenuItems` 和 `RightButton` 属性：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is what the toolbar looks like when rendered:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是渲染后的工具栏看起来：
- en: '![](img/e36dd2f7-d322-4dc7-9e16-1f85e4ee534a.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e36dd2f7-d322-4dc7-9e16-1f85e4ee534a.png)'
- en: 'Here is what the menu looks like with the custom menu options:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有自定义菜单选项的菜单看起来：
- en: '![](img/3810a4f8-b578-4827-9db6-ec8c9ab86ff6.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3810a4f8-b578-4827-9db6-ec8c9ab86ff6.png)'
- en: The values that you're passing to `MenuItems` and `RightButton` are functions
    that return React elements. These functions are actually functional components
    that you're creating on the fly.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您传递给 `MenuItems` 和 `RightButton` 的值是返回 React 元素的函数。这些函数实际上是您即时创建的功能组件。
- en: See also
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`AppBar` demos: [https://material-ui.com/demos/app-bar/](https://material-ui.com/demos/app-bar/)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppBar` 演示：[https://material-ui.com/demos/app-bar/](https://material-ui.com/demos/app-bar/)'
- en: '`AppBar` API documentation: [https://material-ui.com/api/app-bar/](https://material-ui.com/api/app-bar/)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppBar` API 文档：[https://material-ui.com/api/app-bar/](https://material-ui.com/api/app-bar/)'
- en: '`Toolbar` API documentation: [https://material-ui.com/api/toolbar/](https://material-ui.com/api/toolbar/)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Toolbar` API 文档：[https://material-ui.com/api/toolbar/](https://material-ui.com/api/toolbar/)'
- en: With navigation
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有导航
- en: Material-UI apps are typically made up of several pages that are linked together
    using a router, such as `react-router`. Each page renders an App Bar that has
    information specific to that page. This is one example of when the abstraction
    that you created in the *Toolbar abstraction* recipe comes in handy.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Material-UI 应用程序通常由几个页面组成，这些页面通过路由器（如 `react-router`）相互链接。每个页面渲染一个具有特定页面信息的
    App Bar。这是在 *Toolbar 抽象* 菜谱中创建的抽象的一个用例。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s say that you''re building an app that has three pages. On each page,
    you want to `render` an App Bar with the `title` prop of the page. Furthermore,
    the menu in the App Bar should contain links to the three pages. Here''s how to
    do it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在构建一个有三个页面的应用程序。在每个页面上，您想要 `render` 一个具有页面 `title` 属性的 App Bar。此外，AppBar
    中的菜单应包含指向三个页面的链接。以下是实现方法：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here''s what you''ll see when you first load the app:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当您首次加载应用程序时，您会看到以下内容：
- en: '![](img/e87e7444-6064-42f3-87e4-a8e5483d0d6e.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e87e7444-6064-42f3-87e4-a8e5483d0d6e.png)'
- en: 'Here''s what the menu in the App Bar looks like when it''s opened:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当 App Bar 被打开时，菜单看起来是这样的：
- en: '![](img/9cdc9f8d-cf58-42df-9c7c-8cd9eb71e8ca.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9cdc9f8d-cf58-42df-9c7c-8cd9eb71e8ca.png)'
- en: 'Try clicking on Page 2; here''s what you should see:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试点击第 2 页；您应该看到以下内容：
- en: '![](img/7b63d92c-b7a9-4243-bf30-d02e94042128.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b63d92c-b7a9-4243-bf30-d02e94042128.png)'
- en: The title of the App Bar has changed to reflect the title of the page, and the
    content of the page has also changed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: App Bar 的标题已更改，以反映页面的标题，页面的内容也发生了变化。
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start by taking a look at the Routes  component that define the pages
    in your app, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看定义您应用中页面的 Routes 组件，如下所示：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Each `Route` component (from the `react-router` package) corresponds to a page
    in your app. They have a `path` property that matches the path in the browser
    address bar. When there's a match, this Routes component' content is rendered.
    For example, when the path is `/page3`, the content for the `Route` component
    where `path="/page3"` is rendered.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `Route` 组件（来自 `react-router` 包）对应您应用中的一个页面。它们有一个 `path` 属性，与浏览器地址栏中的路径匹配。当有匹配时，此
    Routes 组件的内容会被渲染。例如，当路径是 `/page3` 时，会渲染 `path="/page3"` 的 `Route` 组件的内容。
- en: Each `Route` component also defines a `render()` function. This is called when
    its `path` is matched and the returned content is rendered. The Routes component
    in your app each render `MyToolbar` with a different value for the `title` prop.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `Route` 组件还定义了一个 `render()` 函数。当其 `path` 匹配时，会调用此函数，并渲染返回的内容。您应用中的 Routes
    组件每个都会以不同的 `title` 属性值渲染 `MyToolbar`。
- en: 'Next, let''s take a look at the menu items that make up the `MenuItems` default
    property value, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看组成 `MenuItems` 默认属性值的菜单项，如下所示：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Each of these `MenuItems` properties is a link that points to each of the Routes
    component declared by your app. The `MenuItem` component accepts a `component`
    property that is used to render the link. In this example, you're passing it the
    `Link` component from the `react-router-dom` package. The `MenuItem` component
    will forward any additional properties to the `Link` component, which means that
    you can can pass the `to` property to the `MenuItem` component and it's as though
    you're passing it to the `Link` component.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `MenuItems` 属性中的每一个都是一个指向您应用中声明的每个 Routes 组件的链接。`MenuItem` 组件接受一个 `component`
    属性，用于渲染链接。在这个例子中，您传递了来自 `react-router-dom` 包的 `Link` 组件。`MenuItem` 组件会将任何额外的属性传递给
    `Link` 组件，这意味着您可以将 `to` 属性传递给 `MenuItem` 组件，这就像您将其传递给 `Link` 组件一样。
- en: There's more...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Most of the time, the screens that make up your app will follow the same pattern.
    Rather than have repetitive code in the `render` property of your routes, you
    can create a higher-order function that accepts arguments for the unique parts
    of the screen and returns a new component that can be used by the `render` prop.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，组成您应用屏幕的屏幕将遵循相同的模式。您不必在路由的 `render` 属性中有重复的代码，可以创建一个高阶函数，该函数接受屏幕独特部分的参数，并返回一个可以由
    `render` 属性使用的新组件。
- en: 'In this example, the only two pieces of data that are unique to each screen
    are the title and the content text. Here''s a generic function that builds a new
    functional component that can be used with every `Route` component in the app:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每个屏幕唯一的数据只有标题和内容文本。以下是一个通用函数，它构建了一个新的函数组件，可以用于应用中的每个 `Route` 组件：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To use this function, call it in the `render` property, such as in the following
    code block:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此函数，请在 `render` 属性中调用它，如下代码块所示：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now you have a clear separation of the static `screen` structure that stays
    the same for every screen in the app, and the pieces that are unique to each screen
    that passed as arguments to the `screen()` function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经清楚地分离了静态的 `screen` 结构，它在应用中的每个屏幕上都是相同的，以及作为 `screen()` 函数参数传递的每个屏幕的独特部分。
- en: See also
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'React Router documentation: [https://reacttraining.com/react-router/](https://reacttraining.com/react-router/)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Router 文档：[https://reacttraining.com/react-router/](https://reacttraining.com/react-router/)
- en: '`AppBar` demos: [https://material-ui.com/demos/app-bar/](https://material-ui.com/demos/app-bar/)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppBar` 示例：[https://material-ui.com/demos/app-bar/](https://material-ui.com/demos/app-bar/)'
- en: '`AppBar` API documentation: [https://material-ui.com/api/app-bar/](https://material-ui.com/api/app-bar/)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppBar` API 文档：[https://material-ui.com/api/app-bar/](https://material-ui.com/api/app-bar/)'
