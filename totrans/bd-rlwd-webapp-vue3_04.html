<html><head></head><body>
<div id="_idContainer035">
<h1 class="chapter-number" id="_idParaDest-65"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-66"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.2.1">Creating the Marvel Explorer App</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Letâ€™s build an app thatâ€™s a bit more advanced, using a third-party API to feed it with data. </span><span class="koboSpan" id="kobo.3.2">I hope you like comics, because we will build an explorer on the Marvel Comics API, and I will try to squeeze in some heroic puns. </span><span class="koboSpan" id="kobo.3.3">Weâ€™ll explore adding different routes and add a bit of abstraction to make better use of writing </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">our code.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Weâ€™ll cover the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">this chapter:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.7.1">Getting started</span></span></li>
<li><span class="koboSpan" id="kobo.8.1">Retrieving data from </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">the API</span></span></li>
<li><span class="koboSpan" id="kobo.10.1">Routing in a </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">single-page application</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Writing and </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">using composables</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Searching for and </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">handling data</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">User-friendly </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">error handling</span></span></li>
</ul>
<h1 id="_idParaDest-67"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.18.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.19.1">In this chapter, weâ€™ll replace </span><strong class="bold"><span class="koboSpan" id="kobo.20.1">node package manager</span></strong><span class="koboSpan" id="kobo.21.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.22.1">npm</span></strong><span class="koboSpan" id="kobo.23.1">) with </span><strong class="bold"><span class="koboSpan" id="kobo.24.1">performant npm</span></strong><span class="koboSpan" id="kobo.25.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.26.1">pnpm</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">): </span></span><a href="https://pnpm.io"><span class="No-Break"><span class="koboSpan" id="kobo.28.1">https://pnpm.io</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.29.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">We need to register at </span><a href="https://developer.marvel.com/"><span class="koboSpan" id="kobo.31.1">https://developer.marvel.com/</span></a><span class="koboSpan" id="kobo.32.1"> to retrieve an API key. </span><span class="koboSpan" id="kobo.32.2">Weâ€™ll add </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">Tailwind CSS</span></strong><span class="koboSpan" id="kobo.34.1"> (</span><a href="https://tailwindcss.com/"><span class="koboSpan" id="kobo.35.1">https://tailwindcss.com/</span></a><span class="koboSpan" id="kobo.36.1">) to apply styling to this app </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">In this chapter we introduce routes using the official router for Vue.js </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">applications: </span></span><a href="https://router.vuejs.org/"><span class="No-Break"><span class="koboSpan" id="kobo.40.1">https://router.vuejs.org/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.41.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">The complete code for this chapter is available </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">at </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/04.marvel"><span class="No-Break"><span class="koboSpan" id="kobo.44.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/04.marvel</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.45.1">.</span></span></p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.46.1">Getting started with our new project</span></h1>
<p><span class="koboSpan" id="kobo.47.1">In order to get started, we need</span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.48.1"> an API key. </span><span class="koboSpan" id="kobo.48.2">If you go to </span><a href="https://developer.marvel.com/"><span class="koboSpan" id="kobo.49.1">https://developer.marvel.com/</span></a><span class="koboSpan" id="kobo.50.1"> and select </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">Get a Key</span></strong><span class="koboSpan" id="kobo.52.1"> from the menu, you will need to register</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.53.1"> for a free account. </span><span class="koboSpan" id="kobo.53.2">Afterward, you will be redirected to the developer portal, where you create a key to interact with the API. </span><span class="koboSpan" id="kobo.53.3">Make sure to note the public and </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">private keys.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">For our example, we will access the API from localhost, so you need to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">localhost</span></strong><span class="koboSpan" id="kobo.57.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">127.0.0.1</span></strong><span class="koboSpan" id="kobo.59.1"> to the list of </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">authorized referrers.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.61.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.62.1">If you want to deploy this app to the web, you will need to make sure to add the corresponding URL of the appâ€™s address there as well, but the deployment step is not covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">Iâ€™d like to point out the documentation, which youâ€™ll find under </span><strong class="bold"><span class="koboSpan" id="kobo.65.1">Interactive Documentation</span></strong><span class="koboSpan" id="kobo.66.1">. </span><span class="koboSpan" id="kobo.66.2">I recommend playing around with it for a bit to get a sense of our </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">data provider.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">Letâ€™s start a </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">new project!</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.70.1">
npm init vue@latest</span></pre> <p><span class="koboSpan" id="kobo.71.1">Hit </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">y</span></strong><span class="koboSpan" id="kobo.73.1"> to proceed, choose </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">vue-marvel-explorer</span></strong><span class="koboSpan" id="kobo.75.1"> as the project name, and select the options shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">following image:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.77.1"><img alt="Figure 4.1 â€“ The setup configuration for the Marvel Explorer app" src="image/B19563_04_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.78.1">Figure 4.1 â€“ The setup configuration for the Marvel Explorer app</span></p>
<p><span class="koboSpan" id="kobo.79.1">After following the instructions</span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.80.1"> to install the dependencies we can get </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">to work!</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">Letâ€™s install our projectâ€™s dependencies using pnpm this time. </span><span class="koboSpan" id="kobo.82.2">This is an alternative package manager for node that has some benefits over npm, such as better storage management of packages, which results in increased installation speed and reduced network requests. </span><span class="koboSpan" id="kobo.82.3">If your internet connection</span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.83.1"> is less than optimal, pnpm has got your back! </span><span class="koboSpan" id="kobo.83.2">You can read the installation guide here (</span><a href="https://pnpm.io/installation"><span class="koboSpan" id="kobo.84.1">https://pnpm.io/installation</span></a><span class="koboSpan" id="kobo.85.1">). </span><span class="koboSpan" id="kobo.85.2">The commands are similar to npm, so it should be very easy to get up </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">to speed.</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">Navigate to your projectâ€™s folder and type </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">pnpm install</span></strong><span class="koboSpan" id="kobo.89.1"> (instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">npm install</span></strong><span class="koboSpan" id="kobo.91.1">). </span><span class="koboSpan" id="kobo.91.2">The neat thing is that every future installation of the same package will reference the already installed local cache, which saves a ton of bandwidth </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">and time.</span></span></p>
<p><span class="koboSpan" id="kobo.93.1">Weâ€™ll install tailwind on the project as well, revisiting the steps from the Weather app, using pnpm, an alternative to npm, aimed at optimizing </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">node_modules</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.95.1"> management:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.96.1">
pnpm install -D tailwindcss postcss autoprefixerpnpm dlx tailwindcss init -p</span></pre>
<p><span class="koboSpan" id="kobo.97.1">Letâ€™s update the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">tailwind.config.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.99.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.100.1">
/** @type {import('tailwindcss').Config} */export default {
Â Â purge: ['./index.html', './src/**/*.{vue,js,ts,jsx,tsx}'],
Â Â content: ['./src/**/*.{vue,js,ts,jsx,tsx}'],
Â Â theme: {
Â Â Â Â extend: {},
Â Â },
Â Â plugins: [],
}</span></pre>
<p><span class="koboSpan" id="kobo.101.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">style.css</span></strong><span class="koboSpan" id="kobo.103.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">./</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">src</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.106.1"> folder:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.107.1">
@tailwind base;@tailwind components;
@tailwind utilities;</span></pre>
<p><span class="koboSpan" id="kobo.108.1">And finally, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">./src/main.ts</span></strong><span class="koboSpan" id="kobo.110.1"> file to import the CSS file</span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.111.1"> into the app (note that this file contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">router initialization):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.113.1">
import { createApp } from 'vue'import App from './App.vue'
import router from './router'
</span><strong class="bold"><span class="koboSpan" id="kobo.114.1">import './style.css'</span></strong><span class="koboSpan" id="kobo.115.1">
const app = createApp(App)
app.use(router)
app.mount('#app')</span></pre>
<p><span class="koboSpan" id="kobo.116.1">If you run the development server with </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">pnpm run dev</span></strong><span class="koboSpan" id="kobo.118.1">, youâ€™ll see that the demo app added an example route, allowing you to navigate between a Home and About view. </span><span class="koboSpan" id="kobo.118.2">Close the dev server, and letâ€™s open the project in the </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">code editor.</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">You can remove the components that the default Vue installation added to clean up your project a bit. </span><span class="koboSpan" id="kobo.120.2">If you are unsure, you can always refer to the GitHub repository. </span><span class="koboSpan" id="kobo.120.3">The link can be found at the </span><em class="italic"><span class="koboSpan" id="kobo.121.1">Technical </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.122.1">requirements</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.123.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">Rename the </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">.env.example</span></strong><span class="koboSpan" id="kobo.126.1"> file to .</span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">env</span></strong><span class="koboSpan" id="kobo.128.1"> and make sure to insert the secrets from the Marvel </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">Developer portal:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.130.1">
VITE_APP_MARVEL_API_PUBLIC=YOUR_PUBLIC_KEY_HEREVITE_APP_MARVEL_API_SECRET=YOUR_SECRET_HERE</span></pre>
<p><span class="koboSpan" id="kobo.131.1">Variables from a </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">.env</span></strong><span class="koboSpan" id="kobo.133.1"> file that are prefixed with </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">VITE_APP_</span></strong><span class="koboSpan" id="kobo.135.1"> are automatically passed to and available in your application on a pre-defined </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">import.meta.env</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.137.1"> object.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.138.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.139.1">I want to stress again that sharing secrets is not a best practice in production-like environments. </span><span class="koboSpan" id="kobo.139.2">Youâ€™d normally use something like an authorization broker to make sure that the API only receives trusted requests. </span><span class="koboSpan" id="kobo.139.3">In a way, weâ€™ve done this by defining the request domains in the Marvel API configuration. </span><span class="koboSpan" id="kobo.139.4">Typically, </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">localhost</span></strong><span class="koboSpan" id="kobo.141.1"> or its equivalent, </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">127.0.0.1</span></strong><span class="koboSpan" id="kobo.143.1">, is not something you would see in a production </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">environment either!</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">This concludes our environment</span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.146.1"> set up. </span><span class="koboSpan" id="kobo.146.2">Weâ€™ll now move forward with connecting these settings to </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">our applicat</span><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.148.1">ion.</span></span></p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.149.1">The Superhero connection</span></h1>
<p><span class="koboSpan" id="kobo.150.1">We want to retrieve data</span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.151.1"> from the Marvel Comics API from different components</span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.152.1"> in our application. </span><span class="koboSpan" id="kobo.152.2">A good pattern for doing this is by creating a Vue composable. </span><span class="koboSpan" id="kobo.152.3">A Vue composable is a proven pattern for using and reusing logic throughout your application. </span><span class="koboSpan" id="kobo.152.4">Weâ€™ll create a folder called </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">composables</span></strong><span class="koboSpan" id="kobo.154.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">src</span></strong><span class="koboSpan" id="kobo.156.1"> folder and create a file </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">marvelApi.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">You can import the types from the example </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">repository (</span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/src/types/marvel.ts"><span class="No-Break"><span class="koboSpan" id="kobo.162.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/src/types/marvel.ts</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.163.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">These types are mainly contracts with the API. </span><span class="koboSpan" id="kobo.164.2">Feel free to take a look at them. </span><span class="koboSpan" id="kobo.164.3">I created them by ingesting the results from the API and defining </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">the types.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">Weâ€™ll start with an asynchronous function</span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.167.1"> that fetches the data from the API from the comics</span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.168.1"> endpoint and returns a promise of the response. </span><span class="koboSpan" id="kobo.168.2">Weâ€™re going to expand the functionality gradually. </span><span class="koboSpan" id="kobo.168.3">Add a new composable function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">useComics</span></strong><span class="koboSpan" id="kobo.170.1"> to the file and donâ€™t forget to import </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">the type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.172.1">
import type { Comics } from '@/types/marvel'export const useComics = async (): Promise&lt;Comics&gt; =&gt; {
Â Â const apiKey = import.meta.env.VITE_APP_MARVEL_API_PUBLIC;
Â Â const MARVEL_API = `//gateway.marvel.com/v1/public/
Â Â const API_SIGN = apikey=${apiKey}`
Â Â const requestURI = `${MARVEL_API}/comics?${API_SIGN}`
Â Â const res = await fetch(requestURI);
Â Â const jsonRes = await res.json();
Â Â return jsonRes.data;
}</span></pre>
<p><span class="koboSpan" id="kobo.173.1">Now we can wire the API call to the user interface. </span><span class="koboSpan" id="kobo.173.2">We are going to create our component to display the data</span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.174.1"> from the endpoint. </span><span class="koboSpan" id="kobo.174.2">Create a new Vue component in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">src/components</span></strong><span class="koboSpan" id="kobo.176.1"> folder called </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">ComicsOverview.vue</span></strong><span class="koboSpan" id="kobo.178.1">. </span><span class="koboSpan" id="kobo.178.2">Weâ€™ll start</span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.179.1"> with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">script</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.181.1">tag contents:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.182.1">
&lt;script lang="ts" setup&gt;import { ref, onMounted } from "vue";
import type { Ref } from "vue";
import { useComics } from "@/composables/marvelApi";
import type { Comic } from "@/types/marvel";
const isLoading: Ref&lt;boolean&gt; = ref(false);
const data: Ref&lt;Comic[] | undefined&gt; = ref();
const getComics = async () =&gt; {
Â Â isLoading.value = true;
Â Â const comics = await useComics();
Â Â data.value = comics.results;
Â Â isLoading.value = false;
};
onMounted(async () =&gt; {
Â Â await getComics();
});
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.183.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">script</span></strong><span class="koboSpan" id="kobo.185.1"> block is very similar to the weather app from </span><a href="B19563_04.xhtml#_idTextAnchor092"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.186.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.187.1">. </span><span class="koboSpan" id="kobo.187.2">Weâ€™re requesting data when the component gets mounted, and weâ€™ll track the state using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">isLoading</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.189.1"> variable.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">In the template</span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.191.1"> of the same file, weâ€™ll add</span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.192.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">following contents:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.194.1">
&lt;template&gt;Â Â &lt;div&gt;
Â Â Â Â &lt;div v-if="isLoading"&gt;&lt;p&gt;Loading comicsâ€¦&lt;/p&gt;&lt;/div&gt;
Â Â Â Â &lt;div v-if="data &amp;&amp; !isLoading"&gt;
Â Â Â Â Â Â &lt;div
Â Â Â Â Â Â Â Â class="grid grid-flow-row grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-4"
Â Â Â Â Â Â &gt;
Â Â Â Â Â Â Â Â &lt;div :key="comic.id" v-for="comic in data"&gt;{{ comic.title }}&lt;/div&gt;
Â Â Â Â Â Â &lt;/div&gt;
Â Â Â Â &lt;/div&gt;
Â Â &lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.195.1">You can quickly see the result by temporarily importing the component into </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">App.vue</span></strong><span class="koboSpan" id="kobo.197.1"> and loading it in the template. </span><span class="koboSpan" id="kobo.197.2">A slight difference here is that weâ€™ve abstracted the actual fetch to the composition, which makes the code of the component a bit cleaner and makes the fetch </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">more reusable.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">Now that our data is coming in, weâ€™re going to polish the component a bit. </span><span class="koboSpan" id="kobo.199.2">Letâ€™s create a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">LoadingIndicator.vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.201.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.202.1">
&lt;script setup lang="ts"&gt;const props = defineProps&lt;{
Â Â text?: string;
}&gt;();
&lt;/script&gt;
&lt;template&gt;
Â Â &lt;div
Â Â Â Â class="flex flex-col items-center justify-center p-4 pt-16 min-h-min min-w-screen"
Â Â &gt;
Â Â Â Â &lt;div v-if="text" class="mb-4"&gt;
Â Â Â Â Â Â {{ text }}
Â Â Â Â &lt;/div&gt;
Â Â Â Â &lt;div class="flex space-x-2 animate-pulse"&gt;
Â Â Â Â Â Â &lt;div class="w-3 h-3 bg-gray-500 rounded-full"&gt;&lt;/div&gt;
Â Â Â Â Â Â &lt;div class="w-3 h-3 bg-gray-500 rounded-full"&gt;&lt;/div&gt;
Â Â Â Â Â Â &lt;div class="w-3 h-3 bg-gray-500 rounded-full"&gt;&lt;/div&gt;
Â Â Â Â &lt;/div&gt;
Â Â &lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.203.1">We can import</span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.204.1"> it to the component</span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.205.1"> and then use it to replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">&lt;div v-if="isLoading"&gt;&lt;p&gt;Loading comicsâ€¦&lt;/p&gt;&lt;/div&gt;</span></strong><span class="koboSpan" id="kobo.207.1"> element, </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.209.1">
&lt;script lang="ts" setup&gt;import { ref, onMounted } from "vue";
import type { Ref } from "vue";
import { useComics } from "@/composables/marvelApi";
import type { Comic } from "@/types/marvel";
</span><strong class="bold"><span class="koboSpan" id="kobo.210.1">import LoadingIndicator from "./LoadingIndicator.vue";</span></strong><span class="koboSpan" id="kobo.211.1">
//â€¦ abbreviated
&lt;/script&gt;
&lt;template&gt;
Â Â &lt;div&gt;
Â Â Â Â </span><strong class="bold"><span class="koboSpan" id="kobo.212.1">&lt;LoadingIndicator v-if="isLoading" text="Loading comics..."/&gt;</span></strong><span class="koboSpan" id="kobo.213.1">
Â Â Â Â // â€¦ abbreviated
Â Â &lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.214.1">We do this to create more consistency when using recurring user interface patterns. </span><span class="koboSpan" id="kobo.214.2">Again, this is one of the strengths of a </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">component-based architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.216.1">We can also create the visual representation</span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.217.1"> of a comic. </span><span class="koboSpan" id="kobo.217.2">Weâ€™re going to apply the abstractions</span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.218.1"> right away. </span><span class="koboSpan" id="kobo.218.2">In practice, it happens more often that refactors occur while progressing on the code base. </span><span class="koboSpan" id="kobo.218.3">Itâ€™s tricky to predict what code will be reused beforehand, so donâ€™t hesitate to refactor early and often, when the need arises. </span><span class="koboSpan" id="kobo.218.4">In our case, though, we have a different goal to teach, so we wonâ€™t focus on the </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">refactoring part.</span></span></p>
<p><span class="koboSpan" id="kobo.220.1">Create a component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">CardView.vue</span></strong><span class="koboSpan" id="kobo.222.1"> that contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.224.1">
&lt;template&gt;Â Â Â Â &lt;article class="p-4 bg-white rounded-lg shadow-xl place-content-center text-slate-800"&gt;
Â Â Â Â &lt;header&gt;
Â Â Â Â Â Â Â Â &lt;h1 class="pb-5 text-lg font-semibold "&gt;</span><strong class="bold"><span class="koboSpan" id="kobo.225.1">&lt;slot name="header"&gt;&lt;/slot&gt;</span></strong><span class="koboSpan" id="kobo.226.1">&lt;/h1&gt;
Â Â Â Â &lt;/header&gt;
Â Â Â Â </span><strong class="bold"><span class="koboSpan" id="kobo.227.1">&lt;slot&gt;&lt;/slot&gt;</span></strong><span class="koboSpan" id="kobo.228.1">
Â Â Â Â &lt;/article&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.229.1">In this component, we are making</span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.230.1"> use of slots. </span><span class="koboSpan" id="kobo.230.2">Slots are placeholders for specific dynamic</span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.231.1"> content (components or text) that comes from the parent component. </span><span class="koboSpan" id="kobo.231.2">Slots are an excellent way to reuse templates and offer a lot of flexibility. </span><span class="koboSpan" id="kobo.231.3">Consider the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">LoadingIndicator</span></strong><span class="koboSpan" id="kobo.233.1"> component, which accepts only a text as a property. </span><span class="koboSpan" id="kobo.233.2">Restriction can be good, but sometimes you might prefer flexibility over constraint. </span><span class="koboSpan" id="kobo.233.3">Letâ€™s start to apply this </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">generic component.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">Weâ€™ll create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">ComicCard.vue</span></strong><span class="koboSpan" id="kobo.237.1"> component with the following </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">contents: </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.1-ComicCard.vue"><span class="No-Break"><span class="koboSpan" id="kobo.239.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.1-ComicCard.vue</span></span></a></p>
<p><span class="koboSpan" id="kobo.240.1">Letâ€™s break that component down, shall we? </span><span class="koboSpan" id="kobo.240.2">You should be familiar with most of the concepts, but I have managed to introduce a bit more. </span><span class="koboSpan" id="kobo.240.3">A particular addition is the </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">following line:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.242.1">
const lf = new Intl.ListFormat('en');</span></pre> <p><span class="koboSpan" id="kobo.243.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">Intl</span></strong><span class="koboSpan" id="kobo.245.1"> is a standardized namespace that deals with language-sensitive functions. </span><span class="koboSpan" id="kobo.245.2">In our case, we are setting up a list specific formatter in the English (</span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">en</span></strong><span class="koboSpan" id="kobo.247.1">) language and using it in the template to string together the list of creators. </span><span class="koboSpan" id="kobo.247.2">The list is provided as an array (that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">[â€œEvan Youâ€,</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.249.1">â€œSebastien Chopinâ€,</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.250.1">â€œAnthony Fuâ€]</span></strong><span class="koboSpan" id="kobo.251.1">). </span><span class="koboSpan" id="kobo.251.2">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">Intl</span></strong><span class="koboSpan" id="kobo.253.1"> formatter, the result is readable text that is specific to that language: </span><em class="italic"><span class="koboSpan" id="kobo.254.1">Evan You, Sebastien Chopin, and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.255.1">Anthony Fu!</span></em></span></p>
<p><span class="koboSpan" id="kobo.256.1">Weâ€™re using the computed values to create lists of characters for every comic (</span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">charactersList</span></strong><span class="koboSpan" id="kobo.258.1">) and the creators of every </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">comic (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">creatorsList</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.262.1">In the template, we see how we are using the slots in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">CardView</span></strong><span class="koboSpan" id="kobo.264.1"> component and filling it with our </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">own templates:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.266.1">
&lt;template&gt;Â Â &lt;CardView :data-testid="comic.id"&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.267.1">Â Â Â Â &lt;template v-slot:header&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.268.1">Â </span></strong><span class="koboSpan" id="kobo.269.1">Â Â Â Â Â {{ comic.title }}
</span><strong class="bold"><span class="koboSpan" id="kobo.270.1">Â Â Â Â &lt;/template&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.271.1">Â Â Â Â &lt;template v-slot:default&gt;</span></strong><span class="koboSpan" id="kobo.272.1">
Â Â Â Â Â Â &lt;img
Â Â Â Â Â Â Â Â class="aspect-[150/228] shadow-xl float-left mr-4"
Â Â Â Â Â Â Â Â :src="`${comic.thumbnail.path}.${comic.thumbnail.extension}`"
Â Â Â Â Â Â Â Â width="150"
Â Â Â Â Â Â /&gt;
Â Â Â Â Â Â //â€¦ abbreviated
</span><strong class="bold"><span class="koboSpan" id="kobo.273.1">Â Â Â Â &lt;/template&gt;</span></strong><span class="koboSpan" id="kobo.274.1">
Â Â &lt;/CardView&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.275.1">Weâ€™ve defined the contents</span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.276.1"> of the templates. </span><span class="koboSpan" id="kobo.276.2">Weâ€™ve designated </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">comic.title</span></strong><span class="koboSpan" id="kobo.278.1"> for the header</span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.279.1"> in the component. </span><span class="koboSpan" id="kobo.279.2">For the default slot, weâ€™re providing the markup for the contents of the card. </span><span class="koboSpan" id="kobo.279.3">In both cases, we let the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">&lt;CardView&gt;</span></strong><span class="koboSpan" id="kobo.281.1"> component handle the formatting and style, which also ensures a consistent </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">user interface.</span></span></p>
<p><span class="koboSpan" id="kobo.283.1">In the example code, you will see the shorthand notation for </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">named slots:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.285.1">
&lt;template </span><strong class="bold"><span class="koboSpan" id="kobo.286.1">#header</span></strong><span class="koboSpan" id="kobo.287.1">&gt;Â Â {{ comic.title }}
&lt;/template&gt;
&lt;template </span><strong class="bold"><span class="koboSpan" id="kobo.288.1">#default</span></strong><span class="koboSpan" id="kobo.289.1">&gt;
Â Â //â€¦ abbreviated
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.290.1">For now, weâ€™ll remove the temporary change to </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">App.vue</span></strong><span class="koboSpan" id="kobo.292.1"> because weâ€™re going to add this to a specific </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">route view!</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">With the components we have prepared, weâ€™ll continue by moving those components to specif</span><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.295.1">ic views </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">and routes.</span></span></p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.297.1">Marvelous routes in a single-page application</span></h1>
<p><span class="koboSpan" id="kobo.298.1">Now, letâ€™s take a look</span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.299.1"> at the default setup of the application, because weâ€™ve pre-installed the app to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">vue-router</span></strong><span class="koboSpan" id="kobo.301.1">. </span><span class="koboSpan" id="kobo.301.2">This configured the app with a couple </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">of things:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.303.1">We have an </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">index.ts</span></strong><span class="koboSpan" id="kobo.305.1"> file in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">router</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.307.1"> folder</span></span></li>
<li><span class="koboSpan" id="kobo.308.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">views</span></strong><span class="koboSpan" id="kobo.310.1"> folder, we have two components called </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">HomeView.vue</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.312.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">AboutView.vue</span></strong></span></li>
<li><span class="koboSpan" id="kobo.314.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">App.vue</span></strong><span class="koboSpan" id="kobo.316.1">, we have some components called </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">RouterLink</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.318.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">RouterView</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.320.1">Thatâ€™s how routes are tied together. </span><span class="koboSpan" id="kobo.320.2">Letâ€™s take a look at each </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">of them.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">The contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">router</span></strong><span class="koboSpan" id="kobo.324.1"> folder define and configure the routes for the application. </span><span class="koboSpan" id="kobo.324.2">Routes define the different paths in your application and the components that should be rendered when those paths are accessed. </span><span class="koboSpan" id="kobo.324.3">Each route is represented as an object with properties such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">path</span></strong><span class="koboSpan" id="kobo.326.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">name</span></strong><span class="koboSpan" id="kobo.328.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">component</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">path</span></strong><span class="koboSpan" id="kobo.334.1"> property specifies the URL path, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">component</span></strong><span class="koboSpan" id="kobo.336.1"> property specifies the Vue component to render. </span><span class="koboSpan" id="kobo.336.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">name</span></strong><span class="koboSpan" id="kobo.338.1"> is not required and more meant as a human-readable identifier for </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">a route.</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">Using the default configuration, it defined the home view for us and set up the other view to support code splitting to limit bundle sizes per route. </span><span class="koboSpan" id="kobo.340.2">So, this is a best practice out of </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">the box!</span></span></p>
<p><span class="koboSpan" id="kobo.342.1">Weâ€™ll change the references to </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">about</span></strong><span class="koboSpan" id="kobo.344.1"> into </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">search</span></strong><span class="koboSpan" id="kobo.346.1">, in preparation for our </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">final result:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.348.1">
{Â Â path: '/</span><strong class="bold"><span class="koboSpan" id="kobo.349.1">search</span></strong><span class="koboSpan" id="kobo.350.1">,
Â Â name: </span><strong class="bold"><span class="koboSpan" id="kobo.351.1">search</span></strong><span class="koboSpan" id="kobo.352.1">,
Â Â // route level code-splitting
Â Â // this generates a separate chunk (Search.[hash].js) for this route
Â Â // which is lazy-loaded when the route is visited.
</span><span class="koboSpan" id="kobo.352.2">Â Â component: () =&gt; import('../views/</span><strong class="bold"><span class="koboSpan" id="kobo.353.1">Search</span></strong><span class="koboSpan" id="kobo.354.1">View.vue')
}</span></pre>
<p><span class="koboSpan" id="kobo.355.1">Weâ€™ll rename </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">AboutView.vue</span></strong><span class="koboSpan" id="kobo.357.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">SearchView.vue</span></strong><span class="koboSpan" id="kobo.359.1">. </span><span class="koboSpan" id="kobo.359.2">For the contents of the file, you can just strip most of it, weâ€™ll build</span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.360.1"> something new later on. </span><span class="koboSpan" id="kobo.360.2">Something like this is fine </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">for now:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.362.1">
&lt;template&gt;Â Â &lt;div class="search"&gt;
Â Â Â Â &lt;h1&gt;This is a search page&lt;/h1&gt;
Â Â &lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.363.1">To string it all back together, we can update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">App.vue</span></strong><span class="koboSpan" id="kobo.365.1"> file so the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">RouterLink</span></strong><span class="koboSpan" id="kobo.367.1"> component points to </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">/search</span></strong><span class="koboSpan" id="kobo.369.1"> instead </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">/about</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.373.1">To be clear: you have to use the path that weâ€™ve configured in the router file. </span><span class="koboSpan" id="kobo.373.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">RouterView</span></strong><span class="koboSpan" id="kobo.375.1"> component is used to render the matched component based on the current route. </span><span class="koboSpan" id="kobo.375.2">It acts as a placeholder where the corresponding component is rendered. </span><span class="koboSpan" id="kobo.375.3">Whenever the route changes, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">RouterView</span></strong><span class="koboSpan" id="kobo.377.1"> component will be automatically updated to render the new component. </span><span class="koboSpan" id="kobo.377.2">Remember slots? </span><span class="koboSpan" id="kobo.377.3">Consider </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">RouterView</span></strong><span class="koboSpan" id="kobo.379.1"> as sort of a dynamic slot that can hold an </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">entire view.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">RouterLink</span></strong><span class="koboSpan" id="kobo.382.1"> in turn is used to create navigation links in your application and triggers navigation to the given route when clicked. </span><span class="koboSpan" id="kobo.382.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">to</span></strong><span class="koboSpan" id="kobo.384.1"> attribute of </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">RouterLink</span></strong><span class="koboSpan" id="kobo.386.1"> specifies the path or name of the </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">target route.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">Letâ€™s clean up the parts of the default configuration we donâ€™t </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">need anymore:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.390.1">
&lt;script setup lang="ts"&gt;import { RouterLink, RouterView } from 'vue-router'
&lt;/script&gt;
&lt;template&gt;
Â Â &lt;header&gt;
Â Â Â Â &lt;div class="my-4 text-center"&gt;
Â Â Â Â Â Â &lt;h1 class="mb-4 text-6xl font-extrabold uppercase"&gt;Marvel Explorer ğŸ”­&lt;/h1&gt;
Â Â Â Â Â Â &lt;nav&gt;
Â Â Â Â Â Â Â Â &lt;RouterLink to="/" class="px-4 py-2 border-2 rounded-s-md hover:text-slate-600"&gt;ğŸ“’ Comics&lt;/RouterLink&gt;
Â Â Â Â Â Â Â Â &lt;RouterLink to="/search" class="px-4 py-2 border-2 border-s-0 hover:text-slate-600 rounded-e-md"&gt;ğŸ¦¹ Heroes&lt;/RouterLink&gt;
Â Â Â Â Â Â &lt;/nav&gt;
Â Â Â Â &lt;/div&gt;
Â Â &lt;/header&gt;
Â Â &lt;RouterView /&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.391.1">Since our </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">ComicsOverview.vue</span></strong><span class="koboSpan" id="kobo.393.1"> component is ready, we can</span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.394.1"> add it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">HomeView.vue</span></strong><span class="koboSpan" id="kobo.396.1">, replacing the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">TheWelcome.vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.398.1"> part:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.399.1">
&lt;script setup lang="ts"&gt;import ComicsOverview from '@/components/ComicsOverview.vue';
&lt;/script&gt;
&lt;template&gt;
Â Â &lt;main&gt;
Â Â Â Â &lt;ComicsOverview /&gt;
Â Â &lt;/main&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.400.1">If you now run the app, you can navigate between the home page, which loads the comics overview, and the almost empty </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">search page.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">Weâ€™ll continue to work on getting</span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.403.1"> more information into our application, because our application is limited now to just showing the first pag</span><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.404.1">e of the </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">API results.</span></span></p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.406.1">Optional parameters</span></h2>
<p><span class="koboSpan" id="kobo.407.1">If you analyzed the network request</span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.408.1"> coming from the Marvel API, you may have noticed that the comics we are showing are but the tip of the iceberg. </span><span class="koboSpan" id="kobo.408.2">There are a multitude of comics, and because of that volume, they are not being sent in one response. </span><span class="koboSpan" id="kobo.408.3">The API offers paged results. </span><span class="koboSpan" id="kobo.408.4">We can modify our app to mirror the features of </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">the API!</span></span></p>
<p><span class="koboSpan" id="kobo.410.1">If we open the router file, we can add an optional parameter to a route. </span><span class="koboSpan" id="kobo.410.2">It parses and exposes the value to be used in your application. </span><span class="koboSpan" id="kobo.410.3">The notation for a parameter (or </span><em class="italic"><span class="koboSpan" id="kobo.411.1">param</span></em><span class="koboSpan" id="kobo.412.1"> for short) is to prefix the name with a colon. </span><span class="koboSpan" id="kobo.412.2">Weâ€™ll add a param called </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">page</span></strong><span class="koboSpan" id="kobo.414.1"> to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">home</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.416.1"> route:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.417.1">
{Â Â path: '/</span><strong class="bold"><span class="koboSpan" id="kobo.418.1">:page</span></strong><span class="koboSpan" id="kobo.419.1">',
Â Â name: 'home',
Â Â component: HomeView
},</span></pre>
<p><span class="koboSpan" id="kobo.420.1">We have introduced a slight bug in our application. </span><span class="koboSpan" id="kobo.420.2">The application now </span><em class="italic"><span class="koboSpan" id="kobo.421.1">always expects a parameter</span></em><span class="koboSpan" id="kobo.422.1">. </span><span class="koboSpan" id="kobo.422.2">For the home page, this is not always the case! </span><span class="koboSpan" id="kobo.422.3">The param should be optional. </span><span class="koboSpan" id="kobo.422.4">To mark a param as optional, we add a question mark as </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">a suffix:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.424.1">
{Â Â path: '/:page</span><strong class="bold"><span class="koboSpan" id="kobo.425.1">?</span></strong><span class="koboSpan" id="kobo.426.1">',
Â Â name: 'home',
Â Â component: HomeView
},</span></pre>
<p><span class="koboSpan" id="kobo.427.1">Hooray! </span><span class="koboSpan" id="kobo.427.2">Weâ€™ve successfully </span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.428.1">added an optional parameter. </span><span class="koboSpan" id="kobo.428.2">We can now introduce pagination </span><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.429.1">to our </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">comics overview.</span></span></p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.431.1">Paging Dr Strange</span></h2>
<p><span class="koboSpan" id="kobo.432.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">vue</span></strong><span class="koboSpan" id="kobo.434.1"> router exposes</span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.435.1"> itself as a composable. </span><span class="koboSpan" id="kobo.435.2">A composable is a Vue superpower, used to encapsulate stateful logic for easy reuse. </span><span class="koboSpan" id="kobo.435.3">This means that the router composable, in this case, holds the state of the router, which we can use in </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">any component!</span></span></p>
<p><span class="koboSpan" id="kobo.437.1">This means we can open our </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">ComicsOverview.vue</span></strong><span class="koboSpan" id="kobo.439.1"> file directly to implement pagination. </span><span class="koboSpan" id="kobo.439.2">Letâ€™s take a look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">script</span></strong><span class="koboSpan" id="kobo.441.1"> tag of the component and add a few </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">lines: </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.2-ComicsOverview.vue"><span class="No-Break"><span class="koboSpan" id="kobo.443.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.2-ComicsOverview.vue</span></span></a></p>
<p><span class="koboSpan" id="kobo.444.1">First, weâ€™re importing the composable (</span><em class="italic"><span class="koboSpan" id="kobo.445.1">line 4</span></em><span class="koboSpan" id="kobo.446.1">) and register it to the route constant (</span><em class="italic"><span class="koboSpan" id="kobo.447.1">line 12</span></em><span class="koboSpan" id="kobo.448.1">). </span><span class="koboSpan" id="kobo.448.2">Then weâ€™re adding two reactive variables (</span><em class="italic"><span class="koboSpan" id="kobo.449.1">lines 16, 17</span></em><span class="koboSpan" id="kobo.450.1">) to track the page information. </span><span class="koboSpan" id="kobo.450.2">We access the parameter via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">route.params</span></strong><span class="koboSpan" id="kobo.452.1"> object. </span><span class="koboSpan" id="kobo.452.2">Since we named the variable page we can access the corresponding property on the method. </span><span class="koboSpan" id="kobo.452.3">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">+route.params.page</span></strong><span class="koboSpan" id="kobo.454.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.455.1">lines 19-21</span></em><span class="koboSpan" id="kobo.456.1">) as shorthand to convert the value to a numeric type, and we store it in the </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">reactive </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">currentPage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.460.1">Then, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">getComics</span></strong><span class="koboSpan" id="kobo.462.1">, we use the data coming from the endpoint to actualize the values (</span><em class="italic"><span class="koboSpan" id="kobo.463.1">lines </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.464.1">27, 28</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.466.1">Now that we know how many pages there are and what page we are on, we can use these properties to provide a simp</span><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.467.1">le </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">Pagination</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.469.1"> component.</span></span></p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.470.1">A simple pagination component</span></h2>
<p><span class="koboSpan" id="kobo.471.1">So, letâ€™s create a new </span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.472.1">component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">Pagination.vue</span></strong><span class="koboSpan" id="kobo.474.1"> and add the following </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">contents: </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.3-Pagination.vue"><span class="No-Break"><span class="koboSpan" id="kobo.476.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.3-Pagination.vue</span></span></a></p>
<p><span class="koboSpan" id="kobo.477.1">It should be pretty self-explanatory by now: weâ€™re adding the relevant props (for more flexibility, we provide a </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">path</span></strong><span class="koboSpan" id="kobo.479.1"> property as well) and, based on our current page, we can render the links to the first, previous, or next and last page links and show the </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">pagination status.</span></span></p>
<p><span class="koboSpan" id="kobo.481.1">I would like to point out the aria-hidden</span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.482.1"> property, which we use to mark decorative elements that add no value for screen readers. </span><span class="koboSpan" id="kobo.482.2">Now, weâ€™ll add it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">ComicsOverview.vue</span></strong><span class="koboSpan" id="kobo.484.1"> component by importing it and pasting the template under the overview of </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">comics cards:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.486.1">
&lt;template&gt;Â Â &lt;div&gt;
Â Â Â Â &lt;LoadingIndicator v-if="isLoading" text="Loading comics..." </span><span class="koboSpan" id="kobo.486.2">/&gt;
Â Â Â Â &lt;div v-if="data &amp;&amp; !isLoading"&gt;
Â Â Â Â Â Â &lt;div
Â Â Â Â Â Â Â Â class="grid grid-flow-row grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-4"
Â Â Â Â Â Â &gt;
Â Â Â Â Â Â Â Â &lt;ComicCard
Â Â Â Â Â Â Â Â Â Â :comic="comic"
Â Â Â Â Â Â Â Â Â Â :key="comic.id"
Â Â Â Â Â Â Â Â Â Â v-for="comic in data"
Â Â Â Â Â Â Â Â &gt;&lt;/ComicCard&gt;
Â Â Â Â Â Â &lt;/div&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.487.1">Â Â Â Â Â Â &lt;Pagination</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.488.1">Â Â Â Â Â Â Â Â :total-pages="totalPages"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.489.1">Â Â Â Â Â Â Â Â path="/"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.490.1">Â Â Â Â Â Â Â Â :current-page="+currentPage"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.491.1">Â Â Â Â Â Â &gt;&lt;/Pagination&gt;</span></strong><span class="koboSpan" id="kobo.492.1">
Â Â Â Â &lt;/div&gt;
Â Â &lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.493.1">That works! </span><span class="koboSpan" id="kobo.493.2">We can click</span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.494.1"> to the next page, but nothing happens. </span><span class="koboSpan" id="kobo.494.2">Thatâ€™s because our API doesnâ€™t support pagination yet. </span><span class="koboSpan" id="kobo.494.3">Letâ€™s look into adding it as a feature, so weâ€™ll open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">marvelApi.ts</span></strong><span class="koboSpan" id="kobo.496.1"> file. </span><span class="koboSpan" id="kobo.496.2">First, weâ€™ll add the option for pagination </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">useComics</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.500.1">
export const useComics = async (</span><strong class="bold"><span class="koboSpan" id="kobo.501.1">page: number = 0</span></strong><span class="koboSpan" id="kobo.502.1">): Promise&lt;Comics&gt; =&gt; {Â Â Â Â const apiKey = import.meta.env.VITE_APP_MARVEL_API_PUBLIC;Â Â const MARVEL_API = //gateway.marvel.com/v1/public/
Â Â const API_SIGN = apikey=${apiKey}
</span><strong class="bold"><span class="koboSpan" id="kobo.503.1">Â Â const ITEMS_PER_PAGE = 20;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.504.1">Â Â const pagination = page ? </span><span class="koboSpan" id="kobo.504.2">&amp;offset=${page * ITEMS_PER_PAGE} :</span></strong><span class="koboSpan" id="kobo.505.1">
Â Â const requestURI = ${MARVEL_API}/comics?${API_SIGN}</span><strong class="bold"><span class="koboSpan" id="kobo.506.1">${pagination}</span></strong><span class="koboSpan" id="kobo.507.1">
Â Â const res = await fetch(requestURI);
Â Â const jsonRes = await res.json();
Â Â return jsonRes.data;
}</span></pre>
<p><span class="koboSpan" id="kobo.508.1">Weâ€™re simply accepting a page number, and weâ€™ll use the predefined </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">ITEMS_PER_PAGE</span></strong><span class="koboSpan" id="kobo.510.1"> to determine the offset (which is the way the Marvel API deals with pagination). </span><span class="koboSpan" id="kobo.510.2">Then, we store the query parameter and add it to </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">requestURI</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.514.1">Now, we can flip over to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">ComicsOverview</span></strong><span class="koboSpan" id="kobo.516.1"> component again to implement the pagination and connect</span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.517.1"> the route parameter to the API request. </span><span class="koboSpan" id="kobo.517.2">To accomplish this, we add the following to the </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">script block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.519.1">
&lt;script lang="ts" setup&gt;import { ref, onMounted, </span><strong class="bold"><span class="koboSpan" id="kobo.520.1">watch</span></strong><span class="koboSpan" id="kobo.521.1"> } from "vue";
// abbreviatedâ€¦
const getComics = async (</span><strong class="bold"><span class="koboSpan" id="kobo.522.1">page: number = 0</span></strong><span class="koboSpan" id="kobo.523.1">) =&gt; {
Â Â isLoading.value = true;
Â Â const comics = await useComics(</span><strong class="bold"><span class="koboSpan" id="kobo.524.1">page</span></strong><span class="koboSpan" id="kobo.525.1">);
Â Â currentPage.value = comics?.offset / comics?.limit || 0;
Â Â totalPages.value = Math.ceil(comics.total / comics.limit);
Â Â data.value = comics.results;
Â Â isLoading.value = false;
};
</span><strong class="bold"><span class="koboSpan" id="kobo.526.1">watch(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.527.1">Â Â () =&gt; route.params.page,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.528.1">Â Â async (newPage) =&gt; {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.529.1">Â Â Â Â await getComics(+newPage);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.530.1">Â Â }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.531.1">);</span></strong><span class="koboSpan" id="kobo.532.1">
onMounted(async () =&gt; {
Â Â await getComics(</span><strong class="bold"><span class="koboSpan" id="kobo.533.1">+currentPage.value</span></strong><span class="koboSpan" id="kobo.534.1">);
});
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.535.1">We can simply add the page now to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">getComics</span></strong><span class="koboSpan" id="kobo.537.1"> request and pass it down to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">useComics</span></strong><span class="koboSpan" id="kobo.539.1"> composable. </span><span class="koboSpan" id="kobo.539.2">We do this </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">onMounted</span></strong><span class="koboSpan" id="kobo.541.1">, for when you enter the application from a URL directly. </span><span class="koboSpan" id="kobo.541.2">We also add a watch function, that keeps track of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">route.params.page</span></strong><span class="koboSpan" id="kobo.543.1"> and requests a new page once the value changes. </span><span class="koboSpan" id="kobo.543.2">Weâ€™re using the quick conversion to numeric here as well, as you can see by the </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">plus sign.</span></span></p>
<p><span class="koboSpan" id="kobo.545.1">With all of this in place, we can now browse through all 2,746 pages! </span><span class="koboSpan" id="kobo.545.2">As an extra exercise, why not figure out if you can expand the pagination component to show </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">multiple pages.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">Once youâ€™re ready to move</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.548.1"> forward, weâ€™ll refactor our app to use composables. </span><span class="koboSpan" id="kobo.548.2">They are functions that </span><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.549.1">encapsulate (</span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">stateful) logic.</span></span></p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.551.1">Composables, assemble!</span></h1>
<p><span class="koboSpan" id="kobo.552.1">Letâ€™s take a look at how we can leverage</span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.553.1"> our composables and refactor the app to expand the functionalities a bit. </span><span class="koboSpan" id="kobo.553.2">Composables are all about reusability: itâ€™s their superpower in the Vue space, so letâ€™s put our previously created composable </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">into action.</span></span></p>
<p><span class="koboSpan" id="kobo.555.1">First, we will work on refactoring the </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">useComics</span></strong><span class="koboSpan" id="kobo.557.1"> composable, where we will lightly apply the clean code principles. </span><span class="koboSpan" id="kobo.557.2">In our context, this will translate to applying the single responsibility principle and writing small and cohesive fu</span><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.558.1">nctions with </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">meaningful names.</span></span></p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.560.1">Refactoring useComics</span></h2>
<p><span class="koboSpan" id="kobo.561.1">Weâ€™ll refactor in a non-destructive</span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.562.1"> way too, leaving the existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">useComic</span></strong><span class="koboSpan" id="kobo.564.1"> composable functional</span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.565.1"> until weâ€™re ready to update </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">that too.</span></span></p>
<p><span class="koboSpan" id="kobo.567.1">Weâ€™ll first move the static constants out of the function to the upper scope. </span><span class="koboSpan" id="kobo.567.2">Weâ€™ll also import additional types that we will reference in functions. </span><span class="koboSpan" id="kobo.567.3">This way, we can still access them, but they are available throughout the file. </span><span class="koboSpan" id="kobo.567.4">I make it a practice to group these types of values at the top of the file for easy </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">future reference:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.569.1">import { Path } from '@/types/marvel'</span></strong><span class="koboSpan" id="kobo.570.1">import type { Comics</span><strong class="bold"><span class="koboSpan" id="kobo.571.1">, Characters, Character</span></strong><span class="koboSpan" id="kobo.572.1"> } from '@/types/marvel'
</span><strong class="bold"><span class="koboSpan" id="kobo.573.1">const apiKey = import.meta.env.VITE_APP_MARVEL_API_PUBLIC;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.574.1">const MARVEL_API = //gateway.marvel.com/v1/public/</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.575.1">const API_SIGN = apikey=${apiKey}</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.576.1">const ITEMS_PER_PAGE = 20;</span></strong><span class="koboSpan" id="kobo.577.1">
export const useComics = async (page: number = 0): Promise&lt;Comics&gt; =&gt; {
Â Â const pagination = page ? </span><span class="koboSpan" id="kobo.577.2">&amp;offset=${page * ITEMS_PER_PAGE} :
Â Â const requestURI = ${MARVEL_API}/comics?${API_SIGN}${pagination}
Â Â const res = await fetch(requestURI);
Â Â const jsonRes = await res.json();
Â Â return jsonRes.data;
}</span></pre>
<p><span class="koboSpan" id="kobo.578.1">If we think about what our new composables</span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.579.1"> should do and have in common, we can identify</span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.580.1"> the following activities: determining the pagination, determining a search query, constructing the Marvel Developer API URL, and fetching and returning data. </span><span class="koboSpan" id="kobo.580.2">Weâ€™ll create short, separate functions for each activity. </span><span class="koboSpan" id="kobo.580.3">These are not composables, and we wonâ€™t expose them outside of </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">the file.</span></span></p>
<p><span class="koboSpan" id="kobo.582.1">Letâ€™s add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">getPagination</span></strong><span class="koboSpan" id="kobo.584.1"> function, which accepts page number and translates it to a string</span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.585.1"> translating the page to an </span><strong class="bold"><span class="koboSpan" id="kobo.586.1">offset</span></strong><span class="koboSpan" id="kobo.587.1"> (in line with what the Marvel API </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">would expect):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.589.1">
const getPagination = (page?: number): string =&gt; {Â Â Â Â return page ? </span><span class="koboSpan" id="kobo.589.2">&amp;offset=${page * ITEMS_PER_PAGE} : ''
};</span></pre>
<p><span class="koboSpan" id="kobo.590.1">To construct an additional string containing a search query, we add </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.592.1">
const getQuery = (query?: string): string =&gt; {Â Â Â Â return query ? </span><span class="koboSpan" id="kobo.592.2">&amp;${query} : ''
};</span></pre>
<p><span class="koboSpan" id="kobo.593.1">The next addition is a function to construct the request URI, combining the static constants with the output of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">getPagination</span></strong><span class="koboSpan" id="kobo.595.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">getQuery</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.597.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.598.1">
const getRequestURI = (path: Path,query: string, pagination: string): string =&gt; {Â Â Â Â const apiPath = ${MARVEL_API}/${path};
Â Â Â Â return ${apiPath}?${API_SIGN}${query}${pagination};
};</span></pre>
<p><span class="koboSpan" id="kobo.599.1">And weâ€™ll add a function to do a request and return the result. </span><span class="koboSpan" id="kobo.599.2">In this case, we could potentially reuse this, so we can write it as if it were a composable, using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">use</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.601.1"> prefix:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.602.1">
export const useFetch = async (requestURI: string): Promise&lt;Comics | Characters&gt; =&gt; {Â Â const res = await fetch(requestURI);
Â Â const jsonRes = await res.json();
Â Â return jsonRes.data as Comics | Characters;
};</span></pre>
<p><span class="koboSpan" id="kobo.603.1">Finally, we can string all of the functions</span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.604.1"> together in a composable that will allow</span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.605.1"> us to interact with the Marvel </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">Developer API:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.607.1">
interface ApiOptions {Â Â query?: string;
Â Â page?: number;
}
export const useMarvelAPI = async (path: Path, options: ApiOptions): Promise&lt;Comics | Characters&gt; =&gt; {
Â Â const pagination = getPagination(options.page);
Â Â const query = getQuery(options.query);
Â Â const requestURI = getRequestURI(path, id, query, pagination);
Â Â return useFetch(requestURI);
}</span></pre>
<p><span class="koboSpan" id="kobo.608.1">As you can see, weâ€™ve created a function that can either return comics or characters, this will depend on the path variable we provide. </span><span class="koboSpan" id="kobo.608.2">Since the Marvel Developer API has similar mechanics for every endpoint, we were able to make a useful abstraction of the options </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">we need.</span></span></p>
<p><span class="koboSpan" id="kobo.610.1">The code weâ€™ve added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">MavelAPI.ts</span></strong><span class="koboSpan" id="kobo.612.1"> file looks like </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">this: </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.4-MarvelAPI.ts"><span class="No-Break"><span class="koboSpan" id="kobo.614.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.4-MarvelAPI.ts</span></span></a></p>
<p><span class="koboSpan" id="kobo.615.1">Weâ€™ve expanded the file</span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.616.1"> with abstractions to retrieve data from the endpoint, where we can reuse functions</span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.617.1"> that are generic while being able to request </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">specific content.</span></span></p>
<p><span class="koboSpan" id="kobo.619.1">Letâ€™s investigate incorporating thes</span><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.620.1">e functionalities into </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">our application.</span></span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.622.1">Reassembling functionalities</span></h2>
<p><span class="koboSpan" id="kobo.623.1">Now, we can update</span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.624.1"> our existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">useComics</span></strong><span class="koboSpan" id="kobo.626.1"> composable to build on top of this foundation. </span><span class="koboSpan" id="kobo.626.2">As you can see, weâ€™re now able to reduce the contents of the composable to a single line of code, providing only the path and </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">current page:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.628.1">
export const useComics = async (page: number = 0): Promise&lt;Comics&gt; =&gt; {Â Â </span><strong class="bold"><span class="koboSpan" id="kobo.629.1">return await useMarvelAPI(Path.COMICS, { page }) as Comics</span></strong><span class="koboSpan" id="kobo.630.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.631.1">By running our code, the existing overview of comics with pagination should remain fully functional. </span><span class="koboSpan" id="kobo.631.2">This is a testament to writing clean code rather than the power of composables. </span><span class="koboSpan" id="kobo.631.3">It enables us to implement new, useful code with relative ease. </span><span class="koboSpan" id="kobo.631.4">In our next composable, weâ€™ll request a different type of information, as we will describe in </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">the function.</span></span></p>
<p><span class="koboSpan" id="kobo.633.1">The way we will interact with the search API is to provide the correct path to the API and, in our case, weâ€™ll use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">nameStartsWith</span></strong><span class="koboSpan" id="kobo.635.1"> way of searching. </span><span class="koboSpan" id="kobo.635.2">Weâ€™ll provide it, together with a dynamic search value, as part of </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">the query:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.637.1">
export const useCharacterSearch = async (query: string, page: number = 0): Promise&lt;Characters&gt; =&gt; {Â Â return await useMarvelAPI(Path.CHARACTERS, { query: nameStartsWith=${query}, page }) as Characters
}</span></pre>
<p><span class="koboSpan" id="kobo.638.1">This time, as you can see, weâ€™ve changed the expected response type to </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">Characters</span></strong><span class="koboSpan" id="kobo.640.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">Comics</span></strong><span class="koboSpan" id="kobo.642.1">. </span><span class="koboSpan" id="kobo.642.2">Our IDE will be able to make a distinction between the two types when weâ€™re interacting with </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">these composables.</span></span></p>
<p><span class="koboSpan" id="kobo.644.1">We now have our two composables ready for use in the app. </span><span class="koboSpan" id="kobo.644.2">The way we refactored our file is something of a natural process in coding. </span><span class="koboSpan" id="kobo.644.3">Over time, requirements will change, so it is only logical that the code changes with it. </span><span class="koboSpan" id="kobo.644.4">Having our code split into small, focused functions will make it easier to understand and modify in </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">the future.</span></span></p>
<p><span class="koboSpan" id="kobo.646.1">When using composables, we normally follow the same practice of providing simple-to-use functions and rather splitting them into separate ones than combining them </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">into one.</span></span></p>
<p><span class="koboSpan" id="kobo.648.1">If youâ€™re interested in applying </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.649.1">composables, I recommend checking out </span><a href="https://vueuse.org/"><span class="koboSpan" id="kobo.650.1">https://vueuse.org/</span></a><span class="koboSpan" id="kobo.651.1">. </span><span class="koboSpan" id="kobo.651.2">It hosts a collection of ready-to-use composables for everyday problems in </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">Vue applications.</span></span></p>
<p><span class="koboSpan" id="kobo.653.1">At this point, weâ€™ve seen how the combination of a clean code mindset, combined with specific composables have helped us refactor our applicationâ€™s code into individual parts that are more readable and maintainable. </span><span class="koboSpan" id="kobo.653.2">Weâ€™ve also experienced refactoring code. </span><span class="koboSpan" id="kobo.653.3">Sometimes we refactor due</span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.654.1"> to shifting needs, sometimes we just want to make existing code </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">more readable.</span></span></p>
<p><span class="koboSpan" id="kobo.656.1">Letâ€™s now look at add</span><a id="_idTextAnchor112"/><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.657.1">ing more types of data to </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">our application!</span></span></p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.659.1">Managing the roster</span></h1>
<p><span class="koboSpan" id="kobo.660.1">With our brand new composable, we have</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.661.1"> easy access to more data from the Marvel Developer API! </span><span class="koboSpan" id="kobo.661.2">Weâ€™ll move onto creating the Vue components that will allow the user interface to deal </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">with searching.</span></span></p>
<p><span class="koboSpan" id="kobo.663.1">Weâ€™ll first create a variant of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">ComicCard.vue</span></strong><span class="koboSpan" id="kobo.665.1"> named </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">CharacterCard.vue</span></strong><span class="koboSpan" id="kobo.667.1">. </span><span class="koboSpan" id="kobo.667.2">The component will be a bit simpler, so you can either paste the following contents in the file or create a copy of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">ComicCard.vue</span></strong><span class="koboSpan" id="kobo.669.1"> and update it to match </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">the contents:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.671.1">
&lt;script setup lang="ts"&gt;import type { Character } from "@/types/marvel";
import CardView from "./CardView.vue";
interface Props {
Â Â character: Character;
}
const props = defineProps&lt;Props&gt;();
&lt;/script&gt;
&lt;template&gt;
Â Â &lt;CardView :id="character.id"&gt;
Â Â Â Â &lt;img :src="`${character.thumbnail.path}.${character.thumbnail.extension}`" class="float-left w-12 h-12 mb-2 mr-4 rounded-full shadow-md aspect-square" /&gt;
Â Â Â Â &lt;template #header&gt;{{ character.name }}&lt;/template&gt;
Â Â Â Â &lt;div class="text-base max-w-prose"&gt;{{ character.description }}&lt;/div&gt;
Â Â &lt;/CardView&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.672.1">Thereâ€™s nothing special going on here. </span><span class="koboSpan" id="kobo.672.2">Weâ€™re expecting a single property character, and that should match the type. </span><span class="koboSpan" id="kobo.672.3">We can therefore easily map the underlying properties to a simple </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">HTML template.</span></span></p>
<p><span class="koboSpan" id="kobo.674.1">Next, weâ€™ll create the main component to host all the user interface elements. </span><span class="koboSpan" id="kobo.674.2">Weâ€™ll create a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">SearchCharacter.vue</span></strong><span class="koboSpan" id="kobo.676.1">, and weâ€™ll start with just the template. </span><span class="koboSpan" id="kobo.676.2">This too should look familiar after creating </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">ComicsOverview.vue</span></strong><span class="koboSpan" id="kobo.678.1">. </span><span class="koboSpan" id="kobo.678.2">Iâ€™ve highlighted the key </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">differences: </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.5-SearchCharacter.vue"><span class="No-Break"><span class="koboSpan" id="kobo.680.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.5-SearchCharacter.vue</span></span></a></p>
<p><span class="koboSpan" id="kobo.681.1">Weâ€™re providing a meaningful message when the data is loading (</span><em class="italic"><span class="koboSpan" id="kobo.682.1">line 3</span></em><span class="koboSpan" id="kobo.683.1">), and weâ€™re showing results in a different matter, namely a </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">CharacterCard</span></strong><span class="koboSpan" id="kobo.685.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.686.1">lines 8-12</span></em><span class="koboSpan" id="kobo.687.1">). </span><span class="koboSpan" id="kobo.687.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">Pagination</span></strong><span class="koboSpan" id="kobo.689.1">, we have provided the current path (</span><em class="italic"><span class="koboSpan" id="kobo.690.1">line 16</span></em><span class="koboSpan" id="kobo.691.1">), and weâ€™ve added a more specific message when no data</span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.692.1"> is returned (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.693.1">lines 25-28</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.695.1">Now, weâ€™ll implement a way of inputting a search query to</span><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.696.1"> lead into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">SearchCharacter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.698.1"> presentation.</span></span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.699.1">Searching for heroes</span></h2>
<p><span class="koboSpan" id="kobo.700.1">Searching is an isolated, specific</span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.701.1"> action, so in line with the Single File Components philosophy, we are going to create a specific component </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">for this!</span></span></p>
<p><span class="koboSpan" id="kobo.703.1">Letâ€™s create a form component by creating a new file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">SearchForm.vue</span></strong><span class="koboSpan" id="kobo.705.1">. </span><span class="koboSpan" id="kobo.705.2">Start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">script</span></strong><span class="koboSpan" id="kobo.707.1"> tag, and Iâ€™ll explain some new things along </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">the way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.709.1">
&lt;script lang="ts" setup&gt;import { ref } from "vue";
import type { Ref } from "vue";
</span><strong class="bold"><span class="koboSpan" id="kobo.710.1">const emit = defineEmits(['searchSubmit'])</span></strong><span class="koboSpan" id="kobo.711.1">
interface Props {
Â Â isSearching: boolean;
}
const props = defineProps&lt;Props&gt;();
const query: Ref&lt;string&gt; = ref("");
</span><strong class="bold"><span class="koboSpan" id="kobo.712.1">const search = (): void =&gt; {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.713.1">Â Â emit("searchSubmit", query.value);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.714.1">};</span></strong><span class="koboSpan" id="kobo.715.1">
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.716.1">There are two interesting things going on. </span><span class="koboSpan" id="kobo.716.2">The first highlighted line defines an </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">emit</span></strong><span class="koboSpan" id="kobo.718.1">. </span><span class="koboSpan" id="kobo.718.2">Emitting happens if we want to pass something (an event) upwards in the scope. </span><span class="koboSpan" id="kobo.718.3">Props go down, emits go up. </span><span class="koboSpan" id="kobo.718.4">By using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">defineEmits</span></strong><span class="koboSpan" id="kobo.720.1">, we wrap it so that Vue can keep track of the event at runtime and weâ€™re assigning it the </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">name </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">searchSubmit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.724.1">Next, we have a function</span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.725.1"> called </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">search</span></strong><span class="koboSpan" id="kobo.727.1"> that does nothing but emit the event by referencing its name and passing </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">query.value</span></strong><span class="koboSpan" id="kobo.729.1"> as a parameter. </span><span class="koboSpan" id="kobo.729.2">In our parent component, we will be able to catch the event and </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">its value.</span></span></p>
<p><span class="koboSpan" id="kobo.731.1">Itâ€™s time to add the template. </span><span class="koboSpan" id="kobo.731.2">Letâ€™s start as simply </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">as possible:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.733.1">
&lt;template&gt;Â Â &lt;form class="flex justify-center my-8" </span><strong class="bold"><span class="koboSpan" id="kobo.734.1">v-on:submit.stop="search"</span></strong><span class="koboSpan" id="kobo.735.1">&gt;
Â Â Â Â &lt;input
Â Â Â Â Â Â class="px-3 py-2 border rounded-md rounded-r-none disabled:opacity-40 border-slate-300 text-slate-800 focus:outline-none focus:border-slate-500"
Â Â Â Â Â Â type="text"
Â Â Â Â Â Â </span><strong class="bold"><span class="koboSpan" id="kobo.736.1">v-model="query"</span></strong><span class="koboSpan" id="kobo.737.1">
Â Â Â Â Â Â placeholder="Search..."
</span><span class="koboSpan" id="kobo.737.2">Â Â Â Â Â Â :disabled="isSearching"
Â Â Â Â /&gt;
Â Â Â Â &lt;button
Â Â Â Â Â Â class="px-4 py-2 text-sm font-bold text-white transition-colors duration-300 rounded-md rounded-l-none disabled:opacity-40 bg-slate-500 hover:bg-slate-600"
Â Â Â Â Â Â :disabled="isSearching"
Â Â Â Â Â Â type="submit"
Â Â Â Â &gt;
Â Â Â Â Â Â ğŸ” Search
Â Â Â Â &lt;/button&gt;
Â Â &lt;/form&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.738.1">Here too, two things are important to note. </span><span class="koboSpan" id="kobo.738.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">v-on:submit.stop</span></strong><span class="koboSpan" id="kobo.740.1"> statement is a built-in method that prevents the actual form from being submitted as an HTML form (which would lead to refreshing the page). </span><span class="koboSpan" id="kobo.740.2">Instead, on submit, it calls the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">search</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.742.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.743.1">In order to have any value reference, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">v-model</span></strong><span class="koboSpan" id="kobo.745.1"> to bind the value of query to the inp</span><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.746.1">ut</span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.747.1"> field. </span><span class="koboSpan" id="kobo.747.2">This gives you </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">two-way databinding.</span></span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.749.1">Adding search</span></h2>
<p><span class="koboSpan" id="kobo.750.1">Although the form works, it doesnâ€™t feel like</span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.751.1"> an app: we still have to manually submit the form. </span><span class="koboSpan" id="kobo.751.2">Letâ€™s upgrade the </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">SearchForm</span></strong><span class="koboSpan" id="kobo.753.1"> before moving on to showing the results. </span><span class="koboSpan" id="kobo.753.2">Weâ€™ll use a watcher to monitor the value of the query and trigger the </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">search</span></strong><span class="koboSpan" id="kobo.755.1"> function when it </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">has changed.</span></span></p>
<p><span class="koboSpan" id="kobo.757.1">Weâ€™ll update the code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">script</span></strong><span class="koboSpan" id="kobo.759.1"> tag to match </span><span class="No-Break"><span class="koboSpan" id="kobo.760.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.761.1">
&lt;script lang="ts" setup&gt;import { ref, </span><strong class="bold"><span class="koboSpan" id="kobo.762.1">watch</span></strong><span class="koboSpan" id="kobo.763.1"> } from "vue";
import type { Ref } from "vue";
const emit = defineEmits(["searchSubmit"]);
interface Props {
Â Â isSearching: boolean;
}
const props = defineProps&lt;Props&gt;();
const query: Ref&lt;string&gt; = ref("");
let timeout: number;
const search = (): void =&gt; {
Â Â emit("searchSubmit", query.value);
};
</span><strong class="bold"><span class="koboSpan" id="kobo.764.1">const debouncedSearch = (): void =&gt; {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.765.1">Â Â clearTimeout(timeout);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.766.1">Â Â timeout = setTimeout(async () =&gt; {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.767.1">Â Â Â Â search();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.768.1">Â Â }, 500);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.769.1">};</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.770.1">watch(query, (): void =&gt; {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.771.1">Â Â debouncedSearch();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.772.1">});</span></strong><span class="koboSpan" id="kobo.773.1">
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.774.1">Itâ€™s easy to understand the importing of the watch function and defining the watcher. </span><span class="koboSpan" id="kobo.774.2">And instead of directly calling the search function, the watcher </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">calls </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">debouncedSearch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.778.1">Firing requests to an API is expensive</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.779.1"> in terms of resources. </span><span class="koboSpan" id="kobo.779.2">By debouncing the function, we run a timer of, in this case 500 milliseconds (ms). </span><span class="koboSpan" id="kobo.779.3">When the timer runs out, we then call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">search</span></strong><span class="koboSpan" id="kobo.781.1"> function, which in turn emits the </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">searchSubmit</span></strong><span class="koboSpan" id="kobo.783.1"> event. </span><span class="koboSpan" id="kobo.783.2">If, however, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">debouncedSearch</span></strong><span class="koboSpan" id="kobo.785.1"> function is called before the timer was cleared, we</span><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.786.1"> simply reset the timer and wait another </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">500 ms.</span></span></p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.788.1">An overview with superpowers</span></h2>
<p><span class="koboSpan" id="kobo.789.1">We can finally</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.790.1"> assemble the </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">SearchCharacter</span></strong><span class="koboSpan" id="kobo.792.1"> component. </span><span class="koboSpan" id="kobo.792.2">Letâ€™s start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">script</span></strong><span class="koboSpan" id="kobo.794.1"> tag, since we left it out when we first </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">started: </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.6-SearchCharacter.vue"><span class="No-Break"><span class="koboSpan" id="kobo.796.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.6-SearchCharacter.vue</span></span></a></p>
<p><span class="koboSpan" id="kobo.797.1">Apart from importing our utilities and components, the core of the component is to trigger the search action on the Marvel Developer API. </span><span class="koboSpan" id="kobo.797.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">getCharacterSearch</span></strong><span class="koboSpan" id="kobo.799.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.800.1">lines 20-34</span></em><span class="koboSpan" id="kobo.801.1">) takes care of updating the reactive values to translate to the UI and calculate the pagination. </span><span class="koboSpan" id="kobo.801.2">Its core is using our composable to retrieve the results, which are passed to the reactive </span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">data property.</span></span></p>
<p><span class="koboSpan" id="kobo.803.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">searchReset</span></strong><span class="koboSpan" id="kobo.805.1"> function (</span><em class="italic"><span class="koboSpan" id="kobo.806.1">lines 36-41</span></em><span class="koboSpan" id="kobo.807.1">) makes sure we can always return to the initial state, for instance, when youâ€™d want to clear the UI or when somebody searches for an </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">empty value.</span></span></p>
<p><span class="koboSpan" id="kobo.809.1">In the template itself, we only need to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">SearchForm</span></strong><span class="koboSpan" id="kobo.811.1"> so that our users can find their favorite hero from the </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">Marvel Universe:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.813.1">
&lt;template&gt;Â Â &lt;div&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.814.1">Â Â Â Â &lt;SearchForm</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.815.1">Â Â Â Â Â Â :is-searching="isSearching"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.816.1">Â Â Â Â Â Â @search-submit="search"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.817.1">Â Â Â Â /&gt;</span></strong><span class="koboSpan" id="kobo.818.1">
Â Â Â Â &lt;LoadingIndicator v-if="isSearching" :text="Searching by '${searchQuery}'..." </span><span class="koboSpan" id="kobo.818.2">/&gt;
Â Â Â Â // ...abbreviated
Â Â &lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.819.1">We have extended the app now with the very useful search function. </span><span class="koboSpan" id="kobo.819.2">This means we can put our new composable structure to the test. </span><span class="koboSpan" id="kobo.819.3">It allows us to focus on the implementation of the search form with debouncing, rather than fetching </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">the data.</span></span></p>
<p><span class="koboSpan" id="kobo.821.1">Weâ€™ve seen how our abstractions have helped to expand features with minimal effort. </span><span class="koboSpan" id="kobo.821.2">All weâ€™ve built so far has mostly been about a â€œhappy flow,â€ where the individual parts work as expected. </span><span class="koboSpan" id="kobo.821.3">Since weâ€™re depending</span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.822.1"> on a third-party API, we have no control over its stability and have to prepare for cases where the data is not returned. </span><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.823.1">Weâ€™ll focus on error handling in the </span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">next section.</span></span></p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.825.1">A different vision</span></h1>
<p><span class="koboSpan" id="kobo.826.1">At this point, our app is functioning</span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.827.1"> just fine. </span><span class="koboSpan" id="kobo.827.2">We can improve our app experience by making sure we can handle situations when the API returns an error. </span><span class="koboSpan" id="kobo.827.3">Letâ€™s see how we can make our app a bit more robust in </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">that sense.</span></span></p>
<p><span class="koboSpan" id="kobo.829.1">Weâ€™ll add a page that will be able to display errors to the user when they occur. </span><span class="koboSpan" id="kobo.829.2">Letâ€™s start with a new file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">views</span></strong><span class="koboSpan" id="kobo.831.1"> folder called </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">ErrorView.vue</span></strong><span class="koboSpan" id="kobo.833.1">. </span><span class="koboSpan" id="kobo.833.2">Just create a template with the </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">following contents:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.835.1">
&lt;template&gt;Â Â &lt;main&gt;
Â Â Â Â Oops!
</span><span class="koboSpan" id="kobo.835.2">Â Â &lt;/main&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.836.1">Weâ€™ll circle back to this file later. </span><span class="koboSpan" id="kobo.836.2">We can now at least create a new route in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">router/index.ts</span></strong><span class="koboSpan" id="kobo.838.1"> file, which just duplicates similar logic from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">search</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.840.1"> route:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.841.1">
import { createRouter, createWebHistory } from 'vue-router'import HomeView from '../views/HomeView.vue'
const router = createRouter({
Â Â history: createWebHistory(import.meta.env.BASE_URL),
Â Â routes: [
Â Â Â Â {
Â Â Â Â Â Â path: '/:page?',
Â Â Â Â Â Â name: 'home',
Â Â Â Â Â Â component: HomeView
Â Â Â Â },
Â Â Â Â {
Â Â Â Â Â Â path: '/search',
Â Â Â Â Â Â name: 'search',
Â Â Â Â Â Â component: () =&gt; import('../views/SearchView.vue')
Â Â Â Â }</span><strong class="bold"><span class="koboSpan" id="kobo.842.1">,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.843.1">Â Â Â Â {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.844.1">Â Â Â Â Â Â path: '/error',</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.845.1">Â Â Â Â Â Â name: 'error',</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.846.1">Â Â Â Â Â Â component: () =&gt; import('../views/ErrorView.vue')</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.847.1">Â Â Â Â }</span></strong><span class="koboSpan" id="kobo.848.1">
Â Â ]
})
export default router</span></pre>
<p><span class="koboSpan" id="kobo.849.1">If we then navigate to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">/error</span></strong><span class="koboSpan" id="kobo.851.1"> route in the app, we should see our </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">errorpage</span></strong><span class="koboSpan" id="kobo.853.1">. </span><span class="koboSpan" id="kobo.853.2">Since the data is coming</span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.854.1"> from an external API, we canâ€™t control it. </span><span class="koboSpan" id="kobo.854.2">This makes it an obvious weakness in </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">the app.</span></span></p>
<p><span class="koboSpan" id="kobo.856.1">On top of that, it is common practice to code defensively. </span><span class="koboSpan" id="kobo.856.2">If we look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">marvelApi</span></strong><span class="koboSpan" id="kobo.858.1"> composable file, we can add some safeguards around the composables that weâ€™re using in </span><span class="No-Break"><span class="koboSpan" id="kobo.859.1">the app:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.860.1">
export const useComics = async (page: number = 0): Promise&lt;Comics&gt; =&gt; {</span><strong class="bold"><span class="koboSpan" id="kobo.861.1">Â Â try {</span></strong><span class="koboSpan" id="kobo.862.1">
Â Â Â Â return await useMarvelAPI(Path.COMICS, { page }) as Comics
</span><strong class="bold"><span class="koboSpan" id="kobo.863.1">Â Â } catch {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.864.1">Â Â Â Â throw new Error('An error occurred while trying to read comics');</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.865.1">Â Â }</span></strong><span class="koboSpan" id="kobo.866.1">
}
export const useCharacterSearch = async (query: string, page: number = 0): Promise&lt;Characters&gt; =&gt; {
</span><strong class="bold"><span class="koboSpan" id="kobo.867.1">Â Â try {</span></strong><span class="koboSpan" id="kobo.868.1">
Â Â Â Â return await useMarvelAPI(Path.CHARACTERS, { query: nameStartsWith=${query}, page }) as Characters
</span><strong class="bold"><span class="koboSpan" id="kobo.869.1">Â Â } catch {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.870.1">Â Â Â Â throw new Error('An error occurred while trying to search comics');</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.871.1">Â Â }</span></strong><span class="koboSpan" id="kobo.872.1">
}</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.873.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.874.1">You could also consider adding these </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">try</span></strong><span class="koboSpan" id="kobo.876.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">catch</span></strong><span class="koboSpan" id="kobo.878.1"> blocks on </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">useFetch</span></strong><span class="koboSpan" id="kobo.880.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">useMarvelAPI</span></strong><span class="koboSpan" id="kobo.882.1">. </span><span class="koboSpan" id="kobo.882.2">On error, the error will propagate upwards through the call stack, which means it will be caught at the </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">highest level.</span></span></p>
<p><span class="koboSpan" id="kobo.884.1">Weâ€™re going to simulate</span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.885.1"> erroneous behavior in order to develop for these unforeseen circumstances. </span><span class="koboSpan" id="kobo.885.2">An easy way of doing this is to go to your </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">.env</span></strong><span class="koboSpan" id="kobo.887.1"> file and temporarily rename the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">VITE_APP_MARVEL_API_PUBLIC</span></strong><span class="koboSpan" id="kobo.889.1"> variable to </span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">VITE_APP_MARVEL_API_PUBLIC_ERROR</span></strong><span class="koboSpan" id="kobo.891.1">. </span><span class="koboSpan" id="kobo.891.2">We will change it back once weâ€™re done! </span><span class="koboSpan" id="kobo.891.3">If you run the app, it will not be able to request anything, and you</span><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.892.1"> will see the error message</span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.893.1"> weâ€™ve set in </span><span class="No-Break"><span class="koboSpan" id="kobo.894.1">the console.</span></span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.895.1">Handling the error</span></h2>
<p><span class="koboSpan" id="kobo.896.1">Now weâ€™ll focus on dealing</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.897.1"> with the error in a user-friendly way. </span><span class="koboSpan" id="kobo.897.2">Letâ€™s start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">ComicsOverview.vue</span></strong><span class="koboSpan" id="kobo.899.1"> file. </span><span class="koboSpan" id="kobo.899.2">Weâ€™ll wrap the contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">getComics</span></strong><span class="koboSpan" id="kobo.901.1"> function with another </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">try</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">/</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">catch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.905.1"> block.</span></span></p>
<p><span class="koboSpan" id="kobo.906.1">In this case, the user cannot recover the state from this error, so it doesnâ€™t make sense to remain on this page, since itâ€™s completely broken. </span><span class="koboSpan" id="kobo.906.2">Weâ€™ll redirect the user to our error page instead. </span><span class="koboSpan" id="kobo.906.3">This means weâ€™ll import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">useRouter</span></strong><span class="koboSpan" id="kobo.908.1"> composable from </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">vue-router</span></strong><span class="koboSpan" id="kobo.910.1"> and instantiate it on the component. </span><span class="koboSpan" id="kobo.910.2">Weâ€™ll modify file and specifically the </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">getComics</span></strong><span class="koboSpan" id="kobo.912.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.913.1">accordingly: </span></span><a href="https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.7-ComicsOverview.vue"><span class="No-Break"><span class="koboSpan" id="kobo.914.1">https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.7-ComicsOverview.vue</span></span></a></p>
<p><span class="koboSpan" id="kobo.915.1">Weâ€™re importing (</span><em class="italic"><span class="koboSpan" id="kobo.916.1">line 4</span></em><span class="koboSpan" id="kobo.917.1">) and registering the router (</span><em class="italic"><span class="koboSpan" id="kobo.918.1">line 14</span></em><span class="koboSpan" id="kobo.919.1">) and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">router</span></strong><span class="koboSpan" id="kobo.921.1"> to redirect to a new route when an error occurs (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.922.1">lines 27-29</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.923.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.924.1">Next, weâ€™ll create a component to show in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">ErrorView.vue</span></strong><span class="koboSpan" id="kobo.926.1">. </span><span class="koboSpan" id="kobo.926.2">Letâ€™s create a new component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">ErrorMessage.vue</span></strong><span class="koboSpan" id="kobo.928.1"> with some </span><span class="No-Break"><span class="koboSpan" id="kobo.929.1">static content:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.930.1">
&lt;template&gt;Â Â &lt;article
Â Â Â Â class="p-4 mx-4 my-24 bg-white rounded-lg shadow-xl place-content-center text-slate-800"
Â Â &gt;
Â Â Â Â &lt;header&gt;
Â Â Â Â Â Â &lt;h1 class="pb-5 text-lg font-semibold"&gt;Oops! </span><span class="koboSpan" id="kobo.930.2">ğŸ¤­&lt;/h1&gt;
Â Â Â Â &lt;/header&gt;
Â Â Â Â Something went wrong!
</span><span class="koboSpan" id="kobo.930.3">Â Â &lt;/article&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.931.1">And weâ€™ll update </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">ErrorView.vue</span></strong><span class="koboSpan" id="kobo.933.1"> to load </span><span class="No-Break"><span class="koboSpan" id="kobo.934.1">the component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.935.1">
&lt;script setup lang="ts"&gt;</span><strong class="bold"><span class="koboSpan" id="kobo.936.1">import ErrorMessage from '@/components/ErrorMessage.vue'</span></strong><span class="koboSpan" id="kobo.937.1">
&lt;/script&gt;
&lt;template&gt;
Â Â &lt;main&gt;
Â Â Â Â </span><strong class="bold"><span class="koboSpan" id="kobo.938.1">&lt;ErrorMessage /&gt;</span></strong><span class="koboSpan" id="kobo.939.1">
Â Â &lt;/main&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.940.1">If we run our code, we should</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.941.1"> get redirected to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">/error</span></strong><span class="koboSpan" id="kobo.943.1"> path as long as the API treats us as if weâ€™re not authorized. </span><span class="koboSpan" id="kobo.943.2">Weâ€™ll add </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">errorhandling</span></strong><span class="koboSpan" id="kobo.945.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">SearchCharacter.vue</span></strong><span class="koboSpan" id="kobo.947.1"> as well in </span><span class="No-Break"><span class="koboSpan" id="kobo.948.1">similar fashion:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.949.1">
&lt;script lang="ts" setup&gt;import { ref } from "vue";
import type { Ref } from "vue";
</span><strong class="bold"><span class="koboSpan" id="kobo.950.1">import { useRouter } from "vue-router";</span></strong><span class="koboSpan" id="kobo.951.1">
// â€¦ abbreviated
const router = useRouter();
// â€¦ abbreviated
const getCharacterSearch = async (query: string, page: number = 0) =&gt; {
Â Â </span><strong class="bold"><span class="koboSpan" id="kobo.952.1">try {</span></strong><span class="koboSpan" id="kobo.953.1">
Â Â Â Â if (query !== "") {
Â Â Â Â Â Â isSearching.value = true;
Â Â Â Â Â Â searchQuery.value = query;
Â Â Â Â Â Â const search = await useCharacterSearch(query, page);
Â Â Â Â Â Â currentPage.value = search?.offset / search?.limit || 0;
Â Â Â Â Â Â totalPages.value = Math.ceil(search.total / search.limit);
Â Â Â Â Â Â data.value = search.results;
Â Â Â Â Â Â isSearching.value = false;
Â Â Â Â } else {
Â Â Â Â Â Â searchReset();
Â Â Â Â }
Â Â </span><strong class="bold"><span class="koboSpan" id="kobo.954.1">} catch (e) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.955.1">Â Â Â Â router.push("/error");</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.956.1">Â Â }</span></strong><span class="koboSpan" id="kobo.957.1">
};
// â€¦ abbreviated
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.958.1">In this case, after youâ€™ve attempted</span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.959.1"> a search, the app will redirect to the same page. </span><span class="koboSpan" id="kobo.959.2">It would be nice if we could provide a bit of context to our user, so they can better understand what went wrong. </span><span class="koboSpan" id="kobo.959.3">Fortunately, we have acces</span><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.960.1">s to the error message weâ€™ve thrown in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.961.1">catch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.962.1"> block.</span></span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.963.1">Adding query parameters</span></h2>
<p><span class="koboSpan" id="kobo.964.1">Weâ€™ll modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">router.push</span></strong><span class="koboSpan" id="kobo.966.1"> action so that it passes some </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.967.1">additional information to </span><span class="No-Break"><span class="koboSpan" id="kobo.968.1">the destination.</span></span></p>
<p><span class="koboSpan" id="kobo.969.1">Itâ€™s an easy change that weâ€™ll apply to both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">ComicsOverview.vue</span></strong><span class="koboSpan" id="kobo.971.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">SearchCharacter.vue</span></strong><span class="koboSpan" id="kobo.973.1"> line. </span><span class="koboSpan" id="kobo.973.2">Letâ€™s </span><span class="No-Break"><span class="koboSpan" id="kobo.974.1">change this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.975.1">
} catch (e) {Â Â router.push("/error");
}</span></pre>
<p><span class="koboSpan" id="kobo.976.1">And weâ€™ll change it so that it provides information on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">query</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.978.1"> parameter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.979.1">
} catch (e) {</span><strong class="bold"><span class="koboSpan" id="kobo.980.1">Â Â router.push({ path: 'error', query: { info: e as string }})</span></strong><span class="koboSpan" id="kobo.981.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.982.1">In this case, weâ€™ll pass the message from the error message as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">query</span></strong><span class="koboSpan" id="kobo.984.1"> parameter to the route. </span><span class="koboSpan" id="kobo.984.2">Note that it is not meant to send a large amount of text, but it serves as a good example of using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">query</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.986.1"> parameters.</span></span></p>
<p><span class="koboSpan" id="kobo.987.1">Lastly, we can modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.988.1">ErrorMessage.vue</span></strong><span class="koboSpan" id="kobo.989.1"> file to read into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">query</span></strong><span class="koboSpan" id="kobo.991.1"> parameter in order to show it on the component. </span><span class="koboSpan" id="kobo.991.2">We can achieve that by reading into the route by utilizing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">useRoute</span></strong><span class="koboSpan" id="kobo.993.1"> composable once the component is mounted. </span><span class="koboSpan" id="kobo.993.2">The file would look </span><span class="No-Break"><span class="koboSpan" id="kobo.994.1">like this:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.995.1">&lt;script setup lang="ts"&gt;</span></strong><strong class="bold"><span class="koboSpan" id="kobo.996.1">import { ref, onMounted } from "vue";</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.997.1">import type { Ref } from "vue";</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.998.1">import { useRoute } from "vue-router";</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.999.1">const route = useRoute();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1000.1">const errorMessage: Ref&lt;string&gt; = ref("");</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1001.1">onMounted((): void =&gt; {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1002.1">Â Â errorMessage.value = route.query.info as string;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1003.1">});</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1004.1">&lt;/script&gt;</span></strong><span class="koboSpan" id="kobo.1005.1">
&lt;template&gt;
Â Â &lt;article
Â Â Â Â class="p-4 mx-4 my-24 bg-white rounded-lg shadow-xl place-content-center text-slate-800"
Â Â &gt;
Â Â Â Â &lt;header&gt;
Â Â Â Â Â Â &lt;h1 class="pb-5 text-lg font-semibold"&gt;Oops! </span><span class="koboSpan" id="kobo.1005.2">ğŸ¤­&lt;/h1&gt;
Â Â Â Â &lt;/header&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.1006.1">Â Â Â Â {{ errorMessage }}</span></strong><span class="koboSpan" id="kobo.1007.1">
Â Â &lt;/article&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.1008.1">If you now end up in the error state, you should see a message stating more accurately what went wrong. </span><span class="koboSpan" id="kobo.1008.2">Donâ€™t forget to rename your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">VITE_APP_MARVEL_API_PUBLIC</span></strong><span class="koboSpan" id="kobo.1010.1"> variable once </span><span class="No-Break"><span class="koboSpan" id="kobo.1011.1">youâ€™re done!</span></span></p>
<p><span class="koboSpan" id="kobo.1012.1">At this point weâ€™ve made good progress on pretty common techniques and principles. </span><span class="koboSpan" id="kobo.1012.2">In this chapter, we have introduced composables to the app, which bring reusable functionalities. </span><span class="koboSpan" id="kobo.1012.3">Weâ€™ve also added client side routing and were able to create links in our appsâ€™ user interface as well as apply dynamic routing and passing </span><span class="No-Break"><span class="koboSpan" id="kobo.1013.1">additional parameters.</span></span></p>
<p><span class="koboSpan" id="kobo.1014.1">As an extra bonus, weâ€™ve introduced basic</span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.1015.1"> error handling </span><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.1016.1">and learned a bit more about favorite Marvel </span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1">comic books.</span></span></p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.1018.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1019.1">In this chapter, weâ€™ve learned how to add multiple pages and navigate by several means: by using the router-link component or manipulating the routes programmatically. </span><span class="koboSpan" id="kobo.1019.2">Weâ€™ve created composables in order to use and reuse logic within our application. </span><span class="koboSpan" id="kobo.1019.3">For a better user experience, we learned how we can handle errors in a </span><span class="No-Break"><span class="koboSpan" id="kobo.1020.1">user-friendly manner.</span></span></p>
<p><span class="koboSpan" id="kobo.1021.1">In our next chapter, weâ€™ll build an application using Vuetify, a third-party component library. </span><span class="koboSpan" id="kobo.1021.2">Component libraries allow us to speed up development by making use of ready-made components. </span><span class="koboSpan" id="kobo.1021.3">In addition, weâ€™ll introduce an application state using Pinia, where we can modularly store data (or a state) to be shared between components throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.1022.1">our application.</span></span></p>
</div>


<div class="Content" id="_idContainer036">
<h1 id="_idParaDest-85" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.1.1">Part 2: Intermediate Projects</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part, you will iterate on using external APIs to build data-rich applications. </span><span class="koboSpan" id="kobo.2.2">You will also learn how to handle more complex application state, apply the basics of data storage and retrieval, and identify when and how to use short-term storage or long-term, persistent storage solutions. </span><span class="koboSpan" id="kobo.2.3">You will be introduced to using web technologies to build applications beyond the web and deploy </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">them anywhere.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B19563_05.xhtml#_idTextAnchor130"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Building a Recipe App with Vuetify</span></em></li>
<li><a href="B19563_06.xhtml#_idTextAnchor162"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Creating a Fitness Tracker with Data Visualization</span></em></li>
<li><a href="B19563_07.xhtml#_idTextAnchor204"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Building a Multi-Platform Expense Tracker Using Quasar</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer037">
</div>
</div>
<div>
<div id="_idContainer038">
</div>
</div>
<div>
<div id="_idContainer039">
</div>
</div>
<div>
<div id="_idContainer040">
</div>
</div>
<div>
<div id="_idContainer041">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer042">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer043">
</div>
</div>
<div>
<div id="_idContainer044">
</div>
</div>
<div>
<div id="_idContainer045">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer046">
</div>
</div>
</body></html>