- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing Authentication and Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing a high-quality **authentication** and **authorization** system without
    frustrating the end user is a difficult problem to solve. Authentication is the
    act of verifying the identity of a user, and authorization specifies the privileges
    that a user must have to access a resource. Both processes, **auth** for short,
    must seamlessly work in tandem to address users’ needs with varying roles, needs,
    and job functions.
  prefs: []
  type: TYPE_NORMAL
- en: On today’s web, users have a high baseline level of expectations from any auth
    system they encounter through the browser, so this is an important part of your
    application to get right the first time. The user should always know what they
    can and can’t do in your application. If there are errors, failures, or mistakes,
    the user should be informed about why they occurred. As your application grows,
    it will be easy to miss how an error condition could be triggered. Your implementation
    should be easy to extend or maintain. Otherwise, this basic backbone of your application
    will require a lot of maintenance. In this chapter, we will walk through the challenges
    of creating a great auth UX and implementing a solid baseline experience.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will implement a token-based auth scheme around the user
    entity defined in the last chapter. For a robust and maintainable implementation,
    we will deep dive into **Object-Oriented Programming** (**OOP**) with abstraction,
    inheritance, and factories, along with implementing a cache service, a UI service,
    and an in-memory fake auth service for testing and educational purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing an auth workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript operators for safe data handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing data entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusable services leveraging OOP concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an auth service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A cache service using localStorage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An in-memory auth service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An HTTP interceptor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the following linked repository. The repository contains the final and completed
    state of the code. You can verify your progress at the end of this chapter by
    looking for the end-of-chapter snapshot of code under the `projects` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'For *Chapter 5*:'
  prefs: []
  type: TYPE_NORMAL
- en: Clone the repository [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm install` on the root folder to install dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The beginning state of the project is reflected at:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The end state of the project is reflected at:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the stage name to any `ng` command to act only on that stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `dist/stage8` folder at the root of the repository will contain
    the compiled result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Beware that the source code provided in the book and the version on GitHub are
    likely to be different. The ecosystem around these projects is ever-evolving.
    Between changes to how Angular CLI generates new code, bug fixes, new versions
    of libraries, and side-by-side implementations of multiple techniques, there’s
    a lot of variation that’s impossible to account for. If you find errors or have
    questions, please create an issue or submit a pull request on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by going over how a token-based auth workflow functions.
  prefs: []
  type: TYPE_NORMAL
- en: Designing an auth workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A well-designed authentication workflow is stateless so that there’s no concept
    of an expiring session. Users can interact with your stateless REST APIs from
    as many devices and tabs as they wish, simultaneously or over time. A **JSON Web
    Token** (**JWT**) implements distributed claims-based authentication that can
    be digitally signed or information-protected and/or encrypted, using a **Message
    Authentication Code** (**MAC**). This means that once a user’s identity is authenticated
    (that is, a password challenge on a login form), they receive an encoded claim
    ticket or a token, which can then be used to make future requests to the system
    without having to reauthenticate the identity of the user.
  prefs: []
  type: TYPE_NORMAL
- en: The server can independently verify the validity of this claim and process the
    requests without requiring prior knowledge of having interacted with this user.
    Thus, we don’t have to store session information regarding a user, making our
    solution stateless and easy to scale. Each token will expire after a predefined
    period, and due to their distributed nature, they can’t be remotely or individually
    revoked; however, we can bolster real-time security by interjecting custom account
    and user role status checks to ensure that the authenticated user is authorized
    to access server-side resources.
  prefs: []
  type: TYPE_NORMAL
- en: JWTs implement the **Internet Engineering Task Force** (**IETF**) industry standard
    RFC 7519, found at [https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519).
  prefs: []
  type: TYPE_NORMAL
- en: A good authorization workflow enables conditional navigation based on a user’s
    role, so users are automatically taken to the optimal landing screen; routes and
    UI elements that are not suitable for their roles should not be displayed, and
    if, by mistake, they try to access a restricted path, they should be prevented
    from doing so. You must remember that any client-side role-based navigation is
    merely a convenience and is not meant for security.
  prefs: []
  type: TYPE_NORMAL
- en: This means that every call made to the server should contain the necessary header
    information, with the secure token, so that the user can be reauthenticated by
    the server and their role independently verified. Only then will they be allowed
    to retrieve secured data. By its nature, client-side authentication can’t be trusted.
    All auth logic must be implemented server-side. Implementing password reset screens
    securely can be especially challenging, since they can be triggered within your
    web app or via a link embedded into an email/notification. When the modality of
    interaction increases, the attack surface grows with it. For this reason, I recommend
    building reset screens with server-side rendering so that both the user and the
    server can verify that the intended user is interacting with the system. If you’re
    implementing this client-side, you must ensure the server generates a time-limited,
    one-time-use-only token to pass alongside the new password so that you can be
    reasonably sure the request is legitimate. Next, let’s dive into how you can generate
    secure tokens.
  prefs: []
  type: TYPE_NORMAL
- en: JWT life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JWTs complement a stateless REST API architecture with an encrypted token mechanism
    that allows convenient, distributed, and high-performance authentication and authorization
    of client requests. There are three main components of a token-based authentication
    scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-side**: Captures login information and hides disallowed actions for
    a good UX.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server-side**: Validates that every request is authenticated and has the
    proper authorization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auth service**: Generates and validates encrypted tokens and independently
    verifies the auth status of user requests from a data store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A secure system presumes that data sent/received between clients (applications
    and browsers), systems (servers and services), and databases are encrypted using
    **Transport Layer Security** (**TLS**), which is essentially a newer version of
    the **Secure Sockets Layer** (**SSL**). Your REST API must be hosted with a properly
    configured SSL certificate, serving all API calls over HTTPS so that user credentials
    are never exposed between the client and the server. Similarly, any database or
    third-party service call should happen over TLS. This ensures the security of
    the data in transit.
  prefs: []
  type: TYPE_NORMAL
- en: At rest (when data is in a database), passwords should be stored using a secure
    one-way hashing algorithm with good salting practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Did all the talk of hashing and salting make you think of breakfast? Unfortunately,
    they’re cryptography-related terms. If you want to learn more, check out this
    article: [https://crackstation.net/hashing-security.htm](https://crackstation.net/hashing-security.htm).'
  prefs: []
  type: TYPE_NORMAL
- en: Sensitive user information, such as **Personally Identifiable Information**
    (**PII**), should be encrypted at rest with a secure two-way encryption algorithm,
    unlike passwords. Passwords are hashed, so we verify that the user is providing
    the same password without the system knowing what the password is. With PII, we
    must be able to decrypt data to display it to the user. However, since the data
    is encrypted at rest, if the database is compromised, then the hacked data is
    worthless.
  prefs: []
  type: TYPE_NORMAL
- en: Following a layered approach to security is critical, as attackers will need
    to accomplish the unlikely feat of compromising all layers of your security simultaneously
    to cause meaningful harm to your business.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fun fact**: When you hear about massive data breaches from major corporations,
    the root cause is a lack of proper implementation of in-transit or at-rest security.
    Sometimes, this is because it is too computationally expensive to continually
    encrypt/decrypt data, so engineers rely on being behind firewalls. In that case,
    once the outer perimeter is breached, as they say, the fox has access to the hen
    house.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following sequence diagram, which highlights the life cycle of
    JWT-based authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: The life cycle of JWT-based authentication'
  prefs: []
  type: TYPE_NORMAL
- en: Initially, a user logs in by providing their username and password. Once validated,
    the user’s authentication status and role are encrypted in a JWT with an expiration
    date and time, and it is sent back to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Our Angular (or any other) application can cache this token in local or session
    storage securely so that the user isn’t forced to log in with every request. This
    way, we don’t resort to insecure practices like storing user credentials in cookies
    to provide a good UX.
  prefs: []
  type: TYPE_NORMAL
- en: Our technical reviewer, Jurgen Van de Moere, points out that cookies don’t necessarily
    have to be insecure.
  prefs: []
  type: TYPE_NORMAL
- en: See [https://www.youtube.com/watch?v=9ZOpUtQ_4Uk](https://www.youtube.com/watch?v=9ZOpUtQ_4Uk)
    by Philippe De Ryck, explaining how cookies can be a valid mechanism to store
    a JWT token in specific cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will get a better understanding of the JWT life cycle when you implement
    your own auth service later in this chapter. In the following sections, we will
    design a fully featured auth workflow around the **User** data entity as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: The User entity'
  prefs: []
  type: TYPE_NORMAL
- en: The **User** entity described is slightly different from our initial entity
    model. The entity model reflects how data is stored in the database.
  prefs: []
  type: TYPE_NORMAL
- en: The entity is a flattened (or simplified) representation of the user record.
    Even a flattened entity has complex objects, like a **name**, with properties
    like first, middle, and last. Furthermore, not all properties are required. Additionally,
    when interacting with auth systems and other APIs, we may receive incomplete,
    incorrect, or maliciously formed data, so our code must effectively deal with
    `null` and `undefined` variables.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s see how we can leverage TypeScript operators to effectively deal
    with unexpected data.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript operators for safe data handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is a dynamically typed language. At runtime, the JavaScript engine
    executing our code, like Chrome’s V8, doesn’t know the type of variable we’re
    using. As a result, the engine must infer the type. We can have basic types like
    `boolean`, `number`, `array`, or `string`, or we can have a complex type, which
    is essentially a JSON object. In addition, variables can be `null` or `undefined`.
    In broad terms, `undefined` represents something that hasn’t been declared or
    initialized, and `null` represents the intentional absence of the value of a declared
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: In strongly typed languages, the concept of `undefined` doesn’t exist. Basic
    types have default values, like a `number` being a zero or a `string` being an
    empty string. However, complex types can be `null`. A `null` reference means the
    variable is defined, but there’s no value behind it.
  prefs: []
  type: TYPE_NORMAL
- en: The inventor of the `null` reference, Tony Hoare, called it his “billion-dollar
    mistake.”
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript brings the concepts of strongly typed languages to JavaScript, so
    it must bridge the gap between the two worlds. As a result, TypeScript defines
    types like `null`, `undefined`, `any`, and `never` to make sense of JavaScript’s
    type semantics. I’ve added links to relevant TypeScript documentation in the *Further
    reading* section for a deeper dive into TypeScript types.
  prefs: []
  type: TYPE_NORMAL
- en: As the TypeScript documentation puts it, TypeScript treats `null` and `undefined`
    differently to match the JavaScript semantics. For example, the union type `string
    | null` is a different type than `string | undefined` and `string | undefined
    | null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s another nuance: checking to see whether a value equals `null` using
    `==` versus `===`. Using the double equals operator, checking that `foo != null`
    means that `foo` is defined and not `null`. However, using the triple-equals operator,
    `foo !== null` means that `foo` is not `null` but could be `undefined`. However,
    these two operators don’t consider the truthiness of the variable, which includes
    the case of an empty string.'
  prefs: []
  type: TYPE_NORMAL
- en: These subtle differences have a great impact on how you write code, especially
    when using the strict TypeScript rules that are applied when you create your Angular
    application using the `--strict` option. It is important to remember that TypeScript
    is a compile-time tool and not a runtime tool. At runtime, we’re still dealing
    with the realities of a dynamically typed language. Just because we declared a
    type to be a string doesn’t mean that we will receive a string.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s see how we can deal with issues related to working with unexpected
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Null and undefined checking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with other libraries or dealing with information sent or received
    outside of your application, you must deal with the fact that the variable you
    receive might be `null` or `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: Outside of your application means dealing with user input, reading from a cookie
    or `localStorage`, URL parameters from the router, or an API call over HTTP, to
    name a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our code, we mostly care about the truthiness of a variable. This means
    that a variable is defined, not null, and if it’s a basic type, it has a non-default
    value. Given a `string`, we can check whether the `string` is truthy with a simple
    `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If `foo` is `null`, `undefined`, or an empty string, the variable will be considered
    `falsy`. For certain situations, we can use the conditional or ternary operator
    instead of `if-else`.
  prefs: []
  type: TYPE_NORMAL
- en: The conditional or ternary operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The conditional or ternary operator has the `?:` syntax. On the left-hand side
    of the question mark, the operator takes a conditional statement. On the right-hand
    side, we provide the outcomes for true and false around the colon: `conditional
    ? true-outcome : false-outcome`. The conditional or ternary operator is a compact
    way to represent `if-else` conditions and can be very useful to increase the readability
    of your code base. This operator is not a replacement for an `if-else` block,
    but it is of great use when using the output of the `if-else` condition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `if-else` block can be rewritten as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the conditional or ternary operator makes the code more compact
    and easier to understand. Another common scenario is returning a default value,
    where the variable is `falsy`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we consider the null coalescing operator.
  prefs: []
  type: TYPE_NORMAL
- en: The null coalescing operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The null coalescing operator is `||`. This operator saves us from repetition
    when the truthy result of the conditional is the same as the conditional itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the example where if `foo` is defined, we would like to use the value
    of `foo`, but if it is `undefined`, we need a default value of `''bar''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `foo` is repeated twice. We can avoid the duplication by using
    the null coalescing operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So, if `foo` is `undefined`, `null,` or an empty string, `bar` will be output.
    Otherwise, the value of `foo` will be used. But in some cases, we need only to
    use the default value if the value is `undefined` or `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at the nullish coalescing operator next.
  prefs: []
  type: TYPE_NORMAL
- en: The nullish coalescing operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The nullish coalescing operator is `??`. This operator is like the null coalescing
    operator, with one crucial difference. Checking the truthiness of a variable is
    not enough when dealing with data received from an API or user input, where an
    empty string may be a valid value. As we covered earlier in this section, checking
    for `null` and `undefined` is not as straightforward as it seems. However, we
    know that by using the double equals operator, we can ensure that `foo` is defined
    and not null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding case, if `foo` is an empty string or another value, we will
    get the value of the `foo` output. If it is `null` or `undefined`, we will get
    `''bar''`. A more compact way to do this is by using the nullish coalescing operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will yield the same result as the previous example. However,
    when dealing with complex objects, we need to consider whether their properties
    are `null` or `undefined` as well. For this, we will consider the optional chaining
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: Optional chaining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The optional chaining operator is `?`. It is like Angular’s safe navigation
    operator. Optional chaining ensures that a variable or property is defined and
    not `null` before attempting to access a child property or invoke a function.
    So the statement `foo?.bar?.callMe()` executes without throwing an error, even
    if `foo` or `bar` is `null` or `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the `user` entity, which has a `name` object with properties for `first`,
    `middle`, and `last`. Let’s see what it would take to safely provide a default
    value of an empty string for a middle name, using the nullish coalescing operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we need to check whether a parent object is `truthy` before
    accessing a child property. If `middle` is `null`, an empty string is output.
    Optional chaining makes this task simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using optional chaining and the nullish coalescing operator together, we can
    eliminate repetition and deliver robust code that can effectively deal with the
    realities of JavaScript’s dynamic runtime.
  prefs: []
  type: TYPE_NORMAL
- en: So, when designing your code, you must decide whether to introduce the concept
    of null to your logic or work with default values like empty strings. In the next
    section, as we implement the User entity, you will see how these choices play
    out. So far, we have only used interfaces to define the shape of our data. Next,
    let’s build the User entity, leveraging OOP concepts like classes, enums, and
    abstraction to implement it, along with an auth service.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start simple and see how these patterns are implemented within the context
    of JavaScript classes and TypeScript fundamentals.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing data entities and interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I will demonstrate how you can use classes in your own code
    design to define and encapsulate the behavior of your models, such as the `User`
    class. Later in this chapter, you will see examples of class inheritance with
    abstract base classes, which allows us to standardize our implementation and reuse
    base functionality in a clean and easy-to-maintain manner.
  prefs: []
  type: TYPE_NORMAL
- en: I must point out that OOP has very useful patterns that can increase the quality
    of your code; however, if you overuse it, then you will start losing the benefits
    of the dynamic, flexible, and functional nature of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, all you need is a bunch of functions in a file, and you’ll see examples
    of that throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: A great way to demonstrate the value of classes would be to standardize the
    creation of a default `User` object. We need this because a `BehaviorSubject`
    object needs to be initialized with a default object. It is best to do this in
    one place, rather than copy and paste the same implementation in multiple places.
    It makes a lot of sense for the `User` object to own this functionality instead
    of an Angular service creating default `User` objects. So, let’s implement a `User`
    class to achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: Classes, Interfaces, and Enums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned, we have only worked with interfaces to represent data. We still
    want to continue using interfaces when passing data around various components
    and services. Interfaces are great for describing the kind of properties or functions
    an implementation has, but they suggest nothing about the behavior of these properties
    or functions.
  prefs: []
  type: TYPE_NORMAL
- en: With ES2015 (ES6), JavaScript gained native support for classes, which is a
    crucial concept of the OOP paradigm. Classes are actual implementations of behavior.
    As opposed to just having a collection of functions in a file, a class can properly
    encapsulate behavior. A class can then be instantiated as an object using the
    new keyword.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript takes the ES2015 (and beyond) implementation of classes and introduces
    necessary concepts like abstract classes, private, protected, and public properties,
    and interfaces to make it possible to implement OOP patterns.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by defining enums and interfaces for the data entities we need,
    utilizing the best two features of Typescript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interfaces help us practice the Dependency Inversion Principle from SOLID design:
    depend on abstractions, not on concretions. This means between components or services,
    it is better to pass the interface of an object (an instantiated class) instead
    of the object itself. This is why every class we define will implement an interface.
    Further, interfaces are usually the first thing you can start coding in a new
    project, using them to implement your walking skeleton and API integrations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enums help ensure another important rule: never use string literals. Enums
    are powerful and awesome.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s jump in and define the interfaces and enums we need:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define user roles as an `enum` at the location `src/app/auth/auth.enum.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a `user.ts` file under the `src/app/user/user` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a new interface named `IUser` in the `user.ts` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that every complex property defined on the interface can also be represented
    as a `string`. In transit, all objects are converted to strings using `JSON.stringify()`.
    No type of information is included. We also leverage interfaces to represent `Class`
    objects in memory, which can have complex types. So, our interface properties
    must reflect both cases using union types. For example, the `role` can either
    be of type `Role` or `string`. Similarly, `dateOfBirth` can be a `Date` or a `string`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We define the `address` as an inline type because we don’t use the concept of
    an address outside of this class. In contrast, we define `IName` as its own interface
    because in *Chapter 8*, *Recipes – Reusability, Forms, and Caching*, we will implement
    a separate component for names. We also define a separate interface for phones
    because they are represented as an array. When developing a form, we need to be
    able to address individual array elements, like `IPhone`, in the template code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is the norm to prepend interface names with a capital `I` so that they can
    be easily identified. Don’t worry; there are no compatibility issues with using
    the `IPhone` interface on Android phones!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `user.ts`, define the `IName` and `IPhone` interfaces, and implement the
    `PhoneType` enum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that in the `PhoneType` enum, we explicitly defined `string` values. By
    default, `enum` values are converted into strings as they’re typed, which can
    lead to issues with values stored in a database falling out of sync with how a
    developer chooses to spell a variable name. With explicit and all lowercase values,
    we reduce the risk of bugs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, define the `User` class, which implements the `IUser` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that by defining all properties with default values in the constructors
    as `public` properties, we kill two birds with one stone; otherwise, we would
    need to define properties and initialize them separately. This way, we achieve
    a concise implementation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using a static `Build` function, we can quickly hydrate the object with data
    received from the server. We can also implement the `toJSON()` function to customize
    the serialization behavior of our object before sending the data to the server.
    But before that, let’s add a calculated property.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can use calculated properties in templates or toast messages to conveniently
    display values assembled from multiple parts. A great example is extracting a
    full name from the `name` object as a property in the `User` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A calculated property for assembling a full name encapsulates the logic for
    combining a first, middle, and last name, so you don’t have to rewrite this logic
    in multiple places, adhering to the DRY principle!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement a `fullName` property getter in the `User` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `fullName` to `IUser` as an optional `readonly` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can now use the `fullName` property through the `IUser` interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the `toJSON` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that when serializing the object, we delete the `_id` and `fullName` fields.
    These are values that we don’t want to be stored in the database. The `fullName`
    field is a calculated property, so it doesn’t need storage. The `_id` is normally
    passed as a parameter in a `GET` or a `PUT` call to locate the record. This avoids
    mistakes that may result in overwriting the `id` fields of existing objects.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the `User data` entity implemented, let’s implement the auth
    service next.
  prefs: []
  type: TYPE_NORMAL
- en: Reusable services leveraging OOP concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OOP is an imperative programming style compared to the reactive programming
    style that RxJS enables. Classes form the bedrock of OOP, whereas observables
    do the same for reactive programming using RxJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'I encourage you to become familiar with OOP terminology. Please see the *Further
    reading* section for some useful resources. You should become familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes versus objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition (interfaces)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation (private, protected, and public properties, and property getters
    and setters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism (inheritance, abstract classes, and method overriding)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you know, Angular uses OOP patterns to implement components and services.
    For example, interfaces implement life cycle hooks such as `OnInit`. We aim to
    design a flexible auth service that can implement multiple auth providers. In
    *Chapter 6*, *Implementing Role-Based Navigation*, we will implement an in-memory
    provider and a Google Firebase provider. In *Chapter 7*, *Working with REST and
    GraphQL APIs*, we will implement two custom providers to interact with our backend
    and see how **Role-based Access Control** (**RBAC**) is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: By declaring an abstract base class, we can describe the common login and logout
    behavior of our application, so when we implement another auth provider, we don’t
    have to re-engineer our application.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we can declare abstract functions, which the implementors of our
    base class would have to implement, enforcing our design. Any class that implements
    the base class would also get the benefit of the code implemented in the base
    class, so we wouldn’t need to repeat the same logic in two different places.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class diagram reflects the architecture and inheritance hierarchy
    of our abstract `AuthService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: The AuthService inheritance structure'
  prefs: []
  type: TYPE_NORMAL
- en: '`AuthService` implements the interface `IAuthService`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The interface reflects the public properties that the service exposes. The service
    provides the authentication status as the `authStatus$` observable and the current
    user as `currentUser$`, and it provides three functions, `login`, `logout`, and
    `getToken`.
  prefs: []
  type: TYPE_NORMAL
- en: '`AuthService` requires caching functionality from another service called `CacheService`.
    Instead of using inheritance to incorporate cache functionality, we can inject
    it into the base class. Since `AuthService` is an abstract class, it can’t be
    used independently, so we will implement the three auth providers, `InMemoryAuthService`,
    `FirebaseAuthService`, and `CustomAuthService`, shown at the bottom of the preceding
    diagram.'
  prefs: []
  type: TYPE_NORMAL
- en: Composition is preferred over inheritance, so you must ensure you’re using inheritance
    correctly. Inheritance describes an is-a relationship and composition describes
    a has-a relationship. In this case, we’re using the correct mixture of inheritance
    and composition because `FirebaseAuthService` is an `AuthService`, and `AuthService`
    has a `CacheService`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that all three auth services implement all abstract functions. In addition,
    the `FirebaseAuthService` overrides the base `logout` function to implement its
    own behavior. All three classes inherit from the same abstract class and expose
    the same public interface. All three will execute the same auth workflow against
    different auth servers.
  prefs: []
  type: TYPE_NORMAL
- en: The in-memory auth service doesn’t communicate with a server. The service is
    for demonstration purposes only. It implements fake JWT encoding, so we can demonstrate
    how the JWT life cycle works.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by creating the auth service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an auth service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by creating the abstract auth service and the in-memory service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an auth service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Rename `in-memory-auth.service.ts` to `auth.in-memory.service.ts` so that the
    different auth providers visually group together in File Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the `@Injectable()` decorator of `auth.service.ts` , but keep it on `auth.in-memory.service.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that `authService` is provided in `app.module.ts` and that `InMemoryAuthService`
    is used and not the abstract class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating a separate folder for the service organizes various components related
    to auth, such as the `enum` definition for the user role. Additionally, we will
    be able to add an `authService` fake to the same folder for automated testing.
  prefs: []
  type: TYPE_NORMAL
- en: Implement an abstract auth service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s build an abstract auth service that will orchestrate logins and logouts
    while encapsulating the logic of managing JWTs, auth status, and information regarding
    the current user. By leveraging the abstract class, we should be able to implement
    our own auth service against any auth provider without modifying the internal
    behavior of our application.
  prefs: []
  type: TYPE_NORMAL
- en: The abstract auth service that we will demonstrate enables rich and intricate
    workflows. It is a solution that you can drop into your applications without modifying
    the internal logic. As a result, it is a complicated solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'This auth service will enable us to demonstrate logging in with an email and
    password, caching, and conditional navigation concepts based on authentication
    status and a user’s role:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by installing a JWT decoding library and, to fake authentication, a JWT
    encoding library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement an `IAuthStatus` interface to store decoded user information, a helper
    interface, and the secure by default `defaultAuthStatus`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`IAuthStatus` is an interface that represents the shape of a typical JWT that
    you may receive from your authentication service. It contains minimal information
    about the user and the user’s role. The auth status object can be attached to
    the header of every REST call to APIs to verify the user’s identity. The auth
    status can be optionally cached in `localStorage` to remember the user’s login
    state; otherwise, they would have to re-enter their password with every page refresh.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the preceding implementation, we assume the default role of `None`, as defined
    in the `Role` enum. By not giving any role to the user by default, we’re following
    a least-privileged access model. The user’s correct role will be set after they
    log in successfully with the information received from the auth API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the `IAuthService` interface in `auth.service.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make `AuthService` an `abstract` class, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the interface, `IAuthService`, using VS Code’s quick-fix functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `authStatus$` and `currentUser$` properties as `readonly` and
    initialize our data anchors with their default values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we removed the type definitions of the properties. Instead, we’re
    letting TypeScript infer the type from the initialization.
  prefs: []
  type: TYPE_NORMAL
- en: You must always declare your data anchors as `readonly` so that you don’t accidentally
    overwrite the data stream by re-initializing a data anchor as a new `BehaviorSubject`.
    Doing so would render any prior subscribers orphaned, leading to memory leaks,
    which has many unintended consequences.
  prefs: []
  type: TYPE_NORMAL
- en: All implementors of `IAuthService` must be able to log the user in, transform
    the token we get back from the server so that we can read and store it, support
    access to the current user and the auth status, and provide a way to log the user
    out. We have successfully put in the functions for our public methods and implemented
    default values for our data anchors, creating hooks for the rest of our application.
    But so far, we have only defined what our service can do and not how it can do
    it.
  prefs: []
  type: TYPE_NORMAL
- en: As always, the devil is in the details, and the hard part is the “how.” Abstract
    functions can help us to complete the implementation of a workflow in a service
    within our application, while leaving the portions of the service that must implement
    external APIs undefined.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Auth services that implement the abstract class should be able to support any
    kind of auth provider and any kind of token transformation while being able to
    modify behaviors, like user retrieval logic. We must be able to implement login,
    logout, token, and auth status management without implementing calls to specific
    services.
  prefs: []
  type: TYPE_NORMAL
- en: By defining abstract functions, we can declare a series of methods that must
    implement a given set of inputs and outputs—a signature without an implementation.
    We can then use these abstract functions to orchestrate the implementation of
    our auth workflow.
  prefs: []
  type: TYPE_NORMAL
- en: The Open/Closed principle drives our design goal here. The `AuthService` will
    be open to extension through its ability to be extended to work with any kind
    of token-based auth provider, but it is closed to modification. Once we’re done
    implementing the `AuthService`, we won’t need to modify its code to add additional
    auth providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to define the abstract functions that our auth providers must
    implement, as shown in *Figure 5.3* from earlier in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`authProvider(email, password)`: `Observable<IServerAuthResponse>` can log
    us in via a provider and return a standardized `IServerAuthResponse`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transformJwtToken(token)`: `IAuthStatus` can normalize the token a provider
    returns to the interface of `IAuthStatus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getCurrentUser()`: `Observable<User>` can retrieve the user profile of the
    logged-in user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can then use these functions in our `login`, `logout`, and `getToken` methods
    to implement the auth workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the abstract methods that the derived classes should implement as protected
    properties so that they’re accessible in the derived class, but not publicly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Leveraging these stubbed-out methods, we can now implement a login method to
    log a user in and retrieve the currently logged-in user, updating the `authStatus$`
    and `currentUser$` data streams.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before we move on, implement a `transformError` function to handle errors of
    different types like `HttpErrorResponse` and `string`, providing them in an observable
    stream. In a new file named `common.ts` under `src/app/common`, create the `transformError`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `auth.service.ts`, implement the `login` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `login` method encapsulates the correct order of operations by calling the
    `authProvider` with the `email` and `password` information, then decoding the
    received JWT, transforming it, and updating `authStatus$`. Then, `getCurrentUser()`
    is called only if `status.isAuthenticated` is `true`. Later, `currentUser$` is
    updated, and finally, we catch any errors using our custom `transformError` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We activate the observable stream by calling `subscribe` on it. In the case
    of an error, we call `logout()` to maintain the correct status of our application
    and bubble up errors to consumers of `login` by re-throwing the error, using `throwError`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, the corresponding `logout` function needs to be implemented. Logout is
    triggered by the **Logout** button from the application toolbar in the case of
    a failed login attempt, as shown earlier, or if an unauthorized access attempt
    is detected. We can detect unauthorized access attempts by using a router auth
    guard as the user navigates the application, which is a topic covered later in
    the chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the `logout` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We log out by pushing out the `defaultAuthStatus` as the next value in the `authStatus$`
    stream. Note the use of `setTimeout`, which allows us to avoid timing issues when
    core elements of the application all change statuses at once.
  prefs: []
  type: TYPE_NORMAL
- en: Think about how the `login` method adheres to the Open/Closed principle. The
    method is open to extension through the abstract functions `authProvider`, `transformJwtToken`,
    and `getCurrentUser`. By implementing these functions in a derived class, we can
    externally supply different auth providers without modifying the `login` method.
    As a result, the implementation of the method remains closed to modification,
    thus adhering to the Open/Closed principle.
  prefs: []
  type: TYPE_NORMAL
- en: The true value of creating abstract classes is the ability to encapsulate common
    functionality in an extensible way.
  prefs: []
  type: TYPE_NORMAL
- en: You may ignore the `getToken` function for now, as we are not yet caching our
    JWT. Without caching, the user would have to log in with every page refresh. Let’s
    implement caching next.
  prefs: []
  type: TYPE_NORMAL
- en: A cache service using localStorage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We must be able to cache the authentication status of the logged-in user. As
    mentioned, otherwise, with every page refresh, the user must go through the login
    routine. We need to update `AuthService` so that it persists the auth status.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main ways to store data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cookie`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localStorage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sessionStorage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cookies, while they have their use cases, should not be used to store secure
    data because they can be sniffed or stolen by bad actors. In addition, cookies
    can store only 4 KB of data and can be set to expire.
  prefs: []
  type: TYPE_NORMAL
- en: '`localStorage` and `sessionStorage` are similar. They are protected and isolated
    browser-side stores that allow the storage of larger amounts of data for your
    application. Unlike cookies, you can’t set an expiration date-time on values stored
    in either store. Values stored in either store survive page reloads and restores,
    making them better candidates than cookies for caching information.'
  prefs: []
  type: TYPE_NORMAL
- en: The major difference between `localStorage` and `sessionStorage` is how values
    are persisted across browser tabs. With `sessionStorage`, stored values are removed
    when the browser tab or window is closed. However, `localStorage` persists across
    reboots. In most cases, user logins are cached anywhere from minutes to a month
    or more, depending on your business, so relying on whether the user closes the
    browser window isn’t very useful. Through this process of elimination, I prefer
    `localStorage` because of its isolation and long-term storage capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: JWTs can be encrypted and include a timestamp for expiration. In theory, this
    counters the weaknesses of both cookies and `localStorage`. If implemented correctly,
    either option should be secure for use with JWTs, but `localStorage` is still
    preferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by implementing a caching service that can provide a centralized
    caching method for our application. We can then derive from this service to cache
    our authentication information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating an abstract `cacheService` that encapsulates the method of
    caching:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This cache service class can give caching capabilities to any service. While
    it creates a centralized caching method you can inject into another service, it
    is not meant to be a centralized value store. You should never use it to synchronize
    state, so we can avoid introducing side effects and coupling between services
    and components.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update `AuthService` to inject the `CacheService`, which will enable us to
    implement caching of the JWT in the next section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s go over an example of how to use the base class’s functionality by caching
    the value of the `authStatus` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The technique demonstrated in the example leverages RxJS observable streams
    to update the cache whenever the value of `authStatus$` changes. You can use this
    pattern to persist any kind of data without cluttering your business logic with
    caching code. In this case, we wouldn’t need to update the `login` function to
    call `setItem` because it already calls `this.authStatus.next`, and we can just
    tap into the data stream. This helps with staying stateless and avoiding side
    effects, by decoupling functions from each other.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we also initialize the `BehaviorSubject` using the `getItem` function.
    Using the nullish coalescing operator, we only use cached data if it is not `undefined`
    or `null`. Otherwise, we provide the default value.
  prefs: []
  type: TYPE_NORMAL
- en: You can implement your own custom cache expiration scheme in the `setItem` and
    `getItem` functions or leverage a service created by a third party.
  prefs: []
  type: TYPE_NORMAL
- en: However, for an additional layer of security, we won’t cache the `authStatus`
    object. Instead, we will only cache the encoded JWT, which contains just enough
    information, so we can authenticate requests sent to the server.
  prefs: []
  type: TYPE_NORMAL
- en: In the Implementing JWT auth section of *Chapter 7*, *Working with REST and
    GraphQL APIs,* we discuss how you should encrypt and verify JWT token validity
    to avoid token-based exploits.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand how token-based authentication works to avoid
    revealing compromising secrets. Review the JWT life cycle earlier in this chapter
    to improve your understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s cache the token.
  prefs: []
  type: TYPE_NORMAL
- en: Caching the JWT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s update the authentication service so that it can cache the token:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `AuthService` to be able to set, get, and clear the token, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call `clearToken` and `setToken` during `login`, and `clearToken` during `logout`,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Every subsequent request will contain the JWT in the request header. You should
    secure every API to check for and validate the token received. For example, if
    a user wants to access their profile, the `AuthService` will validate the token
    to check whether the user is authenticated or not; however, a further database
    call will still be required to check whether the user is also authorized to view
    the data. This ensures an independent confirmation of the user’s access to the
    system and prevents any abuse of an unexpired token.
  prefs: []
  type: TYPE_NORMAL
- en: If an authenticated user makes a call to an API where they don’t have the proper
    authorization (say, if a clerk wants to get access to a list of all users), then
    the `AuthService` will return a `falsy` status, and the client will receive a
    `403 Forbidden` response, which will be displayed as an error message to the user.
  prefs: []
  type: TYPE_NORMAL
- en: A user can make a request with an expired token; when this happens, a `401 Unauthorized`
    response is sent to the client. As a good UX practice, we should automatically
    prompt the user to log in again and let them resume their workflow without any
    data loss.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, true security is achieved with robust server-side implementation.
    Any client-side implementation is largely there to enable a good UX around good
    security practices.
  prefs: []
  type: TYPE_NORMAL
- en: An in-memory auth service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let’s implement a concrete version of the auth service that we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by installing a JWT decoding library and, to fake authentication, a JWT
    encoding library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Extend the abstract `AuthService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement a fake `authProvider` function that simulates the authentication
    process, including creating a fake JWT on the fly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `authProvider` implements what would otherwise be a server-side method right
    in the service, so we can conveniently experiment with the code while fine-tuning
    our auth workflow. The provider creates and signs a JWT with the temporary `fake-jwt-sign`
    library so that I can also demonstrate how to handle a properly formed JWT.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Do not ship your Angular application with the `fake-jwt-sign` dependency, since
    it is meant to be server-side code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In contrast, a real auth provider would include a `POST` call to a server.
    See the example code that follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is pretty straightforward, since the hard work is done on the server side.
    This call can also be made to a third-party auth provider, which I cover in the
    Firebase authentication recipe later in this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the API version, `v1`, in the URL path is defined at the service and
    not as part of the `baseUrl`. This is because each API can change versions independently.
    Login may remain `v1` for a long time, while other APIs may be upgraded to `v2`,
    `v3`, and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implementing `transformJwtToken` will be trivial because the login function
    provides us with a token that adheres to `IAuthStatus`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, implement `getCurrentUser`, which should return some default user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, provide a `defaultUser` as a private property to the class; what follows
    is one that I’ve created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a private `defaultUser` property to the `InMemoryAuthService` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Congratulations! You’ve implemented a concrete, but still fake, auth service.
    Now that you have the in-memory auth service in place, be sure to run your Angular
    application and ensure no errors are present.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s test our auth service by implementing a simple login and logout functionality
    accessible through the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Simple login
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we implement a fully-featured `login` component, let’s wire up the pre-baked
    login behavior to the **Login as manager** button we have in the `HomeComponent`.
    We can test the behavior of our auth service before getting into the details of
    delivering a rich UI component.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to simulate logging in as a manager. To accomplish this, we need
    to hardcode an email address and a password to log in and, upon successful login,
    maintain the functionality of navigating to the `/manager` route.
  prefs: []
  type: TYPE_NORMAL
- en: Note that on GitHub, the code sample for this section resides in a file named
    `home.component.simple.ts` under the folder structure of `projects/stage8`. The
    alternate file exists for reference purposes only because the code from this section
    dramatically changes later in the chapter. Ignore the filename difference, as
    it will not impact your coding for this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement a simple login mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `HomeComponent`, implement a `login` function that uses the `AuthService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the template to remove the `routerLink` and, instead, call the `login`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On successful login, we need to navigate to the `/manager` route. We can verify
    that we’re successfully logged in by listening to the `authStatus$` and `currentUser$`
    observables exposed by the `AuthService`. If `authStatus$.isAuthenticated` is
    `true` and `currentUser$._id` is a non-empty string, we have a valid login. We
    can listen to both observables by using RxJS’s `combineLatest` operator. Given
    a valid login condition, we can then use the `filter` operator to reactively navigate
    to the `/manager` route.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `login()` function to implement the login conditional, and upon
    success, navigate to the `/manager` route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we subscribe to the `combineLatest` operator at the end, which is
    critical in activating the observable streams. Otherwise, our login action will
    remain dormant unless some other component subscribes to the stream. You only
    need to activate a stream once.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, test out the new `login` functionality. Verify that the JWT is created
    and stored in `localStorage` using the **Chrome DevTools | Application** tab,
    as shown here:![](img/B20960_05_04.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 5.4: DevTools showing Application | Local Storage'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can view **Local Storage** under the **Application** tab. Make sure that
    the URL of your application is highlighted. In *step 3*, you can see that we have
    a key named `jwt` with a valid-looking token.
  prefs: []
  type: TYPE_NORMAL
- en: Note *steps 4* and *5*, highlighting two warnings, which, respectively, advise
    us not to use the `InMemoryAuthService` and the `fake-jwt-sign` package in production
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Use breakpoints to debug and step through the code to get a more concrete understanding
    of how `HomeComponent`, `InMemoryAuthService`, and `AuthService` work together
    to log the user in.
  prefs: []
  type: TYPE_NORMAL
- en: When you refresh the page, note that you’re still logged in because we’re caching
    the token in local storage.
  prefs: []
  type: TYPE_NORMAL
- en: Since we’re caching the login status, we must also implement a logout experience
    to complete the auth workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Logout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The logout button on the application toolbar is already wired up to navigate
    to the `logout` component we created before. Let’s update this component so that
    it can log the user out when navigated to:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `logout` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we explicitly clear the JWT by passing in `true` to the `logout` function.
    After we call `logout`, we navigate the user back to the home page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Test out the `logout` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that local storage is cleared after logout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have nailed a solid login and logout implementation. However, we’re not yet
    done with the fundamentals of our auth workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to consider the expiration status of our JWT.
  prefs: []
  type: TYPE_NORMAL
- en: Resuming a JWT session
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It wouldn’t be a great UX if you had to log in to Gmail or Amazon every time
    you visited the site. This is why we cache the JWT, but it would be an equally
    bad UX to keep you logged in forever. A JWT has an expiration date policy, where
    the provider can select a few minutes or even months to allow your token to be
    valid, depending on security needs. The in-memory service creates tokens that
    expire in one hour, so if a user refreshes their browser window within that frame,
    we should honor the valid token and let the user continue using the application,
    without asking them to log back in.
  prefs: []
  type: TYPE_NORMAL
- en: On the flip side, if the token is expired, we should automatically navigate
    the user to the login screen for a smooth UX.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `AuthService` class to implement a function named `hasExpiredToken`
    to check whether the token is expired, and a helper function named `getAuthStatusFromToken`
    to decode the token, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Keep your code DRY! Update the `login()` function to use `getAuthStatusFromToken()`
    instead.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the constructor of `AuthService` to check the status of the token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the token is expired, we log the user out and clear the token from `localStorage`.
    Otherwise, we decode the token and push the auth status to the data stream.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A corner case to consider here is to also trigger the reloading of the current
    user in the event of a resumption. We can do this by implementing a new pipe that
    reloads the current user if activated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, let’s refactor the existing user update logic in the `login()` function
    to a private property named `getAndUpdateUserIfAuthenticated` so that we can reuse
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `AuthService`, define an observable property named `resumeCurrentUser$`
    as a fork of `authStatus$`, and use the `getAndUpdateUserIfAuthenticated` logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once `resumeCurrentUser$` is activated and `status.isAuthenticated` is `true`,
    then `this.getCurrentUser()` will be invoked and `currentUser$` will be updated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the constructor of `AuthService` to activate the pipeline if the token
    has not expired:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the preceding technique, we can retrieve the latest user profile data
    without dealing with caching issues.
  prefs: []
  type: TYPE_NORMAL
- en: To experiment with token expiration, I recommend creating a faster-expiring
    token in `InMemoryAuthService`.
  prefs: []
  type: TYPE_NORMAL
- en: As demonstrated earlier in the caching section, it is possible to cache the
    user profile data using `this.cache.setItem` and the profile data from the cache
    on the first launch. This would provide a faster UX and cover cases where users
    may be offline. After the application launches, you could asynchronously fetch
    fresh user data and update `currentUser$` when new data comes in. You would need
    to add additional caching and tweak the `getCurrentUser()` logic to get such functionality
    working. Oh, and you would need a whole lot of testing! It takes a lot of testing
    to create a high-quality auth experience.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! We’re done implementing a robust auth workflow! Next, we need
    to integrate auth with Angular’s HTTP client to attach the token to the HTTP header
    of every request.
  prefs: []
  type: TYPE_NORMAL
- en: An HTTP interceptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implement an HTTP interceptor to inject the JWT into the header of every request
    sent to the API, and gracefully handle authentication failures by asking the user
    to log back in:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `AuthHttpInterceptor` under `auth`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that `AuthService` is leveraged to retrieve the token, and the `redirectUrl`
    is set for the `login` component after a `401` error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note the if statement `if (req.url.startsWith(baseUrl))` filters out any outgoing
    requests not made to our API. This way, we don’t leak our JWT token to external
    services.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update `app.config.ts` to provide the interceptor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ensure that the interceptor adds the token to requests. To do this, open the
    **Chrome DevTools | Network** tab, log in, and then refresh the page:![](img/B20960_05_05.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 5.5: The request header for lemon.svg'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In *step 4*, you can now observe the interceptor in action. The request for
    the `lemon.svg` file has the bearer token in the request header.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our auth mechanism implemented, let’s take advantage of all
    the supporting code we have written with dynamic UI components and a conditional
    navigation system, creating a role-based UX in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now have a solid understanding of how JWT works, how to use TypeScript
    for safe data handling, and how to build extendable services. In this chapter,
    we defined a `User` object that we can hydrate from or serialize to JSON objects,
    applying object-oriented class design and TypeScript operators for safe data handling.
  prefs: []
  type: TYPE_NORMAL
- en: We leveraged OOP design principles, using inheritance and abstract classes to
    implement a base auth service that demonstrates the Open/Closed principle.
  prefs: []
  type: TYPE_NORMAL
- en: We covered the fundamentals of token-based authentication and JWTs so that you
    don’t leak any critical user information. You learned that caching and HTTP interceptors
    are necessary so that users don’t have to input their login information with every
    request. Following that, we implemented an in-memory auth service that doesn’t
    require any external dependencies, which is great for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Coming up, in *Chapter 6*, *Implementing Role Based Navigation*, we will build
    a dynamic UI with navigation and component states reacting to the auth status
    of the app, using router and auth guards, flex layout media queries, Material
    components, and a service factory. We will also implement a Firebase auth provider
    so that you can host your apps on Google Firebase. In *Chapter 7*, *Working with
    REST and GraphQL APIs*, we will bring it all together with two custom auth providers
    that can authenticate against LemonMart Server, using the Minimal MEAN stack.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Salted Password Hashing - Doing it Right, Defuse Security*, 2019; [https://crackstation.net/hashing-security.htm](https://crackstation.net/hashing-security.htm).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Object-oriented programming*; [https://en.wikipedia.org/wiki/Object-oriented_programming](https://en.wikipedia.org/wiki/Object-oriented_programming).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TypeScript Classes*; [https://www.typescriptlang.org/docs/handbook/classes.html](https://www.typescriptlang.org/docs/handbook/classes.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TypeScript Basic Types*; [https://www.typescriptlang.org/docs/handbook/basic-types.html](https://www.typescriptlang.org/docs/handbook/basic-types.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TypeScript Advanced Types*; [https://www.typescriptlang.org/docs/handbook/advanced-types.html](https://www.typescriptlang.org/docs/handbook/advanced-types.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TypeScript 3.7 Features*; [https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Authentication General Guidelines*; [https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How to secure your Firebase project even when your API key is publicly available*;
    paachu, 2019, [https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843](https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions as best as possible to ensure you’ve understood
    the key concepts from this chapter without googling anything. Do you know if you
    got all the answers right? Visit [https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)
    for more:'
  prefs: []
  type: TYPE_NORMAL
- en: What’s in-transit and at-rest security?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the difference between authentication and authorization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain inheritance and polymorphism.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an abstract class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an abstract method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain how the `AuthService` adheres to the Open/Closed principle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does JWT verify your identity?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between RxJS’s `combineLatest` and `merge` operators?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a route guard?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does a service factory allow you to do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/AngularEnterpise3e](Chapter_5.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1116411172100421421.png)'
  prefs: []
  type: TYPE_IMG
