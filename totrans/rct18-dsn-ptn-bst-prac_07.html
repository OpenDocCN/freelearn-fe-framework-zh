<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer033">
<h1 class="chapterNumber">7</h1>
<h1 class="chapterTitle" id="_idParaDest-109">Anti-Patterns to Be Avoided </h1>
<p class="normal">In this book, you’ve learned how to apply best practices when writing a React application. In the first few chapters, we revisited the basic concepts to build a solid understanding, and then we took a leap into more advanced techniques in the following chapters.</p>
<p class="normal">You should now be able to build reusable components, make components communicate with each other, and optimize an application tree to get the best performance. However, developers make mistakes, and this chapter is all about the common anti-patterns we should avoid when using React.</p>
<p class="normal">Looking at common errors will help you to avoid them and will aid your understanding of how React works and how to build applications in the React way. For each problem, we will see an example that shows how to reproduce and solve it.</p>
<p class="normal">In this chapter, we will cover the following topics:</p>
<ul>
<li class="bulletList">Initializing the state using properties</li>
<li class="bulletList">Using indexes as a key</li>
<li class="bulletList">Spreading properties on DOM elements</li>
</ul>
<h1 class="heading-1" id="_idParaDest-110">Technical requirements</h1>
<p class="normal">To complete this chapter, you will need the following:</p>
<ul>
<li class="bulletList">Node.js 19+</li>
<li class="bulletList">Visual Studio Code</li>
</ul>
<p class="normal">You can find the code for this chapter in the book’s GitHub repository: <a href="https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter07"><span class="url">https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter07</span></a>. </p>
<h1 class="heading-1" id="_idParaDest-111">Initializing the state using properties</h1>
<p class="normal">In this section, we will see how<a id="_idIndexMarker236"/> initializing the state using properties received from the parent is usually an anti-pattern. I have used the word <em class="italic">usually</em> because, as we will see, once we have it clear in our mind what the problems with this <a id="_idIndexMarker237"/>approach are, we might still decide to use it.</p>
<p class="normal">One of the best ways to learn something is by looking at the code, so we will start by creating a simple component with a + button to increment a counter.</p>
<p class="normal">Let’s create a functional component named <code class="inlineCode">Counter</code>, as shown in the following code snippet:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { <span class="hljs-variable">FC</span>, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
type <span class="hljs-title">Props</span> = {
 <span class="hljs-attr">count</span>: number
}
<span class="hljs-keyword">const</span> <span class="hljs-title">Counter</span>: <span class="hljs-variable">FC</span>&lt;<span class="hljs-title">Props</span>&gt; = <span class="hljs-function">(</span><span class="hljs-params">props</span><span class="hljs-function">) =&gt;</span> {}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title">Counter</span>
</code></pre>
<p class="normal">Now, let’s set our <code class="inlineCode">count</code> state:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> [state, setState] = useState&lt;number&gt;(props.<span class="hljs-property">count</span>)
</code></pre>
<p class="normal">The implementation of the click handler is straightforward – we just add <code class="inlineCode">1</code> to the current <code class="inlineCode">count</code> value and store the resulting value back in the state:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">handleClick</span> = () =&gt; {
 <span class="hljs-title">setState</span>({ <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> })
}
</code></pre>
<p class="normal">Finally, we render and describe the output, which is composed of the current value of the <code class="inlineCode">count</code> state and the button to increment it:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> (
 <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
 {state.count}
 <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{handleClick}</span><span class="hljs-tag">&gt;</span>+<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
 <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
)
</code></pre>
<p class="normal">Now, let’s render this component, passing <code class="inlineCode">1</code> as the <code class="inlineCode">count</code> property:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">Counter</span><span class="hljs-tag"> </span><span class="hljs-attr">count</span><span class="hljs-tag">=</span><span class="hljs-string">{1}</span><span class="hljs-tag"> /&gt;</span>
</code></pre>
<p class="normal">It works as expected – each click on the <code class="inlineCode">+</code> button increments the current value. So, what’s the problem?</p>
<p class="normal">There are two main<a id="_idIndexMarker238"/> errors, which are outlined as follows:</p>
<ul>
<li class="bulletList">We have a duplicated source of truth.</li>
<li class="bulletList">If the <code class="inlineCode">count</code> property passed to the component changes, the state does not get updated.</li>
</ul>
<p class="normal">If we inspect the <code class="inlineCode">Counter</code> element<a id="_idIndexMarker239"/> using the React DevTools, we notice that <code class="inlineCode">Props</code> and <code class="inlineCode">State</code> hold a similar value:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;<span class="hljs-title">Counter</span>&gt;
<span class="hljs-title">Props</span>
 <span class="hljs-attr">count</span>: <span class="hljs-number">1</span>
<span class="hljs-title">State</span>
 <span class="hljs-attr">count</span>: <span class="hljs-number">1</span>
</code></pre>
<p class="normal">This makes it unclear which is the current and trustworthy value to use inside the component and to display to the user.</p>
<p class="normal">Even worse, clicking <code class="inlineCode">+</code> once makes the values diverge. An example of this divergence is shown in the following code:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;<span class="hljs-title">Counter</span>&gt;
<span class="hljs-title">Props</span>
 <span class="hljs-attr">count</span>: <span class="hljs-number">1</span>
<span class="hljs-title">State</span>
 <span class="hljs-attr">count</span>: <span class="hljs-number">2</span>
</code></pre>
<p class="normal">At this point, we can assume that the second value represents the current count, but this is not explicit and can lead to unexpected behaviors or wrong values down in the tree.</p>
<p class="normal">The second problem centers on how the class is created and instantiated by React. The <code class="inlineCode">useState</code> function of the component gets called only once when the component is created.</p>
<p class="normal">In our <code class="inlineCode">Counter</code> component, we read the value of the <code class="inlineCode">count</code> property and we store it in the state. If the <a id="_idIndexMarker240"/>value of that property changes during the life cycle of the application (let’s say it becomes 10), the <code class="inlineCode">Counter</code> component will never use the new value because it has already been initialized. This puts the component in an inconsistent state, which is not optimal and hard to debug.</p>
<p class="normal">What if we really want<a id="_idIndexMarker241"/> to use the prop’s value to initialize the component, and we know for sure that the value does not change in the future?</p>
<p class="normal">In that case, it’s best practice to make it explicit and give the property a name that makes your intentions clear, such as <code class="inlineCode">initialCount</code>. For example, let’s say we change the prop declaration of the <code class="inlineCode">Counter</code> component in the following way:</p>
<pre class="programlisting code"><code class="hljs-code">type <span class="hljs-title">Props</span> = {
 <span class="hljs-attr">initialCount</span>: number
}
<span class="hljs-keyword">const</span> <span class="hljs-title">Counter</span>: <span class="hljs-variable">FC</span>&lt;<span class="hljs-title">Props</span>&gt; = <span class="hljs-function">(</span><span class="hljs-params">props</span><span class="hljs-function">) =&gt;</span> {
 <span class="hljs-keyword">const</span> [count, setState] = useState&lt;<span class="hljs-title">Count</span>&gt;({ <span class="hljs-attr">count</span>: props.<span class="hljs-property">initialCount</span> })
 ...
}
</code></pre>
<p class="normal">This usage makes it clear that the parent can only initialize the counter, and any subsequent values of the <code class="inlineCode">initialCount</code> property will be disregarded: </p>
<pre class="programlisting code"><code class="hljs-code">&lt;<span class="hljs-title">Counter</span> initialCount={<span class="hljs-number">1</span>} /&gt;
</code></pre>
<p class="normal">In the next section, we are going to delve into the concept of keys.</p>
<h1 class="heading-1" id="_idParaDest-112">Using indexes as a key</h1>
<p class="normal">In <em class="chapterRef">Chapter 15</em>, <em class="italic">Improving the Performance of Your Applications</em>, which talks about performance and<a id="_idIndexMarker242"/> the reconciler, we saw how we can help React figure out the shortest path to update the DOM by using the <code class="inlineCode">key</code> prop.</p>
<p class="normal">The <code class="inlineCode">key</code> property uniquely identifies an element in the DOM and React uses it to check whether the element is new or whether it must be updated when the component properties or state change.</p>
<p class="normal">Using keys is always a good idea and if you don’t do it, React gives a warning in the console (in development mode). However, it is not simply a matter of using a key; sometimes, the value that we decide to use as a<a id="_idIndexMarker243"/> key can make a difference. In fact, using the wrong key can give us unexpected behaviors in some instances. In this section, we will see one of those instances.</p>
<p class="normal">Let’s again create a <code class="inlineCode">List</code> component, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { <span class="hljs-variable">FC</span>, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">const</span> <span class="hljs-title">List</span>: <span class="hljs-variable">FC</span> = <span class="hljs-function">() =&gt;</span> {
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title">List</span>
</code></pre>
<p class="normal">Then we define our state:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> [items, setItems] = <span class="hljs-title">useState</span>([<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>])
</code></pre>
<p class="normal">The implementation of the click handler is slightly different from the previous one because, in this case, we need to insert a new item at the top of the list:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">handleClick</span> = () =&gt; {
<span class="hljs-keyword">const</span> newItems = items.<span class="hljs-title">slice</span>()
 newItems.<span class="hljs-title">unshift</span>(<span class="hljs-string">'baz'</span>)
 <span class="hljs-title">setItems</span>(newItems)
}
</code></pre>
<p class="normal">Finally, in the render, we show the list and the <code class="inlineCode">+</code> button to add the <code class="inlineCode">baz</code> item at the top of the list:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> (
 <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
 <span class="hljs-tag">&lt;</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
  {items.map((item, index) =&gt; (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">li</span><span class="hljs-tag"> </span><span class="hljs-attr">key</span><span class="hljs-tag">=</span><span class="hljs-string">{index}</span><span class="hljs-tag">&gt;</span>{item}<span class="hljs-tag">&lt;/</span><span class="hljs-name">li</span><span class="hljs-tag">&gt;</span>
  ))}
 <span class="hljs-tag">&lt;/</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
 <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{handleClick}</span><span class="hljs-tag">&gt;</span>+<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
 <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
)
</code></pre>
<p class="normal">If you run the component inside the browser, you will not see any problems; clicking the <code class="inlineCode">+</code> button inserts a new item at the top of the list. But let’s do an experiment.</p>
<p class="normal">Let’s change the<a id="_idIndexMarker244"/> render in the following way, adding an input field near each item. We then use an input field because we can edit its content, making it easier to figure out the problem:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> (
 <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
 <span class="hljs-tag">&lt;</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
  {items.map((item, index) =&gt; (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">li</span><span class="hljs-tag"> </span><span class="hljs-attr">key</span><span class="hljs-tag">=</span><span class="hljs-string">{index}</span><span class="hljs-tag">&gt;</span>
  {item}
  <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span><span class="hljs-tag"> </span><span class="hljs-attr">type</span><span class="hljs-tag">=</span><span class="hljs-string">"text"</span><span class="hljs-tag"> /&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">li</span><span class="hljs-tag">&gt;</span>
  ))}
 <span class="hljs-tag">&lt;/</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
 <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{handleClick}</span><span class="hljs-tag">&gt;</span>+<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
 <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
)
</code></pre>
<p class="normal">If we run this component again in the browser, copy the values of the items in the input fields, and then click <em class="keystroke">+</em>, we will get unexpected behavior.</p>
<p class="normal">As shown in the following screenshot, the items shift down while the input elements remain in the same position in such a way that their value does not match the value of the items anymore:</p>
<figure class="mediaobject"><img alt="Graphical user interface, application  Description automatically generated" height="331" src="../Images/B18414_07_01.png" width="653"/></figure>
<p class="packt_figref">Figure 7.1: Using indexes as a key</p>
<p class="normal">Running the <a id="_idIndexMarker245"/>component, clicking <strong class="keyWord">+</strong>, and checking the console should give us all the answers we need.</p>
<p class="normal">What we can see is that instead of inserting the new element at the top, React swaps the text of the two existing elements, and inserts the last item at the bottom as if it was new. The reason it does that is that we are using the index of the map function as the key.</p>
<p class="normal">In fact, the index always starts from <code class="inlineCode">0</code>, even if we push a new item to the top of the list, so React thinks that we changed the values of the existing two and added a new element at index <code class="inlineCode">2</code>. The behavior is the same as it would have been without using the <code class="inlineCode">key</code> property at all.</p>
<p class="normal">This is a very common pattern because we may think that providing any key is always the best solution, but it is not like that at all. The key must be unique and stable, identifying one, and only one, item.</p>
<p class="normal">To solve this problem, we can, for example, use the value of the item if we expect it not to be repeated within the list, or create a unique identifier, for example:</p>
<pre class="programlisting code"><code class="hljs-code"> {items.<span class="hljs-title">map</span>(<span class="hljs-function">(</span><span class="hljs-params">item, index</span><span class="hljs-function">) =&gt;</span> (
   <span class="hljs-tag">&lt;</span><span class="hljs-name">li</span><span class="hljs-tag"> </span><span class="hljs-attr">key</span><span class="hljs-tag">=</span><span class="hljs-string">{</span><span class="hljs-tag">`${</span><span class="hljs-attr">item</span><span class="hljs-tag">}</span><span class="hljs-attr">-</span><span class="hljs-tag">${</span><span class="hljs-attr">index</span><span class="hljs-tag">}`}&gt;</span>
  {item}
   <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span><span class="hljs-tag"> </span><span class="hljs-attr">type</span><span class="hljs-tag">=</span><span class="hljs-string">"text"</span><span class="hljs-tag"> /&gt;</span>
 <span class="hljs-tag">&lt;/</span><span class="hljs-name">li</span><span class="hljs-tag">&gt;</span>
 ))}
</code></pre>
<p class="normal">Now that we have understood the importance of unique and stable keys in React and explored<a id="_idIndexMarker246"/> practical solutions to address this common issue, let’s shift our attention to another prevalent practice in React development. The upcoming section will focus on the spreading of properties on DOM elements, a technique that has recently been labeled as an anti-pattern by Dan Abramov.</p>
<h1 class="heading-1" id="_idParaDest-113">Spreading properties on DOM elements</h1>
<p class="normal">There is a <a id="_idIndexMarker247"/>common practice that has recently been described as an anti-pattern by Dan Abramov; it also triggers a warning in the console<a id="_idIndexMarker248"/> when you do it in your React application.</p>
<p class="normal">It is a technique that is widely used in the community, and I have personally seen it multiple times in real-world projects. We usually spread the properties to the elements to avoid writing every single one manually, which is shown as follows:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;<span class="hljs-title">Component</span> {...props} /&gt;
</code></pre>
<p class="normal">This works very well, and it gets transpiled into the following code by Babel:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">_jsx</span>(<span class="hljs-title">Component</span>, props)
</code></pre>
<p class="normal">However, when we spread properties into a DOM element, we run the risk of adding unknown HTML attributes, which is bad practice.</p>
<p class="normal">The problem is not related only to the <code class="inlineCode">Spread</code> operator; passing non-standard properties one by one leads to the same issues and warnings. Since the <code class="inlineCode">Spread</code> operator hides the single properties we are spreading, it is even harder to figure out what we are passing to the element.</p>
<p class="normal">To see the warning in the console, a basic operation we can do is render the following component:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">Spread</span> = () =&gt; <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> </span><span class="hljs-attr">foo</span><span class="hljs-tag">=</span><span class="hljs-string">"bar"</span><span class="hljs-tag"> /&gt;</span>
</code></pre>
<p class="normal">The message we get looks like the following because the <code class="inlineCode">foo</code> property is not valid for a <code class="inlineCode">div</code> element:</p>
<pre class="programlisting con"><code class="hljs-con"> Unknown prop `foo` on &lt;div&gt; tag. Remove this prop from the element
</code></pre>
<p class="normal">In this case, as we said, it is easy to figure out which attribute we are passing and remove it, but if we use the <code class="inlineCode">Spread</code> operator, as in the following example, we cannot control <a id="_idIndexMarker249"/>which properties are passed from the <a id="_idIndexMarker250"/>parent:</p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword">const</span> <span class="hljs-title">Spread</span> = props =&gt; <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> {</span><span class="hljs-attr">...props</span><span class="hljs-tag">} /&gt;</span>;
</code></pre>
<p class="normal">If we use the component in the following way, there are no issues:</p>
<pre class="programlisting code"><code class="hljs-code"> &lt;<span class="hljs-title">Spread</span> className=<span class="hljs-string">"foo"</span> /&gt;
</code></pre>
<p class="normal">This, however, is not the case if we do something such as the following. React complains because we are applying a non-standard attribute to the DOM element:</p>
<pre class="programlisting code"><code class="hljs-code"> &lt;<span class="hljs-title">Spread</span> foo=<span class="hljs-string">"bar"</span> className=<span class="hljs-string">"baz"</span> /&gt;
</code></pre>
<p class="normal">One solution we can use to solve this problem is to create a property called <code class="inlineCode">domProps</code> that we can spread safely to the component because we are explicitly saying that it contains valid DOM properties.</p>
<p class="normal">For example, we can change the <code class="inlineCode">Spread</code> component in the following way:</p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword">const</span> <span class="hljs-title">Spread</span> = props =&gt; <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> {</span><span class="hljs-attr">...props.domProps</span><span class="hljs-tag">} /&gt;</span>
</code></pre>
<p class="normal">We can then use it as follows:</p>
<pre class="programlisting code"><code class="hljs-code"> &lt;<span class="hljs-title">Spread</span> foo=<span class="hljs-string">"bar"</span> domProps={{ <span class="hljs-attr">className</span>: <span class="hljs-string">'baz'</span> }} /&gt;
</code></pre>
<p class="normal">As we have seen many times with React, it’s always good practice to be explicit.</p>
<h1 class="heading-1" id="_idParaDest-114">Summary</h1>
<p class="normal">Knowing all the best practices is always a good thing, but sometimes, being aware of anti-patterns helps us avoid taking the wrong path. Most importantly, learning the reasons why some techniques are considered bad practice helps us understand how React works, and how we can use it effectively.</p>
<p class="normal">In this chapter, we covered four different ways of using components that can harm the performance and behavior of our web applications.</p>
<p class="normal">For each one of those, we used an example to reproduce the problem and supplied the changes to apply in order to fix the issue.</p>
<p class="normal">We learned why using properties to initialize the state can result in inconsistencies between the state and the properties. We also saw how using the wrong <code class="inlineCode">key</code> attribute can produce bad effects on the reconciliation algorithm. Finally, we learned why spreading non-standard properties to DOM elements is considered an anti-pattern.</p>
<p class="normal">In the next chapter, we will look into the new React Hooks.</p>
</div>
</div></body></html>