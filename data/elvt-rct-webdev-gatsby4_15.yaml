- en: '*Chapter 12*: Using Real-Time Data'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：使用实时数据'
- en: Have you ever ordered food and watched as it made its way closer to your destination
    without you having to refresh the page? You may have also seen this with package
    deliveries or ride-hailing apps. All of these make use of **real-time data**.
    This is a form of data that is presented as soon as it is acquired. So, in these
    examples, as soon as the service you are using has the food, package, or car's
    location, it will relay that information to you. The most common way that convenience
    sites and messaging applications enable real-time data is by using **web sockets**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否曾经点过餐，并看着它向您所在的位置靠近，而无需刷新页面？您可能也见过包裹递送或打车应用中的这种情况。所有这些都使用了**实时数据**。这是一种在获取后立即呈现的数据形式。因此，在这些例子中，一旦您所使用的服务有了食物、包裹或汽车的位置，它就会将此信息传达给您。便利网站和消息应用使实时数据成为可能的最常见方式是使用**WebSocket**。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to web sockets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket简介
- en: Socket.io in action
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Socket.io实战
- en: Live site visitor count
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时网站访问者计数
- en: Gaining further insights with rooms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过房间获取更多见解
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter, you will need to have completed [*Chapter 11*](B15983_11_ePub_RK.xhtml#_idTextAnchor152),
    *Creating Authenticated Experiences*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您需要完成[*第11章*](B15983_11_ePub_RK.xhtml#_idTextAnchor152)，*创建认证体验*。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter12](https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter12).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter12](https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter12)找到。
- en: Introduction to web sockets
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSocket简介
- en: A web socket is a bi-directional communication channel between a client and
    a server. Unlike **REST** requests, the socket connection's channel remains open
    for the client and the server to push messages to and from each other whenever
    they need, instead of closing when a response is received. This kind of communication
    is commonly associated with low latency, which means it can handle high volumes
    of data with minimal delay.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket是客户端和服务器之间的双向通信通道。与**REST**请求不同，WebSocket连接的通道在客户端和服务器需要时始终开启，以便相互推送消息，而不是在收到响应时关闭。这种通信通常与低延迟相关联，这意味着它可以以最小的延迟处理大量数据。
- en: So, how does it work? To start, the client sends an HTTP request to a server,
    asking it to open a connection. If the server agrees, it will send back a response
    with a status of 101, indicating that it will be switching protocols. At this
    point, the handshake is complete and a **TCP/IP** connection is left open, allowing
    messages to pass back and forth between the two devices. This connection will
    remain open until one of the devices disconnects or loses its connection.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，它是如何工作的呢？首先，客户端向服务器发送一个HTTP请求，请求它打开一个连接。如果服务器同意，它将发送一个状态为101的响应，表示它将切换协议。此时，握手完成，一个**TCP/IP**连接保持开启状态，允许两个设备之间来回传递消息。此连接将保持开启，直到其中一个设备断开连接或失去连接。
- en: One of the most popular socket implementations in the JavaScript world is *socket.io*,
    which consists of two parts – a Node.js server and a JavaScript client library.
    We'll look at socket.io in action by creating a minimal demo in the next section.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript世界中，最受欢迎的socket实现之一是*socket.io*，它由两部分组成——一个Node.js服务器和一个JavaScript客户端库。我们将在下一节通过创建一个最小示例来查看socket.io的实战。
- en: Quick Tip
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 快速提示
- en: Note that there are also several other implementations of the *socket.io* server
    and client libraries available in languages other than JavaScript. This may be
    helpful if you want to combine a socket server (which we will create in this chapter)
    with more than just your Gatsby site.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，还有其他几种语言实现的*socket.io*服务器和客户端库可用。如果您想将socket服务器（我们将在本章创建）与Gatsby网站以外的其他内容结合使用，这可能很有帮助。
- en: Socket.io in action
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Socket.io实战
- en: 'In this demo, we will make a server that accepts a socket connection. When
    it receives a message from the client, it will log it to the console. Let''s start
    by creating the server and then move on to the client:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，我们将创建一个接受socket连接的服务器。当它从客户端收到消息时，它将将其记录到控制台。让我们先创建服务器，然后再转到客户端：
- en: Create a folder called `server` in your root directory.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的根目录下创建一个名为 `server` 的文件夹。
- en: 'Open a terminal in the `server` folder and run the following command:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`server`文件夹中打开一个终端，并运行以下命令：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will set up an empty npm package in the folder.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在文件夹中设置一个空的 npm 包。
- en: 'In the same terminal, run the following command:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一终端中，运行以下命令：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create an `app.js` file in the `server` folder and add the following code:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`server`文件夹中创建一个`app.js`文件，并添加以下代码：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This creates a minimal Express server that listens for requests on port `3000`.
    As we have already learned, this socket connection is established with an HTTP
    request, and it requires an HTTP server to do this.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这创建了一个最小化的 Express 服务器，它监听端口`3000`上的请求。正如我们已经学到的，这个套接字连接是通过 HTTP 请求建立的，并且需要一个
    HTTP 服务器来完成这个操作。
- en: 'Verify that the server is working by opening a terminal within the `server`
    folder and running the following command:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`server`文件夹内打开一个终端并运行以下命令来验证服务器是否正常工作：
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Update the `app.js` file with the following code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新`app.js`文件：
- en: '[PRE4]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Before moving on, we must add a `server` folder and run the following command:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，我们必须添加一个`server`文件夹并运行以下命令：
- en: '[PRE5]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, update your `app.js` file with the following code:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下代码更新你的`app.js`文件：
- en: '[PRE6]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we have set up our socket server, let''s interact with it from our
    Gatsby site by using Gatsby as the socket client. Navigate back to the root of
    your Gatsby site. Open a terminal here and run the following command:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置了套接字服务器，让我们通过使用 Gatsby 作为套接字客户端与它交互。返回到你的 Gatsby 网站根目录。在这里打开一个终端并运行以下命令：
- en: '[PRE7]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As the name of the library might suggest, this installs the socket.io client
    library that we will be using to communicate with our web socket server.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如库的名称所暗示的，这安装了我们将用于与我们的 WebSocket 服务器通信的 socket.io 客户端库。
- en: 'Create a new file within your `pages` folder called `socket.js` and add the
    following code to it:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`pages`文件夹中创建一个新文件，命名为`socket.js`，并将以下代码添加到该文件中：
- en: '[PRE8]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Continue editing `socket.js` and add the following code:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续编辑`socket.js`并添加以下代码：
- en: '[PRE9]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Start your Gatsby development server and ensure your socket server is also running.
    Navigate to `localhost:8000/socket`, type in a message, and click **Send message**.
    With any luck, the contents of your message should now be logged within your server's
    terminal. Congratulations – you've just sent your first message via sockets!
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Gatsby 开发服务器，并确保你的套接字服务器也在运行。导航到`localhost:8000/socket`，输入一条消息，然后点击**发送消息**。如果有幸，你的消息内容现在应该已经记录在你的服务器终端中。恭喜你
    – 你刚刚通过套接字发送了第一条消息！
- en: 'Now, let''s expand this demo so that the client can receive communication back
    from the server. As an example, let''s make the server return one of three random
    greetings when it receives a message:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们扩展这个演示，以便客户端可以接收来自服务器的通信。作为一个例子，让我们让服务器在收到消息时返回三个随机问候语中的一个：
- en: 'First, we need to modify how our server handles messages. Modify the socket
    server''s connection configuration with the following code:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要修改服务器处理消息的方式。使用以下代码修改套接字服务器的连接配置：
- en: '[PRE10]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, as well as logging the messages that are received from a client, we emit
    something back to that same client. In this case, we are choosing a random greeting
    to send back.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，除了记录从客户端接收到的消息外，我们还会向同一客户端发送一些信息。在这种情况下，我们选择发送一个随机的问候语。
- en: 'With our Gatsby page, we need to tell it to expect and handle messages of a
    certain type. This works like event listeners, so this should feel familiar to
    you:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的 Gatsby 页面，我们需要告诉它期待并处理特定类型的消息。这就像事件监听器一样，所以这应该对你来说很熟悉：
- en: '[PRE11]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Update the render of the `page` component:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`page`组件的渲染：
- en: '[PRE12]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Within the render, we can map through the server messages and render them to
    the screen in a bulleted list.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在渲染中，我们可以遍历服务器消息并将它们以项目符号列表的形式渲染到屏幕上。
- en: 'Start your Gatsby development server and ensure your socket server is also
    running. Navigate to `localhost:8000/socket`, type in a message, and click **Send
    message**:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Gatsby 开发服务器，并确保你的套接字服务器也在运行。导航到`localhost:8000/socket`，输入一条消息，然后点击**发送消息**：
- en: '![Figure 12.1 – Socket demonstration page'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.1 – 套接字演示页面'
- en: '](img/Figure_12.1_B15983.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.1 – 套接字演示页面](img/Figure_12.1_B15983.jpg)'
- en: Figure 12.1 – Socket demonstration page
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 套接字演示页面
- en: Your message should be logged within the server's terminal, but additionally,
    the server should have also sent a message back. It should be visible underneath
    the **Send Message** button. The speed at which this happens can feel crazy. And
    when the connection is good, it can almost feel like the server message is being
    triggered by your button press.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你的消息应该在服务器的终端中记录，但此外，服务器还应该发送一条消息回来。它应该显示在 **发送消息** 按钮下方。这个过程发生的速度可能会感觉非常快。而且当连接良好时，几乎感觉就像服务器的消息是由你的按钮点击触发的。
- en: We now have a clear understanding of how socket connections work and we have
    managed to send messages between the client and the server. Now, let's apply what
    we have learned and build something useful for our Gatsby site with this technology
    – a live visitor count in our site footer.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对套接字连接的工作原理有了清晰的理解，并且我们已经成功地在客户端和服务器之间发送了消息。现在，让我们应用所学知识，用这项技术为我们的 Gatsby
    网站构建一些有用的功能——在我们的网站页脚中实现实时访客计数。
- en: Live site visitor count
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时网站访客计数
- en: 'The setup for this will need to be a little different from the previous example
    since, in the *Socket.io in action* section, the socket connection was isolated
    to a single page. However, our site footer is not on a single page but every page!
    An implementation of this that would work well is wrapping the site in some context.
    By doing this, we would be able to access the count in other parts of the application
    if we needed to. Let''s try this approach together:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在 *Socket.io in action* 部分中，套接字连接被隔离在单个页面上，因此这个设置的配置需要与之前的例子略有不同。然而，我们的网站页脚不在单个页面上，而是在每个页面上！一个能够很好地实现这一点的方案是将网站包裹在某个上下文中。通过这样做，如果我们需要的话，我们就可以在其他应用程序的部分访问计数。让我们一起来尝试这种方法：
- en: 'Modify the socket server''s connection configuration with the following code:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码修改套接字服务器的连接配置：
- en: '[PRE13]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We've changed this configuration quite a bit, so let's break it down. When a
    new socket connects to the server, we use `io.emit`. This function sends a message
    to all the connected clients instead of a single socket. The socket type is `count`
    and the body contains `io.engine.clientsCount`, which is a count of the number
    of connected clients. If you use this whenever a new client connects, everyone
    will know that the count has changed. Then, we have to make sure that the count
    for clients is updated on disconnect too. For that, we trigger the same `io.emit`
    when the server has seen a client drop off.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们对这个配置做了相当大的改动，所以让我们来分解一下。当一个新套接字连接到服务器时，我们使用 `io.emit`。这个函数向所有已连接的客户端发送消息，而不是单个套接字。套接字类型是
    `count`，正文包含 `io.engine.clientsCount`，这是已连接客户端的数量。如果你在每次新客户端连接时使用这个，每个人都会知道计数已经改变。然后，我们必须确保在客户端断开连接时也更新计数。为此，当服务器看到客户端掉线时，我们触发相同的
    `io.emit`。
- en: Create a new folder inside `src` called `context` if you don't already have
    one.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有创建，请在 `src` 中创建一个名为 `context` 的新文件夹。
- en: 'Create a new file called `stats-context.js` and add the following code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `stats-context.js` 的新文件，并添加以下代码：
- en: '[PRE14]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we are setting up the boilerplate of our stat's context. We create a `useStats`
    hook to access the context values that we will be defining in the next step.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们正在设置我们统计上下文的模板。我们创建一个 `useStats` 钩子来访问我们将在下一步定义的上下文值。
- en: 'Add the following code within `StatsProvider`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `StatsProvider` 中添加以下代码：
- en: '[PRE15]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Within the page level demo, we set up the socket using a `useEffect`. We do
    the same thing here to ensure it only happens one time. Then, we create a second
    `useEffect` that, when connected to the server, will listen for messages of the
    `count` type. If one is received, it updates the count in state, which will then
    be available throughout the application via the `useStats` hook.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在页面级别的演示中，我们使用 `useEffect` 设置套接字。我们在这里做同样的事情，以确保它只发生一次。然后，我们创建第二个 `useEffect`，当连接到服务器时，将监听
    `count` 类型的消息。如果收到这样的消息，它将更新状态中的计数，然后通过 `useStats` 钩子在整个应用程序中可用。
- en: 'Update your `gatsby-browser.js` and `gatbsy-ssr.js` files with the following
    code:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新你的 `gatsby-browser.js` 和 `gatbsy-ssr.js` 文件，添加以下代码：
- en: '[PRE16]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We want to ensure that the count's context is available throughout the application.
    By adding this file to both the `gatsby-browser.js` and `gatsby-ssr.js` files,
    we can be sure it is accessible everywhere.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们希望确保计数的上下文在整个应用程序中可用。通过将此文件添加到 `gatsby-browser.js` 和 `gatsby-ssr.js` 文件中，我们可以确保它在任何地方都可以访问。
- en: 'Create a `VisitorCountBadge.js` file in `src/components/layout` and add the
    following code to it:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/components/layout` 中创建一个名为 `VisitorCountBadge.js` 的文件，并添加以下代码到其中：
- en: '[PRE17]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we are making use of the `useStats` hook to retrieve `liveVistorCount`
    and the connected status. The color of the badge is dependent on the connection's
    status – if it is blue, then we are connected to the server; if not, it will be
    red. Then, we render `liveVistorCount` within this badge so that it is visible
    to the user.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `useStats` 钩子来检索 `liveVistorCount` 和连接状态。徽章的颜色取决于连接状态——如果是蓝色，则表示我们已连接到服务器；如果不是，它将是红色。然后，我们在徽章中渲染
    `liveVistorCount`，以便用户可以看到。
- en: Important Note
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: Here, we are using colors to signify the application state as an example only.
    Color alone should never be used to signify application state in production as
    it can leave your application inaccessible to colorblind users. It is better to
    combine color with another visual indicator, such as text, or at the very least
    an `aria-label`.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们仅用颜色作为示例来表示应用程序状态。在生产环境中，单独使用颜色来表示应用程序状态是不应该的，因为它可能会使色盲用户无法访问你的应用程序。更好的做法是将颜色与另一个视觉指示器结合使用，例如文本，或者至少是一个
    `aria-label`。
- en: 'Update your `Footer` component file with the following code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新你的 `Footer` 组件文件：
- en: '[PRE18]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Start your Gatsby development server and ensure your socket server is also running.
    Navigate to `localhost:8000` and you should see the visitor count. If you duplicate
    your browser tab, the visitor count will rise, while if you close a tab, the count
    will fall. Finally, if you close the terminal with the socket server running,
    you should see the badge change to red, indicating it has lost connection to the
    server.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Gatsby 开发服务器，并确保你的socket服务器也在运行。导航到 `localhost:8000`，你应该能看到访问者计数。如果你复制浏览器标签页，访问者计数会上升，而如果你关闭一个标签页，计数会下降。最后，如果你关闭运行socket服务器的终端，你应该看到徽章变为红色，表示它已与服务器断开连接。
- en: We have now implemented a working current visitor count. Let's build on this
    feature by using rooms.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经实现了一个工作状态下的当前访问者计数。让我们通过使用房间来扩展这个功能。
- en: Gaining further insights with rooms
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过房间获得更深入的见解
- en: There is one element to socket.io events that we have not talked about yet but
    could be of great benefit in our application – `join` and `leave`. The server
    can emit messages to a room to broadcast an event to a subset of the clients connected
    to the server.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论过 socket.io 事件中的一个元素，但在我们的应用程序中可能会有很大的好处——`join` 和 `leave`。服务器可以向房间发出消息，向连接到服务器的客户端子集广播事件。
- en: 'To demonstrate the concept of rooms, we will be breaking down our visitor count
    into more granular stats. Not only will we display to the user the count of total
    users on the site, but we will also provide them with the details of how many
    people are on their current page of the site. Let''s get started:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示房间的概念，我们将把我们的访问者计数分解成更细粒度的统计数据。我们不仅会向用户显示网站上总用户数，还会提供他们当前页面上有多少人的详细信息。让我们开始吧：
- en: 'Update your `server/app.js` file''s socket code so that it includes a new event:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新你的 `server/app.js` 文件的 socket 代码，使其包括一个新的事件：
- en: '[PRE19]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We now expect clients to send us a new event of the `page-update` type. The
    body contains a `currentPage` and an optional `previousPage` for the client. We
    will use these two pieces of information to make them join the room for their
    current page and remove them from the room for their previous page.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们期望客户端发送给我们一个新的 `page-update` 类型的事件。正文包含一个 `currentPage` 和一个可选的 `previousPage`。我们将使用这两条信息让他们加入当前页面的房间，并从他们之前页面的房间中移除。
- en: We have defined a function called `pathToRoom` that we use to take the path
    where the user is and turn it into a string that we can use as a room identifier.
    If the client has sent a previous page, we know that this is not the first page
    on the site they have visited, so they need to be removed from the `previousPage`
    room. To do this, we can call the `socket.leave` function with the room identifier
    as the argument. We can then use `io.to(previousRoom).emit` to emit the new reduced
    count to users still on that page. After that, we can use `currentPage` to determine
    the new room that the user should join and emit the new count to users in that
    room (including the new user).
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们定义了一个名为 `pathToRoom` 的函数，我们用它来获取用户所在路径并将其转换为可以用来作为房间标识符的字符串。如果客户端已经发送了前一页，我们知道这不是他们访问该网站的第一个页面，因此他们需要从
    `previousPage` 房间中移除。为此，我们可以使用带有房间标识符作为参数的 `socket.leave` 函数。然后，我们可以使用 `io.to(previousRoom).emit`
    向仍然在该页面的用户发出新的减少计数。之后，我们可以使用 `currentPage` 来确定用户应该加入的新房间，并向该房间（包括新用户）的用户发出新的计数。
- en: Quick Tip
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 快速提示
- en: '`socket.leave` and `socket.join` are server-side only. Sockets cannot leave
    and join rooms on the client site.'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`socket.leave` 和 `socket.join` 仅在服务器端。套接字不能在客户端离开和加入房间。'
- en: 'Update the `disconnect` event with the following code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新 `disconnect` 事件：
- en: '[PRE20]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When a socket disconnects, we loop through all open rooms and emit the new number
    of clients to each of them.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当套接字断开连接时，我们遍历所有打开的房间，并将新的客户端数量发送给它们。
- en: 'Update your `gatsby-browser.js` and `gatbsy-ssr.js` files with the following
    code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新你的 `gatsby-browser.js` 和 `gatbsy-ssr.js` 文件：
- en: '[PRE21]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Navigate to your `stats-context.js` file and update the `StatsProvider` arguments:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你的 `stats-context.js` 文件并更新 `StatsProvider` 参数：
- en: '[PRE22]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We will need to use the location that we are now passing in, so let's de-structure
    it with props.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将需要使用我们现在传递的位置，所以让我们用 props 解构它。
- en: 'Add two new React hooks to the top of `StatsProvider`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `StatsProvider` 的顶部添加两个新的 React 钩子：
- en: '[PRE23]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Update `useEffect` that''s related to incoming socket events within `StatsProvider`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新与 `StatsProvider` 中传入的套接字事件相关的 `useEffect`：
- en: '[PRE24]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a new `useEffect` inside `StatsProvider`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `StatsProvider` 中创建一个新的 `useEffect`：
- en: '[PRE25]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here is one of the most crucial parts of the code. We add the location to the
    `useEffect` dependency array so that this code runs whenever the user navigates
    between a page. Within `useEffect`, we check that the socket is available in the
    state and that the location update does not match the current location. If both
    conditions are met, we emit a `page-update` to the server, telling it where we
    have moved to so that it can keep track of the locations.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是代码中最关键的部分之一。我们将位置添加到 `useEffect` 依赖数组中，这样每当用户在页面之间导航时，这段代码就会运行。在 `useEffect`
    中，我们检查套接字是否在状态中可用，并且位置更新不匹配当前位置。如果这两个条件都满足，我们就向服务器发出 `page-update`，告诉它我们移动到了哪里，以便它可以跟踪位置。
- en: 'Update the render of the `StatsProvider.js` file:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `StatsProvider.js` 文件的渲染：
- en: '[PRE26]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Update `components/VistorCountBadge.js` with the following code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新 `components/VistorCountBadge.js`：
- en: '[PRE27]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we are retrieving `pageVisitorCount` from the `useStats` hook and rendering
    it to the screen so that the user can see the value within the badge.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们正在从 `useStats` 钩子中检索 `pageVisitorCount` 并将其渲染到屏幕上，以便用户可以在徽章中看到该值。
- en: Start your Gatsby development server and ensure your socket server is also running.
    Navigate to `localhost:8000`; you should see the visitor and page count. If you
    duplicate your browser tab, both numbers should rise, and if you navigate one
    of these tabs to another page on the site, you should see both tabs' page visitor
    counts update.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Gatsby 开发服务器并确保你的套接字服务器也在运行。导航到 `localhost:8000`；你应该能看到访问者和页面计数。如果你复制浏览器标签页，这两个数字都应该增加，如果你将其中一个标签页导航到网站上的另一个页面，你应该看到两个标签页的页面访问者计数更新。
- en: Now that we have implemented an entire feature using sockets, let's summarize
    what we have learned.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用套接字实现了一个完整的功能，让我们总结一下我们学到了什么。
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned all about web sockets and how we can use them to
    utilize real-time data within our Gatsby applications. Then, we implemented a
    working visitor count that shows the number of people on the current page, as
    well as the site as a whole. Visitor count statistics is one of a whole host of
    possible applications for web sockets within a personal site. Perhaps you could
    take what you have learned here and try and implement article reactions, polls,
    or even a chat application?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了有关网络套接字的所有知识，以及我们如何使用它们在我们的 Gatsby 应用程序中利用实时数据。然后，我们实现了一个显示当前页面以及整个网站人数的工作访问者计数器。访问者计数器统计是个人网站中网络套接字可能应用的一大类中的一种。也许你可以将在这里学到的知识尝试应用于实现文章反应、投票甚至聊天应用程序？
- en: In the next chapter, we will learn about our final advanced concept – localization.
    We will learn how we can make our Gatsby site support multiple languages for an
    international audience.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习我们的最后一个高级概念——本地化。我们将学习如何使我们的 Gatsby 网站支持多语言以适应国际受众。
