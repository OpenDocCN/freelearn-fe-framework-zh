<html><head></head><body>
<section epub:type="frontmatter chapter" role="doc-chapter">
<p><a id="_idTextAnchor043"/></p>
<h1 class="chapter-number" id="_idParaDest-32"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-33"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.2.1">Understanding React Essentials</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Welcome to this fundamental chapter of our React essentials guide! </span><span class="koboSpan" id="kobo.3.2">This chapter serves as a solid foundation for your journey into the exciting world of React development. </span><span class="koboSpan" id="kobo.3.3">We will delve into the fundamental concepts of React and provide you with the essential knowledge needed to kickstart your React projects with confidence.</span></p>
<p><span class="koboSpan" id="kobo.4.1">In this chapter, we will explore how to think in components, a crucial mindset for building reusable and modular </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">user interfaces</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.7.1">UIs</span></strong><span class="koboSpan" id="kobo.8.1">). </span><span class="koboSpan" id="kobo.8.2">You will learn the art of breaking your application </span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.9.1">down into smaller, self-contained components, enabling you to create maintainable and scalable code bases. </span><span class="koboSpan" id="kobo.9.2">By understanding this fundamental concept, you will be equipped with the skills to architect robust and flexible React applications.</span></p>
<p><span class="koboSpan" id="kobo.10.1">Additionally, we will introduce you to the most commonly used Hooks in React, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.11.1">useState</span></strong><span class="koboSpan" id="kobo.12.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.13.1">useEffect</span></strong><span class="koboSpan" id="kobo.14.1">, and more. </span><span class="koboSpan" id="kobo.14.2">These Hooks are powerful tools that allow you to manage state, handle side effects, and tap into React’s lifecycle methods within functional components. </span><span class="koboSpan" id="kobo.14.3">By mastering these Hooks, you will have the ability to create dynamic and interactive UIs effortlessly.</span></p>
<p><span class="koboSpan" id="kobo.15.1">By the end of this chapter, you will be well prepared to explore more advanced topics and tackle real-world React challenges in the subsequent chapters of our guide. </span><span class="koboSpan" id="kobo.15.2">So, buckle up and get ready to embark on an exciting journey into the world of React.</span></p>
<p><span class="koboSpan" id="kobo.16.1">So, in this chapter, we will cover the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.17.1">Understanding static components in React</span></li>
<li><span class="koboSpan" id="kobo.18.1">Creating components with props</span></li>
<li><span class="koboSpan" id="kobo.19.1">Breaking down UIs into components</span></li>
<li><span class="koboSpan" id="kobo.20.1">Managing internal state in React</span></li>
<li><span class="koboSpan" id="kobo.21.1">Understanding the rendering process</span></li>
<li><span class="koboSpan" id="kobo.22.1">Exploring common React Hooks</span><a id="_idTextAnchor046"/></li>
</ul>
<h1 id="_idParaDest-34"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.23.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.24.1">A GitHub repository has been created to host all the code we discuss in the book. </span><span class="koboSpan" id="kobo.24.2">For this chapter, you can find it under </span><a href="https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch2"><span class="koboSpan" id="kobo.25.1">https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch2</span></a><span class="koboSpan" id="kobo.26.1">.</span></p>
<h1 id="_idParaDest-35"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.27.1">Understanding static components in React</span></h1>
<p><span class="koboSpan" id="kobo.28.1">React applications are built on components. </span><span class="koboSpan" id="kobo.28.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.29.1">component</span></strong><span class="koboSpan" id="kobo.30.1"> can</span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.31.1"> range from a simple function returning an HTML snippet to a more complex one that interacts with network requests, dynamically generates HTML tags, and even auto-refreshes based on backend service changes.</span></p>
<p><span class="koboSpan" id="kobo.32.1">Let’s start with a basic scenario and </span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.33.1">define a </span><strong class="bold"><span class="koboSpan" id="kobo.34.1">static component</span></strong><span class="koboSpan" id="kobo.35.1">. </span><span class="koboSpan" id="kobo.35.2">In React, a static component (also known as presentational components or dumb components) refers to a component that doesn’t have any state and doesn’t interact with the data or handle any events. </span><span class="koboSpan" id="kobo.35.3">It is a component that only renders the UI based on the props it receives. </span><span class="koboSpan" id="kobo.35.4">Here’s an example:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.36.1">
const StaticArticle = () =&gt; {
  return (
    &lt;article&gt;
      &lt;h3&gt;Think in components&lt;/h3&gt;
      &lt;p&gt;It's important to change your mindset when coding with 
       React.&lt;/p&gt;
    &lt;/article&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.37.1">This static component closely resembles the corresponding HTML snippet, which uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">&lt;article&gt;</span></strong><span class="koboSpan" id="kobo.39.1"> tag to structure content with a title and a paragraph:</span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.40.1">&lt;article&gt;</span></strong><span class="koboSpan" id="kobo.41.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.42.1">&lt;h3&gt;</span></strong><span class="koboSpan" id="kobo.43.1">Think in components</span><strong class="bold"><span class="koboSpan" id="kobo.44.1">&lt;/h3&gt;</span></strong><span class="koboSpan" id="kobo.45.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.46.1">&lt;p&gt;</span></strong><span class="koboSpan" id="kobo.47.1">It's important to change your mindset when coding with React.</span><strong class="bold"><span class="koboSpan" id="kobo.48.1">&lt;/p&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.49.1">&lt;/article&gt;</span></strong></pre> <p><span class="koboSpan" id="kobo.50.1">While </span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.51.1">encapsulating static HTML in a component is useful, there may be a need for the component to represent different articles, not just a specific one. </span><span class="koboSpan" id="kobo.51.2">Just as we pass parameters to a function to make it more versatile, we can pass parameters into a component to make it useful in different contexts. </span><span class="koboSpan" id="kobo.51.3">That can be done with props, which we will discuss in the next secti</span><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.52.1">on.</span></p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.53.1">Creating components with props</span></h1>
<p><span class="koboSpan" id="kobo.54.1">In React, components can receive input in the form of properties, which are commonly referred to as props. </span><strong class="bold"><span class="koboSpan" id="kobo.55.1">Props</span></strong><span class="koboSpan" id="kobo.56.1"> allow</span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.57.1"> us to pass data from a parent component to its child components. </span><span class="koboSpan" id="kobo.57.2">This mechanism enables components to be reusable and adaptable, as they can receive different sets of props to customize their behavior and appearance.</span></p>
<p><span class="koboSpan" id="kobo.58.1">Props are</span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.59.1"> essentially JavaScript objects containing key-value pairs, where the keys represent the prop names and the values contain the corresponding data. </span><span class="koboSpan" id="kobo.59.2">These props can include various types of data, such as strings, numbers, Booleans, or even functions.</span></p>
<p><span class="koboSpan" id="kobo.60.1">By </span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.61.1">passing props to a component, we can control its rendering and behavior dynamically. </span><span class="koboSpan" id="kobo.61.2">This allows us to create flexible and composable components that can be easily composed together to build complex UIs.</span></p>
<p><span class="koboSpan" id="kobo.62.1">Now, let’s move beyond a static component and see how we can make it more generic by using props. </span><span class="koboSpan" id="kobo.62.2">Suppose we want to display a list of blog posts, each with a heading and a summary. </span><span class="koboSpan" id="kobo.62.3">In HTML, we would manually write the HTML fragments. </span><span class="koboSpan" id="kobo.62.4">However, with React components, we can dynamically generate these HTML fragments using JavaScript.</span></p>
<p><span class="koboSpan" id="kobo.63.1">First, let’s start with the basic structure:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.64.1">
type ArticleType = {
  heading: string;
  summary: string;
};
const Article = ({ heading, summary }: ArticleType) =&gt; {
  return (
    &lt;article&gt;
      &lt;h3&gt;{heading}&lt;/h3&gt;
      &lt;p&gt;{summary}&lt;/p&gt;
    &lt;/article&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.65.1">We can then </span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.66.1">pass the desired </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">heading</span></strong><span class="koboSpan" id="kobo.68.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">summary</span></strong><span class="koboSpan" id="kobo.70.1"> values </span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.71.1">to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">Article</span></strong><span class="koboSpan" id="kobo.73.1"> component:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.74.1">
&lt;Article
  heading="Think in components"
  summary="It's important to change your mindset when coding with React."
</span><span class="koboSpan" id="kobo.74.2">/&gt;</span></pre> <p><span class="koboSpan" id="kobo.75.1">Or, we could define another </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">Article</span></strong><span class="koboSpan" id="kobo.77.1"> component:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.78.1">
&lt;Article
  heading="Define custom hooks"
  summary="Hooks are a great way to share state logic."
</span><span class="koboSpan" id="kobo.78.2">/&gt;</span></pre> <p><span class="koboSpan" id="kobo.79.1">By using props, we can pass different values to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">heading</span></strong><span class="koboSpan" id="kobo.81.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">summary</span></strong><span class="koboSpan" id="kobo.83.1"> props when we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">Article</span></strong><span class="koboSpan" id="kobo.85.1"> component. </span><span class="koboSpan" id="kobo.85.2">This makes the component versatile and reusable, as it can be used to display various articles with different titles and summaries based on the provided props.</span></p>
<p><span class="koboSpan" id="kobo.86.1">Props are a</span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.87.1"> fundamental concept in React that allows us to </span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.88.1">customize and configure components, making them dynamic and adaptable to different data or requirements.</span></p>
<p><span class="koboSpan" id="kobo.89.1">A component can have </span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.90.1">any number of props, although it’s recommended to keep them to a manageable amount, preferably no more than five or six. </span><span class="koboSpan" id="kobo.90.2">This helps maintain clarity and understandability, as having too many props can make the component harder to comprehend </span><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.91.1">and extend.</span></p>
<h1 id="_idParaDest-37"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.92.1">Breaking down UIs into components</span></h1>
<p><span class="koboSpan" id="kobo.93.1">Let’s examine </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.94.1">a more complex UI and explore how to break it down into components and implement them separately. </span><span class="koboSpan" id="kobo.94.2">In this example, we will use a weather application:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.95.1"><img alt="Figure 2.1: A weather application" src="image/B21103_02_01.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.96.1">Figure 2.1: A weather application</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.97.1">The entire application can be defined as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">WeatherApplication</span></strong><span class="koboSpan" id="kobo.99.1"> component, which includes</span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.100.1"> several subcomponents:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.101.1">
const WeatherApplication = () =&gt; {
  return (
    &lt;&gt;
      &lt;Heading title="Weather" /&gt;
      &lt;SearchBox /&gt;
      &lt;Notification /&gt;
      &lt;WeatherList /&gt;
    &lt;/&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.102.1">Each subcomponent can perform various tasks, such as fetching data from a remote server, conditionally rendering a drop-down list, or auto-refreshing periodically.</span></p>
<p><span class="koboSpan" id="kobo.103.1">For example, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">SearchBox</span></strong><span class="koboSpan" id="kobo.105.1"> component might have the following structure:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.106.1">
const SearchBox = () =&gt; {
  return (
    &lt;div className="search-box"&gt;
      &lt;input type="text" /&gt;
      &lt;button&gt;Search&lt;/button&gt;
      &lt;div className="search-results" /&gt;
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.107.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">search-results</span></strong><span class="koboSpan" id="kobo.109.1"> section will only appear when data is fetched from the search query.</span></p>
<p><span class="koboSpan" id="kobo.110.1">On the other </span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.111.1">hand, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">Weather</span></strong><span class="koboSpan" id="kobo.113.1"> component could be more straightforward, rendering whatever is passed to it:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.114.1">
type WeatherType = {
  cityName: string;
  temperature: number;
  weather: string;
};
const Weather = ({ cityName, temperature, weather }: WeatherType) =&gt; {
  return (
    &lt;div&gt;
      &lt;span&gt;{cityName}&lt;/span&gt;
      &lt;span&gt;{temperature}&lt;/span&gt;
      &lt;span&gt;{weather}&lt;/span&gt;
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.115.1">When implementing components in real-world scenarios, it is crucial to pay attention to styling and refine the HTML structure with meticulous detail. </span><span class="koboSpan" id="kobo.115.2">Additionally, components should effectively manage their own state, ensuring consistency and responsiveness across renders.</span></p>
<p><span class="koboSpan" id="kobo.116.1">By grasping the concept of components and their proper structuring in React, you gain the ability to construct dynamic and reusable UI elements that contribute to the overall functionality and organization of your application.</span></p>
<p><span class="koboSpan" id="kobo.117.1">As you advance in your React development journey, don’t forget to polish the visual presentation through styling and consider efficient state management techniques to enhance</span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.118.1"> the performance and interactivity of your components.</span></p>
<p><span class="koboSpan" id="kobo.119.1">A complete </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">Weather</span></strong><span class="koboSpan" id="kobo.121.1"> component could be something like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.122.1">
type Weather = {
  main: string;
  temperature: number;
}
type WeatherType = {
  name: string;
  weather: Weather;
}
export function WeatherCard({ name, weather }: WeatherType) {
  return (
    &lt;div className={`weather-container ${weather.main}`}&gt;
      &lt;h3&gt;{name}&lt;/h3&gt;
      &lt;div className="details"&gt;
        &lt;p className="temperature"&gt;{weather.temperature}&lt;/p&gt;
        &lt;div className="weather"&gt;
          &lt;span className="weather-category"&gt;{weather.main}&lt;/span&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.123.1">The code snippet defines two types: </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">Weather</span></strong><span class="koboSpan" id="kobo.125.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">WeatherType</span></strong><span class="koboSpan" id="kobo.127.1">. </span><span class="koboSpan" id="kobo.127.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">Weather</span></strong><span class="koboSpan" id="kobo.129.1"> type represents the weather data with two properties: </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">main</span></strong><span class="koboSpan" id="kobo.131.1"> (string) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">temperature</span></strong><span class="koboSpan" id="kobo.133.1"> (number). </span><span class="koboSpan" id="kobo.133.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">WeatherType</span></strong><span class="koboSpan" id="kobo.135.1"> type represents the structure of the weather data for a specific location, with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">name</span></strong><span class="koboSpan" id="kobo.137.1"> property (string) for the location name and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">weather</span></strong><span class="koboSpan" id="kobo.139.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">Weather</span></strong><span class="koboSpan" id="kobo.141.1"> type.</span></p>
<p><span class="koboSpan" id="kobo.142.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">WeatherCard</span></strong><span class="koboSpan" id="kobo.144.1"> component receives the name and weather props of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">WeatherType</span></strong><span class="koboSpan" id="kobo.146.1"> type. </span><span class="koboSpan" id="kobo.146.2">Inside the component, it renders a </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">div</span></strong><span class="koboSpan" id="kobo.148.1"> container with a dynamic class based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">weather.main</span></strong><span class="koboSpan" id="kobo.150.1"> value.</span></p>
<p><span class="koboSpan" id="kobo.151.1">When </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.152.1">working on complex UIs, it is crucial to break them down into smaller, manageable components. </span><span class="koboSpan" id="kobo.152.2">Each component should represent a separate concept, and they can be combined together using </span><strong class="bold"><span class="koboSpan" id="kobo.153.1">JSX</span></strong><span class="koboSpan" id="kobo.154.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.155.1">JavaScript Extension</span></strong><span class="koboSpan" id="kobo.156.1">), similar to writing HTML code. </span><span class="koboSpan" id="kobo.156.2">While props are useful for passing data to components, there are situations where we need to maintain data within a component itself. </span><span class="koboSpan" id="kobo.156.3">This is where states come into play, allowing us to manage and update d</span><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.157.1">ata internally.</span></p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.158.1">Managing internal state in React</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.159.1">State</span></strong><span class="koboSpan" id="kobo.160.1"> in</span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.161.1"> React</span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.162.1"> refers to the internal data that components can hold and manage. </span><span class="koboSpan" id="kobo.162.2">It allows components to store and update information, enabling dynamic UI updates, interactivity, and data persistence. </span><span class="koboSpan" id="kobo.162.3">State is a fundamental concept in React that helps build responsive and interactive applications.</span></p>
<p><span class="koboSpan" id="kobo.163.1">Applications feature various state types, such as a Boolean for toggle status, a loading state for network requests, or a user-input string for queries. </span><span class="koboSpan" id="kobo.163.2">We’ll explore the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">useState</span></strong><span class="koboSpan" id="kobo.165.1"> Hook, ideal for maintaining local state within a component across re-renders. </span><span class="koboSpan" id="kobo.165.2">React </span><strong class="bold"><span class="koboSpan" id="kobo.166.1">Hooks</span></strong><span class="koboSpan" id="kobo.167.1"> are </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.168.1">a feature introduced in React 16.8 that enables functional components to have state and lifecycle features (we’ll discuss Hooks in more detail in the </span><i class="italic"><span class="koboSpan" id="kobo.169.1">Exploring common React Hoo</span><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.170.1">ks</span></i><span class="koboSpan" id="kobo.171.1"> section later).</span></p>
<p><span class="koboSpan" id="kobo.172.1">Let’s begin by using a simple Hook for internal state management to understand how it maintains data within a component. </span><span class="koboSpan" id="kobo.172.2">For example, the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">SearchBox</span></strong><span class="koboSpan" id="kobo.174.1"> component can</span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.175.1"> be implemented with something like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.176.1">
const SearchBox = () =&gt; {
  const [query, setQuery] = useState&lt;string&gt;();
  const handleChange = (e: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    const value = e.target.value;
    setQuery(value);
  };
  return (
    &lt;div className="search-box"&gt;
      &lt;input type="text" value={query} onChange={handleChange} /&gt;
      &lt;button&gt;Search&lt;/button&gt;
      &lt;div className="search-results"&gt;{query}&lt;/div&gt;
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.177.1">The code snippet showcases that </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">SearchBox</span></strong><span class="koboSpan" id="kobo.179.1"> includes an input field, a search button, and a display area for search results. </span><span class="koboSpan" id="kobo.179.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">useState</span></strong><span class="koboSpan" id="kobo.181.1"> Hook is used to create a state variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">query</span></strong><span class="koboSpan" id="kobo.183.1">, initialized as an empty string. </span><span class="koboSpan" id="kobo.183.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">handleChange</span></strong><span class="koboSpan" id="kobo.185.1"> function captures the user’s input and updates the query state accordingly. </span><span class="koboSpan" id="kobo.185.2">Then, </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">component</span></strong><span class="koboSpan" id="kobo.187.1"> renders the input field with the current value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">query</span></strong><span class="koboSpan" id="kobo.189.1">, a search button, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">div</span></strong><span class="koboSpan" id="kobo.191.1"> tag as a container displaying the search results.</span></p>
<p><span class="koboSpan" id="kobo.192.1">Note here the </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">useState</span></strong><span class="koboSpan" id="kobo.194.1"> Hook is used to manage state within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">SearchBox</span></strong><span class="koboSpan" id="kobo.196.1"> component:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.197.1">
const [query, setQuery] = useState&lt;string&gt;("");</span></pre> <p><span class="koboSpan" id="kobo.198.1">Let’s explain this code a little more specifically:</span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">useState&lt;string&gt;("")</span></strong><span class="koboSpan" id="kobo.200.1">: This line declares a state variable called query and initializes it with an empty string (</span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">""</span></strong><span class="koboSpan" id="kobo.202.1">)</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">const [query, setQuery]</span></strong><span class="koboSpan" id="kobo.204.1">: This syntax uses array destructuring to assign the state variable (</span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">query</span></strong><span class="koboSpan" id="kobo.206.1">) and its corresponding update function (</span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">setQuery</span></strong><span class="koboSpan" id="kobo.208.1">) to variables with the same names</span></li>
</ul>
<p><span class="koboSpan" id="kobo.209.1">Now, we have</span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.210.1"> the state and the setter function bound to the input box. </span><span class="koboSpan" id="kobo.210.2">As we enter a city name in the input box, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">search-results</span></strong><span class="koboSpan" id="kobo.212.1"> area is automatically updated, along with the input value. </span><span class="koboSpan" id="kobo.212.2">Although there are multiple re-renders occurring as we type, the state value persists throughout the process:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.213.1"><img alt="Figure 2.2: Managing state with useState" src="image/B21103_02_02.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.214.1">Figure 2.2: Managing state with useState</span></figcaption></figure>
<p><span class="koboSpan" id="kobo.215.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">useState</span></strong><span class="koboSpan" id="kobo.217.1"> Hook is excellent for managing internal state, yet real-world projects often require handling various other state types. </span><span class="koboSpan" id="kobo.217.2">As applications expand, managing global-level data shared across multiple components, such as from parent to children, becomes necessary. </span><span class="koboSpan" id="kobo.217.3">We’ll discuss different mechanisms for this kind of state management in later sections.</span></p>
<p><span class="koboSpan" id="kobo.218.1">Now that we have gained an understanding of how props and state enable us to create dynamic components, it is important to explore how changes in data impact the rendering process in React. </span><span class="koboSpan" id="kobo.218.2">By understanding this process, we can take steps to optimize our code for improved efficien</span><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.219.1">cy and performance.</span></p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.220.1">Understanding the rendering process</span></h1>
<p><span class="koboSpan" id="kobo.221.1">When the data</span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.222.1"> that a React component relies on changes, whether it is through updated props or a modified state, React needs to update the UI to reflect those changes. </span><span class="koboSpan" id="kobo.222.2">The process is called </span><strong class="bold"><span class="koboSpan" id="kobo.223.1">rendering</span></strong><span class="koboSpan" id="kobo.224.1">, and is composed of the following steps:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.225.1">Initial render</span></strong><span class="koboSpan" id="kobo.226.1">: When </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.227.1">a functional component is first rendered, it generates a virtual representation of the component’s UI. </span><span class="koboSpan" id="kobo.227.2">This virtual representation describes the structure and content of the UI elements.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.228.1">State and props changes</span></strong><span class="koboSpan" id="kobo.229.1">: When</span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.230.1"> there are changes in the component’s state or props, React re-evaluates the component’s function body. </span><span class="koboSpan" id="kobo.230.2">It performs a diffing algorithm to compare the previous and new function bodies, identifying the differences between them.</span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.231.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.232.1">In React, a </span><strong class="bold"><span class="koboSpan" id="kobo.233.1">diffing</span></strong><span class="koboSpan" id="kobo.234.1"> algorithm is an</span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.235.1"> internal mechanism that compares previous and new </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.236.1">virtual </span><strong class="bold"><span class="koboSpan" id="kobo.237.1">Document Object Model</span></strong><span class="koboSpan" id="kobo.238.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.239.1">DOM</span></strong><span class="koboSpan" id="kobo.240.1">) representations of a component and determines the minimal set of changes needed to update the actual DOM.</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.241.1">Reconciliation</span></strong><span class="koboSpan" id="kobo.242.1">: React </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.243.1">determines which parts of the UI need to be updated based on the differences identified during the diffing process. </span><span class="koboSpan" id="kobo.243.2">It updates only those specific parts of the UI, keeping the rest unchanged.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.244.1">Re-rendering</span></strong><span class="koboSpan" id="kobo.245.1">: React </span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.246.1">re-renders the component by updating the virtual representation of the UI. </span><span class="koboSpan" id="kobo.246.2">It generates a new virtual DOM based on the updated function body, replacing the previous virtual DOM.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.247.1">DOM update</span></strong><span class="koboSpan" id="kobo.248.1">: Finally, React</span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.249.1"> efficiently updates the real DOM to reflect the changes in the virtual DOM. </span><span class="koboSpan" id="kobo.249.2">It applies the necessary DOM manipulations, such as adding, removing, or updating elements, to make the UI reflect the updated state and props.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.250.1">This process ensures that the UI remains in sync with the component’s state and props, enabling a reactive and dynamic UI. </span><span class="koboSpan" id="kobo.250.2">React’s efficient rendering approach minimizes unnecessary DOM manipulations and provides a performant rendering experience in functional components.</span></p>
<p><span class="koboSpan" id="kobo.251.1">In this book, we </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.252.1">will explore situations where writing high-performance code is crucial, ensuring that components only re-render when necessary while preserving unchanged parts. </span><span class="koboSpan" id="kobo.252.2">Achieving this requires utilizing Hooks effectively and employing various techniques to optimize rendering.</span></p>
<p><span class="koboSpan" id="kobo.253.1">In an application, data management is essential, but we also encounter side effects such as network requests, DOM events, and the need for data sharing among components. </span><span class="koboSpan" id="kobo.253.2">To tackle these challenges, React provides a range of commonly used Hooks that serve as powerful tools for building applications. </span><span class="koboSpan" id="kobo.253.3">Let’s explore these Hooks and see how they can greatly assist us</span><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.254.1"> in our development process.</span></p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.255.1">Exploring common React Hooks</span></h1>
<p><span class="koboSpan" id="kobo.256.1">We briefly talked about Hooks in the </span><i class="italic"><span class="koboSpan" id="kobo.257.1">Managing internal state in React</span></i><span class="koboSpan" id="kobo.258.1"> section. </span><span class="koboSpan" id="kobo.258.2">In addition, Hooks allow for code reuse, improved readability, and easier testing by separating concerns and making component logic more modular.</span></p>
<p><span class="koboSpan" id="kobo.259.1">Let’s discuss</span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.260.1"> a few of the most common Hooks in this section. </span><span class="koboSpan" id="kobo.260.2">Please be aware that in this chapter, we are focusing on the most used Hooks. </span><span class="koboSpan" id="kobo.260.3">As we progress through the book, we will delve into several more advanced applications of these Hooks. </span><span class="koboSpan" id="kobo.260.4">Regarding the last Hook, </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">useContext</span></strong><span class="koboSpan" id="kobo.262.1">, we will initially explore its basic usage at the end of this section to provide an introductory understanding. </span><span class="koboSpan" id="kobo.262.2">In later chapters, we’ll employ </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">useContext</span></strong><span class="koboSpan" id="kobo.264.1"> in more complex scenarios, allowing for a deeper and more practica</span><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.265.1">l grasp of its functionality.</span></p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.266.1">useState</span></h2>
<p><span class="koboSpan" id="kobo.267.1">We have </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.268.1">already seen the basic usage of </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">useState</span></strong><span class="koboSpan" id="kobo.270.1"> Hook previously in this chapter. </span><span class="koboSpan" id="kobo.270.2">You </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.271.1">can define as many states as you like inside a component, and it’s quite common to do so in real-world projects. </span><span class="koboSpan" id="kobo.271.2">For example, a login form might include a username, a password, and a </span><strong class="bold"><span class="koboSpan" id="kobo.272.1">Remember Me</span></strong><span class="koboSpan" id="kobo.273.1"> flag. </span><span class="koboSpan" id="kobo.273.2">All these states need to be remembered before the user clicks the submit (</span><strong class="bold"><span class="koboSpan" id="kobo.274.1">Login</span></strong><span class="koboSpan" id="kobo.275.1">) button:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer017">
<span class="koboSpan" id="kobo.276.1"><img alt="Figure 2.3: Login form" src="image/B21103_02_03.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.277.1">Figure 2.3: Login form</span></figcaption></figure>
<p><span class="koboSpan" id="kobo.278.1">Based </span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.279.1">on the UI, we’ll need three different states for the username, password, and a Boolean</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.280.1"> flag for </span><strong class="bold"><span class="koboSpan" id="kobo.281.1">Remember Me</span></strong><span class="koboSpan" id="kobo.282.1">, like so:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.283.1">
const Login = () =&gt; {
  const [username, setUsername] = useState&lt;string&gt;("");
  const [password, setPassword] = useState&lt;string&gt;("");
  const [rememberMe, setRememberMe] = useState&lt;boolean&gt;(false);
  return (
    &lt;div className="login-form"&gt;
      &lt;div className="field"&gt;
        &lt;input
          type="text"
          value={username}
          onChange={(event) =&gt; setUsername(event.target.value)}
          placeholder="Username"
        /&gt;
      &lt;/div&gt;
      &lt;div className="field"&gt;
        &lt;input
          type="password"
          value={password}
          onChange={(event) =&gt; setPassword(event.target.value)}
          placeholder="Password"
        /&gt;
      &lt;/div&gt;
      &lt;div className="field"&gt;
        &lt;label&gt;
          &lt;input
            type="checkbox"
            checked={rememberMe}
            onChange={(event) =&gt; setRememberMe(event.target.checked)}
          /&gt;
          Remember Me
        &lt;/label&gt;
      &lt;/div&gt;
      &lt;div className="field"&gt;
        &lt;button&gt;Login&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.284.1">In the</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.285.1"> code </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.286.1">snippet, we have to manage three different states, so it uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">useState</span></strong><span class="koboSpan" id="kobo.288.1"> Hook to manage state for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">username</span></strong><span class="koboSpan" id="kobo.290.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">password</span></strong><span class="koboSpan" id="kobo.292.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">rememberMe</span></strong><span class="koboSpan" id="kobo.294.1"> fields. </span><span class="koboSpan" id="kobo.294.2">The component renders input fields for username and password, a checkbox for </span><strong class="bold"><span class="koboSpan" id="kobo.295.1">Remember Me</span></strong><span class="koboSpan" id="kobo.296.1">, and a </span><strong class="bold"><span class="koboSpan" id="kobo.297.1">Login</span></strong><span class="koboSpan" id="kobo.298.1"> button. </span><span class="koboSpan" id="kobo.298.2">User input updates the corresponding state variables, </span><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.299.1">enabling the capture of form data.</span></p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.300.1">useEffect</span></h2>
<p><span class="koboSpan" id="kobo.301.1">In React, a </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.302.1">side effect </span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.303.1">refers to any code that is not directly related to rendering a component but has an impact outside the component’s scope. </span><span class="koboSpan" id="kobo.303.2">Side effects often involve interacting with external resources, such as making API calls, modifying the underlying DOM (not using the normal React virtual DOM), subscribing to event listeners, or managing timers.</span></p>
<p><span class="koboSpan" id="kobo.304.1">React provides a built-in Hook called </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">useEffect</span></strong><span class="koboSpan" id="kobo.306.1"> to handle side effects within functional components. </span><span class="koboSpan" id="kobo.306.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">useEffect</span></strong><span class="koboSpan" id="kobo.308.1"> Hook allows you to perform side effects after rendering or when specific dependencies change.</span></p>
<p><span class="koboSpan" id="kobo.309.1">By using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">useEffect</span></strong><span class="koboSpan" id="kobo.311.1"> Hook, you can ensure that side effects are executed at the appropriate times during the component’s lifecycle. </span><span class="koboSpan" id="kobo.311.2">This helps maintain the consistency and integrity of the application while separating side effects from the core rendering logic.</span></p>
<p><span class="koboSpan" id="kobo.312.1">Let’s take a look at a typical use case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">useEffect</span></strong><span class="koboSpan" id="kobo.314.1">. </span><span class="koboSpan" id="kobo.314.2">We created an </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">Article</span></strong><span class="koboSpan" id="kobo.316.1"> component in the </span><i class="italic"><span class="koboSpan" id="kobo.317.1">Creating components with props</span></i><span class="koboSpan" id="kobo.318.1"> section; now, let’s make a list of articles. </span><span class="koboSpan" id="kobo.318.2">Normally, an article list could return from some API calls; in JSON format, for example. </span><span class="koboSpan" id="kobo.318.3">We can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">useEffect</span></strong><span class="koboSpan" id="kobo.320.1"> Hook to send the request and set state once the response is returned from an API call, like so:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.321.1">
const ArticleList = () =&gt; {
  const [articles, setArticles] = useState&lt;ArticleType[]&gt;([]);
  useEffect(() =&gt; {
    const fetchArticles = async () =&gt; {
      fetch("/api/articles")
        .then((res) =&gt; res.json())
        .then((data) =&gt; setArticles(data));
    };
    fetchArticles();
  }, []);
  return (
    &lt;div&gt;
      {articles.map((article) =&gt; (
        &lt;Article heading={article.heading} summary={article.summary} 
         /&gt;
      ))}
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.322.1">The code </span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.323.1">snippet</span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.324.1"> demonstrates the usage of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">useEffect</span></strong><span class="koboSpan" id="kobo.326.1"> Hook in a React functional component. </span><span class="koboSpan" id="kobo.326.2">Let’s break it down:</span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">useEffect(() =&gt; { ... </span><span class="koboSpan" id="kobo.327.2">}, []);</span></strong><span class="koboSpan" id="kobo.328.1">: This line declares the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">useEffect</span></strong><span class="koboSpan" id="kobo.330.1"> Hook and provides two arguments. </span><span class="koboSpan" id="kobo.330.2">The first argument is a callback function that contains the side effect code to be executed. </span><span class="koboSpan" id="kobo.330.3">The second argument is an array of dependencies that determines when the side effect should be triggered. </span><span class="koboSpan" id="kobo.330.4">An empty array, </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">[]</span></strong><span class="koboSpan" id="kobo.332.1">, indicates that the side effect should only run once during the initial render.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">const fetchArticles = async () =&gt; { ... </span><span class="koboSpan" id="kobo.333.2">}</span></strong><span class="koboSpan" id="kobo.334.1">: This line declares an asynchronous function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">fetchArticles</span></strong><span class="koboSpan" id="kobo.336.1">. </span><span class="koboSpan" id="kobo.336.2">Inside this function, an API call is made to fetch data from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">/</span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">api/articles</span></strong><span class="koboSpan" id="kobo.339.1"> endpoint.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">fetch("/api/articles")...</span></strong><span class="koboSpan" id="kobo.341.1">: This line uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">fetch</span></strong><span class="koboSpan" id="kobo.343.1"> function to make a </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">GET</span></strong><span class="koboSpan" id="kobo.345.1"> request to the specified API endpoint. </span><span class="koboSpan" id="kobo.345.2">The response is then processed using promises (</span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">then</span></strong><span class="koboSpan" id="kobo.347.1">) to extract the JSON data.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">setArticles(data)</span></strong><span class="koboSpan" id="kobo.349.1">: This line updates the component’s state variable articles with the retrieved data using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">setArticles</span></strong><span class="koboSpan" id="kobo.351.1"> function. </span><span class="koboSpan" id="kobo.351.2">This will trigger a re-render of the component with the updated data.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">fetchArticles()</span></strong><span class="koboSpan" id="kobo.353.1">: This line invokes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">fetchArticles</span></strong><span class="koboSpan" id="kobo.355.1"> function, triggering the API call and updating the article’s state.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.356.1">Once we</span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.357.1"> have </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.358.1">these articles, we can then use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">array.map</span></strong><span class="koboSpan" id="kobo.360.1"> collection API to generate a list of articles.</span></p>
<p><span class="koboSpan" id="kobo.361.1">It’s worth mentioning that when strict mode is on, in development, React runs setup and cleanup one extra time before the actual setup. </span><span class="koboSpan" id="kobo.361.2">In practice, you can wrap the whole application inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">StrictMode</span></strong><span class="koboSpan" id="kobo.363.1"> built-in component from React, and your components will re-render an extra time to find bugs caused by impure rendering along with other checks.</span></p>
<p><span class="koboSpan" id="kobo.364.1">Also, note that the second parameter of </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">useEffect</span></strong><span class="koboSpan" id="kobo.366.1"> is critical. </span><span class="koboSpan" id="kobo.366.2">We used an empty array previously as we don’t want the effect to trigger each time, but there are cases we would like to perform the effect whenever one of the dependencies changes.</span></p>
<p><span class="koboSpan" id="kobo.367.1">For example, let’s say we have an </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">ArticleDetail</span></strong><span class="koboSpan" id="kobo.369.1"> component, and whenever the </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">id</span></strong><span class="koboSpan" id="kobo.371.1"> prop of the article changes, we need to re-fetch the data and re-render:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.372.1">
const ArticleDetail = ({ id }: { id: string }) =&gt; {
  const [article, setArticle] = useState&lt;ArticleType&gt;();
  useEffect(() =&gt; {
    const fetchArticleDetail = async (id: string) =&gt; {
      fetch(`/api/articles/${id}`)
        .then((res) =&gt; res.json())
        .then((data) =&gt; setArticle(data));
    };
    fetchArticleDetail(id);
  }, [id]);
  return (
    &lt;div&gt;
      {article &amp;&amp; (
        &lt;Article heading={article.heading} summary={article.summary} 
         /&gt;
      )}
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.373.1">Inside </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.374.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">useEffect</span></strong><span class="koboSpan" id="kobo.376.1"> Hook, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">fetchArticleDetail</span></strong><span class="koboSpan" id="kobo.378.1"> function is defined to handle the API call. </span><span class="koboSpan" id="kobo.378.2">It fetches the article details based on the provided </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">id</span></strong><span class="koboSpan" id="kobo.380.1"> prop, converts</span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.381.1"> the response to JSON, and updates the article state using </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">setArticle</span></strong><span class="koboSpan" id="kobo.383.1">.</span></p>
<p><span class="koboSpan" id="kobo.384.1">The effect is triggered when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">id</span></strong><span class="koboSpan" id="kobo.386.1"> prop changes. </span><span class="koboSpan" id="kobo.386.2">Upon successful retrieval of the article data, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">Article</span></strong><span class="koboSpan" id="kobo.388.1"> component is rendered with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">heading</span></strong><span class="koboSpan" id="kobo.390.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">summary</span></strong><span class="koboSpan" id="kobo.392.1"> properties from the article state.</span></p>
<p><span class="koboSpan" id="kobo.393.1">An essential feature of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">useEffect</span></strong><span class="koboSpan" id="kobo.395.1"> Hook for handling side effects is the cleanup mechanism. </span><span class="koboSpan" id="kobo.395.2">When using </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">useEffect</span></strong><span class="koboSpan" id="kobo.397.1">, it’s recommended to return a cleanup function that React will call upon the component’s unmounting. </span><span class="koboSpan" id="kobo.397.2">For instance, if you set up a timer within </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">useEffect</span></strong><span class="koboSpan" id="kobo.399.1">, you should provide a function that clears this timer as the return value. </span><span class="koboSpan" id="kobo.399.2">This ensures proper resource management and prevents potential memory leaks in your application.</span></p>
<p><span class="koboSpan" id="kobo.400.1">For example, let’s say we have a component that needs to execute an effect 1 second after the initial rendering, as seen here:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.401.1">
const Timer = () =&gt; {
  useEffect(() =&gt; {
    const timerId = setTimeout(() =&gt; {
      console.log("time is up")
    }, 1000);
    return () =&gt; {
      clearTimeout(timerId)
    }
  }, [])
  return &lt;div&gt;Hello timer&lt;/div&gt;
}</span></pre> <p><span class="koboSpan" id="kobo.402.1">So, within </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.403.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">Timer</span></strong><span class="koboSpan" id="kobo.405.1"> component, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">useEffect</span></strong><span class="koboSpan" id="kobo.407.1"> Hook is used to handle a</span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.408.1"> side effect. </span><span class="koboSpan" id="kobo.408.2">As the component mounts, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">setTimeout</span></strong><span class="koboSpan" id="kobo.410.1"> function is set up to log the message </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">time is up</span></strong><span class="koboSpan" id="kobo.412.1"> after a delay of </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">1000</span></strong><span class="koboSpan" id="kobo.414.1"> milliseconds. </span><span class="koboSpan" id="kobo.414.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">useEffect</span></strong><span class="koboSpan" id="kobo.416.1"> Hook then returns a cleanup function to prevent memory leaks. </span><span class="koboSpan" id="kobo.416.2">This cleanup function uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">clearTimeout</span></strong><span class="koboSpan" id="kobo.418.1"> to clear the timer identified by </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">timerId</span></strong><span class="koboSpan" id="kobo.420.1"> when the component unmounts.</span></p>
<p><span class="koboSpan" id="kobo.421.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">ArticleDetail</span></strong><span class="koboSpan" id="kobo.423.1"> example, the complete version with the cleanup function would be something like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.424.1">
useEffect(() =&gt; {
  const controller = new AbortController();
  const signal = controller.signal;
  const fetchArticleDetail = async (id: string) =&gt; {
    fetch(`/api/articles/${id}`, { signal })
      .then((res) =&gt; res.json())
      .then((data) =&gt; setArticle(data));
  };
  fetchArticleDetail(id);
  return () =&gt; {
    controller.abort();
  };
}, [id]);</span></pre> <p><span class="koboSpan" id="kobo.425.1">In this </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.426.1">code snippet, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">AbortController</span></strong><span class="koboSpan" id="kobo.428.1"> component is used within a </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">useEffect</span></strong><span class="koboSpan" id="kobo.430.1"> Hook to manage the lifecycle of a network request. </span><span class="koboSpan" id="kobo.430.2">When the component mounts, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">useEffect</span></strong><span class="koboSpan" id="kobo.432.1"> Hook triggers, creating a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">AbortController</span></strong><span class="koboSpan" id="kobo.434.1"> and extracting its signal. </span><span class="koboSpan" id="kobo.434.2">This signal is passed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">fetch</span></strong><span class="koboSpan" id="kobo.436.1"> function, linking the request to the controller.</span></p>
<p><span class="koboSpan" id="kobo.437.1">If the component unmounts</span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.438.1"> before the request completes, the cleanup function is called, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">abort</span></strong><span class="koboSpan" id="kobo.440.1"> method of the controller to cancel the ongoing fetch request. </span><span class="koboSpan" id="kobo.440.2">This prevents potential issues such as updating the state of an unmounted component, ensuring better performance and avoiding memory leaks.</span></p>
<p><span class="koboSpan" id="kobo.441.1">Let’s now turn our attention to another crucial Hook that enhances performance by preventing un</span><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.442.1">necessary function creation during re-renders.</span></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.443.1">useCallback</span></h2>
<p><span class="koboSpan" id="kobo.444.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">useCallback</span></strong><span class="koboSpan" id="kobo.446.1"> Hook</span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.447.1"> in React is used to memoize and optimize the</span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.448.1"> creation of callback functions. </span><span class="koboSpan" id="kobo.448.2">It is particularly useful when passing callbacks to child components or when using callbacks as dependencies in other Hooks. </span><span class="koboSpan" id="kobo.448.3">You can see it in action here:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.449.1">
const memoizedCallback = useCallback(callback, dependencies);</span></pre> <p><span class="koboSpan" id="kobo.450.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">useCallback</span></strong><span class="koboSpan" id="kobo.452.1"> Hook takes two arguments:</span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">callback</span></strong><span class="koboSpan" id="kobo.454.1">: This is the function that you want to memoize. </span><span class="koboSpan" id="kobo.454.2">It can be an inline function or a function reference.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">dependencies</span></strong><span class="koboSpan" id="kobo.456.1">: This is an array of dependencies that the memoized callback depends on. </span><span class="koboSpan" id="kobo.456.2">If any of the dependencies change, the callback will be recreated.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.457.1">Let’s explore a </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.458.1">practical example. </span><span class="koboSpan" id="kobo.458.2">We require an editor component to modify the summary of an article. </span><span class="koboSpan" id="kobo.458.3">Whenever a user types a character, the summary needs to be updated, triggering a re-render. </span><span class="koboSpan" id="kobo.458.4">However, this re-rendering can result in the creation of a new function each time, which can impact performance. </span><span class="koboSpan" id="kobo.458.5">To mitigate this, we can utilize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">useCallback</span></strong><span class="koboSpan" id="kobo.460.1"> Hook to optimize the rendering process and avoid unnecessary function recreations:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.461.1">
const ArticleEditor = ({ id }: { id: string }) =&gt; {
  const submitChange = useCallback(
    async (summary: string) =&gt; {
      try {
        await fetch(`/api/articles/${id}`, {
          method: "POST",
          body: JSON.stringify({ id, summary }),
          headers: {
            "Content-Type": "application/json",
          },
        });
      } catch (error) {
        // handling errors
      }
    },
    [id]
  );
  return (
    &lt;div&gt;
      &lt;ArticleForm onSubmit={submitChange} /&gt;
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.462.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">ArticleEditor</span></strong><span class="koboSpan" id="kobo.464.1"> component, </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">useCallback</span></strong><span class="koboSpan" id="kobo.466.1"> is used to memoize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">submitChange</span></strong><span class="koboSpan" id="kobo.468.1"> function, which</span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.469.1"> asynchronously makes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">POST</span></strong><span class="koboSpan" id="kobo.471.1"> request to update an article, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">fetch</span></strong><span class="koboSpan" id="kobo.473.1"> API. </span><span class="koboSpan" id="kobo.473.2">This optimization with </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">useCallback</span></strong><span class="koboSpan" id="kobo.475.1"> ensures that </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">submitChange</span></strong><span class="koboSpan" id="kobo.477.1"> is only recreated when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">id</span></strong><span class="koboSpan" id="kobo.479.1"> prop changes, enhancing performance by reducing unnecessary recalculations.</span></p>
<p><span class="koboSpan" id="kobo.480.1">The component </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.481.1">then renders </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">ArticleForm</span></strong><span class="koboSpan" id="kobo.483.1">, passing </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">submitChange</span></strong><span class="koboSpan" id="kobo.485.1"> as a prop for handling form submissions:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.486.1">
const ArticleForm = ({ onSubmit }: { onSubmit: (summary: string) =&gt; void }) =&gt; {
  const [summary, setSummary] = useState&lt;string&gt;("");
  const handleSubmit = (e: FormEvent) =&gt; {
    e.preventDefault();
    onSubmit(summary);
  };
  const handleSummaryChange = useCallback(
    (event: ChangeEvent&lt;HTMLTextAreaElement&gt;) =&gt; {
      setSummary(event.target.value);
    },
    []
  );
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;h2&gt;Edit Article&lt;/h2&gt;
      &lt;textarea value={summary} onChange={handleSummaryChange} /&gt;
      &lt;button type="submit"&gt;Save&lt;/button&gt;
    &lt;/form&gt;
  );
};</span></pre> <p><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">ArticleForm</span></strong><span class="koboSpan" id="kobo.488.1"> uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">useState</span></strong><span class="koboSpan" id="kobo.490.1"> Hooks to </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.491.1">track the summary state. </span><span class="koboSpan" id="kobo.491.2">When</span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.492.1"> the form is submitted, </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">handleSubmit</span></strong><span class="koboSpan" id="kobo.494.1"> prevents the default form action and calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">onSubmit</span></strong><span class="koboSpan" id="kobo.496.1"> with the current summary. </span><span class="koboSpan" id="kobo.496.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">handleSummaryChange</span></strong><span class="koboSpan" id="kobo.498.1"> function, optimized with </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">useCallback</span></strong><span class="koboSpan" id="kobo.500.1">, updates the summary state based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">textarea</span></strong><span class="koboSpan" id="kobo.502.1"> input. </span><span class="koboSpan" id="kobo.502.2">This use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">useCallback</span></strong><span class="koboSpan" id="kobo.504.1"> ensures the function doesn’t get recreated </span><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.505.1">unnecessarily on each render, improving performance.</span></p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.506.1">The React Context API</span></h2>
<p><span class="koboSpan" id="kobo.507.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.508.1">React Context API</span></strong><span class="koboSpan" id="kobo.509.1"> is a </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.510.1">feature that allows you to pass data directly through the component tree, without having to pass props down manually at every level. </span><span class="koboSpan" id="kobo.510.2">This comes in handy when your application has global data that many components share, or when you have to pass data through components that don’t necessarily need the data but have to pass it down to their children.</span></p>
<p><span class="koboSpan" id="kobo.511.1">For example, imagine that we are creating an application that includes a dark or light theme, depending on the current time (for instance, if it’s daytime, we use light mode). </span><span class="koboSpan" id="kobo.511.2">We would need to set the theme at the root level.</span></p>
<p><span class="koboSpan" id="kobo.512.1">So, first, we define a type </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">ThemeContextType</span></strong><span class="koboSpan" id="kobo.514.1"> and create a context instance </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">ThemeContext</span></strong><span class="koboSpan" id="kobo.516.1"> of the type:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.517.1">
import React from "react";
export type ThemeContextType = {
  theme: "light" | "dark";
};
export const ThemeContext = React.createContext&lt;ThemeContextType | undefined&gt;(
  undefined
);</span></pre> <p><span class="koboSpan" id="kobo.518.1">Then, we create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">ThemeProvider</span></strong><span class="koboSpan" id="kobo.520.1"> component, which will use a React state to manage the current theme:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.521.1">
import React, { useState } from "react";
import { ThemeContext, ThemeContextType } from "./ThemeContext";
export const ThemeProvider = ({ children }) =&gt; {
  const [theme, setTheme] = useState&lt;"light" | "dark"&gt;("light");
  const value: ThemeContextType = { theme };
  return (
    &lt;ThemeContext.Provider value={value}&gt;{children}&lt;/ThemeContext.Provider&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.522.1">Finally, we can use</span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.523.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">ThemeProvider</span></strong><span class="koboSpan" id="kobo.525.1"> component in our application:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.526.1">
import React from "react";
import { ThemeProvider } from "./ThemeProvider";
import App from "./App";
const Root = () =&gt; {
  return (
    &lt;ThemeProvider&gt;
      &lt;App /&gt;
    &lt;/ThemeProvider&gt;
  );
};
export default Root;</span></pre> <p><span class="koboSpan" id="kobo.527.1">In any component in our application, we can now access the current theme:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.528.1">
import React, { useContext } from "react";
import { ThemeContext } from "./ThemeContext";
const ThemedComponent = () =&gt; {
  const context = useContext(ThemeContext);
  const { theme } = context;
  return &lt;div className={theme}&gt;Current Theme: {theme}&lt;/div&gt;;
};
export default ThemedComponent;</span></pre> <p><span class="koboSpan" id="kobo.529.1">In this setup, </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">ThemeContext</span></strong><span class="koboSpan" id="kobo.531.1"> provides</span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.532.1"> the current theme to any components in the tree that are interested in it. </span><span class="koboSpan" id="kobo.532.2">The theme is stored in a state variable in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">ThemeProvider</span></strong><span class="koboSpan" id="kobo.534.1"> component, which is the root component of the app.</span></p>
<p><span class="koboSpan" id="kobo.535.1">The provided code may not offer much utility since the theme cannot be modified. </span><span class="koboSpan" id="kobo.535.2">However, by utilizing the Context API, you can define a modifier that allows children nodes to alter the status. </span><span class="koboSpan" id="kobo.535.3">This mechanism proves highly beneficial for data sharing, making it a valuable tool. </span><span class="koboSpan" id="kobo.535.4">Let’s modify the context interface a little bit:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.536.1">
type Theme = {
  theme: "light" | "dark";
  toggleTheme: () =&gt; void;
};
const ThemeContext = React.createContext&lt;Theme&gt;({
  theme: "light",
  toggleTheme: () =&gt; {},
});</span></pre> <p><span class="koboSpan" id="kobo.537.1">We added a </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">toggleTheme</span></strong><span class="koboSpan" id="kobo.539.1"> function in the context so that the component can modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">theme</span></strong><span class="koboSpan" id="kobo.541.1"> value when needed.</span></p>
<p><span class="koboSpan" id="kobo.542.1">To implement the</span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.543.1"> provider, we can utilize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">useState</span></strong><span class="koboSpan" id="kobo.545.1"> Hook to define an internal state. </span><span class="koboSpan" id="kobo.545.2">By exposing the setter function, the children components can utilize it to update the value of the theme:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.546.1">
const ThemeProvider = ({ children }: { children: ReactNode }) =&gt; {
  // default theme is light
  const [theme, setTheme] = useState&lt;"light" | "dark"&gt;("light");
  const toggleTheme = useCallback(() =&gt; {
    setTheme((prevTheme) =&gt; (prevTheme === "light" ? </span><span class="koboSpan" id="kobo.546.2">"dark" : "light"));
  }, []);
  return (
    &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.547.1">And then, in the calling site, it’s straightforward to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">useContext</span></strong><span class="koboSpan" id="kobo.549.1"> Hook to access values in the context:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.550.1">
const Article = ({ heading, summary }: ArticleType) =&gt; {
  const { theme, toggleTheme } = useContext(ThemeContext);
  return (
    &lt;article className={theme}&gt;
      &lt;h3&gt;{heading}&lt;/h3&gt;
      &lt;p&gt;{summary}&lt;/p&gt;
      &lt;button onClick={toggleTheme}&gt;Toggle&lt;/button&gt;
    &lt;/article&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.551.1">Then, whenever </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.552.1">we click the </span><strong class="bold"><span class="koboSpan" id="kobo.553.1">Toggle</span></strong><span class="koboSpan" id="kobo.554.1"> button, it will change the theme and trigger a re-render:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer018">
<span class="koboSpan" id="kobo.555.1"><img alt="Figure 2.4: Using a theme context" src="image/B21103_02_04.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.556.1">Figure 2.4: Using a theme context</span></figcaption></figure>
<p><span class="koboSpan" id="kobo.557.1">In React, the Context API allows you to create and manage global state that can be accessed by components throughout your application. </span><span class="koboSpan" id="kobo.557.2">This capability enables you to combine multiple context providers, each representing a different slice or aspect of your application’s state.</span></p>
<p><span class="koboSpan" id="kobo.558.1">By using separate context providers, such as one for security, another for logging, and potentially others, you can organize and share related data and functionality efficiently. </span><span class="koboSpan" id="kobo.558.2">Each context provider encapsulates a specific concern, making it easier to manage and update related state without impacting other parts of the application:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.559.1">
import InteractionContext from "xui/interaction-context";
import SecurityContext from "xui/security-context";
import LoggingContext from "xui/logging-context";
const Application = ({ children }) =&gt; {
  const context = {}; // ... </span><span class="koboSpan" id="kobo.559.2">define values for context
  //... </span><span class="koboSpan" id="kobo.559.3">define securityContext
  //... </span><span class="koboSpan" id="kobo.559.4">define loggingContext
  return (
    &lt;InteractionContext.Provider value={context}&gt;
      &lt;SecurityContext.Provider value={securityContext}&gt;
        &lt;LoggingContext.Provider value={loggingContext}&gt;
          {children}
        &lt;/LoggingContext.Provider&gt;
      &lt;/SecurityContext.Provider&gt;
    &lt;/InteractionContext.Provider&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.560.1">This example </span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.561.1">demonstrates the usage of React’s Context API to create and combine multiple context providers within an application component. </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">InteractionContext.Provider</span></strong><span class="koboSpan" id="kobo.563.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">SecurityContext.Provider</span></strong><span class="koboSpan" id="kobo.565.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">LoggingContext.Provider</span></strong><span class="koboSpan" id="kobo.567.1"> are used to wrap the children components and provide the respective context values.</span></p>
<p><span class="koboSpan" id="kobo.568.1">There are several additional built-in Hooks available in React that are used less frequently. </span><span class="koboSpan" id="kobo.568.2">In the </span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.569.1">following chapters, we will introduce these Hooks as needed, focusin</span><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.570.1">g on the ones that are most relevant to the topics at hand.</span></p>
<h1 id="_idParaDest-45"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.571.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.572.1">In this introductory chapter, we covered essential concepts of React and laid the groundwork for your React development journey. </span><span class="koboSpan" id="kobo.572.2">We explored the concept of thinking in components, emphasizing the importance of breaking down applications into reusable and modular pieces. </span><span class="koboSpan" id="kobo.572.3">By adopting this mindset, you’ll be able to create maintainable and scalable code bases.</span></p>
<p><span class="koboSpan" id="kobo.573.1">Furthermore, we introduced you to the most commonly used Hooks in React, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">useState</span></strong><span class="koboSpan" id="kobo.575.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">useEffect</span></strong><span class="koboSpan" id="kobo.577.1">, which empower you to manage state and handle side effects efficiently within functional components. </span><span class="koboSpan" id="kobo.577.2">These Hooks provide the flexibility and power to build dynamic and interactive UIs.</span></p>
<p><span class="koboSpan" id="kobo.578.1">By mastering the fundamental principles of React and familiarizing yourself with the concept of thinking in components, you are now well prepared to dive deeper into the world of React development. </span><span class="koboSpan" id="kobo.578.2">In the upcoming chapters, we will explore more advanced topics and tackle real-world challenges, enabling you to become a proficient React developer.</span></p>
<p><span class="koboSpan" id="kobo.579.1">Remember – React is a powerful tool that opens endless possibilities for creating modern and robust web applications. </span><span class="koboSpan" id="kobo.579.2">In the upcoming chapter, we will delve into the process of breaking down a design into smaller components and explore effective strategies for organizing these components. </span><span class="koboSpan" id="kobo.579.3">We will emphasize the importance of reusability and flexibility, ensuring that our components are adaptable to future changes.</span></p>
</section>
</body></html>