- en: '*Chapter 6*: Authentication with Apollo and React'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have come a long way over the last few chapters. We have now reached the
    point where we are going to implement authentication for our React and GraphQL
    web applications. In this chapter, you are going to learn about some essential
    concepts for building an application with authentication using GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a JWT?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cookies versus localStorage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing authentication in Node.js and Apollo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signing up and logging in users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating GraphQL queries and mutations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing the user from the request context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available in the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter06)'
  prefs: []
  type: TYPE_NORMAL
- en: What are JSON Web Tokens?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSON Web Tokens** (**JWTs**) are still a pretty new standard for carrying
    out authentication; not everyone knows about them, and even fewer people use them.
    This section does not provide a theoretical excursion through the mathematical
    or cryptographic basics of JWTs.'
  prefs: []
  type: TYPE_NORMAL
- en: In traditional web applications written using PHP, for example, you commonly
    have a session cookie. This cookie identifies the user session on the server.
    The session must be stored on the server to retrieve the initial user. The problem
    here is that the overhead of saving and querying all the sessions for all the
    users can be high. When using JWTs, however, there is no need for the server to
    preserve any kind of session ID.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, a JWT consists of everything you need to identify a user.
    The most common approach is to store the creation time of the token, the username,
    the user ID, and maybe the role, such as an admin or a normal user. You should
    not include any personal or critical data for security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: The reason a JWT exists is not to encrypt or secure data in any way. Instead,
    to authorize yourself using a resource such as a server, you send a signed JWT
    that your server can verify. It can only verify the JWT if it was created by a
    service stated as authentic by your server. In most cases, your server will have
    used its public key to sign the token. Any person or service that can read the
    communication between you and the server can access the token and can extract
    the payload without further ado. They are not able to edit its content though,
    because the token is signed with a signature.
  prefs: []
  type: TYPE_NORMAL
- en: The token needs to be transported and stored securely in the browser of the
    client. If the token gets into the wrong hands, that person can access the affected
    application with your identity, initiate actions in your name, or read personal
    data. It is also hard to invalidate a JWT. With a session cookie, you can delete
    the session on the server, and the user will no longer be authenticated through
    the cookie. With a JWT, however, we do not have any information on the server.
    It can only validate the signature of the token and find the user in your database.
    One common approach is to have a blacklist of all the disallowed tokens. Alternatively,
    you can keep the lifetime of a JWT low by specifying the expiration date. This
    solution, however, requires the user to frequently repeat the login process, which
    makes the experience less comfortable.
  prefs: []
  type: TYPE_NORMAL
- en: 'JWTs do not require any server-side storage. The great thing about server-side
    sessions is that you can store specific application states for your user and,
    for example, remember the last actions a user performed. Without a server-side
    store, you either need to implement these features in `localStorage` or implement
    a session store, which is not required for using JWT authentication at all:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'JWTs are an important topic in developer communities. There is some excellent
    documentation available related to what JWTs are, how they can be used, and their
    technological background. Visit the following web page to learn more and to see
    a demonstration of the generation of a JWT: [https://jwt.io/](https://jwt.io/).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – JWT structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.01_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – JWT structure
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the preceding diagram, a JWT consists of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HEADER**: The header specifies the algorithm that was used to generate the
    JWT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PAYLOAD**: The payload consists of all the "session" data, which are called
    claims. The preceding is just a simple representation and does not show the full
    complexity of a JWT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SIGNATURE**: The signature is calculated from the header and payload. To
    verify if a JWT has not been tampered with, the signature is compared to the newly
    generated signature from the actual payload and header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our example, we are going to use JWTs, since they are a modern and decentralized
    method of authentication. Still, you can choose to opt out of this at any point
    and use regular sessions instead, which can be quickly realized in Express.js
    and GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at the different ways of storing the JWT inside
    the browser and how to transmit between `localStorage` and cookies.
  prefs: []
  type: TYPE_NORMAL
- en: localStorage versus cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at another critical question. It is crucial to understand at least
    the basics of how authentication works and how it is secured. You are responsible
    for any faulty implementation that allows data breaches to occur, so always keep
    this in mind. Where do we store the token we receive from the server?
  prefs: []
  type: TYPE_NORMAL
- en: In whichever direction you send a token, you should always be sure that your
    communication is secure. For web applications like ours, be sure that HTTPS is
    enabled and used for all requests. Once the user has successfully authenticated,
    the client receives the JWT, according to the JWT authentication workflow. A JWT
    is not tied to any particular storage medium, so you are free to choose whichever
    you prefer. If we do not store the token when it is received, it will be only
    available in the memory. While the user is browsing our site, this is fine, but
    the moment they refresh the page, they will need to log in again because we haven't
    stored the token anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two standard options: to store the JWT inside `localStorage` or to
    store it inside a cookie. Let''s start by discussing the first option. `localStorage`
    is the option that''s often suggested in tutorials. This is fine, assuming you
    are writing a single-page web application where the content changes dynamically,
    depending on the actions of the user and client-side routing. We do not follow
    any links and load new sites to see new content; instead, the old one is just
    replaced with the new page that you want to show.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Storing the token in `localStorage` has the following disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`localStorage` is not transmitted on every request. When the page is loaded
    initially, you are not able to send the token within your request, so resources
    that need authentication cannot be given back to you. Once your application has
    finished loading, you must make a second request to your server, including the
    token to access the secured content. This behavior has the consequence that it
    is not possible to build server-rendered applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client needs to implement the mechanics to attach the token to every request
    that's sent to the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to the nature of `localStorage`, there is no built-in expiry date on the
    client. If, at some point, the token reaches its expiration date, it still exists
    on the client inside `localStorage`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localStorage` is accessed through pure JavaScript and is therefore open to
    XSS attacks. If someone manages to integrate custom JavaScript in your code or
    site through unsanitized inputs, they can read the token from `localStorage`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are, however, many advantages of using `localStorage`:'
  prefs: []
  type: TYPE_NORMAL
- en: As `localStorage` is not sent automatically with every request, it is secure
    against any **Cross-Site-Request-Forgery** (**CSRF**) attacks attempting to run
    actions from external sites by making random requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localStorage` is easy to read in JavaScript since it is stored as a key-value
    pair.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports a bigger data size, which is great for storing an application state
    or data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main problem with storing such critical tokens inside web storage is that
    you cannot guarantee that there is no unwanted access. Unless you can be sure
    that every single input is sanitized and you are not relying on any third-party
    tools that get bundled into your JavaScript code, there is always a potential
    risk. Just one package you did not build yourself could share your users' web
    storage with its creator, without you or the user ever noticing. Furthermore,
    when you are using a public **Content Delivery Network** (**CDN**), the attack
    base and, consequently, the risk for your application is multiplied.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at cookies. These are great, despite their bad press due to
    the cookie compliance law that was initiated by the EU. Putting aside the more
    negative things that cookies can enable the companies to do, such as tracking
    users, there are still many good things about them. One significant difference
    compared to `localStorage` is that cookies are sent with every request, including
    the initial request for the site your application is hosted on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cookies come with the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Server-side rendering is no problem at all since cookies are sent with every
    request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No further logic needs to be implemented in the frontend to send the JWT.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cookies can be declared as `httpOnly`, which means JavaScript can't access them.
    It secures our token from XSS attacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cookies have a built-in expiration date, which can be set to invalidate the
    cookie in the client browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cookies can be configured to only be readable from specific domains or paths.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All browsers support cookies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These advantages sound good so far, but let''s consider the downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: Cookies are generally open to CSRF attacks, which are situations in which an
    external website makes requests to your API. They expect you to be authenticated
    and hope that they can execute actions on your behalf. We can't stop the cookie
    from being sent with each request to your domain. A common prevention tactic is
    to implement a CSRF token. This special token is also transmitted by your server
    and saved as a cookie. The external website cannot access the cookie with JavaScript
    since it is stored under a different domain. Your server does not read a token
    from the cookies that are transmitted with each request, only from an HTTP header.
    This behavior guarantees that the token was sent by the JavaScript that was hosted
    on your application because only this can have access to the token. Setting up
    the XSRF token for verification, however, introduces a lot of work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing and parsing cookies is not intuitive because they are stored as a
    big comma-separated string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can only store a small amount of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we can see that both approaches have their advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: The most common method is to use `localStorage`, as this is the easiest method.
    In this book, we will start by using `localStorage`, but later switch over to
    cookies when using server-side rendering to give you experience with both. You
    may not need server-side rendering at all. If this is the case, you can skip this
    part and the cookie implementation too.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to implement authentication with GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication with GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basics of authentication should now be clear to you. Now, our task is to
    implement a secure way for users to authenticate. If we have a look at our current
    database, we will see that we are missing the required fields. To do so, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s prepare and add a `password` field and an `email` field. As we learned
    in [*Chapter 3*](B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054), *Connecting
    to the Database*, we must create a migration to edit our user table. You can look
    up the commands in that chapter if you have forgotten them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding command generates the new file for us.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Replace the content of it and try writing the migration on your own, or you
    can check for the right commands in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All the fields are simple strings. Execute the migration, as stated in [*Chapter
    3*](B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054), *Connecting to the Database*.
    The email address needs to be unique. Our old seed file for the users needs to
    be updated now to represent the new fields that we have just added. Add the following
    fields to the first user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Do this for all the users and change the email address for each. Otherwise,
    it will not work. The password is in hashed format and represents the plain password
    123456789\. Since we have added new fields in a separate migration, we must add
    these to the model.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open and add the following new lines as fields to the `user.js` file in the
    `model` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now clear the database, run all the migrations, and execute the seeders again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing we must do is get the login process running. At the moment,
    we are just faking being logged in as the first user in our database.
  prefs: []
  type: TYPE_NORMAL
- en: Apollo login mutation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we are going to edit our GraphQL schema and implement the
    matching resolver function. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the schema and add a new mutation to the `RootMutation` object
    of our `schema.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding schema gives us a login mutation that accepts an email address
    and a password. Both are required to identify and authenticate the user. Then,
    we need to respond with something to the client. For now, the `Auth` type returns
    a token, which is a JWT in our case. You might want to add a different option
    according to your requirements:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The schema is now ready. Head over to the `resolvers` file and add the login
    function inside the mutation object. Before we do this, install and import two
    new packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import these packages at the top of the `resolvers` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `login` function receives `email` and `password` as parameters. It should
    look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code goes through the following steps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We query all the users where the email address matches.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If a user is found, we can move on. It is not possible to have multiple users
    with the same address, as the MySQL unique constraint forbids this.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we use the user's password and compare it with the submitted password,
    using the `bcrypt` package, as explained previously.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the password was correct, we generate a JWT token for the `jwt` variable
    using the `jwt.sign` function. It takes three arguments: the payload, which is
    the user ID and their email address; the key that we sign the JWT with; and the
    amount of time in which the JWT is going to expire.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we return an object containing our JWT.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Something that you might need to rethink is how much detail you give in an error
    message. For example, we might not want to distinguish between an incorrect password
    and a non-existent user. It allows possible attackers or data collectors to know
    which email address is in use.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `login` function is not working yet because we are missing `JWT_SECRET`,
    which is used to sign the JWT. In production, we use the environment variables
    to pass the JWT secret key into our backend code so that we can use this approach
    in development too.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For Linux or Mac, type the following command directly in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `export` function sets the `JWT_SECRET` environment variable for you. Replace
    the JWT provided with a random one. You can use any password generator by setting
    the character count to 128 and excluding any special characters. Setting the environment
    variable allows us to read the secret in our application. You must replace it
    when going to production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert the following code at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This code reads the environment variable from the global Node.js `process`
    object. Be sure to replace the JWT once you publish your application and be sure
    to always store the secret securely. After letting the server reload, we can send
    the first login request. We are going to learn how to do this in React later,
    but the following code shows an example of using Postman:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This request should return a token:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we have generated a signed JWT and returned it within the mutation's
    response. We can continue here and send the token with every request inside the
    HTTP authorization header. Then, we can get the authentication running for all
    the other GraphQL queries or mutations that we have implemented so far.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's continue and learn how to set up React to work with our authentication
    on the backend.
  prefs: []
  type: TYPE_NORMAL
- en: The React login form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to handle the different authentication states of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: The first scenario is that the user is not logged in and cannot see any posts
    or chats. In this case, we need to show a login form to allow the user to authenticate
    themselves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second scenario is that an email and password are sent through the login
    form. The response needs to be interpreted, and if the result is correct, we need
    to save the JWT inside `localStorage` of the browser for now.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When changing `localStorage`, we also need to rerender our React application
    to show the logged-in state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, the user should be able to log out again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must also be able to handle if the JWT expires and the user is unable to
    access any functionalities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The login form will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Login form'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.02_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – Login form
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with the login form, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a separate login mutation file inside the `apollo` folder. It is likely
    that we only need this component in one place in our code, but it is a good idea
    to save GraphQL requests in separate files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the login form component, which uses the login mutation to send the form
    data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `CurrentUser` query to retrieve the logged-in user object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conditionally render the login form if the user is not authenticated or the
    real application, such as the newsfeed, if the user is logged in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will begin by creating a new `login.js` file inside the `mutations` folder
    for the client components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As in the previous mutations, we parse the query string and export the `login`
    function from the `useMutation` Hook.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we must implement the actual login form that uses this mutation. To do
    this, we will create a `loginregister.js` file directly inside the `components`
    folder. As you may expect, we handle the login and registration of users in one
    component. Import the dependencies first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `LoginForm` component will store the form state, display an error message
    if something goes wrong, show a loading state, and send the login mutation, including
    the form data. Add the following code beneath the `import` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The overall React component is pretty straightforward. We just have one form
    and two inputs and we store their values in two state variables. The `onSubmit`
    function is called when the form is submitted, which will then trigger the login
    mutation. The `update` function of the mutation will be a bit different than the
    other mutations we have had so far. We don't write the return value in the Apollo
    cache; instead, we store the JWT inside `localStorage`. The syntax is pretty simple.
    You can directly use `localStorage.get` and `localStorage.set` to interact with
    the web storage.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After saving the JWT to `localStorage`, we call a `changeLoginState` function,
    which we will implement in the next step. The idea of this function is to have
    one global switch to change a user from logged in to logged out or vice versa.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We now need to export a component that will be used by our application. The
    easiest thing to do is set up a wrapper component that handles the login and sign-up
    cases for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert the following code for the wrapper component:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This component just renders the login form and passes the `changeLoginState`
    function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All the basics for authenticating the user are now ready, but they have not
    been imported yet or displayed anywhere. Open the `App.js` file. There, we will
    directly display the feed, chats, and the top bar. The user should not be allowed
    to see everything if they are not logged in. Continue reading to change this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import the new form that we have just created and import the `useEffect` Hook
    from React:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we must store whether the user is logged in or not and, also on the first
    render of our application, check the login state based on `localStorage`. Add
    the following code to the `App` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When loading our page, we have the `loggedIn` state variable to store the current
    logged-in status inside. The default value is either `true` if the token exists
    or `false` if not.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, in the `return` statement, we can use conditional rendering to show the
    login form when the `loggedIn` state variable is set to `false`, which means that
    there is no JWT inside our `localStorage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we pass the `setLoggedIn` function to the login form, which
    is then able to trigger a logged-in state so that React can rerender and show
    the logged-in area. We call this property `changeLoginState` and use it inside
    the login form inside the `update` method in the login mutation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the CSS from the official GitHub repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once we've logged in, our application will present us with the common posts
    feed, as it did previously. The authentication flow is now working, but there
    is one more open task. In the next section, we will allow new users to register
    at Graphbook.
  prefs: []
  type: TYPE_NORMAL
- en: Apollo signup mutation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You should now be familiar with creating new mutations. To do so, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, edit the schema to accept the new mutation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We only need the `username`, `email`, and `password` properties, which were
    mentioned in the preceding code, to accept new users. If your application requires
    a gender or something else, you can add it here. When we're trying to sign up,
    we need to ensure that neither the email address nor the username has already
    been taken.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Copy over the code to implement the resolver for signing up new users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s go through this code step by step:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we mentioned previously, first, we must check if a user with the same email
    or username exists. If this is the case, we throw an error. We use the `Op.or`
    Sequelize operator to implement the MySQL OR condition.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user does not exist, we can hash the password using `bcrypt`. You cannot
    save the plain password for security reasons. When running the `bcrypt.hash` function,
    a random salt is used to make sure nobody ever gets access to the original password.
    This command takes quite some computing time, so the `bcrypt.hash` function is
    asynchronous, and the promise must be resolved before we continue.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The encrypted password, including the other data the user has sent, is then
    inserted into our database as a new user.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: After creating the user, we generate a JWT and return it to the client. The
    JWT allows us to log the user in directly once they've signed up. If you do not
    want this behavior, you can just return a message to indicate that the user has
    signed up successfully.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you can test the `signup` mutation again with Postman while starting the
    backend using `npm run server`. With that, we have finished the backend implementation.
    So, let's start working on the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: React signup form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The registration form is nothing special. We will follow the same steps that
    we took with the login form:'
  prefs: []
  type: TYPE_NORMAL
- en: Clone the `LoginMutation` component, replace the request at the top with the
    `signup` mutation, and hand over the `signup` method to the underlying children.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top, import all the dependencies and then parse the new query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the `username` field is new here, which we send with every `signup`
    request. The logic itself has not changed, so we still extract the JWT from the
    `signup` field when logging the user in after a successful request.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It''s good to see that the `login` and `signup` mutations are quite similar.
    The biggest change is that we conditionally render the login form or the registration
    form. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the new mutation into the `loginregister.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, replace the complete `LoginRegisterForm` component with the following
    new one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should notice that we are storing a `showLogin` variable in the component
    state. This decides if the login or register component is shown, which handles
    the actual business logic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, add a separate component for the register form before the export statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, I added the `username` field, which must be given to
    the mutation. Everything is now set to invite new users to join our social network
    and log in as often as they want.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the next section, we will learn how to use authentication with our existing
    GraphQL requests.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating GraphQL requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The problem is that we are not using authentication everywhere at the moment.
    We are verifying that the user is who they say they are, but we are not rechecking
    this when the requests for chats or messages come in. To accomplish this, we must
    send the JWT token, which we generated specifically for this case, with every
    Apollo request. On the backend, we must specify which request requires authentication,
    read the JWT from the HTTP authorization header, and verify it. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `index.js` file from the `apollo` folder for the client-side code.
    Our `ApolloClient` is currently configured as explained in [*Chapter 4*](B17337_04_Final_ASB_ePub.xhtml#_idTextAnchor085),
    *Hooking Apollo into React*. Before we send any requests, we must read the JWT
    from `localStorage` and add it as an HTTP authorization header. Inside the `link`
    property, we have specified the links for our `ApolloClient` processes. Before
    we configure the HTTP link, we must insert a third preprocessing Hook, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have called the new link `AuthLink` because it allows us to authenticate
    the client on the server. You can copy the `AuthLink` approach for other situations
    where you need to customize the header of your Apollo requests. Here, we just
    read the JWT from `localStorage` and, if it is found, we construct the header
    using the spread operator and add our token to the `Authorization` field as a
    Bearer Token. This is everything that needs to be done on the client side.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To clarify things, take a look at the following `link` property to learn how
    to use this new preprocessor. No initialization is required; it is merely a function
    that is called every time a request is made. Copy the `link` configuration to
    our Apollo Client setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s install one dependency that we require:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For our backend, we need a pretty complex solution. Create a new file called
    `auth.js` inside the GraphQL `services` folder. We want to be able to mark specific
    GraphQL requests in our schema with a so-called directive. If we add this directive
    to our GraphQL schema, we can execute a function whenever the marked GraphQL action
    is requested. In this function, we can verify whether the user is logged in or
    not. Have a look at the following function and save it in the `auth.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Starting from the top, we import three things from the `@graphql/utils` package:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `mapSchema` function takes two arguments. The first is the actual GraphQL
    schema and then an object of functions that can transform the schema.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `getDirective` function will read the schema and try to get the specified
    `directiveName`. Based on that, we can do anything that we want.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MapperKind` is just a set of types that we can use. We are using that to only
    run functions for specific types.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: This function or directive will read the user from the context and pass it to
    our resolvers where the directive is specified within our GraphQL schema.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We must load the new `authDirective` function in the `graphql` `index.js` file,
    which sets up the whole Apollo Server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we create our executable schema, we must extract the new schema transformer
    from the `authDirective` function. After creating the executable schema, we must
    pass it to the transformer so that `authDirective` starts to work. Replace the
    current schema creation with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To verify what we have just done, go to the GraphQL schema and edit `postsFeed`
    `RootQuery` by adding `@auth` to the end of the line, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because we are using a new directive, we also must define it in our GraphQL
    schema so that our server knows about it. Copy the following code directly to
    the top of the schema:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This tiny snippet tells Apollo Server that the `@auth` directive can be used
    with queries, fields, and field definitions so that we can use it everywhere.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you reload the page and manually set the `loggedIn` state variable to true
    via React Developer Tools, you will see the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – GraphQL login error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.03_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – GraphQL login error
  prefs: []
  type: TYPE_NORMAL
- en: Since we implemented the error component earlier, we are now correctly receiving
    an unauthenticated error for the `postsFeed` query if the user is not logged in.
    How can we use the JWT to identify the user and add it to the request context?
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Schema directives are a complex topic as there are many important things to
    bear in mind regarding Apollo and GraphQL. I recommend that you read up on directives
    in detail in the official Apollo documentation: [https://www.graphql-tools.com/docs/introduction](https://www.graphql-tools.com/docs/introduction).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 2*](B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032), *Setting
    Up GraphQL with Express.js*, we set up Apollo Server by providing the executable
    schema and the context, which has been the request object until now. We must check
    if the JWT is inside the request. If this is the case, we need to verify it and
    query the user to see if the token is valid. Let''s start by verifying the authorization
    header. Before doing so, import the new dependencies into the GraphQL `index.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `context` field of the `ApolloServer` initialization must look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have extended the `context` property of the `ApolloServer` class to
    a full-featured function. We read the `auth` token from the headers of the requests.
    If the `auth` token exists, we need to strip out the bearer string, because it
    is not part of the original token that was created by our backend. The Bearer
    Token is the best method of JWT authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are other authentication methods available, such as basic authentication,
    but the bearer method is the best to follow. You can find a detailed explanation
    under RFC6750 by the IETF at [https://tools.ietf.org/html/rfc6750](https://tools.ietf.org/html/rfc6750).
  prefs: []
  type: TYPE_NORMAL
- en: 'Afterward, we must use the `JWT.verify` function to check if the token matches
    the signature that''s been generated by the secret from the environment variables.
    The next step is to retrieve the user once they''ve been verified successfully.
    Replace the content of the `verify` callback with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If the `err` object in the previous code has been filled, we can only return
    the ordinary request object, which triggers an error when it reaches the `auth`
    directive, since there is no user attached. If there are no errors, we can use
    the `utils` object we are already passing to the Apollo Server setup to access
    the database. If you need a reminder, take a look at [*Chapter 2*](B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032),
    *Setting Up GraphQL with Express.js*. After querying the user, we must add them
    to the request object and return the merged user and request object as the context.
    This leads to a successful response from our authorizing directive.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's test this behavior. Start the frontend with `npm run client` and
    the backend using `npm run server`. Don't forget that all Postman requests now
    have to include a valid JWT if the `auth` directive is used in the GraphQL query.
    You can run the login mutation and copy it over to the authorization header to
    run any query. We are now able to mark any query or mutation with the authorization
    flag and, as a result, require the user to be logged in.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the user context from resolver functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the moment, all the API functions of our GraphQL server allow us to simulate
    the user by selecting the first that's available from the database. As we have
    just introduced a full-fledged authentication, we can now access the user from
    the request context. This section quickly explains how to do this for the chat
    and message entities. We will also implement a new query called `currentUser`,
    where we retrieve the logged-in user in our client.
  prefs: []
  type: TYPE_NORMAL
- en: Chats and messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First of all, you must add the `@auth` directive to the chats inside GraphQL's
    `RootQuery` to ensure that users need to be logged in to access any chats or messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the resolver function for the chats. Currently, we are using
    the `findAll` method to get all users, take the first one, and query for all the
    user''s chats. Replace this code with the following new resolver function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we don''t retrieve the user; instead, we directly insert the user ID
    from the context, as shown in the preceding code. That''s all we have to do: all
    the chats and messages that belong to the logged-in user are queried directly
    from the chats table.'
  prefs: []
  type: TYPE_NORMAL
- en: We would need to copy this for the mutations for chats and messages and all
    the other queries and mutations that we have at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: CurrentUser GraphQL query
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JWTs allow us to query for the currently logged-in user. Then, we can display
    the correct authenticated user in the top bar. To request the logged-in user,
    we require a new query called `currentUser` on our backend. In the schema, you
    simply have to add the following line to the `RootQuery` queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Like the `postsFeed` and `chats` queries, we also need the `@auth` directive
    to extract the user from the request context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, in the resolver functions, you only need to insert the following
    three lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We return the user from the context right away, because it is already a user
    model instance with all the appropriate data being returned by Sequelize. On the
    client side, we create this query in a separate component and file. Bear in mind
    that you don''t need to pass the result to all the children because this is done
    automatically by `ApolloConsumer` later. You can follow the previous query component
    examples to see this. Just create a file called `currentUserQuery.js` in the `queries`
    folder with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can import the new query inside the `App.js` file and add the following
    line to the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we executed the `useCurrentUserQuery` Hook to ensure that the query has
    been executed at a global level for all the components. Also, we show a loading
    indicator until the request has finished to ensure that the user is loaded before
    we do anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Every time the `loggedIn` state variable is `true`, we render the components.
    To get access to the response, we must use `ApolloConsumer` in the bar component,
    which we implemented in the previous chapter. We run the `currentUser` query in
    the `App.js` file to ensure that all the child components can rely on the Apollo
    cache to access the user before being rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of having a hardcoded fake user inside `ApolloConsumer`, we can use
    the the `client.readQuery` function to extract the data stored in the `ApolloClient`
    cache to give it to the underlying child component. Replace the current consumer
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, we passed the extracted `currentUser` result from the `client.readQuery`
    method to all the wrapped children of the current component.
  prefs: []
  type: TYPE_NORMAL
- en: The chats that are displayed from now on, as well as the user in the top bar,
    are no longer faked; instead, they are filled with the data related to the logged-in
    user.
  prefs: []
  type: TYPE_NORMAL
- en: The mutations to create new posts or messages still use a static user ID. We
    can switch over to the real logged-in user in the same way as we did previously
    in this section by using the user ID from the `context.user` object. You should
    now be able to do this on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Logging out using React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To complete the circle, we still have to implement the functionality to log
    out. There are two cases when the user can be logged out:'
  prefs: []
  type: TYPE_NORMAL
- en: The user wants to log out and hits the logout button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JWT has expired after 1 day as specified; the user is no longer authenticated,
    and we have to set the state to logged out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow these steps to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by adding a new logout button to the top bar of our application''s
    frontend. To do this, create a new `logout.js` component inside the `bar` folder.
    It should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the logout button triggers the component's logout method when
    it is clicked. Inside the `logout` method, we remove the JWT from `localStorage`
    and execute the `changeLoginState` function that we receive from the parent component.
    Be aware that we do not send a request to our server to log out; instead, we remove
    the token from the client. This is because there is no black or white list that
    we are using to disallow or allow a certain JWT to authenticate on our server.
    The easiest way to log out a user is to remove the token on the client side so
    that neither the server nor the client has it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also reset the client cache. When a user logs out, we must remove all data.
    Otherwise, other users on the same browser will be able to extract all the data,
    which we must prevent. To gain access to the underlying Apollo Client, we must
    import the `withApollo` `Logout` component wrapped inside it. When logging out,
    we must execute the `client.stop` and `client.resetStore` functions so that all
    the data is deleted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To use our new `Logout` component, open the `index.js` file from the `bar`
    folder and import it at the top. We can render it within the `div` top bar, below
    the other inner `div` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we pass the `changeLoginState` function to the `Logout` component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Extract the `changeLoginState` function from the `Bar` component props, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `App.js` file, you must implement one more function to handle the current
    user query correctly. If we are not logged in and then log in, we need to fetch
    the current user. And if we log out, we need to either set or be able to easily
    fetch the current user query again. Add the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Hand this function over not only to `LoginRegisterForm` but also to the `Bar`
    component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you copy the complete CSS from the official GitHub repository, you should
    see a new button at the top-right corner of the screen when you are logged in.
    Hitting it logs you out and requires you to sign in again since the JWT has been
    deleted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The other situation in which we implement logout functionality is when the
    JWT we are using expires. In this case, we log the user out automatically and
    require them to log in again. Go to the `App` component and add the following
    lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are using the `client.onClearStore` event, which is caught through
    the `client.onClearStore` function once the client store is cleared.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To get the preceding code to work, we must access the Apollo Client in our
    `App` component. The easiest way to do this is to use the `withApollo` HoC. Just
    import it from the `@apollo/client` package in the `App.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, export the `App` component – not directly, but through the HoC – and
    extract the `client` property. The following code must go directly beneath the
    `App` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, the component can access the client through its properties. The `clearStore`
    event is thrown whenever the client restore is reset, as its name suggests. You
    are going to see why we need this shortly. When listening to events in React,
    we have to stop listening when the component is unmounted. We handle this inside
    the `useEffect` Hook in the preceding code. Now, we must reset the client store
    to initiate the logout state. When the event is caught, we execute the `changeLoginState`
    function automatically. Consequently, we could remove the section that we passed
    `changeLoginState` to the logout button initially because it is no longer needed,
    but this is not what we want to do here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Extract the client from the `App` component props, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go to the `index.js` file in the `apollo` folder. There, we already caught
    and looped over all the errors that were returned from our GraphQL API. What we
    must do now is loop over all the errors but check each of them for an `UNAUTHENTICATED`
    error. Then, we must execute the `client.clearStore` function. Insert the following
    code into the Apollo Client setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we access the `extensions` property of the error. The `extensions.code`
    field holds the specific error type that's returned. If we are not logged in,
    we remove the JWT and then reset the store. By doing this, we trigger the event
    in our `App` component, which sends the user back to the login form.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A further extension would be to offer a refresh token API function. This feature
    could be run every time we successfully use the API. The problem with this is
    that the user would stay logged in forever, so long as they are using the application.
    Usually, this is not a problem, but if someone else is accessing the same computer,
    they will be authenticated as the original user. There are different ways to implement
    these kinds of functionalities to make the user experience more comfortable, but
    I am not a big fan of these for security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, one of the main issues we had with our application is that we didn't
    have any authentication. We can now tell who is logged in every time a user accesses
    our application. This allows us to secure the GraphQL API and insert new posts
    or messages into the name of the correct user. In this chapter, we discussed the
    fundamental aspects of JWTs, `localStorage`, and cookies. We also looked at how
    hashed password verification and signed tokens work. We then covered how to implement
    JWTs inside React and how to trigger the correct events to log in and log out.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to implement image uploads with a reusable
    component that allows the user to upload new avatar images.
  prefs: []
  type: TYPE_NORMAL
