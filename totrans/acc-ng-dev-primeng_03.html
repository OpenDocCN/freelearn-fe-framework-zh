<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer033">
			<h1 id="_idParaDest-88"><em class="italic"><a id="_idTextAnchor090"/>Chapter 7</em>: Component Harnesses</h1>
			<p>Testing is a fundamental part of software development. It helps ensure that the code that's delivered covers the feature requirements and is free of implementation issues. Sometimes, when testing UI code, it is hard to avoid performing tightly coupled tests on the DOM structure. However, Angular Ivy brings a new solution for this. Component testing harnesses make it possible to develop a testing API for our components using the industry-standard Page Object pattern, but on a more granular level.</p>
			<p>To top this off, component harnesses for the Angular Material directives and components are already included in Angular Ivy. In this chapter, we will learn how to use the component testing harnesses in Angular Components and how to implement custom component harnesses to make it easier to test our components.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Using Angular Material's component harnesses</li>
				<li>Creating a component harness</li>
			</ul>
			<p>By the end of this chapter, you should have gained an overview of how and where to use component harnesses.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor091"/>Using Angular Material's component harnesses</h1>
			<p>You saw<a id="_idIndexMarker291"/> an example of how to use the <strong class="bold">Material Button harness</strong> in <a href="B16295_04_ePub_RK.xhtml#_idTextAnchor055"><em class="italic">Chapter 4</em></a>, <em class="italic">Exploring Angular Components Features.</em> Now, let's explore how to test the <strong class="bold">theme</strong> component using the material<a id="_idIndexMarker292"/> test harnesses with a <em class="italic">Test as a user</em> strategy.  </p>
			<p>As you might remember, the theme component<a id="_idIndexMarker293"/> lets us select the color and size settings<a id="_idIndexMarker294"/> for Angular Academy. The user can do this by selecting a color by going to the <strong class="bold">Color Input</strong> field to obtain the wanted color for the given <strong class="bold">Header background</strong> setting. To simulate this action while testing as a user, we will use a <strong class="source-inline">MatInputHarness</strong> with the <strong class="source-inline">#headerBackground</strong> selector:</p>
			<p class="source-code">  it('should be able to read default header background </p>
			<p class="source-code">   color theme setting', async () =&gt; {</p>
			<p class="source-code">   const headerBackground: MatInputHarness = await </p>
			<p class="source-code">    loader.getHarness(</p>
			<p class="source-code">      MatInputHarness.with({ selector: '#headerBackground' </p>
			<p class="source-code">      })</p>
			<p class="source-code">    );</p>
			<p class="source-code">    expect(await headerBackground.getValue()</p>
			<p class="source-code">     ).toBe('#00aa00');</p>
			<p class="source-code">  });</p>
			<p>Here, we expect the default setting to be <strong class="source-inline">'#00aa00'</strong>. We retrieve the value from the test harness using the <strong class="source-inline">getValue</strong> method.</p>
			<p>In this example, we could also simply find the value<a id="_idIndexMarker295"/> in the input field with the <strong class="source-inline">'#headerBackground'</strong> ID and check its value. So, let's build a more complicated test where<a id="_idIndexMarker296"/> we should be able to change the header background color theme setting:</p>
			<p class="source-code">  it('should be able to change the header background color </p>
			<p class="source-code">   theme setting', async () =&gt; {</p>
			<p class="source-code">    const headerBackground: MatInputHarness = await </p>
			<p class="source-code">     loader.getHarness(</p>
			<p class="source-code">      MatInputHarness.with({ selector: '#headerBackground' </p>
			<p class="source-code">       })</p>
			<p class="source-code">    );</p>
			<p class="source-code">    headerBackground.setValue('#ffbbcc').then(() =&gt; {</p>
			<p class="source-code">      expect(themeService.getSetting(</p>
			<p class="source-code">       'headerBackground')).toBe('#ffbbcc');</p>
			<p class="source-code">    });</p>
			<p class="source-code">  });</p>
			<p>As we did earlier, we will use the component harness to interact with the <strong class="bold">Material Input</strong> button for the header background input button. Now, we will set the value to <strong class="source-inline">'#ffbbccc'</strong> and check that this setting has been picked up by the theme setting.   </p>
			<p>Did you notice that we did not write <strong class="source-inline">fixture.detectChanges()</strong>in this test? We can avoid this because<a id="_idIndexMarker297"/> we are using the component harness that will handle the DOM operations<a id="_idIndexMarker298"/> here. Clicking this input field and interacting with the color selector as the user would have done is somewhat complex using DOM operations, but here, we are using the operations on the component testing harness instead. By doing this, we can avoid brittle changes in the test related to change detection.  </p>
			<p>Similarly, we can use <strong class="source-inline">MatSliderHarness</strong> to <strong class="source-inline">MatInputHarness</strong> to avoid performing DOM operations when testing the <strong class="bold">Video Size</strong> slider setting for the theme component:</p>
			<p class="source-code">  it('should be able to check default text and video slider </p>
			<p class="source-code">   settings', async () =&gt; {</p>
			<p class="source-code">    const videoSizeSetting = </p>
			<p class="source-code">     Number(themeService.getSetting('videoSize'));</p>
			<p class="source-code">    expect(videoSizeSetting).toBe(7);</p>
			<p class="source-code">    const videoSizeSlider: MatSliderHarness = await </p>
			<p class="source-code">     loader.getHarness(</p>
			<p class="source-code">      MatSliderHarness.with({ selector: '#videoSizeSlider' </p>
			<p class="source-code">       })</p>
			<p class="source-code">    );</p>
			<p class="source-code">    expect(await videoSizeSlider.getId()</p>
			<p class="source-code">     ).toBe('videoSizeSlider');</p>
			<p class="source-code">    expect(await videoSizeSlider.getValue()</p>
			<p class="source-code">     ).toBe(Number(videoSizeSetting));</p>
			<p>Now, we can retrieve the default <strong class="source-inline">videoSize</strong> setting from the theme service and the screen component to check that it is <strong class="source-inline">7</strong> by using API operations from the test harness. Using the <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> construct in combination with the test harness leads to fairly compact code here.   </p>
			<p>By now, you should know how to use the existing<a id="_idIndexMarker299"/> material component harnesses. Next, let's dive<a id="_idIndexMarker300"/> into how to build component harnesses for the Angular Academy app.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor092"/>Creating a component harness</h1>
			<p>Let's imagine that we want<a id="_idIndexMarker301"/> to expose our <strong class="source-inline">Video</strong> component so that it can be integrated with other applications. Here, it would make sense to write a test harness for it – but how should we structure it? Our example of displaying YouTube videos using a YouTube Player component inside a <strong class="source-inline">Video</strong> component, which will be inside a Course component, turns out to be difficult to test using a "test as a user" approach in the DOM directly. So, let's take a layered approach here.</p>
			<p>When constructing a component, we should strive to only have a single reference point – the DOM – for each page. Taking a layered approach, we start the test from the Course component, which knows about the Video component, which, in turn, knows about the YouTube Player component. By doing this, we can test from the <strong class="source-inline">Course</strong> component by exposing the <strong class="source-inline">Video</strong> harness that encapsulates the <strong class="source-inline">workspace-video</strong> selector as a Page Object for each of the instances of the <strong class="source-inline">Video</strong> component, like this:</p>
			<p class="source-code">export class VideoHarness extends ComponentHarness {</p>
			<p class="source-code">  static hostSelector = 'workspace-video';</p>
			<p class="source-code">  protected getTextElement = this.locatorFor('.text');</p>
			<p class="source-code">  async getText(): Promise&lt;string|null&gt; {</p>
			<p class="source-code">    const textElement = await this.getTextElement();</p>
			<p class="source-code">    return textElement.text()</p>
			<p class="source-code">  }</p>
			<p class="source-code">  textEquals(video: IVideo, text: string): boolean {</p>
			<p class="source-code">    return</p>
			<p class="source-code">      text?.toLowerCase().trim().includes(</p>
			<p class="source-code">         video.title.trim().toLowerCase()</p>
			<p class="source-code">      );</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Now, we can display the text for each video<a id="_idIndexMarker302"/> by using the <strong class="source-inline">getText()</strong> call from the <strong class="source-inline">course.component.spec.ts</strong> file. Then, we can use the supplied <strong class="source-inline">textEquals</strong> call to test for equality:</p>
			<p class="source-code"> it('should render the video title in text when displaying it', async () =&gt; {</p>
			<p class="source-code">  const renderedVideos =</p>
			<p class="source-code">    await loader.getAllHarnesses(VideoHarness);</p>
			<p class="source-code">  courseService.getCourse('1').subscribe((course) =&gt; {</p>
			<p class="source-code">      renderedVideos.forEach(async (video: VideoHarness) =&gt; {</p>
			<p class="source-code">        const text = await video.getText()|| "";</p>
			<p class="source-code">        expect(course.videos.find((v) =&gt; </p>
			<p class="source-code">         video.textEquals(v, text))).toBeTruthy();</p>
			<p class="source-code">      });</p>
			<p class="source-code">    });</p>
			<p class="source-code"> });</p>
			<p>Here, we looped through all the rendered videos for course <strong class="source-inline">'1'</strong> in the course component and checked that each of the texts accompanying the rendered videos contain the course title we can retrieve via the course service. Note that the <strong class="source-inline">textEquals</strong> function is supplied from the test harness here, which means we can change that function in a later version of the component library.</p>
			<p>We will let the <strong class="source-inline">Video</strong> harness hide the DOM<a id="_idIndexMarker303"/> operations related to the videos using a Page Object approach. The <strong class="source-inline">Video</strong> harness will then know about the implementation that's specific to the <strong class="source-inline">YouTubePlayer</strong> harness, which encapsulates the <strong class="source-inline">youtube-player</strong> selector, like this:</p>
			<p class="source-code">class YoutubePlayerHarness extends ComponentHarness {</p>
			<p class="source-code">  static hostSelector = 'youtube-player';</p>
			<p class="source-code">  async getVideoId(): Promise&lt;string|null&gt; {</p>
			<p class="source-code">    const host = await this.host();</p>
			<p class="source-code">    return await host.getAttribute('ng-reflect-video-id');</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>When rendering videos using the Angular YouTube Player, we expect the video IDs to be available. The trick here is that we want to hide the implementation details for the Angular YouTube Player from the test for the Course component. So, let's introduce the <strong class="source-inline">getVideoId</strong> function to the <strong class="source-inline">Video</strong> harness so that it is available when we test from the Course component:</p>
			<p class="source-code">  it('should have the videoId available when rendering the </p>
			<p class="source-code">   video', async() =&gt; {</p>
			<p class="source-code">    const renderedVideos = await </p>
			<p class="source-code">     loader.getAllHarnesses(VideoHarness);</p>
			<p class="source-code">    renderedVideos.forEach( async(video: VideoHarness) =&gt; {</p>
			<p class="source-code">      const videoId = await video.getVideoId();</p>
			<p class="source-code">      expect(videoId).toBeTruthy();</p>
			<p class="source-code">    })</p>
			<p class="source-code">  })</p>
			<p>The full <strong class="source-inline">Video</strong> harness<a id="_idIndexMarker304"/> will look like this:</p>
			<p class="source-code">export class VideoHarness extends ComponentHarness {</p>
			<p class="source-code">  static hostSelector = 'workspace-video';</p>
			<p class="source-code">  protected getTextElement = this.locatorFor('.text');</p>
			<p class="source-code">  protected getVideoElement = </p>
			<p class="source-code">   this.locatorFor(YoutubePlayerHarness);</p>
			<p class="source-code">  async getText(): Promise&lt;string | null&gt; {</p>
			<p class="source-code">    const textElement = await this.getTextElement();</p>
			<p class="source-code">    return textElement.text();</p>
			<p class="source-code">  }</p>
			<p class="source-code">  async getVideoId(): Promise&lt;string | null&gt; {</p>
			<p class="source-code">    const videoElement = await this.getVideoElement();</p>
			<p class="source-code">    return videoElement.getVideoId();</p>
			<p class="source-code">  }</p>
			<p class="source-code">  textEquals(video: IVideo, text: string): boolean {</p>
			<p class="source-code">     return  text?.toLowerCase().trim().includes(</p>
			<p class="source-code">      video.title.trim().toLowerCase());</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>At this point, we can expose the <strong class="source-inline">Video</strong> test harness, along with the <strong class="source-inline">Video</strong> component, to anyone that wants<a id="_idIndexMarker305"/> to use our <strong class="source-inline">Video</strong> component in their application.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor093"/>Summary</h1>
			<p>In this chapter, we looked at some examples of how to use some of the existing test Material UI test harnesses in the context of the Angular Academy application. Additionally, we introduced how to implement a component harness for the <strong class="source-inline">Video</strong> component that is used in the Angular Academy application.</p>
			<p>In the next chapter, we will wrap up our Angular Academy application by showing you how to use the new provider scopes.</p>
		</div>
	</div></body></html>