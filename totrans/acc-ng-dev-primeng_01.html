<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer030">
			<h1 id="_idParaDest-73"><em class="italic"><a id="_idTextAnchor075"/>Chapter 5</em>: Using CSS Custom Properties</h1>
			<p>We will now dive into the practical details of how to implement the features you encountered in <em class="italic">Part 1 A Quick and Functional Guide to Angular Ivy</em> in the Angular Academy application, which will allow you to browse and select a curriculum of available Angular video courses on YouTube.</p>
			<p>We'll start by describing the Angular Academy application while covering the following topics:</p>
			<ul>
				<li>Building a theme picker using custom CSS properties</li>
				<li>Implementing the theme service</li>
				<li>Controlling CSS Grid templates using custom CSS properties</li>
			</ul>
			<p>By the end of the chapter, you will have gained practical experience in using custom CSS properties in a real-world application.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor076"/>Technical requirements</h1>
			<p>Combining and using all the new features in the Angular Academy application will involve a series of practical choices that are usually hidden in the descriptions in <em class="italic">Part 1</em>, <em class="italic">A Quick and Functional Guide to Angular Ivy</em> which means we will need to provide an overview of the application as a whole.  </p>
			<p>So, before we dive into an in-depth description of all the details, let's check out the code first and have it available for inspection while reading the in-depth description in the upcoming chapters. </p>
			<p>Open the terminal and issue the following command: </p>
			<p class="source-code"> git clone https://github.com/PacktPublishing/Accelerating-Angular-Development-with-Ivy</p>
			<p>The demo project source code will be placed in <strong class="source-inline">projects</strong>/<strong class="source-inline">demo</strong> and can be started on your development machine, like this:</p>
			<p class="source-code">cd Accelerating-Angular-Development-with-Ivy</p>
			<p class="source-code">npm install</p>
			<p class="source-code">ng serve demo</p>
			<p>If you go to <a href="http://localhost:4200">http://localhost:4200</a> on your browser, you should now be able to see the Angular Academy app:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="Images/Figure_5.1_B16295.jpg" alt="Figure 5.1 – In the Angular Academy application, you can see a list of YouTube video courses&#13;&#10;" width="987" height="912"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – In the Angular Academy application, you can see a list of YouTube video courses</p>
			<p>When the Angular Academy application is started, you will see a list of YouTube courses on the default page (as illustrated in <em class="italic">Figure 5.1</em>). Feel free to browse to get a feel of what we will be covering in the upcoming chapters. As an example, try clicking the <strong class="bold">Edit Theme</strong> menu entry to open the theme picker. We will be looking at this in the next section.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor077"/>Building a theme picker using custom CSS properties</h1>
			<p>Having a theme available<a id="_idIndexMarker241"/> for your application is a common and important<a id="_idIndexMarker242"/> use case that is already covered by popular Angular libraries. You may be aware that Angular Material already supports several available themes (for example, the popular <strong class="bold">deeppurple-amber</strong> and <strong class="bold">indigo-pink</strong>). The common approach of using preprocessor variables when using SCSS has been available for some time. But now, you can support dynamic theming using custom CSS properties without having to generate the CSS files using a preprocessor. This adds new options for interactive theming that we will cover in this section.</p>
			<p>Given that further CSS rules can be built using CSS Custom Properties, we can now change several styling rules in one go, directly from one of the components in the application. Here, one or more CSS classes can be calculated on the fly via the <strong class="source-inline">--headerbackground</strong> custom property or simply by attaching the value of the property as the CSS class, like this:</p>
			<p class="source-code">.mycomponent {</p>
			<p class="source-code">  background: var(--headerbackground, white);</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">headerbackground</strong> color can be picked by the user using a theme picker construct, similar to this:</p>
			<p class="source-code">&lt;input name="headerBackground" type="color" /&gt;</p>
			<p>For interactive use, the value of the <strong class="source-inline">headerbackground</strong> custom property could be a variable stored in <strong class="source-inline">localStorage</strong> that's available during use. <strong class="source-inline">headergroundcolor</strong> could then affect the styling of the elements inside the specific tile component.</p>
			<p>In the Angular Academy application, we will wrap<a id="_idIndexMarker243"/> it with an Angular Material form<a id="_idIndexMarker244"/> field in the theme component template, like this:</p>
			<p class="source-code">&lt;mat-form-field appearance="fill"&gt;</p>
			<p class="source-code">   &lt;mat-label&gt; Header background &lt;/mat-label&gt;</p>
			<p class="source-code">   &lt;input</p>
			<p class="source-code">    matInput</p>
			<p class="source-code">    name="headerBackground"</p>
			<p class="source-code">    (blur)="update($event)"</p>
			<p class="source-code">    type="color"</p>
			<p class="source-code">    [value]="headerBackground"</p>
			<p class="source-code">    /&gt;</p>
			<p class="source-code"> &lt;/mat-form-field&gt;</p>
			<p>Using the Material form input field in the theme picker component will look like this: </p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="Images/Figure_5.2_B16295.jpg" alt="Figure 5.2 – You can use the theme picker component to select the header's background color&#13;&#10;" width="605" height="655"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – You can use the theme picker component to select the header's background color</p>
			<p>We can apply the chosen color <em class="italic">directly</em> from the custom SCSS properties to the relevant component SCSS files<a id="_idIndexMarker245"/> in the application or directly at the app scope using<a id="_idIndexMarker246"/> the style syntax precedence works implemented in Ivy. </p>
			<p>For practical purposes, we will use a <strong class="source-inline">@HostBinding</strong> to bind each theme setting to a theme variable for the application scope, like this:</p>
			<p class="source-code">export class AppComponent {</p>
			<p class="source-code">  @HostBinding('style.--background')</p>
			<p class="source-code">  background: string;</p>
			<p class="source-code"> </p>
			<p class="source-code">  @HostBinding('style.--headerbackground')</p>
			<p class="source-code">  headerBackground: string;</p>
			<p class="source-code"> </p>
			<p class="source-code">  @HostBinding('style.--tilebackground')</p>
			<p class="source-code">  tileBackground: string; </p>
			<p class="source-code">  constructor(themeService: ThemeService) {</p>
			<p class="source-code">    this.background = themeService.getSetting(</p>
			<p class="source-code">     'background');</p>
			<p class="source-code">    this.headerBackground = themeService.getSetting(</p>
			<p class="source-code">     'headerBackground');</p>
			<p class="source-code">    this.tileBackground = themeService.getSetting(</p>
			<p class="source-code">     'tileBackground');</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The values for the CSS properties can be retrieved in the theme component via a getter, which retrieves the value via the theme service, like this:</p>
			<p class="source-code">  get headerBackground(): string {</p>
			<p class="source-code">    return this.themeService.getSetting(</p>
			<p class="source-code">     'headerBackground');</p>
			<p class="source-code">  }</p>
			<p>The <strong class="source-inline">update($event)</strong> callback on the theme component could refer to the theme service, which would update the chosen<a id="_idIndexMarker247"/> value behind the scenes. Additionally, the theme<a id="_idIndexMarker248"/> component would allow access to the chosen values for the custom CSS properties by binding them to the application's scope, like this:</p>
			<p class="source-code">  update(event: any): void {</p>
			<p class="source-code">    this.themeService.setSetting(event.target.name, </p>
			<p class="source-code">     event.target.value);</p>
			<p class="source-code">  }</p>
			<p>In the app component, we are referring to the same theme service for handling data updates related to the theme component. By separating handling data updates into a service, we can abstract the details of how to store and retrieve the theme settings for later.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor078"/>Implementing the theme service</h1>
			<p>The theme service<a id="_idIndexMarker249"/> has the responsibility of retrieving the dynamic theme settings. </p>
			<p>Let's start with a simple implementation by using <strong class="source-inline">localStorage</strong>. In this implementation, we will also provide default settings if the value is not available: </p>
			<p class="source-code">import { Injectable } from '@angular/core';</p>
			<p class="source-code">@Injectable({</p>
			<p class="source-code">  providedIn: 'root',</p>
			<p class="source-code">})</p>
			<p class="source-code">export class ThemeService {</p>
			<p class="source-code">  constructor() {} </p>
			<p class="source-code">  public setSetting(name: string, value: string): void {</p>
			<p class="source-code">    localStorage.setItem(name, value);</p>
			<p class="source-code">  } </p>
			<p class="source-code">  public getSetting(name: string): string {</p>
			<p class="source-code">    switch (name) {</p>
			<p class="source-code">      case 'background':</p>
			<p class="source-code">        return localStorage.getItem(name) || 'yellow';</p>
			<p class="source-code">      case 'tileBackground':</p>
			<p class="source-code">        return localStorage.getItem(name) || '#ffcce9';</p>
			<p class="source-code">      case 'headerBackground':</p>
			<p class="source-code">        return localStorage.getItem(name) || '#00aa00';</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return 'white';</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Here, we will provide example settings if the setting has no previous value. For example, if <strong class="source-inline">headerBackground</strong> has not previously been set, then we will set it to <strong class="source-inline">#00aa00</strong>.</p>
			<p>One of the benefits<a id="_idIndexMarker250"/> of using the theme service from the theme picker component is that you, at a later stage, could choose to implement the theme service to use another mechanism for storing and retrieving settings (for example, you could choose to retrieve values from a corporate design token system that may contain the default settings). Additionally, you can also use a provider scope for the service to share data related to the usage scenario, as you will see later in <a href="B16295_08_ePub_RK.xhtml#_idTextAnchor094"><em class="italic">Chapter 8</em></a>, <em class="italic">Additional Provider Scopes</em>. Another aspect of theming is controlling the relative sizes and placement of items on the screen, depending on user preferences. A modern approach to this is using CSS Grids – and it turns out that we can encapsulate these settings<a id="_idIndexMarker251"/> well using custom CSS properties. We will cover how to do this in the next section. </p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor079"/>Controlling CSS Grid templates using custom CSS properties</h1>
			<p>Imagine that you want to emphasize<a id="_idIndexMarker252"/> the importance of the textual<a id="_idIndexMarker253"/> descriptions of videos, so you would like to increase the amount of space for text, and most likely decrease the amount of space used for the video. This could be implemented using a dynamic viewer using some TypeScript logic, which could perform the sizing calculations on the fly. Given that you would like to be able to view the content on your mobile phone as well, you would need to implement considerations for the grid layout on smaller screens. This additional requirement would be complex enough that custom theming would be required. However, as it turns out, we can combine media queries with inline custom CSS properties in a manner that is both compact and easy to understand. </p>
			<p>If we introduce the <strong class="source-inline">video</strong> and <strong class="source-inline">text</strong> CSS classes for the course video tiles, then we can style them using custom CSS properties and CSS Grid techniques while referencing the <strong class="source-inline">container</strong> grid-columns, like this:</p>
			<p class="source-code">.tile {</p>
			<p class="source-code">  background: var(--tilebackground, grey);</p>
			<p class="source-code">  padding: 15px 15px 15px;</p>
			<p class="source-code">  overflow: hidden;</p>
			<p class="source-code">  &amp;.video {</p>
			<p class="source-code">    grid-column: span var(--videosize, 9);</p>
			<p class="source-code">  }</p>
			<p class="source-code">  &amp;.text {</p>
			<p class="source-code">    grid-column: span var(--textsize, 3);</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">videosize</strong> and <strong class="source-inline">textsize</strong> CSS properties would then control how many columns are assigned to <strong class="source-inline">video</strong> and <strong class="source-inline">text</strong>. The declaration of the <strong class="source-inline">container</strong> grid looks like this:</p>
			<p class="source-code">.container {</p>
			<p class="source-code">  display: grid;</p>
			<p class="source-code">  grid-template-columns: repeat(12, 1fr);</p>
			<p class="source-code">  grid-template-rows: 1fr;</p>
			<p class="source-code">  grid-auto-flow: dense;</p>
			<p class="source-code">  padding: 15px 15px 15px;</p>
			<p class="source-code">  align-content: center;</p>
			<p class="source-code">}</p>
			<p>These new CSS classes<a id="_idIndexMarker254"/> could be combined in the <strong class="source-inline">Course</strong> component to render<a id="_idIndexMarker255"/> the videos alongside accompanying text descriptions, like this:</p>
			<p class="source-code">&lt;div class="container"&gt;</p>
			<p class="source-code">  &lt;div class="tile video"&gt;</p>
			<p class="source-code">    &lt;p&gt;</p>
			<p class="source-code">      &lt;youtube-player videoId="{{ videoId }}"&gt;&lt;/youtube-</p>
			<p class="source-code">       player&gt;</p>
			<p class="source-code">    &lt;/p&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">  &lt;div class="tile text"&gt;</p>
			<p class="source-code">    &lt;h3&gt;</p>
			<p class="source-code">      &lt;i&gt;{{ title }}&lt;/i&gt;</p>
			<p class="source-code">    &lt;/h3&gt;</p>
			<p class="source-code">    &lt;p&gt;</p>
			<p class="source-code">      &lt;a href="https://youtube.com/watch?v={{ videoId }}"&gt; </p>
			<p class="source-code">       Open on youtube&lt;/a&gt;</p>
			<p class="source-code">    &lt;/p&gt;</p>
			<p class="source-code">    &lt;p&gt;{{ description }}&lt;/p&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p>To control the sizing inside the course tiles, we will introduce two new variables to the theme component: <strong class="bold">video size</strong> and <strong class="bold">text size</strong>. These two variables will be bound in their range by the available columns<a id="_idIndexMarker256"/> in the CSS Grid (in this case, 12). Additionally. it would<a id="_idIndexMarker257"/> make sense that they sum up to the number of columns. </p>
			<p>The <strong class="bold">video size</strong> and <strong class="bold">text size</strong> sliders could be implemented as part of the theme picker. This would look like this:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="Images/Figure_5.3_B16295.jpg" alt="Figure 5.3 – Using sliders for video and text size &#13;&#10;" width="439" height="486"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Using sliders for video and text size </p>
			<p>For practical purposes, we will bound the <strong class="bold">video size</strong> variable between <strong class="source-inline">3</strong> and <strong class="source-inline">7</strong> (to allow for a max of <strong class="source-inline">5</strong> for <strong class="bold">text size</strong>). This should leave<a id="_idIndexMarker258"/> sufficient room for both the video and the text inside the grid. This simple<a id="_idIndexMarker259"/> approach can be implemented via a Material Slider, like this:</p>
			<p class="source-code">    &lt;mat-label&gt; video size &lt;/mat-label&gt;</p>
			<p class="source-code">    &lt;mat-slider</p>
			<p class="source-code">      thumbLabel</p>
			<p class="source-code">      min="3" max="7" step="1"</p>
			<p class="source-code">      (input)="setSize('videoSize', $event)"</p>
			<p class="source-code">      [value]="videoSize"</p>
			<p class="source-code">    &gt;</p>
			<p class="source-code">    &lt;/mat-slider&gt;</p>
			<p>Here, the <strong class="source-inline">setSize</strong> callback will update the variable using the theme service in the same manner as the other variables – just with the added complexity that we have received a <strong class="source-inline">MatSliderChange</strong>:</p>
			<p class="source-code">  setSize(name: string, event: MatSliderChange): void {</p>
			<p class="source-code">    this.themeService.setSetting(name, </p>
			<p class="source-code">     event.value?.toString() || '1');</p>
			<p class="source-code">    location.reload();</p>
			<p class="source-code">  }</p>
			<p>Every time we change<a id="_idIndexMarker260"/> the value in one of the sliders, the layout of components<a id="_idIndexMarker261"/> inside the grid could be changed. We should pay attention when including output from external components that have their own layout systems (for example, the YouTube Player). We will learn about integrating the YouTube Player in the next chapter, but for now, let's just settle with a simple <strong class="source-inline">location.reload()</strong>. This should illustrate how to force a render of the grid (and all the other components too).</p>
			<p>Before we leave the topic of using custom CSS properties from Angular, let's remember that we want to support smaller screens as well. It turns out that we can introduce an elegant solution by combining custom CSS properties and media queries without referring to Angular code, like this:</p>
			<p class="source-code">.tile {</p>
			<p class="source-code">  background: var(--tilebackground, grey);</p>
			<p class="source-code">  padding: 15px 15px 15px;</p>
			<p class="source-code">  overflow: hidden;</p>
			<p class="source-code">  @media screen and (min-width: 768px) {</p>
			<p class="source-code">    &amp;.video {</p>
			<p class="source-code">      grid-column: span var(--videosize, 9);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    &amp;.text {</p>
			<p class="source-code">      grid-column: span var(--textsize, 3);</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">  @media only screen and (max-width: 768px) {</p>
			<p class="source-code">    grid-column: span 12;</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Here, we can see one of the strengths of adding support for using custom CSS properties directly from within Angular in the application scope: by using a combination of CSS Custom Properties and media<a id="_idIndexMarker262"/> queries outside the Angular components, we can rely<a id="_idIndexMarker263"/> on the expertise of dedicated designers that can work with little or no knowledge about Angular code. Additionally, we would also have the option of creating integrations that could retrieve theme settings from corporate design token systems, without requiring the application to be redeployed when the design tokens change. </p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor080"/>Summary</h1>
			<p>In this chapter, you encountered the Angular Academy application for the first time and learned how CSS Custom Properties can be used to implement the theme picker using a theme service. Along the way, you also had a brief first encounter with the YouTube Player in the course list. </p>
			<p>In the next chapter, we will dig deeper into how to use the YouTube Player and how you can combine a curriculum of YouTube videos using the Angular components you learned about in <em class="italic">Part 1, A Quick and Functional Guide to Angular Ivy</em>. </p>
		</div>
	</div></body></html>