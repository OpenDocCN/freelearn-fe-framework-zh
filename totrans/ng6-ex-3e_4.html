<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Personal Trainer</h1>
                
            
            <article>
                
<p class="calibre3">The <em class="calibre17">7 Minute Workout</em> app has been an excellent opportunity for us to learn about Angular. Working through the app, we have covered a number of Angular constructs. Still, there are areas such as Angular form support and client-server communication that remain unexplored. This is partially due to the fact that 7 Minute Workout, from a functional standpoint, has limited touch points with the end user. Interactions are limited to starting, stopping, and pausing the workout. Also, the app neither consumes nor produces any data (except workout history).</p>
<p class="calibre3">In this chapter, we plan to delve deeper into one of the two aforementioned areas, Angular form support. Keeping up with the health and fitness theme (no pun intended), we plan to build a <em class="calibre17">Personal Trainer</em> app. The new app will be an extension to <em class="calibre17">7 Minute Workout</em>, allowing us to build our own customized workout plans that are not limited to the <em class="calibre17">7 Minute Workout</em> plans we already have.</p>
<p class="calibre3">This chapter is dedicated to understanding Angular forms and how to put them to use as we build out our <em class="calibre17">Personal Trainer</em> app.</p>
<p class="calibre3">The topics that we will cover in this chapter are as follows:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Defining Personal Trainer requirements</strong>: Since we are building a new app in this chapter, we start with defining the app requirements.</li>
<li class="calibre12"><strong class="calibre1">Defining the Personal Trainer model</strong>: Any app design starts with defining its model. We define the model for <em class="calibre2">Personal Trainer</em>, which is similar to the <em class="calibre2">7 Minute Workout</em> app built earlier.</li>
<li class="calibre12"><strong class="calibre1">Defining the Personal Trainer layout and navigation</strong>: We define the layout, navigation patterns, and views for the new app. We also set up a navigation system that is integrated with Angular routes and the main view.</li>
<li class="calibre12"><strong class="calibre1">Adding support pages</strong>: Before we focus on the form capability and build a Workout component, we build some supporting components for workout and exercise listing.</li>
<li class="calibre12"><strong class="calibre1">Defining the Workout Builder component structure</strong>: We lay out the Workout Builder components that we will use to manage workouts.</li>
<li class="calibre12"><strong class="calibre1">Building forms</strong>: We make extensive use of HTML forms and input elements to create custom workouts. In the process, we will learn more about Angular Forms. The concepts that we cover include:
<ul class="calibre30">
<li class="calibre12"><strong class="calibre1">Form types</strong>: The two types of form that can be built with Angular are template-driven and reactive. We're working with both template-driven and reactive forms in this chapter.</li>
<li class="calibre12"><strong class="calibre1">ngModel</strong>: This provides two-way data binding for template driven forms and allows us to track changes and validate form input.</li>
<li class="calibre12"><strong class="calibre1">Reactive Form Controls</strong>: These include the form builder, form control, form group, and form array. These are used to construct forms programmatically.</li>
<li class="calibre12"><strong class="calibre1">Data formatting</strong>: These are the CSS classes that permit us to style our feedback to the user.</li>
<li class="calibre12"><strong class="calibre1">Input validation</strong>: We will learn about the validation capabilities of Angular forms.</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Personal Trainer app - the problem scope</h1>
                
            
            <article>
                
<p class="calibre3">The <em class="calibre17">7 Minute Workout</em> app is good, but what if we could create an app that allows us to build more such workout routines customized to our fitness level and intensity requirements? With this flexibility, we can build any type of workout, whether it is 7 minutes, 8 minutes, 15 minutes, or any other variations. The opportunities are limitless.</p>
<p class="calibre3">With this premise, let's embark on the journey of building our own <em class="calibre17">Personal Trainer</em> app that helps us to create and manage training/workout plans according to our specific needs. Let's start with defining the requirements for the app.</p>
<div class="packt_infobox">
<p class="calibre20">The new <em class="calibre25">Personal Trainer</em> app will now encompass the existing <em class="calibre25">7 Minute Workout</em> app. The component that supports workout creation will be referred to as Workout Builder. The <em class="calibre25">7 Minute Workout</em> app itself will also be referred to as Workout Runner. In the coming chapters, we will fix <em class="calibre25">Workout Runner</em>, allowing it to run any workout created using <em class="calibre25">Workout Builder</em>.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Personal Trainer requirements</h1>
                
            
            <article>
                
<p class="calibre3">Based on the notion of managing workouts and exercises, these are some of the requirements that our <em class="calibre17">Personal Trainer</em> app should fulfill:</p>
<ul class="calibre11">
<li class="calibre12">The ability to list all available workouts.</li>
<li class="calibre12">The ability to create and edit a workout. While creating and editing a workout, it should have:
<ul class="calibre30">
<li class="calibre12">The ability to add workout attributes including name, title, description, and rest duration</li>
<li class="calibre12">The ability to add/remove multiple exercises for workouts</li>
<li class="calibre12">The ability to order exercises in the workout</li>
<li class="calibre12">The ability to save workout data</li>
</ul>
</li>
<li class="calibre12">The ability to list all available exercises.</li>
<li class="calibre12">The ability to create and edit an exercise. While creating and editing an exercise, it should have:
<ul class="calibre30">
<li class="calibre12">The ability to add exercise attributes such as name, title, description, and procedure</li>
<li class="calibre12">The ability to add pictures for the exercise</li>
<li class="calibre12">The ability to add related videos for the exercise</li>
<li class="calibre12">The ability to add audio clues for the exercise</li>
</ul>
</li>
</ul>
<p class="calibre3">All the requirements seem to be self-explanatory, so let's start with the design of the application. As customary, we first need to think about the model that can support these requirements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Personal Trainer model</h1>
                
            
            <article>
                
<p class="calibre3">No surprises here! The Personal Trainer model itself was defined when we created the <em class="calibre17">7 Minute Workout</em> app. The two central concepts of workout and exercise hold good for <em class="calibre17">Personal Trainer</em> too.</p>
<p class="calibre3">The only problem with the existing workout model is that it is in the directory for <kbd class="calibre13">workout-runner</kbd>. This means that in order to use it, we will have to import it from that directory. It makes more sense to move the model into the <kbd class="calibre13">core</kbd> folder so that it is clear that it can be used across features. We'll do that in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting started with the code for Personal Trainer</h1>
                
            
            <article>
                
<p class="calibre3">First, download the base version of the new <em class="calibre17">Personal Trainer</em> app from <kbd class="calibre13">checkpoint4.1</kbd> in the GitHub repository for the book.</p>
<div class="packt_infobox">
<p class="calibre20">The code is available on GitHub <span class="calibre22"><a href="https://github.com/chandermani/angular6byexample" class="calibre21">https://github.com/chandermani/angular6byexample</a></span> for everyone to download. Checkpoints are implemented as branches in GitHub. The branch to download is as follows: <kbd class="calibre24">GitHub Branch: checkpoint4.1</kbd>. If you are not using Git, download the snapshot of Checkpoint 4.1 (a ZIP file) from the following GitHub location: <a href="https://github.com/chandermani/angular6byexample/archive/checkpoint4.1.zip" class="calibre21">https://github.com/chandermani/angular6byexample/archive/checkpoint4.1.zip</a>. Refer to the <kbd class="calibre24">README.md</kbd> file in the <kbd class="calibre24">trainer</kbd> folder when setting up the snapshot for the first time.</p>
</div>
<p class="calibre3">This code has the complete <em class="calibre17">7 Minute Workout (Workout Runner)</em> app. We have added some more content to support the new <em class="calibre17">Personal Trainer</em> app. Some of the relevant updates are:</p>
<ul class="calibre11">
<li class="calibre12">Adding the new <kbd class="calibre13">WorkoutBuilder</kbd> feature. This feature contains implementations pertaining to <em class="calibre2">Personal Trainer</em>.</li>
<li class="calibre12">Updating the layout and styles of the app.</li>
<li class="calibre12">Adding some components and HTML templates with placeholder content for <em class="calibre2">Personal Trainer</em> in the <kbd class="calibre13">workout-builder</kbd> folder under <kbd class="calibre13">trainer/src/app</kbd>.</li>
<li class="calibre12">Defining a new route to the <kbd class="calibre13">WorkoutBuilder</kbd> feature. We will cover setting up this route within the app in the coming section.</li>
<li class="calibre12">As we just mentioned, moving the existing  <kbd class="calibre13">model.ts</kbd> file into the <kbd class="calibre13">core</kbd> folder.</li>
</ul>
<p class="calibre3">Let's discuss how we will be using the model.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the Personal Trainer model in Workout Builder services</h1>
                
            
            <article>
                
<p class="calibre3">In the last chapter, we dedicated a complete section to learning about Angular services, and one thing we found out was that services are useful for sharing data across controllers and other Angular constructs. <span class="calibre6">Open the </span><kbd class="calibre13">model.ts</kbd><span class="calibre6"> file present in the </span><kbd class="calibre13">core</kbd><span class="calibre6"> folder under </span><kbd class="calibre13">app</kbd><span class="calibre6">. </span>In this class, we essentially do not have any data, but a blueprint that describes the shape of the data. The plan<span class="calibre6"> is to use services to expose this model structure.  We have already done that in Workout Runner. Now, we will do the same in Workout Builder.</span></p>
<div class="packt_infobox">
<p class="calibre20">The <kbd class="calibre24">model.ts</kbd> file has been moved into the <kbd class="calibre24">core</kbd> folder as it is shared across the <em class="calibre25">Workout Builder</em> and <em class="calibre25">Workout Runner</em> apps. Note: in <kbd class="calibre24">checkpoint4.1</kbd> we have updated the import statements in <kbd class="calibre24">workout-runner.component.ts</kbd> , <kbd class="calibre24">workout-audio.component.ts</kbd>, <span class="calibre22">and </span><kbd class="calibre24">workout-history-tracker-service.ts</kbd> to reflect this change.</p>
</div>
<p class="calibre3">In <a href="" class="calibre10">Chapter 2</a>, <em class="calibre17">Building Our First App - 7 Minute Workout</em>, we reviewed the class definitions in the model file: <kbd class="calibre13">Exercise</kbd>, <kbd class="calibre13">ExercisePlan</kbd>, and <kbd class="calibre13">WorkoutPlan</kbd><strong class="calibre5">.</strong> As we then mentioned, these three classes constitute our base model. We will now start using this base model in our new app.</p>
<p class="calibre3">That's all on the model design front. The next thing we are going to do is define the structure for the new app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Personal Trainer layout</h1>
                
            
            <article>
                
<p class="calibre3">The skeleton structure of <em class="calibre17">Personal Trainer</em> looks like this:</p>
<div class="packt_figure"><img src="../images/00027.jpeg" class="calibre28"/></div>
<p class="calibre3">This has the following components:</p>
<ul class="calibre11">
<li class="calibre12"><span>Top Nav</span>: This contains the app branding title and history link.</li>
<li class="calibre12"><span>Sub Nav</span>: This has navigation elements that change based on the active component.</li>
<li class="calibre12"><span>Left Nav</span>: This contains elements that are dependent upon the active component.</li>
<li class="calibre12"><span>Content Area</span>: This is where the main view for our component will display. This is where most of the action happens. We will create/edit exercises and workouts and show a list of exercises and workouts here.</li>
</ul>
<p class="calibre3">Look at the source code files; there is a new folder <kbd class="calibre13">workout-builder</kbd> under <kbd class="calibre13">trainer/src/app</kbd>. It has files for each component that we described previously, with some placeholder content. We will be building these components as we go along in this chapter.</p>
<p class="calibre3">However, we first need to link up these components within the app. This requires us to define the navigation patterns for the Workout Builder app and accordingly define the app routes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Personal Trainer navigation with routes</h1>
                
            
            <article>
                
<p class="calibre3">The navigation pattern that we plan to use for the app is the list-detail pattern. We will create list pages for the exercises and workouts available in the app. Clicking on any list item takes us to the detailed view for the item where we can perform all CRUD operations (create/read/update/delete). The following routes adhere to this pattern:</p>
<table border="1" class="calibre32">
<tbody class="calibre33">
<tr class="calibre34">
<td class="calibre35"><strong class="calibre1">Route</strong></td>
<td class="calibre35"><strong class="calibre1">Description</strong></td>
</tr>
<tr class="calibre34">
<td class="calibre35"><kbd class="calibre13">/builder</kbd></td>
<td class="calibre35">This just redirects to <strong class="calibre1">builder/workouts</strong></td>
</tr>
<tr class="calibre34">
<td class="calibre35"><kbd class="calibre13">/builder/workouts</kbd></td>
<td class="calibre35">This lists all the available workouts. It is the landing page for <em class="calibre2">Workout Builder</em></td>
</tr>
<tr class="calibre34">
<td class="calibre35"><kbd class="calibre13">/builder/workout/new</kbd></td>
<td class="calibre35">This creates a new workout</td>
</tr>
<tr class="calibre34">
<td class="calibre35"><kbd class="calibre13">/builder/workout/:id</kbd></td>
<td class="calibre35">This edits an existing workout with the specific ID</td>
</tr>
<tr class="calibre34">
<td class="calibre35"><kbd class="calibre13">/builder/exercises</kbd></td>
<td class="calibre35">This lists all the available exercises</td>
</tr>
<tr class="calibre34">
<td class="calibre35"><kbd class="calibre13">/builder/exercise/new</kbd></td>
<td class="calibre35">This creates a new exercise</td>
</tr>
<tr class="calibre34">
<td class="calibre35"><kbd class="calibre13">/builder/exercise/:id</kbd></td>
<td class="calibre35">This edits an existing exercise with the specific ID</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting started with Personal Trainer navigation</h1>
                
            
            <article>
                
<p class="calibre3">At this point, if you look at the route configuration in <kbd class="calibre13">app-routing.module.ts</kbd> in the <kbd class="calibre13">src/app</kbd> folder, you will find one new route definition, <kbd class="calibre13">builder</kbd><strong class="calibre5">:</strong></p>
<pre class="calibre19">const routes: Routes = [<br class="title-page-name"/>    ...<br class="title-page-name"/>    { path: 'builder', component: WorkoutBuilderComponent },<br class="title-page-name"/>    ...<br class="title-page-name"/>];</pre>
<p class="calibre3">And if you run the application, you will see that the start screen shows another link, <span class="calibre6">Create a Workout</span>:</p>
<div class="packt_figure"><img src="../images/00028.jpeg" class="calibre51"/></div>
<p class="calibre3">Behind the scenes, we have added another router link for this link into <kbd class="calibre13">start.component.html</kbd>:</p>
<pre class="calibre19">&lt;a routerLink="/builder" class="btn btn-primary btn-lg btn-block" role="button" aria-pressed="true"&gt;<br class="title-page-name"/>   &lt;span&gt;Create a Workout&lt;/span&gt;<br class="title-page-name"/>   &lt;span class="ion-md-add"&gt;&lt;/span&gt;<br class="title-page-name"/>&lt;/a&gt;</pre>
<p class="calibre3">And if you click on this link, you will be taken to the following view:</p>
<div class="packt_figure"><img src="../images/00029.jpeg" class="calibre52"/></div>
<p class="calibre3">Again, behind the scenes we have added  <kbd class="calibre13">workout-builder.component.ts</kbd> to the <kbd class="calibre13">trainer/src/app/workout-builder</kbd> folder with the following inline template:</p>
<pre class="calibre19">  template: `<br class="title-page-name"/>    &lt;div class="row"&gt;<br class="title-page-name"/>      &lt;div class="col-sm-3"&gt;&lt;/div&gt;<br class="title-page-name"/>      &lt;div class="col-sm-6"&gt;<br class="title-page-name"/>          &lt;h1 class="text-center"&gt;Workout Builder&lt;/h1&gt;<br class="title-page-name"/>      &lt;/div&gt;<br class="title-page-name"/>      &lt;div class="col-sm-3"&gt;&lt;/div&gt;<br class="title-page-name"/>    &lt;/div&gt;<br class="title-page-name"/>  `</pre>
<p class="calibre3">And this view is displayed on the screen under the header using the router outlet in our <kbd class="calibre13">app.component.html</kbd> template:</p>
<pre class="calibre19">&lt;div class="container body-content app-container"&gt; 
    &lt;router-outlet&gt;&lt;/router-outlet&gt; 
&lt;/div&gt;` </pre>
<p class="calibre3">We have wrapped this component (along with the other files we have stubbed out for this feature) in a new module named <kbd class="calibre13">workout-builder.module.ts:</kbd></p>
<pre class="calibre19">import { NgModule } from '@angular/core';<br class="title-page-name"/>import { CommonModule } from '@angular/common';<br class="title-page-name"/><br class="title-page-name"/>import { WorkoutBuilderComponent } from './workout-builder.component';<br class="title-page-name"/>import { ExerciseComponent } from './exercise/exercise.component';<br class="title-page-name"/>import { ExercisesComponent } from './exercises/exercises.component';<br class="title-page-name"/>import { WorkoutComponent } from './workout/workout.component';<br class="title-page-name"/>import { WorkoutsComponent } from './workouts/workouts.component';<br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  imports: [<br class="title-page-name"/>    CommonModule<br class="title-page-name"/>  ],<br class="title-page-name"/>  declarations: [WorkoutBuilderComponent, ExerciseComponent, ExercisesComponent, WorkoutComponent, WorkoutsComponent]<br class="title-page-name"/>})<br class="title-page-name"/>export class WorkoutBuilderModule { }</pre>
<p class="calibre3">The only thing that might look different here from the other modules that we have created is that we are importing <kbd class="calibre13">CommonModule</kbd> instead of <kbd class="calibre13">BrowserModule</kbd>. This avoids importing the whole of <kbd class="calibre13">BrowserModule</kbd> a second time, which would generate an error when we get to implementing lazy loading for this module.</p>
<p class="calibre3">Finally, we have added an import for this module to <kbd class="calibre13">app.module.ts</kbd>:</p>
<pre class="calibre19">  ... 
@NgModule({ 
  imports: [ 
  ... 
<strong class="calibre1">    WorkoutBuilderModule],</strong> 
  ... </pre>
<p class="calibre3">So, nothing surprising here. These are the basic component building and routing patterns that we introduced in the previous chapters. Following these patterns, we should now begin to think about adding the additional navigation outlined previously for our new feature. However, before we jump into doing that, there are a couple of things we need to consider.</p>
<p class="calibre3">First, if we start adding our routes to the <kbd class="calibre13">app.routing-module.ts</kbd> file, then the number of routes stored there will grow. These new routes for <em class="calibre17">Workout Builder</em> will also be intermixed with the routes for <em class="calibre17">Workout Runner</em><strong class="calibre5">.</strong> While the number of routes we are now adding might seem insignificant, over time this could get to be a maintenance problem.</p>
<p class="calibre3">Second, we need to take into consideration that our application now consists of two features—<em class="calibre17">Workout Runner</em> and <em class="calibre17">Workout Builder</em>. We should be thinking about ways to separate these features within our application so that they can be developed independently of each other.</p>
<p class="calibre3">Put differently, we want <strong class="calibre5">loose coupling</strong> between the features that we build. Using this pattern allows us to swap out a feature within our application without affecting the other features. For example, somewhere down the line we may want to convert the <em class="calibre17">Workout Runner</em> into a mobile app but leave the <em class="calibre17">Workout Builder</em> intact as a web-based application.</p>
<p class="calibre3">Going back to the first chapter, we emphasized that this ability to separate our components from each other is one of the key advantages of using the <strong class="calibre5">component design pattern</strong> that Angular implements. Fortunately, Angular's router gives us the ability to separate out our routing into logically organized <strong class="calibre5">routing configurations</strong> that closely match the features in our application.</p>
<p class="calibre3">In order to accomplish this separation, Angular allows us to use <strong class="calibre5">child routing</strong>, where we can isolate the routing for each of our features. In this chapter, we will use <strong class="calibre5">child routing</strong> to separate out the routing for <em class="calibre17">Workout Builder</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introducing child routes to Workout Builder</h1>
                
            
            <article>
                
<p class="calibre3">Angular supports our goal of isolating the routing for our new <em class="calibre17">Workout Builder</em> by providing us with the ability to create a hierarchy of router components within our application. We currently have just one router component, which is in the root component of our application. But Angular allows us to add what are called <strong class="calibre5">child router components</strong> under our root component. This means that one feature can be ignorant of the routes the other is using and each is free to adapt its routes in response to changes within that feature.</p>
<p class="calibre3">Getting back to our application, we can use <strong class="calibre5">child routing</strong> in Angular to match the routing for the two features of our application with the code that will be using them. So in our application, we can structure the routing into the following routing hierarchy for our <em class="calibre17">Workout Builder</em> (at this point, we are leaving the <em class="calibre17">Workout Runner</em> as is to show the before and after comparison):</p>
<div class="packt_figure"><img src="../images/00030.jpeg" class="calibre53"/></div>
<p class="calibre3">With this approach, we can create a logical separation of our routes by feature and make them easier to manage and maintain.</p>
<p class="calibre3">So, let's get started by adding child routing to our application.</p>
<div class="packt_infobox">
<p class="calibre20">From this point on in this section, we'll be adding to the code that we downloaded earlier for this chapter. If you want to see the complete code for this next section, you can download it from <kbd class="calibre24">checkpoint 4.2</kbd> in the GitHub repository. If you want to work along with us as we build out the code for this section, still be sure to add the changes in <kbd class="calibre24">styles.css</kbd> in the <kbd class="calibre24">trainer/src</kbd> folder that are part of this checkpoint, since we won't be discussing them here. Also be sure and add the files for exercise(s) ,workout(s), and navigation from the <kbd class="calibre24">trainer/src/app/workout-builder</kbd> folder in the repository. At this stage, these are just stub files, which we will implement later in this chapter. However, you will need these stub files here in order to implement navigation for the <em class="calibre25">Workout Builder</em> module. The code is available for everyone to download on GitHub at <span class="calibre22"><a href="https://github.com/chandermani/angular6byexample" target="_blank" class="calibre21">https://github.com/chandermani/angular6byexample</a></span>. Checkpoints are implemented as branches in GitHub. The branch to download is as follows: <kbd class="calibre24">GitHub Branch: checkpoint4.2</kbd> . If you are not using Git, download the snapshot of <kbd class="calibre24">Checkpoint 4.2</kbd> (a ZIP file) from the following GitHub location: <a href="https://github.com/chandermani/angular6byexample/archive/checkpoint4.2.zip" class="calibre21">https://github.com/chandermani/angular6byexample/archive/checkpoint4.2.zip</a>. Refer to the <kbd class="calibre24">README.md</kbd> file in the <kbd class="calibre24">trainer</kbd> folder when setting up the snapshot for the first time.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding the child routing component</h1>
                
            
            <article>
                
<p class="calibre3">In the <kbd class="calibre13">workout-builder</kbd> directory, add a new TypeScript file named <kbd class="calibre13">workout-builder.routing.module.ts</kbd> with the following imports:</p>
<pre class="calibre19">import { NgModule } from '@angular/core';<br class="title-page-name"/>import { Routes, RouterModule } from '@angular/router';<br class="title-page-name"/>import { WorkoutBuilderComponent } from './workout-builder.component';<br class="title-page-name"/>import { WorkoutsComponent } from './workouts/workouts.component';<br class="title-page-name"/>import { WorkoutComponent } from './workout/workout.component';<br class="title-page-name"/>import { ExercisesComponent } from './exercises/exercises.component';<br class="title-page-name"/>import { ExerciseComponent } from './exercise/exercise.component';</pre>
<p class="calibre3">As you can see, we are importing the components we just mentioned; they will be part of our <em class="calibre17">Workout Builder</em> (exercise, exercises, workout, and workouts). Along with those imports, we are also importing <kbd class="calibre13">NgModule</kbd> from the Angular core module and <kbd class="calibre13">Routes</kbd> and <kbd class="calibre13">RouterModule</kbd> from the Angular router module. These imports will give us the ability to add and export child routes.</p>
<div class="packt_infobox">
<p class="calibre20">We are not using the Angular CLI here because it does not have a standalone blueprint for creating a routing module. However, you can have the CLI create a routing module at the time that you create a module using the <kbd class="calibre24">--routing</kbd> option. In this case, we already had an existing module created so we couldn't use that flag. See <a href="https://github.com/angular/angular-cli/blob/master/docs/documentation/stories/routing.md" target="_blank" class="calibre21">https://github.com/angular/angular-cli/blob/master/docs/documentation/stories/routing.md</a> for more details about how to do this.</p>
</div>
<p class="calibre3">Then, add the following route configuration to the file:</p>
<pre class="calibre19">const routes: Routes = [<br class="title-page-name"/>  {<br class="title-page-name"/>    path: 'builder',<br class="title-page-name"/>    component: WorkoutBuilderComponent,<br class="title-page-name"/>    children: [<br class="title-page-name"/>         {path: '', pathMatch: 'full', redirectTo: 'workouts'},<br class="title-page-name"/>         {path: 'workouts', component: WorkoutsComponent },<br class="title-page-name"/>         {path: 'workout/new', component: WorkoutComponent },<br class="title-page-name"/>         {path: 'workout/:id', component: WorkoutComponent },<br class="title-page-name"/>         {path: 'exercises', component: ExercisesComponent},<br class="title-page-name"/>         {path: 'exercise/new', component: ExerciseComponent },<br class="title-page-name"/>         {path: 'exercise/:id', component: ExerciseComponent }<br class="title-page-name"/>    ]<br class="title-page-name"/>  },<br class="title-page-name"/>];</pre>
<p class="calibre3">The first configuration, <kbd class="calibre13">path: 'builder'</kbd>, sets the base URL for the child routes so that each of the child routes prepends it. The next configuration identifies the <kbd class="calibre13">WorkoutBuilder</kbd> component as the feature area root component for the child components in this file. This means it will be the component in which each of the child components is displayed using <kbd class="calibre13">router-outlet</kbd>. The final configuration is a list of one or more children that defines the routing for the child components.</p>
<p class="calibre3">One thing to note here is that we have set up <kbd class="calibre13">Workouts</kbd> as the default for the child routes with the following configuration:</p>
<pre class="calibre19">{path:'', pathMatch: 'full', redirectTo: 'workouts'}, 
 </pre>
<p class="calibre3">This configuration indicates that if someone navigates to <kbd class="calibre13">builder</kbd>, they will be redirected to the <kbd class="calibre13">builder/workouts</kbd> route. The <kbd class="calibre13">pathMatch: 'full'</kbd> setting means that the match will only be made if the path after workout/builder is an empty string. This prevents the redirection from happening if the routes are something else, such as <kbd class="calibre13">workout/builder/exercises</kbd> or any of the other routes we have configured within this file.</p>
<p class="calibre3">Finally, add the following class declaration preceded by an <kbd class="calibre13">@NgModule</kbd> decorator that defines imports and exports for our module:</p>
<pre class="calibre19">@NgModule({<br class="title-page-name"/>  imports: [RouterModule.forChild(routes)],<br class="title-page-name"/>  exports: [RouterModule]<br class="title-page-name"/>})<br class="title-page-name"/>export class WorkoutBuilderRoutingModule { }</pre>
<p class="calibre3">This import is very similar to the one in <kbd class="calibre13">app.routing-module.ts</kbd>, with one difference: instead of <kbd class="calibre13">RouterModule.forRoot</kbd>, we are using <kbd class="calibre13">RouterModule.forChild</kbd>. The reason for the difference may seem self-explanatory: we are creating child routes, not the routes in the root of the application, and this is how we signify that. Under the hood, however, there is a significant difference. This is because we cannot have more than one router service active in our application. <kbd class="calibre13">forRoot</kbd> creates the router service but <kbd class="calibre13">forChild</kbd> does not.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Updating the WorkoutBuilder component</h1>
                
            
            <article>
                
<p class="calibre3">We next need to update the <kbd class="calibre13">WorkoutBuilder</kbd> component to support our new child routes. To do so, change the <kbd class="calibre13">@Component</kbd> decorator for Workout Builder to:</p>
<ol class="calibre14">
<li value="1" class="calibre12">Remove the <kbd class="calibre13">selector</kbd></li>
<li value="2" class="calibre12">Add a <kbd class="calibre13">&lt;abe-sub-nav-main&gt;</kbd> custom element to the template</li>
<li value="3" class="calibre12">Add a <kbd class="calibre13">&lt;router-outlet&gt;</kbd> tag to the template</li>
</ol>
<p class="calibre3">The decorator should now look like the following:</p>
<pre class="calibre19">@Component({<br class="title-page-name"/>  template: `&lt;div class="container-fluid fixed-top mt-5"&gt;<br class="title-page-name"/>                &lt;div class="row mt-5"&gt;<br class="title-page-name"/>                  &lt;abe-sub-nav-main&gt;&lt;/abe-sub-nav-main&gt;<br class="title-page-name"/>                &lt;/div&gt;<br class="title-page-name"/>                &lt;div class="row mt-2"&gt;<br class="title-page-name"/>                  &lt;div class="col-sm-12"&gt;<br class="title-page-name"/>                    &lt;router-outlet&gt;&lt;/router-outlet&gt;<br class="title-page-name"/>                  &lt;/div&gt;<br class="title-page-name"/>                &lt;/div&gt;<br class="title-page-name"/>            &lt;div&gt;`<br class="title-page-name"/>})</pre>
<p class="calibre3">We are removing the selector because <kbd class="calibre13">WorkoutBuilderComponent</kbd> will not be embedded in the application root, <kbd class="calibre13">app.component.ts</kbd>. Instead, it will be reached from <kbd class="calibre13">app.routing-module.ts</kbd> through routing. And while it will handle incoming routing requests from <kbd class="calibre13">app.routes.ts</kbd>, it will in turn be routing them to the other components contained in the Workout Builder feature.</p>
<p class="calibre3">And those components will display their views using the <kbd class="calibre13">&lt;router-outlet&gt;</kbd> tag that we have just added to the <kbd class="calibre13">WorkoutBuilder</kbd> template. Given that the template for <kbd class="calibre13">Workout BuilderComponent</kbd> will be simple, we are using an inline <kbd class="calibre13">template</kbd> instead of a <kbd class="calibre13">templateUrl</kbd>.</p>
<div class="packt_infobox">
<p class="calibre20">Typically, for a component's view we recommend using a <kbd class="calibre24">templateUrl</kbd> that points to a separate HTML template file. This is especially true when you anticipate that the view will involve more than a few lines of HTML. In that situation, it is much easier to work with a view inside its own HTML file. </p>
</div>
<p class="calibre3">We are also adding an <kbd class="calibre13">&lt;abe-sub-nav-main&gt;</kbd> element that will be used to create a secondary top-level menu for navigating within the <em class="calibre17">Workout Builder</em> feature. We'll discuss that a little later in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Updating the Workout Builder module</h1>
                
            
            <article>
                
<p class="calibre3">Now, let's update <kbd class="calibre13">WorkoutBuilderModule</kbd>.  First, add the following import to the file:</p>
<pre class="calibre19">import { WorkoutBuilderRoutingModule } from './workout-builder-routing.module';</pre>
<p class="calibre3">It imports the child routing that we just set up.</p>
<p class="calibre3">Next, update the <kbd class="calibre13">@NgModule</kbd> decorator to add <kbd class="calibre13">workoutBuilderRoutingModule</kbd>:</p>
<pre class="calibre19">...<br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  imports: [<br class="title-page-name"/>    CommonModule,<br class="title-page-name"/>    <strong class="calibre1">WorkoutBuilderRoutingModule</strong><br class="title-page-name"/>  ],<br class="title-page-name"/>...
}) </pre>
<p class="calibre3">Finally, add the imports and declarations for the new navigation components that can be found in <kbd class="calibre13">checkpoint4.2</kbd>:</p>
<pre class="calibre19">import { LeftNavExercisesComponent } from './navigation/left-nav-exercises.component';<br class="title-page-name"/>import { LeftNavMainComponent } from './navigation/left-nav-main.component';<br class="title-page-name"/>import { SubNavMainComponent } from './navigation/sub-nav-main.component';<br class="title-page-name"/>...<br class="title-page-name"/>  declarations: [<br class="title-page-name"/>    ...<br class="title-page-name"/>    LeftNavExercisesComponent,<br class="title-page-name"/>    LeftNavMainComponent,<br class="title-page-name"/>    SubNavMainComponent]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Updating App Routing module</h1>
                
            
            <article>
                
<p class="calibre3">One last step: return to <kbd class="calibre13">app.routing-module.ts</kbd> and remove the import of the <kbd class="calibre13">WorkoutBuilderComponent</kbd> and the route definition that points to the builder:<kbd class="calibre13">{ path: 'builder', component: WorkoutBuilderComponent },</kbd><span class="calibre6">.</span></p>
<div class="packt_infobox">
<p class="calibre20">Be sure to leave the import of the <kbd class="calibre24">WorkoutBuilderModule</kbd>  in <kbd class="calibre24">app.module.ts</kbd> unchanged. We'll discuss removing that in the next section when we cover lazy loading.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Putting it all together</h1>
                
            
            <article>
                
<p class="calibre3">From the previous chapter, we already know how to set up root routing for our application. But now, what we have instead of root routing is area or feature routing that contains child routes. We have been able to achieve the separation of concerns we discussed earlier, so that all the routes related to the <em class="calibre17">Workout Builder</em> are now separately contained in their own routing configuration. This means that we can manage all the routing for <em class="calibre17">Workout Builder</em> in the <kbd class="calibre13">WorkoutBuilderRoutes</kbd> component without affecting other parts of the application.</p>
<p class="calibre3">We can see how the router combines the routes in <kbd class="calibre13">app.routes.ts</kbd> with the default route in <kbd class="calibre13">workout-builder.routes.ts</kbd>, if we now navigate from the start page to the Workout Builder:</p>
<div class="packt_figure"><img src="../images/00031.jpeg" class="calibre54"/></div>
<p class="calibre3">If we look at the URL in the browser, it is <kbd class="calibre13">/builder/workouts</kbd>. You'll recall that the router link on the start page is <kbd class="calibre13">['/builder']</kbd>. So how did the router take us to this location?</p>
<p class="calibre3">It does it this way: when the link is clicked, the Angular router first looks to <kbd class="calibre13">app-routing.module.ts</kbd> for the <kbd class="calibre13">builder</kbd> path because that file contains the configuration for the root routes in our application. The router does not find that path because we have removed it from the routes in that file.</p>
<p class="calibre3">However, <kbd class="calibre13">WorkoutBuilderModule</kbd> has been imported into our <kbd class="calibre13">AppModule</kbd> and that module in turn imports <kbd class="calibre13">workoutBuilderRoutingModule</kbd>. The latter file contains the child routes that we just configured. The router finds that <kbd class="calibre13">builder</kbd> is the parent route in that file and so it uses that route. It also finds the default setting that redirects to the child path <kbd class="calibre13">workouts</kbd> in the event that the <kbd class="calibre13">builder</kbd> path ends with an empty string, which it does in this case.</p>
<p class="calibre3">If you look at the screen, you will see it is displaying the view for <kbd class="calibre13">Workouts</kbd> (and not as previously <em class="calibre17">Workout Builder</em>). This means that the router has successfully routed the request to <kbd class="calibre13">WorkoutsComponent</kbd>, which is the component for the default route in the child route configuration that we set up in <kbd class="calibre13"><span>workoutBuilderRoutingModule</span></kbd>.</p>
<p class="calibre3">This process of route resolution is illustrated here:</p>
<div class="packt_figure"><img src="../images/00032.jpeg" class="calibre55"/></div>
<p class="calibre3">One final thought on child routing. When you look at our child routing component, <kbd class="calibre13">workout-builder.component.ts</kbd>, you will see that it has no references to its parent component, <kbd class="calibre13">app.component.ts</kbd> (as we mentioned earlier, the <kbd class="calibre13">&lt;selector&gt;</kbd> tag has been removed, so  <kbd class="calibre13">WorkoutBuilderComponent</kbd>  is not being embedded in the root component). This means that we have successfully encapsulated <kbd class="calibre13">WorkoutBuilderComponent</kbd> (and all of its related components that are imported in the <kbd class="calibre13">WorkoutBuilderModule</kbd>) in a way that will allow us to move all of it elsewhere in the application, or even into a new application.</p>
<p class="calibre3">Now, it's time for us to move on to converting our routing for the Workout Builder to use lazy loading and building out its navigation menus. If you want to see the completed code for this next section, you can download it from the companion codebase in <kbd class="calibre13">checkpoint 4.3</kbd>. Again, if you are working along with us as we build the application, be sure and update the <kbd class="calibre13">styles.css</kbd> file, which we are not discussing here.</p>
<div class="packt_infobox">
<p class="calibre20">The code is also available for everyone to download on GitHub at <span class="calibre22"><a href="https://github.com/chandermani/angular6byexample" target="_blank" class="calibre21">https://github.com/chandermani/angular6byexample</a></span>. Checkpoints are implemented as branches in GitHub. The branch to download is as follows: <kbd class="calibre24">GitHub Branch: checkpoint4.3</kbd> (folder - <kbd class="calibre24">trainer</kbd>). If you are not using Git, download the snapshot of <kbd class="calibre24">Checkpoint 4.3</kbd> (a ZIP file) from the following GitHub location: <a href="https://github.com/chandermani/angular6byexample/archive/checkpoint4.3.zip" class="calibre21">https://github.com/chandermani/angular6byexample/archive/checkpoint4.3.zip</a>. Refer to the <kbd class="calibre24">README.md</kbd> file in the <kbd class="calibre24">trainer</kbd> folder when setting up the snapshot for the first time.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Lazy loading of routes</h1>
                
            
            <article>
                
<p class="calibre3">When we roll out our application, we expect that our users will be accessing the Workout Runner every day (and we know that this will be the case for you!). But, we anticipate that they will only occasionally be using the Workout Builder to construct their exercises and workout plans. It would therefore be nice if we could avoid the overhead of loading the Workout Builder when our users are just doing their exercises in the Workout Runner. Instead, we would prefer to load Workout Builder only on demand when a user wants to add to or update their exercises and workout plans. This approach is called lazy loading. Lazy loading allows us to em<span class="calibre6">ploy an asynchronous approach when loading our modules. This means that we can load just what is required to get the application started and then load other modules as we need them.</span></p>
<div class="packt_infobox">
<p class="calibre20">Under the hood, when we use the Angular CLI to build and serve our application, it uses WebPack's bundling and chunking capabilities to accomplish lazy loading. We'll be discussing these capabilities as we work through how to implement lazy loading in our application. </p>
</div>
<p class="calibre3">So in our <em class="calibre17">Personal Trainer</em>, we want to change the application so that it only loads the <strong class="calibre5">Workout Builder</strong> on demand. And the Angular router allows us to do just that using lazy loading.</p>
<p class="calibre3">But before we get started implementing lazy loading, let's take a look at our current application and how it is loading our modules. With the developer tools open in the <span class="calibre6">Sources</span> tab, start up the application; when the start page appears in your browser, if you look under the webpack node in the source tree, you will see that all the files in the application have loaded, including both the <em class="calibre17">Workout Runner</em> and <em class="calibre17">Workout Builder</em> files:</p>
<div class="packt_figure"><img src="../images/00033.jpeg" class="calibre56"/></div>
<p class="calibre3">So, even though we may just want to use the <em class="calibre17">Workout Runner</em>, we have to load the <em class="calibre17">Workout Builder</em> as well. In a way, this makes sense if you think of our application as a <strong class="calibre5">Single Page Application</strong> (<strong class="calibre5">SPA</strong>). In order to avoid round trips to the server, an SPA will typically load all the resources that will be needed to use the application when it is first started up by a user. But in our case, the important point is that we do not need the <em class="calibre17">Workout Builder</em> when the application is first loaded. Instead, we would like to load those resources only when the user decides that they want to add or change a workout or exercise.</p>
<p class="calibre3">So, let's get started with making that happen.</p>
<p class="calibre3">First, modify <kbd class="calibre13">app.routing-module.ts</kbd> to add the following route configuration for <kbd class="calibre13">WorkoutBuilderModule</kbd>:</p>
<pre class="calibre19">const routes: Routes = [<br class="title-page-name"/>    ...<br class="title-page-name"/>    <strong class="calibre1">{ path: 'builder', loadChildren: './workout-builder/workout-builder.module#WorkoutBuilderModule'},</strong><br class="title-page-name"/>    { path: '**', redirectTo: '/start' }<br class="title-page-name"/>];</pre>
<p class="calibre3">Notice that the <kbd class="calibre13">loadChildren</kbd> property is:</p>
<pre class="calibre19">module file path + # + module name </pre>
<p class="calibre3">This configuration provides the information that will be needed to load and instantiate <kbd class="calibre13">WorkoutBuilderModule</kbd>. </p>
<p class="calibre3">Next go back to <kbd class="calibre13">workout-builder-routing.module.ts</kbd> and change the <kbd class="calibre13">path</kbd> property to an empty string:</p>
<pre class="calibre19">export const Routes: Routes = [ 
    { 
<strong class="calibre1">        path: '',</strong> 
. . . 
    } 
]; </pre>
<p class="calibre3">We are making this change because we are now setting the path (<kbd class="calibre13">builder</kbd>) to the <kbd class="calibre13">WorkoutBuilderRoutes</kbd> in the new configuration for them that we added in <kbd class="calibre13">app.routing-module.ts</kbd>.</p>
<p class="calibre3">Finally go back to <kbd class="calibre13">app-module.ts</kbd>  and remove the <kbd class="calibre13">WorkoutBuilderModule</kbd> import in the <kbd class="calibre13">@NgModule</kbd> configuration in that file. What this means is that instead of loading the <strong class="calibre5">Workout Builder</strong> feature when the application first starts, we only load it when a user accesses the route to <em class="calibre17">Workout Builder</em>.</p>
<p class="calibre3">Let's go build and run the application again using <kbd class="calibre13">ng serve</kbd>. In the Terminal window, you should see something like the following output:</p>
<div class="packt_figure"><img src="../images/00034.jpeg" class="calibre57"/></div>
<p class="calibre3">What's interesting here is the last line that shows a separate file for the <kbd class="calibre13">workout.builder.module</kbd> called <kbd class="calibre13">workout-builder.module.chunk.js.</kbd>. <strong class="calibre5">WebPack</strong> has used what is called code splitting to carve out our workout builder module into a separate chunk. This chunk will not be loaded in our application until it is needed (that is, when the router navigates to <kbd class="calibre13">WorkoutBuilderModule</kbd>).</p>
<p class="calibre3">Now, keeping the <span class="calibre6">Sources</span> tab open in the Chrome developer tools bring up the application in the browser again. When the start page loads, only the files related to the <em class="calibre17">Workout Runner</em> appear and not those related to the <em class="calibre17">Workout Builder</em>, as shown here:</p>
<div class="packt_figure"><img src="../images/00035.jpeg" class="calibre58"/></div>
<p class="calibre3">Then, if we clear the <span class="calibre6">Network</span> tab and click on the <span class="calibre6">Create a Workout link</span>, we'll see <span class="calibre6">the </span><kbd class="calibre13">workout-builder.module</kbd><span class="calibre6"> chunk</span> load:</p>
<div class="packt_figure"><img src="../images/00036.gif" class="calibre28"/></div>
<p class="calibre3">This means that we have achieved encapsulation of our new feature and with asynchronous routing we are able to use lazy loading to load all its components only when needed.</p>
<p class="calibre3">Child and asynchronous routing make it straightforward to implement applications that allow us to have our cake and eat it too. On one hand, we can build SPAs with powerful client-side navigation, while on the other hand we can also encapsulate features in separate child routing components and load them only on demand.</p>
<p class="calibre3">This power and flexibility of the Angular router give us the ability to meet user expectations by closely mapping our application's behavior and responsiveness to the ways they will use the application. In this case, we have leveraged these capabilities to achieve what we set out to do: immediately load <em class="calibre17">Workout Runner </em>so that our users can get to work on their exercises right away, but avoid the overhead of loading <em class="calibre17">Workout Builder </em>and instead only serve it when a user wants to build a workout.</p>
<p class="calibre3">Now that we have the routing configuration in place in the <em class="calibre17">Workout Builder</em>, we will turn our attention to building out the sub-level and left navigation; this will enable us to use this routing. The next sections cover implementing this navigation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Integrating sub- and side-level navigation</h1>
                
            
            <article>
                
<p class="calibre3">The basic idea around integrating sub- and side-level navigation into the app is to provide context-aware sub-views that change based on the active view. For example, when we are on a list page as opposed to editing an item, we may want to show different elements in the navigation. An e-commerce site is a great example of this. Imagine Amazon's search result page and product detail page. As the context changes from a list of products to a specific product, the navigation elements that are loaded also change.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Sub-level navigation</h1>
                
            
            <article>
                
<p class="calibre3">We'll start by adding sub-level navigation to the <em class="calibre17">Workout Builder</em>. We have already imported our <kbd class="calibre13">SubNavMainComponent</kbd> into the <em class="calibre17">Workout Builder</em>. But, currently it is just displaying placeholder content:</p>
<div class="packt_figure"><img src="../images/00037.jpeg" class="calibre59"/></div>
<p class="calibre3">We'll now replace that content with three router links: <span class="calibre6">Home</span>, <span class="calibre6">New Workout</span>, and <span class="calibre6">New Exercise</span>.</p>
<p class="calibre3">Open the <kbd class="calibre13">sub-nav-main.component.html</kbd> file and change the HTML in it to the following:</p>
<pre class="calibre19">&lt;nav class="navbar fixed-top navbar-dark bg-primary mt-5"&gt;<br class="title-page-name"/>    &lt;div&gt;<br class="title-page-name"/>        &lt;a [routerLink]="['/builder/workouts']" class="btn btn-primary"&gt;<br class="title-page-name"/>        &lt;span class="ion-md-home"&gt;&lt;/span&gt; Home<br class="title-page-name"/>        &lt;/a&gt;<br class="title-page-name"/>        &lt;a [routerLink]="['/builder/workout/new']" class="btn btn-primary"&gt;<br class="title-page-name"/>        &lt;span class="ion-md-add"&gt;&lt;/span&gt; New Workout<br class="title-page-name"/>        &lt;/a&gt;<br class="title-page-name"/>        &lt;a [routerLink]="['/builder/exercise/new']" class="btn btn-primary"&gt;<br class="title-page-name"/>        &lt;span class="ion-md-add"&gt;&lt;/span&gt; New Exercise<br class="title-page-name"/>        &lt;/a&gt;<br class="title-page-name"/>    &lt;/div&gt;<br class="title-page-name"/>&lt;/nav&gt;</pre>
<p class="calibre3">Now, rerun the application and you will see the three navigation links. If we click on the <span class="calibre6">New Exercise</span> link button, we will be routed to <kbd class="calibre13">ExerciseComponent</kbd> and its view will appear in the <span class="calibre6">Router Outlet</span> in the <em class="calibre17">Workout Builder</em> view:</p>
<div class="packt_figure"><img src="../images/00038.jpeg" class="calibre60"/></div>
<p class="calibre3">The <span class="calibre6">New Workout</span> link button will work in a similar fashion; when clicked on, it will take the user to the <kbd class="calibre13">WorkoutComponent</kbd> and display its view in the router outlet. Clicking on the <span class="calibre6">Home</span> link button will return the user to the <kbd class="calibre13">WorkoutsComponent</kbd> and view.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Side navigation</h1>
                
            
            <article>
                
<p class="calibre3">Side-level navigation within the <em class="calibre17">Workout Builder</em> will vary depending on the child component that we navigate to. For instance, when we first navigate to the <em class="calibre17">Workout Builder</em>, we are taken to the <span class="calibre6">Workouts</span> screen because the <kbd class="calibre13">WorkoutsComponent</kbd> route is the default route for the <em class="calibre17">Workout Builder</em>. That component will need side navigation; it will allow us to select to view a list of workouts or a list of exercises.</p>
<p class="calibre3">The component-based nature of Angular gives us an easy way to implement these context-sensitive menus. We can define new components for each of the menus and then import them into the components that need them. In this case, we have three components that will need side menus: <strong class="calibre5">Workouts</strong>, <strong class="calibre5">Exercises</strong>, and <strong class="calibre5">Workout</strong>. The first two of these components can actually use the same menu so we really only need two side menu components: <kbd class="calibre13">LeftNavMainComponent</kbd>, which will be like the preceding menu and will be used by the <kbd class="calibre13">Exercises</kbd> and <kbd class="calibre13">Workouts</kbd> components, and <kbd class="calibre13">LeftNavExercisesComponent</kbd>, which will contain a list of existing exercises and will be used by the <kbd class="calibre13">Workouts</kbd> component.</p>
<p class="calibre3">We already have files for the two menu components, including template files, and have imported them into <kbd class="calibre13">WorkoutBuilderModule</kbd>. We will now integrate these into the components that need them.</p>
<p class="calibre3">First, modify the <kbd class="calibre13">workouts.component.html</kbd> template to add the selector for the menu:</p>
<pre class="calibre19">&lt;div class="row"&gt;<br class="title-page-name"/>    &lt;div&gt;<br class="title-page-name"/>        &lt;abe-left-nav-main&gt;&lt;/abe-left-nav-main&gt;<br class="title-page-name"/>    &lt;/div&gt;<br class="title-page-name"/>    &lt;div class="col-sm-10 builder-content"&gt;<br class="title-page-name"/>        &lt;h1 class="text-center"&gt;Workouts&lt;/h1&gt;<br class="title-page-name"/>    &lt;/div&gt;<br class="title-page-name"/>  &lt;/div&gt;</pre>
<p class="calibre3">Then, replace the placeholder text in the <kbd class="calibre13">left-nav-main.component.html</kbd> with the navigation links to <kbd class="calibre13">WorkoutsComponent</kbd> and <kbd class="calibre13">ExercisesComponent</kbd>:</p>
<pre class="calibre19">&lt;div class="left-nav-bar"&gt;<br class="title-page-name"/>    &lt;div class="list-group"&gt;<br class="title-page-name"/>        &lt;a [routerLink]="['/builder/workouts']" class="list-group-item list-group-item-action"&gt;Workouts&lt;/a&gt;<br class="title-page-name"/>        &lt;a [routerLink]="['/builder/exercises']" class="list-group-item list-group-item-action"&gt;Exercises&lt;/a&gt;<br class="title-page-name"/>    &lt;/div&gt;<br class="title-page-name"/>&lt;/div&gt;</pre>
<p class="calibre3">Run the application and you should see the following:</p>
<div class="packt_figure"><img src="../images/00039.jpeg" class="calibre28"/></div>
<p class="calibre3">Follow the exact same steps to complete the side menu for the <kbd class="calibre13">Exercises</kbd> component.</p>
<div class="packt_infobox">We won't show the code for this menu here, but you can find it in the <kbd class="calibre24">workout-builder/exercises</kbd> folder under <kbd class="calibre24">trainer/src/app</kbd> in <kbd class="calibre24">checkpoint 4.3</kbd> of the GitHub repository.</div>
<p class="calibre3">For the menu for the <span class="calibre6">Workout</span> screen, the steps are the same except that you should change <kbd class="calibre13">left-nav-exercises.component.html</kbd> to the following:</p>
<pre class="calibre19">&lt;div class="left-nav-bar"&gt;<br class="title-page-name"/>  &lt;h3&gt;Exercises&lt;/h3&gt;<br class="title-page-name"/>&lt;/div&gt; </pre>
<p class="calibre3">We will use this template as the starting point for building out a list of exercises that will appear on the left-hand side of the screen and can be selected for inclusion in a workout.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing workout and exercise lists</h1>
                
            
            <article>
                
<p class="calibre3">Even before we start implementing the <span class="calibre6">Workout</span> and <span class="calibre6">Exercise</span> list pages, we need a data store for exercise and workout data. The current plan is to have an in-memory data store and expose it using an Angular service. In <a href="" class="calibre10">Chapter 5</a>, <em class="calibre17">Supporting Server Data Persistence</em>, where we talk about server interaction, we will move this data to a server store for long-term persistence. For now, the in-memory store will suffice. Let's add the store implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">WorkoutService as a workout and exercise repository</h1>
                
            
            <article>
                
<p class="calibre3">The plan here is to create a <kbd class="calibre13">WorkoutService</kbd> instance that is responsible for exposing the exercise and workout data across the two applications. The main responsibilities of the service include:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Exercise-related CRUD operations</strong>: Get all exercises, get a specific exercise based on its name, create an exercise, update an exercise, and delete it</li>
<li class="calibre12"><strong class="calibre1">Workout-related CRUD operations</strong>: These are similar to the exercise-related operations, but targeted toward the workout entity</li>
</ul>
<div class="packt_infobox">
<p class="calibre20">The code is available to download on GitHub at <span class="calibre22"><a href="https://github.com/chandermani/angular6byexample" class="calibre21">https://github.com/chandermani/angular6byexample</a></span>. The branch to download is as follows: <strong class="calibre23">GitHub Branch: checkpoint4.4</strong> (folder—<kbd class="calibre24">trainer</kbd>). If you are not using Git, download the snapshot of <kbd class="calibre24">Checkpoint 4.4</kbd> (a ZIP file) from the following GitHub location: <a href="https://github.com/chandermani/angular6byexample/archive/checkpoint4.4.zip" target="_blank" class="calibre21">https://github.com/chandermani/angular6byexample/archive/checkpoint4.4.zip</a>. Refer to the <kbd class="calibre24">README.md</kbd> file in the <kbd class="calibre24">trainer</kbd> folder when setting up the snapshot for the first time. Again, if you are working along with us as we build the application, be sure to update the <kbd class="calibre24">styles.css</kbd> file, which we are not discussing here. Because some of the files in this section are rather long, rather than showing the code here, we are also going to suggest at times that you simply copy the files into your solution.</p>
</div>
<p class="calibre3">Locate <kbd class="calibre13">workout-service.ts</kbd> in the <kbd class="calibre13">trainer/src/core</kbd> folder. The code in that file should look like the following, except for the implementation of the two methods <kbd class="calibre13">setupInitialExercises</kbd> and <kbd class="calibre13">setupInitialWorkouts</kbd>, which we have left out because of their length:</p>
<pre class="calibre19">import {Injectable} from '@angular/core'; 
import {ExercisePlan} from './model'; 
import {WorkoutPlan} from './model'; 
import {Exercise} from "./model";<br class="title-page-name"/>import { CoreModule } from './core.module'; 
 
@Injectable({<br class="title-page-name"/>  providedIn: CoreModule<br class="title-page-name"/>})
export class WorkoutService { 
    workouts: Array&lt;WorkoutPlan&gt; = []; 
    exercises: Array&lt;Exercise&gt; = []; 
 
    constructor() { 
        this.setupInitialExercises(); 
        this.setupInitialWorkouts(); 
    } 
 
    getExercises(){ 
        return this.exercises; 
    } 
 
    getWorkouts(){ 
        return this.workouts; 
    } 
    setupInitialExercises(){ 
     // implementation of in-memory store. 
    } 
 
    setupInitialWorkouts(){ 
     // implementation of in-memory store. 
    } 
}} </pre>
<p class="calibre3">As we have mentioned before, the implementation of an Angular service is straightforward. Here, we are declaring a class with the name <kbd class="calibre13">WorkoutService</kbd> and decorating it with <kbd class="calibre13">@Injectable</kbd> . Within the <kbd class="calibre13">@Injectable</kbd> decorator, we have  sets the <kbd class="calibre13">provided-in</kbd> property to <kbd class="calibre13">CoreModule</kbd>.  <span class="calibre6">This registers </span><kbd class="calibre13">WorkoutService</kbd><span class="calibre6"> as a provider with Angular's </span><strong class="calibre5">Dependency Injection</strong><span class="calibre6"> framework and makes it available throughout our application.</span></p>
<p class="calibre3">In the class definition, we first create two arrays: one for <kbd class="calibre13">Workouts</kbd> and one for <kbd class="calibre13">Exercises</kbd>. These arrays are of types <kbd class="calibre13">WorkoutPlan</kbd> and <kbd class="calibre13">Exercise</kbd> respectively, and we therefore need to import <kbd class="calibre13">WorkoutPlan</kbd> and <kbd class="calibre13">Exericse</kbd> from <kbd class="calibre13">model.ts</kbd> to get the type definitions for them.</p>
<p class="calibre3">The constructor calls two methods to set up the <span class="calibre6">Workouts</span> and <span class="calibre6">Services List</span>. At the moment, we are just using an in-memory store that populates these lists with data.</p>
<p class="calibre3">The two methods, <kbd class="calibre13">getExercises</kbd> and <kbd class="calibre13">getWorkouts</kbd>, as the names suggest, return a list of exercises and workouts respectively. Since we plan to use the in-memory store to store workout and exercise data, the <kbd class="calibre13">Workouts</kbd> and <kbd class="calibre13">Exercises</kbd> arrays store this data. As we go along, we will be adding more functions to the service.</p>
<p class="calibre3">Time to build out the components for the workout and exercise lists!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Workout and exercise list components</h1>
                
            
            <article>
                
<p class="calibre3">First, open the <kbd class="calibre13">workouts.component.ts</kbd> file in the <kbd class="calibre13">trainer/src/app/workout-builder/workouts</kbd> folder and update the imports as follows:</p>
<pre class="calibre19">import { Component, OnInit } from '@angular/core';<br class="title-page-name"/>import { Router } from '@angular/router';<br class="title-page-name"/><br class="title-page-name"/>import { WorkoutPlan } from '../../core/model';<br class="title-page-name"/>import { WorkoutService } from '../../core/workout.service';; </pre>
<p class="calibre3">This new code imports the Angular  <kbd class="calibre13">Router</kbd> <span class="calibre6">as </span>well as <kbd class="calibre13">WorkoutService</kbd> and the <kbd class="calibre13">WorkoutPlan</kbd> type.</p>
<p class="calibre3">Next, replace the class definition with the following code:</p>
<pre class="calibre19">export class WorkoutsComponent implements OnInit { 
    workoutList:Array&lt;WorkoutPlan&gt; = []; 
 
    constructor( 
        public router:Router, 
        public workoutService:WorkoutService) {} 
 
    ngOnInit() { 
        this.workoutList = this.workoutService.getWorkouts(); 
    } 
 
    onSelect(workout: WorkoutPlan) { 
        this.router.navigate( ['./builder/workout', workout.name] ); 
    } 
} </pre>
<p class="calibre3">This code adds a constructor into which we are injecting the <kbd class="calibre13">Router</kbd> and the <kbd class="calibre13">WorkoutService</kbd>. The <kbd class="calibre13">ngOnInit</kbd> method then calls the <kbd class="calibre13">getWorkouts</kbd> method on the <kbd class="calibre13">WorkoutService</kbd> and populates a <kbd class="calibre13">workoutList</kbd>  array with a list of <kbd class="calibre13">WorkoutPlans</kbd> returned from that method call. We'll use that <kbd class="calibre13">workoutList</kbd> array to populate the list of workout plans that will display in the <kbd class="calibre13">Workouts</kbd> component's view.</p>
<p class="calibre3">You'll notice that we are putting the code for calling <kbd class="calibre13">WorkoutService</kbd> into the <kbd class="calibre13">ngOnInit</kbd> method. We want to avoid placing this code in the constructor. Eventually, we will be replacing the in-memory store that this service uses with a call to an external data store and we do not want the instantiation of our component to be affected by this call. Adding these method calls to the constructor would also complicate testing the component.</p>
<p class="calibre3">To avoid such unintended side effects, we instead place the code in the <kbd class="calibre13">ngOnInit</kbd> method. This method implements one of Angular's life cycle hooks, <kbd class="calibre13">OnInit</kbd>, which Angular calls after creating an instance of the service. This way, we rely on Angular to call this method in a predictable way that does not affect the instantiation of the component.</p>
<p class="calibre3">Next, we'll make almost identical changes to the <kbd class="calibre13">Exercises</kbd> component. As with the <kbd class="calibre13">Workouts</kbd> component, this code injects the workout service into our component. This time, we then use the workout service to retrieve the exercises.</p>
<div class="packt_infobox">Because it so similar to what we just showed you for the <kbd class="calibre24">Workouts</kbd> component, we won't show that code here. Just add it from the <kbd class="calibre24">workout-builder/exercises</kbd> folder in  <kbd class="calibre24">checkpoint 4.4</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Workout and exercise list views</h1>
                
            
            <article>
                
<p class="calibre3">Now, we need to implement the list views that have so far been empty!</p>
<div class="packt_infobox">
<p class="calibre20">In this section, we will be updating the code from <kbd class="calibre24">checkpoint 4.3</kbd> with what is found in <kbd class="calibre24">checkpoint 4.4</kbd>. So if you are coding along with us, simply follow the steps laid out in this section. If you want to see the finished code, then just copy the files from <kbd class="calibre24">checkpoint 4.4</kbd> into your solution.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Workouts list views</h1>
                
            
            <article>
                
<p class="calibre3">To get the view working, open <kbd class="calibre13">workouts.component.html</kbd> and add the following markup:</p>
<pre class="calibre19">&lt;div class="row"&gt;<br class="title-page-name"/>    &lt;div&gt;<br class="title-page-name"/>        &lt;abe-left-nav-main&gt;&lt;/abe-left-nav-main&gt;<br class="title-page-name"/>    &lt;/div&gt;<br class="title-page-name"/>    &lt;div class="col-sm-10 builder-content"&gt;<br class="title-page-name"/>        &lt;h1 class="text-center"&gt;Workouts&lt;/h1&gt;<br class="title-page-name"/>        &lt;div *ngFor="let workout of workoutList|orderBy:'title'" class="workout tile" (click)="onSelect(workout)"&gt;<br class="title-page-name"/>          &lt;div class="title"&gt;{{workout.title}}&lt;/div&gt;<br class="title-page-name"/>          &lt;div class="stats"&gt;<br class="title-page-name"/>              &lt;span class="duration" title="Duration"&gt;&lt;span class="ion-md-time"&gt;&lt;/span&gt; - {{(workout.totalWorkoutDuration? workout.totalWorkoutDuration(): 0)|secondsToTime}}&lt;/span&gt;<br class="title-page-name"/>              &lt;span class="float-right" title="Exercise Count"&gt;&lt;span class="ion-md-list"&gt;&lt;/span&gt; - {{workout.exercises.length}}&lt;/span&gt;<br class="title-page-name"/>          &lt;/div&gt;<br class="title-page-name"/>      &lt;/div&gt;<br class="title-page-name"/>    &lt;/div&gt;<br class="title-page-name"/>  &lt;/div&gt;</pre>
<p class="calibre3">We are using one of the Angular core directives, <kbd class="calibre13">ngFor</kbd>, to loop through the list of workouts and display them in a list on the page. We add the <kbd class="calibre13">*</kbd> sign in front of <kbd class="calibre13">ngFor</kbd> to identify it as an Angular directive. Using a <kbd class="calibre13">let</kbd> statement, we assign <kbd class="calibre13">workout</kbd> as a local variable that we use to iterate through the workout list and identify the values to be displayed for each workout (for example, <kbd class="calibre13">workout.title</kbd>). We then use one of our custom pipes, <kbd class="calibre13">orderBy</kbd>, to display a list of workouts in alphabetical order by title. We are also using another custom pipe, <kbd class="calibre13">secondsToTime</kbd>, to format the time displayed for the total workout duration.</p>
<div class="packt_infobox">If you are coding along with us, you will need to move the <kbd class="calibre24">secondsToTime</kbd> pipe into the shared folder and include it in the <kbd class="calibre24">SharedModule</kbd>. Then, add <kbd class="calibre24">SharedModule</kbd> to <kbd class="calibre24">WorkoutBuilderModule</kbd> as an additional import. That change has already been made in <kbd class="calibre24">checkpoint 4.4</kbd> in the GitHub repository.</div>
<p class="calibre3">Finally, we bind the click event to the following <kbd class="calibre13">onSelect</kbd> method that we add to our component:</p>
<pre class="calibre19"> onSelect(workout: WorkoutPlan) { 
     this.router.navigate( ['/builder/workout', workout.name] ); 
 }  </pre>
<p class="calibre3">This sets up navigation to the workout details page. This navigation happens when we click on an item in the workout list. The selected workout name is passed as part of the route<kbd class="calibre13">/URL</kbd> to the workout detail page.</p>
<p class="calibre3">Go ahead and refresh the builder page (<kbd class="calibre13">/builder/workouts</kbd>); one workout is listed, the 7 Minute Workout. Click on the tile for that workout. You'll be taken to the <span class="calibre6">Workout</span> screen and the workout name, <kbd class="calibre13">7MinWorkout</kbd>, will appear at the end of the URL:</p>
<div class="packt_figure"><img src="../images/00040.jpeg" class="calibre61"/></div>
<div class="packt_figref">The Workout screen</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Exercises list views</h1>
                
            
            <article>
                
<p class="calibre3">We are going to follow the same approach for the <kbd class="calibre13">Exercises</kbd> list view as we did for the <kbd class="calibre13">Workouts</kbd> list view, except that in this case, we will actually be implementing two views: one for the <kbd class="calibre13">Exercises</kbd> component (which will display in the main content area when a user navigates to that component) and one for the <kbd class="calibre13">LeftNavExercisesComponent</kbd> exercises context menu (which will display when the user navigates to the <kbd class="calibre13">Workouts</kbd> component to create or edit a workout).</p>
<p class="calibre3">For the <kbd class="calibre13">Exercises</kbd> component, we will follow an approach that is almost identical to what we did to display a list of workouts in the <kbd class="calibre13">Workouts</kbd> component. So, we won't show that code here. Just add the files for <kbd class="calibre13">exercises.component.ts</kbd> and <kbd class="calibre13">exercises.component.html</kbd> from <kbd class="calibre13">checkpoint 4.4</kbd>.</p>
<p class="calibre3">When you are done copying the files, click on the <span class="calibre6">Exercises</span> link in the left navigation to load the 12 exercises that you have already configured in <kbd class="calibre13">WorkoutService</kbd>.</p>
<p class="calibre3">As with the <kbd class="calibre13">Workouts</kbd> list, this sets up the navigation to the exercise detail page. Clicking on an item in the exercises list takes us to the exercise detail page. The selected exercise name is passed as part of the route<kbd class="calibre13">/URL</kbd> to the exercise detail page.</p>
<p class="calibre3">In the final list view, we will add a list of exercises that will display in the left context menu for the <em class="calibre17">Workout Builder</em> screen. This view is loaded in the left navigation when we create or edit a workout. Using Angular's component-based approach, we will update the <kbd class="calibre13">leftNavExercisesComponent</kbd> and its related view to provide this functionality. Again we won't show that code here. Just add the files for <kbd class="calibre13">left-nav-exercises.component.ts</kbd> and <kbd class="calibre13">left-nav-exercises.component.html</kbd> from the <kbd class="calibre13">trainer/src/app/navigation</kbd> folder in <kbd class="calibre13">checkpoint 4.4</kbd>.</p>
<p class="calibre3">Once you are done copying those files, click on the <span class="calibre6">New Workout</span> button on the sub-navigation menu in the <em class="calibre17">Workout Builder</em> and you will now see a list of exercises displayed in the left navigation menu—exercises that we have already configured in <kbd class="calibre13">WorkoutService</kbd>.</p>
<p class="calibre3">Time to add the ability to load, save, and update exercise/workout data!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building a workout</h1>
                
            
            <article>
                
<p class="calibre3">The core functionality <em class="calibre17">Personal Trainer</em> provides centers around workout and exercise building. Everything is there to support these two functions. In this section, we focus on building and editing workouts using Angular.</p>
<p class="calibre3">The <kbd class="calibre13">WorkoutPlan</kbd> model has already been defined, so we are aware of the elements that constitute a workout. The <em class="calibre17">Workout Builder</em> page facilitates user input and lets us build/persist workout data.</p>
<p class="calibre3">Once complete, the <em class="calibre17">Workout Builder</em> page will look like this:</p>
<div class="packt_figure"><img src="../images/00041.jpeg" class="calibre28"/></div>
<p class="calibre3">The page has a left navigation that lists all the exercises that can be added to the workout. Clicking on the arrow icon on the right adds the exercise to the end of the workout.</p>
<p class="calibre3">The center area is designated for workout building. It consists of exercise tiles laid out in order from top to bottom and a form that allows the user to provide other details about the workout such as name, title, description, and rest duration.</p>
<p class="calibre3">This page operates in two modes:</p>
<ul class="calibre11">
<li class="calibre12"><span>Create</span>/<span>New</span>: This mode is used for creating a new workout. The URL is <kbd class="calibre13">#/ builder/workout/new</kbd>.</li>
<li class="calibre12"><span>Edit</span>: This mode is used for editing the existing workout. The URL is <kbd class="calibre13">#/ builder/workout/:id</kbd>, where <kbd class="calibre13">:id</kbd> maps to the name of the workout.</li>
</ul>
<p class="calibre3">With this understanding of the page elements and layout, it's time to build each of these elements. We will start with left nav (navigation).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Finishing left nav</h1>
                
            
            <article>
                
<p class="calibre3">At the end of the previous section, we updated the left navigation view for the <kbd class="calibre13">Workout</kbd> component to show a list of exercises. Our intention was to let the user click on an arrow next to an exercise to add it to the workout. At the time, we deferred implementing the <kbd class="calibre13">addExercise</kbd> method in the <kbd class="calibre13">LeftNavExercisesComponent</kbd> that was bound to that click event. Now, we will go ahead and do that.</p>
<p class="calibre3">We have a couple of options here. The <kbd class="calibre13">LeftNavExercisesComponent</kbd> is a child component of the <kbd class="calibre13">WorkoutComponent</kbd>, so we can implement child/parent inter-component communication to accomplish that. We covered this technique in the previous chapter while working on <em class="calibre17">7 Minute Workout</em>.</p>
<p class="calibre3">However, adding an exercise to the workout is part of a larger process of building the workout and using child/parent inter-component communication would make the implementation of the <kbd class="calibre13">AddExercise</kbd> method differ from the other functionality that we will be adding going forward.</p>
<p class="calibre3">For this reason, it makes more sense to follow another approach for sharing data, one that we can use consistently throughout the process of building a workout. That approach involves using a service. As we get into adding the other functionality for creating an actual workout, such as save/update logic and implementing the other relevant components, the benefits of going down the service route will become increasingly clear.</p>
<p class="calibre3">So, we introduce a new service into the picture: <kbd class="calibre13">WorkoutBuilderService</kbd>. The ultimate aim of <kbd class="calibre13">WorkoutBuilderService</kbd> service is to coordinate between <kbd class="calibre13">WorkoutService</kbd> (which retrieves and persists the workout) and the components (such as <kbd class="calibre13">LeftNavExercisesComponent</kbd> and others we will add later), while the workout is being built, hence reducing the amount of code in <kbd class="calibre13">WorkoutComponent</kbd> to the bare minimum.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding WorkoutBuilderService</h1>
                
            
            <article>
                
<p class="calibre3"><kbd class="calibre13">WorkoutBuilderService</kbd> monitors the state of the workout that a user of the application is building. It:</p>
<ul class="calibre11">
<li class="calibre12">Tracks the current workout</li>
<li class="calibre12">Creates a new workout</li>
<li class="calibre12">Loads the existing workout</li>
<li class="calibre12">Saves the workout</li>
</ul>
<p class="calibre3">Copy <kbd class="calibre13">workout-builder-service.ts</kbd> from the <kbd class="calibre13">workout-builder/builder-services</kbd> folder under <kbd class="calibre13">trainer/src/app</kbd> in <kbd class="calibre13">checkpoint 4.5</kbd>.</p>
<div class="packt_infobox">
<p class="calibre20">The code is also available for everyone to download on GitHub at <span class="calibre22"><a href="https://github.com/chandermani/angular6byexample" class="calibre21">https://github.com/chandermani/angular6byexample</a></span>. Checkpoints are implemented as branches in GitHub. The branch to download is as follows: <kbd class="calibre24">GitHub Branch: checkpoint4.5</kbd> (folder—<kbd class="calibre24">trainer</kbd>). If you are not using Git, download the snapshot of <kbd class="calibre24">Checkpoint 4.5</kbd> (a ZIP file) from the following GitHub location: <a href="https://github.com/chandermani/angular6byexample/archive/checkpoint4.5.zip" class="calibre21">https://github.com/chandermani/angular6byexample/archive/checkpoint4.5.zip</a>. Refer to the <kbd class="calibre24">README.md</kbd> file in the <kbd class="calibre24">trainer</kbd> folder when setting up the snapshot for the first time. Again, if you are working along with us as we build the application, be sure to update the <kbd class="calibre24">styles.css</kbd> file, which we are not discussing here.</p>
</div>
<p class="calibre3">While we normally make services available application-wide,  <kbd class="calibre13">WorkoutBuilderService</kbd> will only be used in the <em class="calibre17">Workout Builder</em> feature. Therefore, instead of registering it with the providers in <kbd class="calibre13">AppModule</kbd>, we have registered it in the provider array of <kbd class="calibre13">WorkoutBuilderModule</kbd> as follows (after adding it as an import at the top of the file):</p>
<pre class="calibre19">@NgModule({<br class="title-page-name"/>....<br class="title-page-name"/>  <strong class="calibre1">providers: [WorkoutBuilderService]</strong><br class="title-page-name"/>})</pre>
<p class="calibre3">Adding it as a provider here means that it will only be loaded when the <em class="calibre17">Workout Builder</em> feature is being accessed and it cannot be reached outside this module. This means that it can be evolved independently of other modules in the application and can be modified without affecting other parts of the application.</p>
<p class="calibre3">Let's look at some of the relevant parts of the service.</p>
<p class="calibre3"><kbd class="calibre13">WorkoutBuilderService</kbd> needs the type definitions for <kbd class="calibre13">WorkoutPlan</kbd>, <kbd class="calibre13">ExercisePlan</kbd>, and <kbd class="calibre13">WorkoutService</kbd>, so we import these into the component:</p>
<pre class="calibre19">import { WorkoutPlan, ExercisePlan } from '../../core/model';<br class="title-page-name"/>import { WorkoutService } from '../../core/workout.service';</pre>
<p class="calibre3"><kbd class="calibre13">WorkoutBuilderService</kbd> has a dependency on <kbd class="calibre13">WorkoutService</kbd> to provide persistence and querying capabilities. We resolve this dependency by injecting <kbd class="calibre13">WorkoutService</kbd> into the constructor for <kbd class="calibre13">WorkoutBuilderService</kbd><strong class="calibre5">:</strong></p>
<pre class="calibre19"> constructor(public workoutService: WorkoutService) {}</pre>
<p class="calibre3"><kbd class="calibre13">WorkoutBuilderService</kbd> also needs to track the workout being built. We use the <kbd class="calibre13">buildingWorkout</kbd> property for this. The tracking starts when we call the <kbd class="calibre13">startBuilding</kbd> method on the service:</p>
<pre class="calibre19">startBuilding(name: string){ 
    if(name){ 
        this.buildingWorkout = this.workoutService.getWorkout(name) 
        this.newWorkout = false; 
    }else{ 
        this.buildingWorkout = new WorkoutPlan("", "", 30, []); 
        this.newWorkout = true; 
    } 
    return this.buildingWorkout; 
} </pre>
<p class="calibre3">The basic idea behind this tracking function is to set up a <kbd class="calibre13">WorkoutPlan</kbd> object (<kbd class="calibre13">buildingWorkout</kbd>) that will be made available to components to manipulate the workout details. The <kbd class="calibre13">startBuilding</kbd> method takes the workout name as a parameter. If the name is not provided, it implies we are creating a new workout, and hence a new <kbd class="calibre13">WorkoutPlan</kbd> object is created and assigned; if not, we load the workout details by calling <kbd class="calibre13">WorkoutService.getWorkout(name)</kbd>. In any case, the <kbd class="calibre13">buildingWorkout</kbd> object has the workout being worked on.</p>
<p class="calibre3">The <kbd class="calibre13">newWorkout</kbd> object signifies whether the workout is new or an existing one. It is used to differentiate between save and update situations when the <kbd class="calibre13">save</kbd> method on this service is called.</p>
<p class="calibre3">The rest of the methods, <kbd class="calibre13">removeExercise</kbd>, <kbd class="calibre13">addExercise</kbd>, and <kbd class="calibre13">moveExerciseTo</kbd>, are self-explanatory and affect the exercise list that is part of the workout (<kbd class="calibre13">buildingWorkout</kbd>).</p>
<p class="calibre3"><kbd class="calibre13">WorkoutBuilderService</kbd> is calling a new method, <kbd class="calibre13">getWorkout</kbd>, on <kbd class="calibre13">WorkoutService</kbd>, which we have not added yet. Go ahead and copy the <kbd class="calibre13">getWorkout</kbd> implementation from the <kbd class="calibre13">workout-service.ts</kbd> file in the <kbd class="calibre13">services</kbd> folder under <kbd class="calibre13">trainer/src</kbd> in <kbd class="calibre13">checkpoint 4.5</kbd>. We will not dwell on the new service code as the implementation is quite simple.</p>
<p class="calibre3">Let's get back to left nav and implement the remaining functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding exercises using ExerciseNav</h1>
                
            
            <article>
                
<p class="calibre3">To add exercises to the workout we are building, we just need to import <kbd class="calibre13">WorkoutBuilderService</kbd> and <kbd class="calibre13">ExercisePlan</kbd>, inject <kbd class="calibre13">WorkoutBuilderService</kbd> into the <kbd class="calibre13">LeftNavExercisesComponent</kbd>, and call its <kbd class="calibre13">addExercise</kbd> method, passing the selected exercise as a parameter:</p>
<pre class="calibre19">constructor( 
    public workoutService:WorkoutService, 
<strong class="calibre1">    public workoutBuilderService:WorkoutBuilderService) {}</strong> 
. . . 
addExercise(exercise:Exercise) { 
<strong class="calibre1">    this.workoutBuilderService.addExercise(new ExercisePlan(exercise, 30));</strong> 
} </pre>
<p class="calibre3">Internally, <kbd class="calibre13">WorkoutBuilderService.addExercise</kbd> updates the <kbd class="calibre13">buildingWorkout</kbd> model data with the new exercise.</p>
<p class="calibre3">The preceding implementation is a classic case of sharing data between independent components. The shared service exposes the data in a controlled manner to any component that requests it. While sharing data, it is always a good practice to expose the state/data using methods instead of directly exposing the data object. We can see that in our component and service implementations too. <kbd class="calibre13">LeftNavExercisesComponent</kbd> does not update the workout data directly; in fact, it does not have direct access to the workout being built. Instead, it relies upon the service method, <kbd class="calibre13">addExercise</kbd>, to change the current workout's exercise list.</p>
<p class="calibre3">Since the service is shared, there are pitfalls to be aware of. As services are injectable through the system, we cannot stop any component from taking dependency on any service and calling its functions in an inconsistent manner, leading to undesired results or bugs. For example, <kbd class="calibre13">WorkoutBuilderService</kbd> needs to be initialized by calling <kbd class="calibre13">startBuilding</kbd> before <kbd class="calibre13">addExercise</kbd> is called. What happens if a component calls <kbd class="calibre13">addExercise</kbd> before the initialization takes place?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing the Workout component</h1>
                
            
            <article>
                
<p class="calibre3">The <kbd class="calibre13">WorkoutComponent</kbd> is responsible for managing a workout. This includes creating, editing, and viewing the workout. Due to the introduction of <kbd class="calibre13">WorkoutBuilderService</kbd>, the overall complexity of this component will be reduced. Other than the primary responsibility of integrating with, exposing, and interacting with its template view, we will delegate most of the other work to <kbd class="calibre13">WorkoutBuilderService</kbd>.</p>
<p class="calibre3">The <kbd class="calibre13">WorkoutComponent</kbd> is associated with two <kbd class="calibre13">routes/views</kbd>, namely <kbd class="calibre13">/builder/workout/new</kbd> and <kbd class="calibre13">/builder/workout/:id</kbd>. These routes handle both creating and editing workout scenarios. The first job of the component is to load or create the workout that it needs to manipulate.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Route parameters</h1>
                
            
            <article>
                
<p class="calibre3">But before we get to building out the <kbd class="calibre13">WorkoutComponent</kbd>and its associated view, we need to touch briefly on the navigation that brings a user to the screen for that component. This component handles both creating and editing workout scenarios. The first job of the component is to load or create the workout that it needs to manipulate. We plan to use Angular's routing framework to pass the necessary data to the component, so that it will know whether it is editing an existing workout or creating a new one, and in the case of an existing workout, which component it should be editing.</p>
<p class="calibre3">How is this done? The <kbd class="calibre13">WorkoutComponent</kbd> is associated with two routes, namely <kbd class="calibre13">/builder/workout/new</kbd> and <kbd class="calibre13">/builder/workout/:id</kbd>. The difference in these two routes lies in what is at the end of these routes; in one case, it is <kbd class="calibre13">/new</kbd>, and in the other,<kbd class="calibre13"> /:id</kbd>. These are called <strong class="calibre5">route parameters.</strong> The <kbd class="calibre13">:id</kbd> in the second route is a token for a route parameter. The router will convert the token to the ID for the workout component. As we saw earlier, this means that the URL that will be passed to the component in the case of <em class="calibre17">7 Minute Workout</em> will be <kbd class="calibre13">/builder/workout/7MinuteWorkout</kbd>.</p>
<p class="calibre3">How do we know that this workout name is the right parameter for the ID? As you recall, when we set up the event for handling a click on the <span class="calibre6">Workout</span> tiles on the <span class="calibre6">Workouts</span> screen that takes us to the <span class="calibre6">Workout</span> screen, we designated the workout name as the parameter for the ID, like so:</p>
<pre class="calibre19"> onSelect(workout: WorkoutPlan) { 
     this.router.navigate( ['./builder/workout', workout.name] ); 
 }  </pre>
<p class="calibre3">Here, we are constructing the route using the programmatic interface for the router (we covered routing in detail in the previous chapter, so we won't go over that again here). The <kbd class="calibre13">router.navigate</kbd> method accepts an array. This is called the <strong class="calibre5">link parameters array</strong>. The first item in the array is the path of the route, and the second is a route parameter that specifies the ID of the workout. In this case, we set the <kbd class="calibre13">id</kbd> parameter to the workout name. From our discussion of routing in the previous chapter, we know that we can also construct the same type of URL as part of a router link or simply enter it in the browser to get to the <span class="calibre6">Workouts</span> screen and edit a particular workout.</p>
<p class="calibre3">The other of the two routes ends with <kbd class="calibre13">/new</kbd>. Since this route does not have a <kbd class="calibre13">token</kbd> parameter, the router will simply pass the URL unmodified to the <kbd class="calibre13">WorkoutComponent</kbd>. The <kbd class="calibre13">WorkoutComponent</kbd> will then need to parse the incoming URL to identify that it should be creating a new component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Route guards</h1>
                
            
            <article>
                
<p class="calibre3">But before the link takes the user to the <kbd class="calibre13">WorkoutComponent</kbd>, there is another step along the way that we need to consider. The possibility always exists that the ID that is passed in the URL for editing a workout could be incorrect or missing. In those cases, we do not want the component to load, but instead we want to have the user redirected to another page or back to where they came from.</p>
<p class="calibre3">Angular offers a way to accomplish this result with <strong class="calibre5">route guards</strong>. As the name implies, route guards <strong class="calibre5">provide a way to prevent navigation to a route</strong>. A route guard can be used to inject custom logic that can do things such as check authorization, load data, and make other verifications to determine whether the navigation to the component needs to be canceled or not. And all of this is done before the component loads so it is never seen if the routing is canceled.</p>
<p class="calibre3">Angular offers several route guards, including <kbd class="calibre13">CanActivate</kbd>, <kbd class="calibre13">CanActivateChild</kbd>, <kbd class="calibre13">CanDeActivate</kbd>, <kbd class="calibre13">Resolve</kbd>, and <kbd class="calibre13">CanLoad</kbd><strong class="calibre5">.</strong> At this point, we are interested in the <kbd class="calibre13">Resolve</kbd> route guard<strong class="calibre5">. </strong>The <kbd class="calibre13">Resolve</kbd> guard will allow us not only to check for the existence of a workout, but also to load the data associated with a workout before loading the <kbd class="calibre13">WorkoutComponent</kbd>. The advantage of doing the latter is that we avoid the necessity of checking to make sure the data is loaded in the <kbd class="calibre13">WorkoutComponent</kbd> and it eliminates adding conditional logic throughout its component template to make sure that the data is there when it is rendered.  This will be especially useful when in the next chapter when we start using <kbd class="calibre13">observables</kbd> where we must wait for the observable to complete before we are guaranteed of having the data that it will provide. The <kbd class="calibre13">Resolve</kbd> guard will handle waiting for the observable to complete, which means that the <kbd class="calibre13">WorkoutComponent</kbd> will be guaranteed to have the data that it needs before it loads.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing the resolve route guard</h1>
                
            
            <article>
                
<p class="calibre3">The <kbd class="calibre13">Resolve</kbd> guard allows us to prefetch the data for a workout. In our case, what we want to do is use <kbd class="calibre13">Resolve</kbd> to check the validity of any ID that is passed for an existing workout. Specifically, we will run a check on that ID by making a call to the <kbd class="calibre13">WorkoutBuilderService</kbd> to retrieve the Workout Plan and see if it exists. If it exists, we will load the data associated with the Workout Plan so that it is available to the <kbd class="calibre13">WorkoutComponent</kbd>; if not we will redirect back to the Workouts screen. </p>
<p class="calibre3">Copy <kbd class="calibre13">workout.resolver.ts</kbd> <span class="calibre6">from the <kbd class="calibre13">workout-builder/workout</kbd> folder under <kbd class="calibre13">trainer/src/app/workout</kbd> in</span> <kbd class="calibre13">checkpoint 4.5</kbd> and you will see the following code:</p>
<pre class="calibre19">import 'rxjs/add/operator/map';<br class="title-page-name"/>import 'rxjs/add/operator/take';<br class="title-page-name"/>import { Injectable } from '@angular/core';<br class="title-page-name"/>import { Observable } from 'rxjs/Observable';<br class="title-page-name"/>import { Router, Resolve, RouterStateSnapshot,<br class="title-page-name"/>         ActivatedRouteSnapshot } from '@angular/router';<br class="title-page-name"/>import { WorkoutPlan } from '../../core/model';<br class="title-page-name"/>import { WorkoutBuilderService } from '../builder-services/workout-builder.service';<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>@Injectable()<br class="title-page-name"/>export class WorkoutResolver implements Resolve&lt;WorkoutPlan&gt; {<br class="title-page-name"/>  public workout: WorkoutPlan;<br class="title-page-name"/><br class="title-page-name"/>  constructor(<br class="title-page-name"/>    public workoutBuilderService: WorkoutBuilderService,<br class="title-page-name"/>    public router: Router) {}<br class="title-page-name"/><br class="title-page-name"/>  resolve(<br class="title-page-name"/>    route: ActivatedRouteSnapshot,<br class="title-page-name"/>    state: RouterStateSnapshot): WorkoutPlan {<br class="title-page-name"/>    let workoutName = route.paramMap.get('id');<br class="title-page-name"/><br class="title-page-name"/>    if (!workoutName) {<br class="title-page-name"/>        workoutName = '';<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    this.workout = this.workoutBuilderService.startBuilding(workoutName);<br class="title-page-name"/><br class="title-page-name"/>    if (this.workout) {<br class="title-page-name"/>        return this.workout;<br class="title-page-name"/>    } else { // workoutName not found<br class="title-page-name"/>        this.router.navigate(['/builder/workouts']);<br class="title-page-name"/>        return null;<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre3">As you can see, the <kbd class="calibre13">WorkoutResolver</kbd> is an injectable class that implements the <kbd class="calibre13">Resolve</kbd> interface.  The<span class="calibre6"> code injects the </span><kbd class="calibre13">WorkoutBuilderService</kbd><span class="calibre6"> and <kbd class="calibre13">Router</kbd> into the class and implements </span>the interface with the <kbd class="calibre13">resolve</kbd> method. The <kbd class="calibre13">resolve</kbd> method accepts two parameters; <kbd class="calibre13">ActivatedRouteSnapshot</kbd> and <kbd class="calibre13">RouterStateSnapshot</kbd>. In this case, we are only interested in the first of these two parameters, <kbd class="calibre13">ActivatedRouteSnapshot</kbd>.  It contains a <kbd class="calibre13">paramMap</kbd> from which we extract the ID parameter for the route.</p>
<p class="calibre3"><span class="calibre6">The </span><kbd class="calibre13">resolve</kbd><span class="calibre6"> method then calls the </span><kbd class="calibre13">startBuilding</kbd><span class="calibre6"> method of</span> <kbd class="calibre13">WorkoutBuildingService</kbd><span class="calibre6"> using the parameter supplied in the route. If the workout exists, then </span><kbd class="calibre13">resolve</kbd><span class="calibre6"> returns the data and the navigation proceeds; if not, it re-routes the user to the workouts page and returns false. </span><span class="calibre6">If <kbd class="calibre13">new</kbd> is passed as an ID,</span> <kbd class="calibre13">WorkoutBuilderService</kbd><span class="calibre6"> will load a new workout and the </span><kbd class="calibre13">Resolve</kbd><span class="calibre6"> guard will allow navigation to proceed to the </span><kbd class="calibre13">WorkoutComponent</kbd><span class="calibre6">.</span></p>
<p class="calibre3">The <kbd class="calibre13">resolve</kbd> method can return a <kbd class="calibre13">Promise</kbd> , an <kbd class="calibre13">Observable,</kbd> or a synchronous value. If we return an <kbd class="calibre13">Observable</kbd>,  we will need to make sure that the <kbd class="calibre13">Observable</kbd> completes before proceeding with navigation. In this case, however, we are making a synchronous call to a local in-memory data store, so we are just returning a value.</p>
<p class="calibre3">To complete the implementation of the <kbd class="calibre13">WorkoutResolver</kbd>, first make sure to import and add it to <kbd class="calibre13">WorkoutBuilderModule</kbd> as a provider:</p>
<pre class="calibre19">....<br class="title-page-name"/><strong class="calibre1">import { WorkoutResolver } from './workout/workout.resolver';</strong><br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/>....<br class="title-page-name"/>  providers: [WorkoutBuilderService, <strong class="calibre1">WorkoutResolver</strong>]<br class="title-page-name"/>})<br class="title-page-name"/>....</pre>
<p class="calibre3">Then, add it to the route configuration for <kbd class="calibre13">WorkoutComponent</kbd> by updating <kbd class="calibre13">workout-builder-routing.module.ts</kbd> as follows:</p>
<pre class="calibre19">....<br class="title-page-name"/><strong class="calibre1">import { WorkoutResolver } from './workout/workout.resolver';</strong><br class="title-page-name"/>....<br class="title-page-name"/>const routes: Routes = [<br class="title-page-name"/>  {<br class="title-page-name"/>    path: '',<br class="title-page-name"/>    component: WorkoutBuilderComponent,<br class="title-page-name"/>    children: [<br class="title-page-name"/>         {path: '', pathMatch: 'full', redirectTo: 'workouts'},<br class="title-page-name"/>         {path: 'workouts', component: WorkoutsComponent },<br class="title-page-name"/><strong class="calibre1">         {path: 'workout/new', component: WorkoutComponent, resolve: { workout: WorkoutResolver} },</strong><br class="title-page-name"/><strong class="calibre1">         {path: 'workout/:id', component: WorkoutComponent, resolve: { workout: WorkoutResolver} },</strong><br class="title-page-name"/>         {path: 'exercises', component: ExercisesComponent},<br class="title-page-name"/>         {path: 'exercise/new', component: ExerciseComponent },<br class="title-page-name"/>         {path: 'exercise/:id', component: ExerciseComponent }<br class="title-page-name"/>    ]<br class="title-page-name"/>  },<br class="title-page-name"/>];</pre>
<p class="calibre3">As you can see, we add <kbd class="calibre13">WorkoutResolver</kbd> to the routing module's imports. Then, we add <kbd class="calibre13">resolve <span>{ workout: WorkoutResolver }</span></kbd> to the end of the route configuration for <kbd class="calibre13">workout/new</kbd> and <kbd class="calibre13">workout/:id</kbd> . This instructs the router to use the <kbd class="calibre13">WorkoutResolver</kbd> resolve method and assign its return value to <kbd class="calibre13">workout</kbd> in the route's data. This configuration means that <kbd class="calibre13">WorkoutResolver</kbd> will be called <span class="calibre6">prior to the router navigating to </span><kbd class="calibre13">WorkoutComponent</kbd> and that the workout data will be available to the <kbd class="calibre13">WorkoutComponent</kbd> when it loads. We'll see how to extract this data in the <kbd class="calibre13">WorkoutComponent</kbd> in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing the Workout component continued...</h1>
                
            
            <article>
                
<p class="calibre3">Now that we have established the routing that takes us to the <kbd class="calibre13">Workout</kbd> component, let's turn to completing its implementation. So, copy the <kbd class="calibre13">workout.component.ts</kbd> file from the <kbd class="calibre13">workout-builder/workout</kbd> folder under <kbd class="calibre13">trainer/src/app</kbd> in <kbd class="calibre13">checkpoint 4.5</kbd>. (Also, copy <kbd class="calibre13">workout-builder.module.ts</kbd> from the <kbd class="calibre13">workout-builder</kbd> folder. We'll discuss the changes in this file a little later when we get to Angular forms.)</p>
<p class="calibre3">Open <kbd class="calibre13">workout.component.ts</kbd> and you'll see that we have added a constructor that injects <kbd class="calibre13">ActivatedRoute</kbd> and <kbd class="calibre13">WorkoutBuilderService</kbd>:</p>
<pre class="calibre19">    constructor( 
    public route: ActivatedRoute, 
    public workoutBuilderService:WorkoutBuilderService){ } </pre>
<p class="calibre3">In addition, we have added the following <kbd class="calibre13">ngOnInit</kbd> method:</p>
<pre class="calibre19">  ngOnInit() {<br class="title-page-name"/>      this.sub = this.route.data<br class="title-page-name"/>          .subscribe(<br class="title-page-name"/>            (data: { workout: WorkoutPlan }) =&gt; {<br class="title-page-name"/>              this.workout = data.workout;<br class="title-page-name"/>            }<br class="title-page-name"/>          );<br class="title-page-name"/>  }</pre>
<p class="calibre3">The method subscribes to the <kbd class="calibre13">route</kbd> and extracts the <kbd class="calibre13">workout</kbd> from the <kbd class="calibre13">route.data</kbd>. There is no need to check the workout exists because we have already done that in the <kbd class="calibre13">WorkoutResolver</kbd>.</p>
<div class="packt_infobox">
<p class="calibre20">We are subscribing to the <kbd class="calibre24">route.data</kbd> because as an <kbd class="calibre24">ActivatedRoute</kbd>, the <kbd class="calibre24">route</kbd> exposes its <kbd class="calibre24">data</kbd> as an  <kbd class="calibre24">Observable</kbd>, which can change during the lifetime of the component. This gives us the ability to reuse the same component instance with different parameters, even though the <kbd class="calibre24">OnInit</kbd> life cycle event for that component is called only once. We'll cover <kbd class="calibre24">Observables</kbd> in detail in the next chapter.</p>
</div>
<p class="calibre3">In addition to this code, we have also added a series of methods to the <kbd class="calibre13">Workout Component</kbd> for adding, removing,  and moving a workout. These methods all call corresponding methods on the <kbd class="calibre13">WorkoutBuilderService</kbd> and we will not review them in detail here. We've also added an array of <kbd class="calibre13">durations</kbd> for populating the duration drop-down list.</p>
<p class="calibre3">For now, this is enough for the <strong class="calibre5">component</strong> class implementation. Let's update the associated <kbd class="calibre13">Workout</kbd> template.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing the Workout template</h1>
                
            
            <article>
                
<p class="calibre3">Now, copy the <kbd class="calibre13">workout.component.html</kbd> files from the <kbd class="calibre13">workout-builder/workout</kbd> folder under <kbd class="calibre13">trainer/src/app</kbd> in <kbd class="calibre13">checkpoint 4.5</kbd>. Run the app, navigate to <kbd class="calibre13">/builder/workouts</kbd>, and double-click on the <em class="calibre17">7 Minute Workout</em> tile. This should load the <em class="calibre17">7 Minute Workout</em> details with a view similar to the one shown at the start of the <em class="calibre17">Building a workout</em> section.</p>
<div class="packt_infobox">In the event of any problem, you can refer to the <kbd class="calibre24">checkpoint4.5</kbd> code in the <kbd class="calibre24">GitHub repository: Branch: checkpoint4.5</kbd> (folder - <kbd class="calibre24">trainer</kbd>).</div>
<p class="calibre3">We will be dedicating a lot of time to this view, so let's understand some specifics here.</p>
<p class="calibre3">The exercise list div (<kbd class="calibre13">id="exercise-list"</kbd>) lists the exercises that are part of the workout in order. We display them as top-to-bottom tiles in the left part of the content area. Functionally, this template has:</p>
<ul class="calibre11">
<li class="calibre12">The <span>Delete</span> button to delete the exercise</li>
<li class="calibre12">Reorder buttons to move the exercise up and down the list, as well as to the top and bottom</li>
</ul>
<p class="calibre3">We use <kbd class="calibre13">ngFor</kbd> to iterate over the list of exercises and display them:</p>
<pre class="calibre19">&lt;div *ngFor="let exercisePlan of workout.exercises; let i=index" class="exercise-item"&gt; </pre>
<p class="calibre3">You will notice that we are using the <kbd class="calibre13">*</kbd> asterisk in front of <kbd class="calibre13">ngFor</kbd>,  which is shorthand for the <kbd class="calibre13">&lt;template&gt;</kbd> tag. We are also using <kbd class="calibre13">let</kbd> to set two local variables: <kbd class="calibre13">exerisePlan</kbd> to identify an item in the list of exercises and <kbd class="calibre13">i</kbd> to set up an index value that we will use to show a number for the exercises as they are displayed on the screen. We will also use the index value to manage reordering and deleting exercises from the list.</p>
<p class="calibre3">The second div element for workout data (<kbd class="calibre13">id="workout-data"</kbd>) contains the HTML input element for details such as name, title, and rest duration, and a button to save workout changes.</p>
<p class="calibre3">The complete list has been wrapped inside the HTML form element so that we can make use of the form-related capabilities that Angular provides. So, what are these capabilities?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Angular forms</h1>
                
            
            <article>
                
<p class="calibre3">Forms are such an integral part of HTML development that any framework that targets client-side development just cannot ignore them. Angular provides a small but well-defined set of constructs that make standard form-based operations easier.</p>
<p class="calibre3">If we think carefully, any form of interaction boils down to:</p>
<ul class="calibre11">
<li class="calibre12">Allowing user inputs</li>
<li class="calibre12">Validating those inputs against business rules</li>
<li class="calibre12">Submitting the data to the backend server</li>
</ul>
<p class="calibre3">Angular has something to offer for all the preceding use cases.</p>
<p class="calibre3">For user input, it allows us to create two-way bindings between the form input elements and the underlying model, hence avoiding any boilerplate code that we may have to write for model input synchronization.</p>
<p class="calibre3">It also provides constructs to validate the input before it can be submitted.</p>
<p class="calibre3">Lastly, Angular provides HTTP services for client-server interaction and persisting data to the server. We'll cover those services in <a href="" class="calibre10">Chapter 5</a>, <em class="calibre17">Supporting Server Data Persistence</em>.</p>
<p class="calibre3">Since the first two use cases are our main focus in this chapter, let's learn more about Angular user input and data validation support.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Template-driven and reactive forms</h1>
                
            
            <article>
                
<p class="calibre3">Angular offers two types of forms: <strong class="calibre5">template-driven</strong> and <strong class="calibre5">reactive</strong>. We'll be discussing both types of form in this chapter. Because the Angular team indicates that many of us will primarily use <strong class="calibre5">template-driven forms</strong>, that is what we will start with in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Template-driven forms</h1>
                
            
            <article>
                
<p class="calibre3">As the name suggests, <strong class="calibre5">template-driven forms</strong> place the emphasis on developing a form within an HTML template and handling most of the logic for the form inputs, data validation, saving, and updating in-form directives placed within that template. The result is that very little form-related code is required in the component class that is associated with the form's template.</p>
<p class="calibre3"><strong class="calibre5">Template-driven forms</strong> make heavy use of the <kbd class="calibre13">ngModel</kbd> form directive. We will be discussing it in the next sections. It provides two-way data binding for form controls, which is a nice feature indeed. It allows us to write much less boilerplate code to implement a form. It also helps us to manage the state of the form (such as whether the form controls have changed and whether these changes have been saved). And, it also gives us the ability to easily construct messages that display if the validation requirements for a form control have not been met (for example, a required field not provided, email not in the right format, and so on).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting started</h1>
                
            
            <article>
                
<p class="calibre3">In order to use Angular forms in our <kbd class="calibre13">Workout</kbd> component, we must first add some additional configuration. Open<span class="calibre6">  </span><kbd class="calibre13">workout-buider.module.ts</kbd> <span class="calibre6">from the</span> <kbd class="calibre13">workout-builder</kbd> <span class="calibre6">folder under</span> <kbd class="calibre13">trainer/src/app</kbd> <span class="calibre6">in</span> <kbd class="calibre13">checkpoint 4.5</kbd><span class="calibre6">. You will see that it imports <kbd class="calibre13">FormsModule</kbd>:</span></p>
<pre class="calibre19">....<br class="title-page-name"/><strong class="calibre1">import { FormsModule } from '@angular/forms';</strong><br class="title-page-name"/>....<br class="title-page-name"/>@NgModule({ 
    imports: [ 
        CommonModule, 
<strong class="calibre1">        FormsModule,</strong> 
        SharedModule, 
        workoutBuilderRouting 
    ], </pre>
<p class="calibre3">This brings in all that we will need to implement our form, including:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">NgForm</kbd></li>
<li class="calibre12"><kbd class="calibre13">ngModel</kbd></li>
</ul>
<p class="calibre3">Let's start using these to build our form.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using NgForm</h1>
                
            
            <article>
                
<p class="calibre3">In our template (<kbd class="calibre13">workout.component.html</kbd>), we have added the following <kbd class="calibre13">form</kbd> tag:</p>
<pre class="calibre19">&lt;form #f="ngForm" class="row" name="formWorkout" (ngSubmit)="save(f.form)"&gt;. . . 
&lt;/form&gt; </pre>
<p class="calibre3">Let's take a look at what we have here. One interesting thing is that we are still using a standard <kbd class="calibre13">&lt;form&gt;</kbd> tag and not a special Angular tag. We've also used <kbd class="calibre13">#</kbd> to define a local variable <kbd class="calibre13">f</kbd> to which we have assigned <kbd class="calibre13">ngForm</kbd>. Creating this local variable provides us with the convenience of being able to use it for form-related activity in other places within the form. For example, you can see that we are using it at the end of the opening <kbd class="calibre13">form</kbd> tag in a parameter, <kbd class="calibre13">f.form</kbd>, which is being passed to the <kbd class="calibre13">onSubmit</kbd> event bound to <kbd class="calibre13">(ngSubmit)</kbd>.</p>
<p class="calibre3">That last binding to <kbd class="calibre13">(ngSubmit)</kbd> should tell us that something different is going on here. Even though we did not explicitly add the <kbd class="calibre13">NgForm</kbd> directive, our <kbd class="calibre13">&lt;form&gt;</kbd> now has additional events such as <kbd class="calibre13">ngSubmit</kbd> to which we can bind actions. How did this happen? Well, this was not triggered by our assigning <kbd class="calibre13">ngForm</kbd> to a local variable. Instead, it happened <em class="calibre17">auto-magically</em> because we imported the forms module into <kbd class="calibre13">workout-builder.module.ts</kbd>.</p>
<p class="calibre3">With that import in place, Angular scanned our template for a <kbd class="calibre13">&lt;form&gt;</kbd> tag and wrapped that <kbd class="calibre13">&lt;form&gt;</kbd> tag within an <kbd class="calibre13">NgForm</kbd> directive. The Angular documentation indicates that <kbd class="calibre13">&lt;form&gt;</kbd> elements in the component will be upgraded to use the Angular form system. This is important because it means that various capabilities of  <kbd class="calibre13">NgForm</kbd> are now available to use with the form. These include the <kbd class="calibre13">ngSubmit</kbd> event, which signals when a user has triggered a form submission and provides the ability to validate the entire form before submitting it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">ngModel</h1>
                
            
            <article>
                
<p class="calibre3">One of the fundamental building blocks for template-driven forms is <kbd class="calibre13">ngModel</kbd>, and you will find it being used throughout our form. One of the primary roles of <kbd class="calibre13">ngModel</kbd> is to support two-way binding between user input and an underlying model. With such a setup, changes in the model are reflected in the view, and updates to the view too are reflected back on the model. Most of the other directives that we have covered so far only support one-way binding from models to views. <kbd class="calibre13">ngModel</kbd> goes both ways. But, be aware that it is only available within <kbd class="calibre13">NgForm</kbd> for use with elements that allow user input.</p>
<p class="calibre3">As you know, we already have a model that we are using for the <span class="calibre6">Workout</span> page, <kbd class="calibre13">WorkoutPlan</kbd>. Here is the <kbd class="calibre13">WorkoutPlan</kbd> model from <kbd class="calibre13">model.ts</kbd>:</p>
<pre class="calibre19">export class WorkoutPlan { 
  constructor( 
    public name: string, 
    public title: string, 
    public restBetweenExercise: number, 
    public exercises: ExercisePlan[], 
    public description?: string) { 
  } 
totalWorkoutDuration(): number{ 
 . . . [code calculating the total duration of the workout]. . . 
} </pre>
<p class="calibre3">Note the use of the <kbd class="calibre13">?</kbd> after <kbd class="calibre13">description</kbd>. This means that it is an optional property in our model and is not required to create a <kbd class="calibre13">WorkoutPlan</kbd>. In our form, this will mean that we will not require that a description be entered and everything will work fine without it.</p>
<p class="calibre3">Within the <kbd class="calibre13">WorkoutPlan</kbd> model, we also have a reference to an array made up of instances of another type of model: <kbd class="calibre13">ExercisePlan</kbd>. <kbd class="calibre13">ExercisePlan</kbd> in turn is made up of a number (<kbd class="calibre13">duration</kbd>) and another model (<kbd class="calibre13">Exercise</kbd>), which looks like this:</p>
<pre class="calibre19">export class Exercise {<br class="title-page-name"/>    constructor(<br class="title-page-name"/>        public name: string,<br class="title-page-name"/>        public title: string,<br class="title-page-name"/>        public description: string,<br class="title-page-name"/>        public image: string,<br class="title-page-name"/>        public nameSound?: string,<br class="title-page-name"/>        public procedure?: string,<br class="title-page-name"/>        public videos?: Array&lt;string&gt;) { }<br class="title-page-name"/>}</pre>
<p class="calibre3">The use of these nested classes shows that we can create complex hierarchies of models that can all be data-bound within our form using <kbd class="calibre13">NgModel</kbd>. So throughout the form, whenever we need to update one of the values in a <kbd class="calibre13">WorkoutPlan</kbd> or an <kbd class="calibre13">ExercisePlan</kbd>, we can use <kbd class="calibre13">NgModel</kbd> to do that (the <kbd class="calibre13">WorkoutPlan</kbd> model will be represented by a local variable named <kbd class="calibre13">workout</kbd> in the following examples).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using ngModel with input and textarea</h1>
                
            
            <article>
                
<p class="calibre3">Open <kbd class="calibre13">workout-component.html</kbd> and look for <kbd class="calibre13">ngModel.</kbd> It has been applied to form elements that allow user data input. These include input, textarea, and select. The workout name input setup looks like this:</p>
<pre class="calibre19">&lt;input type="text" name="workoutName" class="form-control" id="workout-name" placeholder="Enter workout name. Must be unique." [(ngModel)]="workout.name"&gt;</pre>
<p class="calibre3">The preceding <kbd class="calibre13">[(ngModel)]</kbd> directive sets up a two-way binding between the input control and the <kbd class="calibre13">workout.name</kbd> model property. The brackets and parentheses should each look familiar. Previously, we used them separately from each other: the <kbd class="calibre13">[]</kbd> brackets for property binding and the <kbd class="calibre13">()</kbd> parentheses for event binding. In the latter case, we usually bound the event to a call to a method in the component associated with the template. You can see an example of this in the form with the button that a user clicks on to remove an exercise:</p>
<pre class="calibre19">&lt;span class="btn float-right trashcan" (click)="removeExercise(exercisePlan)"&gt;&lt;span class="ion-ios-trash-outline"&gt;&lt;/span&gt;&lt;/span&gt;<br class="title-page-name"/> </pre>
<p class="calibre3">Here, the click event is explicitly bound to a method called <kbd class="calibre13">removeExercise</kbd> in our <kbd class="calibre13">Workout</kbd> component class. But for the <kbd class="calibre13">workout.name</kbd> input, we do not have an explicit binding to a method on the component. So what's going on here and how does the update happen without us calling a method on the component? The answer to that question is that the combination <kbd class="calibre13">[( )]</kbd> is shorthand for both binding a model property to the input element and wiring up an event that updates the model.</p>
<p class="calibre3">Put differently, if we reference a model element in our form, <kbd class="calibre13">ngModel</kbd> is smart enough to know that what we want to do is update that element (<kbd class="calibre13">workout.name</kbd> here) when a user enters or changes the data in the input field to which it is bound. Under the hood, Angular creates an update method similar to what we would otherwise have to write ourselves. Nice! This approach keeps us from having to write repetitive code to update our model.</p>
<p class="calibre3">Angular supports most of the HTML5 input types, including text, number, select, radio, and checkbox. This means binding between a model and any of these input types just works out of the box.</p>
<p class="calibre3">The <kbd class="calibre13">textarea</kbd> element works the same as the input:</p>
<pre class="calibre19">&lt;textarea name="description" . . . [(ngModel)]="workout.description"&gt;&lt;/textarea&gt; </pre>
<p class="calibre3">Here, we bind <kbd class="calibre13">textarea</kbd> to <kbd class="calibre13">workout.description</kbd>. Under the hood, <kbd class="calibre13">ngModel</kbd> updates the workout description in our model with every change we type into the text area.</p>
<p class="calibre3">To test out how this works, why don't we verify this binding? Add a model interpolation expression at the end of any of the linked inputs, such as this one:</p>
<pre class="calibre19">&lt;input type="text". . . [(ngModel)]="workout.name"&gt;{{workout.name}} </pre>
<p class="calibre3">Open the <span class="calibre6">Workout</span> page, type something in the input, and see how the interpolation is updated instantaneously. The magic of two-way binding!</p>
<div class="packt_figure"><img class="image-border5" src="../images/00042.jpeg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using ngModel with select</h1>
                
            
            <article>
                
<p class="calibre3">Let's look at how <kbd class="calibre13">select</kbd> has been set up:</p>
<pre class="calibre19">&lt;select . . . name="duration" [(ngModel)]="exercisePlan.duration"&gt; 
    &lt;option *ngFor="let duration of durations" [value]="duration.value"&gt;{{duration.title}}&lt;/option&gt; 
&lt;/select&gt; </pre>
<p class="calibre3">We are using <kbd class="calibre13">ngFor</kbd> here to bind to an array, <kbd class="calibre13">durations</kbd>, which is in the <kbd class="calibre13">Workout</kbd> component class. The array looks like this:</p>
<pre class="calibre19"> [{ title: "15 seconds", value: 15 }, 
  { title: "30 seconds", value: 30 }, ...] </pre>
<p class="calibre3">The <kbd class="calibre13">ngFor</kbd> component will loop over the array and populate the drop-down values with the corresponding values in the array with the title for each item being displayed using interpolation, <kbd class="calibre13">{{duration.title}}</kbd>. And <kbd class="calibre13">[(ngModel)]</kbd> then binds the drop-down selection to the <kbd class="calibre13">exercisePlan.duration</kbd> in the model.</p>
<p class="calibre3">Notice here that we are binding to the nested model: <kbd class="calibre13">ExercisePlan</kbd>. And, we may have multiple exercises to which we will be applying this binding. With that being the case, we have to make use of another Angular form directive—<kbd class="calibre13">ngModelGroup</kbd>—to handle these bindings. <kbd class="calibre13">ngModelGroup</kbd> will allow us to create a nested group within our model that will contain the list of exercises included in the workout and then in turn loop over each exercise to bind its duration to the model.</p>
<p class="calibre3">To start with, we will add <kbd class="calibre13">ngModelGroup</kbd> to the div tag that we have created within the form to hold our list of exercises:</p>
<pre class="calibre19">&lt;div id="exercises-list" class="col-sm-2 exercise-list" <strong class="calibre1">ngModelGroup="exercises"</strong>&gt;</pre>
<p class="calibre3">That takes care of creating the nested list of exercises. Now, we have to handle the individual exercises within that list, and we can do that by adding another <kbd class="calibre13">ngModelGroup</kbd> to the individual divs that contain each exercise:</p>
<pre class="calibre19">&lt;div class="exercise tile" <strong class="calibre1">[ngModelGroup]="i"</strong>&gt;</pre>
<p class="calibre3">Here, we are using the index in our for loop to dynamically create an individual model group for each of our exercises. These model groups will be nested inside the first model group that we created. Temporarily, add the tag <kbd class="calibre13">&lt;pre&gt;{{ f.value | json }}&lt;/pre&gt;</kbd> to the bottom of the form and you will be able to see the structure of this nested model:</p>
<pre class="calibre19">{
  "exercises": {
    "0": {
      "duration": 15
    },
    "1": {
      "duration": 60
    },
    "2": {
      "duration": 45
    },
    "exerciseCount": 3
  },
  "workoutName": "1minworkout",
  "title": "1 Minute Workout",
  "description": "desc",
  "restBetweenExercise": 30
}</pre>
<p class="calibre3">This is powerful stuff that enables us to create complicated forms with nested models, all of which can use <kbd class="calibre13">ngModel</kbd> for databinding<strong class="calibre5">.</strong></p>
<div class="packt_infobox">
<p class="calibre20">You may have noticed a subtle difference in the two <kbd class="calibre24">ngModelGroup</kbd> directive tags we just introduced. The second of the two is wrapped in angle brackets, <kbd class="calibre24">[]</kbd>, while the first is not. This is because with the first tag we are just naming our model group, whereas with the second we are binding it dynamically to each exercise's div tag using the index of our for loop. </p>
</div>
<p class="calibre3">Like input, select too supports two-way binding. We saw how changing select updates a model, but the model-to-template binding may not be apparent. To verify that a model to a template binding works, open the <em class="calibre17">7 Minute Workout</em> app and verify the duration dropdowns. Each one has a value that is consistent with the model value (30 seconds).</p>
<p class="calibre3">Angular does an awesome job of keeping the model and view in sync using <kbd class="calibre13">ngModel</kbd>. Change the model and see the view updated; change the view and watch as the model is updated instantaneously.</p>
<p class="calibre3">Now, let's add validation to our form.</p>
<div class="packt_infobox">
<p class="calibre20">The code for the next section is also available for everyone to download on GitHub at <span class="calibre22"><a href="https://github.com/chandermani/angular6byexample" class="calibre21">https://github.com/chandermani/angular6byexample</a></span>. Checkpoints are implemented as branches in GitHub. The branch to download is as follows: <kbd class="calibre24">GitHub Branch: checkpoint4.6</kbd> (folder—<kbd class="calibre24">trainer</kbd>). Or if you are not using Git, download the snapshot of Checkpoint 4.6 (a ZIP file) from the following GitHub location: <a href="https://github.com/chandermani/angular6byexample/archive/checkpoint4.6.zip" class="calibre21">https://github.com/chandermani/angular6byexample/archive/checkpoint4.6.zip</a>. Refer to the <kbd class="calibre24">README.md</kbd> file in the <kbd class="calibre24">trainer</kbd> folder when setting up the snapshot for the first time. Again, if you are working along with us as we build the application, be sure and update the <kbd class="calibre24">styles.css</kbd> file, which we are not discussing here.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Angular validation</h1>
                
            
            <article>
                
<p class="calibre3">As the saying goes, <em class="calibre17">never trust user input</em>. Angular has support for validation, including the standard required, min, max, and pattern, as well as custom validators.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">ngModel</h1>
                
            
            <article>
                
<p class="calibre3"><kbd class="calibre13">ngModel</kbd> is the building block that we will use to implement validation. It does two things for us: it maintains the model state and provides a mechanism for identifying validation errors and displaying validation messages.</p>
<p class="calibre3">To get started, we need to assign <kbd class="calibre13">ngModel</kbd> to a local variable in all of our form controls that we will be validating. In each case, we need to use a unique name for this local variable. For example, for workout name we add <kbd class="calibre13">#name="ngModel"</kbd> within the <kbd class="calibre13">input</kbd> tag for that control along with the HTML 5 <kbd class="calibre13">required</kbd> attribute. The workout name <kbd class="calibre13">input</kbd> tag should now look like this:</p>
<pre class="calibre19">&lt;input type="text" name="workoutName" #name="ngModel" class="form-control" id="workout-name" placeholder="Enter workout name. Must be unique." [(ngModel)]="workout.name" required&gt; </pre>
<p class="calibre3">Continue through the form, assigning <kbd class="calibre13">ngModel</kbd> to local variables for each of the inputs. Also, add the required attribute for all the required fields.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Angular model state</h1>
                
            
            <article>
                
<p class="calibre3">Whenever we use <kbd class="calibre13">NgForm</kbd>, every element within our form, including input, text area, and select, has some states defined on the associated model. <kbd class="calibre13">ngModel</kbd> tracks these states for us. The states tracked are:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">pristine</kbd>: The value of this is <kbd class="calibre13">true</kbd> as long as the user does not interact with the input. Any update to the <kbd class="calibre13">input</kbd> field and <kbd class="calibre13">ng-pristine</kbd> is set to <kbd class="calibre13">false</kbd>.</li>
</ul>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">dirty</kbd>: This is the reverse of <kbd class="calibre13">ng-pristine</kbd>. This is <kbd class="calibre13">true</kbd> when the input data has been updated.</li>
<li class="calibre12"><kbd class="calibre13">touched</kbd>: This is <kbd class="calibre13">true</kbd> if the control ever had focus.</li>
<li class="calibre12"><kbd class="calibre13">untouched</kbd>: This is <kbd class="calibre13">true</kbd> if the control has never lost focus. This is just the reverse of <kbd class="calibre13">ng-touched</kbd>.</li>
<li class="calibre12"><kbd class="calibre13">valid</kbd>: This is <kbd class="calibre13">true</kbd> if there are validations defined on the <kbd class="calibre13">input</kbd> element and none of them are failing.</li>
<li class="calibre12"><kbd class="calibre13">invalid</kbd>: This is <kbd class="calibre13">true</kbd> if any of the validations defined on the element are failing.</li>
</ul>
<p class="calibre3"><kbd class="calibre13">pristine</kbd><kbd class="calibre13">dirty</kbd> or <kbd class="calibre13">touched</kbd><kbd class="calibre13">untouched</kbd> are useful properties that can help us decide when error labels are shown.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Angular CSS classes</h1>
                
            
            <article>
                
<p class="calibre3">Based on the model state, Angular adds some CSS classes to an input element. These include the following:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">ng-valid</kbd>: This is used if the model is valid</li>
<li class="calibre12"><kbd class="calibre13">ng-invalid</kbd>: This is used if the model is invalid</li>
<li class="calibre12"><kbd class="calibre13">ng-pristine</kbd>: This is used if the model is pristine</li>
<li class="calibre12"><kbd class="calibre13">ng-dirty</kbd>: This is used if the model is dirty</li>
<li class="calibre12"><kbd class="calibre13">ng-untouched</kbd>: This is used when the input is never visited</li>
<li class="calibre12"><kbd class="calibre13">ng-touched</kbd>: This is used when the input has focus</li>
</ul>
<p class="calibre3">To verify it, go back to the <kbd class="calibre13">workoutName</kbd> input tag and add a template reference variable named <kbd class="calibre13">spy</kbd> inside the <kbd class="calibre13">input</kbd> tag:</p>
<pre class="calibre19">&lt;input type="text" name="workoutName" #name="ngModel" class="form-control" id="workout-name" placeholder="Enter workout name. Must be unique." [(ngModel)]="workout.name" required #spy&gt; </pre>
<p class="calibre3">Then, below the tag, add the following label:</p>
<pre class="calibre19">&lt;label&gt;{{spy.className}}&lt;/label&gt; </pre>
<p class="calibre3">Reload the application and click on the <span class="calibre6">New Workout</span> link in the <em class="calibre17">Workout Builder</em>. Before touching anything on the screen, you will see the following displayed:</p>
<div class="packt_figure"><img class="image-border6" src="../images/00043.jpeg"/></div>
<p class="calibre3">Add some content into the <span class="calibre6">Name</span> input box and tab away from it. The label changes to this:</p>
<div class="packt_figure"><img class="image-border7" src="../images/00044.jpeg"/></div>
<p class="calibre3">What we are seeing here is Angular changing the CSS classes that apply to this control as the user interacts with it. You can also see these changes by inspecting the <kbd class="calibre13">input</kbd> element in the developer console.</p>
<p class="calibre3">These CSS class transitions are tremendously useful if we want to apply visual clues to the element depending on its state. For example, look at this snippet:</p>
<pre class="calibre19">input.ng-invalid {  border:2px solid red; } </pre>
<p class="calibre3">This draws a red border around any input control that has invalid data.</p>
<p class="calibre3">As you add more validations to the Workout page, you can observe (in the developer console) how these classes are added and removed as the user interacts with the <kbd class="calibre13">input</kbd> element.</p>
<p class="calibre3">Now that we have an understanding of model states and how to use them, let's get back to our discussion of validations (before moving on, remove the variable name and label that you just added).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Workout validation</h1>
                
            
            <article>
                
<p class="calibre3">The workout data needs to be validated for a number of conditions.</p>
<p class="calibre3">After taking the step of adding the local variable references for <kbd class="calibre13">ngModel</kbd> and the required attribute to our <kbd class="calibre13">input</kbd> fields, we have been able to see how <kbd class="calibre13">ngModel</kbd> tracks changes in the state of these controls and how it toggles the CSS styles.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Displaying appropriate validation messages</h1>
                
            
            <article>
                
<p class="calibre3">Now, the input needs to have a value; otherwise, the validation fails. But, how can we know if the validation has failed? <kbd class="calibre13">ngModel</kbd> comes to our rescue here. It can provide the validation state of the particular input. And that gives us what we need to display an appropriate validation message.</p>
<p class="calibre3">Let's go back to the input control for the Workout name. In order to get a validation message to display, we have to first modify the input tag to the following:</p>
<pre class="calibre19">&lt;input type="text" name="workoutName" #name="ngModel" class="form-control" id="workout-name" placeholder="Enter workout name. Must be unique." [(ngModel)]="workout.name" required&gt; </pre>
<p class="calibre3">We have added a local variable called <kbd class="calibre13">#name</kbd> and assigned <kbd class="calibre13">ngModel</kbd> to it. This is called a template reference variable and we can use it with the following label to display a validation message for the input:</p>
<pre class="calibre19">&lt;label *ngIf="name.control.hasError('required') &amp;&amp; (name.touched)" class="alert alert-danger validation-message"&gt;Name is required&lt;/label&gt;  </pre>
<p class="calibre3">We are showing the validation message in the event that the name is not provided and the control has been touched. To check the first condition, we retrieve the <kbd class="calibre13">hasError</kbd> property of the control and see if the error type is <kbd class="calibre13">required</kbd>. We check to see if the name input has been <kbd class="calibre13">touched</kbd> because we do not want the message to display when the form first loads for a new workout.</p>
<div class="packt_infobox">
<p class="calibre20">You will notice that we are using a somewhat more verbose style to identify validation errors than is required in this situation. Instead of <kbd class="calibre24">name.control.hasError('required')</kbd>, we could have used <kbd class="calibre24">!name. valid</kbd> and it would have worked perfectly fine. However, using the more verbose approach allows us to identify validation errors with greater specificity, which will be essential when we start adding multiple validators to our form controls. We'll look at using multiple validators a little later in this chapter. For consistency, we'll stick with the more verbose approach.</p>
</div>
<p class="calibre3">Load the new Workout page (<kbd class="calibre13">/builder/workouts/new</kbd>) now. Enter a value in the name input box and then delete it. The error label appears as shown in the following screenshot:</p>
<div class="packt_figure"><img class="image-border8" src="../images/00045.jpeg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding more validation</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6">Angular provides several out-of-the-box validators, including:</span></p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">required</kbd></li>
<li class="calibre12"><kbd class="calibre13">minLength</kbd></li>
<li class="calibre12"><kbd class="calibre13">maxLength</kbd></li>
<li class="calibre12"><kbd class="calibre13">email</kbd></li>
<li class="calibre12"><kbd class="calibre13">pattern</kbd></li>
</ul>
<p class="calibre3">For the complete list of out-of-the box validators, see the documentation for the <kbd class="calibre13">Validators</kbd> class at <a href="https://angular.io/api/forms/Validators" target="_blank" class="calibre10">https://angular.io/api/forms/Validators.</a></p>
<p class="calibre3"><span class="calibre6">We've seen how the</span> <kbd class="calibre13">required</kbd> <span class="calibre6">validator works. Now, let's look at two of the other out-of-the-box validators:</span> <kbd class="calibre13">minLength</kbd> <span class="calibre6">and </span><kbd class="calibre13">maxLength</kbd><span class="calibre6">. In addition to making it required, we want the title of the workout to be between 5 and 20 characters (we'll look at the</span> <kbd class="calibre13">pattern</kbd> <span class="calibre6">validator a little later in this chapter).</span></p>
<p class="calibre3">So, in addition to the <kbd class="calibre13">required</kbd> attribute we added previously to the title input box, we will add the <kbd class="calibre13">minLength</kbd> attribute and set it to <kbd class="calibre13">5</kbd>, and add the <kbd class="calibre13">maxLength</kbd> attribute and set it to <kbd class="calibre13">20</kbd>, like so:</p>
<pre class="calibre19">&lt;input type="text" . . . minlength="5" maxlength="20" required&gt; </pre>
<p class="calibre3">Then, we add another label with a message that will display when this validation is not met:</p>
<pre class="calibre19">&lt;label *ngIf="(title.control.hasError('minlength') || title.control.hasError('maxlength')) &amp;&amp; workout.title.length &gt; 0" class="alert alert-danger validation-message"&gt;Title should be between 5 and 20 characters long.&lt;/label&gt;  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Managing multiple validation messages</h1>
                
            
            <article>
                
<p class="calibre3">You'll see that the conditions for displaying the message now test for the length not being zero. This prevents the message from displaying in the event that the control is touched but left empty. In that case, the title required message should display. This message only displays if nothing is entered in the field and we accomplish this by checking explicitly to see if the control's <kbd class="calibre13">hasError</kbd> type is <kbd class="calibre13">required</kbd>:</p>
<pre class="calibre19">&lt;label *ngIf="title.control.hasError('required')" class="alert alert-danger validation-message"&gt;Title is required.&lt;/label&gt;</pre>
<p class="calibre3">Since we are attaching two validators to this input field, we can consolidate the check for the input being touched by wrapping both validators in a div tag that checks for that condition being met:</p>
<pre class="calibre19">&lt;div *ngIf="title.touched"&gt; 
  . . . [the two validators] . . . 
&lt;/div&gt; </pre>
<div class="packt_infobox">
<p class="calibre20">What we just did shows how we can attach multiple validations to a single input control and also display the appropriate message in the event that one of the validation conditions is not met. However, it's pretty clear that this approach will not scale for more complicated scenarios. Some inputs contain a lot of validations and controlling when a validation message shows up can become complex. As the expressions for handling the various displays get more complicated, we may want to refactor and move them into a custom directive. Creating a custom directive will be covered in detail in <a href="" class="calibre21">Chapter 6</a>, <em class="calibre25">Angular 2 Directives in Depth</em>.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Custom validation messages for an exercise</h1>
                
            
            <article>
                
<p class="calibre3">A workout without any exercise is of no use. There should at least be one exercise in the workout and we should validate this restriction.</p>
<p class="calibre3">The problem with exercise count validation is that it is not something that the user inputs directly and the framework validates. Nonetheless, we still want a mechanism to validate the exercise count in a manner similar to other validations on this form.</p>
<p class="calibre3">What we will do is add a hidden input box to the form that contains the count of the exercises. We will then bind this to <kbd class="calibre13">ngModel</kbd> and add a pattern validator that will check to make sure that there is more than one exercise. We will set the value of the input box to the count of the exercises:</p>
<pre class="calibre19">&lt;input type="hidden" name="exerciseCount" #exerciseCount="ngModel" ngControl="exerciseCount" class="form-control" id="exercise-count" [(ngModel)]="workout.exercises.length" pattern="[1-9][0-9]*"&gt; </pre>
<p class="calibre3">Then, we will attach a validation message to it similar to what we just did with our other validators:</p>
<pre class="calibre19">&lt;label *ngIf="exerciseCount.control.hasError('pattern')" class="alert alert-danger extended-validation-message"&gt;The workout should have at least one exercise!&lt;/label&gt;  </pre>
<p class="calibre3">We are not using <kbd class="calibre13">ngModel</kbd> in its true sense here. There is no two-way binding involved. We are only interested in using it to do custom validation.</p>
<p class="calibre3">Open the new Workout page, add an exercise, and remove it; we should see this error:</p>
<div class="packt_figure"><img class="image-border9" src="../images/00046.jpeg"/></div>
<p class="calibre3">What we did here could have been easily done without involving any model validation infrastructure. But, by hooking our validation into that infrastructure, we do derive some benefits. We can now determine errors with a specific model and errors with the overall form in a consistent and familiar manner. Most importantly, if our validation fails here, the entire form will be invalidated.</p>
<div class="packt_infobox">
<p class="calibre20">Implementing custom validation the way we just did is not what you would want to do very often. Instead, it will usually make more sense to implement this kind of complicated logic inside a custom directive. We'll cover creating custom directives in detail in <a href="" class="calibre21">Chapter 6</a>, <em class="calibre25">Angular 2 Directives in Depth</em>.</p>
</div>
<p class="calibre3">One nuisance with our newly implemented <kbd class="calibre13">Exercise Count</kbd> validation is that it shows when the screen for a new <kbd class="calibre13">Workout</kbd> first appears. With this message, we are not able to use <kbd class="calibre13">ng-touched</kbd> to hide the display. This is because the exercises are being added programmatically and the hidden input we are using to track their count never changes from untouched as exercises are added or removed.</p>
<p class="calibre3">To fix this problem, we need an additional value to check when the state of the exercise list has been reduced to zero, except when the form is first loaded. The only way that situation can happen is if the user adds and then removes exercises from a workout to the point that there are no more exercises. So, we'll add another property to our component that we can use to track whether the remove method has been called. We call that value <kbd class="calibre13">removeTouched</kbd> and set its initial value to <kbd class="calibre13">false</kbd>:</p>
<pre class="calibre19">removeTouched: boolean = false; </pre>
<p class="calibre3">Then, in the remove method we will set that value to <kbd class="calibre13">true</kbd>:</p>
<pre class="calibre19">removeExercise(exercisePlan: ExercisePlan) { 
    this.removeTouched = true; 
    this.workoutBuilderService.removeExercise(exercisePlan); 
} </pre>
<p class="calibre3">Next, we will add <kbd class="calibre13">removeTouched</kbd> to our validation message conditions, like so:</p>
<pre class="calibre19">&lt;label *ngIf="exerciseCount.control.hasError('pattern') &amp;&amp; (removeTouched)" </pre>
<p class="calibre3">Now, when we open a new workout screen, the validation message will not display. But if the user adds and then removes all the exercises, then it will display.</p>
<p class="calibre3">To understand how model validation rolls up into form validation, we need to understand what form-level validation has to offer. However, even before that, we need to implement saving the workout and calling it from the workout form.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Saving the workout</h1>
                
            
            <article>
                
<p class="calibre3">The workout that we are building needs to be persisted (in-memory only). The first thing that we need to do is extend <kbd class="calibre13">WorkoutService</kbd> and <kbd class="calibre13">WorkoutBuilderService</kbd>.</p>
<p class="calibre3"><kbd class="calibre13">WorkoutService</kbd> needs two new methods, <kbd class="calibre13">addWorkout</kbd> and <kbd class="calibre13">updateWorkout</kbd>:</p>
<pre class="calibre19">addWorkout(workout: WorkoutPlan){ 
    if (workout.name){ 
        this.workouts.push(workout); 
        return workout; 
    } 
} 
 
updateWorkout(workout: WorkoutPlan){ 
    for (var i = 0; i &lt; this.workouts.length; i++) { 
        if (this.workouts[i].name === workout.name) { 
            this.workouts[i] = workout; 
            break; 
        } 
    } 
} </pre>
<p class="calibre3">The <kbd class="calibre13">addWorkout</kbd> method does a basic check on the workout name and then pushes the workout into the workout array. Since there is no backing store involved, if we refresh the page, the data is lost. We will fix this in the next chapter where we persist the data to a server.</p>
<p class="calibre3">The <kbd class="calibre13">updateWorkout</kbd> method looks for a workout with the same name in the existing workouts array and if found, updates and replaces it.</p>
<p class="calibre3">We only add one save method to <kbd class="calibre13">WorkoutBuilderService</kbd> as we are already tracking the context in which workout construction is going on:</p>
<pre class="calibre19">save(){ 
    let workout = this.newWorkout ? 
        this._workoutService.addWorkout(this.buildingWorkout) : 
        this._workoutService.updateWorkout(this.buildingWorkout); 
    this.newWorkout = false; 
    return workout; 
} </pre>
<p class="calibre3">The <kbd class="calibre13">save</kbd> method calls either <kbd class="calibre13">addWorkout</kbd> or <kbd class="calibre13">updateWorkout</kbd> in the <kbd class="calibre13">Workout</kbd> service based on whether a new workout is being created or an existing one is being edited.</p>
<p class="calibre3">From a service perspective, that should be enough. Time to integrate the ability to save workouts into the <kbd class="calibre13">Workout</kbd> component and learn more about the form directive!</p>
<p class="calibre3">Before we look at <kbd class="calibre13">NgForm</kbd> in more detail, let's add the save method to <kbd class="calibre13">Workout</kbd> to save the workout when the <kbd class="calibre13">Save</kbd> button is clicked on. Add this code to the <kbd class="calibre13">Workout</kbd> component:</p>
<pre class="calibre19">save(formWorkout:any){ 
    if (!formWorkout.valid) return; 
    this.workoutBuilderService.save(); 
    this.router.navigate(['/builder/workouts']); 
}  </pre>
<p class="calibre3">We check the validation state of the form using its invalid property and then call the <kbd class="calibre13">WorkoutBuilderService.save</kbd> method if the form state is valid.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">More on NgForm</h1>
                
            
            <article>
                
<p class="calibre3">Forms in Angular have a different role to play as compared to traditional forms that post data to the server. If we go back and look again at the form tag, we will see that it is missing the standard action attribute. The standard form behavior of posting data to the server using full-page post-back does not make sense with an SPA framework such as Angular. In Angular, all server requests are made through asynchronous invocations originating from directives or services.</p>
<p class="calibre3"><span class="calibre6">Under the hood, Angular is also turning off the browser's inbuilt validation. As you have seen in this chapter, we are still using validation attributes such as <kbd class="calibre13">required</kbd> that look the same as native HTML validation attributes. However, as the Angular documentation explains, inside an Angular form "Angular uses directives to match these attributes with validator functions in the framework." See  <a href="https://angular.io/guide/form-validation#template-driven-validation" target="_blank" class="calibre10">https://angular.io/guide/form-validation#template-driven-validation</a></span>.</p>
<p class="calibre3">The form here plays a different role. When the form encapsulates a set of input elements (such as input, textarea, and select) it provides an API for:</p>
<ul class="calibre11">
<li class="calibre12">Determining the state of the form, such as whether the form is dirty or pristine based on the input controls on it</li>
<li class="calibre12">Checking validation errors at the form or control level</li>
</ul>
<div class="packt_infobox">
<p class="calibre20">If you still want the standard form behavior, you can add an <kbd class="calibre24">ngNoForm</kbd> attribute to the <kbd class="calibre24">form</kbd> element, but this will definitely cause a full-page refresh. <span class="calibre22">You can also turn on the browser's inbuilt validation by adding the </span><span class="calibre22"><kbd class="calibre24">ngNativeValidate</kbd> attribute. </span><span class="calibre22">We'll explore the specifics of the</span> <kbd class="calibre24">NgForm</kbd> <span class="calibre22">API a little later in this chapter when we look at saving the form and implementing validation. </span></p>
</div>
<p class="calibre3">The state of the <kbd class="calibre13">FormControl</kbd> objects within the form is being monitored by <kbd class="calibre13">NgForm</kbd>. If any of them are invalid, then <kbd class="calibre13">NgForm</kbd> sets the entire form to invalid. In this case, we have been able to use <kbd class="calibre13">NgForm</kbd> to determine that one or more of the <kbd class="calibre13">FormControl</kbd> objects is invalid and therefore the state of the form as a whole is invalid too.</p>
<p class="calibre3">Let's look at one more issue before we finish this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Fixing the saving of forms and validation messages</h1>
                
            
            <article>
                
<p class="calibre3">Open a new Workout page and directly click on the <span class="calibre6">Save</span> button. Nothing is saved as the form is invalid, but validations on individual form input do not show up at all. It now becomes difficult to know what elements have caused validation failure. The reason behind this behavior is pretty obvious. If we look at the error message binding for the name input element, it looks like this:</p>
<pre class="calibre19">*ngIf="name.control?.hasError('required') &amp;&amp; name.touched"</pre>
<p class="calibre3">Remember that, earlier in the chapter, we explicitly disabled showing validation messages until the user has touched the input control. The same issue has come back to bite us and we need to fix it now.</p>
<p class="calibre3">We do not have a way to explicitly change the touched state of our controls to untouched. Instead, we will resort to a little trickery to get the job done. We'll introduce a new property called <kbd class="calibre13">submitted</kbd>. Add it at the top of the <kbd class="calibre13">Workout</kbd> class definition and set its initial value to <kbd class="calibre13">false</kbd>, like so:</p>
<pre class="calibre19">submitted: boolean = false;</pre>
<p class="calibre3">The variable will be set to <kbd class="calibre13">true</kbd> on the <span class="calibre6">Save</span> button click. Update the save implementation by adding the highlighted code:</p>
<pre class="calibre19">save(formWorkout){ 
<strong class="calibre1">    this.submitted = true;</strong> 
    if (!formWorkout.valid) return; 
    this._workoutBuilderService.save(); 
    this.router.navigate(['/builder/workouts']); 
} </pre>
<p class="calibre3">However, how does this help? Well, there is another part to this fix that requires us to change the error message for each of the controls we are validating. The expression now changes to:</p>
<pre class="calibre19">*ngIf="name.control.hasError('required') &amp;&amp; (name.touched || submitted)"   </pre>
<p class="calibre3">With this fix, the error message is shown when the control is touched or the form submit button is pressed (<kbd class="calibre13">submitted</kbd> is <kbd class="calibre13">true</kbd>). This expression fix now has to be applied to every validation message where a check appears.</p>
<p class="calibre3">If we now open the new <span class="calibre6">Workout</span> page and click on the <span class="calibre6">Save</span> button, we should see all validation messages on the input controls:</p>
<div class="packt_figure"><img class="calibre28" src="../images/00047.jpeg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Reactive forms</h1>
                
            
            <article>
                
<p class="calibre3">The other type of form that Angular supports is called <strong class="calibre5">reactive</strong> forms. <strong class="calibre5">Reactive forms</strong> start with a model that is constructed in a component class. With this approach, we use the <strong class="calibre5">form builder API</strong> to create a form in code and associate it with a model.</p>
<p class="calibre3">Given the minimal code we have to write to get template-driven forms working, why and when should we consider using reactive forms? There are several situations in which we might want to use them. These include cases where we want to take programmatic control of creating the form. This is especially beneficial, as we will see, when we are trying to create form controls dynamically based on data we are retrieving from the server.</p>
<p class="calibre3">If our validation gets complicated, it is often easier to handle it in code. Using reactive forms, we can keep this complicated logic out of the HTML template, making the template syntax simpler.</p>
<p class="calibre3">Another significant advantage of reactive forms is that they make unit-testing the form possible, which is not the case with <strong class="calibre5">template-driven forms.</strong> We can simply instantiate our form controls in our tests and then test them outside the markup on our page.</p>
<p class="calibre3"><strong class="calibre5">Reactive forms</strong> use three new form directives that we haven't discussed before: <kbd class="calibre13">FormGroup</kbd>, <kbd class="calibre13">FormControl</kbd>, and <kbd class="calibre13">FormArray</kbd>. These directives allow the form object that is constructed in code to be tied directly to the HTML markup in the template. The form controls that are created in the component class are then directly available in the form itself. Technically speaking, this means that we don't need to use <kbd class="calibre13">ngModel</kbd> (which is integral to template-driven forms) with reactive forms (although it can be used). The overall approach is a cleaner and less cluttered template with more focus on the code that drives the form. Let's get started with building a reactive form.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting started with reactive forms</h1>
                
            
            <article>
                
<p class="calibre3">We'll make use of reactive forms to build the form to add and edit <span class="calibre6">Exercises</span>. Among other things, this form will allow the user to add links to exercise videos on YouTube. And since they can add any number of video links, we will need to be able to add controls for these video links dynamically. This challenge will present a good test of how effective reactive forms can be in developing more complex forms. Here is how the form will look:</p>
<div class="packt_figure"><img src="../images/00048.jpeg" class="calibre28"/></div>
<p class="calibre3">To get started, open <kbd class="calibre13">workout-builder.module.ts</kbd> and add the following <kbd class="calibre13">import</kbd>:</p>
<pre class="calibre19">import { FormsModule, ReactiveFormsModule }   from '@angular/forms'; 
 ... 
@NgModule({ 
    imports: [ 
        CommonModule, 
        FormsModule, 
<strong class="calibre1">        ReactiveFormsModule,</strong> 
        SharedModule, 
        workoutBuilderRouting 
    ],</pre>
<p class="calibre3"><kbd class="calibre13">ReactiveFormsModule</kbd> contains what we will need to build reactive forms.</p>
<p class="calibre3">Next, copy <kbd class="calibre13">exercise-builder-service.ts</kbd> from the <kbd class="calibre13">workout-builder/builder-services</kbd> folder under <kbd class="calibre13">trainer/src/app</kbd> in <kbd class="calibre13">checkpoint 4.6</kbd> and import it into <kbd class="calibre13">workout-builder.module.ts</kbd>:</p>
<pre class="calibre19">import { ExerciseBuilderService } from "./builder-services/exercise-builder-service"; </pre>
<p class="calibre3">Then, add it as an additional provider to the providers array in that same file:</p>
<pre class="calibre19">@NgModule({ 
   . . . 
  providers: [<br class="title-page-name"/>    WorkoutBuilderService,<br class="title-page-name"/>    WorkoutResolver,<br class="title-page-name"/>    <strong class="calibre1">ExerciseBuilderService,</strong><br class="title-page-name"/>    ExerciseResolver<br class="title-page-name"/>   ]
}) </pre>
<div class="packt_infobox">You will notice here that we also have added <kbd class="calibre24">ExerciseResolver</kbd> as a provider. We won't be covering that here, but you should copy it from the <kbd class="calibre24">exercise</kbd> folder as well and also copy the updated <kbd class="calibre24">workout-builder-routing.module.ts</kbd>, which adds it as a route guard for the navigation to <kbd class="calibre24">ExerciseComponent</kbd>.</div>
<p class="calibre3">Now, open <kbd class="calibre13">exercise.component.ts</kbd> and add the following import statement:</p>
<pre class="calibre19">import { Validators, FormArray, FormGroup, FormControl, FormBuilder } from '@angular/forms';</pre>
<p class="calibre3">This brings in the following, which we will use to construct our form:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">FormBuilder</kbd></li>
<li class="calibre12"><kbd class="calibre13">FormGroup</kbd></li>
<li class="calibre12"><kbd class="calibre13">FormControl</kbd></li>
<li class="calibre12"><kbd class="calibre13">FormArray</kbd></li>
</ul>
<p class="calibre3">Finally, we inject <kbd class="calibre13">FormBuilder</kbd> (as well as <kbd class="calibre13">Router</kbd>, <kbd class="calibre13">ActivatedRoute</kbd>, and <kbd class="calibre13">ExerciseBuilderService</kbd>) into the constructor of our class:</p>
<pre class="calibre19">  constructor(<br class="title-page-name"/>      public route: ActivatedRoute,<br class="title-page-name"/>      public router: Router,<br class="title-page-name"/>      public exerciseBuilderService: ExerciseBuilderService,<br class="title-page-name"/>      public formBuilder: FormBuilder<br class="title-page-name"/>  ) {}</pre>
<p class="calibre3">With these preliminary steps out of the way, we can now go ahead and start building out our form.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the FormBuilder API</h1>
                
            
            <article>
                
<p class="calibre3">The <kbd class="calibre13">FormBuilder</kbd> API is the foundation for reactive forms. You can think of it as a factory for turning out the forms we are constructing in our code. Go ahead and add the <kbd class="calibre13">ngOnInit</kbd> life cycle hook to your class, as follows:</p>
<pre class="calibre19">  ngOnInit() {<br class="title-page-name"/>    this.sub = this.route.data<br class="title-page-name"/>        .subscribe(<br class="title-page-name"/>          (data: { exercise: Exercise }) =&gt; {<br class="title-page-name"/>            this.exercise = data.exercise;<br class="title-page-name"/>          }<br class="title-page-name"/>        );<br class="title-page-name"/><br class="title-page-name"/>      this.buildExerciseForm();<br class="title-page-name"/>  } </pre>
<p class="calibre3">When <kbd class="calibre13">ngOnInit</kbd> fires, it will extract the data for an existing or new <kbd class="calibre13">exercise</kbd> from the route data that has been retrieved and returned by <kbd class="calibre13">ExerciseResolver</kbd>. This is the same pattern we followed with initializing the <kbd class="calibre13">Workout</kbd> component.</p>
<p class="calibre3">Now, let's implement the <kbd class="calibre13">buildExerciseForm</kbd> method by adding the following code:</p>
<pre class="calibre19">buildExerciseForm(){ 
    this.exerciseForm = this.formBuilder.group({ 
        'name': [this.exercise.name, [Validators.required, AlphaNumericValidator.invalidAlphaNumeric]], 
        'title': [this.exercise.title, Validators.required], 
        'description': [this.exercise.description, Validators.required], 
        'image': [this.exercise.image, Validators.required], 
        'nameSound': [this.exercise.nameSound], 
        'procedure': [this.exercise.procedure], 
        'videos': this.addVideoArray() 
    }) 
}  </pre>
<p class="calibre3">Let's examine this code. To start with, we are using the injected instance of <kbd class="calibre13">FormBuilder</kbd> to construct the form and assign it to a local variable, <kbd class="calibre13">exerciseForm</kbd>. Using <kbd class="calibre13">formBuilder.group</kbd>, we add several form controls to our form. We add each of them by a simple key/value mapping:</p>
<pre class="calibre19">'name': [this.exercise.name, Validators.required], </pre>
<p class="calibre3">The left side of the mapping is the name of the <kbd class="calibre13">FormControl</kbd>, and the right is an array containing as its first element the value of the control (in our case, the corresponding element on our exercise model) and the second a validator (in this case, the out-of-the-box required validator). Nice and neat! It's definitely easier to see and reason about our form controls by setting them up outside the template.</p>
<p class="calibre3">We can not only build up <kbd class="calibre13">FormControls</kbd> in our form this way, but also add <kbd class="calibre13">FormControlGroups</kbd> and <kbd class="calibre13">FormControlArray</kbd>, which contain <kbd class="calibre13">FormControls</kbd> within them. This means we can create complex forms that contain nested input controls. In our case, as we have mentioned, we are going to need to accommodate the possibility of our users adding multiple videos to an exercise. We can do this by adding the following code:</p>
<pre class="calibre19">'videos': this.addVideoArray() </pre>
<p class="calibre3">What we are doing here is assigning a <kbd class="calibre13">FormArray</kbd> to videos, which means we can assign multiple controls in this mapping. To construct this new <kbd class="calibre13">FormArray</kbd>, we add the following <kbd class="calibre13">addVideoArray</kbd> method to our class:</p>
<pre class="calibre19">addVideoArray(){ 
    if(this.exercise.videos){ 
        this.exercise.videos.forEach((video : any) =&gt; { 
            this.videoArray.push(new FormControl(video, Validators.required)); 
        }); 
    } 
    return this.videoArray; 
} </pre>
<p class="calibre3">This method constructs a <kbd class="calibre13">FormControl</kbd> for each video; each is then added each to a <kbd class="calibre13">FormArray</kbd> that is assigned to the videos control in our form.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding the form model to our HTML view</h1>
                
            
            <article>
                
<p class="calibre3">So far, we have been working behind the scenes in our class to construct our form. The next step is to wire up our form to the view. To do this, we use the same controls that we used to build the form in our code: <kbd class="calibre13">formGroup</kbd>, <kbd class="calibre13">formControl</kbd>, and <kbd class="calibre13">formArray</kbd>.</p>
<p class="calibre3">Open <kbd class="calibre13">exercise.component.html</kbd> and add a <kbd class="calibre13">form</kbd> tag as follows:</p>
<pre class="calibre19">&lt;form class="row" [formGroup]="exerciseForm" (ngSubmit)="onSubmit(exerciseForm)"&gt;  </pre>
<p class="calibre3">Within the tag, we are first assigning the <kbd class="calibre13">exerciseForm</kbd> that we just built in code to <kbd class="calibre13">formGroup</kbd>. This establishes the connection between our coded model and the form in the view. We also wire up the <kbd class="calibre13">ngSubmit</kbd> event to an <kbd class="calibre13">onSubmit</kbd> method in our code (we'll discuss this method a little later). </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding form controls to our form inputs</h1>
                
            
            <article>
                
<p class="calibre3">Next, we start constructing the inputs for our form. We'll start with the input for the name of our exercise:</p>
<pre class="calibre19">&lt;input name="name" formControlName="name" class="form-control" id="name" placeholder="Enter exercise name. Must be unique."&gt;  </pre>
<p class="calibre3">We assign the name of our coded form control to <kbd class="calibre13">formControlName</kbd>. This establishes the link between the control in our code and the <kbd class="calibre13">input</kbd> field in the markup. Another item of interest here is that we do not use the <kbd class="calibre13">required</kbd> attribute.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding validation</h1>
                
            
            <article>
                
<p class="calibre3">The next thing that we do is add a validation message to the control that will display in the event of a validation error:</p>
<pre class="calibre19">&lt;label *ngIf="exerciseForm.controls['name'].hasError('required') &amp;&amp; (exerciseForm.controls['name'].touched || submitted)" class="alert alert-danger validation-message"&gt;Name is required&lt;/label&gt;</pre>
<p class="calibre3">Notice that this markup is very similar to what we used in template-driven forms for validation, except that the syntax for identifying the control is somewhat more verbose Again, it checks the state of the <kbd class="calibre13">hasError</kbd> property of the control to make sure it is valid.</p>
<p class="calibre3">But wait a minute! How can we validate this input? Haven't we removed the required attribute from our tag? This is where the control mappings that we added in our code come into play. If you look back at the code for the form model, you can see the following mapping for the <kbd class="calibre13">name</kbd> control:</p>
<pre class="calibre19">'name': [this.exercise.name, Validators.required], </pre>
<p class="calibre3">The second element in the mapping array assigns the required validator to the name form control. This means that we don't have to add anything to our template; instead, the form control itself is attached to the template with a required validator. The ability to add a validator in our code enables us to conveniently add validators outside our template. This is especially useful when it comes to writing custom validators with complex logic behind them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding dynamic form controls</h1>
                
            
            <article>
                
<p class="calibre3">As we mentioned earlier, the <span class="calibre6">Exercise</span> form that we are building requires that we allow the user to add one or more videos to the exercise. Since we don't know how many videos the user may want to add, we will have to build the <kbd class="calibre13">input</kbd> fields for these videos dynamically as the user clicks on the <span class="calibre6">Add Video</span> button. Here's how it will look:</p>
<div class="packt_figure"><img src="../images/00049.jpeg" class="calibre62"/></div>
<p class="calibre3">We have already seen the code in our component class that we use to do this. Now, let's take a look at how it is implemented in our template.</p>
<p class="calibre3">We first use <kbd class="calibre13">ngFor</kbd> to loop through our list of videos. Then, we assign the index in our videos to a local variable, <kbd class="calibre13">i</kbd>. No surprises so far:</p>
<pre class="calibre19">&lt;div *ngFor="let video of videoArray.controls; let i=index" class="form-row align-items-center"&gt;</pre>
<p class="calibre3">Inside the loop, we do three things. First, we dynamically add a video<span class="calibre6"> </span><kbd class="calibre13">input</kbd><span class="calibre6"> </span>field for each of the videos currently in our exercise:</p>
<pre class="calibre19">&lt;div class="col-sm-10"&gt;<br class="title-page-name"/>    &lt;input type="text" class="form-control" [formControlName]="i" placeholder="Add a related youtube video identified."/&gt;<br class="title-page-name"/>&lt;/div&gt;</pre>
<p class="calibre3">Next, we add a button to allow the user to delete a video:</p>
<pre class="calibre19">&lt;span class="btn alert-danger" title="Delete this video." (click)="deleteVideo(i)"&gt;<br class="title-page-name"/>    &lt;span class="ion-ios-trash-outline"&gt;&lt;/span&gt;<br class="title-page-name"/>&lt;/span&gt; </pre>
<p class="calibre3">We bind a <kbd class="calibre13">deleteVideo</kbd> method in our component class to the button's <kbd class="calibre13">click</kbd> event and pass to it the index of the video being deleted.</p>
<p class="calibre3">We then add a validation message for each of the video <kbd class="calibre13">input</kbd> fields:</p>
<pre class="calibre19">&lt;label *ngIf="exerciseForm.controls['videos'].controls[i].hasError('required') &amp;&amp; (exerciseForm.controls['videos'].controls[i].touched || submitted)" class="alert alert-danger validation-message"&gt;Video identifier is required&lt;/label&gt;</pre>
<p class="calibre3">The validation message follows the same pattern for displaying the message that we have used elsewhere in this chapter. We drill into the <kbd class="calibre13">exerciseFormControls</kbd> group to find the particular control by its index. Again, the syntax is verbose but easy enough to understand.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Saving the form</h1>
                
            
            <article>
                
<p class="calibre3">The final step in building out our reactive form is to handle saving the form. When we constructed the form tag earlier, we bound the <kbd class="calibre13">ngSubmit</kbd> event to the following <kbd class="calibre13">onSubmit</kbd> method in our code:</p>
<pre class="calibre19">  onSubmit(formExercise: FormGroup) {<br class="title-page-name"/>      this.submitted = true;<br class="title-page-name"/>      if (!formExercise.valid) { return; }<br class="title-page-name"/>      this.mapFormValues(formExercise);<br class="title-page-name"/>      this.exerciseBuilderService.save();<br class="title-page-name"/>      this.router.navigate(['/builder/exercises']);<br class="title-page-name"/>  }</pre>
<p class="calibre3">This method sets <kbd class="calibre13">submitted</kbd> to <kbd class="calibre13">true</kbd>, which will trigger the display of any validation messages that might have been previously hidden because the form had not been touched. It also returns without saving in the event that there are any validation errors on the form. If there are none, then it calls the following <kbd class="calibre13">mapFormValues</kbd> method, which assigns the values from our form to the <kbd class="calibre13">exercise</kbd> that will be saved:</p>
<pre class="calibre19">  mapFormValues(form: FormGroup) {<br class="title-page-name"/>      this.exercise.name = form.controls['name'].value;<br class="title-page-name"/>      this.exercise.title = form.controls['title'].value;<br class="title-page-name"/>      this.exercise.description = form.controls['description'].value;<br class="title-page-name"/>      this.exercise.image = form.controls['image'].value;<br class="title-page-name"/>      this.exercise.nameSound = form.controls['nameSound'].value;<br class="title-page-name"/>      this.exercise.procedure = form.controls['procedure'].value;<br class="title-page-name"/>      this.exercise.videos = form.controls['videos'].value;<br class="title-page-name"/>  }</pre>
<p class="calibre3">It then calls the save method in <kbd class="calibre13">ExerciseBuilderService</kbd> and routes the user back to the exercise list screen (remember that any new exercise will not display in that list because we have not yet implemented data persistence in our application).</p>
<p class="calibre3">We hope this makes it clear; reactive forms offer many advantages when we are trying to build more complicated forms. They allow programming logic to be removed from the template. They permit validators to be added to the form programmatically. And, they support building forms dynamically at runtime.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Custom validators</h1>
                
            
            <article>
                
<p class="calibre3">Now, we'll take a look at one more thing before we conclude this chapter. As anyone who has worked on building web forms (either in Angular or any other web technology) knows, we are often called on to create validations that are unique to the application we are building. Angular provides us with the flexibility to enhance our reactive form validation by building custom validators.</p>
<p class="calibre3">In building our exercise form, we need to be sure about what is entered, as a name contains only alphanumeric characters and no spaces. This is because when we get to storing the exercises in a remote data store, we are going to use the name of the exercise as its key. So, in addition to the standard required field validator, let's build another validator that checks to make sure that the name entered is in alphanumeric form only.</p>
<p class="calibre3">Creating a custom control is quite straightforward. In its simplest form, an Angular custom validator is a function that takes a control as an input parameter, runs the validation check, and returns true or false. So, let's start by adding a TypeScript file with the name <kbd class="calibre13">alphanumeric-validator.ts</kbd>. In that file, first import <kbd class="calibre13">FormControl</kbd> from <kbd class="calibre13">@angular/forms</kbd>, then add the following class to that file:</p>
<pre class="calibre19">export class AlphaNumericValidator {<br class="title-page-name"/>    static invalidAlphaNumeric(control: FormControl): { [key: string]: boolean } {<br class="title-page-name"/>        if ( control.value.length &amp;&amp; !control.value.match(/^[a-z0-9]+$/i) ) {<br class="title-page-name"/>            return {invalidAlphaNumeric: true };<br class="title-page-name"/>        }<br class="title-page-name"/>        return null;<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre3">The code follows the pattern for creating a validator that we just mentioned. The only thing that may be a little surprising is that it returns true when the validation fails! As long as you are clear on this one quirk, you should have no problem writing your own custom validator.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Integrating a custom validator into our forms</h1>
                
            
            <article>
                
<p class="calibre3">So how do we plug our custom validator into our form? If we are using reactive forms, the answer is pretty simple. We add it just like a built-in validator when we build our form in code. Let's do that. Open <kbd class="calibre13">exercise.component.ts</kbd> and first add an import for our custom validator:</p>
<pre class="calibre19">import { AlphaNumericValidator } from '../alphanumeric-validator'; </pre>
<p class="calibre3">Then, modify the form builder code to add the validator to the <kbd class="calibre13">name</kbd> control:</p>
<pre class="calibre19">buildExerciseForm(){ 
    this.exerciseForm = this._formBuilder.group({ 
'name': [this.exercise.name, [Validators.required, <strong class="calibre1">AlphaNumericValidator.invalidAlphaNumeric</strong>]], 
  . . . [other form controls] . . . 
    }); 
} 
 </pre>
<p class="calibre3">Since the name control already has a required validator, we add <kbd class="calibre13">AlphaNumericValidator</kbd> as a second validator using an array that contains both validators. The array can be used to add any number of validators to a control.</p>
<p class="calibre3">The final step is to incorporate the appropriate validation message for the control into our template. Open <kbd class="calibre13">workout.component.html</kbd> and add the following label just below the label that displays the message for the required validator:</p>
<pre class="calibre19">&lt;label *ngIf="exerciseForm.controls['name'].hasError('invalidAlphaNumeric') &amp;&amp; (exerciseForm.controls['name'].touched || submitted)" class="alert alert-danger validation-message"&gt;Name must be alphanumeric&lt;/label&gt; </pre>
<p class="calibre3">The exercise screen will now display a validation message if a non-alphanumeric value is entered in the name input box:</p>
<div class="packt_figure"><img class="image-border10" src="../images/00050.jpeg"/></div>
<p class="calibre3">As we hope you can see, reactive forms give us the ability to add custom validators to our forms in a straightforward manner that allows us to maintain the validation logic in our code and easily integrate it into our templates.</p>
<div class="packt_infobox">
<p class="calibre20">You may have noticed that in this chapter, we have not covered how to use custom validators in template-driven forms. That is because implementing them requires the additional step of building a custom directive. We'll cover that in <a href="" class="calibre21">Chapter 6</a>, <em class="calibre25">Angular 2 Directives in Depth</em>.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuration options for running validation</h1>
                
            
            <article>
                
<p class="calibre3">Before we move on from validation, there is one more topic to cover and that is configuration options for running the validations. So far, we have been using the default option, which runs validation checks on every input event. However, you have the choice of configuring them to run either on "blur"(that is when the user leaves an input control) or when the form is submitted. You can set this configuration at the form level or on a control-by-control basis.</p>
<p class="calibre3">For example, we might decide that to avoid the complexity of handling missing exercises in the workout form, we will set that form to validate only upon submit. We can set this by adding the following highlighted assignment of <kbd class="calibre13">NgFormOptions</kbd> to the form tag:</p>
<pre class="calibre19">&lt;form #f="ngForm" name="formWorkout" (ngSubmit)="save(f.form)" <strong class="calibre1">[ngFormOptions]="{updateOn: 'submit'}"</strong> class="row"&gt;</pre>
<p class="calibre3">This instructs Angular to run our validations only upon <kbd class="calibre13">submit</kbd>. Try it and you’ll see that no validations appear when you make entries into the form. Leave the form blank and press the <span class="calibre6">Save</span> button, and you will see the validation messages appear. Taking this approach, of course, means that there are no visual cues to the user regarding validation until they press the Save button.</p>
<p class="calibre3">There are also a couple of other unintended side effects to using this approach in our form. The first is that the title no longer updates at the top of the screen as we type into the title input box. That value will only be updated when we press <span class="calibre6">Save</span>. Second, you will also see a validation message appear if you add one or more workouts and then remove all of them. This is because of the special conditions we set up for this control, which cause it to fire outside the normal validation flow.</p>
<p class="calibre3">So, maybe we should take a different approach. Angular provides the option of implementing more fine-grained control of the validation flow by allowing us to make such configurations at the control level using <kbd class="calibre13">ngModelOptions</kbd>. For example, let’s remove the <kbd class="calibre13">ngFormOptions</kbd> assignment from the form tag and modify the title input control to add <kbd class="calibre13">ngModelOptions</kbd> as follows:</p>
<pre class="calibre19">&lt;input type="text" name="title" class="form-control" #title="ngModel" id="workout-title" placeholder="What would be the workout title?" [(ngModel)]="workout.title" <strong class="calibre1">[ngModelOptions]="{updateOn: 'blur'}"</strong> minlength="5" maxlength="20" required&gt;</pre>
<p class="calibre3">You’ll then notice that as you type the title into the input box, it does not update the title on the screen until you move off it (which triggers the <kbd class="calibre13">updateOn</kbd> event):</p>
<div class="packt_figure"><img src="../images/00051.jpeg" class="calibre28"/></div>
<div class="title-page-name">
<p class="calibre3">As you will remember, the default option caused the title to update with every keystroke. This is a contrived example but it illustrates how the differences in these configurations work.</p>
<p class="calibre3">You probably don’t see the need to use the on blur setting here. But, incase where you may be doing validation by calling an external data store, this approach could be helpful in limiting the number of calls that are being made. And making such remote calls is exactly what we will be doing in <a href="part0277.html#885BQ0-7edc9b1e1ea341adae33006323903887" class="calibre10">Chapter 6</a>, <em class="calibre17">Angular Directives in Depth</em>, when we implement a custom directive. The directive will be checking for duplicate names that already exist in our remote data store. So, let’s remove this configuration from the title input control and place it instead on the name input control, like so:</p>
<pre class="calibre19">&lt;input type="text" name="workoutName" #name="ngModel" class="form-control" id="workout-name" placeholder="Enter workout name. Must be unique." [(ngModel)]="workout.name" <strong class="calibre1">[ngModelOptions]="{updateOn: 'blur'}"</strong> required&gt;</pre></div>
<p class="calibre3">We also can set the validation timing options within a reactive form. From what we have already learned about reactive forms, you will not be surprised to learn that we will be applying these settings in our code rather than the template. For example, to set them for a form group you use the following syntax:</p>
<pre class="calibre19">new FormGroup(value, {updateOn: 'blur'}));</pre>
<p class="calibre3">We can also apply them to individual form controls and that is what we will do in the case of our exercise form. Like the workout form, we will want to be able to validate the uniqueness of the name by making a remote call. So, we will want to limit the validation checking in a similar manner. We’ll do that by adding the following to the code that creates the name form control:</p>
<pre class="calibre19">  buildExerciseForm() {<br class="title-page-name"/>      this.exerciseForm = this.formBuilder.group({<br class="title-page-name"/>          'name': [<br class="title-page-name"/>            this.exercise.name,<br class="title-page-name"/><strong class="calibre1">           {</strong><br class="title-page-name"/><strong class="calibre1">             updateOn: 'blur',</strong><br class="title-page-name"/><strong class="calibre1">             validators: [Validators.required, AlphaNumericValidator.invalidAlphaNumeric]</strong><br class="title-page-name"/><strong class="calibre1">            }</strong><br class="title-page-name"/>          ],<br class="title-page-name"/>        ....<br class="title-page-name"/>      });<br class="title-page-name"/>  }</pre>
<p class="calibre3">Note that we are putting the setting, along with the <kbd class="calibre13">validators</kbd> array, in the options object inside a pair of curly braces.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre3">We now have a <em class="calibre17">Personal Trainer</em> app. The process of converting a specific <em class="calibre17">7 Minute Workout</em> app to a generic <em class="calibre17">Personal Trainer</em> app helped us learn a number of new concepts.</p>
<p class="calibre3">We started the chapter by defining the new app requirements. Then, we designed the model as a shared service.</p>
<p class="calibre3">We defined some new views and corresponding routes for the <em class="calibre17">Personal Trainer</em> app. We also used both child and asynchronous routing to separate out <em class="calibre17">Workout Builder</em> from the rest of the app.</p>
<p class="calibre3">We then turned our focus to workout building. One of the primary technological focuses in this chapter was on Angular forms. The <em class="calibre17">Workout Builder</em> employed a number of form input elements and we implemented a number of common form scenarios using both template-driven and reactive forms. We also explored Angular validation in depth, and implemented a custom validator. We also covered configuring the timing options for running validation.</p>
<p class="calibre3">The next chapter is all about client-server interaction. The workouts and exercises that we create need to be persisted. In the next chapter, we build a persistence layer, which will allow us to save workout and exercise data on the server.</p>
<p class="calibre3">Before we conclude this chapter, here is a friendly reminder. If you have not completed the exercise building routine for <em class="calibre17">Personal Trainer</em>, go ahead and do it. You can always compare your implementation with what has been provided in the companion code base. There are also things you can add to the original implementation, such as file uploads for the exercise image, and once you are more familiar with client-server interaction, a remote check to determine whether the YouTube videos actually exist.</p>


            </article>

            
        </section>
    </body></html>