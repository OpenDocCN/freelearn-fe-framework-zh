<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">TypeScript Crash Course</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will start working with TypeScript: the language Angular is written with. All the features that ECMAScript 2015 and ECMAScript 2016 provide, such as functions, classes, modules, and decorators, are already implemented in or added to the roadmap of TypeScript. Because of the extra type annotations, there are some syntactical additions compared to JavaScript.</p>
<p>Being already familiar with AngularJS and subsequently ES5, we'll go through a process of smooth transition to TypeScript. We'll start by introducing ES2015 and ES2016. As we mentioned previously, TypeScript is a superset of these new ECMAScript standards, which means that by learning the new versions of JavaScript you'll also learn very important bits of TypeScript. In the second half of the chapter, we'll add the extra syntax for explicit type annotations.</p>
<p>Later in this chapter, we will explain the extra features TypeScript provides, such as static typing and extra syntax. We will discuss the different consequences based on these features, which will help us to be more productive and less error-prone. Let's get going!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to TypeScript</h1>
                </header>
            
            <article>
                
<p>TypeScript is an open source programming language that is developed and maintained by Microsoft. Its initial public release was in October 2012. TypeScript is a superset of ECMAScript, supporting all of the syntax and semantics of JavaScript with some extra features on top, such as static typing and richer syntax.</p>
<p><em>Figure 1</em> shows the relationships among ES5, ES2015, ES2016, and TypeScript:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="245" width="268" src="assets/cdbf660b-f4bd-48e6-9c32-65bdde97a088.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Figure 1</div>
<p>As TypeScript is statically typed, it can provide a number of benefits to us as JavaScript developers. Let's take a quick look at those benefits now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compile-time type checking</h1>
                </header>
            
            <article>
                
<p>One of the most common mistakes we make while writing JavaScript code is to misspell a property or a method name. Usually, we find out about the mistake when we get a runtime error. This can happen during development as well as during production. Hoping that we will know about the error before we deploy our code to the production environment isn't a comfortable feeling! However, this is not a problem specific to JavaScript; it is something common to all the dynamic languages. Even with lots of unit tests, these errors can slip by.</p>
<p>TypeScript provides a compiler, which takes care of such mistakes for us using static code analysis. If we take advantage of static typing, TypeScript will be aware of the existing properties a given object has, and if we misspell any of them, the compiler will warn us with a compile-time error.</p>
<p>Another great benefit of TypeScript is that it allows large teams to collaborate since it provides formal, verifiable naming. This way, it allows us to write easy-to-understand code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Better support by text editors and IDEs</h1>
                </header>
            
            <article>
                
<p>There are a number of tools, such as Tern, that are trying to bring better autocompletion support for JavaScript in text editors and IDEs. However, as JavaScript is a dynamic language, it is impossible for the IDEs and text editors to make sophisticated suggestions without any metadata. Google Closure Compiler, for instance, uses type annotations provided in the JSDoc in order to provide static typing to the language.</p>
<p>Annotating the code with such metadata is a built-in feature of TypeScript known as type annotations. Based on them, text editors and IDEs can perform a better static analysis on our code. This provides better refactoring tools and autocompletion, which increases our productivity and allows us to make fewer mistakes while writing the source code for our applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's even more to TypeScript</h1>
                </header>
            
            <article>
                
<p>TypeScript by itself has a number of other benefits:</p>
<ul>
<li><strong>It is a superset of JavaScript</strong>: All JavaScript programs (for example, ES5 and ES2015) are already valid TypeScript ones. In essence, you have already been writing TypeScript code. Since it is based on the latest version of the ECMAScript standard, it allows us to take advantage of the latest bleeding-edge syntax provided by the language.</li>
<li><strong>It supports optional type checking</strong>: If, for any reason, we decide that we don't want to explicitly define the type of a variable or a method, we can just skip the type definition. However, we should be aware that this means we are no longer taking advantage of the static typing, so we are giving up on all the benefits mentioned earlier.</li>
<li><strong>It is developed and maintained by Microsoft</strong>: The quality of the implementation of the language is very high, and it is unlikely that support will be dropped unexpectedly. TypeScript is based on the work of some of the world's best experts in programming language development.</li>
<li><strong>It is open source</strong>: This allows the community to freely contribute to the language and suggest features, which are discussed in an open manner. The fact that TypeScript is open source makes the development of third-party extensions and tools easier. This extends the scope of its usage even further.</li>
</ul>
<p>Since modern browsers do not support TypeScript natively, there is a compiler that translates the TypeScript code we write into readable JavaScript in a predefined target version of ECMAScript. Once the code is compiled, all the type annotations are removed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using TypeScript</h1>
                </header>
            
            <article>
                
<p>Let's start writing some TypeScript!</p>
<p>In the following sections, we will take a look at different snippets showing some of the features of TypeScript. In order to be able to run the snippets and play with them yourself, you'll need to install the TypeScript compiler on your computer. Let's take a look at how to do this.</p>
<p>The easiest way to install TypeScript is using <strong>Node package manager</strong> (<strong>npm</strong>). I'd recommend that you use version 5.0.0 or a newer version of <kbd>npm</kbd>. If you don't have node.js and <kbd>npm</kbd> installed already, you can visit <a href="https://nodejs.org">https://nodejs.org</a> and follow the instructions there.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing TypeScript with npm</h1>
                </header>
            
            <article>
                
<p>Once you have <kbd>npm</kbd> installed and running, verify that you have the latest version by opening your terminal window and running the following command:</p>
<pre><strong>$ npm -v
</strong></pre>
<p>Use the following command in order to install TypeScript 2.5.0 or newer:</p>
<pre><strong>$ npm install -g typescript@^2.5.0
</strong></pre>
<p>The preceding command will install the TypeScript compiler and add its executable (<kbd>tsc</kbd>) as global.</p>
<p>In order to verify that everything works properly, you can use the following command:</p>
<pre><strong>$ tsc -v
Version 2.5.2
</strong></pre>
<p>The output should be similar to the preceding one, though possibly with a different minor or patch version.</p>
<div class="packt_infobox">Note that we install TypeScript by prefixing the version with caret. This means that <kbd>npm</kbd> will download any version in the range 2.y.z, but below 3.0.0<span>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running our first TypeScript program</h1>
                </header>
            
            <article>
                
<p>Now, let's compile our first TypeScript program! Create a file called <kbd>hello-world.ts</kbd> and enter the following content:</p>
<pre>// ch4/hello-world/hello-world.ts
 
console.log('Hello world!');</pre>
<p>Since we've already installed the TypeScript compiler, we should have a global executable command called <kbd>tsc</kbd>. You can use it in order to compile the file:</p>
<pre><strong>$ tsc hello-world.ts
</strong></pre>
<p>Now, you should see the <kbd>hello-world.js</kbd> file in the same directory where <kbd>hello-world.ts</kbd> is. The <kbd>hello-world.js</kbd> file is the output of the TypeScript compiler; it contains the JavaScript equivalent to the TypeScript we wrote. We can run this file using the following command:</p>
<pre><strong>$ node hello-world.js
</strong></pre>
<p>Now, you'll see the <kbd>Hello world!</kbd> string printed on the screen. In order to combine the process of compiling and running the program, you can use the <kbd>ts-node</kbd> package:</p>
<pre><strong>$ npm install -g ts-node
</strong></pre>
<p>Now you can run this command:</p>
<pre><strong>$ ts-node hello-world.ts
</strong></pre>
<p>You should see the same result, but without the <kbd>hello-world.js</kbd> file stored on the disk.</p>
<div class="packt_tip">You can find the code for this book at <a href="https://github.com/mgechev/switching-to-angular">https://github.com/mgechev/switching-to-angular</a>. Most code snippets in the book's content have a comment as the first line, which shows where you can find the complete example in the directory structure of the samples repository. Note that the paths are relative to the <kbd>app</kbd> directory.</div>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TypeScript syntaxes and features introduced by ES2015 and ES2016</h1>
                </header>
            
            <article>
                
<p>As TypeScript is a superset of JavaScript, before we start learning about its syntax, it'll be easier to start by introducing some of the bigger changes in ES2015 and ES2016; to understand TypeScript, we first must understand ES2015 and ES2016. We will have a whistle-stop tour through these changes before diving into TypeScript properly.</p>
<p>A detailed explanation of ES2015 and ES2016 is beyond the scope of this book. In order to get familiar with all the new features and syntaxes, I strongly recommend that you take a look at <em>Exploring ES6: Upgrade to the next version of JavaScript</em> by <em>Dr. Axel Rauschmayer</em>.</p>
<p>The next couple of pages will introduce new standards and allow us to take advantage of most of the features we will need during the development of Angular applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ES2015 arrow functions</h1>
                </header>
            
            <article>
                
<p>JavaScript has first-class functions, which means that they can be passed around like any other value:</p>
<pre>// ch4/arrow-functions/simple-reduce.ts
 
var result = [1, 2, 3].reduce(function (total, current) { 
  return total + current; 
}, 0); // 6 </pre>
<p>This syntax is great; however, it is a bit too verbose. ES2015 introduced a new syntax to define anonymous functions called the arrow function syntax. Using it, we can create anonymous functions, as seen in the following examples:</p>
<pre>// ch4/arrow-functions/arrow-functions.ts 
 
// example 1 
var result = [1, 2, 3] 
  .reduce((total, current) =&gt; total + current, 0); 
 
console.log(result); // 6

// example 2 
var even = [3, 1, 56, 7].filter(el =&gt; !(el % 2)); 
 
console.log(even); // [56]
 
// example 3 
var sorted = data.sort((a, b) =&gt; { 
  var diff = a.price - b.price; 
  if (diff !== 0) { 
    return diff; 
  } 
  return a.total - b.total; 
}); </pre>
<p>In the first example here, we got the total sum of the elements in the <kbd>[1, 2, 3]</kbd> array. In the second example, we got all the even numbers from the <kbd>[3, 1, 56, 7]</kbd> array. In the third example, we sorted an array by the <kbd>price</kbd> and <kbd>total</kbd> properties in ascending order.</p>
<p>Arrow functions have a few more features that we need to look at. The most important feature is that they keep the context (<kbd>this</kbd>) from the surrounding code:</p>
<pre>// ch4/arrow-functions/context-demo.ts
 
function MyComponent() { 
  this.age = 42; 
  setTimeout(() =&gt; { 
    this.age += 1; 
    console.log(this.age); 
  }, 100); 
}
 
new MyComponent(); // 43 in 100ms. </pre>
<p>For example, when we invoke the <kbd>MyComponent</kbd> function with the <kbd>new</kbd>; operator, <kbd>this</kbd> will point to the new object instantiated by the call. The arrow function will keep the context (<kbd>this</kbd>), in the callback of <kbd>setTimeout</kbd>, and print <kbd>43</kbd> on the screen.</p>
<p>This is extremely useful in Angular since the binding context for a given component is its instance (that is, its <kbd>this</kbd> reference). If we define <kbd>MyComponent</kbd> as an Angular component and we have a binding to the <kbd>age</kbd> property, the preceding code will be valid and all the bindings will work (note that we don't have the scope, neither do we have explicit calls to the <kbd>$digest</kbd> loop, although we have called <kbd>setTimeout</kbd> directly).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the ES2015 and ES2016 classes</h1>
                </header>
            
            <article>
                
<p>When developers new to JavaScript hear that the language empowers the <strong>object-oriented</strong> (<strong>OO</strong>) paradigm, they're normally confused when they discover that there's no syntax for the definition of classes. This perception was born of the fact that some of the most popular programming languages, such as Java, C#, and C++, have the concept of classes used for the construction of objects. However, JavaScript implements the OO paradigm differently. JavaScript has a prototype-based, object-oriented programming model, where we can instantiate objects using the object literal syntax or functions (also known as the constructor functions), and we can take advantage of the inheritance using the so called prototype chain.</p>
<p>Although this is a valid way to implement the OO paradigm, and the semantics are similar to the one in the classical object-oriented model, it is confusing for inexperienced JavaScript developers who are not sure how to process this properly. This is one of the reasons TC39 decided to provide an alternative syntax to use the object-oriented paradigm in the language. Behind the scenes, the new syntax has the same semantics as the one we're used to, such as using the constructor functions and the prototype-based inheritance. However, it provides a more convenient syntax to empower the features of OO paradigm with less boilerplate.</p>
<p>ES2016 adds some extra syntax to the ES2015 classes, such as static and instance property declaration.</p>
<p>Here is an example that demonstrates the syntax used to define the classes in ES2016:</p>
<pre>// ch4/es6-classes/sample-classes.ts 
 
class Human { 
  static totalPeople = 0; 
  _name; // ES2016 property declaration syntax
 
  constructor(name) { 
    this._name = name; 
    Human.totalPeople += 1; 
  }
 
  get name() { 
    return this._name; 
  }
 
  set name(val) { 
    this._name = val; 
  }
 
  talk() { 
    return `Hi, I'm ${this.name}!`; 
  } 
} 
 
class Developer extends Human { 
  _languages; // ES2016 property declaration syntax
 
  constructor(name, languages) { 
    super(name); 
    this._languages = languages; 
  }
 
  get languages() { 
    return this._languages; 
  }
 
  talk() { 
    return `${super.talk()} And I know ${this.languages.join(',')}.`; 
  } 
} </pre>
<p>In ES2015, the explicit declaration of the <kbd>_name</kbd> property is not required; however, since the TypeScript compiler should be aware during compile time of the existing properties of the instances of a given class, we would need to add the declaration of the property to the class definition itself.</p>
<p>The preceding snippet is both a valid TypeScript and JavaScript code. In it, we defined a class called <kbd>Human</kbd>, which adds a single property to the objects instantiated by it. It does this by setting the value of the property to the value of the parameter <kbd>name</kbd> passed to its constructor.</p>
<p>Later, the <kbd>Developer</kbd> class extends the <kbd>Human</kbd> class by specifying a reference to it in the <kbd>extends</kbd> clause. This way, the instances of the <kbd>Developer</kbd> class will have the entire functionality that the <kbd>Human</kbd> class provides, plus the extra features introduced by <kbd>Developer</kbd>.</p>
<p>Now, open the <kbd>ch4/es6-classes/sample-classes.ts</kbd> file and play around with it! You can create different instances of the classes in the same way you create objects using constructor functions:</p>
<pre>var human = new Human('foobar'); 
var dev = new Developer('bar', ['JavaScript']); 
console.log(dev.talk()); </pre>
<p>In order to execute the code, run the following command:</p>
<pre><strong>$ ts-node sample-classes.ts
</strong></pre>
<p>Classes are commonly used in Angular. You can use them to define your components, directives, services, and pipes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining variables with block scope</h1>
                </header>
            
            <article>
                
<p>Another confusing point of JavaScript for developers with a different background is the variable scope in the language. In Java and C++, for example, we're used to the block lexical scope. This means that a given variable defined inside a specific block will be visible only inside that block and all of the nested blocks inside of it.</p>
<p>However, in JavaScript, things are a little bit different. ECMAScript defines a functional lexical scope that has similar semantics to the block lexical scope, but it uses functions instead of blocks. Let's take a look at the following code snippet:</p>
<pre>// ch4/let/var.ts 
 
var fns = []; 
for (var i = 0; i &lt; 5; i += 1) { 
  fns.push(function() { 
    console.log(i); 
  });
} 
fns.forEach(fn =&gt; fn()); </pre>
<p>This has some weird implications. Once the code is executed, it will log five times the number <kbd>5</kbd>.</p>
<p>ES2015 added a new syntax to define variables with block scope visibility. The syntax is similar to the current one, however, instead of <kbd>var</kbd>, it uses the <kbd>let</kbd> keyword:</p>
<pre>// ch4/let/let.ts 
 
var fns = []; 
for (let i = 0; i &lt; 5; i += 1) { 
  fns.push(function() { 
    console.log(i); 
  });
} 
fns.forEach(fn =&gt; fn()); </pre>
<p>Now the semantics will be as expected: we'll see the numbers from <kbd>0</kbd> to <kbd>4</kbd> logged in the console.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Meta-programming with ES2016 decorators</h1>
                </header>
            
            <article>
                
<p>JavaScript is a dynamic language that allows us to easily modify and/or alter the behavior to suit the programs we write. Decorators are a proposal to ES2016, and the design document at <a href="https://github.com/wycats/javascript-decorators">https://github.com/wycats/javascript-decorators</a> describes their work as follows:</p>
<div class="packt_quote">"...make it possible to annotate and modify classes and properties at design time."</div>
<p>Their syntaxes are quite similar to the annotations in Java, and they are even closer to the decorators in Python. ES2016 decorators are used commonly in Angular to define components, directives, and pipes, and to take advantage of the dependency injection mechanism of the framework. Most use cases of decorators involve altering the behavior to a predefined logic or adding some metadata to different constructs.</p>
<p>ES2016 decorators allow us to do a lot of fancy things by changing the behavior of our programs. Typical use cases could be to annotate the given methods or properties as deprecated or read only. A set of predefined decorators that can improve the readability of the code we produce can be found in a project called <kbd>core-decorators.js</kbd>. Another use case is taking advantage of the proxy-based, aspect-oriented programming using a declarative syntax. The library providing this functionality is <kbd>aspect.js</kbd>.</p>
<p>In general, ES2016 decorators are just a new syntax sugar, which translates to JavaScript code we're already familiar with from the previous versions of the language. Let's take a look at a simple example from the draft of the proposal:</p>
<pre>// ch4/decorators/nonenumerable.ts 
 
class Person { 
  @nonenumerable 
  get kidCount() { 
    return 42; 
  } 
} 
 
function nonenumerable(target, name, descriptor) { 
  descriptor.enumerable = false; 
  return descriptor; 
} 
 
var person = new Person(); 
 
for (let prop in person) { 
  console.log(prop); 
} </pre>
<p>In this case, we have an ES2015 class called <kbd>Person</kbd> with a single getter called <kbd>kidCount</kbd>. Over the <kbd>kidCount</kbd> getter, we have applied the <kbd>@nonenumerable</kbd> decorator. The decorator is a function that accepts a target (the <kbd>Person</kbd> class), the name of the target property we intend to decorate (<kbd>kidCount</kbd>), and the descriptor of the target property. After we change the descriptor, we need to return it in order to apply the modification. Basically, the decorator's application can be translated into ECMAScript 5 in the following way:</p>
<pre>descriptor = nonenumerable(Person.prototype, 'kidCount', descriptor) || descriptor; 
Object.defineProperty(Person.prototype, 'kidCount', descriptor); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using configurable decorators</h1>
                </header>
            
            <article>
                
<p>Here is an example of using the decorators defined by Angular:</p>
<pre>@Component({ 
  selector: 'app', 
  providers: [NamesList], 
  templateUrl: './app.html', 
}) 
export class App {} </pre>
<p>When decorators accept arguments (just like <kbd>Component</kbd> in the preceding example), they need to be defined as functions that accept arguments and return the actual decorator:</p>
<pre>function Component(config) { 
  // validate properties 
  return (componentCtrl) =&gt; { 
    // apply decorator 
  }; 
} </pre>
<p>In this example, we defined a function called <kbd>Component</kbd> that accepts a single argument called <kbd>config</kbd> and returns a decorator. On the other hand, the decorator accepts the constructor function as argument, which is the desugared version of the class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing modular code with ES2015</h1>
                </header>
            
            <article>
                
<p>Another problem that JavaScript professionals have experienced over the years is the lack of a module system in the language. Initially, the community developed different patterns, aiming to enforce the modularity and the encapsulation of the software we produce. Such patterns included the module pattern, which takes advantage of the functional lexical scope and closures. Another example is the namespace pattern, which represents the different namespaces as nested objects. AngularJS introduced its own module system that unfortunately doesn't provide features, such as lazy module loading. However, these patterns were more like workarounds rather than real solutions.</p>
<p><strong>CommonJS</strong> (used in node.js) and <strong>AMD</strong> (short for, <strong>Asynchronous Module Definition</strong>) were later invented. They are still widely used today and provide features such as handling of circular dependencies and asynchronous module loading (in AMD).</p>
<p>TC39 took the best of the existing module systems and introduced this concept on a language level. ES2015 provides two APIs to define and consume modules. They are as follows:</p>
<ul>
<li>Declarative API</li>
<li>Imperative API using a module loader</li>
</ul>
<p>Angular takes full advantage of the ES2015 module system, so let's dive into it! In this section, we will take a look at the syntax used for the declarative definition and consumption of modules. We will also take a peek at the API of the module loader in order to see how we can programmatically load modules in an explicit asynchronous manner.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the ES2015 module syntax</h1>
                </header>
            
            <article>
                
<p>Let's take a look at an example:</p>
<pre>// ch4/modules/math.ts 
 
export function square(x) { 
  return Math.pow(x, 2); 
};
 
export function log(x) { 
  return Math.log(x); 
};
 
export const PI = Math.PI; <br/>export const E = Math.E;</pre>
<p>In the preceding snippet, we defined a simple ES2015 module in the <kbd>math.ts</kbd> file. We can think of it as a sample math Angular utility module. Inside it, we define and export the <kbd>square</kbd> and <kbd>log</kbd> functions and the constants <kbd>E</kbd> and <kbd>PI</kbd>. The <kbd>const</kbd> keyword is another keyword brought by ES2015 that is used to define constants. As you can see, what we do is nothing more than prefixing the definitions of the function with the <kbd>export</kbd> keyword. If we want to export the entire functionality in the end and skip the duplicate explicit usage of <kbd>export</kbd>, we can use the following approach:</p>
<pre>// ch4/modules/math2.ts 
 
function square(x) { 
  return Math.pow(x, 2); 
};
 
function log(x) { 
  return Math.log(x); 
};
 
const PI = Math.PI;<br/>const E = Math.E;
 
export { square, log, PI, E }; </pre>
<p>The syntax on the last line is an enhanced object literal syntax, introduced by ES2015. Now, let's take a look at how we can consume this module:</p>
<pre>// ch4/modules/app.ts 
 
import {square, log, E} from './math';
 
console.log(square(2)); // 4 
console.log(log(E)); // 1 </pre>
<p class="mce-root">As an identifier of the module, we use its relative path to the current file. Using destructuring, we import the required symbols: in this case, <kbd>square</kbd>, <kbd>log</kbd> and <kbd>E</kbd>. Now run the <kbd>app.ts</kbd> file with <kbd>ts-node</kbd>: <kbd>ts-node app.ts</kbd>. As output on the screen you should see:</p>
<pre>4<br/>1</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Taking advantage of the implicit asynchronous behavior of the module</h1>
                </header>
            
            <article>
                
<p>An important thing to note is that the ES2015 module syntax has implicit asynchronous behavior.</p>
<div class="CDPAlignCenter CDPAlign"><img height="132" width="153" src="assets/531918ef-6460-4640-af28-91457c3e19f9.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 2</div>
<p>In the preceding diagram (<em>Figure 2)</em>, we have the <kbd>A</kbd>, <kbd>B</kbd>, and <kbd>C</kbd> modules. The <kbd>A</kbd> module uses the <kbd>B</kbd> and <kbd>C</kbd> modules, so it depends on them. Once the user requires the <kbd>A</kbd> module, the JavaScript module loader will need to load the <kbd>B</kbd> and <kbd>C</kbd> modules before being able to invoke any of the logic that resides in the <kbd>A</kbd> module because of the dependencies they have. The <kbd>B</kbd> and <kbd>C</kbd> modules will be loaded asynchronously. Once they are loaded completely, the JavaScript virtual machine will be able to execute the <kbd>A</kbd> module.</p>
<p>Usually, the modern bundlers are going to combine <kbd>A</kbd>, <kbd>B</kbd>, and <kbd>C</kbd> in a single file in order to reduce the overhead of the additional HTTP requests that the browser needs to perform in order to resolve the dependencies of <kbd>A</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using aliases</h1>
                </header>
            
            <article>
                
<p>Another typical situation is when we want to use an alias for a given export. For example, if we use a third-party library, we may want to rename some of its exports in order to escape name collisions or just to have a more convenient naming:</p>
<pre>import {
  platformBrowserDynamic as platform
} from '@angular/platform-browser-dynamic';</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Importing all the module exports</h1>
                </header>
            
            <article>
                
<p>We can import the entire <kbd>math</kbd> module using the following syntax:</p>
<pre>// ch4/modules/app2.ts 
 
import * as math from './math';
 
console.log(math.square(2)); // 4 
console.log(math.log(math.E)); // 1 
console.log(math.PI); // 3.141592653589793 </pre>
<p>The semantics behind this syntax is quite similar to CommonJS, although, in the browser, we have implicit asynchronous behavior.</p>
<div class="packt_tip">Keep in mind that the <kbd>import *</kbd> syntax is often not recommended because it will get all the exported symbols from the target module even if we don't need them. This can lead to an unnecessary increase in the size of the production build of our applications.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Default exports</h1>
                </header>
            
            <article>
                
<p>If a given module defines an <kbd>export</kbd>, which would quite likely be used by any of its consumer modules, we can take advantage of the default <kbd>export</kbd> syntax:</p>
<pre>// ch4/modules/math3.ts 
 
export default function cube(x) { 
  return Math.pow(x, 3); 
};
 
export function square(x) { 
  return Math.pow(x, 2); 
};</pre>
<p>In order to consume this module, we can use the following <kbd>app.ts</kbd> file:</p>
<pre>// ch4/modules/app3.ts 
 
import cube from './math3';
 
console.log(cube(3)); // 27 </pre>
<p>Alternatively, if we want to import the default export, together with additional exports, we can use this:</p>
<pre>// ch4/modules/app4.ts 
 
import cube, { square } from './math3';
 
console.log(square(2)); // 4 
console.log(cube(3)); // 27 </pre>
<p>In general, the default export is nothing more than an named export named with the <kbd>default</kbd> reserved word:</p>
<pre>// ch4/modules/app5.ts 
 
import { default as cube } from './math3';
 
console.log(cube(3)); // 27 </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ES2015 module loader</h1>
                </header>
            
            <article>
                
<p>The new version of the standard defines a programmatic API to work with modules. This is the so called module loader API. It allows us to define and import modules, or configure the module loading.</p>
<p>Let's suppose we have the following module definition in the <kbd>app.js</kbd> file:</p>
<pre>import { square } from './math';
 
export function main() { 
  console.log(square(2)); // 4 
} </pre>
<p>From the <kbd>init.js</kbd> file, we can programmatically load the <kbd>app</kbd> module and invoke its <kbd>main</kbd> function:</p>
<pre>System.import('./app') 
  .then(app =&gt; { 
    app.main(); 
  }) 
  .catch(error =&gt; { 
    console.log('Terrible error happened', error); 
  }); </pre>
<p>The global object <kbd>System</kbd> has a method called <kbd>import</kbd> that allows us to import modules using their identifier. In the preceding snippet, we import the <kbd>app</kbd> module defined in <kbd>app.js</kbd>. Moreover, <kbd>System.import</kbd> returns a promise that can be resolved on success or rejected in case of an error. Once the promise is resolved as the first parameter of the callback passed to <kbd>then</kbd>, we will get the module instance. The first parameter of the callback registered in case of rejection is an object representing the error that happened.</p>
<p>The code from the previous snippet does not exist in the GitHub repository since it requires additional configuration and is not crucial for our purposes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ES2015 and ES2016 recap</h1>
                </header>
            
            <article>
                
<p>Congratulations! We're more than halfway toward learning TypeScript. All the features we just saw are part of TypeScript since it implements a superset of JavaScript; since all these features are an upgrade on top of the current syntax, they are easy for experienced JavaScript developers to grasp.</p>
<p>In the next sections, we will describe all the amazing features of TypeScript that are outside the intersection with ECMAScript.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Taking advantage of static typing</h1>
                </header>
            
            <article>
                
<p>Static typing is what can provide better tooling for our development process. While writing JavaScript, the most that IDEs and text editors can do is to highlight syntax and provide some basic autocompletion suggestions based on sophisticated type inference for our code. This means that we can only verify that we haven't made any typos by running the code.</p>
<p>In the previous sections, we described the new features provided by ECMAScript expected to be implemented by browsers in the near future. In this section, we will take a look at what TypeScript provides in order to help us be less error prone and more productive. At the time of writing this book, there were no plans to implement built-in support for static typing in the browsers.</p>
<p>The TypeScript code goes through intermediate preprocessing that performs the type checking and drops all the type annotations in order to provide valid JavaScript supported by modern browsers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using explicit type declarations</h1>
                </header>
            
            <article>
                
<p>Just like Java and C++, TypeScript allows us to explicitly declare the type of the given variable:</p>
<pre>let foo: number = 42; </pre>
<p>The preceding line defines the <kbd>foo</kbd> variable in the current block using the <kbd>let</kbd> syntax. We explicitly declare that we want <kbd>foo</kbd> to be of the <kbd>number</kbd> type and we set the value of <kbd>foo</kbd> to <kbd>42</kbd>.</p>
<p>Now, let's try to change the value of <kbd>foo</kbd>:</p>
<pre>let foo: number = 42; 
foo = '42'; </pre>
<p>Here, after the declaration of <kbd>foo</kbd>, we will set its value to the <kbd>'42'</kbd> string. This is a perfectly valid JavaScript code; however, if we compile it using the TypeScript's compiler, we will get this:</p>
<pre><strong>$ tsc basic.ts 
basic.ts(2,1): error TS2322: Type 'string' is not assignable to type 'number'.</strong></pre>
<p>Once <kbd>foo</kbd> is associated with the given type, we cannot assign to it values belonging to different types. This is one of the reasons we can skip the explicit type definition in case we assign a value to the given variable:</p>
<pre>let foo = 42; 
foo = '42'; </pre>
<p>The semantics of this code will be the same as the one with the explicit type definition because of the type inference of TypeScript. We'll further take a look at it at the end of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The any type</h1>
                </header>
            
            <article>
                
<p>All the types in TypeScript are subtypes of a type called <kbd>any</kbd>. We can declare variables belonging to the <kbd>any</kbd> type using the <kbd>any</kbd> keyword. Such variables can hold the value of any type:</p>
<pre>let foo: any; 
foo = {}; 
foo = 'bar '; 
foo += 42; 
console.log(foo); // "bar 42" </pre>
<p>The preceding code is a valid TypeScript, and it will not throw any error during compilation or runtime. If we use the <kbd>any</kbd> type for all of our variables, we will be basically writing the code with dynamic typing, which drops all the benefits of the TypeScript's compiler. This is why we have to be careful with <kbd>any</kbd> and use it only when it is necessary.</p>
<p>Other types in TypeScript that we will take a look at are as follows:</p>
<ul>
<li><strong>Primitive types</strong>: These include the Number, String, Boolean, Void, Null, Undefined, and Enum types</li>
<li><strong>Object types</strong>: These include Function types, classes and interface type references, array types, tuple types, function types, and constructor types</li>
<li><strong>Type parameters</strong>: These include Generics that will be described in the <em>Writing generic code using type parameters</em> section</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the primitive types</h1>
                </header>
            
            <article>
                
<p>Most of the primitive types in TypeScript are the ones we are already familiar with in JavaScript: Number, String, Boolean, Null, and Undefined. So, we will skip their formal explanation here. Another set of types that is handy while developing Angular applications is the <kbd>enum</kbd> types defined by users.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Enum types</h1>
                </header>
            
            <article>
                
<p>The Enum types are primitive user-defined types that, according to the specification, are subclasses of Number. The concept of enums exists in the Java, C++, and C# languages, and it has the same semantics in TypeScript: user-defined types consisting of sets of named values called elements. In TypeScript, we can define an <kbd>enum</kbd> using the following syntax:</p>
<pre>enum STATES { 
  CONNECTING, 
  CONNECTED, 
  DISCONNECTING, 
  WAITING, 
  DISCONNECTED  
}; </pre>
<p>This will be translated to the following JavaScript:</p>
<pre>var STATES; 
(function (STATES) { 
    STATES[STATES["CONNECTING"] = 0] = "CONNECTING"; 
    STATES[STATES["CONNECTED"] = 1] = "CONNECTED"; 
    STATES[STATES["DISCONNECTING"] = 2] = "DISCONNECTING"; 
    STATES[STATES["WAITING"] = 3] = "WAITING"; 
    STATES[STATES["DISCONNECTED"] = 4] = "DISCONNECTED"; 
})(STATES || (STATES = {})); </pre>
<p>We can use the <kbd>enum</kbd> type as follows:</p>
<pre>if (this.state === STATES.CONNECTING) { 
  console.log('The system is connecting'); 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the object types</h1>
                </header>
            
            <article>
                
<p>In this section, we will take a look at the array and function types, which belong to the more generic class of Object types. We will also explore how we can define classes and interfaces. Tuple types were introduced by TypeScript 1.3, and their main purpose is to allow the language to begin typing the new features introduced by ES2015, such as destructuring. We will not describe them in this book. For further reading, you can take a look at the language's specification at <a href="http://www.typescriptlang.org">http://www.typescriptlang.org</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The array types</h1>
                </header>
            
            <article>
                
<p>In TypeScript, arrays are JavaScript arrays with a common element type. This means that we cannot have elements from different types in a given array. We have different array types for all the built-in types in TypeScript, plus all the custom types that we define.</p>
<p>We can define an array of numbers as follows:</p>
<pre>let primes: number[] = []; 
primes.push(2); 
primes.push(3); </pre>
<p>If we want to have an array, which seems heterogeneous, similar to the arrays in JavaScript, we can use the <kbd>any[]</kbd> type:</p>
<pre>let randomItems: any[] = []; 
randomItems.push(1); 
randomItems.push('foo'); 
randomItems.push([]); 
randomItems.push({}); </pre>
<p>This is possible since the types of all the values we're pushing to the array are subtypes of the <kbd>any</kbd> type and the array we've declared contains values of the <kbd>any</kbd> type.</p>
<p>We can use the array methods we're familiar with in JavaScript with all the TypeScript Array types:</p>
<pre>let randomItems: any[] = []; 
randomItems.push('foo'); 
randomItems.push('bar'); 
randomItems.join(''); // foobar 
randomItems.splice(1, 0, 'baz'); 
randomItems.join(''); // foobazbar </pre>
<p>We also have the square-brackets operator that gives us random access to the elements of the array:</p>
<pre>let randomItems: any[] = []; 
randomItems.push('foo'); 
randomItems.push('bar'); 
randomItems[0] === 'foo' 
randomItems[1] === 'bar' </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Function types</h1>
                </header>
            
            <article>
                
<p>We're already familiar with how to define a new function in JavaScript. We can use function expression or function declaration:</p>
<pre>// function expression 
var isPrime = function (n) { 
  // body 
};
 
// function declaration 
function isPrime(n) { 
  // body 
}; </pre>
<p>Alternatively, we can use the new arrow function syntax:</p>
<pre>var isPrime = n =&gt; { 
  // body 
}; </pre>
<p>The only thing TypeScript alters is the feature to define the types of the arguments of the function and the type of its return result (that is, the signature of the function). After the compiler of the language performs its type checking and transpilation, all the type annotations will be removed. If we use function expression and assign a function to a variable, we will be able to define the variable type in the following way:</p>
<pre>let variable: (arg1: type1, arg2: type2, ..., argn: typen) =&gt; returnType </pre>
<p>Consider the following example:</p>
<pre>let isPrime: (n: number) =&gt; boolean = n =&gt; { 
  // body 
}; </pre>
<p>If we want to define a method in an object literal, we can do it in the following way:</p>
<pre>let math = { 
  squareRoot(n: number): number { 
    // ... 
  } 
}; </pre>
<p>In the preceding example, we defined an object literal with the method called <kbd>squareRoot</kbd> using the ES2015 syntax.</p>
<p>In case we want to define a function that produces some side effects instead of returning a result, we can declare its return type as <kbd>void</kbd>:</p>
<pre>let person = { 
  _name: null, 
  setName(name: string): void { 
    this._name = name; 
  } 
}; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining classes</h1>
                </header>
            
            <article>
                
<p>TypeScript classes are similar to what ES2015 offers. However, TypeScript alters the type declarations and adds more syntax sugar. For example, let's take the <kbd>Human</kbd> class we defined earlier:</p>
<pre>class Human { 
  static totalPeople = 0; 
  _name: string;
 
  constructor(name) { 
    this._name = name; 
    Human.totalPeople += 1; 
  }
 
  get name() { 
    return this._name; 
  }
 
  set name(val) { 
    this._name = val; 
  }
 
  talk() { 
    return `Hi, I'm ${this.name}!`; 
  } 
} </pre>
<p>There is no difference between the current TypeScript definition and the one we already introduced; however, in this case, the declaration of the <kbd>_name</kbd> property is mandatory. Here is how we can use the class:</p>
<pre>let human = new Human('foo'); 
console.log(human._name); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using access modifiers</h1>
                </header>
            
            <article>
                
<p>Similarly, for most conventional object-oriented languages that support classes, TypeScript allows a definition of access modifiers. In order to deny direct access to the <kbd>_name</kbd> property outside the class it is defined in, we can declare it as private:</p>
<pre>class Human { 
  static totalPeople = 0; 
  private _name: string; 
  // ... 
} </pre>
<p>The supported access modifiers by TypeScript are as follows:</p>
<ul>
<li><strong>Public</strong>: All the properties and methods declared as public can be accessed from anywhere</li>
<li><strong>Private</strong>: All the properties and methods declared as private can be accessed only from inside the definition of the class itself</li>
<li><strong>Protected</strong>: All the properties and methods declared as protected can be accessed from inside the definition of the class or the definition of any other class extending the one that owns the property or the method</li>
</ul>
<p>Access modifiers are a great way to implement Angular services with good encapsulation and a well-defined interface. In order to understand this concept better, let's take a look at an example using the hierarchy of the class defined earlier, which is ported to TypeScript:</p>
<pre>class Human { 
  static totalPeople = 0;
 
  constructor(protected name: string, private age: number) { 
    Human.totalPeople += 1; 
  }
 
  talk() { 
    return `Hi, I'm ${this.name}!`; 
  } 
} 
 
class Developer extends Human { 
  constructor(name: string, private languages: string[], age: number) { 
    super(name, age); 
  }
 
  talk() { 
    return `${super.talk()} And I know ${this.languages.join(', ')}.`; 
  } 
} </pre>
<p>Just like ES2015, TypeScript supports the <kbd>extends</kbd> keyword and desugars it to the prototypal JavaScript inheritance.</p>
<p>In the preceding example, we set the access modifiers of the <kbd>name</kbd> and <kbd>age</kbd> properties directly inside the constructor function. The semantics behind this syntax differs from the one used in the previous example. It has the following meaning: define a protected property called <kbd>name</kbd> of the <kbd>string</kbd> type and assign the first value passed to the constructor call to it. It is the same for the private <kbd>age</kbd> property. This saves us from explicitly setting the value in the constructor itself. If we take a look at the constructor of the <kbd>Developer</kbd> class, we can see that we can use the mixture between these syntaxes. We can explicitly define the property in the constructor's signature, or we can only define that the constructor accepts a parameters of the given types.</p>
<p>Now, let's create a new instance of the <kbd>Developer</kbd> class:</p>
<pre>let dev = new Developer('foo', ['JavaScript', 'Go'], 42); 
dev.languages = ['Java']; </pre>
<p>During compilation, TypeScript will throw an error telling us that:</p>
<p><kbd>Property languages is private and only accessible inside the class "Developer"</kbd>. Now, let's see what will happen if we create a new <kbd>Human</kbd> class and try to access its properties from outside its definition:</p>
<pre>let human = new Human('foo', 42); 
human.age = 42; 
human.name = 'bar'; </pre>
<p>In this case, we'll get the following two errors:</p>
<p><kbd>Property age is private and is only accessible inside the class "Human"</kbd>, and the <kbd>Property name is a protected and only accessible inside class "Human" and its subclasses</kbd>.</p>
<p>However, if we try to access the <kbd>_name</kbd> property from inside the definition of <kbd>Developer</kbd>, the compiler won't throw any errors.</p>
<p>In order to get a better sense of what the TypeScript compiler will produce out of a type-annotated class, let's take a look at the JavaScript produced by the following definition:</p>
<pre>class Human { 
  constructor(private name: string) {} 
} </pre>
<p>The resulting ECMAScript 5 will be as follows:</p>
<pre>var Human = (function () { 
    function Human(name) { 
        this.name = name; 
    } 
    return Human; 
})(); </pre>
<p>The defined property will be added directly to the objects instantiated when calling the constructor function with the <kbd>new</kbd> operator. This means that once the code is compiled, we can directly access the private members of the created objects.</p>
<p>In order to wrap this up, access modifiers are added in the language in order to help us enforce better encapsulation and get compile-time errors in case we violate it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining interfaces</h1>
                </header>
            
            <article>
                
<p><strong>Subtyping</strong> in programming languages allows us to treat objects in the same way based on the observation that they are specialized versions of a generic object. This doesn't mean that they have to be instances of the same class of objects, or that they have a complete intersection between their interfaces. The objects might have only a few common properties and still be treated the same way in a specific context. In JavaScript, we usually use duck typing. We may invoke specific methods for all the objects passed to a function based on the assumption that these methods exist. However, all of us have experienced the <kbd>undefined is not a function</kbd> error thrown by the JavaScript interpreter.</p>
<p>Object-oriented programming and TypeScript come with a solution. They allow us to make sure that our objects have similar behavior if they implement interfaces that declare the subset of the properties they own.</p>
<p>For example, we can define an interface as <kbd>Accountable</kbd>:</p>
<pre>interface Accountable { 
  getIncome(): number; 
} </pre>
<p>Now, we can make sure that both <kbd>Individual</kbd> and <kbd>Firm implement</kbd> this interface by performing the following:</p>
<pre>class Firm implements Accountable { 
  getIncome(): number { 
    // ... 
  } 
}
 
class Individual implements Accountable { 
  getIncome(): number { 
    // ... 
  } 
} </pre>
<p>In case we implement a given interface, we need to provide an implementation for all the methods defined inside it, otherwise, the TypeScript compiler will throw an error. The methods we implement must have the same signature as the ones declared in the interface definition.</p>
<p>TypeScript interfaces also support properties. In the <kbd>Accountable</kbd> interface, we can include a field called <kbd>accountNumber</kbd> with a type of string:</p>
<pre>interface Accountable { 
  accountNumber: string; 
  getIncome(): number; 
} </pre>
<p>We can define it in our class as a field or a getter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interface inheritance</h1>
                </header>
            
            <article>
                
<p>Interfaces may also extend each other. For example, we may turn our <kbd>Individual</kbd> class into an interface that has a social security number:</p>
<pre>interface Accountable { 
  accountNumber: string; 
  getIncome(): number; 
}
 
interface Individual extends Accountable { 
  ssn: string; 
} </pre>
<p>Since interfaces support multiple inheritances, <kbd>Individual</kbd> may also extend the <kbd>Human</kbd> interface that has the <kbd>name</kbd> and <kbd>age</kbd> properties:</p>
<pre>interface Accountable { 
  accountNumber: string; 
  getIncome(): number; 
}
 
interface Human { 
  age: number; 
  name: number; 
}
 
interface Individual extends Accountable, Human { 
  ssn: string; 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing multiple interfaces</h1>
                </header>
            
            <article>
                
<p>In case the behavior of the class is a union of the properties defined in a couple of interfaces, it may implement all of them:</p>
<pre>class Person implements Human, Accountable { 
  age: number; 
  name: string; 
  accountNumber: string;
 
  getIncome(): number { 
    // ... 
  } 
} </pre>
<p>In this case, we need to provide the implementation of all the methods and properties declared inside the interfaces our class implements, otherwise, the compiler will throw a compile-time error.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further expressiveness with TypeScript decorators</h1>
                </header>
            
            <article>
                
<p>In ES2015, we are able to decorate only classes, properties, methods, getters, and setters. TypeScript takes this further by allowing us to decorate functions or method parameters:</p>
<pre>class Http { 
  // ... 
}
 
class GitHubApi { 
  constructor(@Inject(Http) http) { 
    // ... 
  } 
} </pre>
<p>Keep in mind that the parameter decorators should not alter any additional behavior. Instead, they are used to generate metadata. The most typical use case of these decorators is the dependency injection mechanism of Angular.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing generic code using type parameters</h1>
                </header>
            
            <article>
                
<p>In the beginning of the section on using static typing, we mentioned the type parameters. In order to get a better understanding of them, let's begin with an example. Let's suppose that we want to implement the classical data structure <kbd>BinarySearchTree</kbd>. Let's define its interface using a class without applying any method implementations:</p>
<pre>class Node { 
  value: any; 
  left: Node; 
  right: Node; 
} 
 
class BinarySearchTree { 
  private root: Node; 
  insert(any: value): void { /* ... */ } 
  remove(any: value): void { /* ... */ } 
  exists(any: value): boolean { /* ... */ } 
  inorder(callback: {(value: any): void}): void { /* ... */ } 
} </pre>
<p>In the preceding snippet, we defined a class called <kbd>Node</kbd>. The instances of this class represent the individual nodes in our tree. Each node has a <kbd>left</kbd> and <kbd>right</kbd> child nodes and a value of the <kbd>any</kbd> type; we use <kbd>any</kbd> in order to be able to store data of any type inside our nodes and subsequently inside <kbd>BinarySearchTree</kbd>.</p>
<p>Although the earlier implementation looks reasonable, we're giving up on using the most important feature that TypeScript provides, that is, static typing. Using <kbd>any</kbd> as a type of the value field inside the <kbd>Node</kbd> class, we can't take complete advantage of the compile-time type checking. This also limits the autocompletion and refactoring features that IDEs and text editors provide when we access the <kbd>value</kbd> property of the instances of the <kbd>Node</kbd> class.</p>
<p>TypeScript comes with an elegant solution that is already widely popular in the world of static typing: type parameters. Using generics, we can parameterize the classes we create with the type parameters. For example, we can turn our <kbd>Node</kbd> class into the following:</p>
<pre>class Node&lt;T&gt; { 
  value: T; 
  left: Node&lt;T&gt;; 
  right: Node&lt;T&gt;; 
} </pre>
<p>Here, <kbd>Node&lt;T&gt;</kbd> indicates that this class has a single type parameter called <kbd>T</kbd> that is used somewhere inside the definition of the class. We can use <kbd>Node</kbd> by performing the following snippet:</p>
<pre>let numberNode = new Node&lt;number&gt;(); 
let stringNode = new Node&lt;string&gt;(); 
numberNode.right = new Node&lt;number&gt;(); 
numberNode.value = 42; 
numberNode.value = '42'; // Type "string" is not assignable to type "number" 
numberNode.left = stringNode; // Type Node&lt;string&gt; is not assignable to type Node&lt;number&gt; </pre>
<p>In the preceding snippet, we created three nodes: <kbd>numberNode</kbd>, <kbd>stringNode</kbd>, and another node of the <kbd>Node&lt;number&gt;</kbd> type, assigning its value to the right child of <kbd>numberNode</kbd>. Note that since <kbd>numberNode</kbd> is of the <kbd>Node&lt;number&gt;</kbd> type, we can set its value to <kbd>42</kbd>, but we can't use the <kbd>'42'</kbd> string. The same is applicable to its left child. In the definition, we've explicitly declared that we want the left and right children to be of the <kbd>Node&lt;number&gt;</kbd> type. This means that we cannot assign values of the <kbd>Node&lt;string&gt;</kbd> type to them; this is why, we get the second compile-time error.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using generic functions</h1>
                </header>
            
            <article>
                
<p>Another typical use of generics is for defining functions that operate over a set of types. For example, we may define an <kbd>identity</kbd> function that accepts an argument of type <kbd>T</kbd> and returns it:</p>
<pre>function identity&lt;T&gt;(arg: T) { 
  return arg; 
} </pre>
<p>However, in some cases, we may want to use only the instances of the types that have some specific properties. For achieving this, we can use an extended syntax that allows us to declare that we want the types used as type parameters to be subtypes of the given type:</p>
<pre>interface Comparable { 
  compare(a: Comparable): number; 
}
 
function sort&lt;T extends Comparable&gt;(arr: Comparable[]): Comparable[] { 
  // ... 
} </pre>
<p>For example, here, we defined an interface called <kbd>Comparable</kbd>. It has a single operation called <kbd>compare</kbd>. The classes that implement the <kbd>Comparable</kbd> interface need to implement the <kbd>compare</kbd> operation. When <kbd>compare</kbd> is called with a given argument, it returns <kbd>1</kbd> if the target object is bigger than the passed argument, <kbd>0</kbd> if they are equal, and <kbd>-1</kbd> if the target object is smaller than the passed argument.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Having multiple type parameters</h1>
                </header>
            
            <article>
                
<p>TypeScript allows us to use multiple type parameters:</p>
<pre>class Pair&lt;K, V&gt; { 
  key: K; 
  value: V; 
} </pre>
<p>In this case, we can create an instance of the <kbd>Pair&lt;K, V&gt;</kbd> class using the following syntax:</p>
<pre>let pair = new Pair&lt;string, number&gt;(); 
pair.key = 'foo'; 
pair.value = 42; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing less verbose code with the type inference of TypeScript</h1>
                </header>
            
            <article>
                
<p>Static typing has a number of benefits; however, it makes us write a more verbose code by adding all the type annotations.</p>
<p>In some cases, the compiler of TypeScript is able to guess the types of expressions inside our code; let's consider this example:</p>
<pre>let answer = 42; 
answer = '42'; // Type "string" is not assignable to type "number" </pre>
<p>In the preceding snippet, we defined an <kbd>answer</kbd> variable and assigned the value <kbd>42</kbd> to it. Since TypeScript is statically typed and the type of a variable cannot change once declared, the compiler is smart enough to guess that the type of <kbd>answer</kbd> is <kbd>number</kbd>.</p>
<p>If we don't assign a value to a variable within its definition, the compiler will set its type to <kbd>any</kbd>:</p>
<pre>let answer; 
answer = 42; 
answer = '42'</pre>
<p>The preceding snippet will compile without any compile-time errors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Best common type</h1>
                </header>
            
            <article>
                
<p>Sometimes, the type inference could be a result of several expressions. Such is the case when we assign a heterogeneous array to a variable:</p>
<pre>let x = ['42', 42]; </pre>
<p>In this case, the type of <kbd>x</kbd> will be <kbd>any[]</kbd>. However, suppose we have the following:</p>
<pre>let x = [42, null, 32]; </pre>
<p>The type of <kbd>x</kbd> will then be <kbd>number[]</kbd> since the <kbd>Number</kbd> type is a subtype of <kbd>Null</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Contextual type inference</h1>
                </header>
            
            <article>
                
<p>Contextual typing occurs when the type of an expression is implied from its location; let's take this example:</p>
<pre>document.body.addEventListener('mousedown', e =&gt; { 
  e.foo(); // Property "foo" does not exists on a type "MouseEvent" 
}, false); </pre>
<p>In this case, the type of the argument of the <kbd>e</kbd> callback is <em>guessed</em> by the compiler based on the context in which it is used. The compiler understands that the type of <kbd>e</kbd> is based on the call of <kbd>addEventListener</kbd> and the arguments passed to the method. In case we were using a keyboard event (<kbd>keydown</kbd>, for example), TypeScript would have been aware that <kbd>e</kbd> is of the <kbd>KeyboardEvent</kbd> type.</p>
<p>Type inference is a mechanism that allows us to write less verbose code by taking advantage of the static analysis performed by TypeScript. Based on the context, the compiler of TypeScript is able to guess the type of a given expression without explicit definition.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing structural typing</h1>
                </header>
            
            <article>
                
<p>An important feature of the type system of TypeScript is that it's <strong>structurally typed</strong>. Formally this means that the types equivalence and compatibility are determined by the structure of the types, not by other characteristics such as name or inheritance hierarchy.</p>
<p>This may sound quite abstract at first, so let's take a look at a specific example:</p>
<pre>// ch4/structural-typing/example.ts<br/><br/>interface Namable {<br/>  name: string;<br/>}<br/><br/>class Cat {<br/>  name: string;<br/>}<br/><br/>class Castle {<br/>  name: string;<br/>  capacity: string;<br/>}<br/><br/>const formatName = (obj: Namable) =&gt; `The name is ${obj.name}`;</pre>
<p>The preceding snippet defines an interface called <kbd>Namable</kbd>, which has a declaration of a single property called <kbd>name</kbd>. We also define the <kbd>Cat</kbd> and <kbd>Castle</kbd> classes: both of them having a <kbd>name</kbd> property but neither of them implementing the <kbd>Namable</kbd> interface.</p>
<p>If we invoke <kbd>formatName</kbd> with a new instance of <kbd>Cat</kbd> or <kbd>Castle</kbd>, the code will compile just fine:</p>
<pre>const cat = new Cat();<br/>cat.name = 'Kitty';<br/><span>formatName(cat);</span><br/><br/>const castle = new Castle();<br/>castle.name = 'Hogwarts';<br/>formatName(castle);</pre>
<p>In this case, we won't get any compile type errors because the properties that the <kbd>Namable</kbd> interface declares are a subset of the properties declared by <kbd>Cat</kbd> and <kbd>Castle</kbd>. Although in this case, the explicit interface implementation may look unnecessary, it's much more convenient to have it because during development of a given class; we'll get an inline error in our text editor or IDE in case of incorrect interface implementation. <span>To some of the readers, this may look familiar to the <em>implicit interface implementation</em> in Go, however, we can go one step further.</span></p>
<p>Now let's take the signature of <kbd>formatName</kbd> to the following:</p>
<pre>const formatName = (obj: Cat) =&gt; `The name is ${obj.name}`;</pre>
<p>Now we can perform this:</p>
<pre>formatName(new Castle());</pre>
<p>If we invoke <kbd>formatName</kbd> with an instance of <kbd>Castle</kbd>, the code will compile just fine again! This is due to compatibility of the <kbd>Cat</kbd> and <kbd>Castle</kbd> classes: the <kbd>Cat</kbd> class has a subset of the properties declared by <kbd>Castle</kbd>. This may look unnatural to developers used to nominal typing, since in this case <kbd>Cat</kbd> and <kbd>Castle</kbd> are not in the same inheritance chain.</p>
<p>Now, let's change the definition of the <kbd>Cat</kbd> class definition to the following:</p>
<pre>class Cat {<br/>  name: string;<br/>  breed: string;<br/>}</pre>
<p>If we keep the same signature of the <kbd>formatName</kbd> function, then invoking <kbd>formatName</kbd> with an instance of <kbd>Castle</kbd> will produce an error:</p>
<pre>const formatName = (obj: Cat) =&gt; `The name is ${obj.name}`;<br/><br/>formatName(new Castle());<br/>// Argument of type 'Castle' is not assignable to parameter of type 'Cat'.<br/>//  Property 'breed' is missing in type 'Castle'.</pre>
<p>As the compilation error says, we cannot pass objects instances of a class that lacks some of the properties or methods of the type of the parameter of a given function or method signature.</p>
<p>Now that we're familiar with structural typing, let's go to our next stop: ambient type definitions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using ambient type definitions</h1>
                </header>
            
            <article>
                
<p>Although static typing is amazing, most of the frontend libraries we use are built with JavaScript, which is dynamically typed. Since we'd want to use TypeScript with Angular, not having type definitions in the code that uses external JavaScript libraries is a big issue; it prevents us from taking advantage of the compile-time type checking.</p>
<p>TypeScript was built keeping these points in mind. In order to allow the TypeScript compiler to take care of what it does best, we can use the so called ambient type definitions. They allow us to provide external type definitions for the existing JavaScript libraries. This way, they provide hints to the compiler.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using predefined ambient type definitions</h1>
                </header>
            
            <article>
                
<p>Fortunately, we don't have to create ambient type definitions for all JavaScript libraries and frameworks we use. The community and/or the authors of these libraries have already published such definitions online; the biggest repository resides at <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">https://github.com/DefinitelyTyped/DefinitelyTyped</a>. During the last couple of months, the community developed a few tools for managing ambient type definitions, such as <kbd>tsd</kbd> and <kbd>typings</kbd>.</p>
<p>Later, Microsoft introduced an official way to manage them: using <strong><kbd>npm</kbd></strong> by providing an additional configuration in <kbd>tsconfig.json</kbd>. The type definitions are now distributed as scoped packages under the <kbd>@types</kbd> namespace and installed in <kbd>node_modules</kbd>.</p>
<p>Let's create a directory and add a <kbd>package.json</kbd> file to it:</p>
<pre><strong>$ mkdir types-test &amp;&amp; cd types-test &amp;&amp; npm init</strong></pre>
<p>After we provide the default values for the properties that <kbd>npm</kbd> asks us, our <kbd>package.json</kbd>  file in the <kbd>types-test</kbd> directory should look something like this:</p>
<pre>{
  "name": "types-test",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo "Error: no test specified" &amp;&amp; exit 1"
  },
  "author": "",
  "license": "ISC"
}</pre>
<p>We can install a new type definition using this command:</p>
<pre><strong>$ npm install @types/angular --save-dev</strong></pre>
<p>The preceding command will download the type definitions for AngularJS and save them in <kbd>node_modules/@types/angular</kbd>. Note that we provided the <kbd>--save-dev</kbd> flag to <kbd>npm</kbd> in order to save the type definition under <kbd>devDependencies</kbd> of <kbd>package.json</kbd>.</p>
<p> </p>
<div class="packt_tip">When installing ambient type definitions, we would usually use <kbd>--save-dev</kbd> instead of <kbd>--save</kbd>, because the definitions are mostly used in development.</div>
<p>After running the preceding command, your <kbd>package.json</kbd> file should look similar to this:</p>
<pre>{
  "name": "types-test",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo "Error: no test specified" &amp;&amp; exit 1"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@types/angular": "^1.5.20"
  }
}</pre>
<p>Now, in order to use AngularJS with TypeScript, create <kbd>app.ts</kbd> and enter the following content:</p>
<pre>/// &lt;reference path="./node_modules/@types/angular/index.d.ts"/&gt; 
 
var module = angular.module('module', []); 
module.controller('MainCtrl', 
  function MainCtrl($scope: angular.IScope) { 
 
  }); </pre>
<p>To compile <kbd>app.ts</kbd>, use the following command:</p>
<pre><strong>$ tsc app.ts</strong></pre>
<p>The TypeScript compiler will output the compiled content into <kbd>app.js</kbd>. In order to add extra automation and invoke the TypeScript compiler each time we change any of the files in our project, we can use a task runner, such as gulp or grunt, or pass the <kbd>-w</kbd> option to <kbd>tsc</kbd>.</p>
<div class="packt_infobox"><span>Since using the</span> <kbd>reference</kbd> <span>element for including type definitions is considered bad practice, we can use a</span> <kbd>tsconfig.json</kbd> <span>file instead. There, we can configure which directories need to be included in the compilation process by</span> <kbd>tsc</kbd><span>. For more information, visit</span> <a href="http://www.typescriptlang.org/docs/handbook/tsconfig-json.html">http://www.typescriptlang.org/docs/handbook/tsconfig-json.html</a><span>.</span></div>
<p>Now, let's create a file called <kbd>tsconfig.json</kbd> in the same directory, with the following content:</p>
<pre>{
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "experimentalDecorators": true,
    "outDir": "./dist"
  },
  "files": [
    "./app.ts"
  ]
}</pre>
<p>In this configuration file, we provide the <kbd>compilerOptions</kbd> property so that we don't have to pass parameters, such as <kbd>outDir</kbd> and <kbd>module</kbd> formats, as flags to <kbd>tsc</kbd>. Note that in the <kbd>files</kbd> property, we also list the files that we want to be compiled. TypeScript will compile all of them plus all their transitive dependencies!</p>
<p>Now, let's modify our preceding simple snippet:</p>
<pre>var module = angular.module('module', []); 
module.controller('MainCtrl', 
  function MainCtrl($scope: angular.IScope) { 
    const set = new Set&lt;any&gt;();
  });</pre>
<p>The only change we made was to add the line where we declare and initialize a new constant with the returned result by the invocation of the <kbd>Set</kbd> constructor function, with <kbd>any</kbd> as the type parameter. By having <kbd>tsconfig.json</kbd> in the same directory where our <kbd>app.ts</kbd> file and <kbd>node_modules</kbd> are, we can compile the project by running this command:</p>
<pre><strong>$ tsc</strong></pre>
<p>However, we'll get the following error:</p>
<p><kbd>demo.ts(4,22): error TS2304: Cannot find name 'Set'</kbd><span class="packt_screen">.</span></p>
<p>Here, <kbd>Set</kbd> implements the set data structure and is part of the ES2015 standard. Since using the ambient type definitions for ES2015 is a very common practice in all TypeScript projects, Microsoft added them as part of TypeScript itself. To the <kbd>compilerOptions</kbd> property inside <kbd>tsconfig.json</kbd>, add the following <kbd>lib</kbd> property:</p>
<pre>{
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "experimentalDecorators": true,
    "outDir": "./dist",
    "lib": ["es2015", "dom"]
  },
  "files": [
    "./demo.ts"
  ]
}</pre>
<p>Here, <kbd>lib</kbd> has the value of an array, which includes both <kbd>"es2015"</kbd> and <kbd>"dom"</kbd> because we need ES2015 Set, and the type definitions of Angular require the type definitions for the <strong>Document Object Model</strong> (<strong>DOM</strong>). Now when we run <kbd>tsc</kbd> in the directory where your <kbd>tsconfig.json</kbd> file is located, the compilation process should pass successfully and the output file should be located in <kbd>./dist/demo.js</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom ambient type definitions</h1>
                </header>
            
            <article>
                
<p>To understand how everything works together, let's take a look at an example. Suppose, we have the following interface of a JavaScript library:</p>
<pre>var DOM = { 
  // Returns a set of elements which match the passed selector 
  selectElements: function (selector) { 
    // ... 
  }, 
  hide: function (element) { 
    // ... 
  }, 
  show: function (element) { 
    // ... 
  } 
}; </pre>
<p>We have an object literal assigned to a variable called <kbd>DOM</kbd>. The object has the following methods:</p>
<ul>
<li><kbd>selectElements</kbd>: This accepts a single argument with the <kbd>string</kbd> type and returns a set of <kbd>DOM</kbd> elements</li>
<li><kbd>hide</kbd>: This accepts a <kbd>DOM</kbd> node as an argument and returns nothing</li>
<li><kbd>show</kbd>: This accepts a <kbd>DOM</kbd> node as an argument and returns nothing</li>
</ul>
<p>In TypeScript, the preceding definition would look as follows:</p>
<pre>var DOM = { 
  // Returns a set of elements which match the passed selector 
  selectElements: function (selector: string): HTMLElement[] { 
    //...
    return []; 
  }, 
  hide: function (element: HTMLElement): void { 
    element.hidden = true; 
  }, 
  show: function (element: HTMLElement): void { 
    element.hidden = false; 
  } 
}; </pre>
<p>This means that we can define the interface of our library as follows:</p>
<pre>interface LibraryInterface { 
  selectElements(selector: string): HTMLElement[] 
  hide(element: HTMLElement): void 
  show(element: HTMLElement): void 
} </pre>
<p>After we have the interface of our library, it will be easy to create the ambient type definition; we just have to create a file with a <kbd>d.ts</kbd> extension called <kbd>dom</kbd> and enter the following content:</p>
<pre>// inside "dom.d.ts" 
 
interface DOMLibraryInterface { 
  selectElements(selector: string): HTMLElement[] 
  hide(element: HTMLElement): void 
  show(element: HTMLElement): void 
} 
 
declare var DOM: DOMLibraryInterface; </pre>
<p>In the preceding snippet, we defined the interface called <kbd>DOMLibraryInterface</kbd> and declared the <kbd>DOM</kbd> variable of the <kbd>DOMLibraryInterface</kbd> type.</p>
<p>The only thing left before being able to use static typing with our JavaScript library is including the external type definition in the script files we want to use our library in. We can do it as follows:</p>
<pre>/// &lt;reference path="dom.d.ts"/&gt; </pre>
<p>The preceding snippet hints the compiler on where to find the ambient type definitions. An alternative, and better, way to provide a reference to the <kbd>d.ts</kbd> file is to use <kbd>tsconfig.json</kbd> as described earlier.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we made an introduction to the TypeScript language that is used for the implementation of Angular.</p>
<p>While exploring the language, we looked at some of the core features of ES2015 and ES2016. We explained the ES2015 and ES2016 classes, arrow functions, block scope variable definitions, destructuring, and modules. Since Angular takes advantage of the ES2016 decorators, and more accurately their extension in TypeScript, a section was dedicated to them.</p>
<p>After this, we took a look at how we can take advantage of static typing using explicit type definitions. We described some of the built-in types in TypeScript and how we can define classes in the language by specifying access modifiers for their members. Our next stop was the interfaces. We ended our adventures in TypeScript by explaining the type parameters, structural typing, and the ambient type definitions.</p>
<p>In the next chapters, we will explore Angular in depth starting with the components and directives of the framework.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>