- en: 6\. Routing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 路由
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will understand how routing and Vue Router work. We will
    also set up, implement, and manage the routing system in our app with Vue Router.
    Then we will look at dynamic routing for passing parameter values and nested routes
    for better reusability in complex applications. In addition, we will look at JavaScript
    Hooks, which can be used for features such as authentication and error handling.
    By the end of this chapter, you will be ready to handle static and dynamic routing
    in any Vue application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解路由和Vue Router是如何工作的。我们还将使用Vue Router在我们的应用中设置、实现和管理路由系统。然后我们将探讨动态路由以传递参数值，以及嵌套路由以在复杂应用中提高复用性。此外，我们还将探讨JavaScript钩子，这些钩子可用于认证和错误处理等功能。到本章结束时，您将准备好在任何Vue应用中处理静态和动态路由。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '`website.com/about` into their URL bar, they are routed to the about page.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在他们的URL栏中输入`website.com/about`，他们将被路由到关于页面。
- en: With **Single-Page Applications** (**SPAs**), routing allows navigation within
    the application to be done smoothly and without the need for page refreshing.
    In web development, routing is the matching mechanism by which we decide how to
    connect HTTP requests to the code that handles them. We use routing whenever there
    is a need for URL navigation in our application. Most modern web applications
    contain a lot of different URLs, even single-page ones. Thus, routing plays a
    significant role in creating a navigation system and helps users move around our
    application and the web quickly.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在**单页应用**（**SPAs**）中，路由允许在应用内部进行平滑导航，无需刷新页面。在Web开发中，路由是我们决定如何将HTTP请求连接到处理它们的代码的匹配机制。当我们的应用需要URL导航时，我们使用路由。大多数现代Web应用包含大量不同的URL，即使是单页应用。因此，路由在创建导航系统方面发挥着重要作用，并帮助用户快速在我们的应用和网络上移动。
- en: In short, routing is a way for an application to interpret what resource users
    want based on the URL provided. It is a system for web-based resource navigation
    with URLs, such as paths to assets (images and videos), scripts, and stylesheets.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，路由是应用根据提供的URL解释用户想要什么资源的一种方式。它是一个基于URL的Web资源导航系统，例如资产（图像和视频）、脚本和样式的路径。
- en: Vue Router
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue Router
- en: Vue Router, as stated in the Vue.js documentation, is officially recommended
    as a router service for any Vue.js application. It provides a single entry point
    for communication between components with routes, hence controlling the flow of
    the application effectively, regardless of the user's behavior.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Vue.js文档所述，Vue Router被官方推荐为任何Vue.js应用的路由服务。它提供了一个组件间通过路由进行通信的单个入口点，因此可以有效地控制应用流程，无论用户的行为如何。
- en: With a wide range of features, it eases the process of switching pages without
    the need to refresh the page.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过丰富的功能，它简化了页面切换的过程，无需刷新页面。
- en: Setting Up Vue Router
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Vue Router
- en: 'Vue Router is not installed by default; however, it can easily be enabled when
    creating an application with Vue CLI. Create an application by running the following
    command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Vue Router默认未安装；然而，当使用Vue CLI创建应用时，它很容易被启用。通过运行以下命令创建应用：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Select the `Manually select features` option as shown in *Figure 6.1*:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 选择如图6.1所示的`手动选择功能`选项：
- en: '![Figure 6.1: Select the manual preset to create a new Vue.js project'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1：选择手动预设以创建新的Vue.js项目'
- en: '](img/B15218_06_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_06_01.jpg)'
- en: 'Figure 6.1: Select the manual preset to create a new Vue.js project'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：选择手动预设以创建新的Vue.js项目
- en: After choosing the option to manually select features, you will be shown a list
    of features as presented in *Figure 6.2*. At the time of writing, by default `Babel`
    and `Linter / Formatter` are selected. Using the *down arrow* key, navigate to
    the `Router` option. With the option highlighted, press the *spacebar* to enable
    it, and then press *Enter* to continue.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择手动选择功能选项后，您将看到如图6.2所示的特性列表。在撰写本文时，默认选中了`Babel`和`Linter / Formatter`。使用*下箭头*键，导航到`Router`选项。当选项高亮时，按*空格键*启用它，然后按*Enter键*继续。
- en: '![Figure 6.2: Add Vue Router to the project'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2：将Vue Router添加到项目中'
- en: '](img/B15218_06_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_06_02.jpg)'
- en: 'Figure 6.2: Add Vue Router to the project'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：将Vue Router添加到项目中
- en: 'Next, you will be shown a prompt asking if you want to use `history mode` for
    router configuration, as shown in *Figure 6.3*. Enable history mode by entering
    `Y`. History mode allows navigating between pages without the reload required
    by the default hash mode. We''ll compare the two modes more closely later in the
    chapter:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将看到一个提示，询问你是否想为路由配置使用`history mode`，如图6.3所示。通过输入`Y`启用历史模式。历史模式允许在不需要默认hash模式重新加载的情况下在页面之间导航。我们将在本章稍后更详细地比较这两种模式：
- en: '![Figure 6.3: Configure Vue Router with history mode'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3：使用历史模式配置Vue Router](img/B15218_06_03.jpg)'
- en: '](img/B15218_06_03.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_06_03.jpg](img/B15218_06_03.jpg)'
- en: 'Figure 6.3: Configure Vue Router with history mode'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：使用历史模式配置Vue Router
- en: Finally, continue with the rest of the process and we will have a Vue.js application
    with Vue Router ready to use.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，继续进行其余的过程，我们将拥有一个准备就绪的Vue.js应用，其中包含Vue Router。
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you would like to add Vue Router to an existing Vue.js application, you
    can install it as an application''s dependency with the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将Vue Router添加到现有的Vue.js应用中，你可以使用以下命令将其作为应用依赖项安装：
- en: '`npm install vue-router`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm install vue-router`'
- en: The next step is to understand the basics of how `vue-router` performs synchronization
    between the browser URL and the application's view.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是理解`vue-router`如何实现浏览器URL与应用视图之间的同步的基本原理。
- en: First, let's look at the `router-view` element.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看`router-view`元素。
- en: The router-view Element
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由视图元素
- en: The `router-view` element is a **functional** component in which the app routing
    system loads the matched and up-to-date view content of any given URL path received
    from the user.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`router-view`元素是一个**功能性**组件，其中应用的路由系统加载用户接收到的任何给定URL路径的匹配和最新视图内容。'
- en: 'In short, `router-view` is a Vue component whose job is to do the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`router-view`是一个Vue组件，其任务是执行以下操作：
- en: Render different child components
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染不同的子组件
- en: Mount and unmount itself automatically at any nesting level, depending on the
    route's given path
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动在任意嵌套级别挂载和卸载，取决于给定的路由路径
- en: Without `router-view`, it is almost impossible to have dynamic content rendered
    correctly for users at runtime. For example, when a user navigates to the `Home`
    page, `router-view` knows and renders the content related to that page only.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用`router-view`，在运行时几乎不可能正确渲染动态内容。例如，当用户导航到`Home`页面时，`router-view`会知道并只渲染与该页面相关的内。
- en: In the next section, we will see how we can set the entry point (default route)
    of an application by passing it a prop.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何通过传递一个prop来设置应用的入口点（默认路由）。
- en: Using Props to Define the Entry Point of an Application
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Props定义应用的入口点
- en: Since `router-view` is a component, it can also receive props. The only prop
    it receives is `name`, which is the same name registered in the corresponding
    route's record defined in the `router` object at the initialization phase.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`router-view`是一个组件，它也可以接收props。它接收的唯一prop是`name`，这是在初始化阶段在`router`对象中定义的相应路由记录中注册的相同名称。
- en: 'Any other additional attributes are passed directly to the child component
    of `router-view` during rendering. Here is an example with a class attribute:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他额外的属性都会在渲染过程中直接传递给`router-view`的子组件。以下是一个带有class属性的示例：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If `router-view` renders as a child component, we can create an associated
    template where the layout is defined. A very simple example of a template is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`router-view`作为子组件渲染，我们可以在关联的模板中定义布局。一个非常简单的模板示例如下：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The child component receives the passed attribute class, and the actual output
    after rendering becomes the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 子组件接收传递的class属性，渲染后的实际输出如下：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Of course, for our template to be useful, it should also contain the `<router-view/>`
    element so that content we want to route has somewhere to be rendered. One common
    setup is to have a navigation menu within the template and `router-view` underneath.
    That way the content changes between pages but the menu stays the same.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了使我们的模板有用，它也应该包含`<router-view/>`元素，这样我们想要路由的内容就有地方渲染。一个常见的设置是在模板中有一个导航菜单，下面是`router-view`。这样，内容在页面之间变化，但菜单保持不变。
- en: 'Navigate to `App.vue` and ensure your template has the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`App.vue`并确保你的模板中有以下代码：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s remove all the code within `<div id="app">` and leave only one single
    `<router-view/>` component:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们移除`<div id="app">`内的所有代码，只留下一个单独的`<router-view/>`组件：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will now comment out all the code for `routes` as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将注释掉所有`routes`的代码，如下所示：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now our app output will be rendered as a blank page running on `localhost:8080`,
    as shown in *Figure 6.4*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应用的输出将渲染为在 `localhost:8080` 运行的空白页面，如图 6.4 所示：
- en: '![Figure 6.4: Hello Vue Router application in the browser'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.4：浏览器中的 Hello Vue Router 应用程序]'
- en: '](img/B15218_06_04.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_06_04.jpg]'
- en: 'Figure 6.4: Hello Vue Router application in the browser'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：浏览器中的 Hello Vue Router 应用程序
- en: The output is an empty page because we have not set up any router configurations
    in our file, including mapping the paths with the related view. Without this step,
    the routing system will not be able to pick the right view and render it into
    our `router-view` element dynamically.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个空白页面，因为我们没有在我们的文件中设置任何路由配置，包括将路径与相关视图进行映射。没有这一步，路由系统将无法选择正确的视图并将其动态渲染到我们的
    `router-view` 元素中。
- en: In the next section, we will see how to set up Vue Router.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何设置 Vue Router。
- en: Setting Up Vue Router for Vue to Use
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Vue 设置 Vue Router
- en: When we add Vue Router to our project, Vue CLI creates and adds a `router` folder
    to the code directory, containing a single auto-generated `index.js` file. This
    file contains the necessary configurations for our router.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 Vue Router 添加到我们的项目中时，Vue CLI 会创建并添加一个 `router` 文件夹到代码目录中，其中包含一个单独自动生成的
    `index.js` 文件。此文件包含我们路由所需的所有配置。
- en: We will navigate to the file and go through the basic predefined configuration
    for Vue Router.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导航到该文件，并查看 Vue Router 的基本预定义配置。
- en: 'First, you will notice that we need to import both `Vue` and `VueRouter` from
    the `vue` and `vue-router` packages, respectively. Then we call `Vue.use (VueRouter)`
    to install it as a plugin for use within our application:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你会注意到我们需要分别从 `vue` 和 `vue-router` 包中导入 `Vue` 和 `VueRouter`。然后我们调用 `Vue.use
    (VueRouter)` 来将其作为插件安装到我们的应用程序中：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Vue.use` is a global method, as discussed in *Chapter 5*, *Global Component
    Composition*. It triggers the internal `install` method of `VueRouter` together
    with the Vue constructor as soon as Vue is available as a global variable of the
    application. This method has a built-in mechanism to prevent installing a plugin
    more than once.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vue.use` 是一个全局方法，如第 5 章 *全局组件组合* 中所述。它触发 `VueRouter` 的内部 `install` 方法，以及 Vue
    构造函数，一旦 Vue 成为应用程序的全局变量。此方法具有内置机制以防止插件安装超过一次。'
- en: 'After executing `Vue.use(VueRouter)`, the following objects are available for
    access in any component:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `Vue.use(VueRouter)` 后，以下对象在任意组件中都可以访问：
- en: '`this.$router` – The global router object'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.$router` – 全局路由对象'
- en: '`this.$route` – The current route object'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.$route` – 当前路由对象'
- en: '`this` points to the component in context.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`this` 指的是上下文中的组件。'
- en: Now that we have registered the use of Vue Router in our application, let's
    move on to the next step – defining the routes for the configuration object of
    the router instance.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在应用程序中注册了 Vue Router 的使用，接下来进行下一步——定义路由实例的配置对象的路由。
- en: Defining the Routes
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义路由
- en: In a web application, a `route` is a URL path pattern and is mapped to a specific
    handler. The `handler`, in modern web development, is a component, defined and
    located in a physical file. For example, when the user enters the route `localhost:8080//home`,
    if `Home` is mapped to this specific route, the routing system knows to trigger
    the handler `Home` to render the content accordingly.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 Web 应用程序中，一个 `route` 是一个 URL 路径模式，并将其映射到特定的处理器。在现代 Web 开发中，`handler` 是一个组件，定义并位于一个物理文件中。例如，当用户输入路由
    `localhost:8080//home` 时，如果 `Home` 映射到这个特定的路由，路由系统就会知道触发处理器 `Home` 来相应地渲染内容。
- en: As seen in the preceding example, it is crucial to set up the routes (or paths)
    for navigation within the application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，设置应用程序内导航的路由（或路径）至关重要。
- en: 'Each route is an object literal whose properties are declared by the `RouteConfig` interface:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每个路由都是一个对象字面量，其属性由 `RouteConfig` 接口声明：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'All the routes needed for an application are located within the `Array` instance
    of `routes`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序所需的所有路由都位于 `routes` 的 `Array` 实例中：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, let's come back to the previous file, and uncomment the code inside `routes`.
    There will be two predefined routes, `home` and `about`, each as an object and
    located in the `routes` array, for our convenience.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到之前的文件，并取消注释 `routes` 中的代码。将会有两个预定义的路由，`home` 和 `about`，每个都是一个对象，位于 `routes`
    数组中，以便于我们使用。
- en: 'Let''s take a closer look at the first route as an example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以第一个路由为例，进行更详细的了解：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `path` property is a `/about` path will be translated into `<app domain>/about`
    (`localhost:8080/about` or `example.com/about`).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`path`属性是一个`/about`路径，将被转换为`<app domain>/about`（`localhost:8080/about`或`example.com/about`）。'
- en: In this case, Vue Router understands `/` – the empty path – as the default path
    for loading the application when there is no other indicator after the forward
    slash `/`, for example when the user navigates to `<app-domain>` or `<app-domain>/`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Vue Router将`/`——空路径——理解为在没有其他指示符（例如，当用户导航到`<app-domain>`或`<app-domain>/`）后的默认路径，用于加载应用程序。
- en: The next property is `name`, which is a string, indicating the name given to
    the targeted route. Even though it is **optional**, it's strongly recommended
    to have every route defined with a name, for better code maintenance and route
    tracking purposes, which we will discuss further later in this chapter, in the
    *Passing route parameters* section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个属性是`name`，它是一个字符串，表示分配给目标路由的名称。尽管它是**可选的**，但强烈建议为每个路由定义一个名称，以利于代码维护和路由跟踪，我们将在本章后面的*传递路由参数*部分进一步讨论。
- en: The last property is `component`, which is a Vue component instance. `router-view`
    uses this property as a reference to the view component to render the page content
    when the path is active.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个属性是`component`，它是一个Vue组件实例。`router-view`使用这个属性作为对视图组件的引用，在路径激活时渲染页面内容。
- en: Here we have the route defined as the `home` route, mapped as the default path
    to the application and tied to the `Home` component for content.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将路由定义为`home`路由，将其映射为应用的默认路径，并将其与`Home`组件关联以显示内容。
- en: Vue CLI also auto-generates two simple components for these two sample routes
    – `Home` and `About`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Vue CLI也为这两个示例路由自动生成了两个简单的组件——`Home`和`About`。
- en: In the next section, we'll go over some tips that can be helpful when loading
    components to be used with routes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍一些在加载与路由一起使用的组件时可能有所帮助的技巧。
- en: Tips on Loading Components for Route Configuration
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由配置中加载组件的技巧
- en: 'Certainly, we need to import the component to tie it to the targeted route
    in the same `index.js` file. The classic and most popular way is to import it
    at the top of the file, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要在同一个`index.js`文件中导入组件，将其与目标路由关联起来。最经典和最受欢迎的方法是在文件顶部导入，如下所示：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Often this will be added under the main imports as shown in *Figure 6.5*:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这会被添加到主导入之下，如*图6.5*所示：
- en: '![Figure 6.5: Import Home component on line 3 – src/router/index.js'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5：第3行导入Home组件 – src/router/index.js'
- en: '](img/B15218_06_05.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_06_05.jpg]'
- en: 'Figure 6.5: Import Home component on line 3 – src/router/index.js'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：第3行导入Home组件 – src/router/index.js
- en: However, a more efficient way is to lazy-load the component.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个更有效的方法是懒加载组件。
- en: '**Lazy loading**, also known as on-demand loading is a technique that aims
    to optimize the content of a website or web application at runtime. It helps to
    reduce the time consumption and amount of resources required to download for an
    application on the first load. This optimization is critical to ensure the best
    user experience possible, where every millisecond of waiting matters. Besides
    this, lazy loading also allows better code-splitting at the route level, along
    with performance optimization in large or complex applications.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**懒加载**，也称为按需加载，是一种旨在优化网站或Web应用程序在运行时内容的技术。它有助于减少首次加载应用程序时的时间和资源消耗。这种优化对于确保最佳的用户体验至关重要，因为每一毫秒的等待都很重要。除此之外，懒加载还允许在路由级别进行更好的代码拆分，并在大型或复杂应用程序中进行性能优化。'
- en: 'We can lazy-load the component with the benefit of using `webpack`. Instead
    of importing the `About` component at the top of the file, as we did with `Home`
    (see *Figure 6.5*), we can instead dynamically add the following right after defining
    the name for the `about` route:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用`webpack`的优势来懒加载组件。我们可以在定义`about`路由名称之后动态添加以下内容，而不是像处理`Home`组件那样在文件顶部导入`About`组件（参见*图6.5*）：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we dynamically lazy-load the `About` view component for the `about` route.
    During compilation, `webpack` generates a separate chunk with the designated name
    (`"about"`) for the `about` route, and only loads it when the user visits this
    route.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们动态地懒加载`about`路由的`About`视图组件。在编译过程中，`webpack`为`about`路由生成一个具有指定名称（`"about"`）的单独块，并且只有在用户访问此路由时才加载它。
- en: In most cases, since the user will likely land on the default path on the first
    go, it is better to not lazy-load the default component (`Home` in our app) but
    to import it in the normal way. Hence, the tip here is to determine which components
    should be lazy-loaded when designing your routing and combine the two methods
    for the most benefit.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，由于用户很可能会在第一次访问时停留在默认路径上，因此最好不懒加载默认组件（在我们的应用程序中是 `Home`），而是以正常方式导入它。因此，这里的建议是在设计路由时确定哪些组件应该被懒加载，并将两种方法结合起来以获得最大效益。
- en: We will now see how to set up the router instance.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看到如何设置路由实例。
- en: Setting up the Router Instance
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置路由实例
- en: 'After defining the routes, the final step is to create the `router` instance
    based on the given configuration options:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了路由之后，最后一步是根据给定的配置选项创建 `router` 实例：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A configuration is an object consisting of different properties that help to
    form the app's router. We will now examine these properties in the following subsections.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 配置是一个对象，由不同的属性组成，有助于形成应用程序的路由。我们现在将在以下小节中检查这些属性。
- en: routes
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: routes
- en: '`routes` is a must-have option to pass to the constructor. Without this, the
    router won''t be able to recognize the paths and direct users to the suitable
    view content accordingly.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes` 是必须传递给构造函数的选项。没有这个选项，路由器将无法识别路径并相应地将用户引导到合适的视图内容。'
- en: mode
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mode
- en: '`mode` determines the router''s mode. There are two modes in `VueRouter` for
    URLs:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`mode` 决定了路由器的模式。在 `VueRouter` 中，URL 有两种模式：'
- en: '`history` mode: This leverages the default `history.pushState()` API by means
    of the `HTML5 History` API. It allows us to achieve URL navigation without a page
    reload and makes the URL path human-readable, such as `yourapplication.com/about`.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`history` 模式：这通过 `HTML5 History` API 利用默认的 `history.pushState()` API。它允许我们在不重新加载页面的情况下进行
    URL 导航，并使 URL 路径易于阅读，例如 `yourapplication.com/about`。'
- en: '`hash` mode: This uses a hash symbol (`#`) to simulate a URL, for example,
    `yourapplication.com/#about` for an `about` page or `youapplication/#/` for the
    `home` URL of your application.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hash` 模式：这使用哈希符号（`#`）来模拟 URL，例如，`yourapplication.com/#about` 用于 `about` 页面或
    `youapplication/#/` 用于应用程序的 `home` URL。'
- en: base
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: base
- en: '`base` determines the base URL for the app. It will be set as `process.env.BASE_URL`
    to allow developers to control this from outside of the application code (from
    a `.env` file, for example). Hence developers can set the directory from which
    the code should be served upon running.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`base` 决定了应用程序的基本 URL。它将被设置为 `process.env.BASE_URL` 以允许开发人员从应用程序代码之外控制它（例如，从
    `.env` 文件中）。因此，开发人员可以在运行时设置代码应该从中提供服务的目录。'
- en: 'With `base` finally out of the way now, we have the `router` instance created.
    All that is left is to export it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经解决了 `base` 的问题，我们已经创建了 `router` 实例。剩下要做的就是导出它：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then import it in `main.js`, right before the creation of the main app instance''s
    `new Vue` object. We still need to specify `router` in the instance configuration,
    as shown in the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 `main.js` 中导入它，在创建主应用实例的 `new Vue` 对象之前。我们仍然需要在实例配置中指定 `router`，如下所示：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With this updated code, our application will now render as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段更新后的代码，我们的应用程序现在将按以下方式渲染：
- en: '![Figure 6.6: Home page of the Hello Vue Router application in the browser'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.6：浏览器中 Hello Vue Router 应用程序的首页'
- en: '](img/B15218_06_06.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_06_06.jpg)'
- en: 'Figure 6.6: Home page of the Hello Vue Router application in the browser'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6：浏览器中 Hello Vue Router 应用程序的首页
- en: 'If we navigate to `localhost:8080/about`, we will see the rendered content
    of the `about` component from the auto-generated code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们导航到 `localhost:8080/about`，我们将看到从自动生成的代码中渲染的 `about` 组件内容：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The website should look similar to that shown in *Figure 6.7*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 网站应该看起来与 *图 6.7* 中所示相似：
- en: '![Figure 6.7: About page of the "Hello Vue Router" application in the browser'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.7：浏览器中 "Hello Vue Router" 应用程序的关于页面'
- en: '](img/B15218_06_07.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_06_07.jpg)'
- en: 'Figure 6.7: About page of the "Hello Vue Router" application in the browser'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7：浏览器中 "Hello Vue Router" 应用程序的关于页面
- en: In this section, we looked at how lazily loading components can be used to speed
    up large and complex SPAs. We also looked at some of the options that can be set
    when setting up your router, such as routes, mode, and base. In the next section,
    we will learn how to implement and add a message feed page with the help of Vue
    Router.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何使用懒加载组件来加速大型和复杂的 SPAs。我们还探讨了在设置路由时可以设置的某些选项，例如路由、模式和基础。在下一节中，我们将学习如何在
    Vue Router 的帮助下实现和添加消息源页面。
- en: 'Exercise 6.01: Implementing and Adding a Message Feed Page Using Vue Router'
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.01：使用Vue Router实现和添加消息源页面
- en: We are going to create a new page that displays a list of messages to the user.
    Users will be able to visit this page whenever they enter the `localhost:8080/messages`
    path in the browser.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的页面，向用户显示消息列表。用户可以在浏览器中输入`localhost:8080/messages`路径时访问此页面。
- en: To access the code files for this exercise, refer to [https://packt.live/35alpze](https://packt.live/35alpze).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/35alpze](https://packt.live/35alpze)。
- en: 'Use the application generated with `vue create` as a starting point or create
    a new one with `vue-cli`. Ensure you had the router enabled when generating your
    project as described earlier in the chapter:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`vue create`生成的应用程序作为起点，或者使用`vue-cli`创建一个新的应用程序。确保在生成项目时启用了路由，如本章前面所述：
- en: '[PRE17]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s create a new view component called `MessageFeed` by adding a `MessageFeed.vue`
    file to the `./src/views/` folder:![Figure 6.8: The views directory hierarchy'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`./src/views/`文件夹中添加一个名为`MessageFeed.vue`的新视图组件：![图6.8：视图目录层次结构
- en: '](img/B15218_06_08.jpg)'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_06_08.jpg)'
- en: '[PRE18]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a router file at `src/router/index.js`. It should import `VueRouter`
    and tell Vue to use the router as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/router/index.js`中创建一个路由文件。它应该导入`VueRouter`并告诉Vue使用该路由，如下所示：
- en: '[PRE19]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, in `./src/router/index.js`, we declare a route designated for `MessageFeed`,
    named `messageFeed` and with its path set to `/messages`. We will also lazy-load
    the component. This step will be completed by appending an object with the required
    information to the `routes` array:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`./src/router/index.js`文件中，我们声明了一个用于`MessageFeed`的路由，命名为`messageFeed`，并将其路径设置为`/messages`。我们还将懒加载该组件。这一步将通过将包含所需信息的对象附加到`routes`数组中来完成：
- en: '[PRE20]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, in the same file, create a `router` instance using the `routes` we
    defined:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在同一个文件中，使用我们定义的`routes`创建一个`router`实例：
- en: '[PRE21]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the application using the following command:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行应用程序：
- en: '[PRE22]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Upon visiting `localhost:8080/messages` in the browser, the page should appear
    with the correct content – the `Message Feed` page as shown in the following screenshot:![Figure
    6.9: Message feed page rendered by the application'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在浏览器中访问`localhost:8080/messages`时，页面应该显示正确的内容——即如图所示的`Message Feed`页面：![图6.9：应用程序渲染的消息源页面
- en: '](img/B15218_06_09.jpg)'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_06_09.jpg)'
- en: 'Figure 6.9: Message feed page rendered by the application'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：应用程序渲染的消息源页面
- en: This demonstrates how simple it is to add a new page route to a Vue.js application
    using Vue Router, while keeping your code organized and easy to read. Now that
    we have our routes ready to use, we can provide users with the ability to navigate
    between pages, without typing the full path.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了如何简单地将一个新的页面路由添加到Vue.js应用程序中，同时保持代码组织良好且易于阅读。现在我们已经准备好了可用的路由，我们可以为用户提供在页面之间导航的能力，而无需输入完整的路径。
- en: Setting up Navigation Links
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置导航链接
- en: If `router-view` is in charge of rendering the correct active view content relative
    to the URL path, `router-link` is a Vue component that helps users to navigate
    within an app that has routing enabled. By default, it renders an anchor tag `<a>`
    with a correct `href` link generated by its `to` prop.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`router-view`负责根据URL路径渲染正确的活动视图内容，那么`router-link`是一个Vue组件，它帮助用户在启用了路由的应用程序中进行导航。默认情况下，它渲染一个带有由其`to`属性生成的正确`href`链接的锚标签`<a>`。
- en: 'In our example app generated by Vue CLI, since there are two routes pre-populated,
    there are also two `router-link` instances added to the `<template>` section of
    `App.vue` right before `<router-view/>`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们由Vue CLI生成的示例应用程序中，由于有两个预填充的路由，因此也在`App.vue`的`<template>`部分添加了两个`router-link`实例，位于`<router-view/>`之前：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Since we are using the `base` option with the `history` mode, the `to` prop
    of each `router-link` should receive an identical value with the `path` property
    declared in the targeted `route` object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用`base`选项和`history`模式，每个`router-link`的`to`属性应该接收与目标`route`对象中声明的`path`属性相同的值。
- en: 'In addition, because our routes are named, another alternative to the `to`
    prop is to have the same value as the name, instead of the path. Using the name
    is highly recommended to avoid complex link refactoring in case we have to adjust
    the paths given to some routes in our app. Hence, we can rewrite our links as
    follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们的路由已命名，`to`属性的一个替代方案是使用与名称相同的值，而不是路径。使用名称被高度推荐，以避免在需要调整应用程序中某些路由的路径时进行复杂的链接重构。因此，我们可以将链接重写如下：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can also choose to bind a location descriptor object to the `to` prop, in
    a similar format as a `route` object. Consider the following example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以选择将位置描述符对象绑定到`to`属性，其格式类似于`route`对象。考虑以下示例：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In addition, an extra `CSS` class `router-link-active` will be added to the
    `<a>` tag, when the related route is `active`. This class can be customized through
    the `active-class` prop of the `router-link` component.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当相关路由处于活动状态时，将向`<a>`标签添加一个额外的`CSS`类`router-link-active`。这个类可以通过`router-link`组件的`active-class`属性进行自定义。
- en: 'In `DevTools`, we can see the `router-link` component rendered as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DevTools`中，我们可以看到`router-link`组件的渲染方式如下：
- en: '![Figure 6.10: router-link in the browser''s DevTools'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.10：浏览器DevTools中的router-link'
- en: '](img/B15218_06_10.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_06_10.jpg)'
- en: 'Figure 6.10: router-link in the browser''s DevTools'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：浏览器DevTools中的router-link
- en: 'The view in the browser will be as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中的视图将如下所示：
- en: '![Figure 6.11: Home page of Hello Vue Router app with navigation links'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.11：带有导航链接的Hello Vue Router应用首页'
- en: '](img/B15218_06_11.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_06_11.jpg)'
- en: 'Figure 6.11: Home page of Hello Vue Router app with navigation links'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：带有导航链接的Hello Vue Router应用首页
- en: 'Note that since we have access to `this.$router` within a component, we can
    trigger a navigation route programmatically by using `this.$router.push()` and
    pass a path or a router object in a similar way to using `to`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们可以在组件内部访问`this.$router`，我们可以通过使用`this.$router.push()`以编程方式触发导航路由，并传递一个路径或类似`to`的路由对象：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this section, we created an example page that rendered a list of messages
    at the `/messages` route location. We also looked at how you can use the `<router-link/>`
    element to navigate between our views in a way similar to traditional HTML `<a>`
    tags.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了一个示例页面，在`/messages`路由位置渲染消息列表。我们还探讨了如何使用`<router-link/>`元素在视图之间进行导航，其方式与传统HTML
    `<a>`标签类似。
- en: Next, we will see how you can programmatically send a user to their last viewed
    route in a manner similar to the web browser's *back* button.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何以类似于网络浏览器*后退*按钮的方式，以编程方式将用户发送到他们最后查看的路由。
- en: Tip to Implement the Back Button
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现返回按钮的小技巧
- en: Sometimes we would like to navigate back to the previous page. Using `this.$router.push()`
    can achieve this, but this adds more routes in the history stack, instead of going
    back. The correct technique is to use `this.$router.go(steps)`, in which `steps`
    is an integer indicating the number of steps to go back/forward in the history
    stack. This functionality works similarly to `window.history.go(steps)`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望导航回上一页。使用`this.$router.push()`可以实现这一点，但这会在历史堆栈中添加更多路由，而不是返回。正确的技术是使用`this.$router.go(steps)`，其中`steps`是一个整数，表示在历史堆栈中后退/前进的步数。此功能与`window.history.go(steps)`类似。
- en: 'Consider the following example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Besides this, you can also navigate forward to a page that was loaded before
    and still exists in the history stack by using the same method, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以使用相同的方法导航到之前加载且仍然存在于历史堆栈中的页面：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this section, we looked at how you can manually access the router's history
    in order to send a user to the page they were previously on.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何手动访问路由的历史记录，以便将用户发送到他们之前所在的页面。
- en: In the next section, we'll make use of navigation links to add our new message
    feed page to our application's `nav` menu.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将利用导航链接将我们的新消息馈送页面添加到应用程序的`nav`菜单中。
- en: 'Exercise 6.02: Adding the Navigation Link to the MessageFeed Route'
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.02：将导航链接添加到MessageFeed路由
- en: We will add a quick link to the `MessageFeed` route we created in *Exercise
    6.01*, *Implementing and Adding a Message Feed Page Using Vue Router*, using the
    `to` prop and `router-link` as explained in the preceding topic.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`to`属性和`router-link`（如前文所述）添加一个快速链接到我们在*练习6.01*中创建的`MessageFeed`路由，即*使用Vue
    Router实现和添加消息馈送页面*。
- en: To access the code files for this exercise, refer to [https://packt.live/3lr8cYR](https://packt.live/3lr8cYR).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/3lr8cYR](https://packt.live/3lr8cYR)。
- en: 'Use the starter application generated by Vue as a starting point or create
    a new one with `Vue cli`. Ensure you have the router enabled when generating your
    project as described earlier in the chapter:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Vue生成的起始应用程序作为起点，或者使用`Vue cli`创建一个新的应用程序。确保在生成项目时启用路由，如本章前面所述：
- en: '[PRE29]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the `./src/App.vue` file, besides the auto-generated `router-link` components
    for `home` and `about`, add another `router-link` component that points to the
    `/messages` path under the `Message Feed` title:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`./src/App.vue`文件中，除了为`home`和`about`自动生成的`router-link`组件外，还需要添加另一个指向`Message
    Feed`标题下`/messages`路径的`router-link`组件：
- en: '[PRE30]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We will see the navigation links available in any view and they will not disappear
    when users navigate away since they are not a part of the `router-view` component.
    Our screen should look as follows:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将看到在任何视图中都可用导航链接，并且当用户导航离开时它们不会消失，因为它们不是`router-view`组件的一部分。我们的屏幕应该如下所示：
- en: '![Figure 6.12\. Home page of the Hello Vue Router app with updated navigation
    links'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.12\. 更新后的导航链接的Hello Vue Router应用首页'
- en: '](img/B15218_06_12.jpg)'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_06_12.jpg)'
- en: Figure 6.12\. Home page of the Hello Vue Router app with updated navigation
    links
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.12\. 更新后的导航链接的Hello Vue Router应用首页
- en: 'Let''s change the `to` value to point to the object named `messageFeed`, which
    is the same as the `name` given for this route in `./src/App.vue`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`to`值更改为指向名为`messageFeed`的对象，这与在`./src/App.vue`中为该路由指定的`name`相同：
- en: '[PRE31]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The navigation should work as before; clicking on the `Message Feed` link should
    direct you to `/messages`, as shown in the following screenshot:![Figure 6.13:
    Message Feed page of Hello Vue Router after clicking on the Message Feed link'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航应该与之前一样工作；点击`消息流`链接应将您导向`/messages`，如下面的截图所示：![图6.13：点击消息流链接后的Hello Vue Router的消息流页面
- en: '](img/B15218_06_13.jpg)'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_06_13.jpg)'
- en: 'Figure 6.13: Message Feed page of Hello Vue Router after clicking on the Message
    Feed link'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.13：点击消息流链接后的Hello Vue Router的消息流页面
- en: 'Now, open the `index.js` file located in the `./src/router/` folder and change
    the path defined for the `messageFeed` route from `/messages/` to `/messagesFeed`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开位于`./src/router/`文件夹中的`index.js`文件，将`messageFeed`路由定义的路径从`/messages/`更改为`/messagesFeed`：
- en: '[PRE32]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run the application using the following command:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行应用程序：
- en: '[PRE33]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Navigate to the app''s `Home` page and click on `Message Feed` again. It should
    display the same `messages feed` page as before but note that the URL path changed
    to `/messagesFeed`:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导航到应用的`首页`并再次点击`消息流`。它应该显示与之前相同的`消息流`页面，但请注意URL路径已更改为`/messagesFeed`：
- en: '![Figure 6.14: Message Feed page rendered with the updated URL path'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.14：使用更新后的URL路径渲染的消息流页面'
- en: '](img/B15218_06_14.jpg)'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_06_14.jpg)'
- en: 'Figure 6.14: Message Feed page rendered with the updated URL path'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14：使用更新后的URL路径渲染的消息流页面
- en: Note how easy it is to set up the link to the `/messages` path with just one
    line of code, as well as updating the related path without refactoring. So far,
    we have just defined some simple routes without any additional parameters for
    the targeted route. This will be our next challenge.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，仅用一行代码就可以轻松设置指向`/messages`路径的链接，以及更新相关路径而不需要重构。到目前为止，我们只定义了一些简单的路由，没有为目标路由添加任何额外的参数。这将是我们的下一个挑战。
- en: Passing Route Parameters
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递路由参数
- en: In the previous sections of this chapter, each route was a standalone view and
    did not need to pass or connect any data to the other routes. But the power of
    routing is not limited only to this. With **named** routes, we can also easily
    enable data communication between routes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前几节中，每个路由都是一个独立的视图，不需要传递或连接任何数据到其他路由。但路由的力量不仅限于此。通过**命名**路由，我们还可以轻松地启用路由之间的数据通信。
- en: 'In our example app, we want our `about` page to be able to receive a data string
    called `user` as the user''s name from the link trigger. This can be achieved
    by changing the `to` prop from a string literal to an object literal of `:to="{
    name: ''about'' }"`, and then adding a new `params: { user: ''Adam'' }` property
    to that object:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们的示例应用中，我们希望我们的`about`页面能够接收一个名为`user`的数据字符串，作为用户名从链接触发。这可以通过将`to`属性从字符串字面量更改为对象字面量`:to="{
    name: ''about'' }"`来实现，然后向该对象添加一个新的`params: { user: ''Adam'' }`属性：'
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This change informs the router to pass the desired parameters to the `About`
    page when users click on the targeted link. These additional parameters are not
    visible on the rendered `href` link, as shown in the following screenshot:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改通知路由器在用户点击目标链接时将所需的参数传递给`About`页面。这些额外的参数在渲染的`href`链接中不可见，如下面的截图所示：
- en: '![Figure 6.15: Generated href link is without parameters'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.15：生成的href链接没有参数'
- en: '](img/B15218_06_15.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_06_15.jpg)'
- en: 'Figure 6.15: Generated href link is without parameters'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15：生成的href链接没有参数
- en: 'However, the Vue system is tracking these additional parameters. Using the
    Vue DevTools, we can view the parameters by expanding the `to` prop as shown in
    *Figure 6.16*:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Vue 系统正在跟踪这些额外的参数。使用 Vue DevTools，我们可以通过展开如图 6.16 所示的`to`属性来查看参数：
- en: '![Figure 6.16: The params of the to object in Vue DevTools'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.16：Vue DevTools 中 to 对象的 params](img/B15218_06_17.jpg)'
- en: '](img/B15218_06_16.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_06_16.jpg](img/B15218_06_16.jpg)'
- en: 'Figure 6.16: The params of the to object in Vue DevTools'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.16：Vue DevTools 中 to 对象的 params](img/B15218_06_16.jpg)'
- en: 'In the `About.vue` file, since we have access to the currently active `$route`
    (see the *Vue Router* section earlier in this chapter), we can retrieve the data
    passed with the link as `$route.params.user` and print out the value:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在`About.vue`文件中，由于我们可以访问当前活动的`$route`（参见本章前面提到的*Vue Router*部分），我们可以检索通过链接传递的数据，并将其作为`$route.params.user`获取并打印出来：
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output will be as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 6.17: The About page renders the user passed through route params'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.17：About 页面渲染通过路由参数传递的用户](img/B15218_06_17.jpg)'
- en: '](img/B15218_06_17.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_06_17.jpg](img/B15218_06_17.jpg)'
- en: 'Figure 6.17: The About page renders the user passed through route params'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.17：About 页面渲染通过路由参数传递的用户](img/B15218_06_17.jpg)'
- en: Any prop user of `params` will not be visible on the URL path, thus keeping
    the path clean and securing the data transferred between views from the user.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 任何`params`的prop用户都不会出现在URL路径上，从而保持路径的整洁，并确保视图之间传递的数据的安全性。
- en: But using `$route.params.user` is not convenient or readable and doesn't keep
    the component reusable in the long run. We can improve this by decoupling the
    passed `params` with the `props` within the component.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 但是使用`$route.params.user`既不方便也不易读，并且从长远来看不利于组件的可重用性。我们可以通过在组件内部解耦传递的`params`与`props`来改进这一点。
- en: We will now see how to decouple the `params` with the help of `props`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看到如何借助`props`解耦`params`。
- en: Decoupling Params with Props
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用属性解耦参数
- en: 'In the `index.js` file, let''s adjust the configuration of the `about` route
    with an additional property called `props`. By setting this property''s value
    to `true`, the router will automatically understand and map `$route.params` into
    the `props` component accordingly:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.js`文件中，让我们调整`about`路由的配置，添加一个名为`props`的额外属性。通过将此属性的值设置为`true`，路由器将自动理解并将`$route.params`映射到相应的`props`组件：
- en: '[PRE36]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the `About.vue` file, we will declare the `props` type as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在`About.vue`文件中，我们将声明`props`类型如下：
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And in the `<template>` section, we will replace `$route.params.user` with `user`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<template>`部分，我们将`$route.params.user`替换为`user`：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output will still be the same, as shown in the following screenshot:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 输出仍然相同，如下面的截图所示：
- en: '![Figure 6.18: The About page renders the user passed through route params'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.18：About 页面渲染通过路由参数传递的用户](img/B15218_06_18.jpg)'
- en: and mapped to props
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 并映射到属性
- en: '](img/B15218_06_18.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_06_18.jpg](img/B15218_06_18.jpg)'
- en: 'Figure 6.18: The About page renders the user passed through route params and
    mapped to props'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.18：About 页面渲染通过路由参数传递的用户并映射到 props](img/B15218_06_18.jpg)'
- en: 'In addition to this, you can also define the data that you want to pass within
    the `props` property of the `route` configuration. Instead of a Boolean value,
    `props` can now be declared as an object with the required data, as in the following
    example:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以在`route`配置的`props`属性中定义你想要传递的数据。与布尔值不同，现在`props`可以声明为一个对象，包含所需的数据，如下例所示：
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With a similar step, we will declare `age` as a `props` component in `About.vue`,
    and print it out to the screen as text:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类似的步骤，我们将在`About.vue`中将`age`声明为`props`组件，并将其作为文本打印到屏幕上：
- en: '[PRE40]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now when the `About` page is clicked, the page will render as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当点击`About`页面时，页面将渲染如下：
- en: '![Figure 6.19: About page rendered with the props preset in the router configuration'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.19：使用路由配置中预置的 props 渲染的 About 页面](img/B15218_06_19.jpg)'
- en: '](img/B15218_06_19.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_06_19.jpg](img/B15218_06_19.jpg)'
- en: 'Figure 6.19: About page rendered with the props preset in the router configuration'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.19：使用路由配置中预置的 props 渲染的 About 页面](img/B15218_06_19.jpg)'
- en: Our previous user data is not visible anymore! This is because, now, `props`
    is declared with static data in the configuration of the `About` route and can't
    be overridden from outside. Its value is and will remain the same throughout the
    process of navigating around the app, regardless of what values we pass in `params`
    of the `to` prop in the targeted `router-link` component.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前用户数据不再可见！这是因为，现在，`props`在`About`路由的配置中声明为静态数据，并且不能从外部覆盖。它的值在整个在应用程序中导航的过程中将保持不变，无论我们在目标`router-link`组件的`to`属性的`params`中传递什么值。
- en: We will now learn how to pass the content of the selected message to a new message
    page and print it.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将学习如何将所选消息的内容传递到新消息页面并打印出来。
- en: 'Exercise 6.03: Passing the Content of the Selected Message to a New Message
    Page and Having It Printed Out'
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.03：将所选消息的内容传递到新消息页面并打印出来
- en: We shall continue from *Exercise 6.02*, *Adding the Navigation Link to the MessageFeed
    Route*, where we defined the `MessageFeed` route with a URL path to `messages`.
    This view will render a list of predefined messages in the `data` property of
    the `view` component's options.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从*练习6.02*继续，*将导航链接添加到消息推送路由*，在那里我们定义了`MessageFeed`路由，其URL路径为`messages`。此视图将在视图组件选项的`data`属性中渲染预定义的消息列表。
- en: In this exercise, we will create a new `message` page, designated to render
    the content of a message selected by the user. It should be reusable.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个新的`message`页面，专门用于渲染用户选择的消息内容。它应该是可重用的。
- en: To access the code files for this exercise, refer to [https://packt.live/36mTwTY](https://packt.live/36mTwTY).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/36mTwTY](https://packt.live/36mTwTY)。
- en: 'In the `./src/views/` folder, we create a new single-file component called
    `Message.vue`. This component receives a `content` prop of type `string` and renders
    it under a `<p>` tag:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`./src/views/`文件夹中，我们创建了一个新的单文件组件`Message.vue`。该组件接收一个类型为`string`的`content`属性，并在`<p>`标签下渲染它：
- en: '[PRE41]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s register the created view component to the existing `routes` in `./src/router/index.js`.
    We will define the new route as a `message` with the path to `/message`. It will
    also accept `props: true` in order to map all parameters passed to the route to
    the related prop accordingly. The full list of routes to be used is as follows:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '让我们将创建的视图组件注册到`./src/router/index.js`中的现有`routes`。我们将定义一个新的路由为`message`，路径为`/message`。它还将接受`props:
    true`，以便将传递给路由的所有参数相应地映射到相关属性。将要使用的完整路由列表如下：'
- en: '[PRE42]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Since the route is registered and ready to be used, we need to make changes
    to the `<template>` section of `./src/views/MessageFeed.vue` to ensure each message
    line is now clickable and will redirect the user to the new route when clicked.
    Let''s replace the `<p>` tag with `router-click`. And because we have named our
    new route as `message`, we will set `to` to bind to `{ name: ''message'' }`:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '由于路由已注册并准备好使用，我们需要修改`./src/views/MessageFeed.vue`中的`<template>`部分，以确保每条消息现在都是可点击的，并且在点击时将用户重定向到新路由。让我们将`<p>`标签替换为`router-click`。因为我们已经将新路由命名为`message`，所以我们将`to`设置为绑定到`{
    name: ''message'' }`：'
- en: '[PRE43]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Under `template`, we''ll add a `script` tag containing some sample data for
    our `messages`:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`template`中，我们将添加一个包含我们`messages`的一些示例数据的`script`标签：
- en: '[PRE44]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When you open the `./messages` page, all the messages are now clickable as
    shown in the following screenshot:![Figure 6.20: Message Feed page after changing
    messages to be clickable'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你打开`./messages`页面时，现在所有消息都是可点击的，如下面的截图所示：![图6.20：更改消息为可点击后的消息推送页面
- en: '](img/B15218_06_20.jpg)'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_06_20.jpg)'
- en: 'Figure 6.20: Message Feed page after changing messages to be clickable'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.20：更改消息为可点击后的消息推送页面
- en: 'Now when the user clicks on a message, it will open a new page. However, the
    page content will be empty, as we have not passed any content parameter to the
    `<route-click>` component, as shown in the following screenshot:![Figure 6.21:
    Message page with no content generated'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在当用户点击一条消息时，它将打开一个新页面。然而，页面内容将是空的，因为我们没有将任何内容参数传递给`<route-click>`组件，如下面的截图所示：![图6.21：无内容生成的消息页面
- en: '](img/B15218_06_21.jpg)'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_06_21.jpg)'
- en: 'Figure 6.21: Message page with no content generated'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.21：无内容生成的消息页面
- en: 'Let''s go back to `./src/views/MessageFeed.vue` and add `params: { content:
    m }`:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '让我们回到`./src/views/MessageFeed.vue`并添加`params: { content: m }`：'
- en: '[PRE45]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now when you click on the first message, `Hello, how are you?`, the output
    will be the following:![Figure 6.22: Message page with the clicked message''s
    content rendered'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在当你点击第一条消息“你好，你好吗？”，输出将是以下内容：![图6.22：已渲染点击消息内容的消息页面
- en: '](img/B15218_06_22.jpg)'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_06_22.jpg)'
- en: 'Figure 6.22: Message page with the clicked message''s content rendered'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.22：已渲染点击消息内容的消息页面
- en: Simple, isn't it? We have completed the flow from a feed of messages to a detailed
    page of a single selected message dynamically with `router-link` and the combination
    of `params` and `props` of the component. However, there is one significant downside
    to this approach.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 简单，不是吗？我们已经使用`router-link`以及组件的`params`和`props`的组合，动态完成了从消息流到单个选中消息详细页面的流程。然而，这种方法有一个显著的缺点。
- en: Let's refresh the page while you are still on the `./message` path of the first
    message. The output will be the same as in *Step 5* – an empty content page. Upon
    refresh, the route is triggered without any `content` `params` passed, unlike
    when the user clicked on a specific link, and the `params` passed previously were
    not saved or cached. Hence there is no content.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当你仍然位于第一条消息的`./message`路径上时，让我们刷新页面。输出将与*步骤 5*中的相同——一个空的内容页面。刷新后，路由被触发，没有传递任何`content`
    `params`，与用户点击特定链接时不同，之前传递的`params`也没有被保存或缓存。因此，没有内容。
- en: In the following section, we will learn how to intercept the navigation flow
    and solve this problem with **Router Hooks**.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将学习如何拦截导航流程，并使用**路由钩子**解决这个问题。
- en: Router Hooks
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由钩子
- en: 'The general flow of route navigation is described in the following diagram:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 路由导航的一般流程在以下图中描述：
- en: '![Figure 6.23: Navigation resolution flow diagram'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.23：导航解析流程图](img/B15218_06_23.jpg)'
- en: '](img/B15218_06_23.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_06_23.jpg)'
- en: 'Figure 6.23: Navigation resolution flow diagram'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.23：导航解析流程图
- en: 'Once navigation is triggered on a certain route, Vue Router provides several
    primary navigation guards, or Hooks, for developers to guard or intercept that
    navigation process. These guards can be hooked either globally or in the component,
    depending on the type. Some examples are as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在某个路由上触发导航，Vue Router为开发者提供了几个主要的导航守卫或钩子，用于保护或拦截该导航过程。这些守卫可以是全局的或组件内的，具体取决于类型。以下是一些示例：
- en: 'Globally: `beforeEach`, `beforeResolve`, and `afterEach`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局：`beforeEach`、`beforeResolve`和`afterEach`
- en: 'Per component: `beforeEnter`'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个组件：`beforeEnter`
- en: 'In-component: `beforeRouteUpdate`, `beforeRouteEnter`, and `beforeRouterLeave`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件内：`beforeRouteUpdate`、`beforeRouteEnter`和`beforeRouterLeave`
- en: As seen in *Figure 6.23*, navigation is considered completed only after all
    the Hooks or guards have been resolved, including any asynchronous guard. Now,
    let's see how to set up `beforeEach` Hooks.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图 6.23*所示，只有当所有钩子或守卫（包括任何异步守卫）都解析完成后，导航才被认为是完成的。现在，让我们看看如何设置`beforeEach`钩子。
- en: Setting up beforeEach Hooks
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置`beforeEach`钩子
- en: '`beforeEach` is a global Hook and is called at the very beginning of navigation,
    `beforeRouteLeave` of the previous view component). It should be defined as a
    global method of the `router` instance during initialization in the `index.js`
    file and takes the following syntax:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeEach`是一个全局钩子，在导航开始时（前一个视图组件的`beforeRouteLeave`）被调用。它应该在`index.js`文件初始化时定义为一个`router`实例的全局方法，并采用以下语法：'
- en: '[PRE46]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the preceding snippet, `beforeEachCallback` is a `hook` function that receives
    three arguments:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`beforeEachCallback`是一个`hook`函数，它接收三个参数：
- en: '[PRE47]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Or we could write this directly as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以直接这样写：
- en: '[PRE48]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For example, if we want to display a different page to display a generic message
    whenever a user navigates to `About` without a param value for the user, we can
    hook `beforeEach` as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想在用户导航到没有用户参数值的`About`时显示不同的页面来显示通用消息，我们可以将`beforeEach`钩子配置如下：
- en: '[PRE49]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, we check if the destination route is `about` and if it doesn't have any
    additional params passed, nor any value for the `user` param passed, we will navigate
    to an `error` route instead. Otherwise, just proceed as normal with `next()`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查目标路由是否为`about`，并且没有传递任何额外的`params`，也没有为`user`参数传递任何值，我们将导航到`error`路由，而不是正常进行，使用`next()`。
- en: Note
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`next()` is required to be called `if` and once for `else`), or else there
    will be errors.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`next()`必须调用（如果`else`），否则将出现错误。'
- en: 'We still need to create an `error` page with an `Error.vue` view component
    that displays a simple message:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要创建一个带有`Error.vue`视图组件的`error`页面，该组件显示一条简单的消息：
- en: '[PRE50]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Also, make sure to register the path accordingly:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 还要确保相应地注册路径：
- en: '[PRE51]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, in the `Home` view, after clicking on the `About` link, the app will render
    the `Error` page instead of the `About` page as seen in the following screenshot:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`Home`视图中，点击`About`链接后，应用将渲染`Error`页面，而不是`About`页面，如以下截图所示：
- en: '![Figure 6.24: Error page displayed when About is clicked without any param
    passed'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.24：点击About时未传递任何参数显示的错误页面](img/B15218_06_24.jpg)'
- en: '](img/B15218_06_24.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_06_24.jpg)'
- en: 'Figure 6.24: Error page displayed when About is clicked without any param passed'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.24：点击About时未传递任何参数显示的错误页面
- en: 'Now let''s go to the `App.vue` file and assign the `to` prop to bind to an
    `{ name: ''about'', params: { user: ''Adam'' }}` object instead:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，让我们转到`App.vue`文件，并将`to`属性绑定到`{ name: ''about'', params: { user: ''Adam''
    }}`对象上：'
- en: '[PRE52]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s navigate back to our app''s `Home` page and click on the `About` link.
    Since we have a proper `params` passed, the output will be as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们导航回应用的`Home`页面并点击`About`链接。由于我们传递了正确的`params`，输出将如下所示：
- en: '![Figure 6.25: About page displayed when there is a user passed in the params'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.25：当在`params`中传递用户时显示的“关于”页面'
- en: '](img/B15218_06_25.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_06_25.jpg)'
- en: 'Figure 6.25: About page displayed when there is a user passed in the params'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.25：当在`params`中传递用户时显示的“关于”页面
- en: Moreover, from now on, every time we refresh the `About` page, we will get redirected
    to the `Error` page instead since there is no `user` param passed on refreshing.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，从现在开始，每次我们刷新“关于”页面时，都会被重定向到“错误”页面，因为没有在刷新时传递`user`参数。
- en: We shall now look at a few key distinguishing points between the `beforeEach`
    and `beforeResolve` Hooks.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨`beforeEach`和`beforeResolve`钩子之间的一些关键区别点。
- en: Differentiating Between the beforeEach and beforeResolve Hooks
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区分beforeEach和beforeResolve钩子
- en: 'We can also register the global Hook with `beforeResolve` with the same syntax.
    However, unlike `beforeEach`, which is triggered at the creation phase of navigation,
    `beforeResolve` will be triggered just before the navigation is carried out and
    confirmed, **after all the Hooks (both global and in-component) are resolved**:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用相同的语法使用`beforeResolve`注册全局钩子。然而，与在导航创建阶段触发的`beforeEach`不同，`beforeResolve`将在导航执行和确认之前触发，**在所有钩子（全局和组件内）解析之后**：
- en: '[PRE53]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The output results will remain the same as in *Figure 6.25*:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果将与*图6.25*相同：
- en: '![Figure 6.26: About page displayed when there is a user passed in the params'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.26：当在`params`中传递用户时显示的“关于”页面'
- en: '](img/B15218_06_26.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_06_26.jpg)'
- en: 'Figure 6.26: About page displayed when there is a user passed in the params'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.26：当在`params`中传递用户时显示的“关于”页面
- en: Let's now look at the `afterEach` Hook in detail.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来详细看看`afterEach`钩子。
- en: The afterEach Hook
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: afterEach钩子
- en: The `afterEach()` Hook is the last global navigation guard to be triggered after
    the navigation is confirmed (which means after `beforeResolve()`). Unlike the
    other global guards, the Hook function to pass to `afterEach()` does not receive
    a `next` function, hence it won't affect the navigation.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`afterEach()`钩子是在导航确认后（这意味着在`beforeResolve()`之后）被触发的最后一个全局导航守卫。与其他全局守卫不同，传递给`afterEach()`的钩子函数不会接收`next`函数，因此它不会影响导航。'
- en: 'In addition, the `to` and `from` parameters are read-only `Route` objects.
    Hence the best use case for `afterEach` is to save data such as the last visited
    `Route` object for a `Back` button, the passed `params` of the `route` destination,
    or page view tracking. For example, we can have a default value of `user`, assign
    it, and save it whenever needed:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`to`和`from`参数是只读的`Route`对象。因此，`afterEach`的最佳用例是保存数据，例如为“返回”按钮保存最后访问的`Route`对象，传递给路由目标的`params`，或页面视图跟踪。例如，我们可以设置一个默认值`user`，并在需要时赋值并保存：
- en: '[PRE54]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now in the `App.js` file, instead of `Adam`, add the following:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`App.js`文件中，除了`Adam`外，添加以下内容：
- en: '[PRE55]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s change it to `Alex`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其更改为`Alex`：
- en: '[PRE56]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The output now when clicking on the `About` link is as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 点击`About`链接时的输出如下所示：
- en: '![Figure 6.27: About page displaying the new user''s name – Alex'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.27：显示新用户名字的“关于”页面 – Alex'
- en: '](img/B15218_06_27.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_06_27.jpg)'
- en: 'Figure 6.27: About page displaying the new user''s name – Alex'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.27：显示新用户名字的“关于”页面 – Alex
- en: 'But on reload, the `About` page renders with the default user – `Adam` – instead
    since there is a user passed to the `params`, as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在重新加载时，由于传递了`params`中的用户，`About`页面将渲染为默认用户`Adam`，如下所示：
- en: '![Figure 6.28: About page displaying the default user value on reload – Adam'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.28：在重新加载时显示默认用户值“Adam”的“关于”页面'
- en: '](img/B15218_06_28.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_06_28.jpg)'
- en: 'Figure 6.28: About page displaying the default user value on reload – Adam'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.28：在重新加载时显示默认用户值“Adam”的“关于”页面
- en: In this section, we looked at the `afterEach` Hook. We used the `afterEach`
    Hook to pass data through to the `about` page without having to have that data
    contained in the URL. This same technique can be used for updating other behavior
    such as the desired target page when pressing the `back` button.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了`afterEach`钩子。我们使用`afterEach`钩子将数据传递到`about`页面，而无需在URL中包含该数据。同样的技术可以用于更新其他行为，例如按下“返回”按钮时希望的目标页面。
- en: Personalizing Hooks per Route
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根据路由个性化钩子
- en: 'Instead of defining a global Hook, which can cause unseen bugs and requires
    a route check, we can define a `beforeEnter` guard directly in the targeted route''s
    configuration object, for example, our `About` route:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是定义一个全局钩子，这可能会引起未知的错误并需要路由检查，我们可以在目标路由的配置对象中直接定义 `beforeEnter` 守卫，例如，我们的 `About`
    路由：
- en: '[PRE57]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'With this approach, both on reload and on clicking a link to navigate to the
    `About` page, the output is now consistent, as shown in the following screenshot:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，无论是重新加载还是点击链接导航到 `About` 页面，输出现在都是一致的，如下面的截图所示：
- en: '![Figure 6.29: About page rendered with the user value Adam'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.29：使用用户值 Adam 渲染的关于页面]'
- en: '](img/B15218_06_29.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_06_29.jpg]'
- en: 'Figure 6.29: About page rendered with the user value Adam'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.29：使用用户值 Adam 渲染的关于页面
- en: Note
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: With `beforeEnter()`, `to` is write-able and you will have access to `this`
    (which points to the specific route – `About`). It will only be triggered when
    users trigger navigation to the `About` page.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `beforeEnter()`，`to` 是可写的，你将能够访问 `this`（指向特定的路由 - `About`）。它只会在用户触发导航到 `About`
    页面时被触发。
- en: In this section, we looked at the different router Hooks available in Vue, including
    `beforeEach`, `beforeResolve`, and `afterEach`. We saw how each of these Hooks
    is called at a different point in the routing process. As a practical example,
    we looked at a route that, if not provided a parameter, instead directs the user
    to an error page. These Hooks can be very useful especially when setting up an
    authenticated route. In the next section, we'll look at setting up in-component
    Hooks.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了 Vue 中可用的不同路由钩子，包括 `beforeEach`、`beforeResolve` 和 `afterEach`。我们看到了每个钩子如何在路由过程中的不同点被调用。作为一个实际例子，我们查看了一个路由，如果没有提供参数，则将用户重定向到错误页面。这些钩子在设置认证路由时非常有用。在下一节中，我们将探讨设置组件内部的钩子。
- en: Setting up in-Component Hooks
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置组件内部的钩子
- en: Finally, we can also use in-component Hooks as component life cycle Hooks where
    we want to scope those Hooks to component-level for better code maintenance or
    enhance the workflow where the same component needs to behave differently in a
    certain use case.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以使用组件内部的钩子作为组件生命周期钩子，在需要将钩子作用域限定在组件级别以更好地维护代码或增强工作流程的情况下。
- en: 'We can have the `About` component now with the `beforeRouteEnter()` Hook defined
    as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以定义如下的 `beforeRouteEnter()` 钩子来拥有 `About` 组件：
- en: '[PRE58]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see, we don't have access to the `this` scope of the component during
    `beforeRouteEnter`, because the view component is still being created at the moment
    of triggering. Luckily, we can access the instance through a callback passed to
    `next()`. Whenever the navigation is confirmed, which means the component is created,
    the callback will be triggered, and the component instance will be available as
    the sole argument (`comp`) of the callback.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在 `beforeRouteEnter` 期间，我们没有访问组件的 `this` 作用域，因为视图组件在触发时的那一刻仍在创建中。幸运的是，我们可以通过传递给
    `next()` 的回调函数来访问实例。每当导航被确认，即组件被创建时，回调函数将被触发，组件实例将作为回调函数的唯一参数（`comp`）可用。
- en: Note
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For `beforeRouteUpdate` and `beforeRouteLeave`, the component has been created,
    hence this instance is available and there won't be a need for a callback for
    `next()`. In fact, a callback function is only supported in `next()` within the
    use of `beforeRouteEnter()`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `beforeRouteUpdate` 和 `beforeRouteLeave`，组件已经被创建，因此这个实例是可用的，不需要为 `next()`
    提供回调函数。实际上，回调函数仅在 `beforeRouteEnter()` 的使用中支持 `next()`。
- en: '`beforeRouteUpdate` is called when the same component is reused for a different
    route. This applies when we use dynamic routing, which will be discussed in the
    next section.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当相同的组件被用于不同的路由时，会调用 `beforeRouteUpdate`。这适用于我们使用动态路由的情况，这将在下一节中讨论。
- en: '`beforeRouteLeave` is triggered when the component is going to be deactivated
    or before the user navigates away from the current view. This is called right
    before the `beforeEach` guard of the new navigation and is usually used in editor
    components to prevent users from navigating away without saving.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件即将被停用或用户即将离开当前视图时，会触发 `beforeRouteLeave`。这发生在新导航的 `beforeEach` 守卫之前，通常用于编辑组件以防止用户在不保存的情况下离开。
- en: In this guard, we can cancel the new navigation by passing `false` to the `next()` function.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个守卫中，我们可以通过向 `next()` 函数传递 `false` 来取消新的导航。
- en: 'For example, imagine that we add the following Hook to the component''s option
    in the `About.vue` file:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们在 `About.vue` 文件的组件选项中添加以下钩子：
- en: '[PRE59]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When we navigate away from the `About` page, a pop-up dialog will appear asking
    for confirmation as shown in the following screenshot and then continue navigating accordingly:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从“关于”页面导航离开时，会出现一个弹出对话框请求确认，如下面的截图所示，然后继续相应地导航：
- en: '![Figure 6.30: Dialog asking to confirm before navigating away from the About
    page'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.30：在离开“关于”页面之前请求确认的对话框'
- en: '](img/B15218_06_30.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_06_30.jpg)'
- en: 'Figure 6.30: Dialog asking to confirm before navigating away from the About
    page'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.30：在离开“关于”页面之前请求确认的对话框
- en: In this section, we looked at setting up in-component Hooks, that is, Hooks
    that are scoped to specific components. We set up an in-component Hook for our
    `About` component that asks a user to confirm before leaving the page. In the
    next section, we will move our message list into an external file to be loaded
    only when `MessageFeed` is in view.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了设置组件内钩子，即仅限于特定组件的钩子。我们为我们的`About`组件设置了一个组件内钩子，在用户离开页面之前要求用户确认。在下一节中，我们将把消息列表移动到外部文件，以便仅在`MessageFeed`可见时加载。
- en: 'Exercise 6.04: Extracting a Messages List to an External File and Loading It
    Only When MessageFeed Is in View'
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.04：将消息列表提取到外部文件并在MessageFeed可见时加载
- en: Going back to *Exercise 6.03*, *Passing the Content of the Selected Message
    to a New Message Page and Having It Printed Out*, now we will do a bit of code
    enhancement using the `beforeEnter` and `beforeRouteEnter` router hooks. This
    exercise is meant to make you more familiar with using router hooks.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 回到*练习6.03*，*将选中消息的内容传递到新消息页面并打印出来*，现在我们将使用`beforeEnter`和`beforeRouteEnter`路由钩子进行一些代码增强。这个练习旨在让你更熟悉使用路由钩子。
- en: To access the code files for this exercise, refer to [https://packt.live/3lg1F2R](https://packt.live/3lg1F2R).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/3lg1F2R](https://packt.live/3lg1F2R)。
- en: 'Let''s extract the `messages` static data from `./src/views/MessageFeed.vue`
    and save it in `./src/assets/messages.js`:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从`./src/views/MessageFeed.vue`中提取`messages`静态数据并将其保存到`./src/assets/messages.js`中：
- en: '[PRE60]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In `./src/views/MessageFeed.vue`, we will replace the local data property with
    `props: { messages: { type: String, default: [] }}`:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`./src/views/MessageFeed.vue`中，我们将用`props: { messages: { type: String, default:
    [] }}`替换本地数据属性：'
- en: '[PRE61]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now we need to load the list of `messages` and assign it to the `messages`
    `params` upon navigation to the `messages` route. We will do this by using the
    `beforeEnter` Hook in the route''s configuration object. Don''t forget to add
    `props: true` to normalize the `params` into related `props` for rendering. You
    can do that by modifying your `route` defined in `src/router/index.js` as follows:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，我们需要在导航到“消息”路由时加载消息列表并将其分配给`messages`参数。我们将通过使用路由配置对象中的`beforeEnter`钩子来完成此操作。别忘了添加`props:
    true`以将`params`标准化为相关的`props`以进行渲染。你可以通过修改`src/router/index.js`中定义的`route`来实现这一点：'
- en: '[PRE62]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We will lazy-load the list of messages with `import`:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`import`懒加载消息列表：
- en: '[PRE63]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, retrieve the needed information as follows:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按照以下方式检索所需信息：
- en: '[PRE64]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The full code for the route in `src/router/index.js` should be the following:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`src/router/index.js`中路由的完整代码应该是以下内容：'
- en: '[PRE65]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'When viewing the website, we should see a message feed similar to that of the
    last exercise. This is shown in the following screenshot:'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在查看网站时，我们应该看到一个类似于上一个练习的消息推送。如下面的截图所示：
- en: '![Figure 6.31: Message Feed page after refactoring'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.31：重构后的消息推送页面'
- en: '](img/B15218_06_31.jpg)'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_06_31.jpg)'
- en: 'Figure 6.31: Message Feed page after refactoring'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.31：重构后的消息推送页面
- en: At this point, we have learned and practiced how to configure routers, pass
    parameters, and intercept navigation between pages in the application using different
    routing Hooks. In the next section, we are going to look at a more advanced topic
    – **dynamic routing**.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习和实践了如何使用不同的路由钩子配置路由、传递参数以及拦截应用中页面间的导航。在下一节中，我们将探讨一个更高级的主题——**动态路由**。
- en: Dynamic Routing
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态路由
- en: If there is a lot of data that follows the same format, such as a list of users,
    or a list of messages, and it's required to create a page for each of them, we
    need to use a routing pattern. With a routing pattern, we can create a new route
    dynamically from the same component based on some additional information. For
    example, we want to render the `User` view component for every user but with different
    `id` values. Vue Router provides us with the ability to use dynamic segments denoted
    by a colon (`:`) to achieve dynamic routing.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using `params`, which doesn''t persist its value on refresh or appear
    in the URL, we define the required `params` directly in the path as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the preceding code, `:id` means the `params` here are not static. When the
    route matches the given pattern, Vue Router will render the corresponding component
    with the appropriate content, while keeping the URL as it should be. And the value
    of `:id` will be exposed as this `$route.params.id` in that view component''s
    instance:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: When users select URLs such as `/user/1` and `/user/2` (`./src/App.vue`), Vue
    will automatically generate sub-pages using our template.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigation paths will be mapped to the same route pattern and component, but
    with different information, as shown in the following screenshot:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.32: Navigate to /user/2'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_32.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.32: Navigate to /user/2'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on `User 1`, you will see the following:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.33: Navigate to /user/1'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_33.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.33: Navigate to /user/1'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also normalize `id` to the `props` of the `User` component with `props:
    true` and combine it with `beforeRouteEnter()` to load data of the selected user
    before the instance is created and rendered:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now we can adjust `<template>` to print out the details of the user:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The output when selecting `/user/1` will now be as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.34: Navigate to /user/1 with updated UI'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_06_34.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.34: Navigate to /user/1 with updated UI'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'And if we are in the `user/:id` route and change the `:id` to another user,
    we need to update the local data accordingly since `beforeRouteEnter` will not
    be triggered again in this case. In fact, all the lifecycle Hooks of the components
    will not be called, as the component instance is not re-created:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In this section, we looked at dynamic routing by setting up a route that extracts
    a parameter from the given URL. This technique allows you to create user-friendly
    URLs and pass information to routes dynamically. In the next section, we will
    look at catching error paths.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Catching Error Paths
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Other important routes that we always need to remember to handle besides the
    `Home` page ('`/`') include `error` routes, such as `404 Not found` when the URL
    path doesn't match any registered path, among others.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'For `404 Not found`, we can use the `regex` asterisk `*`, which stands for
    *matching everything* to collect all the cases that don''t match the routes. This
    router''s configuration should be located at the end of the array routes to avoid
    matching the wrong path:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`404 未找到`，我们可以使用`regex`星号`*`，它代表*匹配所有内容*来收集所有不匹配路由的情况。此路由器的配置应位于数组`routes`的末尾，以避免匹配错误路径：
- en: '[PRE71]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'When we type a wrong path for `/users`, the output will be as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为`/users`输入错误的路径时，输出将如下所示：
- en: '![Figure 6.35: Redirect to 404 when the ''/users'' path is not found'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.35：当''/users''路径未找到时重定向到404'
- en: '](img/B15218_06_35.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_06_35.jpg](img/B15218_06_35.jpg)'
- en: 'Figure 6.35: Redirect to 404 when the ''/users'' path is not found'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.35：当'/users'路径未找到时重定向到404
- en: In this section, we looked at how the `*` regex wildcard can be used to create
    a catch-all `404` page displayed to anyone that navigates to a non-existent route.
    Next, we will be implementing a message route that passes relevant data in the
    URL itself using a dynamic routing pattern.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何使用`*`正则表达式通配符来创建一个显示给所有导航到不存在路由的人的`404`页面。接下来，我们将实现一个消息路由，使用动态路由模式在URL本身传递相关数据。
- en: 'Exercise 6.05: Implementing a Message Route for Each Message with a Dynamic
    Routing Pattern'
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.05：使用动态路由模式为每个消息实现消息路由
- en: Going back to our message feed in *Exercise 6.04*, *Extracting a Messages List
    to an External File and Loading Only When MessageFeed Is in View*, we will refactor
    our `Message` path to use routing patterns to dynamically navigate to a specific
    message path upon the user's selection. This will get you familiar with creating
    and maintaining dynamic routes in combination with other navigation Hooks.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的消息源在*练习6.04*中，*将消息列表提取到外部文件并在MessageFeed视图中加载*，我们将重构我们的`Message`路径，使用路由模式在用户选择时动态导航到特定的消息路径。这将使你熟悉在与其他导航钩子结合时创建和维护动态路由。
- en: To access the code files for this exercise, refer to [https://packt.live/32sWogX](https://packt.live/32sWogX).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/32sWogX](https://packt.live/32sWogX)。
- en: 'Let''s open `./src/router/index.js` and have the path configuration of the
    message route change to `/message/:id`, where `id` will be the index of that `message`
    in the list of messages:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开`./src/router/index.js`，将消息路由的路径配置更改为`/message/:id`，其中`id`将是消息列表中该`message`的索引：
- en: '[PRE72]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now navigate to `./src/views/MessageFeed.vue` and change the `to` prop of `router-link`
    for each message to the following:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在导航到`./src/views/MessageFeed.vue`，并将每个消息的`router-link`的`to`属性更改为以下内容：
- en: '[PRE73]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Let''s go back to `./src/router/index.js` and define `beforeEnter` as an asynchronous
    Hook for lazy-loading the content of the message into the content prop of our
    `Message` component:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到`./src/router/index.js`，并将`beforeEnter`定义为异步钩子，用于将消息内容懒加载到我们的`Message`组件的内容属性中：
- en: '[PRE74]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Run the application using the following command:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行应用程序：
- en: '[PRE75]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'When clicking on the first message in the `Message Feed`, the next page will
    be as follows:'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当点击`消息源`中的第一条消息时，下一页将如下所示：
- en: '![Figure 6.36: The page displayed when visiting the /message/0 path'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.36：访问/message/0路径时显示的页面'
- en: '](img/B15218_06_36.jpg)'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_06_36.jpg](img/B15218_06_36.jpg)'
- en: 'Figure 6.36: The page displayed when visiting the /message/0 path'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.36：访问/message/0路径时显示的页面
- en: Now that you have learned how to use dynamic routing, you can play around even
    further with more layers of routing patterns, such as `message/:id/author/:aid`.
    However, for such a case, we normally use a better approach, **nested routes**.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何使用动态路由，你可以进一步探索更多层级的路由模式，如`message/:id/author/:aid`。然而，对于这种情况，我们通常采用更好的方法，**嵌套路由**。
- en: Nested Routes
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套路由
- en: In reality, many applications are composed of components that consist of several
    multiple-level nested components. For example, `/user/settings/general` indicates
    that a general view is nested in the `settings` view and this `settings` view
    is nested within the `user` view. It represents the `General information` section
    of a user's settings page.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，许多应用程序由由多个多级嵌套组件组成的组件构成。例如，`/user/settings/general`表示一个通用视图嵌套在`settings`视图中，而这个`settings`视图又嵌套在`user`视图中。它代表用户设置页面的`通用信息`部分。
- en: 'Most of the time, we want the URL to correspond to such a structure, as demonstrated
    in the following screenshot:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们希望URL与以下截图所示的结构相对应：
- en: '![Figure 6.37: User with two nested views – Info and Extra'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.37：具有两个嵌套视图的用户 – 信息和额外信息'
- en: '](img/B15218_06_37.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_06_37.jpg](img/B15218_06_37.jpg)'
- en: 'Figure 6.37: User with two nested views – Info and Extra'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.37：具有两个嵌套视图（信息和个人资料）的用户
- en: Vue Router makes it easy to achieve this structure using `nested` route configurations
    and the `router-view` component.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: Vue Router通过使用`嵌套`路由配置和`router-view`组件，使实现这种结构变得简单。
- en: 'Let''s go back to the `User.vue` view in our previous example (located in `./src/views/`)
    and add a nested `router-view` component in the `<template>` section:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到之前示例中的`User.vue`视图（位于`./src/views/`），并在`<template>`部分添加一个嵌套的`router-view`组件：
- en: '[PRE76]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In order to start rendering components to this `router-view`, we will configure
    the `user` route to have the children option, which accepts an array of route
    configurations for the child routes. For our example, we''ll be adding an `info`
    and `extra` page for each user. These child routes will be accessed as `/user/:id/info`
    and `/user/:id/extra` giving each user a unique `info` and `extra` page:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始向此`router-view`渲染组件，我们将配置`user`路由以具有子选项，该选项接受子路由的路线配置数组。在我们的示例中，我们将为每个用户添加一个“信息”和“额外”页面。这些子路由将通过`/user/:id/info`和`/user/:id/extra`访问，为每个用户提供唯一的“信息”和“额外”页面：
- en: '[PRE77]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Not all the nested paths need to start with `/` as their parent path, which
    will avoid them being treated as a root path and make things easier for Vue Router
    to compute the matching route.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有嵌套路径都需要以`/`开头作为其父路径，这将避免它们被视为根路径，并使Vue Router计算匹配的路由更加容易。
- en: 'Of course, we will have to create two new views in the folder that will render
    all the information about a user based on the `id` received:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们将在文件夹中创建两个新的视图，这些视图将根据接收到的`id`渲染有关用户的所有信息：
- en: '[PRE78]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We also create `UserExtra.vue`, which will render extra information (if there
    is any). In this example, it will render only simple text:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了`UserExtra.vue`，它将渲染额外信息（如果有）。在这个例子中，它将仅渲染简单的文本：
- en: '[PRE79]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The nested views are ready! Whenever the user clicks on the `Info` link, it
    will load the `UserInfo` view into it and update the URL as follows:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套视图已准备就绪！每当用户点击“信息”链接时，它将加载“用户信息”视图并更新URL如下：
- en: '![Figure 6.38: User page with nested UserInfo view'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.38：包含嵌套用户信息视图的用户页面'
- en: '](img/B15218_06_38.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_06_38.jpg]'
- en: 'Figure 6.38: User page with nested UserInfo view'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.38：包含嵌套用户信息视图的用户页面
- en: 'When the user clicks on `Extra`, they will see the same as is shown in the
    following screenshot:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击“额外”时，他们将看到以下截图所示的内容：
- en: '![Figure 6.39: User page with nested UserExtra view'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.39：包含嵌套用户额外视图的用户页面'
- en: '](img/B15218_06_39.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_06_39.jpg]'
- en: 'Figure 6.39: User page with nested UserExtra view'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.39：包含嵌套用户额外视图的用户页面
- en: In this section we looked at nested routes, that is, routes that have multiple
    children. In our example, the child routes were user info and user extra. This
    pattern allows us to create pages that extend their parent pages. In the preceding
    example, we can now make edits to the `About a user` header and have it take effect
    on all child routes. As projects grow, making use of this pattern will allow you
    to avoid having duplicate code across multiple views.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了嵌套路由，即具有多个子路由的路由。在我们的示例中，子路由是用户信息和用户额外。这种模式允许我们创建扩展其父页面的页面。在前面的示例中，我们现在可以编辑“关于用户”标题，并使其对所有子路由生效。随着项目的增长，利用这种模式将允许您避免在多个视图中重复代码。
- en: In the next section, we will use what we've learned so far to create navigation
    tabs for our message view component.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将利用到目前为止所学的内容来为我们的消息视图组件创建导航标签。
- en: 'Exercise 6.06: Building Navigation Tabs within the Message View'
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.06：在消息视图中构建导航标签
- en: We will adapt the knowledge learned from the *Nested Routes* section to build
    a `Message` view from *Exercise 6.05*, *Implementing a Message Route for Each
    Message with a Dynamic Routing Pattern*.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把从“嵌套路由”部分学到的知识应用到构建从“练习 6.05”中创建的“消息”视图。
- en: To access the code files for this exercise, refer to [https://packt.live/2U9Bn6I](https://packt.live/2U9Bn6I).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/2U9Bn6I](https://packt.live/2U9Bn6I)。
- en: 'Firstly, let''s make some changes to our `messages` database in `src/assets/messages.js`
    by adding the following `author` and `sent` fields:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们通过添加以下“作者”和“发送”字段来修改我们的`messages`数据库，该数据库位于`src/assets/messages.js`中：
- en: '[PRE80]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Next, we will create a `MessageAuthor.vue` view that renders only the name
    of the creator of the message:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`MessageAuthor.vue`视图，该视图仅渲染消息创建者的姓名：
- en: '[PRE81]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then we will create a `MessageInfo.vue` view that renders the `message.sent`
    value:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个`MessageInfo.vue`视图，该视图渲染`message.sent`值：
- en: '[PRE82]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Once we are done with the components, we need to register the new nested route
    under the children of the `message` route, inside our router at `src/router/index.js`:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们完成了组件，我们需要在我们的 `src/router/index.js` 路由中的 `message` 路由的子路由下注册新的嵌套路由：
- en: '[PRE83]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Finally, in `Message.vue`, we will refactor the code to the following:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `Message.vue` 中，我们将重构代码如下：
- en: '[PRE84]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'And now we can navigate between the `Author` and `Info` tabs within a `Message`
    as follows:'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们可以在一个 `Message` 中在 `Author` 和 `Info` 标签页之间导航如下：
- en: '![Figure 6.40: Message page with Info selected'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.40：选择 Info 的消息页面'
- en: '](img/B15218_06_40.jpg)'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_06_40.jpg]'
- en: 'Figure 6.40: Message page with Info selected'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.40：选择 Info 的消息页面
- en: 'Run the application using the following command:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行应用程序：
- en: '[PRE85]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'You will see the following when you select the `Author` option:'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你选择 `Author` 选项时，你会看到以下内容：
- en: '![Figure 6.41: Message page with Author selected'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.41：选择作者的消息页面'
- en: '](img/B15218_06_41.jpg)'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_06_41.jpg]'
- en: 'Figure 6.41: Message page with Author selected'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.41：选择作者的消息页面
- en: With this exercise, we have covered almost all the basic functionalities of
    Vue Router, especially on handling dynamic and nested routing. In the final section,
    we will go through how to create a reusable layout for view- templating our application.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习，我们几乎涵盖了 Vue Router 的所有基本功能，特别是处理动态和嵌套路由。在最后一节，我们将介绍如何为视图模板创建可重用的布局。
- en: Using Layouts
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用布局
- en: There are many ways to implement layouts in a Vue.js application. One of them
    is using `slot` and creating a static wrapper layout component on top of `router-view`.
    Despite its flexibility, this approach results in a heavy performance cost, both
    in the unnecessary re-creation of the component and in the extra data-fetching
    required on every route change.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue.js 应用程序中实现布局有许多方法。其中之一是使用 `slot` 并在 `router-view` 之上创建一个静态的包装器布局组件。尽管这种方法具有灵活性，但它会导致高昂的性能成本，包括组件的不必要重新创建以及在每次路由变化时所需的额外数据获取。
- en: 'In this section, we will discuss a better approach, which is to take advantage
    of the power of the dynamic component. The components are as follows:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一种更好的方法，即利用动态组件的力量。组件如下：
- en: '[PRE86]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In the `App.vue` file, we will change the default view generated by Vue CLI
    to only `<router-view>` and a wrapper around it. This wrapper is a dynamic component
    that will render whatever component is defined in the `layout` variable:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `App.vue` 文件中，我们将更改 Vue CLI 生成的默认视图，使其仅包含 `<router-view>` 和围绕它的包装器。这个包装器是一个动态组件，它将渲染在
    `layout` 变量中定义的任何组件：
- en: '[PRE87]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'By default, we will define `layout` in `data` to be the `default.vue` layout:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们将在 `data` 中定义 `layout` 为 `default.vue` 布局：
- en: '[PRE88]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'And in the `layouts` folder, we will create the `default` layout component
    with a simple header navigation, a `main` slot to render the actual content (which
    is whatever `<router-view>` renders), and a footer:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `layouts` 文件夹中，我们将创建一个具有简单头部导航、`main` 插槽以渲染实际内容（这是 `<router-view>` 渲染的内容）和页脚的
    `default` 布局组件：
- en: '[PRE89]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Going back to our `App.vue` file, in order to make the layout `component` render
    in response to corresponding route changes, `router-view` should control which
    layout to render. In other words, `layout` should be updatable and decided by
    the view component rendered inside `router-view`. To achieve this, we will define
    the `currentLayout` property as synchronous with `layout` using `sync` on `<router-view>`:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的 `App.vue` 文件，为了使布局 `component` 能够根据相应的路由变化进行渲染，`router-view` 应该控制渲染哪个布局。换句话说，`layout`
    应该是可更新的，并由 `router-view` 内部渲染的视图组件决定。为了实现这一点，我们将在 `<router-view>` 上使用 `sync` 定义
    `currentLayout` 属性与 `layout` 保持同步：
- en: '[PRE90]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'And upon creating an instance of the `Home.vue` component, we will emit an
    `update:currentLayout` event with the desired layout to be updated and rendered
    accordingly:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `Home.vue` 组件的实例时，我们将发出一个带有期望更新的布局的 `update:currentLayout` 事件，并相应地渲染：
- en: '[PRE91]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The output will be as follows:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Figure 6.42: Home page rendered with a layout'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.42：使用布局渲染的首页'
- en: '](img/B15218_06_42.jpg)'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_06_42.jpg]'
- en: 'Figure 6.42: Home page rendered with a layout'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.42：使用布局渲染的首页
- en: Since the `layout` component is not part of the `router-view` component, it
    will only re-render whenever the layout changes from within the view. This will
    maintain the performance of the app during user navigation.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `layout` 组件不是 `router-view` 组件的一部分，它只有在布局从视图内部发生变化时才会重新渲染。这将保持应用程序在用户导航时的性能。
- en: In this section, we looked at how the dynamic `component` component can be used
    to provide different layouts for different routes. This gives us the ability to
    have different common layouts, for example, one global menu for user-facing pages
    and another for admin pages, rendered based on the routes used. In the next section,
    we'll build on what we learned here by creating a message application with dynamic
    nested routing and layouts.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何使用动态`component`组件为不同的路由提供不同的布局。这使我们能够拥有不同的通用布局，例如，一个用于用户界面页面的全局菜单和另一个用于管理页面的菜单，这些菜单将根据使用的路由进行渲染。在下一节中，我们将通过创建一个具有动态嵌套路由和布局的消息应用来构建我们在这里学到的内容。
- en: 'Activity 6.01: Creating a Message SPA with Dynamic, Nested Routing, and Layouts'
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 6.01：创建具有动态、嵌套路由和布局的消息 SPA
- en: 'This activity aims to leverage your knowledge about Vue Router regarding registering
    routes and handling dynamic routes, nested routes, and route Hooks to create a
    **Message** **SPA**. This application will allow users to compose new messages,
    view a message feed, and navigate between messages to see their details:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动旨在利用您关于Vue Router的知识，包括注册路由、处理动态路由、嵌套路由和路由钩子，以创建**消息****SPA**。此应用将允许用户编写新消息、查看消息流并在消息之间导航以查看其详细信息：
- en: Create a `MessageEditor` view (at `src/views/MessageEditor.vue`) that will render
    a view with `textarea` to the user and a `submit` button to save the message.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`MessageEditor`视图（在`src/views/MessageEditor.vue`），它将为用户渲染一个带有`textarea`的视图和一个`submit`按钮来保存消息。
- en: Register the `editor` route with `MessageEditor` as its view in `src/router/index.js`.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/router/index.js`中将`editor`路由与`MessageEditor`视图注册。
- en: Create a `MessageList` view (at `src/views/MessageList.vue`) that will render
    a list of `message id` values wrapped by an `a` tag, which will direct to the
    single message page with the given `id` upon selection.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`MessageList`视图（在`src/views/MessageList.vue`），它将渲染一个由`a`标签包裹的`message id`值的列表，当选择时，将跳转到具有给定`id`的单个消息页面。
- en: Register the `list` route with `MessageList` as its view in `src/router/index.js`.
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/router/index.js`中将`list`路由与`MessageList`视图注册。
- en: Add the `Messages` view (at `src/views/Messages.vue`), which will render links
    to either `editor` or `list` as its nested routes and render the nested view accordingly.
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Messages`视图（在`src/views/Messages.vue`），它将渲染指向`editor`或`list`的链接作为其嵌套路由，并相应地渲染嵌套视图。
- en: When the user navigates away from `editor`, should some content not yet have
    been submitted, display a message asking if they want to save before navigating
    away. `Yes` will continue, `No` will abort the navigation.
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户从`editor`导航离开时，如果某些内容尚未提交，应显示一条消息询问他们是否在导航离开前保存。选择`Yes`将继续，选择`No`将中止导航。
- en: Add a `Message` view (at `src/views/Message.vue`), which will render message
    content from `props` and have a `back` button to go back to the previous view.
    By default, it should go to `messages`.
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`Message`视图（在`src/views/Message.vue`），它将从`props`渲染消息内容并具有一个返回按钮以返回到上一个视图。默认情况下，它应跳转到`messages`。
- en: Register the `Message` view with the dynamic route of `message/:id` in `src/router/index.js`.
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/router/index.js`中将`Message`视图与动态路由`message/:id`注册。
- en: Improve the UI by creating two different simple layouts, one for `messages`
    (with the title only) and one for `message` (with both the `title` and the `back`
    button).
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建两个不同的简单布局来改进UI，一个用于`messages`（仅包含标题）和一个用于`message`（包含标题和返回按钮）。
- en: 'The expected output is as follows:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: 'The `/list` view that displays a feed of messages should look as follows:'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示消息流的`/list`视图应如下所示：
- en: '![Figure 6.43: The /list view in the Messages app'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.43：消息应用中的 /list 视图]'
- en: '](img/B15218_06_43.jpg)'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_06_43.jpg](img/B15218_06_43.jpg)'
- en: 'Figure 6.43: The /list view in the Messages app'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.43：消息应用中的 /list 视图
- en: 'The `/editor` view that allows the user to compose and send a new message looks
    as follows:'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户编写并发送新消息的`/editor`视图如下所示：
- en: '![Figure 6.44: The /editor view in the Messages app'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.44：消息应用中的 /editor 视图]'
- en: '](img/B15218_06_44.jpg)'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_06_44.jpg](img/B15218_06_44.jpg)'
- en: 'Figure 6.44: The /editor view in the Messages app'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.44：消息应用中的 /editor 视图]'
- en: 'The `/message/:id` dynamic route (here, `/message/0` for a message with the
    `id` of `0`) in the `Message` app looks as follows:'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Message`应用中的`/message/:id`动态路由（这里，`/message/0`表示具有`id`为`0`的消息）如下所示：'
- en: '![Figure 6.45: The /message/0 view in the Message app'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.45：消息应用中的 /message/0 视图]'
- en: '](img/B15218_06_45.jpg)'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_06_45.jpg](img/B15218_06_45.jpg)'
- en: 'Figure 6.45: The /message/0 view in the Message app'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.45：消息应用中的 /message/0 视图]'
- en: 'An alert will be displayed when the user tries to navigate away with an unsaved
    message as shown in the following screenshot:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户尝试带有未保存消息的导航离开时，将显示一个警告，如下面的截图所示：
- en: '![Figure 6.46: The /editor view when the user tries to navigate away with an
    unsaved message'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.46：当用户尝试带有未保存消息的导航离开时的/editor视图]'
- en: '](img/B15218_06_46.jpg)'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15218_06_46.jpg]'
- en: 'Figure 6.46: The /editor view when the user tries to navigate away with an
    unsaved message'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.46：当用户尝试带有未保存消息的导航离开时的/editor视图
- en: Note
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor393).
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以通过[此链接](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor393)找到。
- en: Summary
  id: totrans-533
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we have learned about the most basic and useful functionalities
    offered by Vue Router for building routing for any Vue.js application in an effective
    and organized manner.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Vue Router为构建任何Vue.js应用的路由所提供的最基本和最有用的功能，以有效和有序的方式进行。
- en: '`router-view` and `router-link` allow app developers to easily set up the navigation
    paths to their related views and maintain the SPA concept. The fact that they
    are Vue components themselves provides us as developers with the benefits of the
    Vue architecture, giving us flexibility in implementing nested views or layouts.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '`router-view`和`router-link`允许应用开发者轻松设置导航路径到相关视图，并保持SPA概念。它们本身是Vue组件的事实为我们开发者提供了Vue架构的好处，使我们能够在实现嵌套视图或布局时具有灵活性。'
- en: Defining the route as an object with different properties simplifies the architecture
    process, including refactoring existing paths and adding a new route to the system.
    Using router parameters and patterns provides dynamic routing with reusable views
    and allows communication and data preservation between pages.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 将路由定义为具有不同属性的对象简化了架构过程，包括重构现有路径和向系统中添加新路由。使用路由参数和模式提供了动态路由，具有可重用视图，并允许页面之间的通信和数据保留。
- en: And finally, with Hooks, we saw how we can intercept the navigation flow, setting
    up authentication where needed, redirecting to the desired path, or even loading
    and keeping some important data before the users land on the targeted page. There
    is an unlimited number of use cases where these Hooks can be extremely useful,
    such as when implementing a back button for instance.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过Hooks，我们看到了如何拦截导航流程，在需要的地方设置身份验证，重定向到期望的路径，甚至在用户到达目标页面之前加载并保留一些重要数据。这些Hooks有无数的使用场景，例如在实现返回按钮时非常有用。
- en: With these, we are now capable of composing a Vue.js application with a proper
    navigation system for users to explore, while maintaining the data flow in every
    navigation use case (dynamic routes and nested views) and the application design layout.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们现在能够为用户提供适当的导航系统来探索Vue.js应用，同时保持每个导航用例（动态路由和嵌套视图）的数据流以及应用设计布局。
- en: In the next chapter, you are going to explore how to apply transitions to the
    routing and different animations for beautiful loading effects for your Vue components
    and application.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将探索如何将过渡应用到路由上，并为你的Vue组件和应用添加不同的动画，以实现美丽的加载效果。
