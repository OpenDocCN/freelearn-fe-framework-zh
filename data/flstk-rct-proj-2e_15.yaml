- en: Building a Media Streaming Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Media Streaming 应用程序
- en: Uploading and streaming media content, specifically video content, has been
    a growing part of the internet culture for some time now. From individuals sharing
    personal video content to the entertainment industry disseminating commercial
    content on online streaming services, we all rely on web applications that enable
    smooth uploading and streaming. Capabilities within the MERN stack technologies
    can be used to build and integrate these core streaming features into any MERN-based
    full-stack application. In this chapter, we will extend the MERN skeleton application
    to build a media streaming application, while demonstrating how to utilize MongoDB
    GridFS and add media streaming features to your web applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上传和流式传输媒体内容，特别是视频内容，已经是一段时间来互联网文化中增长的部分。从个人分享个人视频内容到娱乐行业在在线流媒体服务上传播商业内容，我们都依赖于能够实现顺畅上传和流式传输的
    Web 应用程序。MERN 技术栈中的功能可以用于构建和集成这些核心流媒体功能到任何基于 MERN 的全栈应用程序中。在本章中，我们将扩展 MERN 框架应用程序来构建一个媒体流媒体应用程序，同时展示如何利用
    MongoDB GridFS 并将媒体流式传输功能添加到您的 Web 应用程序中。
- en: 'In this chapter, we will cover the following topics to implement basic media
    uploading and streaming by extending the MERN skeleton application:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题，通过扩展 MERN 框架应用程序来实现基本的媒体上传和流式传输：
- en: Introducing MERN Mediastream
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 MERN Mediastream
- en: Uploading videos to MongoDB GridFS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将视频上传到 MongoDB GridFS
- en: Storing and retrieving media details
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储和检索媒体详情
- en: Streaming videos from GridFS to a basic media player
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 GridFS 流式传输视频到基本媒体播放器
- en: Listing, displaying, updating, and deleting media
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出、显示、更新和删除媒体
- en: Introducing MERN Mediastream
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 MERN Mediastream
- en: 'We will build the MERN Mediastream application by extending the skeleton application.
    This will be a simple video streaming application that allows registered users
    to upload videos that can be streamed by anyone browsing the application. The
    following screenshot shows the home page view on the MERN Mediastream application,
    along with a list of popular videos on the platform:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过扩展框架应用程序来构建 MERN Mediastream 应用程序。这将是一个简单的视频流媒体应用程序，允许注册用户上传任何浏览应用程序的人都可以流式传输的视频。以下截图显示了
    MERN Mediastream 应用程序的主页视图，以及平台上流行的视频列表：
- en: '![](img/a726f61d-5154-48bd-a13e-ae648367456b.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a726f61d-5154-48bd-a13e-ae648367456b.png)'
- en: The code for the complete MERN Mediastream application is available on GitHub
    at [https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter11%20and%2012/mern-mediastream](https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter11%20and%2012/mern-mediastream).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 MERN Mediastream 应用程序的代码可在 GitHub 上找到：[https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter11%20and%2012/mern-mediastream](https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter11%20and%2012/mern-mediastream)。
- en: You can clone this code and run the application as you go through the code explanations
    in the rest of this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以克隆此代码，并在阅读本章其余部分的代码解释时运行应用程序。
- en: 'The frontend user interface views that are needed for the features related
    to media uploading, editing, and streaming in a simple media player will be developed
    by extending and modifying existing React components in the MERN skeleton application. The
    component tree shown in the following diagram shows all the custom React components
    that make up the MERN Mediastream frontend that will be developed in this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 需要开发用于简单媒体播放器中媒体上传、编辑和流媒体功能的用户界面视图，这些视图将通过扩展和修改 MERN 框架应用程序中的现有 React 组件来实现。以下图表显示了将在本章中开发的
    MERN Mediastream 前端的所有自定义 React 组件：
- en: '![](img/80f78dff-f6a3-48b6-9244-f532cb0ffa45.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/80f78dff-f6a3-48b6-9244-f532cb0ffa45.png)'
- en: We will add new React components to implement views for uploading a new video,
    listing already posted media, modifying media post details, and displaying a video
    where users can interact with the video content to stream and watch it. We will also
    modify existing components such as the `Home` component so we can render a list
    of popular videos and the `Profile` component so we can list all the videos that
    are posted by a given user. These uploading and streaming capabilities in the
    application will rely on the user's ability to upload video content. In the next
    section, we will discuss how to allow signed-in users to add media to the application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加新的React组件来实现上传新视频、列出已发布的媒体、修改媒体帖子细节以及显示视频的视图。用户可以与视频内容进行交互以流式传输和观看视频。我们还将修改现有的组件，例如`Home`组件，以便我们可以渲染热门视频列表，以及`Profile`组件，以便我们可以列出特定用户发布的所有视频。应用程序中的上传和流媒体功能将依赖于用户上传视频内容的能力。在下一节中，我们将讨论如何允许已登录用户向应用程序添加媒体。
- en: Uploading and storing media
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传和存储媒体
- en: Registered users on the MERN Mediastream application will be able to upload
    videos from their local files to store each video and related details directly
    on MongoDB using GridFS. To enable uploading media content to the application,
    we need to define how to store media details and the video content and implement
    a full-stack slice that will let users create a new media post and upload a video
    file. In the following sections, first we will define a media model for storing
    the details of each media post and configure GridFS to store the associated video
    content. Then, we will discuss implementations for the backend API, which will
    receive and store the video content with other media details, and the frontend
    form view, which will allow a user to create a new media post on the application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: MERN Mediastream应用程序的注册用户将能够从本地文件上传视频，并使用GridFS直接在MongoDB上存储每个视频及其相关细节。为了使应用程序能够上传媒体内容，我们需要定义如何存储媒体细节和视频内容，并实现一个全栈切片，使用户能够创建新的媒体帖子并上传视频文件。在接下来的章节中，首先我们将定义一个媒体模型来存储每个媒体帖子的细节，并配置GridFS以存储相关的视频内容。然后，我们将讨论后端API的实现，该API将接收并存储视频内容以及其他媒体细节，以及前端表单视图，它将允许用户在应用程序上创建新的媒体帖子。
- en: Defining a Media model
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义媒体模型
- en: 'We will implement a Mongoose model to define a Media model for storing the
    details of each piece of media that''s posted to the application. This model will
    be defined in `server/models/media.model.js`, and the implementation will be similar
    to other Mongoose model implementations we covered in the previous chapters, such
    as the Course model we defined in [Chapter 6](c58ac055-5a1e-4bf4-b8a6-c9b311cf267a.xhtml), *Building
    a Web-Based Classroom Application*. The Media schema in this model will have fields
    to record the media title, description, genre, number of views, dates of when
    the media was posted and updated, and a reference to the user who posted the media. The
    code for defining the media fields is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个Mongoose模型来定义一个媒体模型，用于存储发布到应用程序的每条媒体的细节。此模型将在`server/models/media.model.js`中定义，其实现将与我们在前几章中介绍的Mongoose模型实现类似，例如我们在[第6章](c58ac055-5a1e-4bf4-b8a6-c9b311cf267a.xhtml)中定义的课程模型。该模型中的媒体模式将包含记录媒体标题、描述、类型、观看次数、媒体发布和更新的日期以及引用发布媒体的用户的字段。定义媒体字段的代码如下：
- en: '**Media title**: The `title` field is declared to be of the `String` type and
    will be a required field for introducing the media that are uploaded to the application:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**媒体标题**：`title`字段被声明为`String`类型，并将是一个必填字段，用于介绍上传到应用程序的媒体：'
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Media description and genre**: The `description` and `genre` fields will
    be of type `String`, and these will store additional details about the media posted.
    The `genre` field will also allow us to group the different media uploaded to
    the application.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**媒体描述和类型**：`description`和`genre`字段将属于`String`类型，并将存储有关发布的媒体的其他细节。`genre`字段还将允许我们将上传到应用程序的不同媒体分组。'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Number of views**: The `views` field is defined as a `Number` type and will
    keep track of how many times the uploaded media was viewed by users in the application:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观看次数**：`views`字段定义为`Number`类型，并将跟踪上传的媒体在应用程序中被用户观看的次数：'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Media posted by**: The `postedBy` field will reference the user who created
    the media post:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布媒体的用户**：`postedBy`字段将引用创建媒体帖子的用户：'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Created and updated at times**: The `created` and `updated` fields will be `Date` types,
    with `created` generated when a new media is added and `updated` changed when
    any media details are modified:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建和更新时间**：`created`和`updated`字段将是`Date`类型，`created`在添加新媒体时生成，`updated`在修改任何媒体详细信息时更改：'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The fields that were added to the schema definition will only store details
    about each video that's posted to the application. In order to store the video
    content itself, we will use MongoDB GridFS. Before getting into the implementation
    of uploading a video file, in the next section we will discuss how GridFS makes
    it possible to store large files in MongoDB, and then add initialization code
    to start using GridFS in this streaming application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到模式定义中的字段将只存储关于每个发布到应用程序的视频的详细信息。为了存储视频内容本身，我们将使用MongoDB GridFS。在下一节中，在讨论如何实现上传视频文件之前，我们将讨论GridFS如何使MongoDB中存储大文件成为可能，然后添加初始化代码以开始在这个流式应用中使用GridFS。
- en: Using MongoDB GridFS to store large files
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MongoDB GridFS存储大文件
- en: In previous chapters, we discussed how files uploaded by users could be stored
    directly in MongoDB as binary data; for example, when adding a profile photo in the
    *Upload profile photo* section in [Chapter 5](27d3dbdf-0617-4ad8-9dcc-27afa417c174.xhtml),
    *Growing the Skeleton into a Social Media Application*. But this only worked for
    files smaller than 16 MB. In order to store larger files in MongoDB, such as video
    files needed for this streaming application, we will need to use GridFS.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了用户上传的文件可以直接作为二进制数据存储在MongoDB中；例如，在[第5章](27d3dbdf-0617-4ad8-9dcc-27afa417c174.xhtml)的“上传个人照片”部分添加个人照片时。但这仅适用于小于16
    MB的文件。为了在MongoDB中存储更大的文件，例如本流式应用所需的视频文件，我们需要使用GridFS。
- en: GridFS is a specification in MongoDB that allows us to store large files in
    MongoDB by dividing a given file into several chunks. Each chunk can be a maximum
    of 255 KB in size, and is stored as a separate document. When the file has to
    be retrieved in response to a query to GridFS, the chunks are reassembled as needed.
    This opens up the option to fetch and load only parts of the file as required,
    rather than retrieving the whole file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: GridFS是MongoDB中的一个规范，允许我们将一个给定的文件分割成几个块来存储在MongoDB中。每个块的大小最大为255 KB，并作为单独的文档存储。当需要根据对GridFS的查询检索文件时，块会根据需要重新组装。这提供了只获取和加载文件所需部分而不是整个文件的功能。
- en: In the case of storing and retrieving video files for the MERN Mediastream application,
    we will utilize GridFS to store video files and stream parts of the video, depending
    on which part the user skips to and starts playing from.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储和检索MERN Mediastream应用程序的视频文件的情况下，我们将利用GridFS来存储视频文件，并根据用户跳转到的部分和开始播放的部分流式传输视频的相应部分。
- en: You can learn more about the GridFS specification and its features in the official
    MongoDB documentation at [https://docs.mongodb.com/manual/core/gridfs/](https://docs.mongodb.com/manual/core/gridfs/).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方MongoDB文档中了解更多关于GridFS规范及其功能的信息，请参阅[https://docs.mongodb.com/manual/core/gridfs/](https://docs.mongodb.com/manual/core/gridfs/)。
- en: To access and work with MongoDB GridFS from our backend code, we will use the Node.js
    MongoDB driver's streaming API by creating a `GridFSBucket` with the established
    database connection.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们的后端代码访问和使用MongoDB GridFS，我们将通过创建一个`GridFSBucket`并使用建立的数据库连接来使用Node.js MongoDB驱动程序的流式API。
- en: GridFSBucket is the GridFS streaming interface that gives us access to the streaming
    GridFS API. It can be used to interact with files in GridFS. You can learn more
    about GridFSBucket and the streaming API in the Node.js MongoDB Driver API documentation
    at [https://mongodb.github.io/node-mongodb-native/3.2/api/GridFSBucket.html](https://mongodb.github.io/node-mongodb-native/3.2/api/GridFSBucket.html).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: GridFSBucket是GridFS流式接口，它为我们提供了访问流式GridFS API的权限。它可以用来与GridFS中的文件进行交互。您可以在Node.js
    MongoDB驱动程序API文档中了解更多关于GridFSBucket和流式API的信息，请参阅[https://mongodb.github.io/node-mongodb-native/3.2/api/GridFSBucket.html](https://mongodb.github.io/node-mongodb-native/3.2/api/GridFSBucket.html)。
- en: Since we are using Mongoose to establish a connection with the MongoDB database
    for our application, we will add the following code to initialize a new `GridFSBucket`
    with this database connection after it has been established.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用Mongoose与MongoDB数据库建立应用程序的连接，因此将在连接建立后添加以下代码来初始化一个新的`GridFSBucket`。
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/controllers/media.controller.js`:'
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `gridfs` object we created here will give us access to the GridFS functionalities
    that are required to store the video file when new media is created and to fetch
    the file when the media is to be streamed back to the user. In the next section,
    we will add a create media form view and an API in the backend, which will use
    this `gridfs` object to save the video file that's uploaded with the request that's
    sent from the form view in the frontend.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在这里创建的`gridfs`对象将为我们提供访问GridFS功能，这些功能在创建新媒体时存储视频文件以及在媒体要流回用户时检索文件时是必需的。在下一节中，我们将添加创建媒体表单视图和后端API，这些API将使用此`gridfs`对象来保存与前端表单视图发送的请求一起上传的视频文件。 '
- en: Creating a new media post
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的媒体帖子
- en: For a user to be able to create a new media post on the application, we will
    need to integrate a full-stack slice that allows the user to fill out a form in
    the frontend and then save both the provided media details and the associated
    video file in the database in the backend. To implement this feature, in the following
    sections, we will add a create media API in the backend, along with a way to fetch
    this API in the frontend. Then, we will implement a create new media form view
    that allows the user to input media details and select a video file from their
    local filesystem.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户能够在应用程序中创建新的媒体帖子，我们需要集成一个全栈切片，允许用户在前端填写表单，然后在后端将提供的媒体细节和相关的视频文件保存到数据库中。为了实现这个功能，在接下来的章节中，我们将在后端添加一个创建媒体API，以及在前端获取此API的方法。然后，我们将实现一个创建新媒体表单视图，允许用户输入媒体细节并从他们的本地文件系统中选择视频文件。
- en: The create media API
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建媒体API
- en: We will implement a create media API in the backend to allow users to create
    new media posts on the application. This API will receive a POST request at `'/api/media/new/:userId'`
    with the multipart body content containing the media fields and the uploaded video
    file. First, we will declare the create media route and utilize the `userByID`
    method from the user controller, as shown in the following code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后端实现一个创建媒体API，允许用户在应用程序上创建新的媒体帖子。此API将在`'/api/media/new/:userId'`接收包含媒体字段和上传的视频文件的multipart请求体。首先，我们将声明创建媒体路由并利用用户控制器中的`userByID`方法，如下所示。
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/routes/media.routes.js`:'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `userByID` method processes the `:userId` parameter that's passed in the
    URL and retrieves the associated user from the database. The user object becomes
    available in the request object to be used in the next method that will be executed. Similar
    to the user and auth routes, we will have to mount the media routes on the Express
    app in `express.js` as follows.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`userByID`方法处理URL中传递的`:userId`参数，并从数据库中检索相关的用户。用户对象将在请求对象中可用，以便在将要执行的下一种方法中使用。类似于用户和认证路由，我们将在`express.js`中将媒体路由挂载到Express应用上，如下所示。'
- en: '`mern-mediastream/server/express.js`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/express.js`:'
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A POST request to the create route URL, `/api/media/new/:userId`, will make
    sure the user is signed in and then initiate the `create` method in the media
    controller. The `create` controller method will use the `formidable` node module
    to parse the multipart request body that will contain the media details and video
    file uploaded by the user. You can install the module by running the following
    command from the command line:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 向创建路由URL `/api/media/new/:userId` 发送POST请求，将确保用户已登录，然后初始化媒体控制器中的`create`方法。`create`控制器方法将使用`formidable`节点模块来解析包含用户上传的媒体细节和视频文件的multipart请求体。您可以从命令行运行以下命令来安装此模块：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the `create` method, we will use the media fields that have been received
    in the form data and parsed with `formidable` to generate a new Media object and
    then save it to the database. This `create` controller method is defined as follows.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`create`方法中，我们将使用在表单数据中接收并使用`formidable`解析的媒体字段来生成一个新的媒体对象，并将其保存到数据库中。这个`create`控制器方法定义如下。
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/controllers/media.controller.js`:'
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If there is a file in the request, `formidable` will store it temporarily in
    the filesystem. We will use this temporary file and the media object's ID to create
    a writable stream with `gridfs.openUploadStream`. Here, the temporary file will
    be read and then written into MongoDB GridFS, while setting the `filename` value
    to the media ID. This will generate the associated chunks and file information
    documents in MongoDB, and when it is time to retrieve this file, we will identify
    it with the media ID.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求中有文件，`formidable` 将将其临时存储在文件系统中。我们将使用这个临时文件和媒体对象的 ID，通过 `gridfs.openUploadStream`
    创建一个可写流。在这里，临时文件将被读取并写入 MongoDB GridFS，同时设置 `filename` 值为媒体 ID。这将生成与 MongoDB 中的相关块和文件信息文档，当需要检索此文件时，我们将使用媒体
    ID 来识别它。
- en: To use this create media API in the frontend, we will add a corresponding `fetch`
    method in `api-media.js` to make a `POST` request to the API by passing the multipart
    form data from the view. This method will be defined as follows.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要在前端使用此创建媒体 API，我们将在 `api-media.js` 中添加相应的 `fetch` 方法，通过传递视图中的多部分表单数据向 API 发送
    `POST` 请求。此方法将定义如下。
- en: '`mern-mediastream/client/media/api-media.js`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/api-media.js`:'
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This `create` fetch method will take the current user's ID, user credentials,
    and the media form data to make a POST request to the create media API in the
    backend. We will use this method when the user submits the new media form to upload
    a new video and post it on the application. In the next section, we will look
    at the implementation of this form view in the frontend.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `create` 获取方法将获取当前用户的 ID、用户凭据和媒体表单数据，向后端创建媒体 API 发送 POST 请求。当用户提交新的媒体表单以上传新视频并在应用程序上发布时，我们将使用此方法。在下一节中，我们将查看前端中此表单视图的实现。
- en: The NewMedia component
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新媒体组件
- en: Registered users on the MERN Mediastream application will interact with a form
    view to enter details of a new media post. This form view will be rendered in
    the `NewMedia` component, which will allow a signed-in user to create a media
    post by entering the title, description, and genre of the video and uploading
    a video file from their local filesystem.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MERN Mediastream 应用程序上注册的用户将通过表单视图输入新媒体帖子的详细信息。此表单视图将在 `NewMedia` 组件中渲染，允许已登录用户通过输入视频的标题、描述和类型以及从本地文件系统中上传视频文件来创建媒体帖子。
- en: 'This form view will render as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此表单视图将呈现如下：
- en: '![](img/044f5619-fbaa-42bb-bcad-e5d2f97c93f6.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/044f5619-fbaa-42bb-bcad-e5d2f97c93f6.png)'
- en: We will implement this form in a React component named `NewMedia`. For the view,
    we will add the file upload elements using a Material-UI `Button` and an HTML5
    file `input` element, as shown in the following code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个名为 `NewMedia` 的 React 组件中实现此表单。对于视图，我们将使用 Material-UI 的 `Button` 和 HTML5
    文件 `input` 元素添加文件上传元素，如下面的代码所示。
- en: '`mern-mediastream/client/media/NewMedia.js`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/NewMedia.js`:'
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the file `input` element, we specify that it accepts video files, so when
    the user clicks on Upload and browses through their local folders, they only have
    the option to upload a video file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `input` 元素中，我们指定它接受视频文件，因此当用户点击上传并浏览其本地文件夹时，他们只有上传视频文件的选择。
- en: Then, in the view, we add the title, description, and genre form fields with
    the `TextField` components, as shown in the following code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在视图中，我们添加了标题、描述和类型的表单字段，使用 `TextField` 组件，如下面的代码所示。
- en: '`mern-mediastream/client/media/NewMedia.js`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/NewMedia.js`:'
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These form field changes will be tracked with the `handleChange` method when
    a user interacts with the input fields to enter values. The `handleChange` function
    will be defined as follows.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户与输入字段交互输入值时，这些表单字段更改将通过 `handleChange` 方法进行跟踪。`handleChange` 函数将定义如下。
- en: '`mern-mediastream/client/media/NewMedia.js`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/NewMedia.js`:'
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `handleChange` method updates the state with the new values, including the
    name of the video file, if one is uploaded by the user.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleChange` 方法通过更新状态来跟踪新值，包括如果用户上传了视频文件，则包括视频文件名。'
- en: Finally, you can complete this form view by adding a Submit button, which, when
    clicked, should send the form data to the server. We will define a `clickSubmit` method
    here, which will be called when the Submit button is clicked by the user.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以通过添加一个提交按钮来完成此表单视图，当用户点击提交按钮时，应将表单数据发送到服务器。我们在这里定义一个 `clickSubmit` 方法，当用户点击提交按钮时将被调用。
- en: '`mern-mediastream/client/media/NewMedia.js`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/NewMedia.js`:'
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This `clickSubmit` function will take the input values and populate `mediaData`,
    which is a `FormData` object that ensures the data is stored in the correct format
    for the `multipart/form-data` encoding type. Then, the `create` fetch method is
    called to create the new media in the backend with this form data. On successful
    media creation, the user may be redirected to a different view as desired, for
    example, to a Media view with the new media details, as shown in the following
    code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此`clickSubmit`函数将获取输入值并填充`mediaData`，这是一个`FormData`对象，确保数据以正确的格式存储在`multipart/form-data`编码类型中。然后，调用`create`
    fetch方法使用此表单数据在后端创建新的媒体。在成功创建媒体后，用户可能会被重定向到不同的视图，例如，到一个包含新媒体详情的媒体视图，如下面的代码所示。
- en: '`mern-mediastream/client/media/NewMedia.js`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/NewMedia.js`:'
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `NewMedia` component can only be viewed by a signed-in user. Therefore,
    we will add a `PrivateRoute` in the `MainRouter` component, which will render
    this form only for authenticated users at `/media/new`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewMedia`组件只能由已登录用户查看。因此，我们将在`MainRouter`组件中添加一个`PrivateRoute`，这样它只会在`/media/new`为认证用户渲染此表单。'
- en: '`mern-mediastream/client/MainRouter.js`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/MainRouter.js`:'
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This link can be added to any view, such as in the Menu component, so that it's
    rendered conditionally when users are signed in. Now that it is possible to add
    new media posts in this media streaming application, in the next section we will
    discuss the implementation of retrieving and rendering the video content associated
    with each media post. This will allow users to stream and view video files stored
    in MongoDB GridFS from the frontend of the application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此链接可以添加到任何视图，例如在菜单组件中，以便在用户登录时条件性地渲染。现在，由于可以在本媒体流应用中添加新的媒体帖子，在下一节中，我们将讨论检索和渲染与每个媒体帖子关联的视频内容的实现。这将使用户能够从应用程序的前端流式传输和查看存储在MongoDB
    GridFS中的视频文件。
- en: Retrieving and streaming media
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索和流式传输媒体
- en: Any visitor browsing through the MERN Mediastream application will be able to
    view the media posted on the application by its users. Implementing this feature
    will require streaming the video files stored in MongoDB GridFS to the requesting
    client and rendering the stream in a media player. In the following sections,
    we will set up a backend API to retrieve a single video file, which we will then
    use as a source in a React-based media player to render the streaming video.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 任何浏览MERN Mediastream应用程序的访客都将能够查看用户在应用程序上发布的媒体。实现此功能需要将存储在MongoDB GridFS中的视频文件流式传输到请求客户端，并在媒体播放器中渲染流。在以下章节中，我们将设置一个后端API来检索单个视频文件，然后我们将将其用作基于React的媒体播放器的源来渲染流式视频。
- en: The video API
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视频API
- en: To retrieve the video file associated with a single media post, we will implement
    a get video API that will accept a GET request at `'/api/medias/video/:mediaId'` and
    query both the Media collection and GridFS files. We will start implementing this
    video API by declaring the route shown in the following code, along with a way
    to handle the `:mediaId` parameter in the URL.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索与单个媒体帖子关联的视频文件，我们将实现一个接受GET请求的get视频API，请求地址为`'/api/medias/video/:mediaId'`，并查询媒体集合和GridFS文件。我们将通过声明以下代码中的路由以及处理URL中的`:mediaId`参数的方式来实现此视频API。
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/routes/media.routes.js`:'
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `:mediaId` parameter in the route URL will be processed in the `mediaByID`
    controller to fetch the associated document from the Media collection and file
    details from GridFS. These retrieved results are then attached to the request
    object so that it can be used in the `video` controller method as required. This `mediaByID` controller
    method is defined as follows.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 路由URL中的`:mediaId`参数将在`mediaByID`控制器中处理，以从媒体集合和GridFS文件中检索相关文档和文件详情。然后，这些检索到的结果将附加到请求对象中，以便可以在`video`控制器方法中按需使用。此`mediaByID`控制器方法定义如下。
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/controllers/media.controller.js`:'
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To retrieve the relevant file details from GridFS, we use `find` from the MongoDB
    streaming API. We query the files stored in GridFS by the filename value, which
    should match the corresponding media ID in the Media collection. Then, we receive
    the resulting matching file records in an array and attach the first result to
    the request object so that it can be used in the next method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要从GridFS检索相关文件详情，我们使用MongoDB流式API中的`find`。我们通过文件名值查询存储在GridFS中的文件，该值应与媒体集合中相应的媒体ID相匹配。然后，我们以数组形式接收匹配的文件记录，并将第一个结果附加到请求对象中，以便在下一个方法中使用。
- en: The next method that's invoked when this API receives a request is the `video`
    controller method. In this method, depending on whether the request contains range
    headers, we send back the correct chunks of video with the related content information
    set as response headers. The `video` controller method is defined with the following
    structure, with the response composed depending on the existence of range headers
    in the request.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个API接收到请求时，调用的下一个方法是`video`控制器方法。在这个方法中，根据请求是否包含范围头，我们发送回正确的视频块，并将相关内容信息设置为响应头。`video`控制器方法定义如下结构，响应的组成取决于请求中是否存在范围头。
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/controllers/media.controller.js`:'
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, if the request does not contain range headers, we stream
    back the whole video file using `gridfs.openDownloadStream`, which gives us a
    readable stream of the corresponding file stored in GridFS. This is piped with
    the response sent back to the client. In the response header, we set the content
    type and total length of the file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果请求不包含范围头，我们使用`gridfs.openDownloadStream`流回整个视频文件，这为我们提供了存储在GridFS中的相应文件的可读流。这个流与发送回客户端的响应一起管道传输。在响应头中，我们设置了文件的内容类型和总长度。
- en: If the request contains range headers – for example, when the user drags to
    the middle of the video and starts playing from that point – we need to convert
    the received range headers to the start and end positions, which will correspond
    with the correct chunks stored in GridFS, as shown in the following code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求包含范围头——例如，当用户拖动到视频中间并从该点开始播放时——我们需要将接收到的范围头转换为起始和结束位置，这将与存储在GridFS中的正确块相对应，如下面的代码所示。
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/controllers/media.controller.js`:'
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We pass the start and end values that have been extracted from the header as
    a range to `gridfs.openDownloadStream`. These start and end values specify the
    0-based offset in bytes to start streaming from and stop streaming before. We
    also set the response headers with additional file details, including content
    length, range, and type. The content length will now be the total size of the
    content within the defined range. Therefore, the readable stream that's piped
    back to the response, in this case, will only contain the chunks of file data
    that fall within the start and end ranges.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将已从头部提取的起始和结束值作为范围传递给`gridfs.openDownloadStream`。这些起始和结束值指定了从0开始的字节数，以开始流式传输并在此之前停止流式传输。我们还设置了包含附加文件详情的响应头，包括内容长度、范围和类型。内容长度现在将是定义范围内的内容总大小。因此，返回给响应的可读流，在这种情况下，将只包含位于起始和结束范围内的文件数据块。
- en: The final readable stream that's piped to the response after a request is received at
    this get video API can be rendered directly in a basic HTML5 media player or a
    React-flavored media player in the frontend view. In the next section, we will
    look at how to render this video stream in a simple React media player.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收到此获取视频API请求后，最终的可读流被管道传输到响应，可以直接在前端视图的基本HTML5媒体播放器或React风格的媒体播放器中渲染。在下一节中，我们将探讨如何在简单的React媒体播放器中渲染此视频流。
- en: Using a React media player to render the video
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React媒体播放器渲染视频
- en: 'In the frontend of the application, we can render the video file being streamed
    from MongoDB GridFS in a media player. A good option for a React-flavored media
    player is the `ReactPlayer` component, available as a node module, which can be
    customized as required. Providing the video stream as a source to a default `ReactPlayer`
    component will render with basic player controls, as shown in the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的前端，我们可以在媒体播放器中渲染从MongoDB GridFS流出的视频文件。对于React风格的媒体播放器，一个好的选择是作为节点模块提供的`ReactPlayer`组件，可以根据需要自定义。将视频流作为源提供给默认的`ReactPlayer`组件将渲染带有基本播放控件，如下面的截图所示：
- en: '![](img/5426cde7-a7af-44d8-922e-a1b36c11aed7.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5426cde7-a7af-44d8-922e-a1b36c11aed7.png)'
- en: 'To start using `ReactPlayer` in our frontend code, we need to install the corresponding
    node module by running the following Yarn command from the command line:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始在前端代码中使用 `ReactPlayer`，我们需要通过在命令行中运行以下 Yarn 命令来安装相应的节点模块：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once installed, we can import it into any React component and add it to the
    view. For basic usage with the default controls provided by the browser, we can
    add it to any React view in any application that has access to the ID of the media
    to be rendered, as shown in the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以将其导入到任何 React 组件中，并将其添加到视图中。对于使用浏览器提供的默认控件的基本用法，我们可以在任何具有要渲染的媒体 ID
    访问权限的应用程序中的任何 React 视图中添加它，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will load the player with the video stream that was received from the get
    video API and provide the user with basic control options to interact with the
    stream being played. `ReactPlayer` can be customized so that more options are
    available. We will explore some of these advanced options for customizing this `ReactPlayer` with
    our own controls in the next chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载从获取视频 API 收到的视频流播放器，并为用户提供基本控制选项来与正在播放的流进行交互。`ReactPlayer` 可以进行自定义，以便提供更多选项。我们将在下一章中探讨一些用于自定义此
    `ReactPlayer` 并使用我们自己的控件的高级选项。
- en: To learn more about what is possible with `ReactPlayer`, visit [cookpete.com/react-player](https://cookpete.com/react-player).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 `ReactPlayer` 可以实现的功能，请访问 [cookpete.com/react-player](https://cookpete.com/react-player)。
- en: Now, it's possible to retrieve a single video file stored in MongoDB GridFS
    and stream it to a media player in the frontend for the user to view and play
    the video as desired. In the next section, we will discuss how to fetch and display
    lists of multiple videos from the backend to the frontend of the streaming application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以检索存储在 MongoDB GridFS 中的单个视频文件并将其流式传输到前端媒体播放器，以便用户可以按需查看和播放视频。在下一节中，我们将讨论如何从后端获取并显示多个视频列表到流媒体应用程序的前端。
- en: Listing media
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出媒体
- en: 'In MERN Mediastream, we will add list views of relevant media with a snapshot
    of each video to give visitors easier access and an overview of the videos on
    the application. For example, in the following screenshot, the `Profile` component
    displays a list of media posted by the corresponding user, showing the video preview
    and other details of each media:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MERN Mediastream 中，我们将添加相关媒体的列表视图，每个视频都有一个快照，以便访客更容易访问并对应用程序中的视频有一个概述。例如，在下面的屏幕截图中，`Profile`
    组件显示对应用户发布的媒体列表，显示每个媒体的预览和其他详细信息：
- en: '![](img/d39a7f3f-6078-41a7-8bd5-442e6404057e.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d39a7f3f-6078-41a7-8bd5-442e6404057e.png)'
- en: We will set up list APIs in the backend to retrieve different lists, such as
    videos uploaded by a single user and the most popular videos with the highest
    views in the application. Then, these retrieved lists can be rendered in a reusable `MediaList` component,
    which will receive a list of media objects as a prop from a parent component that
    fetches the specific API. In the following sections, we will implement the `MediaList`
    component and the backend APIs to retrieve the two different lists of media from
    the database.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后端设置列表 API 来检索不同的列表，例如单个用户上传的视频和应用程序中观看次数最高的最受欢迎的视频。然后，这些检索到的列表可以在可重用的 `MediaList`
    组件中渲染，该组件将从获取特定 API 的父组件接收媒体对象列表作为属性。在以下章节中，我们将实现 `MediaList` 组件和后端 API，以从数据库中检索两种不同的媒体列表。
- en: The MediaList component
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 媒体列表组件
- en: The `MediaList` component is a reusable component that will take a list of media
    and iterate through it to render each media item in the view. In MERN Mediastream,
    we use it to render a list of the most popular media in the home view and a list
    of media uploaded by a specific user in their profile.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`MediaList` 组件是一个可重用的组件，它将接受一个媒体列表并遍历它，在视图中渲染每个媒体项。在 MERN Mediastream 中，我们使用它来渲染主页视图中最受欢迎的媒体列表以及特定用户在其个人资料中上传的媒体列表。'
- en: In the view part of the `MediaList` component, we will iterate through the `media`
    array that's received in `props` using `map`, as shown in the following code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MediaList` 组件的视图部分，我们将使用 `map` 通过 `props` 中接收到的 `media` 数组，如下面的代码所示。
- en: '`mern-mediastream/client/media/MediaList.js`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/MediaList.js`:'
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This `MediaList` component uses the Material-UI `GridList` components as it
    iterates through the array of objects sent in the props and renders media details
    for each item in the list. It also includes a `ReactPlayer` component, which renders
    the video URL without showing any controls. In the view, this gives the visitor
    a brief overview of each piece of media, as well as a glimpse of the video content.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`MediaList`组件使用Material-UI的`GridList`组件，在遍历传入props的对象数组时渲染列表中每个项目的媒体详情。它还包括一个`ReactPlayer`组件，该组件渲染视频URL而不显示任何控件。在视图中，这为访客提供了每件媒体的一个简要概述，以及视频内容的预览。
- en: 'This component can be added to any view that can provide an array of media
    objects. In the MERN Mediastream application, we use it to render two different
    lists of media: a list of popular media and a list of media posted by a specific
    user. In the next section, we will look at how to retrieve a list of popular media
    from the database to render it in the frontend.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件可以添加到任何可以提供媒体对象数组的视图中。在MERN Mediastream应用程序中，我们使用它来渲染两个不同的媒体列表：一个是热门媒体列表，另一个是特定用户发布的媒体列表。在下一节中，我们将探讨如何从数据库中检索热门媒体列表并在前端渲染它。
- en: Listing popular media
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出热门媒体
- en: To retrieve specific lists of media from the database, we need to set up the
    relevant APIs on the server. For popular media, we will set up a route that receives
    a GET request at `/api/media/popular`. The route will be declared as follows.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从数据库中检索特定的媒体列表，我们需要在服务器上设置相关的API。对于热门媒体，我们将设置一个接收`/api/media/popular`的GET请求的路由。该路由的声明如下。
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/routes/media.routes.js`:'
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A GET request to this URL will invoke the `listPopular` method. The `listPopular`
    controller method will query the Media collection and retrieve nine media documents
    that have the highest `views` in the whole collection. The `listPopular` method
    is defined as follows.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对此URL的GET请求将调用`listPopular`方法。`listPopular`控制器方法将查询媒体集合并检索整个集合中观看次数最高的九个媒体文档。`listPopular`方法定义如下。
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/controllers/media.controller.js`:'
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The result that's returned by the query to the Media collection is sorted by
    the number of views in descending order and limited to nine. Each media document
    in this list will also contain the name and ID of the user who posted it since
    we are calling `populate` to add these user attributes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 查询媒体集合返回的结果按观看次数降序排列，并限制为九个。列表中的每个媒体文档也将包含发布该文档的用户名称和ID，因为我们调用`populate`来添加这些用户属性。
- en: This API can be used in the frontend with a fetch request. You can define a
    corresponding fetch method in `api-media.js` to make the request, similarly to
    other API implementations. Then, the fetch method can be called in a React component,
    such as in the `Home` component for this application. In the `Home` component,
    we will fetch a list of popular videos in a `useEffect` hook, as shown in the
    following code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API可以用一个fetch请求在前端使用。你可以在`api-media.js`中定义一个相应的fetch方法来发起请求，类似于其他API实现。然后，可以在React组件中调用这个fetch方法，例如在本应用程序的`Home`组件中。在`Home`组件中，我们将使用`useEffect`钩子获取热门视频列表，如下面的代码所示。
- en: '`mern-mediastream/client/core/Home.js`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/core/Home.js`:'
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The list that's fetched from the API in this hook is set in the state so that
    it can be passed to a `MediaList` component in the view. In the Home view, we
    can add the `MediaList` as follows, with the list provided as a prop.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在此钩子中从API获取的列表被设置在状态中，以便可以将其传递给视图中的`MediaList`组件。在主页视图中，我们可以添加`MediaList`，如下所示，将列表作为prop提供。
- en: '`mern-mediastream/client/core/Home.js`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/core/Home.js`:'
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will render a list of up to nine of the most popular videos from the database
    on the home page of the MERN Mediastream application. In the next section, we
    will discuss a similar implementation to retrieve and render a list of media that's
    been posted by a specific user.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在MERN Mediastream应用程序的主页上渲染数据库中最受欢迎的前九个视频列表。在下一节中，我们将讨论一个类似的实现来检索和渲染特定用户发布的媒体列表。
- en: Listing media by users
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按用户列出媒体
- en: To be able to retrieve a list of media that's been uploaded by a specific user
    from the database, we will set up an API with a route that accepts a `GET` request
    at `'/api/media/by/:userId'`. The route will be declared as follows.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够从数据库中检索特定用户上传的媒体列表，我们将设置一个API，该API通过`/api/media/by/:userId`接受一个`GET`请求。该路由的声明如下。
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/routes/media.routes.js`:'
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A GET request to this route will invoke the `listByUser` method. The `listByUser`
    controller method will query the Media collection to find media documents that
    have `postedBy` values matching with the `userId` attached as a parameter in the
    URL. The `listByUser` controller method is defined as follows.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对此路由的GET请求将调用`listByUser`方法。`listByUser`控制器方法将查询Media集合以找到具有与URL中附加的`userId`匹配的`postedBy`值的媒体文档。`listByUser`控制器方法定义如下。
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/controllers/media.controller.js`:'
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The result that's returned from the query to the Media collection is sorted
    by the date it was created on, with the latest post showing up first. Each media
    document in this list will also contain the name and ID of the user who posted
    it since we are calling `populate` to add these user attributes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从Media集合查询返回的结果按创建日期排序，最新帖子首先显示。此列表中的每个媒体文档也将包含发布该文档的用户名称和ID，因为我们调用`populate`来添加这些用户属性。
- en: This API can be used in the frontend with a fetch request. You can define a
    corresponding `fetch` method in `api-media.js` to make the request, similar to
    other API implementations. Then, the fetch method can be called in a React component.
    In our application, we use the `fetch` method in the `Profile` component, similar
    to the `listPopular` fetch method we used in the home view, to retrieve the list
    data, set it to the state, and then pass it to a `MediaList` component. This will
    render a profile page with a list of media that was posted by the corresponding
    user.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此API可以通过前端使用fetch请求来使用。你可以在`api-media.js`中定义相应的`fetch`方法来发起请求，类似于其他API实现。然后，可以在React组件中调用`fetch`方法。在我们的应用程序中，我们使用`Profile`组件中的`fetch`方法，类似于我们在主页视图中使用的`listPopular`
    fetch方法，来检索列表数据，将其设置到状态中，然后传递给`MediaList`组件。这将渲染一个包含相应用户发布的媒体列表的个人信息页面。
- en: We are able to retrieve and display multiple videos on the application by utilizing
    APIs that have been implemented in the backend to fetch the list data. We can
    also utilize a ReactPlayer component without controls to give the user a glimpse
    of each video when we render the list in the frontend views. In the next section,
    we will discuss the full-stack slices that will display media posts and allow
    authorized users to update and delete individual media posts in the application.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过利用后端已实现的API来获取列表数据，在应用程序中检索和显示多个视频。我们还可以在前端视图中渲染列表时，使用无控制条的ReactPlayer组件，让用户对每个视频有一个大致的了解。在下一节中，我们将讨论将显示媒体帖子并允许授权用户在应用程序中更新和删除单个媒体帖子的全栈切片。
- en: Displaying, updating, and deleting media
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示、更新和删除媒体
- en: Any visitor to MERN Mediastream will be able to view media details and stream
    videos, while only registered users will be able to edit the media's details and
    delete it any time after they post it on the application. In the following sections,
    we will implement full-stack slices, including backend APIs and frontend views,
    to display a single media post, update details of a media post, and delete a media
    post from the application.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 每位访问MERN Mediastream的访客都将能够查看媒体详细信息并流式传输视频，而只有注册用户才能编辑媒体详情并在发布后随时删除它。在以下章节中，我们将实现包括后端API和前端视图在内的全栈切片，以显示单个媒体帖子、更新媒体帖子的详情以及从应用程序中删除媒体帖子。
- en: Displaying media
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示媒体
- en: Any visitor to MERN Mediastream will be able to browse to a single media view
    to play a video and read the details associated with it. Every time a specific
    video is loaded on the application, we will also increment the number of views
    associated with the media. In the following sections, we will implement the individual
    media view by adding a read media API to the backend, a way to call this API from
    the frontend, and the React component that will display the media details in the
    view.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每位访问MERN Mediastream的访客都将能够浏览到单个媒体视图来播放视频并读取与之相关的详细信息。每次在应用程序中加载特定视频时，我们也将增加与媒体相关的观看次数。在以下章节中，我们将通过向后端添加读取媒体API、从前端调用此API以及将在视图中显示媒体详细信息的相关React组件来实现单个媒体视图。
- en: The read media API
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取媒体API
- en: To implement the read media API in the backend, we will start by adding a `GET` route
    that queries the `Media` collection with an ID and returns the media document
    in the response. The route is declared as follows.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在后端实现读取媒体API，我们首先通过添加一个`GET`路由来查询带有ID的`Media`集合，并在响应中返回媒体文档。该路由声明如下。
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/routes/media.routes.js`:'
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `mediaId` in the request URL will cause the `mediaByID` controller method
    to execute and attach the retrieved media document to the request object so that
    it can be accessed in the next method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请求 URL 中的 `mediaId` 将导致 `mediaByID` 控制器方法执行，并将检索到的媒体文档附加到请求对象中，以便在下一个方法中访问。
- en: A `GET` request to this API will execute the `incrementViews` controller method
    next, which will find the matching media record and increment the `views` value
    by `1`, before saving the updated record to the database. The `incrementViews`
    method is defined as follows.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 向此 API 发送 `GET` 请求将执行 `incrementViews` 控制器方法，该方法将找到匹配的媒体记录，并将 `views` 值增加 `1`，然后将更新后的记录保存到数据库中。`incrementViews`
    方法定义如下。
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/controllers/media.controller.js`:'
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This method will increment the number of views for a given media by 1 every
    time this read media API is called. After the media is updated from this `incrementViews`
    method, the `read` controller method is invoked. The `read` controller method
    will simply return the retrieved media document in response to the requesting
    client, as shown in the following code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用此读取媒体 API 时，此方法将增加给定媒体的观看次数 1。从 `incrementViews` 方法更新媒体后，将调用 `read` 控制器方法。`read`
    控制器方法将简单地返回检索到的媒体文档作为对请求客户端的响应，如下所示。
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/controllers/media.controller.js`:'
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To retrieve the media document that was sent in the response, we need to call
    this read media API in the frontend using a fetch method. We will set up a corresponding
    fetch method in `api-media.js`, as shown in the following code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索响应中发送的媒体文档，我们需要在前端使用 fetch 方法调用此读取媒体 API。我们将在 `api-media.js` 中设置相应的 fetch
    方法，如下所示。
- en: '`mern-mediastream/client/media/api-media.js`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/api-media.js`:'
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This method takes the ID of the media to be retrieved and makes a `GET` request
    to the read API route using a `fetch`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法获取要检索的媒体 ID，并使用 `fetch` 向读取 API 路由发送 `GET` 请求。
- en: The read media API can be used to render individual media details in a view
    or to pre-populate a media edit form. In the next section, we will use this fetch
    method to call the read media API in the React component to render the media details,
    as well as a `ReactPlayer` that will play the associated video.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 读取媒体 API 可以用于在视图中渲染单个媒体详细信息，或预先填充媒体编辑表单。在下一节中，我们将使用此 fetch 方法在 React 组件中调用读取媒体
    API 以渲染媒体详细信息，以及将播放相关视频的 `ReactPlayer`。
- en: The Media component
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 媒体组件
- en: 'The `Media` component will render details of an individual media record and
    stream the video in a basic `ReactPlayer` with default browser controls. The completed
    single Media view will look as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`Media` 组件将渲染单个媒体记录的详细信息，并使用基本 `ReactPlayer` 和默认浏览器控件进行视频流。完成的单个媒体视图将如下所示：'
- en: '![](img/c171333d-9949-44de-8e54-08edce73050f.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c171333d-9949-44de-8e54-08edce73050f.png)'
- en: The `Media` component can call the read API to fetch the media data itself or
    receive the data as props from a parent component that makes the call to the read
    API. In the latter case, the parent component will fetch the media from the server
    in a `useEffect` hook, set it to state, and add it to the `Media` component, as
    follows.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`Media` 组件可以调用读取 API 来获取媒体数据本身，或者从调用读取 API 的父组件接收数据作为 props。在后一种情况下，父组件将在 `useEffect`
    钩子中从服务器获取媒体，将其设置为状态，并将其添加到 `Media` 组件中，如下所示。'
- en: '`mern-mediastream/client/media/PlayMedia.js`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/PlayMedia.js`:'
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In MERN Mediastream, we will add the `Media` component in a `PlayMedia` component
    that fetches the media content from the server in a `useEffect` hook using the
    read API and passes it to `Media` as a prop. The composition of the `PlayMedia`
    component will be discussed in more detail in the next chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MERN Mediastream 中，我们将在 `PlayMedia` 组件中添加 `Media` 组件，该组件使用读取 API 在 `useEffect`
    钩子中从服务器获取媒体内容，并将其作为 props 传递给 `Media`。`PlayMedia` 组件的组成将在下一章中更详细地讨论。
- en: The `Media` component will take this data in the props and render it in the
    view to display the details and load the video in a `ReactPlayer` component. The
    title, genre, and view count details of the media can be rendered in a Material-UI
    `CardHeader` component in the `Media` component, as shown in the following code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`Media` 组件将接受 props 中的数据，并在视图中渲染以显示详细信息，并在 `ReactPlayer` 组件中加载视频。媒体标题、类型和观看次数的详细信息可以在
    `Media` 组件中的 Material-UI `CardHeader` 组件中渲染，如下所示。'
- en: '`mern-mediastream/client/media/Media.js`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/Media.js`:'
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Besides rendering these media details, we will also load the video in the `Media`
    component. The video URL, which is basically the get video API route we set up
    in the backend, is loaded in a `ReactPlayer` with default browser controls, as
    shown in the following code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 除了渲染这些媒体详情外，我们还将加载`Media`组件中的视频。视频URL基本上是我们后端设置的获取视频API路由，在`ReactPlayer`中以默认浏览器控件加载，如下面的代码所示。
- en: '`mern-mediastream/client/media/Media.js`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/Media.js`:'
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will render a simple player that allows the user to play the video stream.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这将渲染一个简单的播放器，允许用户播放视频流。
- en: The `Media` component also renders additional details about the user who posted
    the video, a description of the video, and the date it was created, as shown in
    the following code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Media` 组件还会渲染发布视频的用户的其他详细信息，视频描述以及创建日期，如下面的代码所示。'
- en: '`mern-mediastream/client/media/Media.js`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/Media.js`:'
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the details being displayed in the Material-UI `ListItem` component, we will also
    conditionally show edit and delete options if the currently signed-in user is
    the one who posted the media being displayed. To render these elements conditionally
    in the view, we will add the following code after the `ListItemText` displaying
    the date.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在Material-UI `ListItem` 组件中显示的详情中，我们还将根据当前登录用户是否是显示的媒体发布者有条件地显示编辑和删除选项。为了在视图中有条件地渲染这些元素，我们将在显示日期的`ListItemText`之后添加以下代码。
- en: '`mern-mediastream/client/media/Media.js`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/Media.js`:'
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will ensure that the edit and delete options only render when the current
    user is signed in and is the uploader of the media being displayed. The edit option
    links to the media edit form, while the delete option opens a dialog box that
    can initiate the deletion of this particular media document from the database.
    In the next section, we will implement the functionality of this option to edit
    details of the uploaded media post.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保只有在当前用户已登录并且是显示的媒体的上传者时，才会渲染编辑和删除选项。编辑选项链接到媒体编辑表单，而删除选项打开一个对话框，可以启动从数据库中删除此特定媒体文档的操作。在下一节中，我们将实现此选项的功能，以编辑已上传媒体帖子的详情。
- en: Updating media details
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新媒体详情
- en: Registered users will have access to an edit form for each of their media uploads.
    Updating and submitting this form will save the changes to the given document
    in the Media collection. To implement this capability, we will have to create
    a backend API that allows the update operation on a given media after ensuring
    that the requesting user is authenticated and authorized. Then, this updated API
    needs to be called from the frontend with the changed details of the media. In
    the following sections, we will build this backend API and the React component
    to allow users to make changes to the media they already posted on the application.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注册用户将能够访问他们每个媒体上传的编辑表单。更新并提交此表单将保存对媒体集合中给定文档的更改。为了实现这一功能，我们需要创建一个后端API，允许在确认请求用户已认证并授权后对给定媒体进行更新操作。然后，需要从前端调用此更新API，并带上媒体更改的详细信息。在接下来的章节中，我们将构建这个后端API和React组件，以便用户能够修改他们在应用程序上已发布的媒体。
- en: The media update API
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 媒体更新API
- en: In the backend, we will need an API that allows us to update existing media
    in the database if the user making the request is the authorized creator of the
    given media post. First, we will declare the PUT route, which accepts the update
    request from the client.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在后端，我们需要一个API，允许我们在用户是请求的媒体帖子的授权创建者的情况下更新数据库中的现有媒体。首先，我们将声明PUT路由，该路由接受来自客户端的更新请求。
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/routes/media.routes.js`:'
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When a PUT request is received at `'api/media/:mediaId'`, the server will ensure
    the signed-in user is the original poster of the media content by calling the
    `isPoster` controller method. The `isPoster` controller method is defined as follows.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到 `'api/media/:mediaId'` 的PUT请求时，服务器将确保已登录用户是媒体内容的原始发布者，通过调用`isPoster`控制器方法。`isPoster`控制器方法定义如下。
- en: '`mern-mediastream/server/controllers/media.controller.js:`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/controllers/media.controller.js`:'
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This method ensures the ID of the authenticated user is the same as the user
    ID referenced in the `postedBy` field of the given media document. If the user
    is authorized, the `update` controller method will be called `next` in order to
    update the existing media document with the changes. The `update` controller method
    is defined as follows.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法确保认证用户的ID与给定媒体文档中`postedBy`字段引用的用户ID相同。如果用户被授权，则将调用`update`控制器方法`next`以使用更改更新现有的媒体文档。`update`控制器方法定义如下。
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/controllers/media.controller.js`:'
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This method extends the existing media document with the changed details that
    were received in the request body and saves the updated media to the database.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法通过在请求体中接收到的更改详情扩展现有的媒体文档，并将更新的媒体保存到数据库中。
- en: To access the update API in the frontend, we will add a corresponding fetch
    method in `api-media.js` that takes the necessary user auth credentials and media
    details as parameters before making the fetch call to this update media API, as
    shown in the following code.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在前端访问更新API，我们将在`api-media.js`中添加一个相应的fetch方法，该方法在向此更新媒体API发出fetch调用之前，将必要的用户认证凭证和媒体详细信息作为参数传递，如下所示。
- en: '`mern-mediastream/client/user/api-media.js`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/user/api-media.js`:'
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This fetch method will be used in the media edit form when the user makes updates
    and submits the form. In the next section, we will discuss the implementation
    of this media edit form.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户进行更新并提交表单时，将使用此fetch方法在媒体编辑表单中。在下一节中，我们将讨论此媒体编辑表单的实现。
- en: The media edit form
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 媒体编辑表单
- en: 'The media edit form, which will allow an authorized user to make changes to
    the details of a media post, will be similar to the new media form. However, it
    will not have an upload option, and the fields will be pre-populated with the
    existing values, as shown in the following screenshot:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 允许授权用户更改媒体帖子详细信息的媒体编辑表单将与新媒体表单类似。然而，它将没有上传选项，字段将预先填充现有值，如下面的截图所示：
- en: '![](img/180e69b1-8f55-46f0-b290-6304b551a616.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/180e69b1-8f55-46f0-b290-6304b551a616.png)'
- en: The `EditMedia` component containing this form will fetch the existing values
    of the media by calling the read media API in a `useEffect` hook, as shown in
    the following code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 包含此表单的`EditMedia`组件将通过在`useEffect`钩子中调用读取媒体API来获取媒体的现有值，如下面的代码所示。
- en: '`mern-mediastream/client/media/EditMedia.js`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/media/EditMedia.js`:'
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The retrieved media details are set to state so that the values can be rendered
    in the text fields. The form field elements will be the same as in the `NewMedia`
    component. When a user updates any of the values in the form, the changes will
    be registered in the `media` object in state with a call to the `handleChange`
    method. The `handleChange` method is defined as follows.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 获取的媒体详细信息被设置为状态，以便可以在文本字段中渲染值。表单字段元素将与`NewMedia`组件中的相同。当用户更新表单中的任何值时，通过调用`handleChange`方法，这些更改将在状态中的`media`对象中注册。`handleChange`方法定义如下。
- en: '`mediastream/client/media/EditMedia.js`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`mediastream/client/media/EditMedia.js`:'
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this method, the specific field that's being updated in the form is reflected
    in the corresponding attribute in the media object in state. When the user is
    done editing and clicks submit, a call will be made to the update API with the
    required credentials and the changed media values. This is done by invoking the
    `clickSubmit` method, which is defined as follows.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，表单中正在更新的特定字段会在状态中的媒体对象对应的属性中反映出来。当用户完成编辑并点击提交时，将调用带有所需凭证和更改后的媒体值的更新API。这是通过调用以下定义的`clickSubmit`方法来完成的。
- en: '`mediastream/client/media/EditMedia.js`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`mediastream/client/media/EditMedia.js`:'
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The call to the update media API will update the media details in the corresponding
    media document in the Media collection, while the video file associated with the
    media remains as it is in the database.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 调用更新媒体API将更新媒体集合中相应媒体文档的媒体详细信息，而与媒体关联的视频文件在数据库中保持不变。
- en: This `EditMedia` component can only be accessed by signed-in users and will
    be rendered at `'/media/edit/:mediaId'`. Due to this, we will add a `PrivateRoute` in
    the `MainRouter` component, like so.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`EditMedia`组件只能由已登录的用户访问，并将渲染在`'/media/edit/:mediaId'`。因此，我们将在`MainRouter`组件中添加一个`PrivateRoute`，如下所示。
- en: '`mern-mediastream/client/MainRouter.js`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/client/MainRouter.js`:'
- en: '[PRE46]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This link is added with an edit icon in the `Media` component, allowing the
    user who posted the media to access the edit page. In the `Media` view, the user
    can also choose to delete their media post. We will implement this in the next
    section.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此链接在`Media`组件中添加了一个编辑图标，允许发布媒体的用户访问编辑页面。在`Media`视图中，用户还可以选择删除他们的媒体帖子。我们将在下一节中实现此功能。
- en: Deleting media
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除媒体
- en: An authorized user can completely delete the media they uploaded to the application,
    including the media document in the Media collection and the file chunks stored
    in MongoDB using GridFS. To allow a user to remove the media from the application,
    in the following sections, we will define a backend API for media deletion from
    the database and implement a React component that makes use of this API when the
    user interacts with the frontend to perform this deletion.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 授权用户可以完全删除他们上传到应用程序的媒体，包括媒体集合中的媒体文档和在MongoDB中使用的GridFS存储的文件块。为了允许用户从应用程序中删除媒体，在以下章节中，我们将定义一个从数据库中删除媒体的后端API，并实现一个React组件，当用户与前端交互以执行此删除操作时，该组件将使用此API。
- en: The delete media API
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除媒体API
- en: To delete media from the database, we will implement a delete media API in the
    backend, which will accept a DELETE request from a client at `/api/media/:mediaId`. We
    will add the `DELETE` route for this API as follows, which will allow an authorized
    user to delete their uploaded media records.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要从数据库中删除媒体，我们将在后端实现一个删除媒体API，该API将接受客户端在`/api/media/:mediaId`上的DELETE请求。我们将为此API添加以下`DELETE`路由，这将允许授权用户删除他们上传的媒体记录。
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/routes/media.routes.js`:'
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: When the server receives a DELETE request at `'/api/media/:mediaId'`, it will
    make sure the signed-in user is the original poster of the media by invoking the
    `isPoster` controller method. Then, the `remove` controller method will completely delete
    the specified media from the database. The `remove` method is defined as follows.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器在`'/api/media/:mediaId'`接收到DELETE请求时，它将通过调用`isPoster`控制器方法来确保已登录用户是媒体的原帖发布者。然后，`remove`控制器方法将完全从数据库中删除指定的媒体。`remove`方法定义如下。
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`mern-mediastream/server/controllers/media.controller.js`:'
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Besides deleting the media record from the Media collection, we are also using `gridfs`
    to remove the associated file details and chunks stored in the database.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从媒体集合中删除媒体记录外，我们还使用`gridfs`来删除存储在数据库中的相关文件详情和块。
- en: To access this backend API in the frontend, you will also need a fetch method
    with this route, similar to other API implementations. The fetch method will need
    to take the media ID and the current user's auth credentials in order to call
    the delete media API with these values.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要在前端访问此后端API，您还需要一个具有此路由的fetch方法，类似于其他API实现。fetch方法需要获取媒体ID和当前用户的认证凭证，以便使用这些值调用删除媒体API。
- en: The fetch method will be used when the user performs the delete operation by
    clicking a button in the frontend interface. In the next section, we will discuss
    a React component called `DeleteMedia`, where by this delete media action will
    be performed by the user.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户通过在前端界面中点击按钮执行删除操作时，将使用fetch方法。在下一节中，我们将讨论一个名为`DeleteMedia`的React组件，其中用户将通过此删除媒体操作执行。
- en: The DeleteMedia component
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DeleteMedia组件
- en: 'The `DeleteMedia` component is added to the `Media` component and is only visible
    to the signed-in user who added this specific media. This component is basically
    a button that, when clicked, opens a `Dialog` component asking the user to confirm
    the delete action, as shown in the following screenshot:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeleteMedia`组件被添加到`Media`组件中，并且只对添加了此特定媒体的已登录用户可见。此组件基本上是一个按钮，当点击时，会打开一个`Dialog`组件，提示用户确认删除操作，如以下截图所示：'
- en: '![](img/71d31ba9-fc95-4b16-a1aa-116fdc04ac03.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/71d31ba9-fc95-4b16-a1aa-116fdc04ac03.png)'
- en: This `DeleteMedia` component takes the media ID and title as props when it is
    added in the `Media` component. Its implementation will be similar to the `DeleteUser` component
    we discussed in [Chapter 4](6f2ca10a-8079-4e3a-9d42-a3db8e85b9d9.xhtml), *Adding
    a React Frontend to Complete MERN*. Once the `DeleteMedia` component has been
    added, the user will be able to remove the posted media completely from the application
    by confirming their action.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当`DeleteMedia`组件在`Media`组件中添加时，它接受媒体ID和标题作为props。其实现方式将与我们在[第4章](6f2ca10a-8079-4e3a-9d42-a3db8e85b9d9.xhtml)中讨论的`DeleteUser`组件类似，即*添加React前端以完成MERN*。一旦添加了`DeleteMedia`组件，用户通过确认他们的操作，就能完全从应用程序中移除发布的媒体。
- en: The MERN Mediastream application that we've developed in this chapter is a complete
    media streaming application with the capability to upload video files to the database,
    stream stored videos back to the viewers, support CRUD operations such as media
    create, update, read, and delete, and support options for listing media by uploader
    or popularity.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们开发的MERN Mediastream应用程序是一个完整的媒体流应用程序，具有将视频文件上传到数据库、流回存储的视频给观众、支持如媒体创建、更新、读取和删除等CRUD操作，以及支持按上传者或流行度列出媒体的功能。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we developed a media streaming application by extending the
    MERN skeleton application and leveraging MongoDB GridFS.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过扩展MERN框架应用程序并利用MongoDB GridFS开发了媒体流应用程序。
- en: Besides adding basic add, update, delete, and listing features for media uploads,
    we looked into how MERN-based applications can allow users to upload video files,
    store these files into MongoDB GridFS as chunks, and stream the video back to
    the viewer partially or fully as required. We also covered using `ReactPlayer`
    with default browser controls to stream the video file. You can apply these streaming
    capabilities to any full-stack application that may require storing and retrieving
    large files from the database.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为媒体上传添加基本的添加、更新、删除和列表功能外，我们还探讨了基于MERN的应用程序如何允许用户上传视频文件，将这些文件作为块存储到MongoDB
    GridFS中，并根据需要部分或全部流回给观众。我们还介绍了如何使用带有默认浏览器控制的`ReactPlayer`来流式传输视频文件。您可以将这些流式传输功能应用于可能需要从数据库中存储和检索大型文件的任何全栈应用程序。
- en: In the next chapter, we will learn how to customize `ReactPlayer` with our own
    controls and functionality so that users have more options, such as playing the
    next video in a list. In addition, we will discuss how to improve the SEO of the
    media details by implementing server-side rendering with data for the media view.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何自定义`ReactPlayer`以包含我们自己的控件和功能，以便用户有更多的选择，例如播放列表中的下一个视频。此外，我们还将讨论如何通过实现带有媒体视图数据的服务器端渲染来提高媒体详情的SEO。
