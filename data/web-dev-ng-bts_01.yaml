- en: Quick Start
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速开始
- en: Are you ready to work your way to Angular mastery? My guess is that you are,
    and with this book and your determination, you will. You purchased this book,
    and I not only thank you, but I want to make a promise to you right here, right
    now. Two promises, in fact. The first one is that if you diligently read the material,
    apply the knowledge you'll gain along the way, and build the example application
    with me throughout these pages, you will be well on your way to Angular mastery.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好迈向Angular的精通了吗？我猜你是的，有了这本书和你的决心，你一定会成功的。你购买了这本书，我不仅要感谢你，还要在这里向你做出承诺。事实上，是两个承诺。第一个是，如果你认真阅读材料，应用你在学习过程中获得的知识，并且在这些页面中和我一起构建示例应用程序，你就会在迈向Angular的精通之路上取得很大进展。
- en: If you're anything like me, you have a library packed with literally hundreds
    of technical books and you have read most of them. Some books start off at an
    excruciatingly slow pace, entrenched in theory and historical minutia, while other
    books start off so quickly, they leave the readers scratching their heads wondering
    if they are too dumb to understand the material. The truth is, striking a balance
    while introducing readers to potentially brand new material—and not have them
    nod off as they read their newly acquired 400+ page technical book—is a tricky
    thing to pull off. So, my esteemed budding Angular guru, that is what my second
    promise is to you. I promise to do my utmost in finding that all-elusive happy
    medium between being technically heavy-handed, and being real-world practical
    while making this book as entertaining a read as I possibly can for you.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你和我一样，你的书架上堆满了成百上千本技术书籍，而你已经读过大部分。有些书开始的速度极其缓慢，深陷于理论和历史细枝末节，而其他书则开始得太快，让读者不知所措，想知道自己是不是太笨，无法理解材料。事实上，介绍读者可能全新的材料，而不让他们在阅读新获得的400多页技术书时打瞌睡，是一件棘手的事情。所以，我尊敬的初学者Angular大师，这就是我对你的第二个承诺。我承诺尽我所能找到技术和实际之间的平衡，让这本书在向你介绍新材料的同时，尽可能地有趣。
- en: With the promises well stated, let's start our journey to Angular mastery together
    by taking a quick look at what we're going to cover in this brisk, but all important
    first chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺已经说得很清楚了，让我们一起开始Angular精通之旅，快速浏览一下我们将在这个简洁但非常重要的第一章中涵盖的内容。
- en: We'll set up your development environment in a jiffy, and we'll build our first
    Angular application in order to get some immediate feeling of accomplishment.
    We're going to skim over the details as we write it, but right after that, we'll
    cover a few critical Angular basics in more detail before concluding this chapter.
    These first few basics are the very first things you should get comfortable with
    because we'll use them over and over again throughout the book as we learn about
    the more advanced stuff.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将迅速设置你的开发环境，并构建我们的第一个Angular应用程序，以便立即获得一些成就感。在编写它时，我们会略过细节，但在那之后，我们将更详细地介绍一些关键的Angular基础知识，然后结束本章。这些最基本的知识是你应该熟悉的第一件事情，因为在学习更高级的内容时，我们会一遍又一遍地使用它们。
- en: After we cover these basics, we'll switch gears from Angular speak and we'll
    take a look at the fully fledged application that we'll be building together throughout
    the remainder of the book. As a bonus (and there are a few bonuses in this book
    that I hope will bring you a bunch of value), we're also going to touch on design
    principles, wireframing, and a little used design strategy called paper prototyping—whose
    focus is on usability testing. Paper prototyping has been around since approximately
    1985 and has largely been replaced by Lean UX design since approximately 2008\.
    Still, I'm always amazed at how many of my clients have never even heard of paper
    prototyping—but I'm also happy when they discover the value it brings to them
    when they try it out.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们涵盖了这些基础知识之后，我们将从Angular语言转换，并且我们将看一下我们将在本书的其余部分一起构建的完整应用程序。作为一个奖励（在本书中有一些奖励，我希望能给您带来很多价值），我们还将涉及设计原则、线框图和一种很少使用的设计策略，称为纸质原型设计——其重点是可用性测试。纸质原型设计大约自1985年左右开始流行，并且在大约2008年左右被精益UX设计所取代。然而，我总是惊讶于我的许多客户甚至从未听说过纸质原型设计，但当他们尝试时，他们发现它给他们带来的价值，我也感到很高兴。
- en: 'We''ll cover paper prototyping at a high level at the end of this chapter,
    immediately following the wireframes section, which is the most logical place
    for discussing paper prototyping. We''ll touch on a few UX design principles as
    well, but not on the Lean UX process itself since that would take us too far off
    course from our focus of this book. However, if you have an interest in the Lean
    UX design process, here is a good starting point: [https://www.interaction-design.org/literature/article/a-simple-introduction-to-lean-ux](https://www.interaction-design.org/literature/article/a-simple-introduction-to-lean-ux).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章末尾对纸质原型设计进行高层次的介绍，紧接着线框图部分，这是讨论纸质原型设计的最合逻辑的地方。我们还将涉及一些UX设计原则，但不涉及精益UX设计过程本身，因为那会让我们偏离本书的重点。然而，如果您对精益UX设计过程感兴趣，这是一个很好的起点：[https://www.interaction-design.org/literature/article/a-simple-introduction-to-lean-ux](https://www.interaction-design.org/literature/article/a-simple-introduction-to-lean-ux)。
- en: OK, my esteemed budding Angular guru, are you primed and ready to get started?
    Good! Let's go!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我尊敬的初学者Angular大师，你准备好开始了吗？太好了！让我们开始吧！
- en: 'The topics we will be covering in the chapter are:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主题有：
- en: Angular's evolution
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular的发展
- en: Angular's building blocks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular的构建模块
- en: Setting up your development environment
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置您的开发环境
- en: Writing your first Angular application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写您的第一个Angular应用程序
- en: Angular basics
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular基础知识
- en: Our sample project
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的示例项目
- en: The process of paper prototyping
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纸质原型设计的过程
- en: Angular's evolution
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular的发展
- en: Angular is a frontend JavaScript-based web application framework that provides
    you with everything you need, including the kitchen sink, with which to build
    amazingly powerful **Single Page Applications** (**SPAs**). The application we'll
    be building together is an SPA, and we'll be discussing SPA strategies along the
    way.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是一个基于前端JavaScript的Web应用程序框架，为您提供了构建强大的单页应用程序（SPA）所需的一切，包括厨房水槽。我们将一起构建的应用程序是一个SPA，并且我们将在此过程中讨论SPA策略。
- en: While Angular wasn't the first JavaScript-based frontend web application framework,
    it was quite possibly the most powerful one of them. This is likely due to Angular's
    SPA-centric focus—since there's more to building an SPA application than there
    is to simply provide two-way data binding on your web pages.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Angular不是第一个基于JavaScript的前端Web应用程序框架，但它很可能是其中最强大的一个。这可能是因为Angular专注于SPA，因为构建SPA应用程序比在您的网页上提供双向数据绑定要复杂得多。
- en: The initial release of Angular was in late fall of 2010\. Since then, dozens
    of competing libraries and frameworks have come on the scene, including some that
    also have large adoptions and large production implementations, such as Ember.js,
    Backbone.js, and React.js. Angular, despite having perhaps the highest learning
    curve (and we'll see why this is the case), remains the most powerful one of them
    all.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Angular最初发布于2010年晚秋。自那时以来，已经出现了数十个竞争库和框架，包括一些也具有大规模采用和大规模生产实施的库，如Ember.js、Backbone.js和React.js。尽管Angular可能具有最高的学习曲线（我们将看到为什么会这样），但它仍然是其中最强大的一个。
- en: 'The Angular naming and versioning jungle can, at first glance, seem confusing.
    There are a few reasons for this, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，Angular的命名和版本控制可能会令人困惑。这有几个原因，如下：
- en: '**Angular''s 1.x releases**: Basically, any release prior to Angular 2 is commonly
    referred to as AngularJS.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular的1.x版本**：基本上，任何在Angular 2之前发布的版本通常被称为AngularJS。'
- en: AngularJS is no more actively in development mode. It has been put under long
    term support mode.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AngularJS不再处于积极开发模式。它已被置于长期支持模式下。
- en: 'Angular framework is being actively developed, and so developers need to be
    specific about which of the two Angular frameworks they are referring to when
    discussing them. Fortunately, there are two completely dedicated websites for
    them: [https://angularjs.org/](https://angularjs.org/) and [https://angular.io](https://angular.io),
    respectively. The Angular team adopted semantic versioning, starting with the
    2.0.0 release. You can read more about semantic versioning here: [https://semver.org](https://semver.org).'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular框架正在积极开发，因此开发人员在讨论它们时需要明确指出他们所指的是两个Angular框架中的哪一个。幸运的是，它们分别有两个完全专门的网站：[https://angularjs.org/](https://angularjs.org/)和[https://angular.io](https://angular.io)。Angular团队采用了语义化版本控制，从2.0.0版本开始。您可以在这里阅读更多关于语义化版本控制的信息：[https://semver.org](https://semver.org)。
- en: Angular 2 was a complete rewrite of Angular 1.x (that is, AngularJS), and is
    thus not backward compatible with AngularJS. While Angular 4 was not a complete
    rewrite of Angular 2, it did have some changes in its core libraries that required
    the team to increment its major number from 2 to 4\. Version 3 was skipped as
    a release number altogether.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 2是对Angular 1.x（即AngularJS）的完全重写，因此与AngularJS不兼容。虽然Angular 4并不是对Angular
    2的完全重写，但它的核心库有一些变化，需要团队将其主要版本号从2增加到4。版本3被完全跳过。
- en: All releases from Angular 2 onward are commonly referred to as Angular 2+, or
    simply just as Angular.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Angular 2开始的所有发布通常被称为Angular 2+，或者简单地称为Angular。
- en: Due to having adopted semantic versioning, the Angular team never released Angular
    3 and so went straight from Angular 2 to Angular 4\. Specifically, there was a
    misalignment of the router package's version, which was already distributed as
    version 3.3.0\. We'll cover routing in Angular in great detail in [Chapter 4](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml),
    *Routing*. Don't let this confuse you. Just know that there wasn't ever an Angular
    3\. No big deal. In the Windows OS world, there was never a Windows 9 either.
    These things happen.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于采用了语义化版本控制，Angular团队从未发布过Angular 3，因此直接从Angular 2到Angular 4。具体来说，路由器包的版本存在不一致，已经分发为版本3.3.0。我们将在[第4章](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml)中详细介绍Angular中的路由。不要让这使您感到困惑。只需知道从未有过Angular
    3。没什么大不了的。在Windows操作系统世界中，也从未有过Windows 9。这些事情都会发生。
- en: 'After reading the preceding list, you can see why there tends to be some confusion
    around Angular. However, it''s pretty straightforward if you keep these two things
    in mind:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完上述列表后，您可以看到为什么在Angular周围往往会有一些混淆。然而，只要记住以下两点，就会变得非常简单：
- en: You should really only be using Angular, and not AngularJS (unless you have
    an exceptionally good reason for it)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您真的应该只使用Angular，而不是AngularJS（除非您有一个非常好的理由）。
- en: With the exception of there not being an Angular 3, there will be two major
    releases per year; they should be contiguous in numbering scheme (that is, 8,
    9, and so on), and they are expected to be backward compatible—at least within
    the same major version number (as per the spirit of semantic versioning)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了没有Angular 3之外，每年将有两个主要版本发布；它们应该在编号方案上是连续的（即8、9等），并且预计它们将向后兼容——至少在相同的主要版本号内（根据语义版本控制的精神）。
- en: 'You can check out the official Angular release schedule here: [https://github.com/angular/angular/blob/master/docs/RELEASE_SCHEDULE.md](https://github.com/angular/angular/blob/master/docs/RELEASE_SCHEDULE.md). Since
    Angular is a complete rewrite of the AngularJS platform, and this is worlds apart
    from AngularJS, we''ll skip AngularJS altogether and start by taking a look at
    Components which are Angular''s building blocks. Are you with me? Great, let''s
    speedily move ahead.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里查看官方的Angular发布时间表：[https://github.com/angular/angular/blob/master/docs/RELEASE_SCHEDULE.md](https://github.com/angular/angular/blob/master/docs/RELEASE_SCHEDULE.md)。由于Angular是对AngularJS平台的完全重写，与AngularJS相去甚远，我们将完全跳过AngularJS，首先看一下Angular的构建块——组件。跟上我吗？好的，让我们快速前进。
- en: Angular's building blocks
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular的构建块
- en: Adding new features is the business of publishing new frameworks—but luckily,
    the fundamental underlying architecture does not change very often. When it does,
    it's not typically a complete overhaul. With the exception of Angular 2.0, which
    was completely divergent from its predecessor, all major releases so far contain
    largely the same architecture.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新功能是发布新框架的事情，但幸运的是，基本的底层架构并不经常改变。当它改变时，通常不是完全的彻底改变。除了完全不同于其前身的Angular 2.0之外，到目前为止，所有主要版本发布基本上包含相同的架构。
- en: Let's now take a look at the core architectural pieces of the framework.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看框架的核心架构组件。
- en: Components
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件
- en: Components are like widgets that are in charge of displaying themselves along
    with the data they consume and/or manipulate on areas of your screen called views.
    An Angular application is like a tree of components, and Angular provides mechanisms
    for components to communicate with each other in a bidirectional manner—parent
    to child and child to parent.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 组件就像小部件一样，负责在屏幕上的视图区域显示自己以及它们消耗和/或操作的数据。Angular应用程序就像一个组件树，Angular提供了组件之间双向通信的机制——从父级到子级和从子级到父级。
- en: Templates
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: Components rely on their templates for rendering their data. Templates are where
    you define what the component looks like and you can hook in styles to window-dress
    your component any way you like. A component can either contain its template (that
    is, the HTML) and its styling (that is, the CSS) either directly within itself
    or have references to template and style files outside of itself. At the end of
    the day, the world's fanciest frontend frameworks produce HTML, CSS, and JavaScript
    because these three things are the only things browsers understand.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 组件依赖于它们的模板来呈现它们的数据。模板是您定义组件外观的地方，您可以添加样式来装饰您喜欢的任何方式。组件可以包含其模板（即HTML）和其样式（即CSS），直接在自身内部，或者引用模板和样式文件在自身外部。归根结底，世界上最花哨的前端框架产生HTML、CSS和JavaScript，因为这三样是浏览器唯一理解的东西。
- en: Directives
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令
- en: Within the templates you create for your component, Angular enables you to alter
    the DOM with powerful constructs called directives. There are directives for controlling
    the way things are rendered on the screen (that is, the component view) such as
    repeating snippets of HTML, for displaying things based on conditional logic,
    for hiding or showing things, filtering arrays of data, and much more.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在您为组件创建的模板中，Angular使您能够使用称为指令的强大构造来更改DOM。有用于控制屏幕上的渲染方式（即组件视图）的指令，例如重复HTML片段，根据条件逻辑显示内容，隐藏或显示内容，过滤数据数组等等。
- en: Modules
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: Angular is modular. That is to say that its functionality is wrapped up in modules,
    known as NgModules, and are themselves libraries. Modules are perfect for lumping
    code together in an organized way. For instance, there are modules for helping
    with forms, routing, and communicating with RESTful APIs. Many third-party libraries
    are packaged as NgModules so you can incorporate them into your Angular applications.
    Two examples of this are Material Design and AngularFire—we'll be taking a look
    at both of these libraries in later chapters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是模块化的。也就是说，它的功能被封装在称为NgModule的模块中，并且它们本身就是库。模块非常适合以有组织的方式将代码组合在一起。例如，有用于帮助处理表单、路由和与RESTful
    API通信的模块。许多第三方库被打包为NgModule，因此您可以将它们整合到您的Angular应用程序中。其中两个例子是Material Design和AngularFire
    - 我们将在后面的章节中查看这两个库。
- en: Services
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: Services are not really an Angular artifact per se, but rather a very general
    notion representing encompassed functionality, functions, and features that your
    application's components may need to consume. Things such as logging, data retrieval,
    or virtually any calculation or lookup service, can be written as services—these
    services can reside within your application, or live externally from it. You can
    think of a service as a highly specialized class that provides some *service* (such
    as looking up the distance between two zip codes) and does it well. Just as with
    components, not only are there tons of third-party services you can use in your
    Angular applications, but you can create your own custom services. We'll learn
    how to do this in [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml), *Integrating
    Backend Data Services*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 服务实际上并不是Angular的一个特定部分，而是一个非常普遍的概念，代表着应用程序组件可能需要消耗的封装功能、函数和特性。诸如日志记录、数据检索或几乎任何计算或查找服务等功能可以被编写为服务
    - 这些服务可以存在于您的应用程序中，也可以存在于外部。您可以将服务视为提供某种*服务*（例如查找两个邮政编码之间的距离）并且做得很好的高度专业化的类。与组件一样，不仅有大量的第三方服务可以在您的Angular应用程序中使用，而且您还可以创建自己的自定义服务。我们将在[第12章](9610f27b-03db-4258-8a68-24eb3901117b.xhtml)中学习如何做到这一点，*集成后端数据服务*。
- en: Dependency injection
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: '**Dependency injection**(**DI**), or **Inversion of Control** (**IoC**), is
    a very useful and common software design pattern. This pattern is used to *inject*
    objects into the objects that depend on them. The object you''re using that depends
    on other objects can just go ahead and use it without needing to worry where it
    is in order to load it, or how to instantiate it—you just use it as if it just
    sprung into existence at the time you needed it. Services are perfect for injecting
    into our application. We''ll learn how to use DI in Angular, and how we can use
    the Angular **command-line interface** (**CLI **) to generate injectable services
    of our own design.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入**（**DI**）或**控制反转**（**IoC**）是一种非常有用和常见的软件设计模式。这种模式用于将对象*注入*到依赖于它们的对象中。依赖于其他对象的对象可以直接使用它，而不需要担心它在哪里加载，或者如何实例化它
    - 你只需在需要时使用它，就好像它在你需要它的时候就出现了。服务非常适合注入到我们的应用程序中。我们将学习如何在Angular中使用DI，以及如何使用Angular的**命令行界面**（**CLI**）来生成我们自己设计的可注入服务。'
- en: 'Just before we move on to setting up our development environment, here are
    some interesting things about Angular:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续设置开发环境之前，这里有一些关于Angular的有趣事实：
- en: AngularJS was built using JavaScript, while Angular was built using TypeScript.
    While this adds a level of abstraction when writing Angular applications, using
    TypeScript provides a few important advantages when building larger apps with
    larger teams—we'll get to those shortly.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AngularJS是使用JavaScript构建的，而Angular是使用TypeScript构建的。虽然在编写Angular应用程序时这增加了一定程度的抽象，但使用TypeScript在构建更大的应用程序和更大的团队时提供了一些重要的优势-我们很快就会谈到这些。
- en: AngularJS was based on controllers, whereas Angular is component based. You'll
    learn all you need to know about components in [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml),
    **Building Angular Components.**
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AngularJS基于控制器，而Angular是基于组件的。您将在[第6章](acd5e47c-07a7-4954-993d-360134221325.xhtml)中学习有关组件的所有必要知识，**构建Angular组件**。
- en: SPAs are notorious for being difficult for implementing **Search Engine Optimization**
    (**SEO **), but Angular is SEO friendly.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单页应用程序以难以实现**搜索引擎优化**（**SEO**）而臭名昭著，但Angular对SEO友好。
- en: It's possible to build native mobile applications with Angular.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular也可以构建原生移动应用程序。
- en: It's also possible to build cross-platform, desktop-installed applications with
    Angular.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular也可以构建跨平台的桌面应用程序。
- en: Angular can also run on the server, using Angular Universal.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular也可以在服务器上运行，使用Angular Universal。
- en: You have to admit, this is a pretty impressive and exciting list. These things
    and more make learning Angular a worthwhile endeavor and the marketplace is asking
    for Angular know-how.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须承认，这是一个相当令人印象深刻和令人兴奋的清单。这些事情以及更多其他事情使学习Angular成为一项值得的努力，市场正在寻求Angular的专业知识。
- en: Setting up your development environment
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置您的开发环境
- en: In order to get started with Angular, you're going to need to have the **Angular
    CLI** installed; to install that, you first need to have Node.js and **npm** (**node
    package manager**) installed. If you've already got Node.js and npm installed,
    great! If not, don't worry—they are easy to install and I will take you through
    the installation process in Appendix A, *Toolchain for Web Development with Angular*,
    near the back of the book. In Appendix A, I also take you through installing the
    Angular CLI and how to use it for building Angular applications. For brevity,
    I'll refer to the Angular CLI tool as just the CLI from this point forward.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Angular，您需要安装**Angular CLI**；要安装它，您首先需要安装Node.js和**npm**（**node包管理器**）。如果您已经安装了Node.js和npm，太好了！如果没有，不用担心-它们很容易安装，我将在书的后面附录A“使用Angular进行Web开发的工具链”中带您完成安装过程。在附录A中，我还将带您安装Angular
    CLI以及如何使用它构建Angular应用程序。为了简洁起见，从现在开始我将简称Angular CLI工具为CLI。
- en: If you are unsure whether you have NodeJS and npm installed, you can check really
    quickly by typing `$ node -v` and `$ npm -v`, respectively, on your command line.
    Similarly, you can type `$ ng -v` on the command line to see whether you have
    CLI installed. If you get a version number back, you have that particular tool
    installed (as shown in the following screenshot I took).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定是否已安装NodeJS和npm，您可以通过在命令行上分别输入`$ node -v`和`$ npm -v`来快速检查。同样，您可以在命令行上输入`$
    ng -v`来查看是否已安装CLI。如果您收到版本号，那么您已安装了该特定工具（如我所示的下面的截图）。
- en: '**Note**: Do not type `$` at the beginning of the commands. The `$` signifies
    the command prompt, entry point for the commands you''ll type. Unix-based operating
    systems, such as macOS and Linux systems, commonly use `$` or `%` as their command
    prompt—depending on the shell being used, or if there are any custom settings
    specified in a configuration file on your system. Windows operating systems typically
    use the greater than sign, `>`, as their command prompt.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：不要在命令开头输入`$`。`$`表示命令提示符，您要输入的命令的入口点。基于Unix的操作系统，如macOS和Linux系统，通常使用`$`或`%`作为命令提示符，具体取决于所使用的shell，或者系统上的配置文件中指定的任何自定义设置。Windows操作系统通常使用大于号`>`作为命令提示符。'
- en: '![](assets/2d1515f5-ddb3-4f8b-a4bd-f47283a42a15.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2d1515f5-ddb3-4f8b-a4bd-f47283a42a15.png)'
- en: If any of these commands go unrecognized, jump on over to Appendix A real quick,
    install the tools, and jump right back here. I'll be waiting for you.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中任何命令无法识别，请快速跳转到附录A，安装工具，然后立即回到这里。我会等着你。
- en: We'll also need a code editor. There are many code editors available today,
    including a number of free ones. Though any code editor will suffice, I would
    suggest you use Visual Studio Code for your Angular development—at least while
    working through this book. The reason for this is that Visual Studio Code is free,
    it's cross-platform, and is an excellent code editor. It's also the code editor
    that I've used while writing this book and so when I suggest the use of an extension,
    you can easily install the same one.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个代码编辑器。今天有许多代码编辑器可用，包括一些免费的。虽然任何代码编辑器都可以，但我建议您在编写本书时至少使用Visual Studio
    Code进行Angular开发。原因是Visual Studio Code是免费的，跨平台的，是一个优秀的代码编辑器。这也是我在写这本书时使用的代码编辑器，所以当我建议使用某个扩展时，您可以轻松安装相同的扩展。
- en: The preceding is all you need for this first chapter. When we start building
    the example project, which requires us to have a local database, you'll also need
    to install MongoDB. MongoDB, also known as Mongo, is a great NoSQL database that
    is also free and cross-platform. I take you through Mongo's installation process
    in Appendix B, *MongoDB*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容就是本章的全部内容。当我们开始构建示例项目时，需要我们有一个本地数据库，您还需要安装MongoDB。MongoDB，也称为Mongo，是一个很棒的免费跨平台NoSQL数据库。我会在附录B，*MongoDB*中带您完成Mongo的安装过程。
- en: Additionally, there will be other software that you'll need to install, such
    as Chrome extensions, and I will let you know what they are and where to find
    them at the appropriate time. For now, let's get started with writing some Angular
    code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有其他软件需要安装，例如Chrome扩展程序，我会在适当的时候告诉您它们是什么以及在哪里找到它们。现在，让我们开始编写一些Angular代码。
- en: Writing your first Angular application
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写您的第一个Angular应用程序
- en: When it comes to experimenting with Angular code, as you pick up this awesomely
    powerful framework, you generally have two choices of how to proceed. The first
    is to use an online code editor such as JSFiddle, Plunker, StackBlitz, or more.
    In Appendix C, *Working with StackBlitz*, you'll learn about the basics of using
    StackBlitz so you can use it from time to time to test some quick code without
    needing a test project in your development environment. You can visit the StackBlitz
    website here: [https://stackblitz.com](https://stackblitz.com).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始尝试Angular代码时，作为您掌握这个强大的框架，通常有两种选择。第一种是使用在线代码编辑器，如JSFiddle、Plunker、StackBlitz等。在附录C中，*使用StackBlitz*，您将学习如何基本使用StackBlitz，以便您可以不时地使用它来测试一些快速代码，而无需在开发环境中需要测试项目。您可以在StackBlitz网站上访问：[https://stackblitz.com](https://stackblitz.com)。
- en: The second approach is to use your own local development environment—and since
    we've already set it up in the previous section, you can create a project whose
    sole purpose is to run some quick example code if you'd rather use that than an
    online code editor. My goal is to show you that you have options—there's not just
    one way to experiment with some code as you learn Angular.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用您自己的本地开发环境——因为我们已经在前一节中设置了它，您可以创建一个项目，其唯一目的是运行一些快速示例代码，如果您宁愿使用本地开发环境而不是在线代码编辑器。我的目标是向您展示您有选择的余地——学习Angular并不只有一种方法来尝试一些代码。
- en: When you use an online code editor, such as StackBlitz, the only software you
    need installed is a browser—no other tools whatsoever. While this makes things
    very easy, the trade-off is that you are extremely restricted in what you can
    do. That being said, I encourage you to experiment with an online code editor,
    but we'll only be using our development environments throughout this book. So,
    let's do that and create a small application together in just a few minutes time—we'll
    build a to-do list app.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用在线代码编辑器（如StackBlitz）时，您唯一需要安装的软件是浏览器——没有任何其他工具。虽然这使事情变得非常容易，但代价是您在所能做的事情上受到极大限制。话虽如此，我鼓励您尝试在线代码编辑器，但在本书中我们将只使用我们的开发环境。所以，让我们做到这一点，并在短短几分钟内一起创建一个小应用程序——我们将构建一个待办事项列表应用程序。
- en: Using your development environment
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用您的开发环境
- en: From this point forward, we'll be using our terminals, the CLI, and the Visual
    Studio Code. Head on over to [https://code.visualstudio.com](https://code.visualstudio.com),
    where you'll be able to download the Visual Studio Code installation package for
    your operating system of choice.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将使用我们的终端、CLI和Visual Studio Code。前往[https://code.visualstudio.com](https://code.visualstudio.com)，在那里您可以下载适用于您选择的操作系统的Visual
    Studio Code安装包。
- en: Location of your files
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的文件位置
- en: When it comes to setting up a local environment, you can, of course, place your
    directories and files wherever you like. If you have a folder where you have your
    web application projects, go to it now. If you don't have a dedicated place for
    projects, this is as good a time as any to get into the habit of being organized.
    For instance, on my machine, I have a folder named `dev` for any and all development
    I do. Within my `dev` folder, I have a folder named `playground`, where I have
    a subfolder for each technology I'm learning, or playing with. I prefer to use
    a Mac when writing code, and so my complete pathname to where I have my Angular
    *play stuff* is `/Users/akii/dev/playground/angular` (as shown at the bottom of
    the screenshot of my terminal, a few pages back). That same screenshot also shows
    the versions of Node.js, npm, and the CLI that I had installed at the time of
    writing. If having a directory structure like this works for you, by all means,
    use it. If you already have a way you organize your work, use that. The important
    thing is to be very disciplined and consistent with how you organize your development
    environment.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置本地环境时，您当然可以将目录和文件放在任何您喜欢的地方。如果您有一个存放Web应用项目的文件夹，请立即转到该文件夹。如果您没有专门的项目存放位置，现在是养成有条理习惯的好时机。例如，在我的电脑上，我有一个名为`dev`的文件夹，用于我所做的任何开发。在我的`dev`文件夹中，我有一个名为`playground`的文件夹，其中有一个我正在学习或玩耍的每种技术的子文件夹。我喜欢在编写代码时使用Mac，因此我存放Angular
    *play stuff*的完整路径是`/Users/akii/dev/playground/angular`（如前几页终端屏幕截图底部所示）。同一屏幕截图还显示了我在写作时安装的Node.js、npm和CLI的版本。如果这样的目录结构适合您，请尽管使用。如果您已经有组织工作的方式，请使用它。重要的是要非常有纪律性和一致性地组织您的开发环境。
- en: Generating our to-do list application
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成我们的待办事项列表应用程序
- en: With the installation of what we need now being out of the way—meaning we have
    our CLI tool available to us—go to your terminal and type the following at your
    command prompt `$ ng new to-dolist --style=scss --routing`, and then hit *Enter*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要的安装已经完成 - 这意味着我们可以使用CLI工具 - 转到您的终端并在命令提示符处键入以下内容`$ ng new to-dolist --style=scss
    --routing`，然后按*Enter*。
- en: The `ng` command runs the CLI tool, and its `new` command instructs it to create
    a new Angular application. The application, in this case, is named `to-dolist`.
    You'll notice that there also are two command-line flags, which are special options
    for the `new` command. The style flag tells the CLI that we'd like to use `scss`,
    instead of `css`, and the routing flag tells the CLI that we'd like it to integrate
    and set up routing for us by default. We'll be using SASS, as opposed to CSS,
    in this book, and SCSS is the file extension for Sass files. As a reminder, we're
    going to have a crash course on Sass in [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml), *Bootstrap
    – Grid Layout and Components.*
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng`命令运行CLI工具，其`new`命令指示它创建一个新的Angular应用程序。在这种情况下，应用程序的名称是`to-dolist`。您会注意到还有两个命令行标志，这是`new`命令的特殊选项。style标志告诉CLI我们想要使用`scss`，而不是`css`，routing标志告诉CLI我们希望它默认集成和设置路由。在本书中，我们将使用SASS，而不是CSS，并且SCSS是Sass文件的文件扩展名。作为提醒，我们将在[第3章](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml)中进行Sass的速成课程，*Bootstrap
    - 网格布局和组件*。'
- en: The first time you use the CLI to create your Angular application, it will take
    anywhere from 45 seconds to well over a minute for it to create your project for
    you. This is because it needs to download and install various things for you before
    it creates the project's folder structure. However, when creating subsequent Angular
    applications, the CLI won't take nearly as long.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次使用CLI创建您的Angular应用程序时，它将花费45秒到一分钟多的时间为您创建项目。这是因为它需要为您下载和安装各种东西，然后再创建项目的文件夹结构。但是，创建后续的Angular应用程序时，CLI不会花费太长时间。
- en: Serving up our to do list application
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供我们的待办事项应用程序
- en: 'Once the CLI has completed creating the application, you can run it by changing
    to the project directory (`$ cd to-dolist`) and issuing the `$ ng serve` command.
    This will have the CLI run your application. The CLI''s built-in web server will
    be listening on localhost port `4200` by default. By the way, the CLI''s web server
    keeps watch on your project files, and when it notices a change in one of your
    files, it reloads the application—there''s no need for you to stop the server
    and issue the server command again. This is very convenient as you''re making
    lots of changes and tweaks during development. Next, open your browser and visit
    `http://localhost:4200` and you should see something like the following, which
    proves that the CLI is working correctly:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦CLI完成创建应用程序，您可以通过转到项目目录（`$ cd to-dolist`）并发出`$ ng serve`命令来运行它。这将使CLI运行您的应用程序。CLI的内置Web服务器默认情况下将在localhost端口`4200`上监听。顺便说一句，CLI的Web服务器会监视您的项目文件，当它注意到文件中的更改时，它会重新加载应用程序
    - 您无需停止服务器并再次发出服务器命令。这在开发过程中进行大量更改和调整时非常方便。接下来，打开浏览器并访问`http://localhost:4200`，您应该会看到类似以下内容的东西，这证明了CLI正在正确工作：
- en: '![](assets/f235b2f8-c85e-4dd7-a3e1-9fcc0f7633e9.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f235b2f8-c85e-4dd7-a3e1-9fcc0f7633e9.png)'
- en: 'Now that the CLI created the to-do list application for you, open that folder
    in Visual Studio Code (note: for brevity, I''ll be referring to Visual Studio
    Code as the IDE). You should see a folder structure for your to-do list project
    in the left-hand panel of your IDE, similar to the following (except for the to-do
    folder, which you won''t have just yet; we''ll get to how to generate that using
    the CLI in the upcoming subsection on components).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在CLI已为您创建了待办事项列表应用程序，请在Visual Studio Code中打开该文件夹（注意：为简洁起见，我将把Visual Studio
    Code称为IDE）。您应该在IDE的左侧面板中看到待办事项列表项目的文件夹结构，类似于以下内容（除了待办事项文件夹，您目前还没有；我们将在即将到来的组件子部分中介绍如何使用CLI生成它）。
- en: 'The following is a screenshot of the to-dolist project in the IDE (with the
    `app.component.ts` file open):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是IDE中to-do列表项目的屏幕截图（`app.component.ts`文件已打开）：
- en: '![](assets/bbd90490-510f-4844-93ab-2d44cbfdcd46.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bbd90490-510f-4844-93ab-2d44cbfdcd46.png)'
- en: When working on your Angular applications, the vast majority of your time will
    be spent working within the `src | app` folder.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发Angular应用程序时，您将花费大部分时间在`src | app`文件夹中工作。
- en: Angular basics
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular基础知识
- en: Components are the basic building blocks of Angular. In fact, you can think
    of an Angular web application as a tree of components. When you use the CLI to
    generate the shell for your Angular application, the CLI also autogenerates one
    component for you. The filename is app.component.ts and is in the `src/app` folder.
    The app component is how your Angular application is bootstrapped—meaning that
    it is the first component that is loaded, and all the other components are pulled
    into it. This also means that components can be nested. The previous screenshot
    shows our project directory structure, with the `src/app` folder expanded, and
    the `app.component.ts` open in the IDE's file editor window. The `.ts` file extension
    indicates that it is a TypeScript file. Interesting note—when you write Angular
    applications, you use TypeScript instead of JavaScript. In fact, the Angular team
    used TypeScript to write Angular!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是Angular的基本构建块。实际上，您可以将Angular Web应用程序视为一个组件树。当您使用CLI为Angular应用程序生成外壳时，CLI还会为您自动生成一个组件。文件名为app.component.ts，位于`src/app`文件夹中。应用程序组件是Angular应用程序的引导方式，意味着它是加载的第一个组件，所有其他组件都被拉入其中。这也意味着组件可以嵌套。之前的屏幕截图显示了我们的项目目录结构，`src/app`文件夹已展开，并且`app.component.ts`在IDE的文件编辑器窗口中打开。`.ts`文件扩展名表示它是一个TypeScript文件。有趣的是，当您编写Angular应用程序时，您使用的是TypeScript而不是JavaScript。实际上，Angular团队使用TypeScript编写Angular！
- en: After the following *Components* section, you'll find a complete code listing
    for our Angular application. There are six files that you'll have to edit. Three
    of them are already available in the application that you generated with the CLI.
    The other three will be available in your project once you use the CLI to generate
    the to-do component, which is the directory that you are presently missing when
    you compare your project structure to the previous screenshot. You'll find out
    how to do that in the following *Components* section, which is why the complete
    code listing was inserted afterward. Don't worry—follow along, keep the faith
    that Angular mastery is within your grasp, and you'll be just fine. If you don't
    believe me, just lie down on the floor and mumble these words, *This too, shall
    pass*, three times, slowly.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下*组件*部分之后，您将找到我们Angular应用程序的完整代码清单。有六个文件需要编辑。其中三个已经在您使用CLI生成的应用程序中可用。另外三个将在您使用CLI生成待办事项组件后在项目中可用，这是您比较项目结构和之前屏幕截图时目前缺少的目录。您将在以下*组件*部分中了解如何做到这一点，这就是为什么完整的代码清单被插入在后面。不要担心
    - 跟着走，相信自己可以掌握Angular，一切都会好起来的。如果你不相信我，就躺在地板上，慢慢地喃喃地说这些话，“这也会过去”，三次。
- en: Components
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件
- en: This section is a high-level fly-by on Angular components—just enough coverage
    of what an Angular component is. [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml), *Building
    Angular Components*, is completely dedicated to Angular components and is where
    we're going to take a deep dive into them. Consider this section to be a little
    peek behind the component curtain, and when we get to discussing components, we're
    going to pull the curtains wide open and take a good look at the *Component Wizard
    of Oz*. Remember that in the *Wizard of Oz* story, Dorothy and the gang were petrified
    of the Wizard, but when he was finally revealed behind the curtains, they all
    soon stopped being scared.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分是关于Angular组件的高层次概述 - 对Angular组件是什么的足够覆盖。《第6章》《构建Angular组件》完全专门讨论了Angular组件，我们将深入研究它们。可以将本节视为窥探组件幕后的一点，当我们讨论组件时，我们将拉开窗帘，好好看看“奥兹国的组件巫师”。请记住，在《奥兹国的巫师》故事中，多萝西和小伙伴们都害怕巫师，但当他最终在窗帘后面显露出来时，他们很快就不再害怕了。
- en: As previously mentioned, you can think of components as the basic building blocks
    or Angular, and of your Angular application as a tree of nested components. Buttons,
    progress bars, input fields, entire tables, advanced things such as carousels,
    and even custom video players—these are all components. The components on your
    web page can communicate with each other, and Angular has a couple of rules and
    protocols for how they can go about doing so. By the end of this book, you will
    become very comfortable with the ins and outs of components. You must, for it's
    simply the way of the Angular guru!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，你可以将组件视为Angular的基本构建块，将你的Angular应用程序视为嵌套组件树。按钮、进度条、输入字段、整个表格、高级的东西如轮播图，甚至自定义视频播放器
    - 这些都是组件。你网页上的组件可以相互通信，Angular有一些规则和协议来指导它们如何进行通信。在本书结束时，你将对组件的方方面面非常熟悉。你必须熟悉，因为这就是Angular大师的方式！
- en: When you write a component file, as in the code that follows, there are three
    main sections to it. The first is the import section. The middle section is the
    component decorator, and it's where you indicate what the component's template
    file is (which defines what the component looks like), and what the components
    style file is (which is used to style the component).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一个组件文件时，就像下面的代码一样，它有三个主要部分。第一部分是导入部分。中间部分是组件装饰器，你可以在这里指定组件的模板文件（定义组件的外观）和组件的样式文件（用于为组件设置样式）。
- en: '**Note**: Since we used the `style=scss` flag, we get our file in SCSS as opposed
    to the traditional CSS type file. The export section is the last section in the
    component file and is where all the logic for the component will be placed. There''s
    a lot more that can go into a component''s TypeScript file than what is shown
    in the following code snippet, as we''ll see in [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml), *Building
    Angular Components.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：由于我们使用了`style=scss`标志，我们得到的文件是SCSS，而不是传统的CSS类型文件。导出部分是组件文件中的最后一部分，是组件所有逻辑的放置位置。组件的TypeScript文件中可以放入比下面代码片段中显示的更多内容，我们将在《第6章》《构建Angular组件》中看到。'
- en: '[PRE0]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The CLI created the app component for us by default when it created our application
    for us, but how do we create our own components? The easiest way to generate a
    new component is to use the CLI and issue the following command: `$ ng generate
    component name-of-component`. So, to generate a new component named `to-doitem`,
    we would type `$ ng generate component to-doitem` on our command prompt. Remember
    to do this from within the `src | app` folder. The CLI will generate this component
    and insert it into its own folder, and the name of the newly created folder will
    be the same as the component.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: CLI在创建我们的应用程序时默认为我们创建了应用程序组件，但是我们如何创建自己的组件呢？生成新组件的最简单方法是使用CLI并发出以下命令：`$ ng generate
    component name-of-component`。因此，要生成一个名为`to-doitem`的新组件，我们将在命令提示符中键入`$ ng generate
    component to-doitem`。请记住要在`src | app`文件夹内执行此操作。CLI将生成此组件并将其插入到自己的文件夹中，新创建的文件夹的名称将与组件相同。
- en: 'Inside this folder, you will see four new files and their names all start with
    `to-doitem.component` because the name of our component is `todoitem`, and, well,
    it''s a component. We''ll discuss what the file ending in `spec.ts` is used for
    later, but you may already have a good guess as to what the other three files
    are for. Let''s verify what you are probably already thinking; the component file
    itself is indeed the one named `todoitem.component.ts`. This file contains a reference
    to two of the others: `todoitem.component.html`, which is the template for the
    component (the HTML code, for defining its markup structure), and the `todoitem.component.scss`
    file, which will hold the styling for the component. Additionally, the CLI modified
    an existing file named `app.module.ts`. We''ll discuss this file in more detail
    later on, but for now, all you need to know is that this file acts as a registry
    for your application''s components.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件夹中，您将看到四个新文件，它们的名称都以`to-doitem.component`开头，因为我们的组件名称是`todoitem`，嗯，它是一个组件。我们将在后面讨论以`spec.ts`结尾的文件用于什么，但您可能已经猜到其他三个文件的用途。让我们验证您可能已经在想的内容；组件文件本身的确是名为`todoitem.component.ts`的文件。该文件包含对其他两个文件的引用：`todoitem.component.html`，它是组件的模板（HTML代码，用于定义其标记结构），以及`todoitem.component.scss`文件，它将保存组件的样式。此外，CLI修改了一个名为`app.module.ts`的现有文件。我们将在稍后更详细地讨论这个文件，但现在，您需要知道的是，该文件充当了应用程序组件的注册表。
- en: You may be thinking, *That's a lot of files. Are they all needed?* The short
    answer to that is no. In  [Chapter 5](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml), F*lex-Layout
    – Angular's Responsive Layout Engine,* we'll look at how we can eliminate the
    `.html` file, and the `.scss` files, and just put all of our component *stuff* (the
    HTML and the styling) into our component file. However, there is a reason the
    Angular team provided the mechanism to have all these things be separate—so your
    application's code can be tidy and organized. You can thank them later.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想，“这是很多文件。它们都是必需的吗？”对此的简短回答是否定的。在[第5章](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml)中，*Flex-Layout
    – Angular的响应式布局引擎*，我们将看到如何消除`.html`文件和`.scss`文件，只需将所有组件的*内容*（HTML和样式）放入组件文件中。然而，Angular团队提供了将所有这些内容分开的机制的原因是为了使应用程序的代码整洁有序。稍后您可以感谢他们。
- en: A nice shortcut syntax when using the CLI to generate a component is to type
    `$ ng g c name-of-component`, where `g` is short for generating, and `c` is short
    for the component.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用CLI生成组件时的一个很好的快捷语法是键入`$ ng g c name-of-component`，其中`g`是生成的缩写，`c`是组件的缩写。
- en: In addition to creating our own components from scratch, which we'll look at
    in depth in [Chapter 5](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml), F*lex-Layout
    – Angular's Responsive Layout Engine*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从头开始创建自己的组件，我们将在[第5章](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml)中深入研究，*Flex-Layout
    – Angular的响应式布局引擎*。
- en: Code listing for the to-do list application
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 待办事项列表应用程序的代码清单
- en: Now that you have the to-do component generated, you have four new files within
    the `todo` folder. You'll edit three of them to look like the following code listings
    that follow. You also need to edit three of the files that were already in your
    project, (where we'll open the curtains to meet the wizard), we can also integrate
    components from other libraries and frameworks into our application. We'll take
    a look at how to do this with NG Bootstrap in [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml), *Building
    Angular Components*, and with Angular Material in [Chapter 7](cd8509d5-4bce-4056-8156-557186df18cd.xhtml),
    *Templates, Directives, and Pipes*. There's no shortage of components for Angular,
    and the amount available for your use will only grow over time.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经生成了待办事项组件，您在`todo`文件夹内有四个新文件。您将编辑其中三个文件，使其看起来像下面的代码清单。您还需要编辑项目中已经存在的三个文件，（在这里我们将打开窗帘，见到巫师），我们还可以将其他库和框架的组件集成到我们的应用程序中。我们将在[第6章](acd5e47c-07a7-4954-993d-360134221325.xhtml)中看看如何使用NG
    Bootstrap进行此操作，以及在[第7章](cd8509d5-4bce-4056-8156-557186df18cd.xhtml)中使用Angular
    Material，*模板、指令和管道*。Angular的组件不少，随着时间的推移可用的数量只会增加。
- en: 'Whenever I learn new technology and follow along with a book, blog post, or
    whatever else, I enter everything in by hand—even when the files are available
    for download. Yes, manual entry can be a tedious process, but it engages your
    brain, and the material and concepts start to get absorbed. Simply downloading
    the files and cutting and pasting the contents into your application does not
    have the same effect. I''ll let you decide which way you want to go. If you opt
    for downloading the code, there are instructions at the beginning of this book
    for doing so:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我学习新技术并跟着书籍、博客文章或其他内容时，我都会手动输入所有内容，即使文件可以下载。是的，手动输入可能是一个乏味的过程，但它会激发您的大脑，并且材料和概念开始被吸收。简单地下载文件并将内容剪切粘贴到您的应用程序中并不会产生同样的效果。我会让您决定您想要走哪条路。如果您选择下载代码，本书开头有相应的说明：
- en: 'The code listing for `todo.component.html` (within the `src | app | todo` folder)
    is shown here:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`todo.component.html`（在`src | app | todo`文件夹内）的代码清单如下所示：'
- en: '[PRE1]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The code listing for `todo.component.ts` (within the `src | app | todo` folder)
    is as follows:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`todo.component.ts`（在`src | app | todo`文件夹内）的代码清单如下所示：'
- en: '[PRE2]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The code listing for `todo.component.scss` (within the `src | app | todo` folder)
    is as follows:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`todo.component.scss`（在`src | app | todo`文件夹内）的代码清单如下所示：'
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is the code listing for `app.component.html` (within the `src
    | app` folder). [Chapter 1](f1243d74-a120-408f-8181-cb379b457dd1.xhtml), *Quick
    Start* : to-do List (quick example app):'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是`app.component.html`（在`src | app`文件夹内）的代码清单。[第1章](f1243d74-a120-408f-8181-cb379b457dd1.xhtml)，*快速入门*：待办事项列表（快速示例应用）：
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The code listing for `app.module.ts` (within the `src | app` folder) is as
    follows:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.module.ts`（在`src | app`文件夹内）的代码清单如下所示：'
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The code listing for `styles.scss` (within the `src` folder) is shown here:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`styles.scss`（在`src`文件夹内）的代码清单如下所示：'
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Cool! So, now you have all the code in place. Do you remember how to run your
    Angular application? Enter `$ ng serve` at your command prompt, and once the message
    comes up that the compilation was successful, open your browser and go to `http://localhost:4200`.
    Does the application work? If so, congratulations on building your first Angular
    application! If not, check for typos.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在您已经把所有的代码放在了正确的位置。您还记得如何运行您的Angular应用程序吗？在命令提示符处输入`$ ng serve`，一旦出现编译成功的消息，打开浏览器并转到`http://localhost:4200`。应用程序是否正常工作？如果是，恭喜您建立了您的第一个Angular应用程序！如果不是，请检查拼写错误。
- en: Play around with your new application. We haven't bothered to take the time
    to add functionality to edit the to-do item, or to delete them, but you can clear
    it out by just reloading the application by hitting your browser's refresh button.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 玩一下您的新应用程序。我们还没有花时间添加编辑待办事项或删除它们的功能，但您可以通过点击浏览器的刷新按钮来清除它。
- en: Why do things get cleared out upon refreshing the page? This happens because
    we have an SPA and are not persisting the data that we enter into a database.
    We'll definitely be sure to add the ability to persist our data when we build
    our much larger application, which will be introduced to you by the end of this
    chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么刷新页面后会清空数据？这是因为我们使用的是单页应用，没有将输入的数据持久化到数据库中。当我们构建更大的应用程序时，我们一定会确保在本章末尾向您介绍的应用程序中添加持久化数据的能力。
- en: Interpolation
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插值
- en: Interpolation is how you get a value from a variable within your component class
    to render in the component's template. If you recall, the logic for the component
    goes in the export section of the component class. That is the same place where
    variables are that you would like to use interpolation to have their values rendered
    in the template (that is, rendered on the web page). Let's assume that you have
    a variable called `items` and that its value is currently `4`. To render the value
    in the template, you use a pair of double curly braces with the variable in between
    them. The variables and component logic are written inside the class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 插值是从组件类中的变量获取值并在组件模板中呈现的方法。如果您还记得，组件的逻辑放在组件类的导出部分。这也是您想要使用插值的变量所在的地方，以便在模板中呈现它们的值（即在网页上呈现）。假设您有一个名为`items`的变量，其值目前为`4`。要在模板中呈现该值，您可以使用一对双大括号，变量位于其中。变量和组件逻辑都写在类内部。
- en: Don't worry—we'll see lots of code snippets throughout the book that use interpolation,
    but for now, you can see this sample code that shows it in action. The code is
    meaningless and hardcoded for now, but it does demonstrate interpolation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心——在整本书中，我们会看到很多使用插值的代码片段，但现在，您可以看到这个示例代码，展示了它的作用。目前，这段代码是无意义的，是硬编码的，但它确实演示了插值。
- en: 'The first screenshot is of the component file (`home.component.ts`); the variable
    is declared on line 10:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个屏幕截图是组件文件（`home.component.ts`）；变量在第10行声明：
- en: '![](assets/30572145-f1fc-41da-bb99-4aeefaf4a75e.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/30572145-f1fc-41da-bb99-4aeefaf4a75e.png)'
- en: 'This second screenshot is of the component''s template file (`home.component.html`).
    Notice the pair of double curly braces on line 6:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个屏幕截图是组件的模板文件（`home.component.html`）。注意第6行的一对双大括号：
- en: '![](assets/76e0188f-b097-4146-8680-c70da6505d7b.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/76e0188f-b097-4146-8680-c70da6505d7b.png)'
- en: 'This last screenshot shows the rendered value, `4` in this case. That''s the
    basics of interpolation. We''ll see much more advanced usage of it throughout
    the book as we work on our annotated photo album:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '最后一个屏幕截图显示了呈现的值，这里是`4`。这就是插值的基础。在整本书中，随着我们在我们的注释相册上的工作，我们会看到更高级的用法： '
- en: '![](assets/3684dbe0-0840-4063-9527-d2a2f7646344.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3684dbe0-0840-4063-9527-d2a2f7646344.png)'
- en: Templating and styling
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板化和样式
- en: 'We''ve already mentioned something about templating and styling in the last
    few paragraphs of the *Components* section. Now that we have a small project available
    to us—the one that we created with the CLI—we can see what this looks like in
    code. Open your Angular project in the IDE, and open the `app.component.ts` file.
    Lines 5 and 6 in this app component file contain the references to its associated
    template (the `.html` file), and its style file (`.scss`), respectively. The following
    is a screenshot of the open project in my IDE, with the `app.component.ts` file
    open:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在*组件*部分的最后几段中，我们已经提到了有关模板和样式的内容。现在我们有一个小项目可用——我们用CLI创建的一个——我们可以看看这在代码中是什么样子。在IDE中打开您的Angular项目，并打开`app.component.ts`文件。这个应用组件文件的第5和第6行包含了它关联模板（`.html`文件）和样式文件（`.scss`）的引用。以下是我IDE中打开项目的屏幕截图，`app.component.ts`文件已打开：
- en: '![](assets/e12b6c78-e46f-443e-9ffc-baf3919b0333.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e12b6c78-e46f-443e-9ffc-baf3919b0333.png)'
- en: Property binding
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性绑定
- en: There are two types of data binding we can do in Angular, namely, one-way and
    two-way. Interpolation is very similar to one-way data binding. This is because,
    in both cases, data flows from the component class to the component template and
    not the other way around. Property binding is data binding in the sense that the
    data is being bound to a property.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，我们可以进行两种数据绑定，即单向和双向。内插类似于单向数据绑定。这是因为在这两种情况下，数据都是从组件类流向组件模板，而不是相反。属性绑定是数据绑定，因为数据被绑定到属性。
- en: It's also possible to have two-way property binding—meaning, not only can the
    value of a component property be bound to the template, but the template can alter
    the value of a component property. This is made possible in Angular by `ngModel`.
    Again, don't worry about this for now. We will take a look at two-way property
    binding later on. Just know that both one-way and two-way property binding is
    possible in Angular.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以进行双向属性绑定，意思是不仅可以将组件属性的值绑定到模板，而且模板也可以改变组件属性的值。这在Angular中通过`ngModel`实现。不用担心这个，我们稍后会看到双向属性绑定。只需知道在Angular中，单向和双向属性绑定都是可能的。
- en: Implementing one-way property binding is very straightforward. All you need
    to do is to put square brackets around the HTML property (in the component's template)
    you want the data bound to, and assign the variable to it. To see a quick example
    of what one-way property binding looks like in code, take a look at the next three
    screenshots.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 实现单向属性绑定非常简单。您只需要在组件模板中的HTML属性周围加上方括号，并将变量分配给它。要看一下单向属性绑定在代码中是什么样子的快速示例，请查看接下来的三张屏幕截图。
- en: 'The first screenshot is of the component file (`home.component.ts`); the variable,
    `txtPlaceholder`, is declared on line 11:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第一张屏幕截图是组件文件（`home.component.ts`）；变量`txtPlaceholder`在第11行声明：
- en: '![](assets/31cdb8a5-ea56-47b0-9f2b-31262d708db0.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/31cdb8a5-ea56-47b0-9f2b-31262d708db0.png)'
- en: 'This next screenshot is of the component''s template file (`home.component.html`).
    In line 14, you can see the square brackets around the placeholder property of
    the input element:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张屏幕截图是组件的模板文件（`home.component.html`）。在第14行，您可以看到输入元素的占位符属性周围有方括号：
- en: '![](assets/a85ab11c-81f6-48a4-ae43-e5143ea231b2.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a85ab11c-81f6-48a4-ae43-e5143ea231b2.png)'
- en: 'This last screenshot is of the application running in the browser. You can
    see the text, Enter your todo item here, inserted as the placeholder text for
    the textbox via one-way property binding:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一张屏幕截图是应用程序在浏览器中运行的情况。您可以看到文本“在此输入您的待办事项”被插入为文本框的占位文本，通过单向属性绑定：
- en: '![](assets/cd5ce0ef-f94c-491c-bea0-ed5154c3108d.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cd5ce0ef-f94c-491c-bea0-ed5154c3108d.png)'
- en: Event binding
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件绑定
- en: In Angular, event binding simply means that an event will be registered on an
    element within a component, and when that event happens, it will trigger a function
    to be called. In other words, an event will call a function. There are a ton of
    events that you can have Angular listen for—such as a button being clicked, a
    mouse hovering over an image, or when the user presses a key down when the cursor
    is in a textbox, and lots more. And, of course, you can write any function you
    can possibly think of to make other stuff happen, such as calling a web service,
    changing the color of the background page, calculating the value of Pi to 1,000
    decimal places, or virtually anything else your heart desires. But how can we
    set up event binding in our Angular application to tie the event we're interested
    in, on the element we're interested in, to run the function we want? Well, thankfully,
    the Angular team made this super easy for us.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，事件绑定简单地意味着在组件内的元素上注册一个事件，当该事件发生时，将触发调用一个函数。换句话说，一个事件将调用一个函数。你可以让Angular监听大量的事件，比如按钮被点击，鼠标悬停在图像上，或者当用户在文本框中按下键时，还有很多其他事件。当然，你可以编写任何你能想到的函数来实现其他功能，比如调用web服务，改变背景页面的颜色，计算Pi的值到1000位小数，或者几乎任何你想要的其他功能。但是，我们如何在我们的Angular应用程序中设置事件绑定，以便将我们感兴趣的事件，绑定到我们感兴趣的元素，运行我们想要的函数呢？幸运的是，Angular团队为我们做到了这一点。
- en: Suppose we'd like to have some user interaction via events such as click or
    mouseover—we can use event binding to map the functionality.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想通过点击或悬停鼠标等事件进行一些用户交互 - 我们可以使用事件绑定来映射功能。
- en: Now, that example is not very interesting, but we do have our to-do list application
    to look at the code we've already written. If you've typed in the code listings.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个例子并不是很有趣，但我们有我们的待办事项列表应用程序，可以查看我们已经编写的代码。如果你已经输入了代码清单。
- en: Our sample project
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的示例项目
- en: Learning a new programming language, or learning a new framework, is a matter
    of hands-on experimentation and repetition. Even Dr. Sheldon Cooper from *The
    Big Bang Theory* can't learn Angular just by reading a book on it. However, just
    following along with random code examples isn't much fun to do and, at the end
    of the day, you don't really have anything you can use. So, the approach we'll
    take on our journey to Angular mastery is to build a fully fledged web application
    that is fun to build and practical since you can deploy it and use it yourself.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 学习一门新的编程语言，或者学习一个新的框架，是一个动手实验和重复的问题。即使是《生活大爆炸》中的谢尔顿博士也不能只靠读一本关于Angular的书就学会它。然而，只是跟随随机的代码示例并不是一件有趣的事情，而且到最后，你实际上并没有任何可以使用的东西。因此，我们在学习Angular的过程中采取的方法是构建一个完整的网络应用程序，这样做既有趣又实用，因为你可以部署并自己使用它。
- en: Annotated photo album
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释照片相册
- en: The application that we'll be building together is based on one of the online
    services I've launched called Vizcaro. Vizcaro is a photo sharing service, but
    instead of sharing individual photos, you share albums (groups of photos). Also,
    the photos and albums will be annotated so you can add titles and captions to
    them. Our version won't have all the bells and whistles that my online service
    offers, but it will have just enough parts to make it a great web application
    to build in order to learn the material in this book.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一起构建的应用程序是基于我推出的一个在线服务之一，名为Vizcaro。Vizcaro是一个照片分享服务，但与其分享单个照片不同，你分享相册（一组照片）。此外，照片和相册将被注释，因此你可以为它们添加标题和说明。我们的版本不会拥有我在线服务提供的所有功能，但它将有足够的部分，使它成为一个很好的网络应用程序，以便学习本书中的材料。
- en: Design principles
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计原则
- en: 'There are generally two types of design: the way in which you design your user
    interface (the GUI), and the way in which you design the software components (API
    interfaces, services, components, and more). Throughout this book, we''ll be covering
    quite a few design principles for the code. Angular is a spectacularly well-designed
    piece of software, and this is great for us because it provides a perfect opportunity
    to discuss software design as we learn Angular itself, in addition to when building
    our application. We''ll also be covering user interface design principles in general
    as we build our application throughout the remainder of this book, but particularly
    when we build out our templates using our wireframes to help guide us.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有两种设计类型：设计用户界面（GUI）的方式，以及设计软件组件（API接口、服务、组件等）的方式。在本书中，我们将涵盖许多代码设计原则。Angular是一个设计非常出色的软件，这对我们来说非常好，因为它为我们提供了一个完美的机会，在学习Angular本身的同时讨论软件设计，以及在构建我们的应用程序时。在本书的剩余部分中，我们还将涵盖用户界面设计原则，特别是在使用线框来指导我们构建模板时。
- en: In general, the term UX design is used when discussing user interface design.
    Borrowing a definition of UX design from *Wikipedia:*
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当讨论用户界面设计时，会使用UX设计这个术语。从维基百科借来UX设计的定义：
- en: '*"UX design is the process of enhancing user satisfaction with a product by
    improving the usability, accessibility, and pleasure provided in the interaction
    with the pr*o*duct."*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: “UX设计是通过改善产品的可用性、可访问性和提供的互动乐趣来增强用户对产品的满意度的过程。”
- en: This is a good definition and applies to more than just software products.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的定义，适用于不仅仅是软件产品。
- en: Wireframes
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线框
- en: Wireframes have been around since the early '80s. Their focus, at least initially,
    was on what the screen in the desktop application did (remember, web applications
    were not around yet), and for its general layout. They were not meant to be used
    as what the final design was to look like—including font selection, colors, and
    other properties of the controls on the screen. In essence, they were the *prototype
    on paper*. *Paper prototyping*, conversely, is a process that uses the wireframes.
    It's worth noting that the nouns *wireframes* and *mockups* are used interchangeably—they
    are the same thing. I'll briefly cover the paper prototyping process at the end
    of this chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 线框从80年代初就开始存在。它们的重点，至少最初，是桌面应用程序中屏幕的功能（请记住，当时还没有网络应用程序），以及其一般布局。它们并不是用来展示最终设计的样子，包括字体选择、颜色和屏幕上控件的其他属性。实质上，它们是“纸上原型”。相反，纸上原型是使用线框的过程。值得注意的是，名词“线框”和“模型”可以互换使用，它们是同一回事。我将在本章末尾简要介绍纸上原型的过程。
- en: Wireframing tools
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线框工具
- en: As you probably have already guessed, or already know, there are several tools
    available for creating wireframes when laying out your application, such as Balsamiq
    Mockups, Mockflow, and Visio. For my web applications, and in this book, my preference
    is to use Balsamiq Mockups. Which one you end up using for your applications,
    or are already using, doesn't matter. In fact, even if your wireframes are drawn
    by hand using a pen on the back of your napkin from your favorite fast food restaurant,
    it would be cool with me. Seriously, the important thing is that you get into
    the habit of creating wireframes before writing a single line of code. Why? Because
    it's a smart thing to do, and it saves you a lot of time. Additionally, it gives
    you the perfect opportunity to really think about what you're going to be building.
    And, it's something that you can present to users in order to get their feedback
    on the usability without writing a single line of code. There are even more benefits;
    it gives you some idea on how you would design your data model for the application,
    as well as APIs for services it may consume. Would you start a business without
    a business plan? Would you build your dream home without a blueprint? Building
    a web application shouldn't be any different specification out the pages using
    wireframes. Always. Capiche?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，或者已经知道的，有几种工具可用于创建线框图，用于布局你的应用程序，比如Balsamiq Mockups，Mockflow和Visio。对于我的Web应用程序，以及本书中，我更喜欢使用Balsamiq
    Mockups。你最终使用哪种工具，或者已经在使用哪种工具，都无关紧要。事实上，即使你的线框图是用笔在你最喜欢的快餐餐厅餐巾纸的背面手绘的，我也觉得很酷。说真的，重要的是在编写一行代码之前养成创建线框图的习惯。为什么？因为这是明智的做法，可以节省大量时间。此外，这给了你一个完美的机会来真正思考你将要构建的东西。而且，这是你可以向用户展示的东西，以便在编写一行代码之前获得他们对可用性的反馈。还有更多好处；它让你对如何为应用程序设计数据模型以及可能使用的服务的API有了一些想法。你会在没有商业计划的情况下开始一项业务吗？你会在没有蓝图的情况下建造你的梦想之家吗？构建Web应用程序不应该有任何不同，使用线框图规范页面。永远。明白了吗？
- en: Wireframes for our annotated photo album
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们注释的相册的线框图
- en: There are 10 wireframes that we'll be using for building our application—one
    for each screen it will have. The following is the listing of them, and a short
    description precedes each screenshot.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用10个线框图来构建我们的应用程序，每个屏幕都有一个。以下是它们的列表，每个屏幕截图前都有简短的描述。
- en: Home page
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主页
- en: 'Every web application needs a starting page of some kind. It''s known by many
    names, typically one of these: home page, landing page, index page, or splash
    page. Ours will be straightforward. No Flash animation or rainbow-colored backgrounds;
    it will be a simple page that lets the user know what the site does, and hopefully,
    it does that within five to seven seconds. If it doesn''t, you may lose the visitor
    forever:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Web应用程序都需要某种起始页面。它通常有许多名称，通常是这些之一：主页，登陆页面，索引页面或闪屏页面。我们的将是直接的。没有Flash动画或彩虹色的背景；它将是一个简单的页面，让用户知道网站的功能，并希望在五到七秒内完成。如果不能，你可能会永远失去访问者。
- en: '![](assets/ea890012-567d-4c92-818c-c96051c6c623.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ea890012-567d-4c92-818c-c96051c6c623.png)'
- en: Dashboard
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仪表板
- en: Most web applications don't have a dashboard page, but those that do typically
    provide a summary of *things* the user has, the last time they had logged in,
    and any notifications that the company would like to bring to the user's attention.
    If you use online banking, chances are that your bank's online banking web application
    has a dashboard page—and it probably is a list of accounts (checking, savings,
    credit cards, car loans, and more), and the balances on those accounts that you
    have with them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络应用程序没有仪表板页面，但那些有的通常会提供用户拥有的*东西*摘要，他们上次登录的时间，以及公司希望引起用户注意的任何通知。如果您使用在线银行业务，很可能您的银行在线银行网络应用程序有一个仪表板页面
    - 它可能是账户列表（支票、储蓄、信用卡、汽车贷款等），以及您在这些账户上的余额。
- en: 'We''re going to build an application that users will implement to create photo
    albums, and so our dashboard will contain the number of photos we have uploaded,
    the number of photo albums, the last time we logged in, and more:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个用户将用来创建相册的应用程序，因此我们的仪表板将包含我们上传的照片数量，相册数量，上次登录时间等：
- en: '![](assets/d581b2ce-f2d4-4777-b599-b1bef1e654be.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d581b2ce-f2d4-4777-b599-b1bef1e654be.png)'
- en: Image upload
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图片上传
- en: 'Since our application is supposed to enable our users to create photo albums,
    we''d better have a way for them to upload their photos! Yes—we are dedicating
    an entire web page to upload one photo at a time because we will use this same
    page to preview it after it has been uploaded—and to *undo* the upload. You''d
    be surprised to know that there is a well-known photo sharing site that does not
    show what you have just uploaded until you go to the listing of your photos! Having
    an immediate confirmation that the photo you intended to upload is, in fact, the
    one that was uploaded:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序应该让用户创建相册，我们最好让他们有办法上传照片！是的 - 我们将专门为上传一张照片而设立一个整个网页，因为我们将在上传后使用同一个页面来预览它
    - 并且*撤消*上传。您会惊讶地知道，有一个著名的照片分享网站直到您转到照片列表才会显示您刚刚上传的内容！立即确认您打算上传的照片实际上就是已上传的照片：
- en: '![](assets/7449aa18-12f6-493f-9e4c-1ac9c154bdc7.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7449aa18-12f6-493f-9e4c-1ac9c154bdc7.png)'
- en: Photo preparation
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 照片准备
- en: 'Uploading a photo is the first step in our annotated photo album application.
    We are devoting another web page to *preparation* the photo. This is where we
    will allow the user to resize the image and annotate it (give it a name and a
    caption). The photo''s caption will be shown when viewing it in the photo album:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 上传照片是我们注释相册应用程序的第一步。我们将为*准备*照片专门设置另一个网页。这是我们将允许用户调整图像大小并对其进行注释（给它一个名称和标题）的地方。查看相册时，照片的标题将显示出来：
- en: '![](assets/5fe4f4c7-bf33-4eb4-b79d-44f984d291c7.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5fe4f4c7-bf33-4eb4-b79d-44f984d291c7.png)'
- en: Create Album
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建相册
- en: 'Before the user can add photos in their photo albums, they have to be able
    to create the albums. This is what the following web page will be used for:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户可以在他们的相册中添加照片之前，他们必须能够创建相册。以下网页将用于此目的：
- en: '![](assets/e37499af-b3ba-4e09-a05e-7e5d0843cf35.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e37499af-b3ba-4e09-a05e-7e5d0843cf35.png)'
- en: Photo listing
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 照片列表
- en: 'You always need to think of usability and how to design the most intuitive
    user interface you possibly can. This page will show a listing of all the photos
    that the user has uploaded. Additionally, they can edit the name and caption for
    any of the photos right on this same page. The less jumping around from page to
    page that your users need to do, the happier they''ll be:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您总是需要考虑可用性以及如何设计尽可能直观的用户界面。此页面将显示用户上传的所有照片列表。此外，他们可以在同一页面上编辑任何照片的名称和标题。您的用户需要跳转的页面越少，他们就会越开心：
- en: '![](assets/59af18c7-4b71-4aaa-b476-45bc36327cbc.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/59af18c7-4b71-4aaa-b476-45bc36327cbc.png)'
- en: Photo album listing
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相册列表
- en: 'This page does for photo albums what the previous page did for photos—provides
    a listing of all the albums the user created and has an intuitive way to edit
    their name and description (as opposed to the caption for photos) without going
    to another web page:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面为相册做了前一页为照片所做的事情——提供了用户创建的所有相册的列表，并提供了一种直观的方式来编辑它们的名称和描述（而不是照片的标题），而无需转到另一个网页：
- en: '![](assets/46ec35d7-1d44-4526-a14b-e039003346c0.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/46ec35d7-1d44-4526-a14b-e039003346c0.png)'
- en: Workbench
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作台
- en: 'The workbench is the place where the user will be able to drag a photo onto
    a photo album. This will be our way of allowing the user to intuitively associate
    a specific photo to a specific album. By the way, not only will our drag and drop
    feature be intuitive and functional, it will add an element of fun for the user.
    Psychologically, users want to *play* on the site. Dragging and dropping—though
    not a mind-blowing experience—is more fun to do than it would be to select a photo
    from a photo dropdown, then select an album from an album dropdown, and, finally,
    click a *connect* or *associate* button. The former method would please the user,
    and the latter would make them send you a nastygram—then leave the site, never
    to return:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 工作台是用户可以将照片拖放到相册的地方。这将是我们让用户直观地将特定照片与特定相册关联的方式。顺便说一句，我们的拖放功能不仅直观而且功能强大，还会为用户增添一些乐趣。从心理上讲，用户希望在网站上“玩耍”。拖放——虽然不是令人惊叹的体验——比从照片下拉菜单中选择照片，然后从相册下拉菜单中选择相册，最后点击“连接”或“关联”按钮更有趣。前一种方法会让用户满意，而后一种方法会让他们发脾气，然后离开网站，再也不回来了。
- en: '![](assets/16597a79-4baf-40ae-8f85-07d830b16ad7.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/16597a79-4baf-40ae-8f85-07d830b16ad7.png)'
- en: Album viewer
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相册查看器
- en: 'At the end of the day, the users want to see their photo albums in an engaging
    way. The drag and drop stuff was fun but they''re not here for that. They''re
    here to see photos from their son''s birthday party, their daughter''s high school
    graduation, or pictures of their dream home. This is an important page for them;
    it''s where their work of using our site will pay off for them. Let''s not disappoint
    them:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 归根结底，用户希望以一种引人入胜的方式查看他们的相册。拖放的东西很有趣，但他们不是为了这个而来。他们来这里是为了看到儿子生日派对的照片，女儿高中毕业的照片，或者他们梦想家园的照片。这对他们来说是一个重要的页面；这是他们使用我们网站的工作将为他们付出的地方。让我们不要让他们失望：
- en: '![](assets/7aa7fb53-ab7c-4a21-8aa1-294ba62bfa96.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7aa7fb53-ab7c-4a21-8aa1-294ba62bfa96.png)'
- en: This concludes the introduction of our annotated photo album that we'll be building
    throughout the remainder of the book, the wireframing and this chapter's planned
    material that was to be covered. I did, however, want to quickly discuss paper
    prototyping, as a closing to the chapter, and to tie it back to the planning of
    our Angular application.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们在本书剩余部分将要构建的带注释的相册、线框和本章计划涵盖的材料的介绍。然而，我想快速讨论一下纸面原型，作为本章的结束，并将其与我们的Angular应用程序的规划联系起来。
- en: Paper prototyping
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纸面原型
- en: As mentioned near the beginning of this chapter, paper prototyping is a process.
    We had also mentioned that the core focus of paper prototyping was on usability
    testing. What we hadn't mentioned was that paper prototyping should be a part
    of the software development methodology that your development team uses—be it
    waterfall, or some form of agile. Specifically, paper prototyping should come
    immediately after the requirements documents are delivered to the project manager.
    That is the high-level view of what paper prototyping is and where it fits in.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开头提到的，纸面原型设计是一个过程。我们还提到纸面原型设计的核心重点是可用性测试。我们没有提到的是，纸面原型设计应该成为你的开发团队使用的软件开发方法论的一部分——无论是瀑布模型还是某种敏捷形式。具体来说，纸面原型设计应该在需求文档交付给项目经理后立即进行。这就是纸面原型设计是什么以及它在哪里适用的高层视图。
- en: Let's now take a look at the mechanics of the process at the lower level, meaning the
    interaction of the development team with the users of the application that is
    to be developed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在来看一下在较低层面上的流程机制，也就是开发团队与即将开发的应用程序的用户之间的互动。
- en: The mechanics, or process in which paper prototyping is done is to first create
    the wireframes and print them out (I know, more trees will be cut down and global
    warming becomes an even larger threat, but paper prototyping is important). Once
    the paper version is in front of you, your boss, your client, or a group of intended
    users (such as a focus group), you, or whomever else, will *use* the paper prototype
    just like they would by clicking their mouse onto the actual web application as
    if it were already finished and in production. You would ask them to pretend that
    it was the actual finished application. It sounds silly at first but human beings
    have an incredible imagination, and with little effort, they will be using it
    as they would the real thing! This is not hypnosis here but rather something quite
    magical starts to happen. Without your direction, except for at the very beginning
    when you explain what you're requesting of them and why, they will start to ramble
    on, talking out loud about the actions they are taking, or are thinking of taking,
    such as, *Ok, so now I need to fill this out and submit the form*, or *Where is
    the button to undo what I just did. I made a mistake*. The best information you're
    going to get from people going through this exercise is when they offer suggestions
    for how something may be improved, such as *It'd be nice if I can easily navigate
    back to where I...* . Can you imagine coding web pages and then realizing the
    changes being asked to have a far-reaching effect and would be a time-consuming
    change? It happens a lot.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 纸面原型设计的机制或流程是首先创建线框图并打印出来（我知道，会有更多的树被砍伐，全球变暖会变得更加严重，但纸面原型设计很重要）。一旦纸质版本摆在你面前，你的老板、客户或一群预期用户（比如焦点小组），你或其他人会像点击鼠标一样*使用*纸面原型，就好像它已经完成并投入生产一样。你会要求他们假装它是实际的完成应用程序。起初听起来很傻，但人类有着令人难以置信的想象力，只需很少的努力，他们就会像使用真正的东西一样使用它！这不是催眠，而是一种非常神奇的事情开始发生。除了在一开始解释你要求他们做什么以及为什么要求他们这样做时，他们会开始自发地大声谈论他们正在采取的行动，或者正在考虑采取的行动，比如，“好的，现在我需要填写这个表格并提交”，或者“按钮在哪里可以撤销我刚刚做的事情。我犯了一个错误”。通过这种练习，你从人们那里得到的最好的信息是他们提出了如何改进某些东西的建议，比如“如果我能轻松地导航回到我...”你能想象编写网页然后意识到被要求进行的更改具有深远影响并且需要耗费大量时间吗？这经常发生。
- en: Do you realize what you have by doing this? You have test users and you haven't
    written a single line of code! It is quite a powerful exercise! Try it, and email
    me your story.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你意识到通过这样做你得到了什么了吗？你有了测试用户，而且你还没有写一行代码！这是一个非常有力的练习！试一试，然后给我发电子邮件分享你的故事。
- en: So, when I explain this to a client—not to be the user, but how to present the
    paper prototyping process to their users and/or clients, I'm usually asked, *But
    this is paper. How do we change the screen?* I reply the best way I can—by showing
    them an example. I usually have a sample set of wireframes with me. Not only to
    demonstrate the paper prototyping process but also to just show a good example
    of wireframes. I lay down the login screen on the table we're seated at, and I
    ask them to log in using their finger as the mouse pointer, and then typing on
    their imaginary keyboard. After they chuckle and just play along with me by typing
    their username and password by fake typing on the table under the wireframe, they
    then hit the login button, and I become the computer—I pick up the login wireframe
    and put down the dashboard wireframe. They usually stop chuckling, look at the
    dashboard page, take a few seconds, and then look at me nodding and say, *This
    is cool. I get it*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，当我向客户解释这一点时——不是作为用户，而是如何向他们的用户和/或客户展示纸质原型制作过程时，我通常会被问到，*但这是纸张。我们怎么改变屏幕呢？*我会尽我所能地回答——通过向他们展示一个例子。我通常会带着一套线框的样本。不仅是为了演示纸质原型制作过程，也是为了展示一个良好的线框的例子。我把登录屏幕放在我们坐着的桌子上，然后让他们用手指作为鼠标指针登录，并在他们想象中的键盘上输入。在他们轻笑并和我一起假装在线框下输入他们的用户名和密码后，他们点击登录按钮，然后我成为了电脑——我拿起登录线框，放下仪表盘线框。他们通常停止轻笑，看着仪表盘页面，停顿几秒钟，然后看着我点头说，*这很酷。我明白了*。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was packed with a wide array of topics, I know. It was inevitable
    because there is no one best starting point for all the readers. For instance,
    some readers know what wireframes are and have used them for years, while other
    readers may have only just heard of the term, or maybe not even that. This is
    the third edition of this book, but it is quite a bit different from the first
    two editions and even if it was largely the same, which it isn't, it doesn't mean
    that readers have already gone through the first two editions. You can think of
    this first chapter as a type of funnel—a wide enough funnel that brings readers
    of all levels of experience, and differing knowledge, into a common track for
    learning Angular, and the other symbiotic technologies that are covered in this
    book. Starting with [Chapter 2](82376b53-6401-4844-9440-7ba76a2fb6a2.xhtml), *ECMAScript
    and TypeScript Crash Course*, the funnel approach is over. The rest of the chapters
    will be a lot more focused on the subject matter at hand. So, thank you for hanging
    in there with me. Still, I hope that there were a few things that made wading
    through this first couple of dozen pages worthwhile, even if you're not completely
    new to Angular.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章涵盖了各种各样的主题，我知道。这是不可避免的，因为没有一个最佳的起点适用于所有读者。例如，一些读者知道线框是什么，并且已经使用了多年，而其他读者可能刚刚听说过这个术语，甚至连那都不知道。这是本书的第三版，但它与前两版有很大不同，即使它基本上是相同的，这并不意味着读者已经阅读了前两版。你可以把这一章看作是一种漏斗——一个足够宽的漏斗，将各种经验水平和不同知识的读者引入学习Angular和本书涵盖的其他共生技术的共同轨道。从[第二章](82376b53-6401-4844-9440-7ba76a2fb6a2.xhtml)开始，*ECMAScript和TypeScript
    Crash Course*，漏斗方法结束了。其余的章节将更加专注于手头的主题。所以，感谢你和我一起坚持下来。不过，我希望在翻阅这前几十页时，有一些事情是值得的，即使你对Angular并不完全陌生。
- en: In review, we covered the evolution of Angular, including its semantic versioning
    and release schedule. Although the installation of NodeJS, npm, and the CLI are
    covered in Appendix A, this chapter is what guided that discussion, and we then
    used the CLI to build our first Angular app and a to-do list app together. We'll
    name the app to-do list because we're developers and not marketers (wink). We
    also covered how to use StackBlitz for building the same Angular application without
    having any reliance on our local development environment. We then covered the
    first very basic building blocks of Angular that you need to know well since they
    will be used again and again for any Angular apps you build. Namely, these were
    templating, property binding, event binding, and class binding. Lastly, we introduced
    the annotated photo album application that we'll be building together throughout
    this book and covered UX design principles, wireframing, and paper prototyping
    along the way. Whew! Mama mia!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，我们涵盖了Angular的演变，包括其语义版本和发布计划。虽然NodeJS、npm和CLI的安装在附录A中有介绍，但本章是引导该讨论的基础，并且我们使用CLI来构建我们的第一个Angular应用程序和一个待办事项列表应用程序。我们将应用程序命名为待办事项列表，因为我们是开发人员，而不是营销人员（眨眼）。我们还介绍了如何使用StackBlitz来构建相同的Angular应用程序，而不依赖于我们的本地开发环境。然后，我们介绍了Angular的第一个非常基本的构建模块，你需要很好地了解它们，因为它们将在你构建任何Angular应用程序时一再使用。具体来说，这些是模板化、属性绑定、事件绑定和类绑定。最后，我们介绍了我们将在整本书中一起构建的注释相册应用程序，并在此过程中介绍了UX设计原则、线框图和纸质原型。哇！天哪！
- en: In the next chapter, we will first understand the relationship between JavaScript
    and TypeScript. We will the as then, as the name suggests, do a crash course on
    TypeScript and it's advantages over JavaScript.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将首先了解JavaScript和TypeScript之间的关系。然后，正如其名称所示，我们将对TypeScript进行快速入门，并介绍它相对于JavaScript的优势。
