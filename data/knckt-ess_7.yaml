- en: Chapter 7. Durandal – The KnockoutJS Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。Durandal – KnockoutJS 框架
- en: Through six chapters, we have built a complete frontend application with the
    basic libraries.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过六章，我们已经使用基本库构建了一个完整的前端应用程序。
- en: 'We have used some libraries to achieve our objective:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一些库来实现我们的目标：
- en: '**Bootstrap 3**: To have a solid, responsive, and cross-browser base style
    in CSS3'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bootstrap 3**：用于在 CSS3 中拥有坚实、响应式和跨浏览器的基本样式。'
- en: '**jQuery**: To manipulate the DOM and communicate with the server side through
    AJAX'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jQuery**：用于操作 DOM 并通过 AJAX 与服务器端通信。'
- en: '**Mockjax**: To fake AJAX communication'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mockjax**：用于模拟 AJAX 通信。'
- en: '**MockJSON**: To create fake data'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MockJSON**：创建虚假数据。'
- en: '**KnockoutJS**: To bind data and synchronize JavaScript data and views easily'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**KnockoutJS**：用于绑定数据并轻松同步 JavaScript 数据和视图。'
- en: 'We have also applied some design patterns to improve the quality of our code:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应用了一些设计模式来提高代码质量：
- en: '**The reveal pattern**: To show the public interface of our objects and hide
    the private properties and methods'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**揭示模式**：显示对象的公共接口并隐藏私有属性和方法。'
- en: '**The module pattern**: To isolate our code and make it portable'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块模式**：用于隔离我们的代码并使其可移植。'
- en: '**The dependency injection pattern**: To improve cohesion and decrease coupling'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入模式**：用于提高内聚性和减少耦合度。'
- en: Finally, we introduced a library that helps us to manage dependencies in our
    project, RequireJS.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了一个帮助我们管理项目依赖的库，RequireJS。
- en: In small projects you can work with just these libraries. When the project grows,
    however, handling dependencies becomes harder. The more libraries and styles you
    need, the more difficult it is to maintain all of them. Also, it becomes harder
    to maintain the view-model, which begins to have too many lines of code. Splitting
    the view-model results in writing more events to communicate them, and events
    make code harder to debug.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在小型项目中，您可以仅使用这些库。但是，当项目增长时，处理依赖关系变得更加困难。您需要的库和样式越多，维护它们就越困难。此外，维护视图模型也变得更加困难，因为它开始具有太多的代码行。拆分视图模型会导致编写更多的事件来通信，而事件会使代码更难调试。
- en: To solve all these problems, Rob Eisenberg ([http://eisenbergeffect.bluespire.com/](http://eisenbergeffect.bluespire.com/))
    and his team created **Durandal** ([http://durandaljs.com/](http://durandaljs.com/)).
    Durandal is a framework that joins all the libraries and good practices you will
    learn henceforth.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决所有这些问题，Rob Eisenberg（[http://eisenbergeffect.bluespire.com/](http://eisenbergeffect.bluespire.com/)）及其团队创建了**Durandal**（[http://durandaljs.com/](http://durandaljs.com/)）。Durandal
    是一个框架，它集成了你今后将学到的所有库和良好的实践。
- en: In this chapter, you are going to acquire knowledge of the basics to start working
    with the Durandal framework. You are not going to work on your cart project in
    this chapter. This will continue in the next chapter. This chapter is about understanding
    how Durandal works and how it connects all the pieces to create web applications
    fast and easily.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习 Durandal 框架的基础知识，以便开始使用它。在本章中，您不会在购物车项目上工作。这将在下一章中继续。本章是关于了解 Durandal
    如何工作以及它如何连接所有部件以快速轻松地创建 Web 应用程序。
- en: It is important to mention that Durandal has been one of the simplest and fastest
    frameworks for building applications. When another good framework called AngularJS
    ([https://angularjs.org/](https://angularjs.org/)) announced its version 2.0,
    Eisenberg abandoned Durandal and became part of the AngularJS team. It was a big
    blow for the Durandal and KnockoutJS community. But recently, Eisenberg left the
    AngularJS 2.0 project and announced new versions of Durandal. So we can say that
    we are working with one of the best frameworks for developing modern, cross-browser,
    and fully-compatible web applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 需要提及的是，Durandal 一直是构建应用程序的最简单和最快的框架之一。当另一个名为 AngularJS（[https://angularjs.org/](https://angularjs.org/)）的良好框架宣布其
    2.0 版本时，艾森伯格放弃了 Durandal 并成为 AngularJS 团队的一部分。这对 Durandal 和 KnockoutJS 社区来说是一个重大打击。但最近，艾森伯格离开了
    AngularJS 2.0 项目，并宣布了 Durandal 的新版本。因此，我们可以说我们正在使用最佳框架之一来开发现代、跨浏览器且完全兼容的 Web 应用程序。
- en: Installing Durandal
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Durandal
- en: 'To install Durandal, follow these steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Durandal，请按照以下步骤操作：
- en: Go to [http://durandaljs.com/downloads.html](http://durandaljs.com/downloads.html).
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 [http://durandaljs.com/downloads.html](http://durandaljs.com/downloads.html)。
- en: 'Download the latest version of the starter kit: [http://durandaljs.com/version/latest/HTML%20StarterKit.zip](http://durandaljs.com/version/latest/HTML%20StarterKit.zip).'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载最新版本的入门套件：[http://durandaljs.com/version/latest/HTML%20StarterKit.zip](http://durandaljs.com/version/latest/HTML%20StarterKit.zip)。
- en: Unzip it in your project folder.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其解压缩到您的项目文件夹中。
- en: Rename it as `durandal-cart`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为`durandal-cart`。
- en: Add the Mongoose server to the project or use the server you feel comfortable
    with.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Mongoose 服务器添加到项目中，或者使用你感觉舒适的服务器。
- en: The starter kit will give you a very good starting point to understand how Durandal
    works. In the following projects we can start directly with the standalone Durandal
    library, but here we are going to analyze the parts of this framework carefully.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 起始套件将为你提供一个非常好的起点，以了解 Durandal 的工作原理。在接下来的项目中，我们可以直接使用独立的 Durandal 库开始，但在这里，我们将仔细分析这个框架的各个部分。
- en: 'To dig further into Durandal, download the `HTML Samples.zip` file ([http://durandaljs.com/version/latest/HTML%20Samples.zip](http://durandaljs.com/version/latest/HTML%20Samples.zip)),
    but it is up to you to test these interesting samples. The following are the contents
    of the starter kit:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解 Durandal，请下载`HTML Samples.zip`文件（[http://durandaljs.com/version/latest/HTML%20Samples.zip](http://durandaljs.com/version/latest/HTML%20Samples.zip)），但测试这些有趣的示例取决于你。以下是起始套件的内容：
- en: The starter kit contains three folders and an HTML `index` file.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 起始套件包含三个文件夹和一个 HTML `index` 文件。
- en: 'The `app` folder contains the application itself. This contains two folders:
    `viewmodels` and `views`.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app`文件夹包含应用程序本身。其中包含两个文件夹：`viewmodels`和`views`。'
- en: The `viewmodels` folder has all the view-models the application needs—usually
    one view-model per page.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viewmodels`文件夹包含应用程序需要的所有视图模型——通常每个页面一个视图模型。'
- en: The `views` folder contains the HTML bound to each view-model—usually one view
    per view-model. However, you can compose views (you will see that this is the
    actual power of Durandal).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views`文件夹包含绑定到每个视图模型的 HTML——通常每个视图对应一个视图模型。但是，你可以组合视图（你会发现这才是 Durandal 的实际力量）。'
- en: The `lib` folder contains the Durandal framework and all the libraries that
    the framework depends on.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib`文件夹包含 Durandal 框架和框架所依赖的所有库。'
- en: Inside the `durandal/js` folder you will find a folder called `plugins`. You
    can extend Durandal using plugins. You can also extend KnockoutJS using components
    and `bindingHandlers`.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`durandal/js`文件夹内，你会找到一个名为`plugins`的文件夹。你可以使用插件扩展 Durandal。你也可以使用组件和`bindingHandlers`扩展
    KnockoutJS。
- en: There is another folder called `transitions`. Inside it you can add animations
    that can be fired when a transition between two pages is complete. By default,
    there is just one (`entrance.js`), but you can download more from the Internet
    or build your own ones.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一个名为`transitions`的文件夹。在其中，你可以添加在两个页面之间进行过渡时触发的动画。默认情况下，只有一个（`entrance.js`），但你可以从互联网下载更多，或者自己构建。
- en: The `index.html` file will be the entry point to the JavaScript application.![Installing
    Durandal](img/7074OS_07_01.jpg)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.html`文件将是 JavaScript 应用程序的入口点。![安装 Durandal](img/7074OS_07_01.jpg)'
- en: Durandal's folder structure
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Durandal 的文件夹结构
- en: Durandal patterns
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Durandal 模式
- en: Before learning more about Durandal, let's learn about some patterns and concepts
    about the framework.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在更深入了解 Durandal 之前，让我们先学习一些关于框架的模式和概念。
- en: 'Durandal is a **Single Page Application** (**SPA**) framework. This means that:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Durandal 是一个**单页应用程序**（**SPA**）框架。这意味着：
- en: All web applications run on a single page (index page)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的 Web 应用程序都在一个页面上运行（首页）
- en: There is no full-page refreshing; just the parts that change are updated
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有完整页面刷新；只更新更改的部分
- en: Routing is not a server responsibility any more.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由不再是服务器的责任。
- en: AJAX is the basis of the communication with the server side
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AJAX 是与服务器端通信的基础
- en: 'Durandal follows the Model-View-ViewModel (MVVM) pattern:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Durandal 遵循 Model-View-ViewModel（MVVM）模式：
- en: 'Actually, it is called the MV* pattern because we can substitute the * with
    anything we use: View-model (MVVM), Controller (MVC), or Presenter (MVP). By convention,
    Durandal uses view-models.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上，它被称为 MV* 模式，因为我们可以用任何我们使用的东西替换 *：View-model（MVVM），Controller（MVC）或 Presenter（MVP）。按照惯例，Durandal
    使用视图模型。
- en: The MVVM pattern separates the view from the state (logic) of the application.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVVM 模式将应用程序的视图与状态（逻辑）分离。
- en: The view comprises the HTML files.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图由 HTML 文件组成。
- en: The view-models comprise JavaScript files bound to views.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图模型由绑定到视图的 JavaScript 文件组成。
- en: Durandal is focused on views and view-models. Models are not part of the framework.
    We should decide how they are built.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Durandal 专注于视图和视图模型。模型不是框架的一部分。我们应该决定如何构建它们。
- en: 'The framework uses the **Asynchronous Module Definition** (**AMD**) pattern
    to manage dependencies. It possesses the following characteristics:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架使用**异步模块定义**（**AMD**）模式来管理依赖关系。它具有以下特点：
- en: It uses RequireJS for this purpose.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用 RequireJS 实现这一目的。
- en: We should define one module per file.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该为每个文件定义一个模块。
- en: The name of the module will be the name of the file without the extension.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的名称将是没有扩展名的文件的名称。
- en: The index.html file
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: index.html 文件
- en: 'The `index.html` file is the entry point to the app. It should have a container
    with the ID, `applicationHost`. The application will run inside this container,
    and views will be interchanged:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html` 文件是应用程序的入口点。它应该有一个带有 ID `applicationHost` 的容器。应用程序将在此容器内运行，并且视图将被交换：'
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can define a `splash` element using the `splash` class. It shows when the
    application has completely loaded.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `splash` 类定义一个 `splash` 元素。当应用程序完全加载时，它会显示。
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, set the entry point of the Durandal application with RequireJS, as
    we set in the previous chapter. Set the `main.js` file as the entry point to the
    JavaScript:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 RequireJS 设置 Durandal 应用程序的入口点，就像我们在上一章中设置的一样。将 `main.js` 文件设置为 JavaScript
    的入口点：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The main.js file
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: main.js 文件
- en: 'The `main.js` file contains the RequireJS configuration. Here we can see which
    libraries use Durandal to work:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.js` 文件包含 RequireJS 配置。在这里，我们可以看到 Durandal 使用哪些库来工作：'
- en: '`text`: This is a RequireJS extension to load files that are not JavaScript
    files. Durandal uses `text` to load templates.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`: 这是一个 RequireJS 的扩展，用于加载非 JavaScript 文件。Durandal 使用 `text` 来加载模板。'
- en: '`durandal`: This is the core of the framework.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`durandal`: 这是框架的核心。'
- en: '`plugins`: In this folder, we can find parts of the framework that are not
    required in all applications. These pieces of code can be loaded according to
    project needs.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plugins`: 在这个文件夹中，我们可以找到并非所有应用程序都需要的框架部分。这些代码片段可以根据项目需要加载。'
- en: '`transitions`: This contains the different animations we can play between page
    transitions. By default, we have just the entry animation.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transitions`: 这包含了我们可以在页面转换之间播放的不同动画。默认情况下，我们只有进入动画。'
- en: '`knockout`: This is the library used to bind views and view-models.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`knockout`: 这是用于绑定视图和视图模型的库。'
- en: '`bootstrap`: This is the design library related to the `bootstrap.css` library.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootstrap`: 这是与 `bootstrap.css` 库相关的设计库。'
- en: '`jQuery`: This is the DOM manipulation library.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jQuery`: 这是 DOM 操作库。'
- en: 'You already have experience with RequireJS, since you converted files from
    your application to follow the AMD specification. This is how the `main.js` file
    containing the RequireJS configuration should look:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经有了使用 RequireJS 的经验，因为你将应用程序文件转换为遵循 AMD 规范。这就是包含 RequireJS 配置的 `main.js` 文件应该如何看起来的：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then define the `main` module. Define dependencies in the same way you used
    RequireJS in your cart project:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后定义 `main` 模块。以与您在购物车项目中使用 RequireJS 相同的方式定义依赖项：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This module is where the application is configured. In the starter kit project,
    there is a default configuration that helps you understand what you can do at
    this point:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块是配置应用程序的地方。在入门套件项目中，有一个默认配置，可以帮助您了解在这一点上可以做什么：
- en: 'Activate the debug (or not):'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激活调试（或不激活）：
- en: '[PRE5]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Set the application title. The application title will be concatenated with the
    page title by default.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置应用程序标题。应用程序标题将默认与页面标题连接起来。
- en: '[PRE6]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Activate and configure plugins:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激活和配置插件：
- en: '[PRE7]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Start the application:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动应用程序：
- en: '[PRE8]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When you start the application, you can choose to follow Durandal's conventions.
    If you choose to follow them by default, Durandal will relate view-models with
    views by looking for views in the `views` folder. They should have the same name
    the view-model has. This means that if you have a view-model called `viewmodel/catalog.js`,
    its associated view will be called `views/catalog.js`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当您启动应用程序时，您可以选择遵循 Durandal 的约定。如果您选择默认遵循它们，Durandal 将通过查找 `views` 文件夹中的视图将视图模型与视图关联起来。它们应该具有与视图模型相同的名称。这意味着如果你有一个名为
    `viewmodel/catalog.js` 的视图模型，它的关联视图将被称为 `views/catalog.js`。
- en: '![The main.js file](img/7074OS_07_02.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![主 `main.js` 文件](img/7074OS_07_02.jpg)'
- en: This is the file structure created by following Durandal conventions and is
    good for small and medium projects
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是按照 Durandal 约定创建的文件结构，适用于中小型项目
- en: This convention is good for small and medium projects. In big projects, it is
    recommended not to use Durandal conventions. If we choose not to use these conventions,
    Durandal will look for the view in the same folder that the view-model is in.
    For example, if the view-model is called `catalog/table.js`, the view should be
    named `catalog/table.html`. This allows us to group views and view-models by feature.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这种约定适用于小型和中型项目。在大型项目中，建议不使用Durandal约定。如果我们选择不使用这些约定，Durandal将在与视图模型相同的文件夹中查找视图。例如，如果视图模型称为`catalog/table.js`，则视图应命名为`catalog/table.html`。这使我们可以按功能组织视图和视图模型。
- en: '![The main.js file](img/7074OS_07_03.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![main.js文件](img/7074OS_07_03.jpg)'
- en: By not using Durandal conventions, we group our files by feature, which is good
    for big and scalable projects
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不使用Durandal约定，我们按功能对文件进行分组，这对于大型和可扩展的项目是有益的
- en: Finally, indicate to the framework which view-model will start the application.
    By default, the shell view-model does this.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，指示框架哪个视图模型将启动应用程序。默认情况下，shell视图模型会执行此操作。
- en: The shell view-model
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: shell视图模型
- en: '**Shell** is the entry point module. It is the module that wraps the other
    modules. It is loaded just once and has the DOM elements that persist all the
    time.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shell**是入口模块。它是包装其他模块的模块。它只加载一次，并且具有一直存在的DOM元素。'
- en: 'To define a view-model, define a simple JavaScript object using the AMD pattern,
    as done in the following steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义视图模型，请使用AMD模式定义一个简单的JavaScript对象，如以下步骤所示：
- en: 'Define dependencies, that is, the router and the Durandal app:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义依赖关系，即路由器和Durandal应用程序：
- en: '[PRE9]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Expose the `router` method. The `router` method will give us an object that
    allows us to show the navigation bar easily.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暴露`router`方法。`router`方法将给我们一个对象，使我们可以轻松显示导航栏。
- en: '[PRE10]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Expose the `search` method. This is an optional method. It's part of the starter
    kit application. It manages the global search.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暴露`search`方法。这是一个可选方法。它是入门套件应用程序的一部分。它管理全局搜索。
- en: '[PRE11]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Expose the `activate` method. This is an important method in Durandal view-models.
    The `activate` method is fired when the view-model is ready. Here, you can request
    data to bind it to the view. We will see more about Durandal life-cycle methods
    soon.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暴露`activate`方法。这是Durandal视图模型中的一个重要方法。`activate`方法在视图模型准备就绪时触发。在这里，您可以请求数据以将其绑定到视图。我们很快将看到有关Durandal生命周期方法的更多信息。
- en: '[PRE12]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The shell view
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: shell视图
- en: 'The **shell view** contains the navigation bar: the search bar and an element
    with an attached class called `page-host`. This element will be bound to the router,
    as in the following code. You can configure an animation to make the transition
    between pages cooler.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**shell视图**包含导航栏：搜索栏和附加类称为`page-host`的元素。此元素将绑定到路由器，如下面的代码所示。您可以配置动画以使页面之间的过渡更加酷。'
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Durandal life cycle
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Durandal生命周期
- en: 'It is important we understand clearly how a Durandal application works. This
    is a schema of how your application starts:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们清楚地了解Durandal应用程序如何工作是很重要的。这是您的应用程序启动的模式图：
- en: The `index.html` page uses RequireJS to request the `main.js` file.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`index.html`页面使用RequireJS请求`main.js`文件。'
- en: The `main.js` file configures require and defines the main module, which is
    responsible for the application configuration, and launches the shell module.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main.js`文件配置require并定义主模块，负责应用程序配置，并启动shell模块。'
- en: The shell module handles the global context of the application. It manages components
    that will be persistent along the different life cycles. In the starter kit application,
    it manages the search bar. But it can also manage the log in and log out functionality,
    for example. The shell module is what configures all routes.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: shell模块处理应用程序的全局上下文。它管理沿不同生命周期持续存在的组件。在入门套件应用程序中，它管理搜索栏。但是它也可以管理登录和注销功能，例如。shell模块是配置所有路由的地方。
- en: Finally, the router configures the navigation along all the pages the application
    has.![Durandal life cycle](img/7074OS_07_04.jpg)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，路由器配置沿着应用程序拥有的所有页面的导航。![Durandal生命周期](img/7074OS_07_04.jpg)
- en: Durandal initialization life cycle
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Durandal初始化生命周期
- en: The activation life cycle
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 激活生命周期
- en: 'The **activation** **life cycle** controls the activation and the deactivation
    of the page. Durandal allows us to use predefined methods to access different
    parts of the cycle. Let''s take a look at the Durandal methods:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**激活生命周期**控制页面的激活和停用。Durandal允许我们使用预定义的方法访问周期的不同部分。让我们看一下Durandal方法：'
- en: '`canDeactivate`: This should return true, false, or as a redirect object. It
    is fired when you try to abandon a page. If the result of the method is true,
    you will be able to leave the page. If it is false, the routing process will be
    interrupted. If you return a redirect object, you will be redirected.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canDeactivate`: 当您尝试放弃页面时，应返回true、false或重定向对象。如果方法的结果为true，则可以离开页面。如果是false，则路由过程将被中断。如果返回重定向对象，则会重定向。'
- en: '`canActivate`: When you arrive at a new page, you can evaluate if you are able
    to see this page. For example, you can check if you are logged in to your if you
    have enough admin rights to see the page. If you return `canActivate` true, you
    will be able to see the page. If it returns false, the routing process will be
    interrupted. You can also redirect the user to another page.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canActivate`: 当您到达新页面时，可以评估是否能够查看此页面。例如，您可以检查是否已登录到您的页面，或者是否具有足够的管理员权限来查看页面。如果返回`canActivate`
    true，则可以查看该页面。如果返回false，则路由过程将被中断。您还可以将用户重定向到另一个页面。'
- en: '`deactivate`: If `canDeactivate` returns true and you can activate the next
    view, the `deactivate` method is fired. Here is a good place to clear timeouts
    and events, if necessary.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deactivate`: 如果`canDeactivate`返回true并且您可以激活下一个视图，则会触发`deactivate`方法。在这里，如果需要的话，清除超时和事件是一个很好的地方。'
- en: '`activate`: If `canActivate` returns true and you can deactivate the last view,
    the `activate` method is fired. Here is the place where you should load all your
    data, bind your elements, and initialize events.![The activation life cycle](img/7074OS_07_05.jpg)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activate`: 如果`canActivate`返回true并且您可以停用上一个视图，则会触发`activate`方法。这是您应该加载所有数据、绑定您的元素并初始化事件的地方。![激活生命周期](img/7074OS_07_05.jpg)'
- en: Activation life cycle
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 激活生命周期
- en: 'There are other methods we can use in our life cycle:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法可以在我们的生命周期中使用：
- en: '`getView`: With this you can build an observable to define the path of the
    view that the view-model has bound.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getView`: 使用此方法，您可以构建一个observable来定义视图模型绑定的视图路径。'
- en: '`viewUrl`: This returns a string that represents the path of the view attached
    to the view-model. The difference between `viewUrl` and `getView` is that the
    former is a string and the latter is an observable.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viewUrl`: 这返回一个表示附加到视图模型的视图路径的字符串。`viewUrl`和`getView`之间的区别在于前者是一个字符串，而后者是一个observable。'
- en: '`binding`: This is called before the binding between view and view-model begins.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binding`: 在视图和视图模型之间的绑定开始之前调用此方法。'
- en: '`bindingComplete`: This is called immediately after the binding is completed.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bindingComplete`: 在绑定完成后立即调用。'
- en: '`attached`: This is called when the composition engine attaches the view to
    the DOM. You can use this hook to manipulate elements using jQuery selectors.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attached`: 当组合引擎将视图附加到DOM时调用。您可以使用此钩子使用jQuery选择器来操作元素。'
- en: '`compositionComplete`: This is the last hook fired by the composition engine.
    Here you can measure DOM elements.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compositionComplete`: 这是组合引擎触发的最后一个钩子。在这里，您可以测量DOM元素。'
- en: '`detached`: This hook is fired when the view is detached from the DOM. We can
    perform clean up work here.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detached`: 当视图从DOM中分离时，将触发此钩子。我们可以在这里执行清理工作。'
- en: You can read more about the composition life cycle at [http://durandaljs.com/documentation/Interacting-with-the-DOM.html](http://durandaljs.com/documentation/Interacting-with-the-DOM.html).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://durandaljs.com/documentation/Interacting-with-the-DOM.html](http://durandaljs.com/documentation/Interacting-with-the-DOM.html)了解更多关于组合生命周期的信息。
- en: The promise pattern
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Promise模式
- en: Durandal uses promises to manage asynchronous behaviors. A clear example is
    the `app.start()` method which is in the `main.js` file.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Durandal使用promises来管理异步行为。一个明显的例子是`app.start()`方法，它在`main.js`文件中。
- en: A promise is an object that contains a value that can be used in the future,
    when the prerequisites to obtain this value are accomplished. In this case, the
    `then` method will not be fired until the result `app.start()` method is obtained.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Promise是一个包含在未来可以使用的值的对象，当获得此值的先决条件时可以使用。在这种情况下，直到获得`app.start()`方法的结果之后，`then`方法才不会被触发。
- en: 'Internally, Durandal uses jQuery''s promise implementation in order to minimize
    third-party dependencies. However, other libraries you use may require Q, or you
    may need more advanced asynchronous programming capabilities than jQuery can provide.
    In these cases, you will want to plug Q''s promise mechanism into Durandal so
    that you can have a single consistent promise implementation throughout. To integrate
    the Q library, follow these steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Durandal 使用 jQuery 的 promise 实现以最小化第三方依赖关系。然而，你使用的其他库可能需要 Q，或者你可能需要比 jQuery
    提供的更高级的异步编程能力。在这些情况下，你将希望将 Q 的 promise 机制插入到 Durandal 中，以便你可以在整个过程中拥有一个统一的 promise
    实现。要集成 Q 库，请按照以下步骤操作：
- en: Add the `Q` library to the RequireJS config.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Q` 库添加到 RequireJS 配置中。
- en: 'Add this code in the `main.js` file, just before the `app.start()` instruction:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此代码添加到 `main.js` 文件中，在 `app.start()` 指令之前：
- en: '[PRE14]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you are using the HTTP Durandal plugin, this approach will not be enough
    if you want to use Q promises. You need to wrap the jQuery promise into a Q promise,
    as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 HTTP Durandal 插件，则如果你想使用 Q promises，这种方法将不够。你需要将 jQuery promise 包装成
    Q promise，如下所示：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can read more about the Q library at [http://durandaljs.com/documentation/Q.html](http://durandaljs.com/documentation/Q.html).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [http://durandaljs.com/documentation/Q.html](http://durandaljs.com/documentation/Q.html)
    阅读更多关于 Q 库的信息。
- en: 'This is the basic interface of jQuery promises that we have available in Durandal:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在 Durandal 中可用的基本 jQuery promise 接口：
- en: '`done(successFn)`: This will be fired if the promise is resolved successfully.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`done(successFn)`: 如果 promise 成功解析，则将触发此事件。'
- en: '`fail(failFn)`: This will be fired if the promise is rejected.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fail(failFn)`: 如果 promise 被拒绝，则将触发此事件。'
- en: '`always()`: This will be fired in both cases, success and failure.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`always()`: 这将在成功和失败两种情况下触发。'
- en: '`then(succesFn,failFn)`: This is an alias to join `done` and `fail` methods.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`then(succesFn,failFn)`: 这是 `done` 和 `fail` 方法的别名。'
- en: '`when(valueOrFunction)`: This will create a promise with the value or function
    passed as a parameter.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`when(valueOrFunction)`: 这将使用传递的值或函数创建一个 promise。'
- en: To know more about jQuery promises refer to the official documentation at [http://api.jquery.com/promise/](http://api.jquery.com/promise/).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 jQuery promises 的信息，请参考官方文档 [http://api.jquery.com/promise/](http://api.jquery.com/promise/)。
- en: Compositions
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合
- en: '**Composition** is the most powerful part of Durandal. While modules help to
    split the application into small parts, compositions allows us to join them all
    again. There are two types of composition, object composition and visual composition.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合** 是 Durandal 中最强大的部分。虽然模块帮助将应用程序分解为小部分，但组合允许我们将它们全部再次连接起来。组合有两种类型，对象组合和视觉组合。'
- en: To apply visual composition, you need to use the compose binding. You can combine
    KnockoutJS observables with the compose binding to achieve dynamic compositions.
    Compose binding gives you a complete configuration interface to enhance the flexibility
    and reusability of your components.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用视觉组合，你需要使用 compose 绑定。你可以将 KnockoutJS observables 与 compose 绑定结合使用以实现动态组合。Compose
    绑定提供了一个完整的配置界面，以增强组件的灵活性和可重用性。
- en: Object composition
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象组合
- en: 'You can achieve **object composition** by using just RequireJS and the AMD
    pattern. The simplest case is that you have two modules: A and B. The B module
    requires the functionality of A, so you request module A in module B using RequireJS,
    as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过仅使用 RequireJS 和 AMD 模式来实现**对象组合**。最简单的情况是你有两个模块：A 和 B。B 模块需要 A 的功能，所以你在模块
    B 中使用 RequireJS 请求模块 A，如下所示：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Visual composition
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视觉组合
- en: '**Visual composition** allows you to break down your view into small pieces
    and reconnect (or compose) them, making them reusable. This is a central and unique
    function in Durandal and is managed by the Composition module. The most common
    manner of composing views is using the compose binding handler.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**视觉组合** 允许你将视图分解成小块并重新连接（或组合）它们，使它们可重用。这是 Durandal 中的一个核心和独特功能，并由 Composition
    模块管理。组合视图的最常见方式是使用 compose 绑定处理程序。'
- en: 'Let''s take a look at how the shell view is composed:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 shell 视图是如何组合的：
- en: RequireJS is used to find the shell module. By convention, it knows that it
    is in the `shell.js` file.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 RequireJS 来查找 shell 模块。按照惯例，它知道它在 `shell.js` 文件中。
- en: 'The view locator locates the appropriate view for shell: `shell.html`.'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图定位器会为 shell 定位适当的视图：`shell.html`。
- en: The view engine creates a view from the markup in `shell.html`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图引擎从 `shell.html` 中的标记创建视图。
- en: The shell module and the shell view are data-bound together using KnockoutJS.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 KnockoutJS 将 shell 模块和 shell 视图进行数据绑定。
- en: The bound shell view is inserted into the `applicationHost` div.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将绑定外壳视图插入`applicationHost` div中。
- en: The "entrance" transition is used to animate the view.![Visual composition](img/7074OS_07_06.jpg)
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “入口”过渡用于动画显示视图。![可视化组合](img/7074OS_07_06.jpg)
- en: Composition life cycle
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 组合生命周期
- en: 'Now take a look how you can do some visual composition. You can move the navigation
    to its own view and compose the shell using the navigation view, by following
    these steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看一下如何进行一些可视化组合。您可以将导航移动到其自己的视图，并使用导航视图组合外壳，按照以下步骤操作：
- en: Open `shell.html` file.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`shell.html`文件。
- en: Cut the `<nav></nav>` element.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剪切`<nav></nav>`元素。
- en: Paste it in a new file called `navigation.html`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其粘贴到名为`navigation.html`的新文件中。
- en: 'Add a `<div>` in the `shell.html` file and bind the compose element, as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`shell.html`文件中添加一个`<div>`并绑定组合元素，如下所示：
- en: '[PRE17]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can also create a view-model called `navigation.js` linked to the view:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建一个名为`navigation.js`的视图模型，链接到视图：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You also have the option to convert the `compose` variable into an observable
    that will be generated in the view-model:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以选择将`compose`变量转换为在视图模型中生成的可观察变量：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is a brief run-down about how the compose binding works:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有关组合绑定工作原理的简要介绍：
- en: 'If it''s a string value:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是字符串值：
- en: If it has a view extension, locate the view and inject it into the DOM, binding
    against the current context.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它具有视图扩展名，则定位视图并将其注入到DOM中，并根据当前上下文进行绑定。
- en: If it is a module ID, locate the module, locate its view, and bind and inject
    them into the DOM.
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是模块ID，则定位模块，定位其视图，并将它们绑定并注入到DOM中。
- en: If it's an object, locate its view and bind and inject them into the DOM.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是一个对象，则定位其视图并将其绑定并注入到DOM中。
- en: If it's a function, call the function with the new modifier, get its return
    value, find the view for the return value, and bind and inject them into the DOM.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是一个函数，则使用新修饰符调用该函数，获取其返回值，找到该返回值的视图，并将它们绑定并注入到DOM中。
- en: 'If you want to customize the composition, you can pass the view and the model
    data directly to the composer binding, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要自定义组合，可以直接将视图和模型数据传递给组合器绑定，如下所示：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This allows you to combine different views with the same data, setting model
    or view as observables.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许您将具有相同数据的不同视图组合为可观察的模型或视图。
- en: 'You can also compose views with Knockout comments:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用Knockout注释组合视图：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can increase the setting values of the compose binding:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以增加组合绑定的设置值：
- en: '`transition`: You can indicate a transition when the composition changes.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transition`：您可以在组合更改时指示过渡。'
- en: '`cacheviews`: This will not remove views from the DOM.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cacheviews`：这不会从DOM中移除视图。'
- en: '`activate`: This defines the activate function for this composition.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activate`：这为此组合定义了激活函数。'
- en: '`perserveContext`: If you set this to `false` you will detach the parent context.
    This is useful when there is no model associated with the view. It improves performance.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`perserveContext`：如果将其设置为`false`，则会分离父上下文。当视图没有关联的模型时，这很有用。它提高了性能。'
- en: '`activationData`: This refers to the data attached to the `activate` function.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activationData`：这是指附加到`activate`函数的数据。'
- en: '`mode`: This could be `inline` or `templated`. Inline is the mode by default.
    The `templated` mode is used with the `data-part` attribute and is often used
    with widgets.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mode`：这可以是`inline`或`templated`。默认情况下，内联是模式。`templated`模式与`data-part`属性一起使用，通常与小部件一起使用。'
- en: '`onError`: You can bind an error handler function to fail gracefully when a
    composition fails as shown in the following code:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError`：您可以绑定一个错误处理程序函数，以在组合失败时优雅地失败，如下面的代码所示：'
- en: '[PRE22]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can find a complete explanation of composition in the Durandal documentation
    at [http://durandaljs.com/documentation/Using-Composition.html](http://durandaljs.com/documentation/Using-Composition.html).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Durandal文档中找到有关组合的完整说明，网址为[http://durandaljs.com/documentation/Using-Composition.html](http://durandaljs.com/documentation/Using-Composition.html)。
- en: Router
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器
- en: Durandal provides a router plugin to make navigation quick and easy. The router
    works in cooperation with the history plugin to handle the navigation state in
    the browser.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Durandal提供了一个路由器插件，使导航快速简便。路由器与历史插件配合工作，处理浏览器中的导航状态。
- en: 'To use the router plugin:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用路由器插件：
- en: 'Activate the plugin in the `main.js` file:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.js`文件中激活插件：
- en: '[PRE23]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Configure it in the `shell.js` file:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`shell.js`文件中进行配置：
- en: '[PRE24]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Following is an example of how the router of our shopping cart application
    could be:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们购物车应用程序的路由器示例：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Take a look at the `shell.js` file. The router is passed as an element of the
    view-model. This allows you to update your navigation based on what the current
    route is. Durandal provides a friendly interface to build a navigation menu from
    a `router` object. Map routes in the shell activate hook and then, using the router
    fluent API, build the navigation model.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`shell.js`文件。路由器作为视图模型的一个元素传递。这使您能够根据当前路由更新导航。Durandal提供了一个友好的界面来从`router`对象构建导航菜单。在shell激活挂钩中映射路由，然后使用路由器流畅API构建导航模型。
- en: Finally, return the `router.activate()` method which contains a promise from
    the shell activate hook. Returning a promise means that the composition engine
    will wait until the router is ready before displaying the shell.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，返回包含来自shell激活挂钩的承诺的`router.activate()`方法。返回一个承诺意味着组合引擎将等待路由器准备好后再显示shell。
- en: Let's look at route mapping in more detail. A route has different patterns.
    Minimally, you should provide a route and a `moduleId` value. When the URL hash
    changes, the router will detect that and use the route pattern to find the correct
    route. Then it will load the module with the `moduleId` value. The router will
    activate and compose the view.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下路由映射。路由有不同的模式。至少，您应该提供一个路由和一个`moduleId`值。当URL哈希更改时，路由器将检测到并使用路由模式找到正确的路由。然后，它将加载具有`moduleId`值的模块。路由器将激活并组合视图。
- en: 'There are some optional parameters:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些可选参数：
- en: '`nav`: When you call the `buildNavigationModel` method, it will create an observable
    array called `navigationModel` only with the routes that have this property set
    to `true`.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nav`：当您调用`buildNavigationModel`方法时，它将只使用此属性设置为`true`的路由创建一个名为`navigationModel`的可观察数组。'
- en: '`title`: This is used to set the document title.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：这用于设置文档标题。'
- en: '`hash`: With this, you can provide a custom hash to use for data-binding to
    an anchor tag. The router will generate a hash if none is provided.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hash`：使用此选项，您可以提供用于数据绑定到锚标记的自定义哈希。如果未提供哈希，则路由器将生成一个哈希。'
- en: 'There are four different types of routes:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种不同类型的路由：
- en: '**Default route** is set as an empty string:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认路由**设置为空字符串：'
- en: '[PRE26]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Static routes** have no parameters:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态路由**没有参数：'
- en: '[PRE27]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Parametrized routes** are routes with parameters:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数化路由**是带参数的路由：'
- en: 'A parameter is defined with a colon:'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用冒号定义参数：
- en: '[PRE28]'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Optional parameters are wrapped between parentheses:'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选参数在括号内：
- en: '[PRE29]'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Splat routes** are used to build child routes. We can define them using an
    asterisk:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Splat路由**用于构建子路由。我们可以使用星号来定义它们：'
- en: '[PRE30]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Unknown routes** are managed by the method: `mapUnknownRoutes(module,view)`:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未知路由**由方法管理：`mapUnknownRoutes(module,view)`：'
- en: '[PRE31]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you look in the `navigation.html` file you will be able to see how the router
    works.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看`navigation.html`文件，您将能够看到路由器的工作方式。
- en: 'Notice that the `foreach` binding against the `navigationModel` property router
    is built with the `buildNavigationModel` method. Each element of this array has
    an `isActive` flag, which is set to `true` when the route is active. Finally,
    there is a property called `isNavigating` that allows you to alert the user that
    navigation between pages is happening as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于`navigationModel`属性路由的`foreach`绑定是使用`buildNavigationModel`方法构建的。此数组的每个元素都有一个`isActive`标志，当路由处于活动状态时，该标志被设置为`true`。最后，有一个名为`isNavigating`的属性，允许您向用户发出导航页面之间正在进行的警告，如下所示：
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you go back to the `shell.html` page, you will see that you attach a router
    binding to the `page-host` element. This binding displays the active route inside
    `page-host` container. This is just another demonstration of the power of Durandal
    composition.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回到`shell.html`页面，你会看到你将路由器绑定到`page-host`元素。此绑定在`page-host`容器中显示活动路由。这只是Durandal组合功能的另一个演示。
- en: Route parameters
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由参数
- en: Route parameters are set in the route using a colon. These parameters can be
    passed to the `canActivate` and `activate` methods of each module. If the route
    has a query string, it is passed as the last argument.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 路由参数在路由中使用冒号设置。这些参数可以传递给每个模块的`canActivate`和`activate`方法。如果路由有查询字符串，则作为最后一个参数传递。
- en: Triggering navigation
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触发导航
- en: 'There are some ways to trigger navigation that have been enlisted here:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了一些触发导航的方式：
- en: 'Use an anchor tag:'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用锚标记：
- en: '[PRE33]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Use the `router.navigate(hash)` method. This will trigger navigation to the
    associated module.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`router.navigate(hash)`方法。这将触发导航到关联的模块。
- en: '[PRE34]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you want to add a new history entry but not invoke the module, just set
    the second parameter to `false`:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想要添加一个新的历史记录条目但不调用模块，只需将第二个参数设置为`false`：
- en: '[PRE35]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you just want to replace the history entry, pass a JSON object with the
    `replace` value `true` and `trigger` value `false`:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您只想替换历史记录条目，请传递一个带有`replace`值`true`和`trigger`值`false`的JSON对象：
- en: '[PRE36]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Child routers
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子路由器
- en: In big applications, you must be able to handle maybe tens or hundreds of routes.
    Your application can just have one main router, but there is the possibility of
    it having multiple child routers. This provides Durandal a way to handle deep-linking
    scenarios and encapsulate routes by feature.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型应用程序中，您必须能够处理数十个甚至数百个路由。您的应用程序可能只有一个主路由器，但也可能有多个子路由器。这为Durandal提供了处理深度链接场景并根据功能封装路由的方法。
- en: 'Typically, the parent will map a route with a splat (*). The child router will
    work relative to that route. Let''s look at an example:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，父级将使用星号(*)映射一个路由。子路由器将相对于该路由工作。让我们看一个例子：
- en: Require the application router.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要应用程序路由器。
- en: Call the `createChildRouter()`. This will create a new router.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`createChildRouter()`。这将创建一个新的路由器。
- en: Use the `makeRelative` API. Configure the base `moduleId` and the `fromParent`
    property. This property makes the routes relative to the parent's routes.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`makeRelative` API。配置基本的`moduleId`和`fromParent`属性。该属性使路由相对于父级的路由。
- en: 'This is how it works:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作原理：
- en: '[PRE37]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: First, it catches the `product/:id*`action pattern. This will cause navigation
    to `product.js`. The application router will detect the presence of the child
    router and it delegate control to the child.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它捕获`product/:id*`动作模式。这将导致导航到`product.js`。应用程序路由器将检测到子路由的存在，并将控制委托给子路由。
- en: When a child router works with parameters, activate the `dynamicHash` property
    inside the `makeRelative` method.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当子路由与参数一起使用时，在`makeRelative`方法中激活`dynamicHash`属性。
- en: Events
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: '**Events** are used to communicate between modules. The event API is integrated
    into the `app` module and is very simple:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件**用于模块间通信。事件API集成到`app`模块中，非常简单：'
- en: '**on**: To subscribe the view-model to an event'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**on**：订阅视图模型的事件'
- en: '[PRE38]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**off**: To unsubscribe the view-model from an event'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**off**：取消订阅视图模型的事件'
- en: '[PRE39]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**trigger**: To trigger an event'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发器**：触发事件'
- en: '[PRE40]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can pass all event names to listen to all type of events:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将所有事件名称传递给监听所有类型的事件：
- en: '[PRE41]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Read more about events at [http://durandaljs.com/documentation/Leveraging-Publish-Subscribe.html](http://durandaljs.com/documentation/Leveraging-Publish-Subscribe.html).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在[http://durandaljs.com/documentation/Leveraging-Publish-Subscribe.html](http://durandaljs.com/documentation/Leveraging-Publish-Subscribe.html)阅读更多关于事件的内容。
- en: Widgets
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小部件
- en: '**Widgets** are another important part in the composition of Durandal. They
    are like view-models, with one exception. View-models can be singletons, and we
    usually prefer that they be singletons because they represent a unique page on
    the site. On the other hand, widgets are mainly coded with a constructor, so they
    can be instantiated as many times as we need. Therefore, when we build a widget
    we don''t return an object as it occurs in view-models. Instead, we return a constructor
    and Durandal instantiates the widget.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**小部件**是Durandal组成中的另一个重要部分。它们就像视图模型，只有一个例外。视图模型可以是单例的，我们通常更喜欢它们是单例的，因为它们代表站点上的唯一页面。另一方面，小部件主要是用构造函数编写的，因此它们可以根据需要实例化多次。因此，当我们构建小部件时，我们不返回对象，就像视图模型中发生的那样。相反，我们返回一个构造函数，Durandal实例化小部件。'
- en: Save widgets in `app/widgets/{widget_name}`. The widget should have a `viewmodel.js`
    file and a `view.html` file.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 将小部件保存在`app/widgets/{widget_name}`中。小部件应该有一个`viewmodel.js`文件和一个`view.html`文件。
- en: We are going to develop a widget called `accordion` to demonstrate how widgets
    work. This widget will be based in the jQuery collapse plugin that comes with
    Bootstrap.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个名为`accordion`的小部件来演示小部件的工作原理。此小部件将基于Bootstrap提供的jQuery折叠插件。
- en: Setting up widgets
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置小部件
- en: 'Follow these steps to create a plugin:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '按照以下步骤创建一个插件： '
- en: 'Add the `bootstrap` library to the project. To achieve this, add it to the
    dependencies of the main module:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`bootstrap`库添加到项目中。要实现这一点，请将其添加到主模块的依赖项中：
- en: '[PRE42]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Install the plugin. Register the widget plugin in the `main.js` file:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装插件。在`main.js`文件中注册小部件插件：
- en: '[PRE43]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Create a directory called widget inside the `app` folder.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app`文件夹中创建一个名为widget的目录。
- en: Add a subdirectory named `accordion`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`accordion`的子目录。
- en: Add a file named `viewmodel.js` inside the `accordion` directory.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`accordion`目录下添加一个名为`viewmodel.js`的文件。
- en: Add a file named `view.html` inside the `accordion` directory.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`accordion`目录中添加一个名为`view.html`的文件。
- en: If you don't like Durandal's conventions, you can read more about widget configuration
    at [http://durandaljs.com/documentation/api#module/widget](http://durandaljs.com/documentation/api#module/widget).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢Durandal的约定，可以在[http://durandaljs.com/documentation/api#module/widget](http://durandaljs.com/documentation/api#module/widget)上阅读有关小部件配置的更多信息。
- en: Writing the widget view
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写小部件视图
- en: 'To write the view, follow these steps:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 编写视图，请按照以下步骤进行：
- en: Open the `app/widgets/expander/view.html` file.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app/widgets/expander/view.html`文件。
- en: 'Write this code following the bootstrap3 collapse template ([http://getbootstrap.com/javascript/#collapse](http://getbootstrap.com/javascript/#collapse)):'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写此代码，按照bootstrap3折叠模板（[http://getbootstrap.com/javascript/#collapse](http://getbootstrap.com/javascript/#collapse)）：
- en: '[PRE44]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: By writing the view first you can identify which variables you need to create
    in the view-model to complete the view. In this case, you will need an array of
    items that stores accordion elements. It will contain an ID for each collapsible
    element that will auto-generate inside the widget, the header text and the body.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 通过先编写视图，你可以确定需要在视图模型中创建哪些变量才能完成视图。在这种情况下，你将需要一个存储手风琴元素的项目数组。它将包含每个可折叠元素的ID，在小部件内自动生成，标题文本和正文。
- en: Writing the widget view-model
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写小部件视图模型
- en: 'To write the widget view-model, open the `viewmode.js` file in the `accordion`
    widget folder and write this code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写小部件视图模型，请打开`accordion`小部件文件夹中的`viewmode.js`文件，并编写以下代码：
- en: '[PRE45]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, you return a constructor for the widget, not a view-model itself
    as you do with pages.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，你返回了一个小部件的构造函数，而不是像页面一样返回一个视图模型本身。
- en: In this case, to manage the life cycle you just need to define the `activate`
    method to assign values and generate IDs. Remember that if you want to add some
    DOM modification with code, the attached method would be a good place to do so.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，要管理生命周期，你只需定义`activate`方法来分配值和生成ID。请记住，如果你想用代码添加一些DOM修改，那么附加方法将是一个不错的地方。
- en: Registering the widget
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册小部件
- en: 'To register the widget, you just need to register it in the main module (`main.js`):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册小部件，只需在主模块（`main.js`）中注册即可：
- en: '[PRE46]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Building a page with Durandal
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Durandal构建页面
- en: Now that you have learned all the basics of the Durandal framework, let's create
    a new page that will contain our widget and some basic data.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了Durandal框架的所有基础知识，让我们创建一个包含我们的小部件和一些基本数据的新页面。
- en: 'To define a new page in Durandal, always follow the same steps:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Durandal中定义新页面，始终按照相同步骤进行：
- en: 'Define the route in the shell view-model:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在shell视图模型中定义路由：
- en: '[PRE47]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Define the `views/accordion.html` file. Notice that inside the accordion binding
    you can define the `data-part` templates. Here, you are using the power of composition
    that Durandal gives you. By adding an `add` button, you are giving the widget
    the possibility of adding new elements.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`views/accordion.html`文件。注意，在手风琴绑定内部，你可以定义`data-part`模板。在这里，你正在使用Durandal提供的组合能力。通过添加一个`add`按钮，你为小部件提供了添加新元素的可能性。
- en: '[PRE48]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Define the `viewmodels/accordion.js` file. You have set `projects` as an observable
    array and initialized it in the `activate` method. The view-model is provided
    with an `add` function that triggers an event called `accordion:add`. This sends
    a message with the new tab values. The widget should listen to this event and
    create an action.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`viewmodels/accordion.js`文件。你已经将`projects`设置为可观察数组，并在`activate`方法中进行了初始化。视图模型提供了一个`add`函数，触发名为`accordion:add`的事件。这会发送带有新标签值的消息。小部件应监听此事件并执行操作。
- en: '[PRE49]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Define the event in the `widgets/accordion/viewmodel.js` file, updating the
    `activate` method:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`widgets/accordion/viewmodel.js`文件中定义事件，更新`activate`方法：
- en: '[PRE50]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Define the detached life cycle method to turn off `add event` once the widget
    is not on the screen:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义分离的生命周期方法，以便在小部件不在屏幕上时关闭`add event`：
- en: '[PRE51]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Launch the application and test the widget.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序并测试小部件。
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, you were introduced to Durandal. Using a framework that has
    all the pieces perfectly connected, instead of a bunch of libraries, helps you
    to avoid rewriting the same code again and again. It means that thanks to Durandal,
    you can follow one of the basic principles of developers (Don't Repeat Yourself
    – DRY) easily.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经了解了Durandal。使用一个所有部件都完美连接的框架，而不是一堆库，可以帮助你避免一遍又一遍地重写相同的代码。这意味着，多亏了Durandal，你可以轻松地遵循开发者的基本原则之一（不要重复自己
    - DRY）。
- en: You learned useful concepts, such as how to install and bring up a Durandal
    project. You also learned about how the life cycle of a Durandal application works.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你学到了一些有用的概念，比如如何安装和启动 Durandal 项目。你还了解了 Durandal 应用程序的生命周期是如何工作的。
- en: One of the most powerful features of Durandal is the composition. You can compose
    interfaces very easy and it is almost transparent for the developer.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Durandal 最强大的功能之一是组合。你可以非常轻松地组合界面，对开发者几乎是透明的。
- en: You learned how Durandal manages promises. By default, it uses jQuery promises
    but you saw that it is very easy to use other libraries like Q.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解了 Durandal 如何管理承诺。默认情况下，它使用 jQuery 的承诺，但你发现很容易使用其他库，比如 Q。
- en: Finally, you developed a widget and integrated it into a view-model. While view-models
    are singletons, widgets are elements that you can instantiate several times. They
    are a powerful part of the Durandal composition.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你开发了一个小部件，并将其集成到视图模型中。虽然视图模型是单例的，但小部件是可以多次实例化的元素。它们是 Durandal 组合的一个强大部分。
- en: In the next chapter, we will migrate step by step from our KnockoutJS cart into
    a Durandal Single Page Application.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将逐步将我们的 KnockoutJS 购物车迁移到 Durandal 单页面应用程序。
