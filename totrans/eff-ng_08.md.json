["```js\nexport class Counter {\n  count = signal(0);\n  add() { this.count.update((count) => count + 1) }\n  subtract() { this.count.update((count) => count - 1) }\n}\n```", "```js\n@Injectable({ providedIn: 'root' })\nexport class ExpensesStore {}\n```", "```js\nprivate expenses = new BehaviorSubject<ExpenseModel[]>([]);\nexpenses$ = this.expenses.asObservable();\n```", "```js\nprotected expensesApi = inject(ExpensesHttpService);\n```", "```js\nfetchExpenses(): void {\n  this.expensesApi.get().subscribe({\n    next: (expenses) => { this.expenses.next(expenses) },\n    error: (err) => { console.log(‹err ==>›, err) }\n  });\n}\n```", "```js\nprivate get currentExpenses() {return this.expenses.value}\n```", "```js\naddExpense(expense: ExpenseModel): void {\n  this.expensesApi.post(expense).subscribe({\n    next: (addedExpense) => {\n      addedExpense.id = !addedExpense.id ? this.currentExpenses.length + 1 : addedExpense.id;\n      this.expenses.next([...this.currentExpenses, addedExpense]);\n    },\n    error: (err) => { console.log(‹err ==>›, err) }\n  })\n}\n```", "```js\ndeleteExpense(id: number): void {\n  this.expensesApi.delete(id).subscribe({\n    next: () => {\n      this.expenses.next(this.currentExpenses.filter(expense => expense.id !== id));\n    },\n    error: (err) => { console.log(‹err ==>›, err) }\n  })\n}\n```", "```js\nprivate expense: Subject<ExpenseModel> = new Subject();\nexpense$: Observable<ExpenseModel> = this.expense.asObservable();\nprivate selectedExpense: BehaviorSubject<ExpenseModel | null> = new BehaviorSubject<ExpenseModel | null>(null);\nselectedExpense$ = this.selectedExpense.asObservable();\n```", "```js\nprivate fetchExpenseById(id: number, select = false) {\n  this.expensesApi.getById(id).subscribe({\n    next: (expense) => { select ? this.selectedExpense.next(expense) : this.expense.next(expense) },\n    error: (err) => { console.log(‹err ==>›, err) }\n  })\n}\n```", "```js\ngetExpense(id: number): void {\n  const expense = this.currentExpenses.find(expense => expense.id === id);\n  expense ? this.expense.next(expense) : this.fetchExpenseById(id);\n}\nselectExpense(id: number): void {\n  const expense = this.currentExpenses.find(expense => expense.id === id);\n  expense ? this.selectedExpense.next(expense) : this.fetchExpenseById(id, true);\n}\n```", "```js\nupdateExpense(expense: ExpenseModel): void {\n  this.expensesApi.put(expense).subscribe({\n    next: (expense) => {\n      this.expenses.next(this.currentExpenses.map(exp => exp.id === expense.id ? expense : exp));\n    },\n    error: (err) => { console.log(‹err ==>›, err) }})\n}\n```", "```js\nprivate inclVat = new BehaviorSubject<boolean>(false);\ninclVat$ = this.inclVat.asObservable();\nadjustVat(): void {\n  this.inclVat.next(!this.inclVat.value);\n}\n```", "```js\nclearExpenseSelection(): void {\n  this.selectedExpense.next(null);\n}\nresetState(): void {\n  this.expenses.next([]);\n  this.selectedExpense.next(null);\n  this.inclVat.next(false);\n}\n```", "```js\n@Injectable({ providedIn: 'root' })\nexport class ExpensesFacade {}\n```", "```js\nexport interface IExpensesFacade {\n  expenseSelector$: Observable<ExpenseModel>;\n  selectedExpenseSelector$: Observable<ExpenseModel>;\n  inclVatSelector$: Observable<boolean>;\n  addExpense(expense: ExpenseModel): void;\n  adjustVat(): void;\n  clearExpenseSelection(): void;\n  deleteExpense(id: number): void;\n  fetchExpenses(): void;\n  getExpense(id: number): void;\n  getExpenses(id: number): Observable<ExpensesViewModel>;\n  resetExpenseState(): void;\n  selectExpense(id: number): void;\n  updateExpense(expense: ExpenseModel): void;\n}\n```", "```js\nexport class ExpensesFacade implements IExpensesFacade {…}\n```", "```js\nprotected readonly expensesStore = inject(ExpensesStore);\n```", "```js\nfetchExpenses() {\n  this.expensesStore.fetchExpenses();\n}\n```", "```js\nexport interface ExpensesViewModel {\n  total: number;\n  inclVat: boolean;\n  expenses: ExpenseModel[];\n}\n```", "```js\ngetExpenses(): Observable<ExpensesViewModel> {\n  return combineLatest([this.expensesStore.expenses$, this.expensesStore.inclVat$]).pipe(\n    distinctUntilChanged(),\n    map(([expenses, inclVat]) => ({\n      expenses: structuredClone(expenses).map(expense => {\n        expense.amount.value = inclVat ? expense.amount.value * (1 + expense.amount.vatPercentage / 100) : expense.amount.value;\n        return expense;\n      }),\n      inclVat,\n      total: expenses.reduce((acc, expense) => {\n        return acc + (inclVat ? (expense.amount.value * (1 + expense.amount.vatPercentage / 100)) : expense.amount.value);\n      }, 0),\n    }))\n  );\n}\n```", "```js\nprotected readonly expensesFacade = inject(ExpensesFacade);\n```", "```js\nngOnInit() { this.expensesFacade.fetchExpenses() }\n```", "```js\nexpenses = this.expensesFacade.getExpenses();\n```", "```js\n@if(expenses | async; as expensesVm) {……} @else {Loading… }\n```", "```js\n@for (expense of expensesVm.expenses; track expense.id){…}\n```", "```js\n<td>{{ expense.amount.value.toFixed(2) | currency }}</td>\n<td>{{ expense.amount.vatPercentage }}%</td>\n```", "```js\n<td>Total: {{expensesVm.total}}</td>\n```", "```js\nadjustVat() { this.expensesStore.adjustVat() }\n```", "```js\ninclVatSelector$ = this.expensesStore.inclVat$;\n```", "```js\n<div class=\"vatToggle\">\n  <span>Incl. VAT:</span>\n  <label class=»switch»>\n    <input (click)=»expensesFacade.adjustVat()\" type=\"checkbox\"\n      [checked]=»expensesFacade.inclVatSelector$ | async\">\n    <span class=»slider round»></span>\n  </label>\n</div>\n```", "```js\nprivate mapExpense(expense: ExpenseModel, inclVat: boolean) {\n  const expenseClone = structuredClone(expense) as ExpenseModel;\n  expenseClone.amount.value = inclVat ? expenseClone.amount.value * (1 + expenseClone.amount.vatPercentage / 100) : expenseClone.amount.value;\n  return expenseClone;\n}\n```", "```js\nexpenses: expenses.map(expense => this.mapExpense(expense, inclVat)),\n```", "```js\nexpenseSelector$ = this.expensesStore.expense$.pipe(withLatestFrom(this.expensesStore.inclVat$), map(([expense, inclVat]) => this.mapExpense(expense, inclVat)));\n```", "```js\nselectedExpenseSelector$ = combineLatest([this.expensesStore.selectedExpense$, this.expensesStore.inclVat$]).pipe(filter(([expense]) => !!expense), map(([expense, inclVat]) => this.mapExpense(expense as ExpenseModel, inclVat)));\n```", "```js\nprivate expensesState = signal<ExpenseModel[]>([]);\nexpenses = this.expensesState as Signal<ExpenseModel[]>;\n```", "```js\nthis.expenses()\n```", "```js\n!this.inclVat()\n```", "```js\nresetState(): void {\n  this.expensesState.set([]);\n  this.selectedExpenseState.set(null);\n  this.inclVatState.set(false);\n}\n```", "```js\nselectedExpense: Signal<ExpenseModel | null>;\ninclVat: Signal<boolean>;\nexpenses: Signal<ExpensesViewModel>\n```", "```js\nexpenses = computed<ExpensesViewModel>(() => {\n  const inclVat = this.expensesStore.inclVat();\n  return {\n    expenses: this.expensesStore.expenses().map(expense => this.mapExpense(expense, inclVat)),\n    inclVat,\n    total: this.expensesStore.expenses().reduce((acc, expense) => {\n      return acc + (inclVat ? (expense.amount.value * (1 + expense.amount.vatPercentage / 100)) : expense.amount.value);\n    }, 0),\n  }\n});\n```", "```js\ninclVat = this.expensesStore.inclVat;\nselectedExpense = this.expensesStore.selectedExpense;\n```", "```js\nexpenses = this. expensesFacade.expenses;\n```", "```js\n[checked]=\"expensesFacade.inclVat()\"\n@if(expenses(); as expensesVm) { …… }\n```", "```js\nnpm install @ngrx/store --save\nnpm i @ngrx/effects\n```", "```js\n[Unique State Name] Description of the action\n```", "```js\nexport const fetchExpenses = createAction(`[Expenses] Fetch Expenses`);\n```", "```js\nexport const fetchExpensesSuccess = createAction(`[Expenses] Fetch Expenses Success`, props<{ expenses: ExpenseModel[] }>());\nexport const fetchExpensesFailed = createAction(`[Expenses] Fetch Expenses Failed`);\n```", "```js\nexport * as ExpenseActions from './expenses.actions';\n```", "```js\n@Injectable({ providedIn: 'root' })\nexport class ExpensesEffects {}\n```", "```js\nprivate readonly actions = inject(Actions);\nprivate readonly expensesApi = inject(ExpensesHttpService);\n```", "```js\nfetchExpeses$ = createEffect(() =>\n  this.actions.pipe(\n    ofType(ExpenseActions.fetchExpenses.type),\n    switchMap(() => this.expensesApi.get().pipe(\n      map((expenses: ExpenseModel[]) => ExpenseActions.fetchExpensesSuccess({ expenses })),\n      catchError(() => of(ExpenseActions.fetchExpensesFailed()))\n    ))\n  )\n);\n```", "```js\nexport * from './expenses.effects';\n```", "```js\nexport interface ExpensesState {\n  expenses: ExpenseModel[];\n  selectedExpense: ExpenseModel | null;\n  isLoading: boolean;\n  inclVat: boolean;\n  error: string | null;\n}\n```", "```js\nexport const initialExpensesState: Readonly<ExpensesState> = {\n  expenses: [],\n  selectedExpense: null,\n  isLoading: false,\n  inclVat: false,\n  error: null\n};\n```", "```js\nexport const expensesReducer = createReducer<ExpensesState>(initialExpensesState);\n```", "```js\ncreateReducer<ExpensesState>(\n  initialExpensesState,\n  on(ExpenseActions.fetchExpenses, (state) => ({\n    ...state,\n    isLoading: true\n  }))\n)\n```", "```js\non(ExpenseActions.fetchExpensesSuccess, (state, { expenses }) => ({\n  ...state,\n  isLoading: false,\n  expenses,\n  error: null\n})),\non(ExpenseActions.fetchExpensesFailed, (state) => ({\n  ...state,\n  isLoading: false,\n  error: ‹Failed to fetch expenses!›\n})),\n```", "```js\nexport const expensesFeatureKey = 'expenses';\n```", "```js\nexport * from './expenses.reducer';\n```", "```js\nprovideStore(),\nprovideState({ name: expensesFeatureKey, reducer: expensesReducer }),\n```", "```js\nexport const selectExpensesState = createFeatureSelector<ExpensesState>(expensesFeatureKey);\n```", "```js\nexport const selectExpenses = createSelector(selectExpensesState, (state) => state.expenses);\nexport const selectError = createSelector(selectExpensesState, (state) => state.error);\nexport const selectIsLoading = createSelector(selectExpensesState, (state) => state.isLoading);\n```", "```js\nexport * as ExpenseSelectors from './expenses.selectors';\n```", "```js\nexport * from './lib/state/expenses/index';\n```", "```js\nprotected readonly store = inject(Store);\n```", "```js\nthis.store.dispatch(ExpenseActions.fetchExpenses());\n```", "```js\nexpensesSignal = toSignal(this.store.select(ExpenseSelectors.selectExpenses), { initialValue: [] });\n```", "```js\nexport const adjustVat = createAction(`[Expenses] Adjust incl vat`);\n```", "```js\non(ExpenseActions.adjustVat, (state) => ({\n  ...state,\n  inclVat: !state.inclVat\n})),\n```", "```js\nexport const selectInclVat = createSelector(selectExpensesState, (state) => state.inclVat);\n```", "```js\ninclVat = toSignal(this.store.select(ExpenseSelectors.selectInclVat), { initialValue: false });\n```", "```js\nthis.store.dispatch(ExpenseActions.adjustVat());\n```"]